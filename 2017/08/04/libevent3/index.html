<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="网络编程,Linux环境编程," />










<meta name="description" content="Events have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an event base, it becomes initialized. At this point, you can add, which makes it pending in">
<meta property="og:type" content="article">
<meta property="og:title" content="libevent学习文档(三)working with event">
<meta property="og:url" content="http://www.limerence2017.com/2017/08/04/libevent3/index.html">
<meta property="og:site_name" content="恋恋风辰的个人博客">
<meta property="og:description" content="Events have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an event base, it becomes initialized. At this point, you can add, which makes it pending in">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-08-04T10:23:33.000Z">
<meta property="article:modified_time" content="2022-07-31T07:11:50.041Z">
<meta property="article:author" content="恋恋风辰">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="Linux环境编程">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.limerence2017.com/2017/08/04/libevent3/"/>





  <title>libevent学习文档(三)working with event | 恋恋风辰的个人博客</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恋恋风辰的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2017/08/04/libevent3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">libevent学习文档(三)working with event</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T18:23:33+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netprogram/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>Events</code> have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an <code>event base</code>, it becomes initialized. At this point, you can add, which makes it pending in the base. When the event is pending, if the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomesactive, and its (user-provided) callback function is run. If the event is configured persistent, it remains pending. If it is not persistent, it stops being pending when its callback runs. You can make a pending event non-pending by deleting it, and you can add a non-pending event to make it pending again.</p>
<p>事件有相似的生命周期，一旦你调用libevent函数设置event和event_base关联后，event被初始化了。add这个事件会使它阻塞，当事件阻塞时，有触发事件的条件出现，事件会激活，回调函数会被调用。<code>如果事件被设置为永久，它保持阻塞</code>。<code>如果不是永久，当事件的回调函数调用的时候就不阻塞了</code>。可以通过删除一个事件使它由阻塞变为非阻塞。通过添加使它由非阻塞变为阻塞。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_TIMEOUT      0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_READ         0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_WRITE        0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SIGNAL       0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PERSIST      0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ET           0x20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> *<span class="built_in">event_new</span>(<span class="keyword">struct</span> event_base *base, <span class="type">evutil_socket_t</span> fd,</span><br><span class="line">    <span class="type">short</span> what, event_callback_fn cb,</span><br><span class="line">    <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_free</span><span class="params">(<span class="keyword">struct</span> event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过event_new创建事件，通过event_free释放。 参数base 表示event绑定在那个event_base上, fd表示event关联的描述符， what表示事件的类型，是一个bitfield, 上面那些宏按位或，cb是事件回调函数，事件就绪后可以触发。event_free释放event事件。</p>
<p>All new events are initialized and non-pending. To make an event pending, call event_add() (documented below).</p>
<p>To deallocate an event, call event_free(). It is safe to call event_free() on an event that is pending or active: doing so makes the event non-pending and inactive before deallocating it.</p>
<p>所有新创建的事件都是初始化的，并且非阻塞，调用event_add可以让一个事件变为阻塞。<br>调用event_free释放event，在事件阻塞或者激活状态下调用event_free是安全的，这个函数会在释放event之前将事件变为非阻塞并且非激活状态。</p>
<p><code>EV_TIMEOUT</code></p>
<p>This flag indicates an event that becomes active after a timeout elapses.</p>
<p><code>EV_READ</code></p>
<p>This flag indicates an event that becomes active when the provided file descriptor is ready for reading.</p>
<p><code>EV_WRITE</code></p>
<p>This flag indicates an event that becomes active when the provided file descriptor is ready for writing.</p>
<p><code>EV_SIGNAL</code></p>
<p>Used to implement signal detection. See “Constructing signal events” below.</p>
<p><code>EV_PERSIST</code></p>
<p>Indicates that the event is persistent. See “About Event Persistence” below.</p>
<p><code>EV_ET</code></p>
<p>Indicates that the event should be edge-triggered, if the underlying event_base backend supports edge-triggered events.</p>
<p><code>EV_TIMEOUT</code>：表示过一段事件后event变为active。</p>
<p><code>EV_READ</code>：当文件描述可读的时候变为就绪。</p>
<p><code>EV_WRITE</code>：当文件描述符可写的时候变为就绪。</p>
<p><code>EV_SIGNAL</code>：信号事件的标记</p>
<p><code>EV_PERSIST</code>：永久事件，下面会介绍。</p>
<p><code>EV_ET</code>：如果后端支持边缘触发事件，那么事件是边缘触发的。</p>
<p><code>About Event Persistence</code></p>
<p>By default, whenever a pending event becomes active (because its fd is ready to read or write, or because its timeout expires), it becomes non-pending right before its callback is executed. Thus, if you want to make the event pending again, you can call event_add() on it again from inside the callback function.</p>
<p>If the EV_PERSIST flag is set on an event, however, the event is persistent. This means that event remains pending even when its callback is activated. If you want to make it non-pending from within its callback, you can call event_del() on it.</p>
<p>The timeout on a persistent event resets whenever the event’s callback runs. Thus, if you have an event with flags EV_READ|EV_PERSIST and a timeout of five seconds, the event will become active:</p>
<p>Whenever the socket is ready for reading.</p>
<p>Whenever five seconds have passed since the event last became active.</p>
<p>默认情况下，当一个阻塞事件变为active时，(读事件可读，写事件可写，超时间到期等)，在事件对应的回调函数调用前该事件就会变为非阻塞的。因此，如果想要将事件变为阻塞，需要在事件的回调函数里调用event_add()</p>
<p>如果设置了EV_PERSIST 标记位， 那么事件就变味永久的，这意味着事件在回调函数触发时任然保持pending，如果你想要在回调函数调用后该事件变为非阻塞，需要调用event_del()。</p>
<p>当事件回调函数调用后超时会被重置，因此，如果事件带有EV_READ|EV_PERSIST标记，并且有5秒的超时值，如下情况事件会变为active：</p>
<p><code>1当socket可读时</code></p>
<p><code>2从上次变为active之后过了5秒后事件会变为active。</code></p>
<p>当事件的回调函数需要用到自己作为参数时候，需要将参数传递为</p>
<p>void *event_self_cbarg();</p>
<p>代码例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n_calls = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> *me = arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cb_func called %d times so far.\n&quot;</span>, ++n_calls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n_calls &gt; <span class="number">100</span>)</span><br><span class="line">       <span class="built_in">event_del</span>(me);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> one_sec = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line">    <span class="comment">/* We&#x27;re going to set up a repeating timer to get called called 100</span></span><br><span class="line"><span class="comment">       times. */</span></span><br><span class="line">    ev = <span class="built_in">event_new</span>(base, <span class="number">-1</span>, EV_PERSIST, cb_func, <span class="built_in">event_self_cbarg</span>());</span><br><span class="line">    <span class="built_in">event_add</span>(ev, &amp;one_sec);</span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For performance and other reasons, some people like to allocate events as a part of a larger structure. For each use of the event, this saves them:</p>
<p>The memory allocator overhead for allocating a small object on the heap.</p>
<p>The time overhead for dereferencing the pointer to the struct event.</p>
<p>The time overhead from a possible additional cache miss if the event is not already in the cache.</p>
<p>有时候开辟event作为一个较大结构体的一部分，可以节省在堆上开辟小对象的内存，也可以节省间接引用事件指针的事件和额外内存流失的处理。</p>
<p>文档的作者并不提倡用event_assign这个函数，推荐使用event_new，而且对于一些问题event_assign并不好调试</p>
<p>下面是使用event_assign的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event_pair</span> &#123;</span><br><span class="line">         <span class="type">evutil_socket_t</span> fd;</span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">event</span> read_event;</span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">event</span> write_event;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readcb</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writecb</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event_pair</span> *<span class="built_in">event_pair_new</span>(<span class="keyword">struct</span> event_base *base, <span class="type">evutil_socket_t</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_pair</span> *p = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> event_pair));</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;fd = fd;</span><br><span class="line">        <span class="built_in">event_assign</span>(&amp;p-&gt;read_event, base, fd, EV_READ|EV_PERSIST, readcb, p);</span><br><span class="line">        <span class="built_in">event_assign</span>(&amp;p-&gt;write_event, base, fd, EV_WRITE|EV_PERSIST, writecb, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WARNING<br>Never call event_assign() on an event that is already pending in an event base. Doing so can lead to extremely hard-to-diagnose errors. If the event is already initialized and pending, call event_del() on it before you call event_assign() on it again.</p>
<p>event在event_base中阻塞时不要调用event_assign()，否则会造成很难查找分析的问题，如果一个事件已经初始化并且pending了，需要调用event_del()删除他，然后再次调用event_assign()。</p>
<p>evtimer_assign和evsignal_assign分别是定时器和信号的注册函数。</p>
<p>由于调用event_assign()可能会造成版本兼容的问题，调用如下函数，可以获取到event运行时大小。<br>size_t event_get_struct_event_size(void);</p>
<p>This function returns the number of bytes you need to set aside for a struct event. As before, you should only be using this function if you know that heap-allocation is actually a significant problem in your program, since it can make your code much harder to read and write.</p>
<p>这个函数返回event结构体旁边的偏移位置的字节数，只有在你觉得堆开辟确实是一个难题的时候才采用这个方法。因为这么做会是你的代码更难去读和写。</p>
<p><code>事件的添加：</code><br>int event_add(struct event *ev, const struct timeval *tv);<br>Calling event_add on a non-pending event makes it pending in its configured base. The function returns 0 on success, and -1 on failure. If tv is NULL, the event is added with no timeout. Otherwise, tv is the size of the timeout in seconds and microseconds.</p>
<p>If you call event_add() on an event that is already pending, it will leave it pending, and reschedule it with the provided timeout. If the event is already pending, and you re-add it with the timeout NULL, event_add() will have no effect.</p>
<p>调用event_add会让一个event变得pending，返回0表示成功，-1表示失败。如果tv设置为NULL，表示没有超时检测。否则，tv表示超时的秒数和毫秒。<br>如果在一个pending的event上调用add，会使它pengding，并且根据超时值重新计时。</p>
<p><code>事件的删除：</code><br>int event_del(struct event *ev);</p>
<p>事件删除函数，会将一个阻塞或者激活的事件变为非阻塞和非激活的，如果事件是非阻塞的或者非激活的，调用这个函数并没有什么影响。同样，返回0表示成功，-1表示失败。</p>
<p><code>优先级设置：</code><br>int event_priority_set(struct event *event, int priority);</p>
<p>每个event_base有priorities，event可以设置从0到这个值之间的一个数，0表示成功，-1表示失败。<br>优先级高的先处理，优先级低的后处理。<br>如果不设置优先级，默认值为event_base中队列大小除以2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_cb</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_cb</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main_loop</span><span class="params">(<span class="type">evutil_socket_t</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">event</span> *important, *unimportant;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">event_base</span> *base;</span><br><span class="line"></span><br><span class="line">  base = <span class="built_in">event_base_new</span>();</span><br><span class="line">  <span class="built_in">event_base_priority_init</span>(base, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">/* Now base has priority 0, and priority 1 */</span></span><br><span class="line">  important = <span class="built_in">event_new</span>(base, fd, EV_WRITE|EV_PERSIST, write_cb, <span class="literal">NULL</span>);</span><br><span class="line">  unimportant = <span class="built_in">event_new</span>(base, fd, EV_READ|EV_PERSIST, read_cb, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">event_priority_set</span>(important, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">event_priority_set</span>(unimportant, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now, whenever the fd is ready for writing, the write callback will</span></span><br><span class="line"><span class="comment">     happen before the read callback.  The read callback won&#x27;t happen at</span></span><br><span class="line"><span class="comment">     all until the write callback is no longer active. */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>除此之外，libevent还为我们提供了一些接口访问当前event_base 和event属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_pending</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *ev, <span class="type">short</span> what, <span class="keyword">struct</span> timeval *tv_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="function"><span class="type">evutil_socket_t</span> <span class="title">event_get_fd</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event_base</span> *<span class="built_in">event_get_base</span>(<span class="type">const</span> <span class="keyword">struct</span> event *ev);</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">event_get_events</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *event,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">struct</span> event_base **base_out,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">evutil_socket_t</span> *fd_out,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">short</span> *events_out,</span></span></span><br><span class="line"><span class="params"><span class="function">        event_callback_fn *callback_out,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> **arg_out)</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>event_pending 获取当前event对应的what属性事件是否pending或者被激活，If it is, and any of the flags EV_READ, EV_WRITE, EV_SIGNAL, and EV_TIMEOUT are set in the whatargument, the function returns all of the flags that the event is currently pending or active on</p>
<p>任类型都可以设置到what参数里，这个函数返回当前pending或者激活状态的标记按位或。event_get_signal和event_get_fd返回event关联的信号id和文件描述符id， event_get_base返回event绑定的event_base，<br>event_get_events返回event监听的事件集合，event_get_callback返回event的回调函数，以及<br>event_get_callback_arg返回回调函数参数，<br>event_get_priority返回event的优先级<br>event_get_assignment这个函数返回event所有绑定的信息到对应的指针域，如果形参为NULL，表示忽略。\</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Change the callback and callback_arg of &#x27;ev&#x27;, which must not be</span></span><br><span class="line"><span class="comment"> * pending. */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">replace_callback</span><span class="params">(<span class="keyword">struct</span> event *ev, event_callback_fn new_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *new_callback_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">event_base</span> *base;</span><br><span class="line">    <span class="type">evutil_socket_t</span> fd;</span><br><span class="line">    <span class="type">short</span> events;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pending;</span><br><span class="line"></span><br><span class="line">    pending = <span class="built_in">event_pending</span>(ev, EV_READ|EV_WRITE|EV_SIGNAL|EV_TIMEOUT,</span><br><span class="line">                            <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        <span class="comment">/* We want to catch this here so that we do not re-assign a</span></span><br><span class="line"><span class="comment">         * pending event.  That would be very very bad. */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                <span class="string">&quot;Error! replace_callback called on a pending event!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">event_get_assignment</span>(ev, &amp;base, &amp;fd, &amp;events,</span><br><span class="line">                         <span class="literal">NULL</span> <span class="comment">/* ignore old callback */</span> ,</span><br><span class="line">                         <span class="literal">NULL</span> <span class="comment">/* ignore old callback argument */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">event_assign</span>(ev, base, fd, events, new_callback, new_callback_arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>还有个能只调用一次事件的创建接口</p>
<p>int event_base_once(struct event_base <em>, evutil_socket_t, short,<br>  void (</em>)(evutil_socket_t, short, void *), void *, const struct timeval *);</p>
<p>这个函数不支持EV_SIGNAL 和 EV_PERSIST ，这个事件也不支持手动删除和激活。当该事件对应的回调函数触发后，该事件会自动从event_base中移除，并且libevent会析构掉该event。</p>
<p><code>激活event的接口</code></p>
<p>void event_active(struct event *ev, int what, short ncalls);</p>
<p>这个函数可以根据what(EV_READ, EV_WRITE,EV_TIMER等)将event设置为active，调用函数前，event是否为pengding并不影响，<br>并且激活它并且变为非阻塞状态。<br>在同一个事件递归的调用event_active会导致内存耗尽。</p>
<p>下面是一个错误例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cb</span><span class="params">(<span class="type">int</span> sock, <span class="type">short</span> which, <span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Whoops: Calling event_active on the same event unconditionally</span></span><br><span class="line"><span class="comment">           from within its callback means that no other events might not get</span></span><br><span class="line"><span class="comment">           run! */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_active</span>(ev, EV_WRITE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">event_base_new</span>();</span><br><span class="line"></span><br><span class="line">        ev = <span class="built_in">event_new</span>(base, <span class="number">-1</span>, EV_PERSIST | EV_READ, cb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_add</span>(ev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_active</span>(ev, EV_WRITE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_base_loop</span>(base, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>有两种改进的方式，一种是采用定时器，另一种是采用libevent提供的event_config_set_max_dispatch_interval</p>
<p>定时器的就是只调用一次loop，之后的回调函数cb会反复调用，因为cb内部发现event不是阻塞状态了，就要将event删除后再加入，loop内部检测到新的event，继续调用cb，反复调用cb</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cb</span><span class="params">(<span class="type">int</span> sock, <span class="type">short</span> which, <span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">evtimer_pending</span>(ev, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">       <span class="built_in">event_del</span>(ev);</span><br><span class="line">       <span class="built_in">evtimer_add</span>(ev, &amp;tv);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">event_base_new</span>();</span><br><span class="line"></span><br><span class="line">   tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">   tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   ev = <span class="built_in">evtimer_new</span>(base, cb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">evtimer_add</span>(ev, &amp;tv);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">event_base_loop</span>(base, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_config_set_max_dispatch_interval设置了dispatch的时间间隔，每个一段时间才派发就绪时间，这样就不会导致递归造成的资源耗尽了。</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cb</span><span class="params">(<span class="type">int</span> sock, <span class="type">short</span> which, <span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">event_active</span>(ev, EV_WRITE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_config</span> *cfg = <span class="built_in">event_config_new</span>();</span><br><span class="line">        <span class="comment">/* Run at most 16 callbacks before checking for other events. */</span></span><br><span class="line">        <span class="built_in">event_config_set_max_dispatch_interval</span>(cfg, <span class="literal">NULL</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">event_base_new_with_config</span>(cfg);</span><br><span class="line">        ev = <span class="built_in">event_new</span>(base, <span class="number">-1</span>, EV_PERSIST | EV_READ, cb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_add</span>(ev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_active</span>(ev, EV_WRITE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">event_base_loop</span>(base, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<p>今天的学习就到这里，这是我的公众号</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"># 网络编程</a>
          
            <a href="/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/" rel="tag"># Linux环境编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/04/libevent4/" rel="next" title="Libevent学习笔记(四) bufferevent 的 concepts and basics">
                <i class="fa fa-chevron-left"></i> Libevent学习笔记(四) bufferevent 的 concepts and basics
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/07/libevent2/" rel="prev" title="libevent学习文档(二)eventbase相关接口和参数">
                libevent学习文档(二)eventbase相关接口和参数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">219</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/secondtonone1" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" target="_blank" title="ZhiHu">
                    
                      <i class="fa fa-fw fa-ZhiHu"></i>ZhiHu</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恋恋风辰</span>

  
  
 
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
 
 
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
