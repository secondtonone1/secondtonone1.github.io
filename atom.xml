<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恋恋风辰的个人博客</title>
  
  
  <link href="http://www.limerence2017.com/atom.xml" rel="self"/>
  
  <link href="http://www.limerence2017.com/"/>
  <updated>2025-03-01T15:35:25.743Z</updated>
  <id>http://www.limerence2017.com/</id>
  
  <author>
    <name>恋恋风辰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>零基础C++(33) 单例模式演变</title>
    <link href="http://www.limerence2017.com/2025/03/01/cppbase33/"/>
    <id>http://www.limerence2017.com/2025/03/01/cppbase33/</id>
    <published>2025-03-01T04:49:27.000Z</published>
    <updated>2025-03-01T15:35:25.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式概念"><a href="#单例模式概念" class="headerlink" title="单例模式概念"></a>单例模式概念</h2><p>今天给大家讲讲单例模式演变流程，从C++98到C++11经历了哪些变化？哪一种单例模式更为安全。</p><p>单例模式（Singleton Pattern）是一种创建型设计模式，旨在确保一个类在整个应用程序生命周期中仅且只有一个实例，并提供一个全局访问点以获取该实例。设计单例模式的主要原因和作用包括以下几个方面：</p><h3 id="1-控制实例数量"><a href="#1-控制实例数量" class="headerlink" title="1. 控制实例数量"></a>1. 控制实例数量</h3><p>单例模式确保一个类只有一个实例，防止在程序中创建多个实例可能导致的资源浪费或状态不一致问题。例如，数据库连接池、配置管理类等通常使用单例模式，以确保全局只有一个连接池或配置实例。</p><h3 id="2-提供全局访问点"><a href="#2-提供全局访问点" class="headerlink" title="2. 提供全局访问点"></a>2. 提供全局访问点</h3><p>单例模式通过提供一个全局访问点，使得在程序的任何地方都可以方便地访问该实例。这对于那些需要在多个模块或组件之间共享的资源或服务尤为重要，如日志记录器、缓存管理器等。</p><h3 id="3-延迟实例化"><a href="#3-延迟实例化" class="headerlink" title="3. 延迟实例化"></a>3. 延迟实例化</h3><p>单例模式通常采用懒加载的方式，即在第一次需要使用实例时才创建。这有助于节省系统资源，特别是在实例创建成本较高或初期并不需要该实例的情况下。</p><h3 id="4-避免命名冲突"><a href="#4-避免命名冲突" class="headerlink" title="4. 避免命名冲突"></a>4. 避免命名冲突</h3><p>通过将单例实例作为一个类的静态成员，可以避免在全局命名空间中引入多个实例，减少命名冲突的风险。</p><h3 id="5-管理共享资源"><a href="#5-管理共享资源" class="headerlink" title="5. 管理共享资源"></a>5. 管理共享资源</h3><p>在多线程环境下，单例模式可以有效管理共享资源，确保线程安全。例如，操作系统中的线程池、任务管理器等常使用单例模式，以协调多个线程对资源的访问。</p><h3 id="设计单例模式的考虑因素"><a href="#设计单例模式的考虑因素" class="headerlink" title="设计单例模式的考虑因素"></a>设计单例模式的考虑因素</h3><p>虽然单例模式有诸多优点，但在设计和使用时也需要注意以下几点：</p><ul><li><strong>线程安全</strong>：在多线程环境下，需要确保单例实例的创建和访问是线程安全的，常用的方法有双重检查锁定（Double-Checked Locking）和使用静态内部类等。</li><li><strong>延迟初始化</strong>：根据需求选择是否采用延迟初始化，以平衡性能和资源利用。</li><li><strong>可测试性</strong>：单例模式可能会影响代码的可测试性，特别是在单元测试中，可能需要通过依赖注入等手段来替代单例实例。</li><li><strong>限制扩展</strong>：单例模式通过限制实例数量可能会限制类的扩展性，需谨慎使用。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要确保全局只有一个实例的场景，如配置管理、日志系统、设备驱动等。</li><li>需要全局访问点来协调系统中的多个部分，如缓存、线程池等。</li></ul><h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><ul><li>需要多个实例以满足不同需求的场景。</li><li>对象的生命周期需要更灵活控制的场合。</li></ul><p>总的来说，单例模式通过控制类的实例数量和提供全局访问点，为系统资源管理和状态一致性提供了有效的解决方案。然而，在实际应用中，应根据具体需求和上下文环境，谨慎决定是否使用单例模式，以避免潜在的设计问题。</p><h2 id="局部静态变量方式"><a href="#局部静态变量方式" class="headerlink" title="局部静态变量方式"></a>局部静态变量方式</h2><p>这种方式最简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过静态成员变量实现单例</span></span><br><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single2</span>(<span class="type">const</span> Single2 &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single2 &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Single2 &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2 &amp;<span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single2 single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码通过局部静态成员single实现单例类，原理就是函数的局部静态变量生命周期随着进程结束而结束。上述代码通过懒汉式的方式实现。<br>调用如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_single2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//多线程情况下可能存在问题</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; &amp;Single2::<span class="built_in">GetInst</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; &amp;Single2::<span class="built_in">GetInst</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp1  is  0x1304b10</span><br><span class="line">sp2  is  0x1304b10</span><br></pre></td></tr></table></figure><p>确实生成了唯一实例，在C++98年代，上述单例模式存在隐患，对于多线程方式生成的实例可能时多个。</p><p>随着C++ 11的来临，这种方式不再存在线程安全问题，是最为简单也是最适合新手的方式。</p><h2 id="静态成员变量指针方式-饿汉式"><a href="#静态成员变量指针方式-饿汉式" class="headerlink" title="静态成员变量指针方式(饿汉式)"></a>静态成员变量指针方式(饿汉式)</h2><p>可以定义一个类的静态成员变量，用来控制实现单例，这种方式依靠静态成员提前初始化保证生成的单例是唯一的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single2Hungry</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2Hungry</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single2Hungry</span>(<span class="type">const</span> Single2Hungry &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single2Hungry &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Single2Hungry &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2Hungry *<span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="built_in">Single2Hungry</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Single2Hungry *single;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这么做的一个好处是我们可以通过饿汉式的方式避免线程安全问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式初始化</span></span><br><span class="line">Single2Hungry *Single2Hungry::single = Single2Hungry::<span class="built_in">GetInst</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_s2</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is thread &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;inst is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_single2hungry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; Single2Hungry::<span class="built_in">GetInst</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">thread <span class="title">tid</span><span class="params">(thread_func_s2, i)</span></span>;</span><br><span class="line">        tid.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test_single2hungry</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 addr is 0x1e4b00</span><br><span class="line">s2 addr is 0x1e4b00</span><br><span class="line">this is thread 0</span><br><span class="line">inst is 0x1e4b00</span><br><span class="line">this is thread 1</span><br><span class="line">inst is 0x1e4b00</span><br><span class="line">this is thread 2</span><br><span class="line">inst is 0x1e4b00</span><br></pre></td></tr></table></figure><p>可见无论单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。</p><p>饿汉式是在程序启动时就进行单例的初始化，这种方式也可以通过懒汉式调用，无论饿汉式还是懒汉式都存在一个问题，就是什么时候释放内存？</p><p>多线程情况下，释放内存就很难了，还有二次释放内存的风险。</p><h2 id="静态成员变量指针方式-懒汉式"><a href="#静态成员变量指针方式-懒汉式" class="headerlink" title="静态成员变量指针方式(懒汉式)"></a>静态成员变量指针方式(懒汉式)</h2><p>我们定义一个单例类并用懒汉式方式调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式指针</span></span><br><span class="line"><span class="comment">//即使创建指针类型也存在问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SinglePointer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SinglePointer</span>(<span class="type">const</span> SinglePointer &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePointer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SinglePointer &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SinglePointer *<span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single = <span class="keyword">new</span> <span class="built_in">SinglePointer</span>();</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SinglePointer *single;</span><br><span class="line">    <span class="type">static</span> mutex s_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>cpp</code>文件里初始化静态成员,并定义一个测试函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="comment">//在类的cpp文件定义static变量</span></span><br><span class="line">SinglePointer *SinglePointer::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SinglePointer::s_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_lazy</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is lazy thread &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;inst is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">GetInst</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_singlelazy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">thread <span class="title">tid</span><span class="params">(thread_func_lazy, i)</span></span>;</span><br><span class="line">        tid.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//何时释放new的对象？造成内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test_singlelazy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this is lazy thread 0</span><br><span class="line">inst is 0xbc1700</span><br><span class="line">this is lazy thread 1</span><br><span class="line">inst is 0xbc1700</span><br><span class="line">this is lazy thread 2</span><br><span class="line">inst is 0xbc1700</span><br></pre></td></tr></table></figure><p>此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。</p><p><strong>C++11改进</strong></p><p>我们可以利用C++11 提供的<strong>once_flag</strong>实现安全的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DAY34_SINGLETON_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAY34_SINGLETON_SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonOnceFlag</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingletonOnceFlag* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, []&#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> <span class="built_in">SingletonOnceFlag</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingletonOnceFlag</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonOnceFlag</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingletonOnceFlag</span>(<span class="type">const</span> SingletonOnceFlag&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingletonOnceFlag&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingletonOnceFlag&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> SingletonOnceFlag* _instance;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//DAY34_SINGLETON_SINGLETON_H</span></span></span><br></pre></td></tr></table></figure><p>static成员要在cpp中初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingletonOnceFlag *SingletonOnceFlag::_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001 &gt; nul&quot;</span>);</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x19a74de7420</span></span><br><span class="line"><span class="number">0x19a74de7420</span></span><br></pre></td></tr></table></figure><h2 id="智能指针方式-懒汉式"><a href="#智能指针方式-懒汉式" class="headerlink" title="智能指针方式(懒汉式)"></a>智能指针方式(懒汉式)</h2><p>可以利用智能指针自动回收内存的机制设计单例类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DAY34_SINGLETON_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAY34_SINGLETON_SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonOnceFlag</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingletonOnceFlag&gt; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, []&#123;</span><br><span class="line">            _instance = std::<span class="built_in">shared_ptr</span>&lt;SingletonOnceFlag&gt;(<span class="keyword">new</span> <span class="built_in">SingletonOnceFlag</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingletonOnceFlag</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonOnceFlag</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingletonOnceFlag</span>(<span class="type">const</span> SingletonOnceFlag&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingletonOnceFlag&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingletonOnceFlag&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingletonOnceFlag&gt; _instance;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//DAY34_SINGLETON_SINGLETON_H</span></span></span><br></pre></td></tr></table></figure><p>同样在<code>SingletonOnceFlag.cpp</code>中进行单例成员的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingletonOnceFlag&gt; SingletonOnceFlag::_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>再次测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001 &gt; nul&quot;</span>);</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingletonOnceFlag::getInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次输出析构信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x1d620a47420</span><br><span class="line">0x1d620a47420</span><br><span class="line">this is singleton destruct</span><br></pre></td></tr></table></figure><h2 id="辅助类智能指针单例模式"><a href="#辅助类智能指针单例模式" class="headerlink" title="辅助类智能指针单例模式"></a>辅助类智能指针单例模式</h2><p>智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by secon on 2025/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DAY34_SINGLETON_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAY34_SINGLETON_SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(SingleAutoSafe *sf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deleter operator()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> sf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, []&#123;</span><br><span class="line">            _instance = std::<span class="built_in">shared_ptr</span>&lt;SingleAutoSafe&gt;(<span class="keyword">new</span> <span class="built_in">SingleAutoSafe</span>(), <span class="built_in">SafeDeletor</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义友元类，通过友元类调用该类析构函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAutoSafe&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAutoSafe&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; _instance;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//DAY34_SINGLETON_SINGLETON_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在cpp文件中实现静态成员的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><code>SafeDeletor</code>要写在<code>SingleAutoSafe</code>上边，并且<code>SafeDeletor</code>要声明为<code>SingleAutoSafe</code>类的友元类，这样就可以访问<code>SingleAutoSafe</code>的析构函数了。</p><p>我们在构造<code>single</code>时制定了<code>SafeDeletor()</code>,<code>single</code>在回收时，会调用<code>SingleAutoSafe</code>的仿函数，从而完成内存的销毁。</p><p>并且<code>SingleAutoSafe</code>的析构函数为私有的无法被外界手动调用了。</p><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001 &gt; nul&quot;</span>);</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleAutoSafe::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleAutoSafe::getInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleAutoSafe::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleAutoSafe::getInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x1b379b07420</span><br><span class="line">0x1b379b07420</span><br><span class="line">this is safe deleter operator()</span><br></pre></td></tr></table></figure><h2 id="通用的单例模板类-CRTP"><a href="#通用的单例模板类-CRTP" class="headerlink" title="通用的单例模板类(CRTP)"></a>通用的单例模板类(CRTP)</h2><p>我们可以通过声明单例的模板类，然后继承这个单例模板类的所有类就是单例类了。达到泛型编程提高效率的目的。</p><p><strong>CRTP的概念</strong></p><p>CRTP是一种将派生类作为模板参数传递给基类的技术，即一个类继承自一个以自身为模板参数的基类。这种模式常用于实现静态多态、接口的默认实现、编译时策略选择等。</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TempClass</span> &#123;</span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//CRTP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealClass</span>: <span class="keyword">public</span> TempClass&lt;RealClass&gt;&#123;</span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>单例基类实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag s_flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">            _instance = <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _instance.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>我们定义一个网络的单例类，继承上述模板类即可，并将构造和析构设置为私有，同时设置友元保证自己的析构和构造可以被友元类调用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过继承方式实现网络模块单例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleNet</span> : <span class="keyword">public</span> Singleton&lt;SingleNet&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;SingleNet&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleNet</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleNet</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SingleNet destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试案例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001 &gt; nul&quot;</span>);</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleNet::GetInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleNet::GetInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleNet::GetInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        SingleNet::GetInstance()-&gt;PrintAddress();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x212248b7420</span></span><br><span class="line"><span class="number">0x212248b7420</span></span><br><span class="line">SingleNet destruct</span><br><span class="line"><span class="keyword">this</span> is singleton destruct</span><br></pre></td></tr></table></figure><h2 id="源码和视频"><a href="#源码和视频" class="headerlink" title="源码和视频"></a>源码和视频</h2><p><a href="https://www.bilibili.com/video/BV1y69TYTEEY/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9">视频地址</a></p><p><a href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/base">源码地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单例模式概念&quot;&gt;&lt;a href=&quot;#单例模式概念&quot; class=&quot;headerlink&quot; title=&quot;单例模式概念&quot;&gt;&lt;/a&gt;单例模式概念&lt;/h2&gt;&lt;p&gt;今天给大家讲讲单例模式演变流程，从C++98到C++11经历了哪些变化？哪一种单例模式更为安全。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>引用折叠和原样转发</title>
    <link href="http://www.limerence2017.com/2025/02/22/cppbase32/"/>
    <id>http://www.limerence2017.com/2025/02/22/cppbase32/</id>
    <published>2025-02-22T01:56:32.000Z</published>
    <updated>2025-02-28T02:07:25.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-左值与右值"><a href="#1-左值与右值" class="headerlink" title="1. 左值与右值"></a>1. 左值与右值</h2><h3 id="1-1-定义与分类"><a href="#1-1-定义与分类" class="headerlink" title="1.1 定义与分类"></a>1.1 定义与分类</h3><p><strong>左值（lvalue）</strong>和<strong>右值（rvalue）</strong>是C++中用于描述表达式值类别的重要概念。</p><ul><li><strong>左值（lvalue）</strong>：<ul><li>表示具有持久存储的对象。</li><li>可以出现在赋值语句的左侧。</li><li>可以被取地址（即，可以使用<code>&amp;</code>运算符）。</li><li>示例：变量名、引用等。</li></ul></li><li><strong>右值（rvalue）</strong>：<ul><li>表示临时对象或没有持久存储的值。</li><li>通常出现在赋值语句的右侧。</li><li>不能被取地址。</li><li>示例：字面量、临时对象、表达式结果等。</li></ul></li></ul><p>C++11进一步细化了右值的分类：</p><ul><li><strong>纯右值（prvalues）</strong>：表示临时对象或字面量，如<code>42</code>、<code>3.14</code>。</li><li><strong>将亡值（xvalues，expiring values）</strong>：表示即将被移动的对象，如<code>std::move</code>的结果。</li></ul><span id="more"></span><h3 id="1-2-示例代码"><a href="#1-2-示例代码" class="headerlink" title="1.2 示例代码"></a>1.2 示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;           <span class="comment">// a是一个左值</span></span><br><span class="line">    <span class="type">int</span>&amp; b = a;           <span class="comment">// b是a的左值引用</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; c = <span class="number">20</span>;         <span class="comment">// c是一个右值引用，绑定到临时右值20</span></span><br><span class="line">    <span class="type">int</span> d = a + <span class="number">5</span>;        <span class="comment">// (a + 5)是一个纯右值</span></span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;Hello&quot;</span>;                   <span class="comment">// s1是一个左值</span></span><br><span class="line">    std::string s2 = std::<span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>);      <span class="comment">// std::string(&quot;World&quot;)是一个纯右值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, d: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2: &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查类型</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    <span class="comment">// 使用 decltype((a)) 获取 a 的类型，包括引用</span></span><br><span class="line">    <span class="comment">// `(a)` 是一个左值表达式，所以 decltype((a)) 是 `int&amp;`</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a 是左值: &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>((a))&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c 是右值引用: &quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="keyword">decltype</span>(c)&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="number">10</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">15</span></span><br><span class="line"><span class="attr">s1:</span> <span class="string">Hello,</span> <span class="attr">s2:</span> <span class="string">World</span></span><br><span class="line"><span class="string">a</span> <span class="string">是左值:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">c</span> <span class="string">是右值引用:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="1-3-类型判断工具"><a href="#1-3-类型判断工具" class="headerlink" title="1.3 类型判断工具"></a>1.3 类型判断工具</h3><p>C++标准库提供了几个类型特性（type traits）用于判断表达式的值类别：</p><ul><li><code>std::is_lvalue_reference&lt;T&gt;</code>：判断类型<code>T</code>是否为左值引用。</li><li><code>std::is_rvalue_reference&lt;T&gt;</code>：判断类型<code>T</code>是否为右值引用。</li><li><code>std::is_lvalue&lt;T&gt;</code>（C++20起）：判断表达式是否为左值。</li><li><code>std::is_rvalue&lt;T&gt;</code>（C++20起）：判断表达式是否为右值。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func(int&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func(int&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; ref = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断类型</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    <span class="comment">// 使用 decltype((a)) 获取 a 的类型，包括引用</span></span><br><span class="line">    <span class="comment">// `(a)` 是一个左值表达式，所以 decltype((a)) 是 `int&amp;`</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a 是左值: &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>((a))&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref 是左值引用: &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(ref)&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="built_in">func</span>(a);          <span class="comment">// 调用func(int&amp;)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);         <span class="comment">// 调用func(int&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a 是左值: <span class="literal">true</span></span><br><span class="line">ref 是左值引用: <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>&amp;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>&amp;&amp;)</span></span></span><br></pre></td></tr></table></figure><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><p>理解左值与右值的区别是实现<strong>移动语义</strong>、<strong>完美转发</strong>以及高效内存管理的基础。在编写高性能C++代码时，合理利用右值引用和移动语义可以显著提升程序的效率。</p><hr><h2 id="2-模板万能引用（转发引用）"><a href="#2-模板万能引用（转发引用）" class="headerlink" title="2. 模板万能引用（转发引用）"></a>2. 模板万能引用（转发引用）</h2><h3 id="2-1-定义与特性"><a href="#2-1-定义与特性" class="headerlink" title="2.1 定义与特性"></a>2.1 定义与特性</h3><p><strong>模板万能引用</strong>（也称为<strong>转发引用</strong>，英文为<strong>forwarding references</strong>）是C++11引入的一种引用类型，具有以下特点：</p><ul><li>表现形式为<code>T&amp;&amp;</code>，其中<code>T</code>是模板参数。</li><li>在特定条件下，编译器会将其解析为左值引用或右值引用。</li><li>能够统一处理左值和右值，适用于泛型编程中的参数传递。</li></ul><p><strong>重要特性</strong>：</p><ul><li>当模板参数<code>T</code>被推导为普通类型时，<code>T&amp;&amp;</code>是右值引用。</li><li>当模板参数<code>T</code>被推导为引用类型时，<code>T&amp;&amp;</code>会根据引用折叠规则解析为左值引用。</li></ul><h3 id="2-2-引用折叠规则"><a href="#2-2-引用折叠规则" class="headerlink" title="2.2 引用折叠规则"></a>2.2 引用折叠规则</h3><p>引用折叠是C++中的一项规则，用于处理引用类型的嵌套。主要规则如下：</p><ul><li><code>&amp; &amp;</code>、<code>&amp; &amp;&amp;</code>、<code>&amp;&amp; &amp;</code> 都折叠为 <code>&amp;</code>（左值引用）。</li><li><code>&amp;&amp; &amp;&amp;</code> 折叠为 <code>&amp;&amp;</code>（右值引用）。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_referenc</span><span class="params">(T&amp;&amp; x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T is lvalue reference: &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;T&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T is rvalue reference: &quot;</span> &lt;&lt; std::is_rvalue_reference&lt;T&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T is rvalue : &quot;</span> &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt; ::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is lvalue reference: &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(x)&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is rvalue reference: &quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="keyword">decltype</span>(x)&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">check_reference</span>(a);          <span class="comment">// T被推导为 int&amp;， 因此 T&amp;&amp; -&gt; int&amp; &amp;&amp; -&gt; int&amp;</span></span><br><span class="line">    <span class="built_in">check_reference</span>(<span class="number">20</span>);         <span class="comment">// T被推导为 int，  T&amp;&amp; -&gt; int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T <span class="built_in">is</span> lvalue reference: <span class="literal">true</span></span><br><span class="line">T <span class="built_in">is</span> rvalue reference: <span class="literal">false</span></span><br><span class="line">T <span class="built_in">is</span> rvalue : <span class="literal">false</span></span><br><span class="line">x <span class="built_in">is</span> lvalue reference: <span class="literal">true</span></span><br><span class="line">x <span class="built_in">is</span> rvalue reference: <span class="literal">false</span></span><br><span class="line">T <span class="built_in">is</span> lvalue reference: <span class="literal">false</span></span><br><span class="line">T <span class="built_in">is</span> rvalue reference: <span class="literal">false</span></span><br><span class="line">T <span class="built_in">is</span> rvalue : <span class="literal">true</span></span><br><span class="line">x <span class="built_in">is</span> lvalue reference: <span class="literal">false</span></span><br><span class="line">x <span class="built_in">is</span> rvalue reference: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是要注意，如果如果我这样调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">check_referenc</span>(c);</span><br></pre></td></tr></table></figure><p>输出的却是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T is lvalue reference: <span class="literal">true</span></span><br><span class="line">T is rvalue reference: <span class="literal">false</span></span><br><span class="line">T is rvalue : <span class="literal">false</span></span><br><span class="line">x is lvalue reference: <span class="literal">true</span></span><br><span class="line">x is rvalue reference: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然而，实际中 <code>T</code> 被推导为 <code>int&amp;</code>，这是因为 <strong>命名的右值引用变量在表达式中被视为左值</strong>。</p><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol><li><strong>变量的值类别（Value Category）</strong>：<ul><li><strong>左值（lvalue）</strong>：有名称，可以出现在赋值的左侧。</li><li><strong>右值（rvalue）</strong>：临时的、没有名称的值，一般不能出现在赋值的左侧。</li></ul></li><li><strong>命名的右值引用变量是左值</strong>：<ul><li>虽然 <code>c</code> 的类型是 <code>int&amp;&amp;</code>，但作为一个变量名，它本身是一个左值。</li><li>这意味着在表达式中使用 <code>c</code> 时，<code>c</code> 被视为左值，而不是右值。</li></ul></li><li><strong>类型推导规则</strong>：<ul><li>当模板参数使用<code>T&amp;&amp;</code>（被称为转发引用或万能引用）时，类型推导遵循特定规则：<ul><li><strong>如果传入的是左值</strong>，<code>T</code> 被推导为 <code>T&amp;</code>。</li><li><strong>如果传入的是右值</strong>，<code>T</code> 被推导为 <code>T</code>（非引用类型）。</li></ul></li></ul></li></ol><ul><li><strong>传入左值（<code>c</code>）</strong>：<ul><li><code>c</code> 是一个命名的右值引用变量，但作为表达式它是左值。</li><li>因此，<code>T</code> 被推导为 <code>int&amp;</code>。</li><li><code>T&amp;&amp;</code> 则根据引用折叠规则（<code>int&amp; &amp;&amp;</code> =&gt; <code>int&amp;</code>）。</li></ul></li></ul><p>为了让 <code>T</code> 被推导为右值引用，我们需要传递一个 <strong>真正的右值</strong>。这可以通过使用 <code>std::move</code> 来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::move(c) 是右值，T 被推导为 int</span></span><br><span class="line"><span class="built_in">check_reference</span>(std::<span class="built_in">move</span>(c));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T is lvalue reference: <span class="literal">false</span></span><br><span class="line">T is rvalue reference: <span class="literal">false</span></span><br><span class="line">T is rvalue : <span class="literal">true</span></span><br><span class="line">x is lvalue reference: <span class="literal">false</span></span><br><span class="line">x is rvalue reference: <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol><li>**传递右值 <code>std::move(c)</code>**：<ul><li><code>std::move(c)</code> 将 <code>c</code> 转换为 <code>int&amp;&amp;</code>（右值）。</li><li><code>T</code> 被推导为 <code>int</code>（非引用类型）。</li><li><code>std::is_lvalue_reference&lt;T&gt;::value</code> 为 <code>false</code>。</li><li><code>std::is_rvalue_reference&lt;T&gt;::value</code> 为 <code>false</code>。</li><li><code>std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value</code> 相当于 <code>std::is_rvalue_reference&lt;int&amp;&amp;&gt;::value</code>，为 <code>true</code>。</li><li><code>decltype(x)</code> 相当于 <code>int&amp;&amp;</code>，所以 <code>x</code> 被识别为右值引用。</li></ul></li><li><strong>为什么T被实例化为int而不是int&amp;&amp;</strong></li></ol><p>在模板参数中，当一个类型参数 <code>T</code> 以 <code>T&amp;&amp;</code> 的形式出现，并且 <code>T</code> 是模板参数时，<code>T&amp;&amp;</code> 被称为 <strong>转发引用</strong>（有时称为<strong>万能引用</strong>）。转发引用具有特殊的类型推导规则：</p><ul><li><strong>如果传递的是左值</strong>，<code>T</code> 被推导为 <code>T&amp;</code>。</li><li><strong>如果传递的是右值</strong>，<code>T</code> 被推导为 <code>T</code>（<strong>不带引用</strong>）。</li></ul><p> <strong>模板类型推导的具体规则</strong></p><p>根据 <strong>C++ 标准</strong>（C++17 标准草案）：</p><blockquote><p>如果 P 是 <code>T&amp;&amp;</code>，并且 A（实参类型）是一个非引用类型的表达式，则 <code>T</code> 被推导为 A 的类型。</p><p>如果 P 是 <code>T&amp;&amp;</code>，并且 A 是一个引用类型的表达式，则去除引用后的类型用于推导。</p></blockquote><p>具体到我们的例子：</p><ul><li><strong>传递 <code>c</code>（一个左值，类型 <code>int&amp;&amp;</code>）：</strong><ul><li>表达式 <code>c</code> 是一个 <strong>左值</strong>。</li><li>当传递左值给 <code>T&amp;&amp;</code> 时，<code>T</code> 被推导为 <code>int&amp;</code>（即 <code>int</code> 加上引用）。</li><li>因此，参数类型 <code>T&amp;&amp;</code> 实际上是 <code>int&amp; &amp;&amp;</code>，根据引用折叠规则，<code>int&amp; &amp;&amp;</code> 合并为 <code>int&amp;</code>。</li></ul></li><li><strong>传递 <code>std::move(c)</code>（一个右值，类型 <code>int&amp;&amp;</code>）：</strong><ul><li>表达式 <code>std::move(c)</code> 是一个 <strong>右值</strong>。</li><li>当传递右值给 <code>T&amp;&amp;</code> 时，<code>T</code> 被推导为 <code>int</code>（不带引用）。</li><li>因此，参数类型 <code>T&amp;&amp;</code> 是 <code>int&amp;&amp;</code>。</li></ul></li></ul><p><strong>也可以采用原样转发，达到和move相同的效果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">check_referenc</span>(std::forward&lt;<span class="type">int</span>&amp;&amp;&gt;(c));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T is lvalue reference: <span class="literal">false</span></span><br><span class="line">T is rvalue reference: <span class="literal">false</span></span><br><span class="line">T is rvalue : <span class="literal">true</span></span><br><span class="line">x is lvalue reference: <span class="literal">false</span></span><br><span class="line">x is rvalue reference: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-3-示例代码"><a href="#2-3-示例代码" class="headerlink" title="2.3 示例代码"></a>2.3 示例代码</h3><p>以下示例展示了如何使用模板万能引用编写能够接受任意类型参数的函数，并通过转发保持参数的原有值类别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数，分别有左值和右值的重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;process(int&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;process(int&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的包装函数，使用转发引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 原样转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(a);          <span class="comment">// 传递左值，调用process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">20</span>);         <span class="comment">// 传递右值，调用process(int&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">process(int&amp;)</span></span><br><span class="line"><span class="string">process(int&amp;&amp;)</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>wrapper</code>函数使用模板万能引用<code>T&amp;&amp;</code>接收参数，通过<code>std::forward&lt;T&gt;(arg)</code>实现原样转发，确保传递给<code>process</code>函数的参数保持其原有的值类别。</p><p>如果我们把wrapper改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的包装函数，使用转发引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arg); <span class="comment">// 原样转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(a);          <span class="comment">// 传递左值，调用process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">20</span>);         <span class="comment">// 传递右值，调用process(int&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process(int&amp;)</span><br><span class="line">process(int&amp;)</span><br></pre></td></tr></table></figure><p>因为虽然wrapper(20)调用时会将T实例化为int类型, arg变为<code>int &amp;&amp;</code> 类型，但是arg本身是一个左值, 所以调用process会选择左值引用版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;x)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;process(int&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-类型推导（Type-Deduction）"><a href="#3-类型推导（Type-Deduction）" class="headerlink" title="3. 类型推导（Type Deduction）"></a>3. 类型推导（Type Deduction）</h2><h3 id="3-1-类型推导规则"><a href="#3-1-类型推导规则" class="headerlink" title="3.1 类型推导规则"></a>3.1 类型推导规则</h3><p>在C++模板编程中，<strong>类型推导</strong>是指编译器根据传入的实参自动推导模板参数的类型。类型推导遵循以下基本规则：</p><ol><li><strong>模板参数的推导</strong>：<ul><li>当模板参数与函数参数进行匹配时，编译器会根据实参类型推导出模板参数类型<code>T</code>。</li></ul></li><li><strong>引用的处理</strong>：<ul><li>如果函数参数采用右值引用（如<code>T&amp;&amp;</code>），且传递的是左值，则<code>T</code>会被推导为左值引用类型。</li><li>如果传递的是右值，则<code>T</code>会被推导为非引用类型。</li></ul></li><li><strong>cv限定符的去除</strong>：<ul><li>类型推导会去除顶层的<code>const</code>和<code>volatile</code>修饰。</li></ul></li></ol><h3 id="3-2-与引用的关系"><a href="#3-2-与引用的关系" class="headerlink" title="3.2 与引用的关系"></a>3.2 与引用的关系</h3><p>在模板参数中使用引用类型时，类型推导会涉及引用折叠规则。例如，当一个模板函数参数为<code>T&amp;</code>或<code>T&amp;&amp;</code>时，传入参数的值类别会影响<code>T</code>的推导结果。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deduce_type</span><span class="params">(T&amp;&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is T an lvalue reference? &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;T&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is T an rvalue reference? &quot;</span> &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; ref = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deduce_type</span>(a);            <span class="comment">// T被推导为 int&amp;</span></span><br><span class="line">    <span class="built_in">deduce_type</span>(<span class="number">10</span>);           <span class="comment">// T被推导为 int</span></span><br><span class="line">    <span class="built_in">deduce_type</span>(ref);          <span class="comment">// T被推导为 const int&amp;</span></span><br><span class="line">    <span class="built_in">deduce_type</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// T被推导为 int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Is</span> T an lvalue reference? <span class="literal">true</span></span><br><span class="line"><span class="built_in">Is</span> T an rvalue reference? <span class="literal">false</span></span><br><span class="line"><span class="built_in">Is</span> T an lvalue reference? <span class="literal">false</span></span><br><span class="line"><span class="built_in">Is</span> T an rvalue reference? <span class="literal">true</span></span><br><span class="line"><span class="built_in">Is</span> T an lvalue reference? <span class="literal">true</span></span><br><span class="line"><span class="built_in">Is</span> T an rvalue reference? <span class="literal">false</span></span><br><span class="line"><span class="built_in">Is</span> T an lvalue reference? <span class="literal">false</span></span><br><span class="line"><span class="built_in">Is</span> T an rvalue reference? <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-3-示例代码"><a href="#3-3-示例代码" class="headerlink" title="3.3 示例代码"></a>3.3 示例代码</h3><p>以下示例展示了不同情况下模板参数<code>T</code>的推导结果，以及如何利用类型推导编写通用函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_type</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type of T: &quot;</span> </span><br><span class="line">              &lt;&lt; (std::is_lvalue_reference&lt;T&gt;::value ? <span class="string">&quot;lvalue reference&quot;</span> : <span class="string">&quot;rvalue reference&quot;</span>) </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; (std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value ? <span class="string">&quot;Integral&quot;</span> : <span class="string">&quot;Non-Integral&quot;</span>)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; y = x;</span><br><span class="line">    <span class="built_in">display_type</span>(x);            <span class="comment">// T被推导为 int&amp;</span></span><br><span class="line">    <span class="built_in">display_type</span>(<span class="number">20</span>);           <span class="comment">// T被推导为 int&amp;&amp;</span></span><br><span class="line">    <span class="built_in">display_type</span>(y);            <span class="comment">// T被推导为 const int&amp;</span></span><br><span class="line">    <span class="built_in">display_type</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// T被推导为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type of T: lvalue reference, Integral</span><br><span class="line">Type of T: rvalue reference, Integral</span><br><span class="line">Type of T: lvalue reference, Integral</span><br><span class="line">Type of T: rvalue reference, Integral</span><br></pre></td></tr></table></figure><p>在此示例中，通过模板函数<code>display_type</code>，我们可以观察到不同参数传递方式下，模板参数<code>T</code>的推导结果。</p><hr><h2 id="4-原样转发（Perfect-Forwarding）"><a href="#4-原样转发（Perfect-Forwarding）" class="headerlink" title="4. 原样转发（Perfect Forwarding）"></a>4. 原样转发（Perfect Forwarding）</h2><h3 id="4-1-定义与作用"><a href="#4-1-定义与作用" class="headerlink" title="4.1 定义与作用"></a>4.1 定义与作用</h3><p><strong>原样转发</strong>（Perfect Forwarding）是指在模板函数中，将接收到的参数以其原有的值类别（左值或右值）传递给另一个函数。这项技术确保了泛型代码能够像手写特定代码那样高效和正确地处理参数。</p><p><strong>作用</strong>：</p><ul><li>保持参数的值类别，确保正确调用函数重载。</li><li>利用移动语义，避免不必要的拷贝，提升性能。</li><li>编写通用、复用性强的代码。</li></ul><h3 id="4-2-实现原理"><a href="#4-2-实现原理" class="headerlink" title="4.2 实现原理"></a>4.2 实现原理</h3><p>原样转发通常结合<strong>模板万能引用</strong>（转发引用）和<code>std::forward</code>来实现。具体流程如下：</p><ol><li><p>使用模板万能引用（<code>T&amp;&amp;</code>）接收参数。</p></li><li><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::forward&lt;T&gt;(arg)</span><br></pre></td></tr></table></figure><p>将参数转发给目标函数。</p><ul><li><code>std::forward</code>根据<code>T</code>的类型，将参数转换为左值或右值。</li><li>如果参数原本是左值，<code>std::forward</code>返回左值引用。</li><li>如果参数原本是右值，<code>std::forward</code>返回右值引用。</li></ul></li></ol><h3 id="4-3-为什么需要原样转发"><a href="#4-3-为什么需要原样转发" class="headerlink" title="4.3 为什么需要原样转发"></a>4.3 为什么需要原样转发</h3><p>在泛型编程中，函数模板可能需要将接收到的参数传递给其他函数。若不使用原样转发，参数会失去原有的值类别信息，可能导致以下问题：</p><ul><li>右值参数被当作左值处理，无法利用移动语义，导致性能下降。</li><li>无法正确调用目标函数的重载版本。</li><li>增加不必要的拷贝开销，影响程序性能。</li></ul><p>通过原样转发，可以确保参数在传递过程中保持其原有的左值或右值特性，提升代码的效率和灵活性。</p><h3 id="4-4-示例代码"><a href="#4-4-示例代码" class="headerlink" title="4.4 示例代码"></a>4.4 示例代码</h3><p>以下示例展示了如何实现一个通用的<code>wrapper</code>函数，通过原样转发将参数传递给目标函数，同时保留参数的值类别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数，分别有左值和右值的重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing lvalue: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing rvalue: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的包装函数，实现原样转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(name);                     <span class="comment">// 传递左值，调用process(const std::string&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="string">&quot;Bob&quot;</span>);                    <span class="comment">// 传递右值，调用process(std::string&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(std::<span class="built_in">move</span>(name));          <span class="comment">// 传递右值，调用process(std::string&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Processing lvalue:</span> <span class="string">Alice</span></span><br><span class="line"><span class="attr">Processing rvalue:</span> <span class="string">Bob</span></span><br><span class="line"><span class="attr">Processing rvalue:</span> <span class="string">Alice</span></span><br></pre></td></tr></table></figure><p>在上述代码中：</p><ul><li><code>wrapper(name)</code>传递的是左值，<code>T</code>被推导为<code>std::string&amp;</code>，<code>std::forward</code>保持其为左值引用，调用<code>process(const std::string&amp;)</code>。</li><li><code>wrapper(&quot;Bob&quot;)</code>传递的是右值，<code>T</code>被推导为<code>const char*</code>，在<code>process</code>函数重载的选择上，这里简单化处理为调用接收右值的版本（视具体实现而定）。</li><li><code>wrapper(std::move(name))</code>传递的是右值，<code>T</code>被推导为<code>std::string</code>，<code>std::forward</code>将其转换为右值引用，调用<code>process(std::string&amp;&amp;)</code>。</li></ul><h3 id="4-5-泛型工厂函数示例"><a href="#4-5-泛型工厂函数示例" class="headerlink" title="4.5 泛型工厂函数示例"></a>4.5 泛型工厂函数示例</h3><p>以下示例展示了如何使用原样转发实现一个泛型工厂函数，完美转发构造函数的参数，以高效创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左值引用构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed Person(const std::string&amp;, int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右值引用构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(std::string&amp;&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(n)), <span class="built_in">age</span>(a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed Person(std::string&amp;&amp;, int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数，使用原样转发构造函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">create</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递左值</span></span><br><span class="line">    Person p1 = <span class="built_in">create</span>&lt;Person&gt;(name, <span class="number">30</span>); </span><br><span class="line">    <span class="comment">// 传递右值</span></span><br><span class="line">    Person p2 = <span class="built_in">create</span>&lt;Person&gt;(std::<span class="built_in">string</span>(<span class="string">&quot;Bob&quot;</span>), <span class="number">25</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructed <span class="title">Person</span>(<span class="params"><span class="keyword">const</span> std::<span class="built_in">string</span>&amp;, <span class="built_in">int</span></span>)</span></span><br><span class="line"><span class="function">Constructed <span class="title">Person</span>(<span class="params">std::<span class="built_in">string</span>&amp;&amp;, <span class="built_in">int</span></span>)</span></span><br></pre></td></tr></table></figure><p>在此示例中：</p><ul><li><code>create&lt;Person&gt;(name, 30)</code>传递的是左值，调用<code>Person(const std::string&amp;, int)</code>构造函数。</li><li><code>create&lt;Person&gt;(std::string(&quot;Bob&quot;), 25)</code>传递的是右值，调用<code>Person(std::string&amp;&amp;, int)</code>构造函数。</li></ul><p>通过原样转发，<code>create</code>函数能够根据传入参数的值类别，调用相应的构造函数，实现高效的对象创建。</p><h3 id="4-6-避免不必要的拷贝"><a href="#4-6-避免不必要的拷贝" class="headerlink" title="4.6 避免不必要的拷贝"></a>4.6 避免不必要的拷贝</h3><p>以下示例展示了如果不使用原样转发，可能导致的多次拷贝问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigObject</span>(<span class="type">const</span> std::string&amp; d) : <span class="built_in">data</span>(d) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BigObject constructed with lvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigObject</span>(std::string&amp;&amp; d) : <span class="built_in">data</span>(std::<span class="built_in">move</span>(d)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BigObject constructed with rvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数，左值和右值的重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> BigObject&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing lvalue BigObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(BigObject&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing rvalue BigObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装函数，不使用原样转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_wrapper</span><span class="params">(T&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(obj); <span class="comment">// 始终以左值形式传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装函数，使用原样转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_wrapper</span><span class="params">(T&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(obj)); <span class="comment">// 原样转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Sample data&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用bad_wrapper</span></span><br><span class="line">    BigObject bo1 = <span class="built_in">BigObject</span>(s);              <span class="comment">// 使用lvalue构造</span></span><br><span class="line">    BigObject bo2 = <span class="built_in">BigObject</span>(std::<span class="built_in">move</span>(s));   <span class="comment">// 使用rvalue构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bad_wrapper</span>(bo1); <span class="comment">// 始终作为左值处理</span></span><br><span class="line">    <span class="built_in">bad_wrapper</span>(<span class="built_in">BigObject</span>(<span class="string">&quot;Temp&quot;</span>)); <span class="comment">// 作为左值处理，浪费移动语义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用good_wrapper</span></span><br><span class="line">    <span class="built_in">good_wrapper</span>(bo1); <span class="comment">// 作为左值处理</span></span><br><span class="line">    <span class="built_in">good_wrapper</span>(<span class="built_in">BigObject</span>(<span class="string">&quot;Temp&quot;</span>)); <span class="comment">// 作为右值处理，利用移动语义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigObject constructed <span class="keyword">with</span> lvalue</span><br><span class="line">BigObject constructed <span class="keyword">with</span> rvalue</span><br><span class="line">Processing lvalue BigObject</span><br><span class="line">Processing lvalue BigObject</span><br><span class="line">BigObject constructed <span class="keyword">with</span> rvalue</span><br><span class="line">Processing rvalue BigObject</span><br></pre></td></tr></table></figure><p>在此示例中：</p><ul><li><code>bad_wrapper</code>函数不使用<code>std::forward</code>，导致即使传递的是右值，<code>process</code>函数也以左值形式接收，无法利用移动语义。</li><li><code>good_wrapper</code>函数使用<code>std::forward</code>，正确保持参数的值类别，允许<code>process</code>函数调用右值重载，从而利用移动语义，提高性能。</li></ul><hr><h2 id="5-forward源码剖析"><a href="#5-forward源码剖析" class="headerlink" title="5. forward源码剖析"></a>5. forward源码剖析</h2><p><code>std::forward</code>之所以能进行原样转发，我们来看一下源码，<code>std::forward</code>实现了两个版本</p><p><strong>返回左值引用版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="重点解释"><a href="#重点解释" class="headerlink" title="重点解释"></a>重点解释</h3><p><strong>1. <code>_GLIBCXX_NODISCARD</code></strong></p><p><strong><code>_GLIBCXX_NODISCARD</code></strong> 是一个宏，通常定义在 **libstdc++**（GNU的C++标准库实现）中，用于指示编译器不要忽略函数的返回值。具体来说，它通常被定义为 <strong>C++17</strong> 引入的 <code>[[nodiscard]]</code> 属性，或者对应的编译器特定属性。</p><ul><li><p><strong><code>[[nodiscard]]</code> 属性</strong>：这是C++17引入的一个属性，用于标记函数的返回值不应该被忽略。如果调用该函数的返回值被忽略，编译器会发出警告。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">compute</span>(); <span class="comment">// 编译器会发出警告，因为返回值被忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在<code>_GLIBCXX_NODISCARD</code>中的作用</strong>：通过使用这个宏，<code>forward</code>函数的设计者告诉编译器和使用者：调用 <code>forward</code> 时，返回值不应该被忽略，因为它在转发参数时起到了关键作用。如果返回值被忽略，可能会导致意想不到的行为或性能问题。</p></li></ul><p><strong>总结</strong>：<code>_GLIBCXX_NODISCARD</code> 确保使用 <code>forward</code> 时，返回的转发结果不会被无意中忽略，增强代码的安全性和正确性。</p><p><strong>2. <code>constexpr</code></strong></p><p><strong><code>constexpr</code></strong> 是C++11引入的一个关键字，用于指示一个函数或变量可以在编译时求值。</p><ul><li><strong>在函数中的作用</strong>：<ul><li><strong>编译时计算</strong>：<code>constexpr</code> 函数可以在编译时被求值，如果传入的参数也都是编译时常量。</li><li><strong>优化性能</strong>：通过在编译时进行计算，可以减少运行时的开销，提高程序的性能。</li></ul></li><li><strong>在 <code>forward</code> 函数中的作用</strong>：<ul><li><strong>高效实现</strong>：<code>forward</code> 是一个轻量级的操作，通常涉及简单的静态类型转换（如 <code>static_cast</code>）。将其定义为 <code>constexpr</code> 允许编译器在可能的情况下在编译时完成这些转换，从而避免不必要的运行时开销。</li><li><strong>支持常量表达式</strong>：如果在编译时上下文中使用 <code>forward</code>，例如在 <code>constexpr</code> 函数中，它能够在编译时正确地转发参数。</li></ul></li></ul><p><strong>总结</strong>：<code>constexpr</code> 使得 <code>forward</code> 函数能够在编译时进行优化，同时确保在运行时不引入额外的开销。</p><p><strong>3. <code>remove_reference</code>作用</strong></p><p>源码分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">remove_reference</span></span><br><span class="line">  &#123; <span class="keyword">using</span> type = _Tp; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Tp&amp;&gt;</span><br><span class="line">  &#123; <span class="keyword">using</span> type = _Tp; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Tp&amp;&amp;&gt;</span><br><span class="line">  &#123; <span class="keyword">using</span> type = _Tp; &#125;;</span><br></pre></td></tr></table></figure><p>根据模板就近匹配规则，会按照最相似的方式进行匹配，优先匹配特例化版本，比如</p><p><code>remove_reference&lt;int&gt;</code> 会调用第一个版本</p><p><code>remove_reference&lt;int&amp;&gt;</code>会调用第二个版本(特例化)</p><p><code>remove_reference&lt;int&amp;&amp;&gt;</code>会调用第三个版本</p><p>所以我们对比这三个版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="type">int</span>&gt;::type;</span><br><span class="line">remove_reference&lt;<span class="type">int</span>&amp;&gt;::type;</span><br><span class="line">remove_reference&lt;<span class="type">int</span>&amp;&amp;&gt;::type;</span><br></pre></td></tr></table></figure><p>这三个版本的type都为int，这样达到了去引用的效果。</p><p>所以带入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span></span><br></pre></td></tr></table></figure><p>我们可以指导__t一定是个左值引用类型。</p><p><strong>原样转发内幕</strong></p><p>此时我们考虑对一个左值引用类型(int&amp; )参数执行forward函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p><strong>函数各部分解释</strong>：</p><ul><li>**模板参数 <code>typename _Tp</code>**： 定义了一个模板类型参数 <code>_Tp</code>，表示要转发的类型。</li><li>**<code>typename std::remove_reference&lt;_Tp&gt;::type&amp; __t</code>**： 使用 <code>std::remove_reference</code> 去除 <code>_Tp</code> 的引用性质，然后以左值引用的形式接受参数。</li><li>**<code>static_cast&lt;_Tp&amp;&amp;&gt;(__t)</code>**： 通过 <code>static_cast</code> 将参数转换为 <code>_Tp</code> 类型的右值引用。这是实现完美转发的关键步骤，使得被转发的参数保留其原有的值类别。</li><li>**<code>noexcept</code>**： 指明函数不会抛出异常，有助于编译器进行优化，并提高代码的异常安全性。</li></ul><p>__t为int&amp;类型，TP被实例化为int&amp;,  通过引用折叠</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; std::forward&lt;<span class="type">int</span>&amp;&gt;(arg)</span><br></pre></td></tr></table></figure><p>达到了原样转发的目的。</p><p>**模板参数 <code>typename _Tp</code>**： 定义了一个模板类型参数 <code>_Tp</code>，表示要转发的类型。</p><p>同样我们分析右值引用类型原样转发原理</p><p><strong>返回右值引用版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value,</span><br><span class="line"> <span class="string">&quot;std::forward must not be used to convert an rvalue to an lvalue&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里限制了不能将右值引用转化为左值引用。</p><p><code>__t</code>是右值引用类型，当我们执行如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; forward&lt;<span class="type">int</span>&amp;&amp;&gt;(args)</span><br></pre></td></tr></table></figure><p><code>_Tp</code>被实例化为<code>int&amp;&amp;</code>, 返回类型通过折叠变为<code>int&amp;&amp;</code> , 参数<code>__t</code>变为<code>int&amp;&amp;</code>类型</p><h2 id="6-move源码解析"><a href="#6-move源码解析" class="headerlink" title="6. move源码解析"></a>6. move源码解析</h2><p><code>std::move</code>源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  _GLIBCXX_NODISCARD</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>可以看到move的实现很简单，无论<code>__t</code>是左值引用还是右值引用，都会通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>)</span><br></pre></td></tr></table></figure><p>强制转换为去除引用的type, 再加上<code>&amp;&amp;</code>的类型，也就是具体的右值引用类型。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li><strong>左值与右值</strong>：理解值类别是掌握C++移动语义、资源管理和高效编程的基础。左值代表具有持久存储的对象，而右值通常是临时对象。</li><li><strong>模板万能引用（转发引用）</strong>：通过<code>T&amp;&amp;</code>形式的模板参数，可以统一处理左值和右值，适用于泛型编程中的参数传递。引用折叠规则决定了<code>T&amp;&amp;</code>在不同上下文中的解析方式。</li><li><strong>类型推导</strong>：编译器根据实参自动推导模板参数类型，涉及引用类型时需要理解引用折叠规则和类型推导的细节。</li><li><strong>原样转发（Perfect Forwarding）</strong>：结合模板万能引用和<code>std::forward</code>，确保在泛型函数中将参数以其原有值类别传递给目标函数，避免不必要的拷贝，提升代码效率和灵活性。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-左值与右值&quot;&gt;&lt;a href=&quot;#1-左值与右值&quot; class=&quot;headerlink&quot; title=&quot;1. 左值与右值&quot;&gt;&lt;/a&gt;1. 左值与右值&lt;/h2&gt;&lt;h3 id=&quot;1-1-定义与分类&quot;&gt;&lt;a href=&quot;#1-1-定义与分类&quot; class=&quot;headerlink&quot; title=&quot;1.1 定义与分类&quot;&gt;&lt;/a&gt;1.1 定义与分类&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;左值（lvalue）&lt;/strong&gt;和&lt;strong&gt;右值（rvalue）&lt;/strong&gt;是C++中用于描述表达式值类别的重要概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左值（lvalue）&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;表示具有持久存储的对象。&lt;/li&gt;
&lt;li&gt;可以出现在赋值语句的左侧。&lt;/li&gt;
&lt;li&gt;可以被取地址（即，可以使用&lt;code&gt;&amp;amp;&lt;/code&gt;运算符）。&lt;/li&gt;
&lt;li&gt;示例：变量名、引用等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右值（rvalue）&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;表示临时对象或没有持久存储的值。&lt;/li&gt;
&lt;li&gt;通常出现在赋值语句的右侧。&lt;/li&gt;
&lt;li&gt;不能被取地址。&lt;/li&gt;
&lt;li&gt;示例：字面量、临时对象、表达式结果等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11进一步细化了右值的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;纯右值（prvalues）&lt;/strong&gt;：表示临时对象或字面量，如&lt;code&gt;42&lt;/code&gt;、&lt;code&gt;3.14&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将亡值（xvalues，expiring values）&lt;/strong&gt;：表示即将被移动的对象，如&lt;code&gt;std::move&lt;/code&gt;的结果。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>DeepSeek-R1本地部署知识库</title>
    <link href="http://www.limerence2017.com/2025/02/08/AI01/"/>
    <id>http://www.limerence2017.com/2025/02/08/AI01/</id>
    <published>2025-02-08T12:08:17.000Z</published>
    <updated>2025-02-09T04:49:09.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p>考虑大家看文档会比较吃力，可以参考我的视频教程</p><p><a href="https://www.bilibili.com/video/BV1GkNyeDEpK/?pop_share=1&vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9">https://www.bilibili.com/video/BV1GkNyeDEpK/?pop_share=1&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9</a></p><h2 id="DeepSeek简介"><a href="#DeepSeek简介" class="headerlink" title="DeepSeek简介"></a>DeepSeek简介</h2><p>深度求索人工智能基础技术研究有限公司(简称“深度求索”或“DeepSeek”)，成立于2023年，是一家专注于实现AGI的中国公司。</p><p>产品DeepSeek为一款AI工具，可以解析文本，生成代码，推理解析等。</p><h2 id="模型-amp-价格"><a href="#模型-amp-价格" class="headerlink" title="模型 &amp; 价格"></a>模型 &amp; 价格</h2><p>下表所列模型价格以“百万 tokens”为单位。Token 是模型用来表示自然语言文本的的最小单位，可以是一个词、一个数字或一个标点符号等。我们将根据模型输入和输出的总 token 数进行计量计费。</p><table><thead><tr><th>模型(1)</th><th>上下文长度</th><th>最大思维链长度(2)</th><th>最大输出长度(3)</th><th>百万tokens 输入价格 （缓存命中）(4)</th><th>百万tokens 输入价格 （缓存未命中）</th><th>百万tokens 输出价格 输出价格</th></tr></thead><tbody><tr><td>deepseek-chat</td><td>64K</td><td>-</td><td>8K</td><td>0.5元</td><td>2元</td><td>8元</td></tr><tr><td>deepseek-reasoner</td><td>64K</td><td>32K</td><td>8K</td><td>1元</td><td>4元</td><td>16元(5)</td></tr></tbody></table><ol><li><code>deepseek-chat</code> 模型已经升级为 <strong>DeepSeek-V3</strong>；<code>deepseek-reasoner</code> 模型为新模型 <strong>DeepSeek-R1</strong>。</li><li><strong>思维链</strong>为<code>deepseek-reasoner</code>模型在给出正式回答之前的思考过程，其原理详见<a href="https://api-docs.deepseek.com/zh-cn/guides/reasoning_model">推理模型</a>。</li><li>如未指定 <code>max_tokens</code>，默认最大输出长度为 4K。请调整 <code>max_tokens</code> 以支持更长的输出。</li><li>关于上下文缓存的细节，请参考<a href="https://api-docs.deepseek.com/zh-cn/news/news0802">DeepSeek 硬盘缓存</a>。</li><li><code>deepseek-reasoner</code>的输出 token 数包含了思维链和最终答案的所有 token，其计价相同。</li></ol><h2 id="性能对齐-OpenAI-o1-正式版"><a href="#性能对齐-OpenAI-o1-正式版" class="headerlink" title="性能对齐 OpenAI-o1 正式版"></a>性能对齐 OpenAI-o1 正式版</h2><p>DeepSeek-R1 在后训练阶段大规模使用了强化学习技术，在仅有极少标注数据的情况下，极大提升了模型推理能力。在数学、代码、自然语言推理等任务上，性能比肩 OpenAI o1 正式版。</p><p><img src="https://cdn.llfc.club/abbe5dcf3b85c33ded2d624fe84a2ec.png" alt="https://cdn.llfc.club/abbe5dcf3b85c33ded2d624fe84a2ec.png"></p><h2 id="蒸馏小模型超越-OpenAI-o1-mini"><a href="#蒸馏小模型超越-OpenAI-o1-mini" class="headerlink" title="蒸馏小模型超越 OpenAI o1-mini"></a>蒸馏小模型超越 OpenAI o1-mini</h2><p>在开源 DeepSeek-R1-Zero 和 DeepSeek-R1 两个 660B 模型的同时，通过 DeepSeek-R1 的输出，蒸馏了 6 个小模型开源给社区，其中 32B 和 70B 模型在多项能力上实现了对标 OpenAI o1-mini 的效果。</p><p><img src="https://dp-cdn-deepseek.obs.cn-east-3.myhuaweicloud.com/api-docs/deepseek_r1_benchmark_table.png" alt="img"></p><h2 id="API-及定价"><a href="#API-及定价" class="headerlink" title="API 及定价"></a>API 及定价</h2><p>DeepSeek-R1 API 服务定价为每百万输入 tokens 1 元（缓存命中）/ 4 元（缓存未命中），每百万输出 tokens 16 元。</p><p><img src="https://dp-cdn-deepseek.obs.cn-east-3.myhuaweicloud.com/api-docs/deepseek_r1_price.jpeg" alt="img"></p><p><img src="https://dp-cdn-deepseek.obs.cn-east-3.myhuaweicloud.com/api-docs/deepseek_r1_price_compare.png" alt="img"></p><p>详细的 API 调用指南请参考官方文档： <a href="https://api-docs.deepseek.com/zh-cn/guides/reasoning_model">https://api-docs.deepseek.com/zh-cn/guides/reasoning_model</a></p><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="Ollama-官方版：【点击前往】"><a href="#Ollama-官方版：【点击前往】" class="headerlink" title="Ollama 官方版：【点击前往】"></a><strong>Ollama 官方版：</strong>【<a href="https://ollama.com/">点击前往</a>】</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209105510.png" alt="image-20250209105503303"></p><p>下载windows版本并安装</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209111710.png" alt="image-20250209111710518"></p><p>我在windows做测试，然后部署</p><p>安装命令</p><p><strong>1.5B Qwen DeepSeek R1(需4G显存)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure><p><strong>7B Qwen DeepSeek R1(4~12G显存)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:7b</span><br></pre></td></tr></table></figure><p><strong>8B Llama DeepSeek R1(4~12G显存)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:8b</span><br></pre></td></tr></table></figure><p><strong>14B Qwen DeepSeek R1(12~24G显存)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:14b</span><br></pre></td></tr></table></figure><p><strong>32B Qwen DeepSeek R1(24G显存)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:32b</span><br></pre></td></tr></table></figure><p><strong>70B Llama DeepSeek R1(32G显存以上)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:70b</span><br></pre></td></tr></table></figure><p>我们选择1.5b模型安装</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209112145.png" alt="image-20250209112145406"></p><p>安装成功<img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209114003.png" alt="image-20250209114003740"></p><h3 id="AnythingLLM-下载"><a href="#AnythingLLM-下载" class="headerlink" title="AnythingLLM 下载"></a><strong>AnythingLLM</strong> 下载</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209114426.png" alt="image-20250209114426088"></p><p><strong>1、Github 开源版 【<a href="https://github.com/Mintplex-Labs/anything-llm">点击下载</a>】</strong></p><p><strong>2、官方版：【<a href="https://anythingllm.com/">点击下载</a>】</strong></p><p>我们选择开源版下载，拉到最下面有markdown文档</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209114631.png" alt="image-20250209114631891"></p><p>点击DownloadNow, 选择x64版本下载</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209115524.png" alt="image-20250209115524398"></p><p>下载完成，安装</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209115437.png" alt="image-20250209115436788"></p><p>安装完成</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209121534.png" alt="image-20250209121534198"></p><p>点击完成自动运行</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209121713.png" alt="image-20250209121713655"></p><p>点击Get started，然后一路跳过</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209121816.png" alt="image-20250209121816605"></p><p>记得填写邮箱和使用目的</p><p>然后再填写工作区</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122112.png" alt="image-20250209122112515"></p><p>点击右侧箭头完成，进入使用界面，如果此时使用会出现模型未设置</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122226.png" alt="image-20250209122226640"></p><p>点击设置按钮，选择聊天选项，接下来选择模型</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122457.png" alt="image-20250209122457152"></p><p>设置模型为ollama</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122532.png" alt="image-20250209122532873"></p><p>设置后</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122828.png" alt="image-20250209122828156"></p><p>记得更新</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122859.png" alt="image-20250209122859291"></p><p><strong>注意：本地部署也是支持开启联网搜索模式的</strong></p><p>点击设置按钮</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209123038.png" alt="image-20250209123038941"></p><p>只需在AnythingLLM的设置界面中，找到“代理技能”选项。 启用Web Search：在代理技能列表中找到 Web Search ，点击开启。 选择搜索引擎即可！</p><p>如下图所示:</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209123125.png" alt="image-20250209123125101"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试代码生成能力"><a href="#测试代码生成能力" class="headerlink" title="测试代码生成能力"></a>测试代码生成能力</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209124010.png" alt="image-20250209124009974"></p><h3 id="测试检索能力"><a href="#测试检索能力" class="headerlink" title="测试检索能力"></a>测试检索能力</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209124053.png" alt="image-20250209124053537"></p><h3 id="测试推理能力"><a href="#测试推理能力" class="headerlink" title="测试推理能力"></a>测试推理能力</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209124127.png" alt="image-20250209124127054"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视频教程&quot;&gt;&lt;a href=&quot;#视频教程&quot; class=&quot;headerlink&quot; title=&quot;视频教程&quot;&gt;&lt;/a&gt;视频教程&lt;/h2&gt;&lt;p&gt;考虑大家看文档会比较吃力，可以参考我的视频教程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.c</summary>
      
    
    
    
    <category term="AI" scheme="http://www.limerence2017.com/categories/AI/"/>
    
    
    <category term="AI" scheme="http://www.limerence2017.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>模板详解</title>
    <link href="http://www.limerence2017.com/2025/01/29/cppbase31/"/>
    <id>http://www.limerence2017.com/2025/01/29/cppbase31/</id>
    <published>2025-01-29T12:43:45.000Z</published>
    <updated>2025-02-15T04:33:10.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板基础"><a href="#模板基础" class="headerlink" title="模板基础"></a>模板基础</h2><p>C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板允许编写通用的函数，通过类型参数化，使其能够处理不同的数据类型。它通过模板参数定义与类型无关的函数。</p><p><strong>语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">functionName</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：最大值函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; std::endl;         <span class="comment">// int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3.14</span>, <span class="number">2.72</span>) &lt;&lt; std::endl;  <span class="comment">// double 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;    <span class="comment">// char 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">3.14</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li><strong>模板参数列表</strong>以 <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code> 开头，两者等价。</li><li><strong>类型推导</strong>：编译器根据函数参数自动推导模板参数类型。</li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板允许定义通用的类，通过类型参数化，实现不同类型的对象。</p><p><strong>语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T memberVariable;</span><br><span class="line">    <span class="comment">// 构造函数、成员函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例：简单的 Pair 类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: 1, 2.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, std::string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Hello, World</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="string">&quot;Age&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Age, 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Pair: 1, 2.5</span></span><br><span class="line"><span class="section">Pair: Hello, World</span></span><br><span class="line"><span class="section">Pair: Age, 30</span></span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>类模板可以有多个类型参数。</li><li>模板参数可以被用于成员变量和成员函数中。</li><li>类模板实例化时指定具体类型，如 <code>Pair&lt;int, double&gt;</code>。</li></ul><hr><h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>模板参数决定了模板的泛用性与灵活性。C++ 模板参数种类主要包括类型参数、非类型参数和模板模板参数。</p><h3 id="类型参数（Type-Parameters）"><a href="#类型参数（Type-Parameters）" class="headerlink" title="类型参数（Type Parameters）"></a>类型参数（Type Parameters）</h3><p>类型参数用于表示任意类型，在模板实例化时被具体的类型替代。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非类型参数（Non-Type-Parameters）"><a href="#非类型参数（Non-Type-Parameters）" class="headerlink" title="非类型参数（Non-Type Parameters）"></a>非类型参数（Non-Type Parameters）</h3><p>非类型参数允许模板接受非类型的值，如整数、指针或引用。C++17 支持更多非类型参数类型，如 <code>auto</code>。</p><p><strong>语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data[N];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例：固定大小的数组类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data[N];</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FixedArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    arr.<span class="built_in">print</span>(); <span class="comment">// 输出：0 10 20 30 40 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10 20 30 40 </span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>非类型参数必须是编译期常量。</li><li>允许的类型包括整型、枚举、指针、引用等，但不包括浮点数和类类型。</li></ul><h3 id="模板模板参数（Template-Template-Parameters）"><a href="#模板模板参数（Template-Template-Parameters）" class="headerlink" title="模板模板参数（Template Template Parameters）"></a>模板模板参数（Template Template Parameters）</h3><p>模板模板参数允许模板接受另一个模板作为参数。这对于抽象容器和策略模式等场景非常有用。</p><p><strong>语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>示例：容器适配器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Container&lt;T, std::allocator&lt;T&gt;&gt;&amp; container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : container)</span><br><span class="line">            std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ContainerPrinter&lt;std::vector, <span class="type">int</span>&gt; vecPrinter;</span><br><span class="line">    vecPrinter.<span class="built_in">print</span>(vec); <span class="comment">// 输出：1 2 3 4 5 </span></span><br><span class="line"></span><br><span class="line">    ContainerPrinter&lt;std::list, <span class="type">int</span>&gt; listPrinter;</span><br><span class="line">    listPrinter.<span class="built_in">print</span>(lst); <span class="comment">// 输出：10 20 30 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">10 20 30 </span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>模板模板参数需要完全匹配被接受模板的参数列表。</li><li>可通过默认模板参数增强灵活性。</li></ul><hr><h2 id="模板特化（Template-Specialization）"><a href="#模板特化（Template-Specialization）" class="headerlink" title="模板特化（Template Specialization）"></a>模板特化（Template Specialization）</h2><p>模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持<strong>全特化（Full Specialization）**和**偏特化（Partial Specialization）**，但需要注意的是，</strong>函数模板不支持偏特化**，只能进行全特化。</p><h3 id="全特化（Full-Specialization）"><a href="#全特化（Full-Specialization）" class="headerlink" title="全特化（Full Specialization）"></a>全特化（Full Specialization）</h3><p>全特化是针对模板参数的完全特定类型组合。它提供了模板的一个特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;SpecificType&gt; &#123;</span><br><span class="line">    <span class="comment">// 针对 SpecificType 的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：类模板全特化"><a href="#示例：类模板全特化" class="headerlink" title="示例：类模板全特化"></a>示例：类模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Printer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Printer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    intPrinter.<span class="built_in">print</span>(<span class="number">100</span>); <span class="comment">// 输出：General Printer: 100</span></span><br><span class="line"></span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    stringPrinter.<span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>); <span class="comment">// 输出：String Printer: Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">General Printer:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">String Printer:</span> <span class="string">Hello,</span> <span class="string">World!</span></span><br></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul><li><strong>通用模板</strong>适用于所有类型，在<code>print</code>函数中以通用方式输出值。</li><li><strong>全特化模板</strong>针对<code>std::string</code>类型进行了专门化，实现了不同的<code>print</code>函数。</li><li>当实例化<code>Printer&lt;std::string&gt;</code>时，编译器选择全特化版本而非通用模板。</li></ul><h3 id="偏特化（Partial-Specialization）"><a href="#偏特化（Partial-Specialization）" class="headerlink" title="偏特化（Partial Specialization）"></a>偏特化（Partial Specialization）</h3><p>偏特化允许模板对部分参数进行特定类型的处理，同时保持其他参数的通用性。对于<strong>类模板</strong>而言，可以针对模板参数的某些特性进行偏特化；对于<strong>函数模板</strong>，则仅支持全特化，不支持偏特化。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：当 U 是指针类型时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, U*&gt; &#123;</span><br><span class="line">    <span class="comment">// 针对 U* 的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：类模板偏特化"><a href="#示例：类模板偏特化" class="headerlink" title="示例：类模板偏特化"></a>示例：类模板偏特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用 Pair 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板偏特化：当第二个类型是指针时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U* second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U* b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair with pointer: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: 1, 2.5</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">3.14</span>;</span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">double</span>*&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Pi&quot;</span>, &amp;value)</span></span>;</span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair with pointer: Pi, 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Pair:</span> <span class="number">1</span>, <span class="number">2.5</span></span><br><span class="line">Pair <span class="keyword">with</span> pointer: Pi, <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul><li><strong>通用模板</strong>处理非指针类型对。</li><li><strong>偏特化模板</strong>处理第二个类型为指针的情况，打印指针指向的值。</li><li>使用偏特化提升了模板的灵活性，使其能够根据部分参数类型进行不同处理。</li></ul><h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>与类模板不同，<strong>函数模板不支持偏特化</strong>，只能进行全特化。当对函数模板进行全特化时，需要显式指定类型。</p><h4 id="示例：函数模板全特化"><a href="#示例：函数模板全特化" class="headerlink" title="示例：函数模板全特化"></a>示例：函数模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General print: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printValue</span>&lt;std::string&gt;(<span class="type">const</span> std::string&amp; value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized print for std::string: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>); <span class="comment">// 调用通用模板，输出：General print: 42</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">3.14</span>); <span class="comment">// 调用通用模板，输出：General print: 3.14</span></span><br><span class="line">    <span class="built_in">printValue</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 调用全特化模板，输出：Specialized print for std::string: Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">General <span class="built_in">print</span>: <span class="number">42</span></span><br><span class="line">General <span class="built_in">print</span>: <span class="number">3.14</span></span><br><span class="line">Specialized <span class="built_in">print</span> <span class="keyword">for</span> std::<span class="type">string</span>: Hello</span><br></pre></td></tr></table></figure><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><ul><li><strong>通用函数模板</strong>适用于所有类型，提供通用的<code>printValue</code>实现。</li><li><strong>全特化函数模板</strong>专门处理<code>std::string</code>类型，提供不同的输出格式。</li><li>调用<code>printValue</code>时，编译器根据实参类型选择适当的模板版本。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>优先级</strong>：全特化版本的优先级高于通用模板，因此当特化条件满足时，总是选择特化版本。</li><li><strong>显式指定类型</strong>：函数模板特化需要在调用时显式指定类型，或者确保类型推导可以正确匹配特化版本。</li><li><strong>不支持偏特化</strong>：无法通过偏特化对函数模板进行部分特化，需要通过其他方法（如重载）实现类似功能。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>全特化</strong>适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。</li><li><strong>偏特化</strong>仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。</li><li><strong>函数模板</strong>仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。</li><li><strong>特化模板</strong>提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。</li></ul><hr><h2 id="变参模板（Variadic-Templates）"><a href="#变参模板（Variadic-Templates）" class="headerlink" title="变参模板（Variadic Templates）"></a>变参模板（Variadic Templates）</h2><p>变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 <code>std::tuple</code>、<code>std::variant</code> 等模板库组件的基础。</p><h3 id="定义与语法"><a href="#定义与语法" class="headerlink" title="定义与语法"></a>定义与语法</h3><p>变参模板使用 <strong>参数包（Parameter Pack）</strong>，通过 <code>...</code> 语法来表示。</p><p><strong>语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(T first, Args... args)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="递归与展开（Recursion-and-Expansion）"><a href="#递归与展开（Recursion-and-Expansion）" class="headerlink" title="递归与展开（Recursion and Expansion）"></a>递归与展开（Recursion and Expansion）</h3><p>变参模板通常与递归相结合，通过递归地处理参数包，或者使用 <strong>折叠表达式（Fold Expressions）</strong> 来展开发参数包。</p><p><strong>递归示例：打印所有参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况：无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归情况：至少一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(<span class="type">const</span> T&amp; first, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">printAll</span>(args...); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printAll</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 输出：1 2.5 Hello A </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2.5</span> Hello <span class="selector-tag">A</span> </span><br></pre></td></tr></table></figure><p><strong>折叠表达式版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用折叠表达式的printAll</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用左折叠展开参数包，并在每个参数之后输出一个空格</span></span><br><span class="line">    ((std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ...);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printAll</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 输出：1 2.5 Hello A </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>折叠表达式示例：计算总和</strong></p><p>C++17 引入了折叠表达式，简化了参数包的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> -&gt; <span class="title">decltype</span><span class="params">((args + ...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.0</span>) &lt;&lt; std::endl; <span class="comment">// 输出：7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><p><strong>示例：日志记录器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况：无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归情况：至少一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg, <span class="type">const</span> T&amp; first, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;&quot;</span>, args...); <span class="comment">// 递归调用，省略消息前缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;Error&quot;</span>, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出：Error: 404 Not Found </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;Sum&quot;</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 输出：Sum: 10 20 30 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Error: 404 Not Found </span></span><br><span class="line"><span class="section">Sum: 10 20 30 </span></span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>变参模板极大地提升了模板的灵活性。</li><li>使用递归或折叠表达式处理参数包。</li><li>常用于实现通用函数、容器类和元编程工具。</li></ul><h2 id="模板折叠（Fold-Expressions）"><a href="#模板折叠（Fold-Expressions）" class="headerlink" title="模板折叠（Fold Expressions）"></a>模板折叠（Fold Expressions）</h2><h3 id="1-折叠表达式的概念与背景"><a href="#1-折叠表达式的概念与背景" class="headerlink" title="1. 折叠表达式的概念与背景"></a>1. 折叠表达式的概念与背景</h3><p>在C++中，<strong>可变参数模板</strong>允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。</p><p><strong>折叠表达式</strong>的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。</p><p><strong>折叠表达式</strong>可分为：</p><ul><li><strong>一元折叠表达式（Unary Fold）</strong>：对参数包中的每个参数应用一个一元操作符。</li><li><strong>二元折叠表达式（Binary Fold）</strong>：对参数包中的每个参数应用一个二元操作符。</li></ul><p>此外，<strong>二元折叠表达式</strong>可进一步细分为**左折叠（Left Fold）**和**右折叠（Right Fold）**，取决于操作符的结合方向。</p><h3 id="2-一元折叠表达式（Unary-Fold）"><a href="#2-一元折叠表达式（Unary-Fold）" class="headerlink" title="2. 一元折叠表达式（Unary Fold）"></a>2. 一元折叠表达式（Unary Fold）</h3><p><strong>一元折叠表达式</strong>用于在参数包的每个参数前或后应用一元操作符。语法形式如下：</p><p><strong>前置一元折叠（Unary Prefix Fold）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(op ... pack)</span><br></pre></td></tr></table></figure><p><strong>后置一元折叠（Unary Postfix Fold）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack ... op)</span><br></pre></td></tr></table></figure><p>其中，<code>op</code> 是一元操作符，如<code>!</code>（逻辑非）、<code>~</code>（按位取反）等。</p><p><strong>示例1：逻辑非操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个参数非操作，然后再将这些操作&amp;&amp;</span></span><br><span class="line"><span class="comment">//(!args &amp;&amp; ...) 相当于 !a &amp;&amp; !b &amp;&amp; ...</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allNot</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!args &amp;&amp; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二元折叠表达式（Binary-Fold）"><a href="#3-二元折叠表达式（Binary-Fold）" class="headerlink" title="3. 二元折叠表达式（Binary Fold）"></a>3. 二元折叠表达式（Binary Fold）</h3><p><strong>二元折叠表达式</strong>用于在参数包的每个参数之间应用一个二元操作符。它们可以分为**二元左折叠（Binary Left Fold）**和**二元右折叠（Binary Right Fold）**，取决于操作符的结合方向。</p><p><strong>二元折叠表达式语法</strong></p><ul><li><p><strong>二元左折叠（Left Fold）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(init op ... op pack)</span><br></pre></td></tr></table></figure><p>或者简化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack1 op ... op packN)</span><br></pre></td></tr></table></figure></li><li><p><strong>二元右折叠（Right Fold）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack1 op ... op init op ...)</span><br></pre></td></tr></table></figure><p>或者简化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack1 op ... op packN)</span><br></pre></td></tr></table></figure></li></ul><p>其中，<code>op</code> 是二元操作符，如<code>+</code>、<code>*</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;&lt;</code> 等。</p><p><strong>左折叠与右折叠的区别</strong></p><ul><li><strong>二元左折叠（Binary Left Fold）</strong>：操作符从左至右结合，等价于 <code>(((a op b) op c) op d)</code>。</li><li><strong>二元右折叠（Binary Right Fold）</strong>：操作符从右至左结合，等价于 <code>(a op (b op (c op d)))</code>。</li></ul><p><strong>示例1：求和（Binary Left Fold）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元左折叠：((arg1 + arg2) + arg3) + ... + argN</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumLeftFold</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sumLeftFold</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong><code>(args + ...)</code></strong> 是一个二元左折叠表达式。</li><li>它将<code>+</code>操作符逐个应用于参数，按照左折叠顺序。</li><li>即，<code>((1 + 2) + 3) + 4 = 10</code>。</li><li></li></ul><p><strong>示例2：乘积（Binary Right Fold）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元右折叠：arg1 * (arg2 * (arg3 * ... * argN))</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">productRightFold</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... * args); <span class="comment">// 右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">productRightFold</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong><code>(... \* args)</code></strong> 是一个二元右折叠表达式。</li><li>它将<code>*</code>操作符逐个应用于参数，按照右折叠顺序。</li><li>即，<code>2 * (3 * 4) = 2 * 12 = 24</code>。</li></ul><p><strong>示例3：逻辑与（Binary Left Fold）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; std::endl; <span class="comment">// 输出：false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong><code>(args &amp;&amp; ...)</code></strong> 是一个二元左折叠表达式。</li><li>用于检查所有参数是否为<code>true</code>。</li><li>类似于链式的逻辑与运算。</li></ul><hr><h3 id="4-左折叠与右折叠（Left-and-Right-Folds）"><a href="#4-左折叠与右折叠（Left-and-Right-Folds）" class="headerlink" title="4. 左折叠与右折叠（Left and Right Folds）"></a>4. 左折叠与右折叠（Left and Right Folds）</h3><p>了解<strong>左折叠</strong>和<strong>右折叠</strong>的区别，对于正确选择折叠表达式的形式至关重要。</p><p><strong>二元左折叠（Binary Left Fold）</strong></p><ul><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(args op ...)</span><br></pre></td></tr></table></figure></li><li><p><strong>展开方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((arg1 op arg2) op arg3) op ... op argN</span><br></pre></td></tr></table></figure></li><li><p><strong>适用场景</strong>：</p><ul><li>当操作符是结合性的且从左侧开始累积操作时（如<code>+</code>、<code>*</code>）。</li><li>需要严格的顺序执行时，确保从左到右依次处理参数。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(args + ...) <span class="comment">// 左折叠求和</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>二元右折叠（Binary Right Fold）</strong></p><ul><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... op args)</span><br></pre></td></tr></table></figure></li><li><p><strong>展开方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">arg1 <span class="title">op</span> <span class="params">(arg2 op (arg3 op ... op argN))</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>适用场景</strong>：</p><ul><li>当操作符是右结合的，或当需要从右侧开始累积操作时。</li><li>某些特定的逻辑和数据结构可能需要右侧先处理。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... + args) <span class="comment">// 右折叠求和</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>嵌套折叠表达式</strong></p><p>在某些复杂场景下，可能需要嵌套使用左折叠和右折叠，以达到特定的操作顺序。例如，结合多个不同的操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">complexFold</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先左折叠求和，然后右折叠求乘积</span></span><br><span class="line">    <span class="keyword">return</span> (args + ...) * (... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">complexFold</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// (1+2+3) * (1+2+3) = 6 * 6 = 36</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>在此示例中，我们首先对参数进行左折叠求和，然后对参数进行右折叠求和，最后将两者相乘。</li><li>这种嵌套用途展示了折叠表达式的灵活性。</li></ul><hr><h3 id="5-op-在折叠表达式中的作用"><a href="#5-op-在折叠表达式中的作用" class="headerlink" title="5. op 在折叠表达式中的作用"></a>5. <code>op</code> 在折叠表达式中的作用</h3><p>在折叠表达式中，<code>op</code> 代表<strong>二元操作符</strong>，用于定义如何将参数包中的各个参数相互结合。<code>op</code> 可以是任何合法的二元操作符，包括但不限于：</p><ul><li><strong>算术操作符</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 等。</li><li><strong>逻辑操作符</strong>：<code>&amp;&amp;</code>、<code>||</code> 等。</li><li><strong>按位操作符</strong>：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code> 等。</li><li><strong>比较操作符</strong>：<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 等。</li><li><strong>自定义操作符</strong>：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。</li></ul><p><strong><code>op</code> 的选择直接影响折叠表达式的行为和结果</strong>。选择适当的操作符是实现特定功能的关键。</p><p><strong>示例1：使用加法操作符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">addAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 使用 &#x27;+&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">addAll</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：使用逻辑与操作符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...); <span class="comment">// 使用 &#x27;&amp;&amp;&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; std::endl; <span class="comment">// 输出：false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例3：使用左移操作符（流插入）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="comment">// 使用 &#x27;&lt;&lt;&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printAll</span>(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出：Hello, world!123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><p>在上述示例中，<code>op</code> 分别为 <code>+</code>、<code>&amp;&amp;</code>、<code>&lt;&lt;</code>。</p></li><li><p>每个操作符定义了如何将参数包中的元素相互结合。</p></li></ul><p><strong>示例4：使用自定义操作符</strong></p><p>假设有一个自定义类型<code>Point</code>，并重载了<code>+</code>操作符以支持点的相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &#x27;+&#x27; 操作符</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point&#123; x + other.x, y + other.y &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元左折叠：((p1 + p2) + p3) + ... + pN</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">Point <span class="title">sumPoints</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 使用 &#x27;+&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, p2&#123;<span class="number">3</span>, <span class="number">4</span>&#125;, p3&#123;<span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Point result = <span class="built_in">sumPoints</span>(p1, p2, p3);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of Points: (&quot;</span> &lt;&lt; result.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; result.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>; <span class="comment">// 输出：(9, 12)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>通过重载<code>+</code>操作符，<code>sumPoints</code>函数能够将多个<code>Point</code>对象相加，得到累积的结果。</li></ul><h3 id="6-示例代码与应用"><a href="#6-示例代码与应用" class="headerlink" title="6. 示例代码与应用"></a>6. 示例代码与应用</h3><p>为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。</p><p><strong>示例1：字符串拼接</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">concatenate</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::string&#123;&#125; + ... + args); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">concatenate</span>(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot; Have a nice day.&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出：Hello, world! Have a nice day.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：计算逻辑与</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">areAllTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">areAllTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;   <span class="comment">// 输出：true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">areAllTrue</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例3：计算最大值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">maxAll</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::max)(first, ... , args); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxAll</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出：9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述示例中的<code>(std::max)(first, ... , args)</code>是一个非标准用法，需要根据具体情况调整。通常，<code>std::max</code>不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用<code>std::initializer_list</code>或其他方法实现多参数的最大值计算。</p><p><strong>示例4：筛选逻辑</strong></p><p>假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args || ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">anyTrue</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl; <span class="comment">// 输出：true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">anyTrue</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>) &lt;&lt; std::endl; <span class="comment">// 输出：false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-注意事项与最佳实践"><a href="#7-注意事项与最佳实践" class="headerlink" title="7. 注意事项与最佳实践"></a>7. 注意事项与最佳实践</h3><p><strong>1. 操作符的选择</strong></p><p>选择合适的操作符（<code>op</code>）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。</p><p><strong>2. 操作符的结合性</strong></p><p>不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。</p><p><strong>3. 参数包的初始化</strong></p><p>在二元折叠表达式中，有时需要一个初始值（<code>init</code>）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumWithInit</span><span class="params">(<span class="type">int</span> init, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (init + ... + args); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sumWithInit</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出：16 (10 + 1 + 2 + 3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 参数包为空的情况</strong></p><p>如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和函数，如果参数包为空返回0</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args); <span class="comment">// 左折叠，初始值为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出：6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>() &lt;&lt; std::endl;        <span class="comment">// 输出：0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 与递归模板的比较</strong></p><p>折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。</p><p><strong>6. 编译器支持</strong></p><p>确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括：</p><ul><li><strong>GCC</strong>：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。</li><li><strong>Clang</strong>：从版本5开始支持C++17。</li><li><strong>MSVC（Visual Studio）</strong>：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。</li></ul><p><strong>7. 性能考虑</strong></p><p>折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。</p><hr><h2 id="SFINAE（Substitution-Failure-Is-Not-An-Error）"><a href="#SFINAE（Substitution-Failure-Is-Not-An-Error）" class="headerlink" title="SFINAE（Substitution Failure Is Not An Error）"></a>SFINAE（Substitution Failure Is Not An Error）</h2><h3 id="一、什么是SFINAE？"><a href="#一、什么是SFINAE？" class="headerlink" title="一、什么是SFINAE？"></a>一、什么是SFINAE？</h3><p><strong>SFINAE</strong> 是 “Substitution Failure Is Not An Error”（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。</p><h3 id="二、SFINAE的工作原理"><a href="#二、SFINAE的工作原理" class="headerlink" title="二、SFINAE的工作原理"></a>二、SFINAE的工作原理</h3><p>在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。</p><h3 id="三、SFINAE的应用场景"><a href="#三、SFINAE的应用场景" class="headerlink" title="三、SFINAE的应用场景"></a>三、SFINAE的应用场景</h3><ol><li><strong>函数重载选择</strong>：根据参数类型的不同选择不同的函数实现。</li><li><strong>类型特性检测</strong>：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。</li><li><strong>条件编译</strong>：根据模板参数的特性决定是否编译某些代码段。</li></ol><h3 id="四、SFINAE的基本用法"><a href="#四、SFINAE的基本用法" class="headerlink" title="四、SFINAE的基本用法"></a>四、SFINAE的基本用法</h3><p>SFINAE通常与<code>std::enable_if</code>、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。</p><p><strong>示例一：通过<code>std::enable_if</code>实现函数重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于整数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于浮点类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Floating point type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">10</span>);      <span class="comment">// 输出: Integral type: 10</span></span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">3.14</span>);    <span class="comment">// 输出: Floating point type: 3.14</span></span><br><span class="line">    <span class="comment">// print_type(&quot;Hello&quot;); // 编译错误，没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>std::enable_if</code> 根据条件 <code>std::is_integral&lt;T&gt;::value</code> 或 <code>std::is_floating_point&lt;T&gt;::value</code> 决定是否启用对应的函数模板。</li><li>当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。</li></ul><p><strong>示例二：检测类型是否具有特定成员</strong></p><p>假设我们需要实现一个函数，仅当类型 <code>T</code> 具有成员函数 <code>foo</code> 时才启用该函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助类型，检测是否存在成员函数 foo</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">has_foo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> yes[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> no[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="built_in">void</span> (U::*)()&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SFINAE</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> yes&amp; <span class="title">test</span><span class="params">(SFINAE&lt;U, &amp;U::foo&gt;*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> no&amp; <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="number">0</span>)) == <span class="built_in">sizeof</span>(yes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数仅在 T 有 foo() 成员时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_foo&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutFoo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf); <span class="comment">// 输出: WithFoo::foo() \n foo() called.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithoutFoo wf2;</span></span><br><span class="line">    <span class="comment">// call_foo(wf2); // 编译错误，没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>has_foo</code> 是一个类型萃取类，用于检测类型 <code>T</code> 是否具有成员函数 <code>foo</code>。</li><li><code>call_foo</code> 函数模板仅在 <code>T</code> 具有 <code>foo</code> 成员时启用。</li><li>对于不具有 <code>foo</code> 成员的类型，编译器会忽略 <code>call_foo</code>，从而避免编译错误。</li></ul><p><strong>示例三：通过模板特化实现不同的行为</strong></p><p>以下是完整的、正确实现 <code>TypePrinter</code> 的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个 Trait 用于检测 T 是否有非 void 的 `value_type`</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_non_void_value_type : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当 T 有 `value_type` 且 `value_type` 不是 void 时，特化为 std::true_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_non_void_value_type</span>&lt;T, std::<span class="type">enable_if_t</span>&lt;!std::is_void_v&lt;<span class="keyword">typename</span> T::value_type&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义 TypePrinter 主模板，使用一个布尔参数控制特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> HasValueType = has_non_void_value_type&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> TypePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 特化：当 HasValueType 为 true 时，表示 T 有非 void 的 `value_type`</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypePrinter</span>&lt;T, <span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T has a member type &#x27;value_type&#x27;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化：当 HasValueType 为 false 时，表示 T 没有 `value_type` 或 `value_type` 是 void</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypePrinter</span>&lt;T, <span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world! T does not have a member type &#x27;value_type&#x27;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithValueType</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutValueType</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithVoidValueType</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypePrinter&lt;WithValueType&gt;::<span class="built_in">print</span>();        <span class="comment">// 输出: T has a member type &#x27;value_type&#x27;.</span></span><br><span class="line">    TypePrinter&lt;WithoutValueType&gt;::<span class="built_in">print</span>();     <span class="comment">// 输出: hello world! T does not have a member type &#x27;value_type&#x27;.</span></span><br><span class="line">    TypePrinter&lt;WithVoidValueType&gt;::<span class="built_in">print</span>();    <span class="comment">// 输出: hello world! T does not have a member type &#x27;value_type&#x27;.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>Trait <code>has_non_void_value_type</code></strong>:<ul><li><strong>主模板</strong>：默认情况下，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::false_type</code>，表示 <code>T</code> 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>。</li><li><strong>特化模板</strong>：仅当 <code>T</code> 有 <code>value_type</code> 且 <code>value_type</code> 不是 <code>void</code> 时，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::true_type</code>。</li></ul></li><li><strong><code>TypePrinter</code> 模板</strong>:<ul><li><strong>主模板</strong>：接受一个类型 <code>T</code> 和一个布尔模板参数 <code>HasValueType</code>，默认为 <code>has_non_void_value_type&lt;T&gt;::value</code>。</li><li>**特化版本 <code>TypePrinter&lt;T, true&gt;</code>**：当 <code>HasValueType</code> 为 <code>true</code> 时，表示 <code>T</code> 有非 <code>void</code> 的 <code>value_type</code>，提供相应的 <code>print</code> 实现。</li><li>**特化版本 <code>TypePrinter&lt;T, false&gt;</code>**：当 <code>HasValueType</code> 为 <code>false</code> 时，表示 <code>T</code> 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>，提供默认的 <code>print</code> 实现。</li></ul></li><li><strong>测试结构体</strong>：<ul><li><code>WithValueType</code>：有一个非 <code>void</code> 的 <code>value_type</code>。</li><li><code>WithoutValueType</code>：没有 <code>value_type</code>。</li><li><code>WithVoidValueType</code>：有一个 <code>value_type</code>，但它是 <code>void</code>。</li></ul></li><li><strong><code>main</code> 函数</strong>：<ul><li>分别测试了三种情况，验证 <code>TypePrinter</code> 的行为是否符合预期。</li></ul></li></ol><h3 id="五、SFINAE的优缺点"><a href="#五、SFINAE的优缺点" class="headerlink" title="五、SFINAE的优缺点"></a>五、SFINAE的优缺点</h3><p><strong>优点</strong>：</p><ol><li><strong>灵活性高</strong>：能够根据类型特性选择不同的实现，提升代码的泛化能力。</li><li><strong>类型安全</strong>：通过编译期检测，避免了运行时错误。</li><li><strong>无需额外的运行时开销</strong>：所有的类型筛选都在编译期完成。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>复杂性高</strong>：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。</li><li><strong>编译器错误信息难以理解</strong>：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。</li><li><strong>模板实例化深度限制</strong>：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。</li></ol><h3 id="六、现代C-中的替代方案"><a href="#六、现代C-中的替代方案" class="headerlink" title="六、现代C++中的替代方案"></a>六、现代C++中的替代方案</h3><p>随着C++11及后续标准的发展，引入了诸如<code>decltype</code>、<code>constexpr</code>、<code>if constexpr</code>、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的<strong>概念（Concepts）</strong>提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。</p><p><strong>示例：使用概念替代SFINAE</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个概念，要求类型 T 是整数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当 T 满足 Integral 概念时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">42</span>);        <span class="comment">// 输出: Integral type: 42</span></span><br><span class="line">    <span class="comment">// print_type(3.14);   // 编译错误，不满足 Integral 概念</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>使用概念<code>Integral</code>代替<code>std::enable_if</code>，语法更简洁，代码更易读。</li><li>当类型不满足概念时，编译器会给出明确的错误信息，便于调试。</li></ul><p>虽然上述方法经典且有效，但在C++11及以后版本，存在更简洁和易读的方式来实现相同的功能。例如，使用<code>std::void_t</code>和更现代的检测技巧，或者直接使用C++20的概念（Concepts），使代码更加清晰。</p><p><strong>示例：使用<code>std::void_t</code>简化<code>has_foo</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::void_t 简化 has_foo</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = std::<span class="type">void_t</span>&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> has_foo : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_foo</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">foo</span>())&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数仅在 T 有 foo() 成员时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;has_foo&lt;T&gt;::value, <span class="type">void</span>&gt;</span><br><span class="line"><span class="built_in">call_foo</span>(T&amp; obj) &#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutFoo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf); <span class="comment">// 输出: WithFoo::foo()</span></span><br><span class="line">                   <span class="comment">//      foo() called.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithoutFoo wf2;</span></span><br><span class="line">    <span class="comment">// call_foo(wf2); // 编译错误，没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>利用<code>std::void_t</code>，<code>has_foo</code>结构更为简洁。</li><li><code>decltype(std::declval&lt;T&gt;().foo())</code>尝试在不实例化<code>T</code>对象的情况下检测<code>foo()</code>成员函数。</li><li>如果<code>foo()</code>存在，<code>has_foo&lt;T&gt;</code>继承自<code>std::true_type</code>，否则继承自<code>std::false_type</code>。</li></ul><p><strong>使用C++20概念</strong></p><p>如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个概念，要求类型 T 具有 void foo()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> HasFoo = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">    &#123; t.<span class="built_in">foo</span>() &#125; -&gt; std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当 T 满足 HasFoo 概念时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;HasFoo T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutFoo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf); <span class="comment">// 输出: WithFoo::foo()</span></span><br><span class="line">                   <span class="comment">//      foo() called.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithoutFoo wf2;</span></span><br><span class="line">    <span class="comment">// call_foo(wf2); // 编译错误，不满足 HasFoo 概念</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong><code>HasFoo</code>概念</strong>：使用<code>requires</code>表达式检测类型<code>T</code>是否具有<code>void foo()</code>成员函数。</li><li><strong><code>call_foo</code>函数模板</strong>：仅当<code>T</code>满足<code>HasFoo</code>概念时，模板被启用。</li><li>这种方式更直观，易于理解和维护。</li></ul><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。</p><hr><h2 id="综合案例：结合模板特化与折叠表达式"><a href="#综合案例：结合模板特化与折叠表达式" class="headerlink" title="综合案例：结合模板特化与折叠表达式"></a>综合案例：结合模板特化与折叠表达式</h2><p>为了进一步巩固对模板特化和折叠表达式的理解，本节将通过一个综合案例展示如何将两者结合使用。</p><h3 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h3><p>实现一个通用的日志记录器<code>Logger</code>，能够处理任意数量和类型的参数，并根据不同的类型组合调整输出格式。具体需求包括：</p><ol><li>对于普通类型，使用通用的打印格式。</li><li>对于指针类型，打印指针地址或指向的值。</li><li>对于<code>std::string</code>类型，使用专门的格式。</li><li>支持可变数量的参数，通过折叠表达式实现参数的逐一打印。</li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>**定义通用类模板<code>Logger</code>**，使用模板特化和偏特化处理不同类型。</li><li><strong>实现<code>log</code>函数</strong>，使用模板折叠表达式逐一打印参数。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Logger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">log</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Logger: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板偏特化：当 T 是指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;T, <span class="keyword">typename</span> std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板全特化：当 T 是 std::string</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Logger: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板，用于递归调用 Logger::log</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logOne</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    Logger&lt;T&gt;::<span class="built_in">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板折叠表达式实现多参数日志记录</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">logOne</span>(args), ...); <span class="comment">// 左折叠，调用 logOne 对每个参数进行日志记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;a;</span><br><span class="line">    <span class="type">double</span>* pNull = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Logger 类模板进行特化打印</span></span><br><span class="line">    Logger&lt;<span class="type">int</span>&gt;::<span class="built_in">log</span>(a);          <span class="comment">// 输出：General Logger: 10</span></span><br><span class="line">    Logger&lt;<span class="type">double</span>*&gt;::<span class="built_in">log</span>(pNull);  <span class="comment">// 输出：Pointer Logger: nullptr</span></span><br><span class="line">    Logger&lt;std::string&gt;::<span class="built_in">log</span>(s);  <span class="comment">// 输出：String Logger: &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nLogging multiple parameters:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">logAll</span>(a, b, s, ptr, pNull);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    General Logger: 10</span></span><br><span class="line"><span class="comment">    General Logger: 3.14</span></span><br><span class="line"><span class="comment">    String Logger: &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment">    Pointer Logger: 10</span></span><br><span class="line"><span class="comment">    Pointer Logger: nullptr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">General Logger:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Pointer Logger:</span> <span class="string">nullptr</span></span><br><span class="line"><span class="attr">String Logger:</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Logging multiple parameters:</span></span><br><span class="line"><span class="attr">General Logger:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">General Logger:</span> <span class="number">3.14</span></span><br><span class="line"><span class="attr">String Logger:</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="attr">Pointer Logger:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Pointer Logger:</span> <span class="string">nullptr</span></span><br></pre></td></tr></table></figure><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><ol><li>**通用模板<code>Logger&lt;T, Enable&gt;</code>**：<ul><li>使用第二个模板参数<code>Enable</code>与SFINAE（Substitution Failure Is Not An Error）结合，控制模板特化。</li><li>对于非指针类型和非<code>std::string</code>类型，使用通用实现，打印<code>&quot;General Logger: value&quot;</code>。</li></ul></li><li>**类模板偏特化<code>Logger&lt;T, Enable&gt;</code>**：<ul><li>使用<code>std::enable_if</code>和<code>std::is_pointer</code>，当<code>T</code>是指针类型时，特化模板。</li><li>实现指针类型的特殊日志处理，打印指针指向的值或<code>nullptr</code>。</li></ul></li><li>**类模板全特化<code>Logger&lt;std::string&gt;</code>**：<ul><li>为<code>std::string</code>类型提供全特化版本，使用不同的输出格式。</li></ul></li><li><strong><code>logOne</code>函数模板</strong>：<ul><li>简化调用过程，调用相应的<code>Logger&lt;T&gt;::log</code>方法。</li></ul></li><li><strong><code>logAll</code>函数模板</strong>：<ul><li>使用模板折叠表达式<code>(logOne(args), ...)</code>，实现对所有参数的逐一日志记录。</li><li>通过左折叠的逗号表达式，确保每个<code>logOne</code>调用依次执行。</li></ul></li><li><strong><code>main</code>函数</strong>：<ul><li>测试不同类型的日志记录，包括普通类型、指针类型和<code>std::string</code>类型。</li><li>调用<code>logAll</code>函数，实现多参数的综合日志记录。</li></ul></li></ol><h2 id="模板元编程（Template-Metaprogramming）"><a href="#模板元编程（Template-Metaprogramming）" class="headerlink" title="模板元编程（Template Metaprogramming）"></a>模板元编程（Template Metaprogramming）</h2><ul><li><strong>什么是模板元编程</strong>：模板元编程（Template Metaprogramming）是一种在编译期通过模板机制进行代码生成和计算的编程技术。它利用编译器的模板实例化机制，在编译期间执行代码逻辑，以提高程序的性能和灵活性。</li><li><strong>模板元编程的优势</strong>：<ul><li>提高代码的可重用性和泛化能力。</li><li>在编译期进行复杂计算，减少运行时开销。</li><li>实现类型安全的高级抽象。</li></ul></li></ul><h3 id="模板元编程基础"><a href="#模板元编程基础" class="headerlink" title="模板元编程基础"></a>模板元编程基础</h3><ul><li><strong>模板特化（Template Specialization）</strong>：<ul><li><strong>全特化（Full Specialization）</strong>：为特定类型提供特定实现。</li><li><strong>偏特化（Partial Specialization）</strong>：为部分模板参数特定的情况提供实现。</li></ul></li><li><strong>递归模板（Recursive Templates）</strong>：利用模板的递归实例化机制，实现编译期计算。</li></ul><h3 id="编译期计算"><a href="#编译期计算" class="headerlink" title="编译期计算"></a>编译期计算</h3><p>模板元编程允许在编译时执行计算，如计算阶乘、斐波那契数列等。</p><p><strong>示例：编译期阶乘</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5! = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：5! = 120</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0! = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">0</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：0! = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br><span class="line">0! = 1</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li><strong>基本模板</strong> <code>Factorial</code>定义了一个静态常量<code>value</code>，其值为<code>N * Factorial&lt;N - 1&gt;::value</code>，实现递归计算。</li><li><strong>特化模板</strong> <code>Factorial&lt;0&gt;</code>定义递归终止条件，当<code>N=0</code>时，<code>value</code>为1。</li><li>在<code>main</code>函数中，通过<code>Factorial&lt;5&gt;::value</code>获取5的阶乘结果，编译期即生成其值。</li></ol><p><strong>静态成员变量的基本规则</strong></p><p>在 C++ 中，静态成员变量的声明与定义有以下基本规则：</p><ol><li><strong>声明（Declaration）</strong>：在类内部声明静态成员变量，告诉编译器该类包含这个静态成员。</li><li><strong>定义（Definition）</strong>：在类外部对静态成员变量进行定义，分配存储空间。</li></ol><p>通常，对于非 <code>constexpr</code> 或非 <code>inline</code> 的静态成员变量，<strong>必须</strong> 在类外进行定义，否则会导致链接器错误（undefined reference）。</p><p><strong>特殊情况：<code>static const</code> 整数成员</strong></p><p>对于 <code>static const</code> <strong>整数类型</strong> 的静态成员变量，C++ 标准做了一些特殊的处理：</p><ul><li><p><strong>类内初始化</strong>：你可以在类内部初始化 <code>static const</code> 整数成员变量，例如 <code>static const int value = 42;</code>。</p></li><li><p>使用场景</p><p>：</p><ul><li><strong>不需要类外定义</strong>：在某些情况下，编译器在编译阶段可以直接使用类内的初始化值，无需类外定义。</li><li><strong>需要类外定义</strong>：如果你在程序中对该静态成员变量进行取址（例如，<code>&amp;Factorial&lt;5&gt;::value</code>），或者在其他需要该变量的存储位置时，就需要在类外进行定义。</li></ul></li></ul><p><strong>C++11 及之前的标准</strong></p><p>在 C++11 及更早的标准中，对于 <code>static const</code> 整数成员变量：</p><ul><li><p>不需要类外定义的情况</p><p>：</p><ul><li>仅在作为编译期常量使用时，不需要类外定义。例如，用于数组大小、模板参数等。</li></ul></li><li><p>需要类外定义的情况</p><p>：</p><ul><li><p>当你需要对变量进行取址，或者在需要其存储位置时，必须在类外定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Factorial&lt;N&gt;::value;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>C++17 及更新标准</strong></p><p>从 C++17 开始，引入了 <strong>内联变量（inline variables）</strong>，使得在类内定义静态成员变量变得更加灵活：</p><ul><li><p>内联静态成员变量</p><p>：</p><ul><li>使用 <code>inline</code> 关键字，可以在类内对静态成员变量进行定义，无需在类外进行单独定义。</li><li>这适用于 C++17 及更高版本。</li></ul></li></ul><p>例如，你可以这样编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，无需在类外进行定义，因为 <code>inline</code> 确保了该变量在每个翻译单元中都只有一个实例。</p><p><strong>在 C++11 及之前的标准</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>作为编译期常量使用</p><p>：</p><ul><li>例如，用于其他模板参数或编译期常量计算时，不需要类外定义。</li></ul></li><li><p>取址或需要存储位置时</p><p>：</p><ul><li><p>需要在类外进行定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Factorial&lt;N&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Factorial&lt;<span class="number">0</span>&gt;::value;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>在 C++17 及更高标准</strong></p><p>如果你使用 C++17 及更高版本，可以使用 <code>inline</code> 关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>无需类外定义</p><p>：</p><ul><li><code>inline</code> 使得在类内的定义成为唯一的定义，即使在多个翻译单元中使用，也不会导致重复定义错误。</li></ul></li></ul><p><strong>实际示例与测试</strong></p><p><strong>示例 1：仅作为编译期常量使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的 Factorial 模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial&lt;5&gt;::value = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>C++11 及之前</strong>：无需类外定义。</li><li><strong>C++17 及更新</strong>：同样无需类外定义，且可以使用 <code>inline</code> 进一步优化。</li></ul><p><strong>示例 2：取址</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的 Factorial 模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义（在 C++11 及之前需要）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Factorial&lt;N&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Factorial&lt;<span class="number">0</span>&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial&lt;5&gt;::value = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;Factorial&lt;5&gt;::value = &quot;</span> &lt;&lt; &amp;Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>C++11 及之前</strong>：必须提供类外定义，否则会在链接时出现错误。</li><li><strong>C++17 及更新</strong>：若未使用 <code>inline</code>，仍需提供类外定义；使用 <code>inline</code> 则无需。</li></ul><p><strong>示例 3：使用 <code>inline</code>（C++17 及更高）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的 Factorial 模板（使用 inline）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial&lt;5&gt;::value = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;Factorial&lt;5&gt;::value = &quot;</span> &lt;&lt; &amp;Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++17 及以上：<ul><li>无需类外定义。</li><li><code>inline</code> 保证了多重定义的合法性。</li></ul></li></ul><p><strong>详细解析</strong></p><p><strong>为什么有这样的特殊处理？</strong></p><ul><li><p>优化与性能</p><p>：</p><ul><li>在编译期常量的情况下，不需要在运行时分配存储空间，编译器可以优化掉相关代码。</li></ul></li><li><p>兼容性</p><p>：</p><ul><li>早期 C++ 标准遵循这种规则，允许在类内初始化静态常量成员变量，便于模板元编程和常量表达式的使用。</li></ul></li><li><p><code>inline</code> 变量</p><p>：</p><ul><li>C++17 引入 <code>inline</code> 关键字用于变量，解决了静态成员变量在多个翻译单元中的定义问题，使得代码更简洁。</li></ul></li></ul><p><strong>是否总是需要定义？</strong></p><p>并非总是需要。关键在于 <strong>如何使用</strong> 这个静态成员变量：</p><ul><li><strong>仅作为编译期常量使用</strong>：无需类外定义。</li><li><strong>需要存储位置或取址</strong>：需要类外定义，除非使用 <code>inline</code>（C++17 及以上）。</li></ul><p><strong>编译器与链接器的行为</strong></p><ul><li><p>编译阶段</p><p>：</p><ul><li>类内的初始化用于编译期常量计算，不涉及存储分配。</li></ul></li><li><p>链接阶段</p><p>：</p><ul><li>如果没有类外定义，且静态成员被 odr-used（可能需要存储位置），链接器会报错，提示找不到符号定义。</li><li>使用 <code>inline</code> 关键字后，编译器处理为内联变量，避免了多重定义问题。</li></ul></li></ul><p><strong>示例：编译期斐波那契数列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci&lt;10&gt; = &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：Fibonacci&lt;10&gt; = 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci&lt;20&gt; = &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">20</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：Fibonacci&lt;20&gt; = 6765</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fibonacci</span>&lt;10&gt; <span class="operator">=</span> <span class="number">55</span></span><br><span class="line"><span class="type">Fibonacci</span>&lt;20&gt; <span class="operator">=</span> <span class="number">6765</span></span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>模板元编程利用编译期计算提升程序性能。</li><li>需要理解模板递归与终止条件。</li><li>常与类型特性和模板特化结合使用。</li></ul><h3 id="类型计算与SFINAE"><a href="#类型计算与SFINAE" class="headerlink" title="类型计算与SFINAE"></a>类型计算与SFINAE</h3><ul><li><strong>类型计算</strong>：在编译期进行类型的推导和转换。</li><li><strong>SFINAE（Substitution Failure Is Not An Error）</strong>：模板实例化过程中，如果某个替换失败，编译器不会报错，而是忽略该模板，并尝试其他匹配。</li></ul><p><strong>示例：检测类型是否可加</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否可以对T类型进行加法操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> is_addable : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_addable</span>&lt;T, <span class="keyword">decltype</span>(<span class="built_in">void</span>(std::<span class="built_in">declval</span>&lt;T&gt;() + std::<span class="built_in">declval</span>&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">static_assert</span>(is_addable&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int should be addable&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_addable&lt;<span class="type">void</span>*&gt;::value, <span class="string">&quot;void* should not be addable&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><p><strong>1. <code>struct is_addable&lt;...&gt; : std::true_type &#123;&#125;</code></strong></p><ul><li><strong>目的</strong>：定义一个名为 <code>is_addable</code> 的结构体模板，它继承自 <code>std::true_type</code>。</li><li><strong>作用</strong>：当特定的模板参数满足条件时，这个特化版本将被选中，表示 <code>T</code> 类型是可加的，即支持 <code>+</code> 操作符。</li></ul><p><strong>2. 模板参数解释：<code>&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt;</code></strong></p><ul><li>**<code>T</code>**：这是要检查的类型。</li><li>**<code>std::declval&lt;T&gt;()</code>**：<ul><li>用途：<code>std::declval&lt;T&gt;()</code> 是一个用于在不实际创建 <code>T</code> 类型对象的情况下，生成一个 <code>T</code> 类型的右值引用。</li><li>作用：它允许我们在编译时模拟 <code>T</code> 类型的对象，以便用于表达式的检测。</li></ul></li><li>**<code>std::declval&lt;T&gt;() + std::declval&lt;T&gt;()</code>**：<ul><li>表达式：尝试对两个 <code>T</code> 类型的右值引用进行加法运算。</li><li>目的：检查 <code>T</code> 类型是否支持 <code>+</code> 操作符。</li></ul></li><li>**<code>void(...)</code>**：<ul><li>将加法表达式的结果转换为 <code>void</code> 类型。这是为了在 <code>decltype</code> 中仅关心表达式是否有效，而不关心其具体类型。</li></ul></li><li>**<code>decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))</code>**：<ul><li>作用：如果 <code>T</code> 类型支持加法运算，则该 <code>decltype</code> 表达式的类型为 <code>void</code>，否则会导致替换失败</li></ul></li></ul><h3 id="高级模板元编程技巧"><a href="#高级模板元编程技巧" class="headerlink" title="高级模板元编程技巧"></a>高级模板元编程技巧</h3><ul><li><strong>变参模板（Variadic Templates）</strong>：支持模板参数包，实现更加灵活的模板定义。</li></ul><p><strong>示例：求和模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本递归模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;N, Ns...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N + Sum&lt;Ns...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = Sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::value; <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li><strong>基本模板</strong> <code>Sum</code>接受一个整数参数包<code>Ns...</code>。</li><li><strong>特化模板</strong> <code>Sum&lt;&gt;</code>定义递归终止条件，<code>value</code>为0。</li><li><strong>递归定义</strong> <code>Sum&lt;N, Ns...&gt;</code>将第一个参数<code>N</code>与剩余参数的和相加。</li><li>在<code>main</code>函数中，通过<code>Sum&lt;1, 2, 3, 4, 5&gt;::value</code>计算1+2+3+4+5=15。</li></ol><ul><li><strong>类型列表（Type Lists）</strong>：通过模板参数包管理类型的集合。</li></ul><p><strong>示例：类型列表和元素访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类型列表中第N个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, <span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = Head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> TypeAt&lt;TypeList&lt;Tail...&gt;, N - <span class="number">1</span>&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> list = TypeList&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> third_type = TypeAt&lt;list, <span class="number">2</span>&gt;::type; <span class="comment">// char</span></span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li>**<code>TypeList</code>**：定义一个包含多个类型的类型列表。</li><li><code>TypeAt</code>：通过递归模板，从<code>TypeList</code>中获取第N个类型。<ul><li>当N为0时，类型为<code>Head</code>。</li><li>否则，递归获取<code>Tail...</code>中第N-1个类型。</li></ul></li><li><strong>使用</strong>：定义<code>list</code>为<code>TypeList&lt;int, double, char&gt;</code>，<code>third_type</code>为第2个类型，即<code>char</code>。</li></ol><h3 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h3><p><strong>案例1：静态断言与类型检查</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_type</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = std::is_integral&lt;T&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">static_assert</span>(is_integral_type&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int is integral&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_integral_type&lt;<span class="type">float</span>&gt;::value, <span class="string">&quot;float is not integral&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>案例2：编译期字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>为什么需要外部定义 <code>value</code></strong></p><p>在 C++ 中，静态成员变量与类的实例无关，它们存在于全局命名空间中。然而，静态成员变量的声明和定义是不同的：</p><ol><li><strong>声明</strong>：告诉编译器类中存在这个变量。</li><li><strong>定义</strong>：为这个变量分配存储空间。</li></ol><p>对于非 <code>inline</code> 的静态成员变量，即使是 <code>constexpr</code>，都需要在类外部进行定义。否则，链接器在处理多个翻译单元时会因为找不到变量的定义而报错。</p><p><strong>具体原因</strong></p><ol><li><strong>模板类的静态成员变量</strong>：<ul><li>每当模板实例化时，都会产生一个新的类类型，每个类类型都有自己的一组静态成员变量。</li><li>因此，编译器需要知道这些静态成员变量在所有翻译单元中都唯一对应一个定义。</li></ul></li><li><strong><code>constexpr</code> 静态成员变量</strong>：<ul><li>从 C++17 开始，<code>inline</code> 关键字引入，使得 <code>constexpr</code> 静态成员变量可以在类内定义，并且隐式地具有 <code>inline</code> 属性。这意味着不需要在类外定义它们，因为 <code>inline</code> 确保了在多个翻译单元中有同一份定义。</li><li>但在 C++17 之前或不使用 <code>inline</code> 的情况下，即使是 <code>constexpr</code>，仍需在类外定义。</li></ul></li></ol><ul><li><strong>类内声明</strong>：<code>static constexpr char value[...]</code> 声明了 <code>value</code> 并给予了初始值。</li><li><strong>类外定义</strong>：<code>constexpr char String&lt;Cs...&gt;::value[...]</code> 为 <code>value</code> 分配了存储空间。</li></ul><p>如果省略类外定义，编译器会在链接阶段找不到 <code>value</code> 的定义，导致链接错误。这尤其适用于 C++14 及更早版本，以及 C++17 中未使用 <code>inline</code> 的情形。</p><p><strong>如何避免外部定义</strong></p><p>如果你使用的是 <strong>C++17</strong> 或更高版本，可以通过 <code>inline</code> 关键字将静态成员变量声明为 <code>inline</code>，从而在类内完成定义，无需再在外部定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure><p>在这个版本中，<code>inline</code> 关键字告诉编译器这是一个内联变量，允许在多个翻译单元中存在同一份定义，而不会导致重复定义错误。因此，无需在类外再次定义 <code>value</code>。</p><p><strong>完整示例对比</strong></p><p><strong>不使用 <code>inline</code>（需要类外定义）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问 value</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; hello::value;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>inline</code>（无需类外定义，C++17 起）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问 value</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; hello::value;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-20-Concepts"><a href="#C-20-Concepts" class="headerlink" title="C++20 Concepts"></a>C++20 Concepts</h2><p>C++20 引入了 <strong>Concepts</strong>，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。</p><h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><p><strong>定义一个 Concept</strong></p><p>Concepts 使用 <code>concept</code> 关键字定义，并作为函数或类模板的约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Concept：要求类型必须是可输出到 std::ostream</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Printable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">    &#123; std::cout &lt;&lt; a &#125; -&gt; std::same_as&lt;std::ostream&amp;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用 Concept 约束模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Concepts 约束函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;Printable T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">42</span>);          <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// print(std::vector&lt;int&gt;&#123;1, 2, 3&#125;); // 编译错误，std::vector&lt;int&gt; 不满足 Printable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制与约束"><a href="#限制与约束" class="headerlink" title="限制与约束"></a>限制与约束</h3><p>Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。</p><p><strong>示例：排序函数中的 Concepts</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可比较的概念</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序函数，约束类型必须可比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortVector</span><span class="params">(std::vector&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sortVector</span>(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：1 2 3 4 </span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::vector&lt;std::vector&lt;int&gt;&gt; vecs;</span></span><br><span class="line">    <span class="comment">// sortVector(vecs); // 编译错误，std::vector&lt;int&gt; 不满足 Comparable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 </span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>Concepts 提供了模板参数的语义约束。</li><li>使用 Concepts 提高模板的可读性和可维护性。</li><li>生成更友好的编译错误信息，易于调试。</li></ul><hr><h2 id="模板实例化与编译器行为"><a href="#模板实例化与编译器行为" class="headerlink" title="模板实例化与编译器行为"></a>模板实例化与编译器行为</h2><p>理解模板实例化的过程有助于进行有效的模板设计与优化，尤其是在涉及链接和编译时间时。</p><h3 id="显式实例化（Explicit-Instantiation）"><a href="#显式实例化（Explicit-Instantiation）" class="headerlink" title="显式实例化（Explicit Instantiation）"></a>显式实例化（Explicit Instantiation）</h3><p>显式实例化告诉编译器生成特定类型下的模板代码，主要用于分离模板的声明与定义，减少编译时间。</p><p><strong>语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明模板（通常在头文件中）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模板（通常在源文件中）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>示例：分离类模板的声明与定义</strong></p><p><em>MyClass.h</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure><p><em>MyClass.cpp</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">doSomething</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something with &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure><p><em>main.cpp</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with i</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyClass&lt;char&gt; obj3; // 链接错误，因为 MyClass&lt;char&gt; 未实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing something <span class="keyword">with</span> i</span><br><span class="line">Doing something <span class="keyword">with</span> d</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>显式实例化需要在模板定义后进行。</li><li>只有显式实例化的类型在未实例化时可用于模板分离。</li><li>未显式实例化的类型可能导致链接错误。</li></ul><h3 id="隐式实例化（Implicit-Instantiation）"><a href="#隐式实例化（Implicit-Instantiation）" class="headerlink" title="隐式实例化（Implicit Instantiation）"></a>隐式实例化（Implicit Instantiation）</h3><p>隐式实例化是编译器在模板被实际使用时自动生成对应实例代码的过程。通常，模板定义与使用都在头文件中完成。</p><p><strong>示例：</strong></p><p><em>MyClass.h</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something with &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure><p><em>main.cpp</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with i</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with d</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">char</span>&gt; obj3;</span><br><span class="line">    obj3.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Doing something <span class="keyword">with</span> i</span><br><span class="line">Doing something <span class="keyword">with</span> d</span><br><span class="line">Doing something <span class="keyword">with</span> c</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>隐式实例化不需要显式声明或定义。</li><li>模板定义必须在使用前可见，通常通过头文件实现。</li><li>容易导致编译时间增加，尤其是大型模板库。</li></ul><h3 id="链接时问题与解决方案"><a href="#链接时问题与解决方案" class="headerlink" title="链接时问题与解决方案"></a>链接时问题与解决方案</h3><p>由于模板是在使用时被实例化，跨源文件使用模板可能导致链接时问题，如重复定义或未定义引用。</p><p><strong>解决方案：</strong></p><ol><li><strong>内联实现</strong>：将模板的定义与声明一起放在头文件中，避免链接时重复定义。</li><li><strong>显式实例化</strong>：将常用的模板实例化放在源文件中，其他源文件通过 <code>extern</code> 或头文件引用已有实例。</li><li>**使用 <code>extern template</code>**：告知编译器某些模板实例已在其他源文件中显式实例化。</li></ol><p><strong>示例：使用 <code>extern template</code></strong></p><p><em>MyClass.h</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明模板实例，但不定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure><p><em>MyClass.cpp</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">doSomething</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something with &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure><p><em>main.cpp</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">doSomething</span>(); <span class="comment">// 使用已显式实例化的模板</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">doSomething</span>(); <span class="comment">// 使用已显式实例化的模板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyClass&lt;char&gt; obj3; // 链接错误，未实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ul><li>使用 <code>extern template</code> 声明已在其他源文件中实例化的模板。</li><li>减少编译时间和链接大小，防止重复定义。</li></ul><hr><h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><p>掌握模板的最佳实践有助于编写高效、可维护的代码，同时避免常见的陷阱和问题。</p><h3 id="模板定义与实现分离"><a href="#模板定义与实现分离" class="headerlink" title="模板定义与实现分离"></a>模板定义与实现分离</h3><p>对于类模板，通常将模板的声明和定义放在同一头文件中，以确保编译器在实例化模板时能够看到完整的定义。尽管可以尝试将模板定义分离到源文件，但需要结合显式实例化，这会增加复杂性，且不适用于广泛使用的模板。</p><p><strong>推荐做法：</strong></p><ul><li><strong>类模板</strong>：将声明和实现统一在头文件中。</li><li><strong>函数模板</strong>：同样将声明和实现统一在头文件中，或使用显式实例化。</li></ul><h3 id="避免过度模板化"><a href="#避免过度模板化" class="headerlink" title="避免过度模板化"></a>避免过度模板化</h3><p>虽然模板提供了极大的灵活性，但过度复杂的模板会导致代码难以理解、维护和编译时间增加。</p><p><strong>建议：</strong></p><ul><li>只在必要时使用模板。</li><li>保持模板的简单性和可读性，避免过度嵌套和复杂的特化。</li><li>合理使用类型特性和 Concepts 进行约束。</li></ul><h3 id="提高编译速度的方法"><a href="#提高编译速度的方法" class="headerlink" title="提高编译速度的方法"></a>提高编译速度的方法</h3><p>模板的广泛使用可能导致编译时间显著增加。以下方法有助于优化编译速度：</p><ol><li><strong>预编译头文件（Precompiled Headers）</strong>：将频繁使用的模板库放入预编译头中，加速编译。</li><li><strong>显式实例化</strong>：通过显式实例化减少模板的重复编译。</li><li><strong>模块化编程（C++20 Modules）</strong>：利用模块化将模板库进行编译和链接，减少编译时间。</li><li><strong>合理分割头文件</strong>：避免头文件中的模板定义过大，分割成较小的模块。</li></ol><h3 id="代码复用与库设计"><a href="#代码复用与库设计" class="headerlink" title="代码复用与库设计"></a>代码复用与库设计</h3><p>模板是实现高度复用库组件的有效手段，如标准库（<code>std::vector</code>、<code>std::map</code> 等）广泛使用模板。设计模板库时，需考虑以下因素：</p><ul><li><strong>接口的一致性</strong>：保持模板库的接口简洁、一致，便于使用者理解和使用。</li><li><strong>文档与示例</strong>：提供详细的文档和示例代码，帮助使用者理解模板库的用法。</li><li><strong>错误信息友好</strong>：通过 Concepts、SFINAE 等机制提供清晰的错误信息，降低使用门槛。</li><li><strong>性能优化</strong>：利用模板的编译期计算和内联等特性，提高库组件的性能。</li></ul><h3 id="避免模板错误的困惑"><a href="#避免模板错误的困惑" class="headerlink" title="避免模板错误的困惑"></a>避免模板错误的困惑</h3><p>模板错误通常复杂且难以理解，以下方法有助于减少模板错误的困惑：</p><ul><li><strong>逐步调试</strong>：从简单的模板开始，逐步增加复杂性，便于定位错误。</li><li><strong>使用编译器警告与工具</strong>：开启编译器的警告选项，使用静态分析工具检测模板代码中的问题。</li><li><strong>代码注释与文档</strong>：详细注释复杂的模板代码，提供文档说明其设计和用途。</li></ul><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C++ 模板机制是实现泛型编程的核心工具，通过类型参数化和编译期计算，极大地提升了代码的复用性、灵活性和性能。从基础的函数模板和类模板，到高级的模板特化、变参模板、模板元编程、SFINAE 和 Concepts，掌握模板的各个方面能够帮助开发者编写更高效、更加通用的 C++ 代码。</p><p>在实际应用中，合理运用模板不仅可以简化代码结构，还可以提高代码的可维护性和可扩展性。然而，模板的复杂性也要求开发者具备扎实的 C++ 基础和良好的编程习惯，以避免过度复杂化和难以调试的问题。</p><p>通过本教案的系统学习，相信您已经具备了全面理解和运用 C++ 模板的能力，能够在实际项目中高效地利用模板特性，编写出更为优秀的代码。</p><hr><h2 id="练习与习题"><a href="#练习与习题" class="headerlink" title="练习与习题"></a>练习与习题</h2><h3 id="练习-1：实现一个通用的-Swap-函数模板"><a href="#练习-1：实现一个通用的-Swap-函数模板" class="headerlink" title="练习 1：实现一个通用的 Swap 函数模板"></a>练习 1：实现一个通用的 Swap 函数模板</h3><p><strong>要求：</strong></p><ul><li>编写一个函数模板 <code>swapValues</code>，可以交换任意类型的两个变量。</li><li>在 <code>main</code> 函数中测试 <code>int</code>、<code>double</code>、<code>std::string</code> 类型的交换。</li></ul><p><strong>提示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。"><a href="#练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。" class="headerlink" title="练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。"></a>练习 2：实现一个模板类 <code>Triple</code>，存储三个相同类型的值，并提供获取各个成员的函数。</h3><p><strong>要求：</strong></p><ul><li>模板参数为类型 <code>T</code>。</li><li>提供构造函数、成员变量及访问函数。</li><li>在 <code>main</code> 中实例化 <code>Triple&lt;int&gt;</code> 和 <code>Triple&lt;std::string&gt;</code>，进行测试。</li></ul><h3 id="练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。"><a href="#练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。" class="headerlink" title="练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。"></a>练习 3：使用模板特化，为类模板 <code>Printer</code> 提供针对 <code>bool</code> 类型的全特化，实现专门的输出格式。</h3><p><strong>要求：</strong></p><ul><li>通用模板类 <code>Printer</code>，具有 <code>print</code> 函数，输出 <code>General Printer: value</code>。</li><li>全特化 <code>Printer&lt;bool&gt;</code>，输出 <code>Boolean Printer: true</code> 或 <code>Boolean Printer: false</code>。</li></ul><h3 id="练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。"><a href="#练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。" class="headerlink" title="练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。"></a>练习 4：实现一个变参模板函数 <code>logMessages</code>，可以接受任意数量和类型的参数，并依次打印它们。</h3><p><strong>要求：</strong></p><ul><li>使用递归方法实现。</li><li>在 <code>main</code> 中测试不同参数组合的调用。</li></ul><h3 id="练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。"><a href="#练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。" class="headerlink" title="练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。"></a>练习 5：编写模板元编程结构 <code>IsPointer</code>, 用于在编译期判断一个类型是否为指针类型。</h3><p><strong>要求：</strong></p><ul><li>定义 <code>IsPointer&lt;T&gt;</code>，包含 <code>value</code> 静态常量成员，值为 <code>true</code> 或 <code>false</code>。</li><li>使用特化进行实现。</li><li>在 <code>main</code> 中使用 <code>static_assert</code> 进行测试。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsPointer&lt;<span class="type">int</span>*&gt;::value, <span class="string">&quot;int* is a pointer&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!IsPointer&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int is not a pointer&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。"><a href="#练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。" class="headerlink" title="练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。"></a>练习 6：使用 SFINAE，编写一个函数模板 <code>enableIfExample</code>，只有当类型 <code>T</code> 具有 <code>size()</code> 成员函数时才启用。</h3><p><strong>要求：</strong></p><ul><li>使用 <code>std::enable_if</code> 和类型特性检测 <code>size()</code> 成员。</li><li>在 <code>main</code> 中测试 <code>std::vector&lt;int&gt;</code>（应启用）和 <code>int</code>（不应启用）。</li></ul><p><strong>提示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_size&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">enableIfExample</span><span class="params">(<span class="type">const</span> T&amp; container)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Container has size: &quot;</span> &lt;&lt; container.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。"><a href="#练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。" class="headerlink" title="练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。"></a>练习 7：使用 C++20 Concepts，定义一个 Concept <code>Integral</code>，要求类型必须是整型，并使用该 Concept 约束一个函数模板 <code>isEven</code>，判断传入的整数是否为偶数。</h3><p><strong>要求：</strong></p><ul><li>定义 <code>Integral</code> Concept。</li><li>编写函数模板 <code>isEven(u)</code>，仅接受满足 <code>Integral</code> 的类型。</li><li>在 <code>main</code> 中测试不同类型的调用。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"><a href="#练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。" class="headerlink" title="练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"></a>练习 8：实现一个固定大小的栈（<code>FixedStack</code>）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。</h3><p><strong>要求：</strong></p><ul><li>模板参数为类型 <code>T</code> 和 <code>std::size_t N</code>。</li><li>提供 <code>push</code>, <code>pop</code>, <code>top</code> 等成员函数。</li><li>在 <code>main</code> 中测试 <code>FixedStack&lt;int, 5&gt;</code> 和 <code>FixedStack&lt;std::string, 3&gt;</code>。</li></ul><h3 id="练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。"><a href="#练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。" class="headerlink" title="练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。"></a>练习 9：实现一个模板类 <code>TypeIdentity</code>，其成员类型 <code>type</code> 等同于模板参数 <code>T</code>。并使用 <code>static_assert</code> 检查类型关系。</h3><p><strong>要求：</strong></p><ul><li>定义 <code>TypeIdentity&lt;T&gt;</code>，包含类型成员 <code>type</code>。</li><li>使用 <code>std::is_same</code> 与 <code>static_assert</code> 验证。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;TypeIdentity&lt;<span class="type">int</span>&gt;::type, <span class="type">int</span>&gt;::value, <span class="string">&quot;TypeIdentity&lt;int&gt; should be int&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。"><a href="#练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。" class="headerlink" title="练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。"></a>练习 10：编写一个模板元编程结构 <code>LengthOf</code>, 用于在编译期计算类型列表的长度。</h3><p><strong>要求：</strong></p><ul><li>使用 <code>TypeList</code> 模板定义类型列表。</li><li>定义 <code>LengthOf&lt;TypeList&lt;...&gt;&gt;::value</code> 表示类型列表的长度。</li><li>在 <code>main</code> 中使用 <code>static_assert</code> 进行测试。</li></ul><p><strong>提示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>&lt;TypeList&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> value = <span class="keyword">sizeof</span>...(Ts);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>通过上述内容及练习，相信您已全面掌握了 C++ 模板的各个方面。从基础概念到高级技术，模板为 C++ 编程提供了强大的工具。持续练习与应用，将进一步巩固您的模板编程能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模板基础&quot;&gt;&lt;a href=&quot;#模板基础&quot; class=&quot;headerlink&quot; title=&quot;模板基础&quot;&gt;&lt;/a&gt;模板基础&lt;/h2&gt;&lt;p&gt;C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载详解</title>
    <link href="http://www.limerence2017.com/2025/01/23/cppbase30/"/>
    <id>http://www.limerence2017.com/2025/01/23/cppbase30/</id>
    <published>2025-01-23T11:57:06.000Z</published>
    <updated>2025-02-15T02:51:50.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运算符重载概述"><a href="#运算符重载概述" class="headerlink" title="运算符重载概述"></a>运算符重载概述</h2><p><strong>运算符重载（Operator Overloading）</strong>允许开发者为自定义类型定义或重新定义运算符的行为，使得自定义类型的对象能够使用与内置类型相同的运算符进行操作。这不仅提高了代码的可读性，还增强了代码的表达能力。</p><h2 id="为什么需要运算符重载"><a href="#为什么需要运算符重载" class="headerlink" title="为什么需要运算符重载"></a>为什么需要运算符重载</h2><p>在面向对象编程中，我们经常需要定义自己的类来表示某些实体（如复数、向量、矩形等）。为了使这些类的对象能够与内置类型一样方便地进行操作，运算符重载显得尤为重要。例如：</p><ul><li>对于复数类，使用 <code>+</code> 运算符进行加法运算。</li><li>对于字符串类，使用 <code>&lt;&lt;</code> 运算符进行输出。</li><li>对于矩阵类，使用 <code>*</code> 运算符进行矩阵乘法。</li></ul><p>通过运算符重载，可以使代码更简洁、直观，类似于数学表达式。</p><h2 id="运算符重载的规则与限制"><a href="#运算符重载的规则与限制" class="headerlink" title="运算符重载的规则与限制"></a>运算符重载的规则与限制</h2><ol><li><strong>不能改变运算符的优先级和结合性</strong>：运算符的优先级和结合性在编译阶段就确定，不能通过重载来改变。</li><li><strong>不能创建新的运算符</strong>：仅能重载C++中已有的运算符，不能定义新的运算符。</li><li><strong>至少有一个操作数必须是用户定义的类型</strong>：不能对两个内置类型进行运算符重载。</li><li><strong>某些运算符不能重载</strong>：包括 <code>.</code>（成员选择运算符）、<code>.*</code>、<code>::</code>、<code>?:</code>（条件运算符）等。</li><li><strong>重载运算符的优先级和结合性不可改变</strong>。</li></ol><h2 id="运算符重载的方法"><a href="#运算符重载的方法" class="headerlink" title="运算符重载的方法"></a>运算符重载的方法</h2><p>在C++中，运算符可以通过成员函数或非成员函数（通常是友元函数）来重载。</p><h3 id="成员函数方式"><a href="#成员函数方式" class="headerlink" title="成员函数方式"></a>成员函数方式</h3><p>运算符作为类的成员函数进行重载时，左操作数是当前对象（<code>this</code>）。因此，对于需要修改左操作数的运算符，成员函数方式通常更直观。</p><p><strong>语法示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassName <span class="keyword">operator</span>+(<span class="type">const</span> ClassName&amp; other);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非成员函数方式（友元函数）"><a href="#非成员函数方式（友元函数）" class="headerlink" title="非成员函数方式（友元函数）"></a>非成员函数方式（友元函数）</h3><p>当需要对两个不同类型的对象进行运算，或者左操作数不是当前类的对象时，通常使用非成员函数方式。为了访问类的私有成员，非成员函数通常被声明为类的友元函数。</p><p><strong>语法示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> ClassName <span class="keyword">operator</span>+(<span class="type">const</span> ClassName&amp; lhs, <span class="type">const</span> ClassName&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><h3 id="1-1-运算符"><a href="#1-1-运算符" class="headerlink" title="1.1 + 运算符"></a>1.1 <code>+</code> 运算符</h3><p><strong>作用</strong>：实现两个对象的加法操作。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real + other.real, <span class="keyword">this</span>-&gt;imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">    <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 + c2 = (<span class="number">4.5</span> + <span class="number">1.5i</span>)</span><br></pre></td></tr></table></figure><h3 id="1-2-运算符"><a href="#1-2-运算符" class="headerlink" title="1.2 - 运算符"></a>1.2 <code>-</code> 运算符</h3><p><strong>作用</strong>：实现两个对象的减法操作。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 - 运算符（成员函数）</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real - other.real, <span class="keyword">this</span>-&gt;imag - other.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.5</span>, <span class="number">-1.5</span>)</span></span>;</span><br><span class="line">    Complex c4 = c1 - c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span> &lt;&lt; c4 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 - c2 = (<span class="number">2.5</span> + <span class="number">7.5i</span>)</span><br></pre></td></tr></table></figure><h3 id="1-3-运算符"><a href="#1-3-运算符" class="headerlink" title="1.3 * 运算符"></a>1.3 <code>*</code> 运算符</h3><p><strong>作用</strong>：实现对象的乘法操作。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 * 运算符（成员函数）</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">    <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    Complex c5 = c1 * c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span> &lt;&lt; c5 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 * c2 = (<span class="number">13.5</span> + <span class="number">1i</span>)</span><br></pre></td></tr></table></figure><h3 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 / 运算符"></a>1.4 <code>/</code> 运算符</h3><p><strong>作用</strong>：实现对象的除法操作。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 / 运算符（成员函数）</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">    <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Complex c6 = c1 / c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span> &lt;&lt; c6 &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 / c2 = (<span class="number">-0.823529</span> + <span class="number">1.64706i</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2. 赋值运算符"></a>2. 赋值运算符</h2><h3 id="2-1-运算符"><a href="#2-1-运算符" class="headerlink" title="2.1 = 运算符"></a>2.1 <code>=</code> 运算符</h3><p><strong>作用</strong>：实现对象的赋值操作。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><p>C++编译器会自动生成默认的拷贝赋值运算符，但当类中包含动态分配内存或需要自定义行为时，需要自行重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符（成员函数）</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;real = other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">    <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    Complex c2;</span><br><span class="line">    c2 = c1; <span class="comment">// 使用拷贝赋值运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c2 = &quot;</span> &lt;&lt; c2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">c2</span> = (<span class="number">3</span> + <span class="number">4</span>i)</span><br></pre></td></tr></table></figure><h3 id="2-2-复合赋值运算符（-）"><a href="#2-2-复合赋值运算符（-）" class="headerlink" title="2.2 复合赋值运算符（+=, -=, *=, /=）"></a>2.2 复合赋值运算符（<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>）</h3><p><strong>作用</strong>：实现复合赋值操作，如 <code>+=</code>，<code>-=</code> 等。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 += 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real += other.real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag += other.imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 -= 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real -= other.real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag -= other.imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 *= 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">    <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 /= 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">    <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    c1 += c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 += c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    c1 -= c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 -= c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    c1 *= c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 *= c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c1 /= c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 /= c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 += c2: (<span class="number">4</span> + <span class="number">6i</span>)</span><br><span class="line">c1 -= c2: (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">c1 *= c2: (<span class="number">-5</span> + <span class="number">10i</span>)</span><br><span class="line">c1 /= c2: (<span class="number">2</span> + <span class="number">0i</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3. 比较运算符"></a>3. 比较运算符</h2><h3 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 == 运算符"></a>3.1 <code>==</code> 运算符</h3><p><strong>作用</strong>：判断两个对象是否相等。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 == 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 == 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="built_in">return</span> (lhs.real == rhs.real) &amp;&amp; (lhs.imag == rhs.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 == c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 和 c2 相等</span><br><span class="line">c1 和 c3 不相等</span><br></pre></td></tr></table></figure><h3 id="3-2-运算符"><a href="#3-2-运算符" class="headerlink" title="3.2 != 运算符"></a>3.2 <code>!=</code> 运算符</h3><p><strong>作用</strong>：判断两个对象是否不相等。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 != 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 != 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 != c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 != c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 和 c2 相等</span><br><span class="line">c1 和 c3 不相等</span><br></pre></td></tr></table></figure><h3 id="3-3-lt-gt-lt-gt-运算符"><a href="#3-3-lt-gt-lt-gt-运算符" class="headerlink" title="3.3 &lt;, &gt;, &lt;=, &gt;= 运算符"></a>3.3 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> 运算符</h3><p><strong>作用</strong>：实现对象之间的大小比较。对于复数来说，通常没有自然的大小顺序，但为了示例，可以定义复数的模长进行比较。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt; 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &gt; 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;= 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &gt;= 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt; 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="type">double</span> lhs_mod = std::<span class="built_in">sqrt</span>(lhs.real * lhs.real + lhs.imag * lhs.imag);</span><br><span class="line">    <span class="type">double</span> rhs_mod = std::<span class="built_in">sqrt</span>(rhs.real * rhs.real + rhs.imag * rhs.imag);</span><br><span class="line">    <span class="keyword">return</span> lhs_mod &lt; rhs_mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &gt; 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs &lt; lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;= 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(rhs &lt; lhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &gt;= 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs &lt; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>; <span class="comment">// 模长 5</span></span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>; <span class="comment">// 模长 sqrt(5) ≈ 2.236</span></span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>; <span class="comment">// 模长 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &lt; c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长小于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长不小于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长不大于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &lt;= c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长小于或等于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt;= c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于或等于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长小于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 的模长不小于 c2 的模长</span><br><span class="line">c1 的模长大于 c2 的模长</span><br><span class="line">c1 的模长小于或等于 c3 的模长</span><br><span class="line">c1 的模长大于或等于 c3 的模长</span><br></pre></td></tr></table></figure><hr><h2 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h2><h3 id="4-1-amp-amp-运算符"><a href="#4-1-amp-amp-运算符" class="headerlink" title="4.1 &amp;&amp;, ||, ! 运算符"></a>4.1 <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> 运算符</h3><p><strong>作用</strong>：实现逻辑操作。需要注意，C++ 中的 <code>&amp;&amp;</code> 和 <code>||</code> 运算符无法短路地重载，而且通常不建议重载它们，因为会改变其原有的逻辑语义。通常，建议使用类型转换或其他方法来实现逻辑判断。</p><p><strong>示例类</strong>：<code>Boolean</code> 类（用于示例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boolean</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Boolean</span>(<span class="type">bool</span> val = <span class="literal">false</span>) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑非运算符（!）（成员函数）</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑与运算符（&amp;）（非短路）（成员函数）</span></span><br><span class="line">    Boolean <span class="keyword">operator</span>&amp;(<span class="type">const</span> Boolean&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="keyword">this</span>-&gt;value &amp; other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑或运算符（|）（非短路）（成员函数）</span></span><br><span class="line">    Boolean <span class="keyword">operator</span>|(<span class="type">const</span> Boolean&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="keyword">this</span>-&gt;value | other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Boolean&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Boolean&amp; b) &#123;</span><br><span class="line">    os &lt;&lt; (b.value ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Boolean <span class="title">b1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Boolean <span class="title">b2</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Boolean b3 = b1 &amp; b2;</span><br><span class="line">    Boolean b4 = b1 | b2;</span><br><span class="line">    Boolean b5 = !b1;</span><br><span class="line">    Boolean b6 = !b2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 &amp; b2 = &quot;</span> &lt;&lt; b3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 | b2 = &quot;</span> &lt;&lt; b4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!b1 = &quot;</span> &lt;&lt; b5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!b2 = &quot;</span> &lt;&lt; b6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b1</span> <span class="string">&amp;</span> <span class="string">b2</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"><span class="string">b1</span> <span class="string">|</span> <span class="string">b2</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="type">!b1</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"><span class="type">!b2</span> <span class="string">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><strong>注意</strong>：在重载 <code>&amp;&amp;</code> 和 <code>||</code> 运算符时，要明白它们不会具有短路行为。因此，通常不建议重载这两个运算符。</li><li>本例中，使用 <code>&amp;</code> 和 <code>|</code> 运算符来模拟逻辑与、或操作。</li></ul><hr><h2 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h2><h3 id="5-1-amp-运算符"><a href="#5-1-amp-运算符" class="headerlink" title="5.1 &amp;, |, ^, ~ 运算符"></a>5.1 <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code> 运算符</h3><p><strong>作用</strong>：实现位级操作，如按位与、按位或、按位异或、按位取反。</p><p><strong>示例类</strong>：<code>Bitmask</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmask</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Bitmask</span>(<span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">0</span>) : <span class="built_in">bits</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &amp; 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>&amp;(<span class="type">const</span> Bitmask&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits &amp; other.bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 | 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>|(<span class="type">const</span> Bitmask&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits | other.bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 ^ 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>^(<span class="type">const</span> Bitmask&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits ^ other.bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 ~ 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>~() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(~<span class="keyword">this</span>-&gt;bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Bitmask&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Bitmask&amp; b) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; b.bits &lt;&lt; std::dec;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bitmask <span class="title">bm1</span><span class="params">(<span class="number">0b10101010</span>)</span></span>; <span class="comment">// 0xAA</span></span><br><span class="line">    <span class="function">Bitmask <span class="title">bm2</span><span class="params">(<span class="number">0b11001100</span>)</span></span>; <span class="comment">// 0xCC</span></span><br><span class="line"></span><br><span class="line">    Bitmask bm3 = bm1 &amp; bm2;</span><br><span class="line">    Bitmask bm4 = bm1 | bm2;</span><br><span class="line">    Bitmask bm5 = bm1 ^ bm2;</span><br><span class="line">    Bitmask bm6 = ~bm1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 &amp; bm2 = &quot;</span> &lt;&lt; bm3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 | bm2 = &quot;</span> &lt;&lt; bm4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 ^ bm2 = &quot;</span> &lt;&lt; bm5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~bm1 = &quot;</span> &lt;&lt; bm6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bm1 &amp; bm2 = 0x88</span><br><span class="line">bm1 | bm2 = 0xee</span><br><span class="line">bm1 ^ bm2 = 0x66</span><br><span class="line">~bm1 = 0xffffff55</span><br></pre></td></tr></table></figure><h3 id="5-2-lt-lt-gt-gt-位移运算符"><a href="#5-2-lt-lt-gt-gt-位移运算符" class="headerlink" title="5.2 &lt;&lt;, &gt;&gt; 位移运算符"></a>5.2 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> 位移运算符</h3><p><strong>作用</strong>：实现位移操作，如左移、右移。</p><p><strong>示例类</strong>：<code>Bitmask</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt; 运算符（左移，成员函数）</span></span><br><span class="line">Bitmask <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> shift) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits &lt;&lt; shift);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &gt;&gt; 运算符（右移，成员函数）</span></span><br><span class="line">Bitmask <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> shift) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits &gt;&gt; shift);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bitmask <span class="title">bm1</span><span class="params">(<span class="number">0b0001</span>)</span></span>; <span class="comment">// 0x1</span></span><br><span class="line"></span><br><span class="line">    Bitmask bm2 = bm1 &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    Bitmask bm3 = bm1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 &lt;&lt; 3 = &quot;</span> &lt;&lt; bm2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 &gt;&gt; 1 = &quot;</span> &lt;&lt; bm3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bm1 &lt;&lt; <span class="string">3 = 0x8</span></span><br><span class="line"><span class="string">bm1 &gt;&gt; 1 = 0x0</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>重载位移运算符时，通常接受一个整型参数，表示位移的位数。</li></ul><hr><h2 id="6-自增自减运算符"><a href="#6-自增自减运算符" class="headerlink" title="6. 自增自减运算符"></a>6. 自增自减运算符</h2><h3 id="6-1-前置-和-运算符"><a href="#6-1-前置-和-运算符" class="headerlink" title="6.1 前置 ++ 和 -- 运算符"></a>6.1 前置 <code>++</code> 和 <code>--</code> 运算符</h3><p><strong>作用</strong>：实现对象的自增和自减操作。</p><p><strong>示例类</strong>：<code>Counter</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> c = <span class="number">0</span>) : <span class="built_in">count</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置 ++ 运算符（成员函数）</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置 -- 运算符（成员函数）</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Counter&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Counter&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; c.count;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;++c = &quot;</span> &lt;&lt; ++c &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--c = &quot;</span> &lt;&lt; --c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始值: 10</span><br><span class="line"><span class="addition">++c = 11</span></span><br><span class="line"><span class="deletion">--c = 10</span></span><br></pre></td></tr></table></figure><h3 id="6-2-后置-和-运算符"><a href="#6-2-后置-和-运算符" class="headerlink" title="6.2 后置 ++ 和 -- 运算符"></a>6.2 后置 <code>++</code> 和 <code>--</code> 运算符</h3><p><strong>作用</strong>：实现对象的后置自增和自减操作。</p><p><strong>示例类</strong>：<code>Counter</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置 ++ 运算符（成员函数）</span></span><br><span class="line">Counter <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Counter temp = *<span class="keyword">this</span>;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置 -- 运算符（成员函数）</span></span><br><span class="line">Counter <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    Counter temp = *<span class="keyword">this</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c++ = &quot;</span> &lt;&lt; c++ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c-- = &quot;</span> &lt;&lt; c-- &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">初始值: 10</span></span><br><span class="line">c++ = 10</span><br><span class="line">c-- = 11</span><br><span class="line"><span class="section">当前值: 10</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><strong>前置运算符</strong>：先修改对象，再返回引用。</li><li><strong>后置运算符</strong>：先保存原值，修改对象，再返回原值。</li></ul><hr><h2 id="7-下标运算符"><a href="#7-下标运算符" class="headerlink" title="7. 下标运算符 []"></a>7. 下标运算符 <code>[]</code></h2><p><strong>作用</strong>：实现对象的下标访问，如数组访问。</p><p><strong>示例类</strong>：<code>Vector</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; components;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; comps) : <span class="built_in">components</span>(comps) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 运算符（非 const）</span></span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= components.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> components[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 运算符（const）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= components.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> components[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; v);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.components.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        os &lt;&lt; v.components[i];</span><br><span class="line">        <span class="keyword">if</span> (i != v.components.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v</span><span class="params">(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始向量: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v[1] = &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">5.0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;修改后向量: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问越界</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v[3] = &quot;</span> &lt;&lt; v[<span class="number">3</span>] &lt;&lt; std::endl; <span class="comment">// 越界</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">初始向量: (1, 2, 3)</span></span><br><span class="line">v[1] = 2</span><br><span class="line"><span class="section">修改后向量: (1, 5, 3)</span></span><br><span class="line"><span class="section">错误: 下标越界！</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>提供了 <code>const</code> 和 非 <code>const</code> 两种重载，以支持不同上下文中的访问。</li><li>在访问时进行了边界检查，确保安全性。</li></ul><hr><h2 id="8-函数调用运算符"><a href="#8-函数调用运算符" class="headerlink" title="8. 函数调用运算符 ()"></a>8. 函数调用运算符 <code>()</code></h2><p><strong>作用</strong>：使对象能够像函数一样被调用，常用于函数对象（functors）或仿函数。</p><p><strong>示例类</strong>：<code>Multiplier</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multiplier</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> factor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Multiplier</span>(<span class="type">double</span> f = <span class="number">1.0</span>) : <span class="built_in">factor</span>(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 () 运算符（成员函数）</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Multiplier <span class="title">double_it</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Multiplier <span class="title">triple_it</span><span class="params">(<span class="number">3.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_it(5) = &quot;</span> &lt;&lt; <span class="built_in">double_it</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;triple_it(5) = &quot;</span> &lt;&lt; <span class="built_in">triple_it</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double_it(5) = 10</span><br><span class="line">triple_it(5) = 15</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>通过重载 <code>()</code> 运算符，<code>Multiplier</code> 对象可以像函数一样接受参数并进行操作。</li><li>常用于需要定制函数行为的场景，如排序时的比较函数。</li></ul><hr><h2 id="9-输入输出运算符-lt-lt-gt-gt"><a href="#9-输入输出运算符-lt-lt-gt-gt" class="headerlink" title="9. 输入输出运算符 &lt;&lt;, &gt;&gt;"></a>9. 输入输出运算符 <code>&lt;&lt;</code>, <code>&gt;&gt;</code></h2><p><strong>作用</strong>：实现对象与输入输出流之间的交互。</p><p><strong>示例类</strong>：<code>Complex</code>（复数类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符（友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;&gt; 运算符（友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">    <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &gt;&gt; 运算符</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Complex&amp; c) &#123;</span><br><span class="line">    <span class="comment">// 假设输入格式为：real imag</span></span><br><span class="line">    is &gt;&gt; c.real &gt;&gt; c.imag;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入复数的实部和虚部，以空格分隔: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您输入的复数是: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例输入</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入复数的实部和虚部，以空格分隔: 3.5 -2.1</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您输入的复数是: (<span class="number">3.5</span> - <span class="number">2.1i</span>)</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>&lt;&lt;</code> 运算符用于输出对象到流中。</li><li><code>&gt;&gt;</code> 运算符用于从流中输入对象的数据。</li><li>一般将这些运算符重载为友元函数，以便访问类的私有成员。</li></ul><hr><h2 id="10-其他运算符"><a href="#10-其他运算符" class="headerlink" title="10. 其他运算符"></a>10. 其他运算符</h2><h3 id="10-1-成员访问运算符-gt-gt"><a href="#10-1-成员访问运算符-gt-gt" class="headerlink" title="10.1 成员访问运算符 -&gt;, -&gt;*"></a>10.1 成员访问运算符 <code>-&gt;</code>, <code>-&gt;*</code></h3><p><strong>说明</strong>：</p><ul><li>运算符 <code>-&gt;</code> 和 <code>-&gt;*</code> 通常用于代理模式或智能指针的实现，较为复杂。</li><li>其重载需要返回一个指针类型，以便进一步访问成员。</li><li>通常不建议普通类进行重载，除非有特定需求。</li></ul><p><strong>示例类</strong>：<code>Proxy</code> 类（代理模式）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;RealObject::display()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealObject* ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Proxy</span>(RealObject* p = <span class="literal">nullptr</span>) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -&gt; 运算符（成员函数）</span></span><br><span class="line">    RealObject* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RealObject real;</span><br><span class="line">    <span class="function">Proxy <span class="title">proxy</span><span class="params">(&amp;real)</span></span>;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;<span class="built_in">display</span>(); <span class="comment">// 使用重载的 -&gt; 运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealObject::<span class="built_in">display</span>()</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>Proxy</code> 类通过重载 <code>-&gt;</code> 运算符，将对 <code>Proxy</code> 对象的成员访问转发给其内部的 <code>RealObject</code> 对象。</li><li>这是实现代理模式或智能指针的常见方式。</li></ul><hr><h2 id="综合案例：复数（Complex）类中的所有运算符重载"><a href="#综合案例：复数（Complex）类中的所有运算符重载" class="headerlink" title="综合案例：复数（Complex）类中的所有运算符重载"></a>综合案例：复数（Complex）类中的所有运算符重载</h2><p>为了将上述所有运算符的重载整合在一个类中，以下是一个全面的 <code>Complex</code> 类示例，涵盖了大部分可重载的运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real = other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real + other.real, <span class="keyword">this</span>-&gt;imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 - 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real - other.real, <span class="keyword">this</span>-&gt;imag - other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 * 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">        <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 / 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>/(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">        <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 += 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real += other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag += other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -= 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real -= other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag -= other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 *= 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">        <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 /= 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">        <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 == 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="built_in">return</span> (lhs.real == rhs.real) &amp;&amp; (lhs.imag == rhs.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 != 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt; 运算符（基于模长）</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="type">double</span> lhs_mod = std::<span class="built_in">sqrt</span>(lhs.real * lhs.real + lhs.imag * lhs.imag);</span><br><span class="line">        <span class="type">double</span> rhs_mod = std::<span class="built_in">sqrt</span>(rhs.real * rhs.real + rhs.imag * rhs.imag);</span><br><span class="line">        <span class="keyword">return</span> lhs_mod &lt; rhs_mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> rhs &lt; lhs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;= 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rhs &lt; lhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;= 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(lhs &lt; rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">        <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">            os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;&gt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Complex&amp; c) &#123;</span><br><span class="line">        <span class="comment">// 简单输入格式：real imag</span></span><br><span class="line">        is &gt;&gt; c.real &gt;&gt; c.imag;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 ~ 运算符（取反复数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>~() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real, -<span class="keyword">this</span>-&gt;imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑非运算符（!）</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;real == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;imag == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载下标运算符（如 c[0] 返回 real, c[1] 返回 imag）</span></span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> real;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> imag;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> real;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> imag;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++real;</span><br><span class="line">        ++imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后置 ++ 运符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        Complex temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++real;</span><br><span class="line">        ++imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前置 -- 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        --real;</span><br><span class="line">        --imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后置 -- 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        Complex temp = *<span class="keyword">this</span>;</span><br><span class="line">        --real;</span><br><span class="line">        --imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; part)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (part == <span class="string">&quot;real&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> real;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (part == <span class="string">&quot;imag&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> imag;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;参数错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    Complex c3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算</span></span><br><span class="line">    c3 = c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c3 = &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    Complex c4 = c1 + c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c4 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    Complex c5 = c1 - c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span> &lt;&lt; c5 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    Complex c6 = c1 * c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span> &lt;&lt; c6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Complex c7 = c1 / c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span> &lt;&lt; c7 &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较运算</span></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于 c2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长不大于 c2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非运算</span></span><br><span class="line">    Complex c_zero;</span><br><span class="line">    <span class="keyword">if</span> (!c1)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 不是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c_zero)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c_zero 是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c_zero 不是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取反运算</span></span><br><span class="line">    Complex c_neg = ~c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~c1 = &quot;</span> &lt;&lt; c_neg &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标运算</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1[0] (real) = &quot;</span> &lt;&lt; c1[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1[1] (imag) = &quot;</span> &lt;&lt; c1[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;c1[2] = &quot; &lt;&lt; c1[2] &lt;&lt; std::endl; // 会抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增自减运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;++c1 = &quot;</span> &lt;&lt; ++c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1++ = &quot;</span> &lt;&lt; c1++ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--c1 = &quot;</span> &lt;&lt; --c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1-- = &quot;</span> &lt;&lt; c1-- &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 的实部: &quot;</span> &lt;&lt; <span class="built_in">c1</span>(<span class="string">&quot;real&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 的虚部: &quot;</span> &lt;&lt; <span class="built_in">c1</span>(<span class="string">&quot;imag&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入运算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个复数的实部和虚部，以空格分隔: &quot;</span>;</span><br><span class="line">    Complex c_input;</span><br><span class="line">    std::cin &gt;&gt; c_input;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您输入的复数是: &quot;</span> &lt;&lt; c_input &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例运行</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">c3 = (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">c1 + c2 = (<span class="number">4.5</span> + <span class="number">1.5i</span>)</span><br><span class="line">c1 - c2 = (<span class="number">1.5</span> + <span class="number">6.5i</span>)</span><br><span class="line">c1 * c2 = (<span class="number">13.5</span> + <span class="number">1i</span>)</span><br><span class="line">c1 / c2 = (<span class="number">-0.823529</span> + <span class="number">1.64706i</span>)</span><br><span class="line">c1 的模长大于 c2</span><br><span class="line">c1 不是零复数</span><br><span class="line">c_zero 是零复数</span><br><span class="line">~c1 = (<span class="number">3</span> - <span class="number">4i</span>)</span><br><span class="line">c1[<span class="number">0</span>] (<span class="built_in">real</span>) = <span class="number">3</span></span><br><span class="line">c1[<span class="number">1</span>] (<span class="built_in">imag</span>) = <span class="number">4</span></span><br><span class="line">c1 = (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">++c1 = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1++ = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1 = (<span class="number">5</span> + <span class="number">6i</span>)</span><br><span class="line">--c1 = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1-- = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1 = (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">c1 的实部: <span class="number">3</span></span><br><span class="line">c1 的虚部: <span class="number">4</span></span><br><span class="line">请输入一个复数的实部和虚部，以空格分隔: <span class="number">2.5</span> <span class="number">-3.5</span></span><br><span class="line">您输入的复数是: (<span class="number">2.5</span> - <span class="number">3.5i</span>)</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>该类集成了大部分可重载的运算符，包括算术、赋值、比较、逻辑、位运算、自增自减、下标、函数调用以及输入输出运算符。</li><li>某些运算符（如 <code>&amp;&amp;</code>, <code>||</code>, <code>-&gt;*</code>）未在此示例中体现，因为它们的重载较为复杂且不常见。</li><li>在实际开发中，应根据需求选择性地重载运算符，避免过度设计。</li></ul><hr><h2 id="11-其他可重载运算符"><a href="#11-其他可重载运算符" class="headerlink" title="11. 其他可重载运算符"></a>11. 其他可重载运算符</h2><h3 id="11-1-逗号运算符"><a href="#11-1-逗号运算符" class="headerlink" title="11.1 逗号运算符 ,"></a>11.1 逗号运算符 <code>,</code></h3><p><strong>作用</strong>：实现对象在逗号表达式中的行为。</p><p><strong>示例类</strong>：<code>Logger</code> 类（用于示例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; msg = <span class="string">&quot;&quot;</span>) : <span class="built_in">message</span>(msg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逗号运算符（成员函数）</span></span><br><span class="line">    Logger <span class="keyword">operator</span>,(<span class="type">const</span> Logger&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 简单示例：连接日志消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Logger</span>(<span class="keyword">this</span>-&gt;message + <span class="string">&quot;, &quot;</span> + other.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Logger&amp; l);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Logger&amp; l) &#123;</span><br><span class="line">    os &lt;&lt; l.message;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Logger <span class="title">log1</span><span class="params">(<span class="string">&quot;启动&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Logger <span class="title">log2</span><span class="params">(<span class="string">&quot;加载配置&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Logger <span class="title">log3</span><span class="params">(<span class="string">&quot;初始化&quot;</span>)</span></span>;</span><br><span class="line">    Logger combined = (log1, log2, log3);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;组合日志: &quot;</span> &lt;&lt; combined &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">组合日志: 启动, 加载配置, 初始化</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>重载 <code>,</code> 运算符可以自定义逗号表达式的行为，但在实际应用中不常见，应谨慎使用。</li><li>多个逗号运算符的重载会按从左至右的顺序依次调用。</li></ul><hr><h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ol><li><strong>语义一致性</strong>：重载运算符后，其行为应与运算符的传统意义保持一致。例如，<code>+</code> 应表示加法，避免引起混淆。</li><li><strong>效率</strong>：尽量避免不必要的对象拷贝，可以通过返回引用或使用移动语义提升效率。</li><li><strong>异常安全</strong>：在实现运算符重载时，考虑并处理可能的异常情况，确保程序的健壮性。</li><li><strong>封装性</strong>：保持类的封装性，避免过度暴露内部细节。仅在必要时使用友元函数。</li><li><strong>返回类型</strong>：根据运算符的用途选择合适的返回类型。例如，算术运算符通常返回新对象，赋值运算符返回引用等。</li><li><strong>避免复杂的逻辑</strong>：运算符重载应简洁明了，不应包含过于复杂的逻辑，避免使代码难以理解和维护。</li><li><strong>可读性</strong>：使用适当的注释和文档说明运算符重载的行为，增强代码的可读性。</li></ol><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>运算符重载是C++中强大的特性，允许开发者为自定义类定义或重新定义运算符的行为，使对象的操作更加直观和符合逻辑。在设计和实现运算符重载时，应遵循语义一致性、效率和封装性等原则，避免滥用。通过本教案中的详细案例，学习者可以全面理解运算符重载的应用，并在实际编程中灵活运用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;运算符重载概述&quot;&gt;&lt;a href=&quot;#运算符重载概述&quot; class=&quot;headerlink&quot; title=&quot;运算符重载概述&quot;&gt;&lt;/a&gt;运算符重载概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;运算符重载（Operator Overloading）&lt;/strong&gt;允许开发者为</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>unorderedmap以及手写无序map</title>
    <link href="http://www.limerence2017.com/2025/01/14/cppbase29/"/>
    <id>http://www.limerence2017.com/2025/01/14/cppbase29/</id>
    <published>2025-01-14T08:18:11.000Z</published>
    <updated>2025-02-15T02:51:21.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unordermap用法"><a href="#unordermap用法" class="headerlink" title="unordermap用法"></a>unordermap用法</h1><p><code>unordered_map</code> 是 C++ 标准库中的关联容器，提供了基于哈希表的键值对存储结构。与 <code>map</code> （基于红黑树实现）不同，<code>unordered_map</code> 提供的是平均常数时间复杂度的查找、插入和删除操作，但不保证元素的顺序。</p><p>以下是 <code>unordered_map</code> 的详细用法说明：</p><h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h2><p>要使用 <code>unordered_map</code>，需要包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="2-基本定义"><a href="#2-基本定义" class="headerlink" title="2. 基本定义"></a>2. 基本定义</h2><p><code>unordered_map</code> 的基本模板定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;KeyType, ValueType, Hash = std::hash&lt;KeyType&gt;, KeyEqual = std::equal_to&lt;KeyType&gt;, Allocator = std::allocator&lt;std::pair&lt;<span class="type">const</span> KeyType, ValueType&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="常用模板参数："><a href="#常用模板参数：" class="headerlink" title="常用模板参数："></a>常用模板参数：</h3><ul><li><strong>KeyType</strong>：键的类型，需要支持哈希运算和相等比较。</li><li><strong>ValueType</strong>：值的类型。</li><li><strong>Hash</strong>：哈希函数，默认为 <code>std::hash&lt;KeyType&gt;</code>。</li><li><strong>KeyEqual</strong>：键相等的比较函数，默认为 <code>std::equal_to&lt;KeyType&gt;</code>。</li><li><strong>Allocator</strong>：内存分配器，默认为 <code>std::allocator</code>。</li></ul><h2 id="3-常用操作"><a href="#3-常用操作" class="headerlink" title="3. 常用操作"></a>3. 常用操作</h2><h3 id="3-1-创建和初始化"><a href="#3-1-创建和初始化" class="headerlink" title="3.1 创建和初始化"></a>3.1 创建和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 unordered_map，键为 string，值为 int</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始化列表初始化</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; umap_init = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用其他容器范围初始化</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ordered_map = &#123;&#123;<span class="string">&quot;carrot&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;lettuce&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; <span class="title">umap_from_map</span><span class="params">(ordered_map.begin(), ordered_map.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-插入元素"><a href="#3-2-插入元素" class="headerlink" title="3.2 插入元素"></a>3.2 插入元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用下标操作符</span></span><br><span class="line">umap[<span class="string">&quot;grape&quot;</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用 insert</span></span><br><span class="line">umap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;melon&quot;</span>, <span class="number">6</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：使用 emplace，直接在容器内部构造元素</span></span><br><span class="line">umap.<span class="built_in">emplace</span>(<span class="string">&quot;kiwi&quot;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3-访问元素"><a href="#3-3-访问元素" class="headerlink" title="3.3 访问元素"></a>3.3 访问元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下标操作符访问或插入</span></span><br><span class="line"><span class="type">int</span> apple_count = umap[<span class="string">&quot;apple&quot;</span>]; <span class="comment">// 如果 &quot;apple&quot; 不存在，会插入一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法访问，不存在时会抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> banana_count = umap.<span class="built_in">at</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Key not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 find() 方法查找</span></span><br><span class="line"><span class="keyword">auto</span> it = umap.<span class="built_in">find</span>(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Orange count: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Orange not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-删除元素"><a href="#3-4-删除元素" class="headerlink" title="3.4 删除元素"></a>3.4 删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据键删除</span></span><br><span class="line">umap.<span class="built_in">erase</span>(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据迭代器删除</span></span><br><span class="line"><span class="keyword">auto</span> it = umap.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    umap.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空整个容器</span></span><br><span class="line">umap.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h3 id="3-5-遍历元素"><a href="#3-5-遍历元素" class="headerlink" title="3.5 遍历元素"></a>3.5 遍历元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : umap) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = umap.<span class="built_in">begin</span>(); it != umap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-其他常用方法"><a href="#3-6-其他常用方法" class="headerlink" title="3.6 其他常用方法"></a>3.6 其他常用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取大小</span></span><br><span class="line"><span class="type">size_t</span> size = umap.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为空</span></span><br><span class="line"><span class="type">bool</span> is_empty = umap.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取桶的数量（用于哈希表内部结构）</span></span><br><span class="line"><span class="type">size_t</span> bucket_count = umap.<span class="built_in">bucket_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新哈希，调整桶的数量</span></span><br><span class="line">umap.<span class="built_in">rehash</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个容器中移交元素到另一个容器</span></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; umap2 = std::<span class="built_in">move</span>(umap);</span><br></pre></td></tr></table></figure><h2 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h2><h3 id="4-1-预分配桶数"><a href="#4-1-预分配桶数" class="headerlink" title="4.1 预分配桶数"></a>4.1 预分配桶数</h3><p>如果预先知道元素的大致数量，可以通过 <code>reserve</code> 预分配内存，以减少哈希表的重哈希开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umap.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 预分配足够容纳100个元素的桶</span></span><br></pre></td></tr></table></figure><h3 id="4-2-自定义哈希函数"><a href="#4-2-自定义哈希函数" class="headerlink" title="4.2 自定义哈希函数"></a>4.2 自定义哈希函数</h3><p>如果键的类型是自定义类型或需要特殊的哈希策略，可以自定义哈希函数。例如，自定义结构体作为键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PointHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.x) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.y) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 unordered_map 使用自定义哈希函数</span></span><br><span class="line">std::unordered_map&lt;Point, std::string, PointHash&gt; point_map;</span><br><span class="line">point_map[&#123;<span class="number">1</span>, <span class="number">2</span>&#125;] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">point_map[&#123;<span class="number">3</span>, <span class="number">4</span>&#125;] = <span class="string">&quot;B&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-自定义键相等比较"><a href="#4-3-自定义键相等比较" class="headerlink" title="4.3 自定义键相等比较"></a>4.3 自定义键相等比较</h3><p>如果需要自定义键的比较逻辑，可以提供自定义的 <code>KeyEqual</code> 函数对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PointEqual</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a.x == b.x) &amp;&amp; (a.y == b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 unordered_map 使用自定义哈希和比较函数</span></span><br><span class="line">std::unordered_map&lt;Point, std::string, PointHash, PointEqual&gt; point_map;</span><br></pre></td></tr></table></figure><h2 id="5-与-map-的比较"><a href="#5-与-map-的比较" class="headerlink" title="5. 与 map 的比较"></a>5. 与 <code>map</code> 的比较</h2><ul><li><strong>底层实现</strong>：<code>unordered_map</code> 基于哈希表，实现的操作平均时间复杂度为常数级别；<code>map</code> 基于红黑树，实现的查找、插入、删除操作时间复杂度为对数级别。</li><li><strong>元素顺序</strong>：<code>unordered_map</code> 不保证元素的顺序；<code>map</code> 按键的顺序（通常是升序）存储元素。</li><li><strong>适用场景</strong>：当需要快速查找、插入和删除，且不关心元素顺序时，选择 <code>unordered_map</code>；当需要有序存储或按顺序遍历时，选择 <code>map</code>。</li></ul><h2 id="6-完整示例"><a href="#6-完整示例" class="headerlink" title="6. 完整示例"></a>6. 完整示例</h2><p>以下是一个使用 <code>unordered_map</code> 的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; age == other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;std::string&gt;()(p.name) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.age) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unordered_map，键为 string，值为 int</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; fruit_count;</span><br><span class="line">    fruit_count[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    fruit_count[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    fruit_count.<span class="built_in">emplace</span>(<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Apple count: &quot;</span> &lt;&lt; fruit_count[<span class="string">&quot;apple&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : fruit_count) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义类型作为键</span></span><br><span class="line">    std::unordered_map&lt;Person, std::string, PersonHash&gt; person_map;</span><br><span class="line">    Person p1&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    Person p2&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    person_map[p1] = <span class="string">&quot;Engineer&quot;</span>;</span><br><span class="line">    person_map.<span class="built_in">emplace</span>(p2, <span class="string">&quot;Designer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问自定义类型键的值</span></span><br><span class="line">    Person p3&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s job: &quot;</span> &lt;&lt; person_map[p3] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Apple count:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">banana:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">orange:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">apple:</span> <span class="number">5</span></span><br><span class="line"><span class="string">Alice&#x27;s</span> <span class="attr">job:</span> <span class="string">Engineer</span></span><br></pre></td></tr></table></figure><h1 id="手写unordermap"><a href="#手写unordermap" class="headerlink" title="手写unordermap"></a>手写unordermap</h1><h2 id="1-哈希表的基本原理"><a href="#1-哈希表的基本原理" class="headerlink" title="1. 哈希表的基本原理"></a>1. 哈希表的基本原理</h2><p>哈希表是一种基于键值对的数据结构，通过<strong>哈希函数</strong>（Hash Function）将键映射到表中的一个索引位置，以实现快速的数据访问。哈希表的关键特性包括：</p><ul><li><strong>哈希函数</strong>：将键映射到表中一个特定的桶（Bucket）或槽（Slot）。</li><li><strong>冲突解决</strong>：当不同的键通过哈希函数映射到同一个桶时，需要一种机制来处理这些冲突。常见的方法有<strong>链地址法</strong>（Separate Chaining）和<strong>开放地址法</strong>（Open Addressing）。</li><li><strong>负载因子</strong>（Load Factor）：表示表中已存储元素的数量与表大小之间的比率。高负载因子可能导致更多的冲突，需要通过扩容来维持性能。</li></ul><p>在本实现中，我们将采用<strong>链地址法</strong>来处理哈希冲突，即每个桶存储一个链表（或其他动态数据结构）来存储具有相同哈希值的元素。</p><h2 id="2-数据结构设计"><a href="#2-数据结构设计" class="headerlink" title="2. 数据结构设计"></a>2. 数据结构设计</h2><h3 id="HashNode-结构"><a href="#HashNode-结构" class="headerlink" title="HashNode 结构"></a>HashNode 结构</h3><p><code>HashNode</code> 用于存储键值对及相关的指针，以构建链表。每个 <code>HashNode</code> 包含键、值和指向下一个节点的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::hash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// For iterator_traits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// For exceptions</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashNode 结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line">    std::pair&lt;<span class="type">const</span> Key, T&gt; data;</span><br><span class="line">    HashNode* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HashNode</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span><br><span class="line">        : <span class="built_in">data</span>(std::<span class="built_in">make_pair</span>(key, value)), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MyHashMap-类定义"><a href="#MyHashMap-类定义" class="headerlink" title="MyHashMap 类定义"></a>MyHashMap 类定义</h3><p><code>MyHashMap</code> 是我们自定义的哈希表实现，支持基本的 <code>Map</code> 操作和迭代器功能。它使用一个向量（<code>std::vector</code>）来存储桶，每个桶是一个链表，用于处理冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 迭代器类前向声明</span></span><br><span class="line">    <span class="keyword">class</span> Iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型定义</span></span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> mapped_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数及析构函数</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(size_type initial_capacity = <span class="number">16</span>, <span class="type">double</span> max_load_factor = <span class="number">0.75</span>);</span><br><span class="line">    ~<span class="built_in">MyHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyHashMap&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器操作</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 迭代器别名</span></span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::forward_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">        <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">        <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作符</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增操作符</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyHashMap* map_;</span><br><span class="line">        size_type bucket_index_;</span><br><span class="line">        HashNode&lt;Key, T&gt;* current_node_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个有效节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;</span><br><span class="line">    size_type bucket_count_;</span><br><span class="line">    size_type element_count_;</span><br><span class="line">    <span class="type">double</span> max_load_factor_;</span><br><span class="line">    Hash hash_func_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-基本操作实现"><a href="#3-基本操作实现" class="headerlink" title="3. 基本操作实现"></a>3. 基本操作实现</h2><h3 id="构造函数及析构函数"><a href="#构造函数及析构函数" class="headerlink" title="构造函数及析构函数"></a>构造函数及析构函数</h3><p>初始化哈希表，设置初始容量和负载因子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">MyHashMap</span>(size_type initial_capacity, <span class="type">double</span> max_load_factor)</span><br><span class="line">    : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">      <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">      <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123;</span><br><span class="line">    buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::~<span class="built_in">MyHashMap</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入（Insert）"><a href="#插入（Insert）" class="headerlink" title="插入（Insert）"></a>插入（Insert）</h3><p>向哈希表中插入键值对。如果键已存在，则更新其值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            node-&gt;data.second = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键不存在，插入新节点到链表头部</span></span><br><span class="line">    HashNode&lt;Key, T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">HashNode</span>&lt;Key, T&gt;(key, value);</span><br><span class="line">    new_node-&gt;next = buckets_[index];</span><br><span class="line">    buckets_[index] = new_node;</span><br><span class="line">    ++element_count_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查负载因子，可能需要扩容</span></span><br><span class="line">    <span class="type">double</span> load_factor = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(element_count_) / bucket_count_;</span><br><span class="line">    <span class="keyword">if</span> (load_factor &gt; max_load_factor_) &#123;</span><br><span class="line">        <span class="built_in">rehash</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找（Find）"><a href="#查找（Find）" class="headerlink" title="查找（Find）"></a>查找（Find）</h3><p>根据键查找对应的值，返回指向值的指针。如果未找到，则返回 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">const</span> T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除（Erase）"><a href="#删除（Erase）" class="headerlink" title="删除（Erase）"></a>删除（Erase）</h3><p>根据键删除对应的键值对，返回删除是否成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    HashNode&lt;Key, T&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                buckets_[index] = node-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            --element_count_;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未找到键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空（Clear）"><a href="#清空（Clear）" class="headerlink" title="清空（Clear）"></a>清空（Clear）</h3><p>删除哈希表中的所有元素，释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets_[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态扩容（Rehashing）"><a href="#动态扩容（Rehashing）" class="headerlink" title="动态扩容（Rehashing）"></a>动态扩容（Rehashing）</h3><p>当负载因子超过阈值时，扩展哈希表容量并重新分配所有元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">rehash</span>() &#123;</span><br><span class="line">    size_type new_bucket_count = bucket_count_ * <span class="number">2</span>;</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; <span class="built_in">new_buckets</span>(new_bucket_count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* next_node = node-&gt;next;</span><br><span class="line">            size_type new_index = <span class="built_in">hash_func_</span>(node-&gt;data.first) % new_bucket_count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入到新桶的头部</span></span><br><span class="line">            node-&gt;next = new_buckets[new_index];</span><br><span class="line">            new_buckets[new_index] = node;</span><br><span class="line"></span><br><span class="line">            node = next_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换旧桶</span></span><br><span class="line">    buckets_ = std::<span class="built_in">move</span>(new_buckets);</span><br><span class="line">    bucket_count_ = new_bucket_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取大小和状态"><a href="#获取大小和状态" class="headerlink" title="获取大小和状态"></a>获取大小和状态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::size_type MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element_count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">empty</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element_count_ == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-迭代器的实现"><a href="#4-迭代器的实现" class="headerlink" title="4. 迭代器的实现"></a>4. 迭代器的实现</h2><p>为了支持迭代器操作，使 <code>MyHashMap</code> 能够像标准容器一样被遍历，我们需要实现一个内部的 <code>Iterator</code> 类。</p><h3 id="Iterator-类定义"><a href="#Iterator-类定义" class="headerlink" title="Iterator 类定义"></a>Iterator 类定义</h3><p><code>Iterator</code> 类需要跟踪当前桶的索引和当前节点指针。它还需要能够找到下一个有效的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node)</span><br><span class="line">    : <span class="built_in">map_</span>(map), <span class="built_in">bucket_index_</span>(bucket_index), <span class="built_in">current_node_</span>(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::reference</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_node_-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员访问操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointer</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(current_node_-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map_ == other.map_ &amp;&amp;</span><br><span class="line">           bucket_index_ == other.bucket_index_ &amp;&amp;</span><br><span class="line">           current_node_ == other.current_node_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符!=</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// advance 函数：移动到下一个有效节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">advance</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current_node_ = current_node_-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_node_ == <span class="literal">nullptr</span> &amp;&amp; bucket_index_ + <span class="number">1</span> &lt; map_-&gt;bucket_count_) &#123;</span><br><span class="line">        ++bucket_index_;</span><br><span class="line">        current_node_ = map_-&gt;buckets_[bucket_index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h3><p>在 <code>MyHashMap</code> 类中实现 <code>begin()</code> 和 <code>end()</code> 函数来返回迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// begin() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">begin</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets_[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, i, buckets_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// end() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-完整代码示例"><a href="#5-完整代码示例" class="headerlink" title="5. 完整代码示例"></a>5. 完整代码示例</h2><p>以下是完整的 <code>MyHashMap</code> 实现，包括所有上述内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::hash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// For iterator_traits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// For exceptions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashNode 结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line">    std::pair&lt;<span class="type">const</span> Key, T&gt; data;</span><br><span class="line">    HashNode* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HashNode</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span><br><span class="line">        : <span class="built_in">data</span>(std::<span class="built_in">make_pair</span>(key, value)), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyHashMap 类定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 迭代器类前向声明</span></span><br><span class="line">    <span class="keyword">class</span> Iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型定义</span></span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> mapped_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数及析构函数</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(size_type initial_capacity = <span class="number">16</span>, <span class="type">double</span> max_load_factor = <span class="number">0.75</span>);</span><br><span class="line">    ~<span class="built_in">MyHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyHashMap&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器操作</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 迭代器别名</span></span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::forward_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">        <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">        <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作符</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增操作符</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyHashMap* map_;</span><br><span class="line">        size_type bucket_index_;</span><br><span class="line">        HashNode&lt;Key, T&gt;* current_node_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个有效节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;</span><br><span class="line">    size_type bucket_count_;</span><br><span class="line">    size_type element_count_;</span><br><span class="line">    <span class="type">double</span> max_load_factor_;</span><br><span class="line">    Hash hash_func_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">MyHashMap</span>(size_type initial_capacity, <span class="type">double</span> max_load_factor)</span><br><span class="line">    : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">      <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">      <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123;</span><br><span class="line">    buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::~<span class="built_in">MyHashMap</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            node-&gt;data.second = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键不存在，插入新节点到链表头部</span></span><br><span class="line">    HashNode&lt;Key, T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">HashNode</span>&lt;Key, T&gt;(key, value);</span><br><span class="line">    new_node-&gt;next = buckets_[index];</span><br><span class="line">    buckets_[index] = new_node;</span><br><span class="line">    ++element_count_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查负载因子，可能需要扩容</span></span><br><span class="line">    <span class="type">double</span> load_factor = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(element_count_) / bucket_count_;</span><br><span class="line">    <span class="keyword">if</span> (load_factor &gt; max_load_factor_) &#123;</span><br><span class="line">        <span class="built_in">rehash</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找函数（非常量版本）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找函数（常量版本）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">const</span> T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    HashNode&lt;Key, T&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                buckets_[index] = node-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            --element_count_;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未找到键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets_[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态扩容函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">rehash</span>() &#123;</span><br><span class="line">    size_type new_bucket_count = bucket_count_ * <span class="number">2</span>;</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; <span class="built_in">new_buckets</span>(new_bucket_count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* next_node = node-&gt;next;</span><br><span class="line">            size_type new_index = <span class="built_in">hash_func_</span>(node-&gt;data.first) % new_bucket_count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入到新桶的头部</span></span><br><span class="line">            node-&gt;next = new_buckets[new_index];</span><br><span class="line">            new_buckets[new_index] = node;</span><br><span class="line"></span><br><span class="line">            node = next_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换旧桶</span></span><br><span class="line">    buckets_ = std::<span class="built_in">move</span>(new_buckets);</span><br><span class="line">    bucket_count_ = new_bucket_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// begin() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">begin</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets_[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, i, buckets_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// end() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node)</span><br><span class="line">    : <span class="built_in">map_</span>(map), <span class="built_in">bucket_index_</span>(bucket_index), <span class="built_in">current_node_</span>(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::reference</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_node_-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员访问操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointer</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(current_node_-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map_ == other.map_ &amp;&amp;</span><br><span class="line">           bucket_index_ == other.bucket_index_ &amp;&amp;</span><br><span class="line">           current_node_ == other.current_node_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符!=</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// advance 函数：移动到下一个有效节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">advance</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current_node_ = current_node_-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_node_ == <span class="literal">nullptr</span> &amp;&amp; bucket_index_ + <span class="number">1</span> &lt; map_-&gt;bucket_count_) &#123;</span><br><span class="line">        ++bucket_index_;</span><br><span class="line">        current_node_ = map_-&gt;buckets_[bucket_index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-使用示例"><a href="#6-使用示例" class="headerlink" title="6. 使用示例"></a>6. 使用示例</h2><p>以下是一个使用 <code>MyHashMap</code> 的示例，展示如何插入、查找、删除以及使用迭代器遍历元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyHashMap&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;grape&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Map contents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string keyToFind = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* value = myMap.<span class="built_in">find</span>(keyToFind);</span><br><span class="line">    <span class="keyword">if</span>(value != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nFound &quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; with value: &quot;</span> &lt;&lt; *value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter erasing apple and cherry:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map contents:</span><br><span class="line">cherry =&gt; 4</span><br><span class="line">banana =&gt; 5</span><br><span class="line">apple =&gt; 3</span><br><span class="line">grape =&gt; 7</span><br><span class="line">orange =&gt; 2</span><br><span class="line"></span><br><span class="line">Found banana with value: 5</span><br><span class="line"></span><br><span class="line">After erasing apple and cherry:</span><br><span class="line">banana =&gt; 5</span><br><span class="line">grape =&gt; 7</span><br><span class="line">orange =&gt; 2</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：由于哈希表的桶顺序依赖于哈希函数的实现，输出顺序可能与预期有所不同。</p><p><code>Hash()</code> 在上述 <code>MyHashMap</code> 实现中是一个<strong>哈希函数对象</strong>。让我们详细解释一下它的含义以及它在代码中的作用。</p><h2 id="Hash-是什么？"><a href="#Hash-是什么？" class="headerlink" title="Hash 是什么？"></a><code>Hash</code> 是什么？</h2><p>在 <code>MyHashMap</code> 的模板定义中，<code>Hash</code> 是一个<strong>模板参数</strong>，用于指定键类型 <code>Key</code> 的哈希函数。它有一个默认值 <code>std::hash&lt;Key&gt;</code>，这意味着如果用户在实例化 <code>MyHashMap</code> 时没有提供自定义的哈希函数，<code>std::hash&lt;Key&gt;</code> 将被使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="默认情况下：std-hash-lt-Key-gt"><a href="#默认情况下：std-hash-lt-Key-gt" class="headerlink" title="默认情况下：std::hash&lt;Key&gt;"></a>默认情况下：<code>std::hash&lt;Key&gt;</code></h3><p><code>std::hash</code> 是 C++ 标准库（STL）中提供的一个模板结构，用于为各种内置类型（如 <code>int</code>, <code>std::string</code> 等）生成哈希值。<code>std::hash&lt;Key&gt;</code> 会根据 <code>Key</code> 的类型自动选择合适的哈希函数实现。</p><p>例如：</p><ul><li>对于 <code>int</code> 类型，<code>std::hash&lt;int&gt;</code> 会生成一个简单的哈希值。</li><li>对于 <code>std::string</code> 类型，<code>std::hash&lt;std::string&gt;</code> 会基于字符串内容生成哈希值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::hash&lt;<span class="type">int</span>&gt; intHasher;</span><br><span class="line"><span class="type">size_t</span> hashValue = <span class="built_in">intHasher</span>(<span class="number">42</span>); <span class="comment">// 生成整数 42 的哈希值</span></span><br><span class="line"></span><br><span class="line">std::hash&lt;std::string&gt; stringHasher;</span><br><span class="line"><span class="type">size_t</span> stringHash = <span class="built_in">stringHasher</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 生成字符串 &quot;hello&quot; 的哈希值</span></span><br></pre></td></tr></table></figure><h3 id="自定义哈希函数"><a href="#自定义哈希函数" class="headerlink" title="自定义哈希函数"></a>自定义哈希函数</h3><p>除了使用 <code>std::hash</code>，用户还可以自定义哈希函数，以适应特定的需求或优化性能。例如，假设你有一个自定义的键类型 <code>Point</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以定义一个自定义的哈希函数 <code>PointHasher</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PointHasher</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的哈希组合，实际应用中应选择更好的哈希组合方法</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.x) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.y) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，在实例化 <code>MyHashMap</code> 时使用自定义哈希函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyHashMap&lt;Point, std::string, PointHasher&gt; pointMap;</span><br><span class="line">Point p1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pointMap.<span class="built_in">insert</span>(p1, <span class="string">&quot;Point1&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Hash-在代码中的作用"><a href="#Hash-在代码中的作用" class="headerlink" title="Hash() 在代码中的作用"></a><code>Hash()</code> 在代码中的作用</h2><p>在 <code>MyHashMap</code> 的构造函数中，<code>Hash()</code> 用于<strong>实例化</strong>哈希函数对象，并将其赋值给成员变量 <code>hash_func_</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">MyHashMap</span>(size_type initial_capacity, <span class="type">double</span> max_load_factor)</span><br><span class="line">    : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">      <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">      <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123; <span class="comment">// 这里的 Hash() 是一个默认构造函数调用</span></span><br><span class="line">    buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体作用："><a href="#具体作用：" class="headerlink" title="具体作用："></a>具体作用：</h3><ol><li><strong>实例化哈希函数对象</strong>：<ul><li><code>Hash()</code> 会调用 <code>Hash</code> 类型的默认构造函数，创建一个哈希函数对象。</li><li>如果 <code>Hash</code> 是 <code>std::hash&lt;Key&gt;</code>，那么就创建一个 <code>std::hash&lt;Key&gt;</code> 对象。</li></ul></li><li><strong>存储哈希函数对象</strong>：<ul><li>生成的哈希函数对象被存储在成员变量 <code>hash_func_</code> 中，以便在哈希表的各种操作（如插入、查找、删除）中使用。</li></ul></li><li><strong>支持不同的哈希函数</strong>：<ul><li>由于 <code>Hash</code> 是一个模板参数，可以灵活地使用不同的哈希函数，无需修改 <code>MyHashMap</code> 的内部实现。</li></ul></li></ol><h2 id="示例代码解释"><a href="#示例代码解释" class="headerlink" title="示例代码解释"></a>示例代码解释</h2><p>以下是相关部分的简化示例，帮助理解 <code>Hash</code> 和 <code>Hash()</code> 的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::hash</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyHashMap</span>(<span class="type">size_t</span> initial_capacity = <span class="number">16</span>, <span class="type">double</span> max_load_factor = <span class="number">0.75</span>)</span><br><span class="line">        : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">          <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">          <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123; <span class="comment">// 实例化哈希函数对象</span></span><br><span class="line">        buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash_value = <span class="built_in">hash_func_</span>(key); <span class="comment">// 使用哈希函数对象</span></span><br><span class="line">        <span class="type">size_t</span> index = hash_value % bucket_count_;</span><br><span class="line">        <span class="comment">// 插入逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;</span><br><span class="line">    <span class="type">size_t</span> bucket_count_;</span><br><span class="line">    <span class="type">size_t</span> element_count_;</span><br><span class="line">    <span class="type">double</span> max_load_factor_;</span><br><span class="line">    Hash hash_func_; <span class="comment">// 存储哈希函数对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong><code>Hash</code> 是模板参数</strong>，用于指定键类型 <code>Key</code> 的哈希函数。默认情况下，它使用 C++ 标准库中的 <code>std::hash&lt;Key&gt;</code>。</li><li><strong><code>Hash()</code> 是一个默认构造函数调用</strong>，用于实例化哈希函数对象，并将其存储在 <code>hash_func_</code> 成员变量中，以便在哈希表操作中使用。</li><li><strong>用户可以自定义哈希函数</strong>，通过提供自定义的哈希函数对象，实现对特定键类型的优化或满足特殊需求。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unordermap用法&quot;&gt;&lt;a href=&quot;#unordermap用法&quot; class=&quot;headerlink&quot; title=&quot;unordermap用法&quot;&gt;&lt;/a&gt;unordermap用法&lt;/h1&gt;&lt;p&gt;&lt;code&gt;unordered_map&lt;/code&gt; 是 C</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>手写线程安全智能指针</title>
    <link href="http://www.limerence2017.com/2024/12/27/cppbase27/"/>
    <id>http://www.limerence2017.com/2024/12/27/cppbase27/</id>
    <published>2024-12-27T06:11:08.000Z</published>
    <updated>2025-02-15T02:51:09.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现有-SimpleSharedPtr-的线程安全性分析"><a href="#现有-SimpleSharedPtr-的线程安全性分析" class="headerlink" title="现有 SimpleSharedPtr 的线程安全性分析"></a>现有 <code>SimpleSharedPtr</code> 的线程安全性分析</h2><p>在多线程环境下，确保智能指针的线程安全性主要涉及以下几个方面：</p><ol><li><strong>引用计数管理</strong>：多个线程可能会同时拷贝、移动或销毁智能指针实例，导致引用计数的修改。若引用计数不是原子操作，则会引发数据竞争和未定义行为。</li><li><strong>指针和控制块的访问</strong>：多个线程可能会同时访问或修改同一个智能指针实例的 <code>ptr</code> 和 <code>control</code> 成员，这需要同步机制来保护。</li></ol><p><strong>当前 <code>SimpleSharedPtr</code> 的问题：</strong></p><ul><li><strong>引用计数非原子</strong>：<code>ControlBlock::ref_count</code> 是普通的 <code>int</code> 类型，当多个线程同时修改 <code>ref_count</code> 时，会引发竞态条件。</li><li><strong>缺乏同步机制</strong>：<code>SimpleSharedPtr</code> 的成员函数（如拷贝构造、赋值操作符等）在修改 <code>ptr</code> 和 <code>control</code> 时没有任何同步机制，导致多个线程同时操作同一个 <code>SimpleSharedPtr</code> 实例时不安全。</li></ul><hr><h2 id="实现线程安全的-SimpleSharedPtr"><a href="#实现线程安全的-SimpleSharedPtr" class="headerlink" title="实现线程安全的 SimpleSharedPtr"></a>实现线程安全的 <code>SimpleSharedPtr</code></h2><p>为了解决上述问题，可以从以下几个方面入手：</p><h3 id="方法一：使用-std-atomic-管理引用计数"><a href="#方法一：使用-std-atomic-管理引用计数" class="headerlink" title="方法一：使用 std::atomic 管理引用计数"></a>方法一：使用 <code>std::atomic</code> 管理引用计数</h3><p>将 <code>ControlBlock::ref_count</code> 从普通的 <code>int</code> 替换为 <code>std::atomic&lt;int&gt;</code>，以确保引用计数的线程安全递增和递减。</p><p><strong>优点：</strong></p><ul><li>简单高效，避免使用互斥锁带来的性能开销。</li><li>类似于标准库中 <code>std::shared_ptr</code> 实现的引用计数管理。</li></ul><p><strong>缺点：</strong></p><ul><li>只能保证引用计数本身的线程安全，无法保护 <code>ptr</code> 和 <code>control</code> 的同步访问。</li></ul><h3 id="方法二：引入互斥锁保护指针操作"><a href="#方法二：引入互斥锁保护指针操作" class="headerlink" title="方法二：引入互斥锁保护指针操作"></a>方法二：引入互斥锁保护指针操作</h3><p>在 <code>SimpleSharedPtr</code> 中引入 <code>std::mutex</code>，在所有可能修改 <code>ptr</code> 和 <code>control</code> 的操作中加锁。</p><p><strong>优点：</strong></p><ul><li>确保 <code>ptr</code> 和 <code>control</code> 在多线程访问时的一致性。</li><li>提供更全面的线程安全保障。</li></ul><p><strong>缺点：</strong></p><ul><li>引入锁机制，可能带来性能开销，特别是在高并发场景下。</li></ul><h3 id="方法三：组合使用-std-atomic-和互斥锁"><a href="#方法三：组合使用-std-atomic-和互斥锁" class="headerlink" title="方法三：组合使用 std::atomic 和互斥锁"></a>方法三：组合使用 <code>std::atomic</code> 和互斥锁</h3><p>结合使用 <code>std::atomic&lt;int&gt;</code> 进行引用计数的管理，并使用 <code>std::mutex</code> 保护指针和控制块的访问。</p><p><strong>优点：</strong></p><ul><li>引用计数管理高效且线程安全。</li><li>指针和控制块的访问得到完全的同步保护。</li></ul><p><strong>缺点：</strong></p><ul><li>复杂性较高，需要同时管理原子操作和互斥锁。</li></ul><hr><h2 id="完整线程安全的-ThreadSafeSharedPtr-实现"><a href="#完整线程安全的-ThreadSafeSharedPtr-实现" class="headerlink" title="完整线程安全的 ThreadSafeSharedPtr 实现"></a>完整线程安全的 <code>ThreadSafeSharedPtr</code> 实现</h2><p>结合上述方法二和方法一，我们可以实现一个名为 <code>ThreadSafeSharedPtr</code> 的类模板，确保在多线程环境下的安全性。以下是具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制块结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的 shared_ptr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                 <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control;  <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，用于保护 ptr 和 control</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            <span class="comment">// 原子递减引用计数</span></span><br><span class="line">            <span class="keyword">if</span> (--(control-&gt;ref_count) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> control;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Resource and ControlBlock destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Decremented ref_count to &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">ThreadSafeSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructed ThreadSafeSharedPtr (nullptr).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadSafeSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Constructed ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ThreadSafeSharedPtr</span>(<span class="type">const</span> ThreadSafeSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mtx)</span></span>;</span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copied ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">    ThreadSafeSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadSafeSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 为避免死锁，使用 std::scoped_lock 同时锁定两个互斥锁</span></span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(mtx, other.mtx);</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                control-&gt;ref_count++;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Assigned ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">ThreadSafeSharedPtr</span>(ThreadSafeSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mtx)</span></span>;</span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved ThreadSafeSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    ThreadSafeSharedPtr&amp; <span class="keyword">operator</span>=(ThreadSafeSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 为避免死锁，使用 std::scoped_lock 同时锁定两个互斥锁</span></span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(mtx, other.mtx);</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move-assigned ThreadSafeSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ThreadSafeSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> control ? control-&gt;ref_count.<span class="built_in">load</span>() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        ptr = p;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Reset ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关键改动说明"><a href="#关键改动说明" class="headerlink" title="关键改动说明"></a>关键改动说明</h3><ol><li><p><strong>引用计数原子化</strong>：</p><ul><li><p>将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ControlBlock::ref_count</span><br></pre></td></tr></table></figure><p>从普通的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt;</span><br></pre></td></tr></table></figure><p>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ref_count;</span><br></pre></td></tr></table></figure></li><li><p>使用原子操作管理引用计数，确保多线程下的安全递增和递减：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">control-&gt;ref_count++;</span><br><span class="line"><span class="keyword">if</span> (--(control-&gt;ref_count) == <span class="number">0</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>ref_count.load()</code> 获取当前引用计数的值。</p></li></ul></li><li><p><strong>引入互斥锁</strong>：</p><ul><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadSafeSharedPtr</span><br></pre></td></tr></table></figure><p>中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx</span><br></pre></td></tr></table></figure><p>，用于保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control</span><br></pre></td></tr></table></figure><p>的访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> std::mutex mtx;</span><br></pre></td></tr></table></figure></li><li><p>在所有可能修改或访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control</span><br></pre></td></tr></table></figure><p>的成员函数中加锁，确保同步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在拷贝构造函数和拷贝赋值操作符中，为避免死锁，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::scoped_lock</span><br></pre></td></tr></table></figure><p>同时锁定两个互斥锁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx, other.mtx)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>线程安全的成员函数</strong>：</p><ul><li>对于 <code>operator*</code> 和 <code>operator-&gt;</code>，在返回前锁定互斥锁，确保在多线程环境中的安全访问。</li><li>其他成员函数如 <code>use_count</code>、<code>get</code> 和 <code>reset</code> 同样在访问共享资源前加锁。</li></ul></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>避免死锁</strong>：在需要同时锁定多个互斥锁时，使用 <code>std::scoped_lock</code>（C++17 引入）可以同时锁定多个互斥锁，避免死锁风险。</li><li><strong>性能开销</strong>：引入互斥锁会带来一定的性能开销，尤其是在高并发场景下。根据实际需求，权衡线程安全性和性能之间的关系。</li></ul><hr><h2 id="测试线程安全的-ThreadSafeSharedPtr"><a href="#测试线程安全的-ThreadSafeSharedPtr" class="headerlink" title="测试线程安全的 ThreadSafeSharedPtr"></a>测试线程安全的 <code>ThreadSafeSharedPtr</code></h2><p>为了验证 <code>ThreadSafeSharedPtr</code> 的线程安全性，我们可以编写一个多线程程序，让多个线程同时拷贝、赋值和销毁智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeSharedPtr.h&quot;</span> <span class="comment">// 假设将上述代码保存为该头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_copy</span><span class="params">(ThreadSafeSharedPtr&lt;Test&gt; sptr, <span class="type">int</span> thread_id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; is copying shared_ptr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ThreadSafeSharedPtr&lt;Test&gt; local_sptr = sptr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; copied shared_ptr, use_count = &quot;</span> &lt;&lt; local_sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    local_sptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_reset</span><span class="params">(ThreadSafeSharedPtr&lt;Test&gt;&amp; sptr, <span class="type">int</span> new_val, <span class="type">int</span> thread_id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; is resetting shared_ptr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(new_val));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; reset shared_ptr, use_count = &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating ThreadSafeSharedPtr with Test(100).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">ThreadSafeSharedPtr&lt;Test&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial use_count: &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程进行拷贝操作</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads_copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads_copy.<span class="built_in">emplace_back</span>(thread_func_copy, sptr, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads_copy) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After copy threads, use_count: &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程进行 reset 操作</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads_reset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads_reset.<span class="built_in">emplace_back</span>(thread_func_reset, std::<span class="built_in">ref</span>(sptr), <span class="number">200</span> + i, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads_reset) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After reset threads, final use_count: &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出示例（具体顺序可能因线程调度而异）：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Creating</span> <span class="string">ThreadSafeSharedPtr</span> <span class="string">with</span> <span class="string">Test(100).</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="string">Constructed</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Initial use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">0</span> <span class="string">is</span> <span class="string">copying</span> <span class="string">shared_ptr.</span></span><br><span class="line"><span class="string">Copied</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">0</span> <span class="string">copied</span> <span class="string">shared_ptr,</span> <span class="string">use_count</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">1</span> <span class="string">is</span> <span class="string">copying</span> <span class="string">shared_ptr.</span></span><br><span class="line"><span class="string">Copied</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">1</span> <span class="string">copied</span> <span class="string">shared_ptr,</span> <span class="string">use_count</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">After</span> <span class="string">copy</span> <span class="string">threads,</span> <span class="attr">use_count:</span> <span class="number">6</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">0</span> <span class="string">is</span> <span class="string">resetting</span> <span class="string">shared_ptr.</span></span><br><span class="line"><span class="string">Decremented</span> <span class="string">ref_count</span> <span class="string">to</span> <span class="number">5</span></span><br><span class="line"><span class="string">Resource</span> <span class="string">and</span> <span class="string">ControlBlock</span> <span class="string">destroyed.</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="string">Reset</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">After</span> <span class="string">reset</span> <span class="string">threads,</span> <span class="attr">final use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="string">Exiting</span> <span class="string">main.</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>多个线程同时拷贝 <code>sptr</code>，引用计数正确递增。</li><li>多个线程同时重置 <code>sptr</code>，确保引用计数和资源管理的正确性。</li><li>最终，只有最新分配的对象存在，引用计数为 <code>1</code>。</li></ul><hr><h2 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h2><ol><li><strong>引用计数的原子性</strong>：<ul><li>使用 <code>std::atomic&lt;int&gt;</code> 来保证引用计数的线程安全递增和递减。</li><li>避免使用普通的 <code>int</code>，因为在多线程环境下会导致数据竞争。</li></ul></li><li><strong>互斥锁的使用</strong>：<ul><li>使用 <code>std::mutex</code> 来保护 <code>ptr</code> 和 <code>control</code> 的访问，防止多个线程同时修改智能指针实例。</li><li>尽量缩小锁的范围，避免在互斥锁保护的临界区内执行耗时操作，以减少性能开销。</li></ul></li><li><strong>避免死锁</strong>：<ul><li>在需要同时锁定多个互斥锁时，使用 <code>std::scoped_lock</code> 来一次性锁定，确保锁的顺序一致，避免死锁风险。</li></ul></li><li><strong>尽量遵循 RAII 原则</strong>：<ul><li>使用 <code>std::lock_guard</code> 或 <code>std::scoped_lock</code> 等 RAII 机制来管理互斥锁，确保在异常抛出时自动释放锁，防止死锁。</li></ul></li><li><strong>避免多重管理</strong>：<ul><li>确保不通过裸指针绕过智能指针的引用计数管理，避免资源泄漏或重复释放。</li></ul></li><li><strong>性能考虑</strong>：<ul><li>在高并发场景下，频繁的锁操作可能成为性能瓶颈。根据实际需求，可以考虑使用更轻量级的同步机制，如 <code>std::shared_mutex</code>（C++17）用于读多写少的场景。</li></ul></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过将 <code>ControlBlock::ref_count</code> 改为 <code>std::atomic&lt;int&gt;</code>，并在 <code>ThreadSafeSharedPtr</code> 中引入互斥锁来保护 <code>ptr</code> 和 <code>control</code> 的访问，可以实现一个<strong>线程安全的智能指针</strong>。这种实现确保了在多线程环境下，多个线程可以安全地拷贝、赋值和销毁智能指针，同时正确管理引用计数和资源。</p><p><strong>关键点总结：</strong></p><ul><li><strong>引用计数的原子性</strong>：使用 <code>std::atomic&lt;int&gt;</code> 保证引用计数操作的线程安全。</li><li><strong>互斥锁保护</strong>：使用 <code>std::mutex</code> 保护智能指针实例的内部状态，防止多个线程同时修改。</li><li><strong>RAII 机制</strong>：利用 <code>std::lock_guard</code> 和 <code>std::scoped_lock</code> 等 RAII 机制，确保锁的正确管理和释放。</li><li><strong>避免死锁</strong>：在需要同时锁定多个互斥锁时，使用 <code>std::scoped_lock</code> 以避免死锁风险。</li><li><strong>性能优化</strong>：平衡线程安全性和性能，避免不必要的锁竞争。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现有-SimpleSharedPtr-的线程安全性分析&quot;&gt;&lt;a href=&quot;#现有-SimpleSharedPtr-的线程安全性分析&quot; class=&quot;headerlink&quot; title=&quot;现有 SimpleSharedPtr 的线程安全性分析&quot;&gt;&lt;/a&gt;现有 &lt;c</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>map用法和手写map</title>
    <link href="http://www.limerence2017.com/2024/12/27/cppbase28/"/>
    <id>http://www.limerence2017.com/2024/12/27/cppbase28/</id>
    <published>2024-12-27T06:11:08.000Z</published>
    <updated>2025-02-15T02:52:22.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-map用法"><a href="#std-map用法" class="headerlink" title="std::map用法"></a>std::map用法</h1><p><code>std::map</code> 是 C++ 标准模板库（STL）中的一个关联容器，用于存储键值对（key-value pairs），其中每个键都是唯一的，并且按照特定的顺序（通常是升序）自动排序。<code>std::map</code> 通常基于红黑树实现，提供对元素的高效查找、插入和删除操作。</p><h2 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h2><ul><li><strong>有序性</strong>：<code>std::map</code> 中的元素按照键的顺序自动排序，默认使用 <code>&lt;</code> 运算符进行比较。</li><li><strong>唯一键</strong>：每个键在 <code>std::map</code> 中必须是唯一的，如果尝试插入重复的键，则插入操作会失败。</li><li><strong>关联容器</strong>：通过键快速访问对应的值，通常具有对数时间复杂度（O(log n)）。</li><li><strong>可变性</strong>：可以动态地插入和删除元素。</li></ul><h2 id="2-头文件和命名空间"><a href="#2-头文件和命名空间" class="headerlink" title="2. 头文件和命名空间"></a>2. 头文件和命名空间</h2><p>要使用 <code>std::map</code>，需要包含头文件 <code>&lt;map&gt;</code> 并使用 <code>std</code> 命名空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h2 id="3-声明和初始化"><a href="#3-声明和初始化" class="headerlink" title="3. 声明和初始化"></a>3. 声明和初始化</h2><h3 id="3-1-声明一个-std-map"><a href="#3-1-声明一个-std-map" class="headerlink" title="3.1 声明一个 std::map"></a>3.1 声明一个 <code>std::map</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键为 int，值为 std::string 的 map</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键为 std::string，值为 double 的 map</span></span><br><span class="line">map&lt;string, <span class="type">double</span>&gt; priceMap;</span><br></pre></td></tr></table></figure><h3 id="3-2-初始化-std-map"><a href="#3-2-初始化-std-map" class="headerlink" title="3.2 初始化 std::map"></a>3.2 初始化 <code>std::map</code></h3><p>可以使用初始化列表或其他方法初始化 <code>map</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; myMap = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;Apple&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;Banana&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="string">&quot;Cherry&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-主要操作"><a href="#4-主要操作" class="headerlink" title="4. 主要操作"></a>4. 主要操作</h2><h3 id="4-1-插入元素"><a href="#4-1-插入元素" class="headerlink" title="4.1 插入元素"></a>4.1 插入元素</h3><p>有几种方法可以向 <code>std::map</code> 中插入元素：</p><h4 id="4-1-1-使用-insert-函数"><a href="#4-1-1-使用-insert-函数" class="headerlink" title="4.1.1 使用 insert 函数"></a>4.1.1 使用 <code>insert</code> 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;Date&quot;</span>));</span><br><span class="line"><span class="comment">// 或者使用 `make_pair`</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;Elderberry&quot;</span>));</span><br><span class="line"><span class="comment">// 或者使用初始化列表</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">6</span>, <span class="string">&quot;Fig&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-1-2-使用下标运算符"><a href="#4-1-2-使用下标运算符" class="headerlink" title="4.1.2 使用下标运算符 []"></a>4.1.2 使用下标运算符 <code>[]</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myMap[<span class="number">7</span>] = <span class="string">&quot;Grape&quot;</span>;</span><br><span class="line"><span class="comment">// 如果键 8 不存在，则会插入键 8 并赋值</span></span><br><span class="line">myMap[<span class="number">8</span>] = <span class="string">&quot;Honeydew&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 <code>[]</code> 运算符时，如果键不存在，会自动插入该键，并将值初始化为类型的默认值。</p><h3 id="4-2-访问元素"><a href="#4-2-访问元素" class="headerlink" title="4.2 访问元素"></a>4.2 访问元素</h3><h4 id="4-2-1-使用下标运算符"><a href="#4-2-1-使用下标运算符" class="headerlink" title="4.2.1 使用下标运算符 []"></a>4.2.1 使用下标运算符 <code>[]</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string fruit = myMap[<span class="number">1</span>]; <span class="comment">// 获取键为 1 的值 &quot;Apple&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果键不存在，<code>[]</code> 会插入该键并返回默认值。</p><h4 id="4-2-2-使用-at-成员函数"><a href="#4-2-2-使用-at-成员函数" class="headerlink" title="4.2.2 使用 at 成员函数"></a>4.2.2 使用 <code>at</code> 成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    string fruit = myMap.<span class="built_in">at</span>(<span class="number">2</span>); <span class="comment">// 获取键为 2 的值 &quot;Banana&quot;</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> out_of_range&amp; e) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>at</code> 函数在键不存在时会抛出 <code>std::out_of_range</code> 异常，适合需要异常处理的场景。</p><h4 id="4-2-3-使用-find-成员函数"><a href="#4-2-3-使用-find-成员函数" class="headerlink" title="4.2.3 使用 find 成员函数"></a>4.2.3 使用 <code>find</code> 成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key 3: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// 输出 &quot;Cherry&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key 3 not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find</code> 返回一个迭代器，指向找到的元素，若未找到则返回 <code>map::end()</code>。</p><h3 id="4-3-删除元素"><a href="#4-3-删除元素" class="headerlink" title="4.3 删除元素"></a>4.3 删除元素</h3><h4 id="4-3-1-使用-erase-函数"><a href="#4-3-1-使用-erase-函数" class="headerlink" title="4.3.1 使用 erase 函数"></a>4.3.1 使用 <code>erase</code> 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按键删除</span></span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按迭代器删除</span></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    myMap.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除区间 [first, last)</span></span><br><span class="line">myMap.<span class="built_in">erase</span>(myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">find</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h4 id="4-3-2-使用-clear-函数"><a href="#4-3-2-使用-clear-函数" class="headerlink" title="4.3.2 使用 clear 函数"></a>4.3.2 使用 <code>clear</code> 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap.<span class="built_in">clear</span>(); <span class="comment">// 删除所有元素</span></span><br></pre></td></tr></table></figure><h3 id="4-4-遍历-std-map"><a href="#4-4-遍历-std-map" class="headerlink" title="4.4 遍历 std::map"></a>4.4 遍历 <code>std::map</code></h3><h4 id="4-4-1-使用迭代器"><a href="#4-4-1-使用迭代器" class="headerlink" title="4.4.1 使用迭代器"></a>4.4.1 使用迭代器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, string&gt;::iterator it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-使用基于范围的-for-循环（C-11-及以上）"><a href="#4-4-2-使用基于范围的-for-循环（C-11-及以上）" class="headerlink" title="4.4.2 使用基于范围的 for 循环（C++11 及以上）"></a>4.4.2 使用基于范围的 <code>for</code> 循环（C++11 及以上）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-常用成员函数"><a href="#4-5-常用成员函数" class="headerlink" title="4.5 常用成员函数"></a>4.5 常用成员函数</h3><ul><li>**<code>size()</code>**：返回容器中元素的数量。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>count(key)</code>**：返回具有指定键的元素数量（对于 <code>map</code>，返回 0 或 1）。</li><li><strong><code>lower_bound(key)</code></strong> 和 **<code>upper_bound(key)</code>**：返回迭代器，分别指向第一个不小于和第一个大于指定键的元素。</li><li>**<code>equal_range(key)</code>**：返回一个范围，包含所有等于指定键的元素。</li></ul><h2 id="5-自定义键的排序"><a href="#5-自定义键的排序" class="headerlink" title="5. 自定义键的排序"></a>5. 自定义键的排序</h2><p>默认情况下，<code>std::map</code> 使用 <code>&lt;</code> 运算符对键进行排序。如果需要自定义排序方式，可以提供一个自定义的比较函数或函数对象。</p><h3 id="5-1-使用函数对象"><a href="#5-1-使用函数对象" class="headerlink" title="5.1 使用函数对象"></a>5.1 使用函数对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string, Compare&gt; myMapDesc;</span><br><span class="line">myMapDesc[<span class="number">1</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">myMapDesc[<span class="number">2</span>] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="5-2-使用-lambda-表达式（C-11-及以上）"><a href="#5-2-使用-lambda-表达式（C-11-及以上）" class="headerlink" title="5.2 使用 lambda 表达式（C++11 及以上）"></a>5.2 使用 lambda 表达式（C++11 及以上）</h3><p>需要注意，<code>std::map</code> 的第三个模板参数必须是可比较类型，不能直接使用 lambda 表达式作为模板参数。不过，可以使用 <code>std::function</code> 或自定义结构体来包装 lambda。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareLambda</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string, CompareLambda&gt; myMapDesc;</span><br><span class="line">myMapDesc[<span class="number">1</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="6-std-map-与其他关联容器的比较"><a href="#6-std-map-与其他关联容器的比较" class="headerlink" title="6. std::map 与其他关联容器的比较"></a>6. <code>std::map</code> 与其他关联容器的比较</h2><ul><li>**<code>std::unordered_map</code>**：基于哈希表实现，提供平均常数时间复杂度的查找、插入和删除操作，但不保证元素的顺序。适用于对顺序无要求且需要高效查找的场景。</li><li>**<code>std::multimap</code>**：允许多个相同键的元素，其他特性与 <code>std::map</code> 类似。适用于需要存储重复键值对的场景。</li></ul><h2 id="7-性能考虑"><a href="#7-性能考虑" class="headerlink" title="7. 性能考虑"></a>7. 性能考虑</h2><ul><li><p>时间复杂度</p><p>：</p><ul><li>查找、插入、删除：O(log n)</li><li>遍历：O(n)</li></ul></li><li><p><strong>空间复杂度</strong>：<code>std::map</code> 通常需要额外的空间来维护树结构，相比 <code>std::vector</code> 等序列容器，内存开销更大。</p></li></ul><p>选择使用 <code>std::map</code> 还是其他容器，应根据具体需求和性能要求进行权衡。</p><h2 id="8-完整示例"><a href="#8-完整示例" class="headerlink" title="8. 完整示例"></a>8. 完整示例</h2><p>以下是一个完整的示例，展示了 <code>std::map</code> 的基本用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 map，键为 int，值为 string</span></span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    myMap.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;Cherry&quot;</span>&#125;);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="string">&quot;Date&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key 1: &quot;</span> &lt;&lt; myMap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key 2: &quot;</span> &lt;&lt; myMap.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> keyToFind = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(keyToFind);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found key &quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key &quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 map</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;All elements:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After deleting key 2:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Map is not empty. Size: &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    myMap.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After clearing, map is &quot;</span> &lt;&lt; (myMap.<span class="built_in">empty</span>() ? <span class="string">&quot;empty.&quot;</span> : <span class="string">&quot;not empty.&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Key 1:</span> <span class="string">Apple</span></span><br><span class="line"><span class="attr">Key 2:</span> <span class="string">Banana</span></span><br><span class="line"><span class="attr">Found key 3:</span> <span class="string">Cherry</span></span><br><span class="line"><span class="attr">All elements:</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Apple</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Banana</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Cherry</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">4</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Date</span></span><br><span class="line"><span class="attr">After deleting key 2:</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Apple</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Cherry</span></span><br><span class="line"><span class="attr">Key:</span> <span class="number">4</span><span class="string">,</span> <span class="attr">Value:</span> <span class="string">Date</span></span><br><span class="line"><span class="attr">Map is not empty. Size:</span> <span class="number">3</span></span><br><span class="line"><span class="string">After</span> <span class="string">clearing,</span> <span class="string">map</span> <span class="string">is</span> <span class="string">empty.</span></span><br></pre></td></tr></table></figure><h1 id="BST实现map"><a href="#BST实现map" class="headerlink" title="BST实现map"></a>BST实现map</h1><h2 id="1-选择底层数据结构"><a href="#1-选择底层数据结构" class="headerlink" title="1. 选择底层数据结构"></a>1. 选择底层数据结构</h2><p><code>std::map</code> 通常基于平衡的二叉搜索树（如红黑树）实现，以保证操作的时间复杂度为 O(log n)。为了简化实现，本文将采用<strong>普通的二叉搜索树</strong>，即不进行自平衡处理。不过在实际应用中，为了保证性能，建议使用自平衡的树结构（例如红黑树、AVL 树）。</p><h2 id="2-设计数据结构"><a href="#2-设计数据结构" class="headerlink" title="2. 设计数据结构"></a>2. 设计数据结构</h2><h3 id="2-1-节点结构"><a href="#2-1-节点结构" class="headerlink" title="2.1 节点结构"></a>2.1 节点结构</h3><p>首先，需要定义树的节点结构，每个节点包含键值对以及指向子节点的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    std::pair&lt;Key, T&gt; data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode* parent;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value, TreeNode* parentNode = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data</span>(std::<span class="built_in">make_pair</span>(key, value)), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(parentNode) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-Map-类的定义"><a href="#2-2-Map-类的定义" class="headerlink" title="2.2 Map 类的定义"></a>2.2 Map 类的定义</h3><p>接下来，定义 <code>MyMap</code> 类，包含根节点和基本操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyMap</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyMap</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">MyMap</span>(<span class="type">const</span> MyMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyMap&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;Key, T&gt;(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;Key, T&gt;* current = root;</span><br><span class="line">        TreeNode&lt;Key, T&gt;* parent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; current-&gt;data.first) &#123;</span><br><span class="line">                current = current-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; current-&gt;data.first) &#123;</span><br><span class="line">                current = current-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 键已存在，更新值</span></span><br><span class="line">                current-&gt;data.second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt; parent-&gt;data.first) &#123;</span><br><span class="line">            parent-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;Key, T&gt;(key, value, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;Key, T&gt;(key, value, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素，返回指向节点的指针</span></span><br><span class="line">    <span class="function">TreeNode&lt;Key, T&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;Key, T&gt;* current = root;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; current-&gt;data.first) &#123;</span><br><span class="line">                current = current-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; current-&gt;data.first) &#123;</span><br><span class="line">                current = current-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;Key, T&gt;* node = <span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到要删除的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点有两个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到中序后继</span></span><br><span class="line">            TreeNode&lt;Key, T&gt;* successor = <span class="built_in">minimum</span>(node-&gt;right);</span><br><span class="line">            node-&gt;data = successor-&gt;data; <span class="comment">// 替换数据</span></span><br><span class="line">            node = successor; <span class="comment">// 将要删除的节点指向后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点有一个或没有子节点</span></span><br><span class="line">        TreeNode&lt;Key, T&gt;* child = (node-&gt;left) ? node-&gt;left : node-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            child-&gt;parent = node-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            root = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;</span><br><span class="line">            node-&gt;parent-&gt;left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;parent-&gt;right = child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">        root = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Iterator</span>(TreeNode&lt;Key, T&gt;* node = <span class="literal">nullptr</span>) : <span class="built_in">current</span>(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        std::pair&lt;<span class="type">const</span> Key, T&gt;&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::pair&lt;<span class="type">const</span> Key, T&gt;* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(current-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递增</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            current = <span class="built_in">successor</span>(current);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递增</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            current = <span class="built_in">successor</span>(current);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current == other.current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current != other.current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode&lt;Key, T&gt;* current;</span><br><span class="line"></span><br><span class="line">        <span class="function">TreeNode&lt;Key, T&gt;* <span class="title">minimum</span><span class="params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">TreeNode&lt;Key, T&gt;* <span class="title">successor</span><span class="params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">minimum</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;Key, T&gt;* p = node-&gt;parent;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; node == p-&gt;right) &#123;</span><br><span class="line">                node = p;</span><br><span class="line">                p = p-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="built_in">minimum</span>(root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;Key, T&gt;* root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除树中的所有节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(TreeNode&lt;Key, T&gt;* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">clear</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">clear</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小的节点</span></span><br><span class="line">    <span class="function">TreeNode&lt;Key, T&gt;* <span class="title">minimum</span><span class="params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最大的节点</span></span><br><span class="line">    <span class="function">TreeNode&lt;Key, T&gt;* <span class="title">maximum</span><span class="params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-解释"><a href="#2-3-解释" class="headerlink" title="2.3 解释"></a>2.3 解释</h3><ol><li><p><strong>TreeNode 结构</strong>：</p><ul><li><code>data</code>: 存储键值对 <code>std::pair&lt;Key, T&gt;</code>。</li><li><code>left</code> 和 <code>right</code>: 指向左子节点和右子节点。</li><li><code>parent</code>: 指向父节点，便于迭代器中查找后继节点。</li></ul></li><li><p><strong>MyMap 类</strong>：</p><ul><li><p>构造与析构</p><p>：</p><ul><li>构造函数初始化根节点为空。</li><li>析构函数调用 <code>clear</code> 释放所有节点内存。</li></ul></li><li><p>插入 (<code>insert</code>)</p><p>：</p><ul><li>从根节点开始，根据键的大小确定插入左子树还是右子树。</li><li>如果键已存在，更新对应的值。</li></ul></li><li><p>查找 (<code>find</code>)</p><p>：</p><ul><li>按照键的大小在树中查找对应的节点。</li></ul></li><li><p>删除 (<code>erase</code>)</p><p>：</p><ul><li>查找到目标节点。</li><li>如果节点有两个子节点，找到中序后继节点并替换当前节点的数据，然后删除后继节点。</li><li>如果节点有一个或没有子节点，直接替换节点指针并删除节点。</li></ul></li><li><p>清空 (<code>clear</code>)</p><p>：</p><ul><li>使用递归方式删除所有节点。</li></ul></li><li><p>迭代器</p><p>：</p><ul><li>定义了嵌套的 <code>Iterator</code> 类，支持前置和后置递增操作。</li><li>迭代器通过中序遍历实现，保证键的顺序性。</li><li><code>begin()</code> 返回最小的节点，<code>end()</code> 返回 <code>nullptr</code>。</li></ul></li></ul></li></ol><h2 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h2><p>下面提供一个使用 <code>MyMap</code> 的示例，展示插入、查找、删除和迭代操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyMap&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;grape&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历元素（按键的字母顺序）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Map contents (in-order):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string keyToFind = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> node = myMap.<span class="built_in">find</span>(keyToFind);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nFound &quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; with value: &quot;</span> &lt;&lt; node-&gt;data.second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter erasing apple and cherry:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map contents (in-order):</span><br><span class="line">apple =&gt; 3</span><br><span class="line">banana =&gt; 5</span><br><span class="line">cherry =&gt; 4</span><br><span class="line">grape =&gt; 7</span><br><span class="line">orange =&gt; 2</span><br><span class="line"></span><br><span class="line">Found banana with value: 5</span><br><span class="line"></span><br><span class="line">After erasing apple and cherry:</span><br><span class="line">banana =&gt; 5</span><br><span class="line">grape =&gt; 7</span><br><span class="line">orange =&gt; 2</span><br></pre></td></tr></table></figure><h2 id="4-迭代器的详细实现"><a href="#4-迭代器的详细实现" class="headerlink" title="4. 迭代器的详细实现"></a>4. 迭代器的详细实现</h2><p>为了支持迭代器的正常使用，<code>Iterator</code> 类实现了以下功能：</p><ul><li>**解引用操作符 (<code>operator\*</code> 和 <code>operator-&gt;</code>)**：<ul><li>允许访问键值对，如 <code>it-&gt;first</code> 和 <code>it-&gt;second</code>。</li></ul></li><li>**递增操作符 (<code>operator++</code>)**：<ul><li>前置递增（<code>++it</code>）和后置递增（<code>it++</code>）用于移动到下一个元素。</li><li>通过查找当前节点的中序后继节点实现。</li></ul></li><li>**比较操作符 (<code>operator==</code> 和 <code>operator!=</code>)**：<ul><li>判断两个迭代器是否指向同一个节点。</li></ul></li></ul><h3 id="中序后继节点的查找"><a href="#中序后继节点的查找" class="headerlink" title="中序后继节点的查找"></a>中序后继节点的查找</h3><p>迭代器使用中序遍历来确保键的有序性。计算后继节点的步骤如下：</p><ol><li><strong>当前节点有右子树</strong>：<ul><li>后继节点是右子树中的最小节点。</li></ul></li><li><strong>当前节点没有右子树</strong>：<ul><li>向上查找，直到找到一个节点是其父节点的左子树，此时父节点即为后继节点。</li></ul></li></ol><p>如果没有后继节点（即当前节点是最大的节点），则返回 <code>nullptr</code>，表示迭代器到达 <code>end()</code>。</p><h2 id="5-扩展功能"><a href="#5-扩展功能" class="headerlink" title="5. 扩展功能"></a>5. 扩展功能</h2><p>上述实现是一个基本的 <code>Map</code>，还可以根据需要扩展更多功能，例如：</p><ul><li><strong>支持 <code>const</code> 迭代器</strong>：<ul><li>定义 <code>const_iterator</code>，确保在只读操作时数据不被修改。</li></ul></li><li><strong>实现平衡树</strong>：<ul><li>为了提高性能，可以实现红黑树、AVL 树等自平衡二叉搜索树，保证操作的时间复杂度为 O(log n)。</li></ul></li><li><strong>添加更多成员函数</strong>：<ul><li>如 <code>operator[]</code>、<code>count</code>、<code>lower_bound</code>、<code>upper_bound</code> 等，增加容器的功能性。</li></ul></li><li><strong>异常处理</strong>：<ul><li>增加对异常情况的处理，例如在删除不存在的键时抛出异常等。</li></ul></li><li><strong>迭代器的逆向遍历</strong>：<ul><li>实现双向迭代器，支持逆序遍历（<code>rbegin()</code> 和 <code>rend()</code>）。</li></ul></li></ul><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>AVL树（Adelson-Velsky and Landis树）是一种自平衡的二叉搜索树（BST），它在插入和删除操作后通过旋转来保持树的平衡，从而确保基本操作（如查找、插入和删除）的时间复杂度保持在O(log n)。使用AVL树来实现<code>map</code>（键值对映射）是一个高效的选择，特别适合需要频繁查找、插入和删除操作的场景。</p><h2 id="1-模板化AVL树节点"><a href="#1-模板化AVL树节点" class="headerlink" title="1. 模板化AVL树节点"></a>1. 模板化AVL树节点</h2><p>首先，我们需要将<code>AVLNode</code>结构模板化，使其能够处理不同类型的键和值。我们假设键类型<code>KeyType</code>支持<code>operator&lt;</code>进行比较，因为AVL树需要对键进行排序以维护其性质。</p><p>首先，我们定义AVL树的节点。每个节点包含一个键（<code>key</code>）、一个值（<code>value</code>）、节点高度（<code>height</code>），以及指向左子节点和右子节点的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 用于 std::max</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 用于 std::function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板化的AVL树节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    ValueType value;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLNode* left;</span><br><span class="line">    AVLNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">const</span> KeyType&amp; k, <span class="type">const</span> ValueType&amp; val)</span><br><span class="line">        : <span class="built_in">key</span>(k), <span class="built_in">value</span>(val), <span class="built_in">height</span>(<span class="number">1</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：</p><ul><li><code>KeyType</code>：键的类型，需要支持比较操作（如 <code>operator&lt;</code>）。</li><li><code>ValueType</code>：值的类型，可以是任何类型。</li></ul></blockquote><h2 id="2-辅助函数的模板化"><a href="#2-辅助函数的模板化" class="headerlink" title="2. 辅助函数的模板化"></a>2. 辅助函数的模板化</h2><p>辅助函数同样需要模板化，以适应不同的<code>AVLNode</code>类型。</p><h3 id="获取节点高度"><a href="#获取节点高度" class="headerlink" title="获取节点高度"></a>获取节点高度</h3><p>获取节点的高度。如果节点为空，则高度为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取平衡因子"><a href="#获取平衡因子" class="headerlink" title="获取平衡因子"></a>获取平衡因子</h3><p>平衡因子（Balance Factor）是左子树高度减去右子树高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h3><p>右旋转用于处理左子树过高的情况（例如，左左情况）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    y                             x</span></span><br><span class="line"><span class="code">   / \                           / \</span></span><br><span class="line"><span class="code">  x   T3            ==&gt;          z   y</span></span><br><span class="line"><span class="code"> / \                               / \</span></span><br><span class="line"><span class="code">z   T2                            T2  T3</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">rightRotate</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* y)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* x = y-&gt;left;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    y-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的根</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h3><p>左旋转用于处理右子树过高的情况（例如，右右情况）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  x                             y</span><br><span class="line"> / \                           / \</span><br><span class="line">T1  y           ==&gt;            x   z</span><br><span class="line">   / \                       / \</span><br><span class="line">  T2  z                     T1  T2</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">leftRotate</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* x)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* y = x-&gt;right;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    x-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    y-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的根</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-AVL树的核心操作模板化"><a href="#3-AVL树的核心操作模板化" class="headerlink" title="3. AVL树的核心操作模板化"></a>3. AVL树的核心操作模板化</h2><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>插入操作遵循标准的二叉搜索树插入方式，然后通过旋转保持树的平衡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">insertNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node, <span class="type">const</span> KeyType&amp; key, <span class="type">const</span> ValueType&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 执行标准的BST插入</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;KeyType, ValueType&gt;(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = <span class="built_in">insertNode</span>(node-&gt;left, key, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = <span class="built_in">insertNode</span>(node-&gt;right, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果键已经存在，更新其值</span></span><br><span class="line">        node-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新节点高度</span></span><br><span class="line">    node-&gt;height = <span class="number">1</span> + std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;left), <span class="built_in">getHeight</span>(node-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据平衡因子进行旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><p>按键查找节点，返回对应的值。如果键不存在，返回<code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">ValueType* <span class="title">searchNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node, <span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == node-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchNode</span>(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchNode</span>(node-&gt;right, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取最小值节点"><a href="#获取最小值节点" class="headerlink" title="获取最小值节点"></a>获取最小值节点</h3><p>用于删除节点时找到中序后继。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">getMinValueNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除操作分为三种情况：删除节点是叶子节点、有一个子节点或有两个子节点。删除后，通过旋转保持树的平衡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">deleteNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* root, <span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 执行标准的BST删除</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点有一个或没有子节点</span></span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">nullptr</span>) || (root-&gt;right == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            AVLNode&lt;KeyType, ValueType&gt;* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 一个子节点</span></span><br><span class="line">                *root = *temp; <span class="comment">// 复制内容</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 节点有两个子节点，获取中序后继</span></span><br><span class="line">            AVLNode&lt;KeyType, ValueType&gt;* temp = <span class="built_in">getMinValueNode</span>(root-&gt;right);</span><br><span class="line">            <span class="comment">// 复制中序后继的内容到此节点</span></span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;value = temp-&gt;value;</span><br><span class="line">            <span class="comment">// 删除中序后继</span></span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新节点高度</span></span><br><span class="line">    root-&gt;height = <span class="number">1</span> + std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;left), <span class="built_in">getHeight</span>(root-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据平衡因子进行旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;left) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">leftRotate</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;right) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">rightRotate</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模板化的AVLMap类"><a href="#4-模板化的AVLMap类" class="headerlink" title="4. 模板化的AVLMap类"></a>4. 模板化的AVLMap类</h2><p>现在，我们将所有模板化的函数集成到一个模板类<code>AVLMap</code>中。这个类将提供如下功能：</p><ul><li><code>put(const KeyType&amp; key, const ValueType&amp; value)</code>：插入或更新键值对。</li><li><code>get(const KeyType&amp; key)</code>：查找键对应的值，返回指向值的指针，如果键不存在则返回<code>nullptr</code>。</li><li><code>remove(const KeyType&amp; key)</code>：删除指定键的键值对。</li><li><code>inorderTraversal()</code>：中序遍历，返回有序的键值对列表。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderHelper</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node, std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt;&amp; res)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">inorderHelper</span>(node-&gt;left, res);</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(node-&gt;key, node-&gt;value);</span><br><span class="line">            <span class="built_in">inorderHelper</span>(node-&gt;right, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLMap</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> KeyType&amp; key, <span class="type">const</span> ValueType&amp; value)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">insertNode</span>(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找值，返回指向值的指针，如果键不存在则返回nullptr</span></span><br><span class="line">    <span class="function">ValueType* <span class="title">get</span><span class="params">(<span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchNode</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">deleteNode</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历，返回有序的键值对</span></span><br><span class="line">    std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; <span class="built_in">inorderTraversal</span>() <span class="type">const</span> &#123;</span><br><span class="line">        std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; res;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，释放所有节点的内存</span></span><br><span class="line">    ~<span class="built_in">AVLMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 使用后序遍历释放节点</span></span><br><span class="line">        std::function&lt;<span class="type">void</span>(AVLNode&lt;KeyType, ValueType&gt;*)&gt; destroy = [&amp;](AVLNode&lt;KeyType, ValueType&gt;* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                <span class="built_in">destroy</span>(node-&gt;left);</span><br><span class="line">                <span class="built_in">destroy</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">destroy</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：</p><ul><li><p>模板参数</p><p>：</p><ul><li><code>KeyType</code>：键的类型，需要支持<code>operator&lt;</code>进行比较。</li><li><code>ValueType</code>：值的类型，可以是任意类型。</li></ul></li><li><p>内存管理</p><p>：</p><ul><li>析构函数使用后序遍历释放所有动态分配的节点，防止内存泄漏。</li></ul></li><li><p>异常安全</p><p>：</p><ul><li>当前实现没有处理异常情况。如果需要更高的异常安全性，可以进一步增强代码，例如在插入过程中捕获异常并回滚操作。</li></ul></li></ul></blockquote><h2 id="5-使用示例"><a href="#5-使用示例" class="headerlink" title="5. 使用示例"></a>5. 使用示例</h2><p>下面的示例展示了如何使用模板化的<code>AVLMap</code>类，使用不同类型的键和值。</p><h3 id="示例-1：使用int作为键，std-string作为值"><a href="#示例-1：使用int作为键，std-string作为值" class="headerlink" title="示例 1：使用int作为键，std::string作为值"></a>示例 1：使用<code>int</code>作为键，<code>std::string</code>作为值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设上面的AVLNode结构、辅助函数和AVLMap类已经定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVLMap&lt;<span class="type">int</span>, std::string&gt; avlMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="number">10</span>, <span class="string">&quot;十&quot;</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="number">20</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="number">30</span>, <span class="string">&quot;三十&quot;</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="number">40</span>, <span class="string">&quot;四十&quot;</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="number">50</span>, <span class="string">&quot;五十&quot;</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="number">25</span>, <span class="string">&quot;二十五&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; traversal = avlMap.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, \&quot;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;\&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键</span></span><br><span class="line">    std::string* val = avlMap.<span class="built_in">get</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键20的值: &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键20不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val = avlMap.<span class="built_in">get</span>(<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键25的值: &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键25不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val = avlMap.<span class="built_in">get</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键60的值: &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键60不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键20</span></span><br><span class="line">    avlMap.<span class="built_in">remove</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除键20后，中序遍历: &quot;</span>;</span><br><span class="line">    traversal = avlMap.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, \&quot;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;\&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中序遍历: (10, <span class="string">&quot;十&quot;</span>) (20, <span class="string">&quot;二十&quot;</span>) (25, <span class="string">&quot;二十五&quot;</span>) (30, <span class="string">&quot;三十&quot;</span>) (40, <span class="string">&quot;四十&quot;</span>) (50, <span class="string">&quot;五十&quot;</span>) </span><br><span class="line">获取键20的值: 二十</span><br><span class="line">获取键25的值: 二十五</span><br><span class="line">键60不存在。</span><br><span class="line">删除键20后，中序遍历: (10, <span class="string">&quot;十&quot;</span>) (25, <span class="string">&quot;二十五&quot;</span>) (30, <span class="string">&quot;三十&quot;</span>) (40, <span class="string">&quot;四十&quot;</span>) (50, <span class="string">&quot;五十&quot;</span>) </span><br></pre></td></tr></table></figure><h3 id="示例-2：使用std-string作为键，double作为值"><a href="#示例-2：使用std-string作为键，double作为值" class="headerlink" title="示例 2：使用std::string作为键，double作为值"></a>示例 2：使用<code>std::string</code>作为键，<code>double</code>作为值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设上面的AVLNode结构、辅助函数和AVLMap类已经定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVLMap&lt;std::string, <span class="type">double</span>&gt; avlMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">1.99</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">0.99</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">2.99</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="string">&quot;date&quot;</span>, <span class="number">3.49</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="string">&quot;elderberry&quot;</span>, <span class="number">5.99</span>);</span><br><span class="line">    avlMap.<span class="built_in">put</span>(<span class="string">&quot;fig&quot;</span>, <span class="number">2.49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; traversal = avlMap.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(\&quot;&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键</span></span><br><span class="line">    <span class="type">double</span>* val = avlMap.<span class="built_in">get</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键\&quot;banana\&quot;的值: &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键\&quot;banana\&quot;不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val = avlMap.<span class="built_in">get</span>(<span class="string">&quot;fig&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键\&quot;fig\&quot;的值: &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键\&quot;fig\&quot;不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val = avlMap.<span class="built_in">get</span>(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键\&quot;grape\&quot;的值: &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键\&quot;grape\&quot;不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键&quot;banana&quot;</span></span><br><span class="line">    avlMap.<span class="built_in">remove</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除键\&quot;banana\&quot;后，中序遍历: &quot;</span>;</span><br><span class="line">    traversal = avlMap.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(\&quot;&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中序遍历: (<span class="string">&quot;apple&quot;</span>, 1.99) (<span class="string">&quot;banana&quot;</span>, 0.99) (<span class="string">&quot;cherry&quot;</span>, 2.99) (<span class="string">&quot;date&quot;</span>, 3.49) (<span class="string">&quot;elderberry&quot;</span>, 5.99) (<span class="string">&quot;fig&quot;</span>, 2.49) </span><br><span class="line">获取键<span class="string">&quot;banana&quot;</span>的值: 0.99</span><br><span class="line">获取键<span class="string">&quot;fig&quot;</span>的值: 2.49</span><br><span class="line">键<span class="string">&quot;grape&quot;</span>不存在。</span><br><span class="line">删除键<span class="string">&quot;banana&quot;</span>后，中序遍历: (<span class="string">&quot;apple&quot;</span>, 1.99) (<span class="string">&quot;cherry&quot;</span>, 2.99) (<span class="string">&quot;date&quot;</span>, 3.49) (<span class="string">&quot;elderberry&quot;</span>, 5.99) (<span class="string">&quot;fig&quot;</span>, 2.49) </span><br></pre></td></tr></table></figure><h2 id="6-完整的通用代码"><a href="#6-完整的通用代码" class="headerlink" title="6. 完整的通用代码"></a>6. 完整的通用代码</h2><p>以下是模板化的<code>AVLMap</code>的完整实现代码，包括所有辅助函数和类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>   <span class="comment">// 用于 std::max</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  <span class="comment">// 用于 std::function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板化的AVL树节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    ValueType value;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLNode* left;</span><br><span class="line">    AVLNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">const</span> KeyType&amp; k, <span class="type">const</span> ValueType&amp; val)</span><br><span class="line">        : <span class="built_in">key</span>(k), <span class="built_in">value</span>(val), <span class="built_in">height</span>(<span class="number">1</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点高度</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取平衡因子</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋转</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">rightRotate</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* y)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* x = y-&gt;left;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    y-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的根</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋转</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">leftRotate</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* x)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* y = x-&gt;right;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    x-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    y-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的根</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">insertNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node, <span class="type">const</span> KeyType&amp; key, <span class="type">const</span> ValueType&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 执行标准的BST插入</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;KeyType, ValueType&gt;(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = <span class="built_in">insertNode</span>(node-&gt;left, key, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = <span class="built_in">insertNode</span>(node-&gt;right, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果键已经存在，更新其值</span></span><br><span class="line">        node-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新节点高度</span></span><br><span class="line">    node-&gt;height = <span class="number">1</span> + std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;left), <span class="built_in">getHeight</span>(node-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据平衡因子进行旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">ValueType* <span class="title">searchNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node, <span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == node-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchNode</span>(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchNode</span>(node-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">getMinValueNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">AVLNode&lt;KeyType, ValueType&gt;* <span class="title">deleteNode</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* root, <span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 执行标准的BST删除</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点有一个或没有子节点</span></span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">nullptr</span>) || (root-&gt;right == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            AVLNode&lt;KeyType, ValueType&gt;* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有子节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 一个子节点</span></span><br><span class="line">                *root = *temp; <span class="comment">// 复制内容</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 节点有两个子节点，获取中序后继</span></span><br><span class="line">            AVLNode&lt;KeyType, ValueType&gt;* temp = <span class="built_in">getMinValueNode</span>(root-&gt;right);</span><br><span class="line">            <span class="comment">// 复制中序后继的内容到此节点</span></span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;value = temp-&gt;value;</span><br><span class="line">            <span class="comment">// 删除中序后继</span></span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新节点高度</span></span><br><span class="line">    root-&gt;height = <span class="number">1</span> + std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;left), <span class="built_in">getHeight</span>(root-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据平衡因子进行旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;left) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">leftRotate</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;right) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">rightRotate</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板化的AVLMap类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLNode&lt;KeyType, ValueType&gt;* root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderHelper</span><span class="params">(AVLNode&lt;KeyType, ValueType&gt;* node, std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt;&amp; res)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">inorderHelper</span>(node-&gt;left, res);</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(node-&gt;key, node-&gt;value);</span><br><span class="line">            <span class="built_in">inorderHelper</span>(node-&gt;right, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLMap</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> KeyType&amp; key, <span class="type">const</span> ValueType&amp; value)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">insertNode</span>(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找值，返回指向值的指针，如果键不存在则返回nullptr</span></span><br><span class="line">    <span class="function">ValueType* <span class="title">get</span><span class="params">(<span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchNode</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> KeyType&amp; key)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">deleteNode</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历，返回有序的键值对</span></span><br><span class="line">    std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; <span class="built_in">inorderTraversal</span>() <span class="type">const</span> &#123;</span><br><span class="line">        std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; res;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，释放所有节点的内存</span></span><br><span class="line">    ~<span class="built_in">AVLMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 使用后序遍历释放节点</span></span><br><span class="line">        std::function&lt;<span class="type">void</span>(AVLNode&lt;KeyType, ValueType&gt;*)&gt; destroy = [&amp;](AVLNode&lt;KeyType, ValueType&gt;* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                <span class="built_in">destroy</span>(node-&gt;left);</span><br><span class="line">                <span class="built_in">destroy</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">destroy</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1：int 键，std::string 值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;示例 1：int 键，std::string 值\n&quot;</span>;</span><br><span class="line">    AVLMap&lt;<span class="type">int</span>, std::string&gt; avlMap1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    avlMap1.<span class="built_in">put</span>(<span class="number">10</span>, <span class="string">&quot;十&quot;</span>);</span><br><span class="line">    avlMap1.<span class="built_in">put</span>(<span class="number">20</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    avlMap1.<span class="built_in">put</span>(<span class="number">30</span>, <span class="string">&quot;三十&quot;</span>);</span><br><span class="line">    avlMap1.<span class="built_in">put</span>(<span class="number">40</span>, <span class="string">&quot;四十&quot;</span>);</span><br><span class="line">    avlMap1.<span class="built_in">put</span>(<span class="number">50</span>, <span class="string">&quot;五十&quot;</span>);</span><br><span class="line">    avlMap1.<span class="built_in">put</span>(<span class="number">25</span>, <span class="string">&quot;二十五&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; traversal1 = avlMap1.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, \&quot;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;\&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键</span></span><br><span class="line">    std::string* val1 = avlMap1.<span class="built_in">get</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (val1)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键20的值: &quot;</span> &lt;&lt; *val1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键20不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val1 = avlMap1.<span class="built_in">get</span>(<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">if</span> (val1)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键25的值: &quot;</span> &lt;&lt; *val1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键25不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val1 = avlMap1.<span class="built_in">get</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (val1)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键60的值: &quot;</span> &lt;&lt; *val1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键60不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键20</span></span><br><span class="line">    avlMap1.<span class="built_in">remove</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除键20后，中序遍历: &quot;</span>;</span><br><span class="line">    traversal1 = avlMap1.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, \&quot;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;\&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n-----------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：std::string 键，double 值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;示例 2：std::string 键，double 值\n&quot;</span>;</span><br><span class="line">    AVLMap&lt;std::string, <span class="type">double</span>&gt; avlMap2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    avlMap2.<span class="built_in">put</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">1.99</span>);</span><br><span class="line">    avlMap2.<span class="built_in">put</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">0.99</span>);</span><br><span class="line">    avlMap2.<span class="built_in">put</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">2.99</span>);</span><br><span class="line">    avlMap2.<span class="built_in">put</span>(<span class="string">&quot;date&quot;</span>, <span class="number">3.49</span>);</span><br><span class="line">    avlMap2.<span class="built_in">put</span>(<span class="string">&quot;elderberry&quot;</span>, <span class="number">5.99</span>);</span><br><span class="line">    avlMap2.<span class="built_in">put</span>(<span class="string">&quot;fig&quot;</span>, <span class="number">2.49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; traversal2 = avlMap2.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(\&quot;&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键</span></span><br><span class="line">    <span class="type">double</span>* val2 = avlMap2.<span class="built_in">get</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键\&quot;banana\&quot;的值: &quot;</span> &lt;&lt; *val2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键\&quot;banana\&quot;不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val2 = avlMap2.<span class="built_in">get</span>(<span class="string">&quot;fig&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键\&quot;fig\&quot;的值: &quot;</span> &lt;&lt; *val2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键\&quot;fig\&quot;不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    val2 = avlMap2.<span class="built_in">get</span>(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取键\&quot;grape\&quot;的值: &quot;</span> &lt;&lt; *val2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键\&quot;grape\&quot;不存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键&quot;banana&quot;</span></span><br><span class="line">    avlMap2.<span class="built_in">remove</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除键\&quot;banana\&quot;后，中序遍历: &quot;</span>;</span><br><span class="line">    traversal2 = avlMap2.<span class="built_in">inorderTraversal</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : traversal2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(\&quot;&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><strong>平衡维护</strong>：在每次插入或删除后，都会更新节点的高度并计算平衡因子。如果某个节点的平衡因子超出了<code>[-1, 1]</code>范围，就需要通过旋转来重新平衡树。</li><li><strong>查找操作</strong>：由于AVL树的高度被保持在<code>O(log n)</code>，查找操作的时间复杂度为<code>O(log n)</code>。</li><li><strong>更新操作</strong>：如果插入的键已经存在，则更新其对应的值。</li><li><strong>遍历操作</strong>：中序遍历可以按键的顺序遍历所有键值对。</li><li><strong>内存管理</strong>：确保在析构函数中正确释放所有动态分配的内存，避免内存泄漏。</li><li><strong>泛型支持（可选）</strong>：为了使<code>AVLMap</code>更加通用，可以将其模板化，以支持不同类型的键和值。例如：</li></ol><p><strong>编译与运行</strong>：</p><p>假设保存为 <code>avlmap.cpp</code>，使用以下命令编译并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -o avlmap avlmap.cpp</span><br><span class="line">./avlmap</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：<span class="type">int</span> 键，std::string 值</span><br><span class="line">中序遍历: (<span class="number">10</span>, <span class="string">&quot;十&quot;</span>) (<span class="number">20</span>, <span class="string">&quot;二十&quot;</span>) (<span class="number">25</span>, <span class="string">&quot;二十五&quot;</span>) (<span class="number">30</span>, <span class="string">&quot;三十&quot;</span>) (<span class="number">40</span>, <span class="string">&quot;四十&quot;</span>) (<span class="number">50</span>, <span class="string">&quot;五十&quot;</span>) </span><br><span class="line">获取键<span class="number">20</span>的值: 二十</span><br><span class="line">获取键<span class="number">25</span>的值: 二十五</span><br><span class="line">键<span class="number">60</span>不存在。</span><br><span class="line">删除键<span class="number">20</span>后，中序遍历: (<span class="number">10</span>, <span class="string">&quot;十&quot;</span>) (<span class="number">25</span>, <span class="string">&quot;二十五&quot;</span>) (<span class="number">30</span>, <span class="string">&quot;三十&quot;</span>) (<span class="number">40</span>, <span class="string">&quot;四十&quot;</span>) (<span class="number">50</span>, <span class="string">&quot;五十&quot;</span>) </span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">示例 <span class="number">2</span>：std::string 键，<span class="type">double</span> 值</span><br><span class="line">中序遍历: (<span class="string">&quot;apple&quot;</span>, <span class="number">1.99</span>) (<span class="string">&quot;banana&quot;</span>, <span class="number">0.99</span>) (<span class="string">&quot;cherry&quot;</span>, <span class="number">2.99</span>) (<span class="string">&quot;date&quot;</span>, <span class="number">3.49</span>) (<span class="string">&quot;elderberry&quot;</span>, <span class="number">5.99</span>) (<span class="string">&quot;fig&quot;</span>, <span class="number">2.49</span>) </span><br><span class="line">获取键<span class="string">&quot;banana&quot;</span>的值: <span class="number">0.99</span></span><br><span class="line">获取键<span class="string">&quot;fig&quot;</span>的值: <span class="number">2.49</span></span><br><span class="line">键<span class="string">&quot;grape&quot;</span>不存在。</span><br><span class="line">删除键<span class="string">&quot;banana&quot;</span>后，中序遍历: (<span class="string">&quot;apple&quot;</span>, <span class="number">1.99</span>) (<span class="string">&quot;cherry&quot;</span>, <span class="number">2.99</span>) (<span class="string">&quot;date&quot;</span>, <span class="number">3.49</span>) (<span class="string">&quot;elderberry&quot;</span>, <span class="number">5.99</span>) (<span class="string">&quot;fig&quot;</span>, <span class="number">2.49</span>) </span><br></pre></td></tr></table></figure><h2 id="7-注意事项与扩展"><a href="#7-注意事项与扩展" class="headerlink" title="7. 注意事项与扩展"></a>7. 注意事项与扩展</h2><h3 id="1-键类型的要求"><a href="#1-键类型的要求" class="headerlink" title="1. 键类型的要求"></a>1. 键类型的要求</h3><p>为了使<code>AVLMap</code>正常工作，键类型<code>KeyType</code>必须支持以下操作：</p><ul><li><p><strong>比较操作</strong>：必须定义<code>operator&lt;</code>，因为AVL树依赖于它来维护排序。如果使用自定义类型作为键，请确保定义了<code>operator&lt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomKey</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CustomKey&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id != other.id)</span><br><span class="line">            <span class="keyword">return</span> id &lt; other.id;</span><br><span class="line">        <span class="keyword">return</span> name &lt; other.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-泛型支持与约束"><a href="#2-泛型支持与约束" class="headerlink" title="2. 泛型支持与约束"></a>2. 泛型支持与约束</h3><p>在C++20之前，模板并不支持在模板参数上强制施加约束（需要依赖文档和用户理解）。从C++20起，可以使用<strong>概念（Concepts）</strong>来施加约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">requires</span> std::totally_ordered&lt;KeyType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLMap</span> &#123;</span><br><span class="line">    <span class="comment">// 类定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，编译器会在实例化模板时检查<code>KeyType</code>是否满足<code>std::totally_ordered</code>，即是否支持所有必要的比较操作。</p><h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. 性能优化</h3><ul><li><strong>内存管理</strong>：当前实现使用递归进行插入和删除，如果树非常深，可能会导致栈溢出。可以考虑使用迭代方法或优化递归深度。</li><li><strong>缓存友好</strong>：使用自适应数据结构（如缓存友好的节点布局）可以提升性能。</li><li><strong>多线程支持</strong>：当前实现不是线程安全的。如果需要在多线程环境中使用，需要添加适当的同步机制。</li></ul><h3 id="4-额外功能"><a href="#4-额外功能" class="headerlink" title="4. 额外功能"></a>4. 额外功能</h3><p>根据需求，你可以为<code>AVLMap</code>添加更多功能：</p><ul><li><strong>迭代器</strong>：实现输入迭代器、中序遍历迭代器，以便支持范围基（range-based）<code>for</code>循环。</li><li><strong>查找最小/最大键</strong>：提供方法<code>findMin()</code>和<code>findMax()</code>。</li><li><strong>前驱/后继查找</strong>：在树中查找给定键的前驱和后继节点。</li><li><strong>支持不同的平衡因子策略</strong>：例如，允许用户指定自定义的平衡策略。</li></ul><h3 id="5-与标准库的比较"><a href="#5-与标准库的比较" class="headerlink" title="5. 与标准库的比较"></a>5. 与标准库的比较</h3><p>虽然自己实现<code>AVLMap</code>是一项很好的学习练习，但在实际生产环境中，建议使用C++标准库中已经高度优化和测试过的容器，如<code>std::map</code>（通常实现为红黑树）、<code>std::unordered_map</code>（哈希表）等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::map</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; stdMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    stdMap[<span class="number">10</span>] = <span class="string">&quot;十&quot;</span>;</span><br><span class="line">    stdMap[<span class="number">20</span>] = <span class="string">&quot;二十&quot;</span>;</span><br><span class="line">    stdMap[<span class="number">30</span>] = <span class="string">&quot;三十&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : stdMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, \&quot;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot;\&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::map</code>提供了与<code>AVLMap</code>类似的功能，并且经过了高度优化，适用于大多数应用场景。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树（<strong>Red-Black Tree</strong>）是一种自平衡的二叉搜索树，它通过对节点进行颜色标记（红色或黑色）并遵循特定的规则来保证树的平衡性，从而确保基本操作（如查找、插入、删除）的时间复杂度为 **O(log n)**。红黑树广泛应用于计算机科学中，例如在实现关联容器（如 <code>std::map</code>、<code>std::set</code>）时常用到。</p><h2 id="1-红黑树的五大性质"><a href="#1-红黑树的五大性质" class="headerlink" title="1. 红黑树的五大性质"></a>1. 红黑树的五大性质</h2><p>红黑树通过以下 <strong>五大性质</strong> 维持其平衡性：</p><ol><li><strong>节点颜色</strong>：每个节点要么是<strong>红色</strong>，要么是<strong>黑色</strong>。</li><li><strong>根节点颜色</strong>：根节点是<strong>黑色</strong>。</li><li><strong>叶子节点颜色</strong>：所有叶子节点（NIL 节点，即空节点）都是<strong>黑色</strong>的。这里的叶子节点不存储实际数据，仅作为树的终端。</li><li><strong>红色节点限制</strong>：如果一个节点是<strong>红色</strong>的，则它的两个子节点都是<strong>黑色</strong>的。也就是说，<strong>红色节点不能有红色的子节点</strong>。</li><li><strong>黑色平衡</strong>：从任意节点到其所有后代叶子节点的路径上，<strong>包含相同数量的黑色节点</strong>。这被称为每条路径上的<strong>黑色高度</strong>相同。</li></ol><h3 id="这些性质的意义"><a href="#这些性质的意义" class="headerlink" title="这些性质的意义"></a>这些性质的意义</h3><ul><li><strong>性质1</strong> 和 <strong>性质2</strong> 确保节点颜色的基本规则，便于后续操作中进行颜色判断和调整。</li><li><strong>性质3</strong> 保证了所有实际节点的子节点（NIL 节点）的统一性，简化了操作逻辑。</li><li><strong>性质4</strong> 防止了连续的红色节点出现，避免导致过度不平衡。</li><li><strong>性质5</strong> 保证了树的平衡性，使得树的高度始终保持在 <strong>O(log n)</strong> 的范围内，从而确保基本操作的高效性。</li></ul><p>这些性质共同作用，使得红黑树在最坏情况下也能保持较好的性能表现。</p><hr><h2 id="2-红黑树的插入操作"><a href="#2-红黑树的插入操作" class="headerlink" title="2. 红黑树的插入操作"></a>2. 红黑树的插入操作</h2><p>插入操作是红黑树中常见的操作，与标准的二叉搜索树（BST）插入类似，但需要额外的步骤来维护红黑树的性质。</p><h3 id="2-1-插入步骤概述"><a href="#2-1-插入步骤概述" class="headerlink" title="2.1 插入步骤概述"></a>2.1 插入步骤概述</h3><p>插入操作通常分为以下两个主要步骤：</p><ol><li><strong>标准二叉搜索树插入</strong>：根据键值比较，将新节点插入到合适的位置，初始颜色为<strong>红色</strong>。</li><li><strong>插入后的修正（Insert Fixup）</strong>：通过重新着色和旋转操作，恢复红黑树的五大性质。</li></ol><h3 id="2-2-插入后的修正（Insert-Fixup）"><a href="#2-2-插入后的修正（Insert-Fixup）" class="headerlink" title="2.2 插入后的修正（Insert Fixup）"></a>2.2 插入后的修正（Insert Fixup）</h3><p>插入一个红色节点可能会破坏红黑树的性质，尤其是<strong>性质4</strong>（红色节点不能连续）。为了修复这些潜在的冲突，需要进行颜色调整和旋转操作。</p><h4 id="修正步骤："><a href="#修正步骤：" class="headerlink" title="修正步骤："></a>修正步骤：</h4><p>插入修正的过程通常遵循以下规则（以下描述假设新插入的节点 <strong>z</strong> 是红色）：</p><ol><li><strong>父节点为黑色</strong>：<ul><li>如果 <strong>z</strong> 的父节点是黑色的，那么插入操作不会破坏红黑树的性质，修正过程结束。</li></ul></li><li><strong>父节点为红色</strong>：<ul><li><strong>情况1</strong>：<strong>z</strong> 的叔叔节点（即 <strong>z</strong> 的父节点的兄弟节点）也是红色。<ul><li>将父节点和叔叔节点重新着色为黑色。</li><li>将祖父节点重新着色为红色。</li><li>将 <strong>z</strong> 指向祖父节点，继续检查上层节点，防止高层的性质被破坏。</li></ul></li><li><strong>情况2</strong>：<strong>z</strong> 的叔叔节点是黑色，且 <strong>z</strong> 是其父节点的右子节点。<ul><li>对 <strong>z</strong> 的父节点进行左旋转。</li><li>将 <strong>z</strong> 指向其新的左子节点（即原父节点）。</li></ul></li><li><strong>情况3</strong>：<strong>z</strong> 的叔叔节点是黑色，且 <strong>z</strong> 是其父节点的左子节点。<ul><li>将父节点重新着色为黑色。</li><li>将祖父节点重新着色为红色。</li><li>对祖父节点进行右旋转。</li></ul></li></ul></li></ol><h4 id="旋转操作的重要性"><a href="#旋转操作的重要性" class="headerlink" title="旋转操作的重要性"></a>旋转操作的重要性</h4><p>在修正过程中，<strong>旋转操作</strong>用于调整树的局部结构，使得红黑树的性质得以恢复。这些旋转包括<strong>左旋转</strong>和<strong>右旋转</strong>，在后续章节中将详细介绍。</p><h4 id="插入修正的代码实现示例"><a href="#插入修正的代码实现示例" class="headerlink" title="插入修正的代码实现示例"></a>插入修正的代码实现示例</h4><p>以下是红黑树插入修正的一个简化版 C++ 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="type">void</span> RedBlackTree&lt;Key, Value&gt;::<span class="built_in">insertFixUp</span>(RBTreeNode&lt;Key, Value&gt;* z) &#123;</span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent != <span class="literal">nullptr</span> &amp;&amp; z-&gt;parent-&gt;color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">            RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;right; <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y != <span class="literal">nullptr</span> &amp;&amp; y-&gt;color == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1：叔叔为红色</span></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = z-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;</span><br><span class="line">                    <span class="comment">// 情况2：z为右子节点</span></span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(z);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3：z为左子节点</span></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rightRotate</span>(z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况对称：父节点是右子节点</span></span><br><span class="line">            RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;left; <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y != <span class="literal">nullptr</span> &amp;&amp; y-&gt;color == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1</span></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = z-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                    <span class="comment">// 情况2</span></span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(z);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3</span></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">leftRotate</span>(z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;color = BLACK; <span class="comment">// 最终根节点必须为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-红黑树的删除操作"><a href="#3-红黑树的删除操作" class="headerlink" title="3. 红黑树的删除操作"></a>3. 红黑树的删除操作</h2><p>删除操作同样重要且复杂，因为它可能破坏红黑树的多个性质。与插入类似，删除操作也需要两个主要步骤：</p><ol><li><strong>标准二叉搜索树删除</strong>：按照 BST 的规则删除节点。</li><li><strong>删除后的修正（Delete Fixup）</strong>：通过重新着色和旋转操作，恢复红黑树的性质。</li></ol><h3 id="3-1-删除步骤概述"><a href="#3-1-删除步骤概述" class="headerlink" title="3.1 删除步骤概述"></a>3.1 删除步骤概述</h3><p>删除操作分为以下步骤：</p><ol><li><strong>定位要删除的节点</strong>：<ul><li>如果要删除的节点 <strong>z</strong> 有两个子节点，则找到其中序后继节点 <strong>y</strong>（即 <strong>z</strong> 的右子树中的最小节点）。</li><li>将 <strong>y</strong> 的值复制到 <strong>z</strong>，然后将删除目标转移到 <strong>y</strong>。此时 <strong>y</strong> 至多只有一个子节点。</li></ul></li><li><strong>删除节点</strong>：<ul><li>若 <strong>y</strong> 只有一个子节点 <strong>x</strong>（可能为 NIL），则用 <strong>x</strong> 替代 <strong>y</strong> 的位置。</li><li>记录被删除节点的原颜色 <strong>y_original_color</strong>。</li></ul></li><li><strong>删除修正</strong>（仅当 <strong>y_original_color</strong> 为黑色时）：<ul><li>因为删除一个黑色节点会影响路径上的黑色数量，需通过多次调整来恢复红黑树的性质。</li></ul></li></ol><h3 id="3-2-删除后的修正（Delete-Fixup）"><a href="#3-2-删除后的修正（Delete-Fixup）" class="headerlink" title="3.2 删除后的修正（Delete Fixup）"></a>3.2 删除后的修正（Delete Fixup）</h3><p>删除后的修正较为复杂，涉及多种情况处理。以下为主要的修正步骤和可能遇到的情况：</p><h4 id="修正步骤：-1"><a href="#修正步骤：-1" class="headerlink" title="修正步骤："></a>修正步骤：</h4><ol><li><p><strong>初始化</strong>：设 <strong>x</strong> 为替代被删除的节点的位置，<strong>x</strong> 可能为实际节点或 NIL 节点。</p></li><li><p><strong>循环修正</strong>：</p><ul><li>当 <strong>x</strong> 不是根节点，且 <strong>x</strong> 的颜色为<strong>黑色</strong>，进入修正循环。</li><li>判断 <strong>x</strong> 是其父节点的左子节点还是右子节点，并相应地设定兄弟节点 <strong>w</strong>。</li></ul></li><li><p><strong>处理不同情况</strong>：</p><p><strong>情况1</strong>：<strong>w</strong> 是红色的。</p><ul><li>将 <strong>w</strong> 重新着色为黑色。</li><li>将 <strong>x</strong> 的父节点重新着色为红色。</li><li>对 <strong>x</strong> 的父节点进行左旋转或右旋转，取决于是左子节点还是右子节点。</li><li>更新 <strong>w</strong>，继续修正过程。</li></ul><p><strong>情况2</strong>：<strong>w</strong> 是黑色，且 <strong>w</strong> 的两个子节点都是黑色。</p><ul><li>将 <strong>w</strong> 重新着色为红色。</li><li>将 <strong>x</strong> 设为其父节点，继续修正。</li></ul><p><strong>情况3</strong>：<strong>w</strong> 是黑色，且 <strong>w</strong> 的左子节点是红色，右子节点是黑色。</p><ul><li>将 <strong>w</strong> 的左子节点重新着色为黑色。</li><li>将 <strong>w</strong> 重新着色为红色。</li><li>对 <strong>w</strong> 进行右旋转或左旋转，取决于是左子节点还是右子节点。</li><li>更新 <strong>w</strong>，进入<strong>情况4</strong>。</li></ul><p><strong>情况4</strong>：<strong>w</strong> 是黑色，且 <strong>w</strong> 的右子节点是红色。</p><ul><li>将 <strong>w</strong> 的颜色设为 <strong>x</strong> 的父节点颜色。</li><li>将 <strong>x</strong> 的父节点重新着色为黑色。</li><li>将 <strong>w</strong> 的右子节点重新着色为黑色。</li><li>对 <strong>x</strong> 的父节点进行左旋转或右旋转，取决于是左子节点还是右子节点。</li><li>结束修正。</li></ul></li><li><p><strong>最终步骤</strong>：将 <strong>x</strong> 设为根节点，并将其颜色设为黑色，确保根节点的颜色为黑色。</p></li></ol><h4 id="删除修正的代码实现示例"><a href="#删除修正的代码实现示例" class="headerlink" title="删除修正的代码实现示例"></a>删除修正的代码实现示例</h4><p>由于删除修正涉及较多的情况，以下为一个简化版的红黑树删除修正的 C++ 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="type">void</span> RedBlackTree&lt;Key, Value&gt;::<span class="built_in">deleteFixUp</span>(RBTreeNode&lt;Key, Value&gt;* x) &#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; (x == <span class="literal">nullptr</span> || x-&gt;color == BLACK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">            RBTreeNode&lt;Key, Value&gt;* w = x-&gt;parent-&gt;right; <span class="comment">// 兄弟节点</span></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1</span></span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">leftRotate</span>(x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;left == <span class="literal">nullptr</span> || w-&gt;left-&gt;color == BLACK) &amp;&amp;</span><br><span class="line">                (w-&gt;right == <span class="literal">nullptr</span> || w-&gt;right-&gt;color == BLACK)) &#123;</span><br><span class="line">                <span class="comment">// 情况2</span></span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;right == <span class="literal">nullptr</span> || w-&gt;right-&gt;color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况3</span></span><br><span class="line">                    <span class="keyword">if</span> (w-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                        w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(w);</span><br><span class="line">                    w = x-&gt;parent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况4</span></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                <span class="built_in">leftRotate</span>(x-&gt;parent);</span><br><span class="line">                x = root; <span class="comment">// 修正完成</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况对称：x 是右子节点</span></span><br><span class="line">            RBTreeNode&lt;Key, Value&gt;* w = x-&gt;parent-&gt;left; <span class="comment">// 兄弟节点</span></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1</span></span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rightRotate</span>(x-&gt;parent);</span><br><span class="line">                w = x-&gt;parent-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((w-&gt;right == <span class="literal">nullptr</span> || w-&gt;right-&gt;color == BLACK) &amp;&amp;</span><br><span class="line">                (w-&gt;left == <span class="literal">nullptr</span> || w-&gt;left-&gt;color == BLACK)) &#123;</span><br><span class="line">                <span class="comment">// 情况2</span></span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;left == <span class="literal">nullptr</span> || w-&gt;left-&gt;color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况3</span></span><br><span class="line">                    <span class="keyword">if</span> (w-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                        w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(w);</span><br><span class="line">                    w = x-&gt;parent-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况4</span></span><br><span class="line">                w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                <span class="built_in">rightRotate</span>(x-&gt;parent);</span><br><span class="line">                x = root; <span class="comment">// 修正完成</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">nullptr</span>)</span><br><span class="line">        x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-旋转操作详解"><a href="#4-旋转操作详解" class="headerlink" title="4. 旋转操作详解"></a>4. 旋转操作详解</h2><p><strong>旋转操作</strong>是红黑树中用于重新平衡树的关键操作，包括<strong>左旋转</strong>和<strong>右旋转</strong>。旋转操作通过调整节点的父子关系，改变树的局部结构，从而保持红黑树的性质。</p><h3 id="4-1-左旋转（Left-Rotate）"><a href="#4-1-左旋转（Left-Rotate）" class="headerlink" title="4.1 左旋转（Left Rotate）"></a>4.1 左旋转（Left Rotate）</h3><p><strong>左旋转</strong>围绕节点 <strong>x</strong> 进行，其目的是将 <strong>x</strong> 的右子节点 <strong>y</strong> 提升为 <strong>x</strong> 的父节点，<strong>x</strong> 变为 <strong>y</strong> 的左子节点，<strong>y</strong> 的左子节点 <strong>b</strong> 成为 <strong>x</strong> 的右子节点。</p><p><strong>旋转前：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  x</span><br><span class="line"> / \</span><br><span class="line"><span class="selector-tag">a</span>   y</span><br><span class="line">   / \</span><br><span class="line">  <span class="selector-tag">b</span>   c</span><br></pre></td></tr></table></figure><p><strong>旋转后：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    y</span><br><span class="line">   / \</span><br><span class="line">  x   c</span><br><span class="line"> / \</span><br><span class="line"><span class="selector-tag">a</span>   <span class="selector-tag">b</span></span><br></pre></td></tr></table></figure><p><strong>左旋转的代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="type">void</span> RedBlackTree&lt;Key, Value&gt;::<span class="built_in">leftRotate</span>(RBTreeNode&lt;Key, Value&gt;* x) &#123;</span><br><span class="line">    RBTreeNode&lt;Key, Value&gt;* y = x-&gt;right;</span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line"></span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == <span class="literal">nullptr</span>)</span><br><span class="line">        root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-右旋转（Right-Rotate）"><a href="#4-2-右旋转（Right-Rotate）" class="headerlink" title="4.2 右旋转（Right Rotate）"></a>4.2 右旋转（Right Rotate）</h3><p><strong>右旋转</strong>是 <strong>左旋转</strong> 的镜像操作，围绕节点 <strong>y</strong> 进行，其目的是将 <strong>y</strong> 的左子节点 <strong>x</strong> 提升为 <strong>y</strong> 的父节点，<strong>y</strong> 变为 <strong>x</strong> 的右子节点，<strong>x</strong> 的右子节点 <strong>b</strong> 成为 <strong>y</strong> 的左子节点。</p><p><strong>旋转前：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    y</span><br><span class="line">   / \</span><br><span class="line">  x   c</span><br><span class="line"> / \</span><br><span class="line"><span class="selector-tag">a</span>   <span class="selector-tag">b</span></span><br></pre></td></tr></table></figure><p><strong>旋转后：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  x</span><br><span class="line"> / \</span><br><span class="line"><span class="selector-tag">a</span>   y</span><br><span class="line">   / \</span><br><span class="line">  <span class="selector-tag">b</span>   c</span><br></pre></td></tr></table></figure><p><strong>右旋转的代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="type">void</span> RedBlackTree&lt;Key, Value&gt;::<span class="built_in">rightRotate</span>(RBTreeNode&lt;Key, Value&gt;* y) &#123;</span><br><span class="line">    RBTreeNode&lt;Key, Value&gt;* x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line"></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">nullptr</span>)</span><br><span class="line">        root = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right)</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line"></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转操作的作用"><a href="#旋转操作的作用" class="headerlink" title="旋转操作的作用"></a>旋转操作的作用</h3><p>通过旋转操作，可以改变树的高度和形状，确保红黑树的性质在插入和删除后得到维护。旋转不会破坏二叉搜索树的性质，仅改变节点之间的指向关系。</p><hr><h2 id="5-简化版红黑树实现"><a href="#5-简化版红黑树实现" class="headerlink" title="5.简化版红黑树实现"></a>5.简化版红黑树实现</h2><h3 id="节点结构体"><a href="#节点结构体" class="headerlink" title="节点结构体"></a>节点结构体</h3><p>首先，我们定义红黑树节点的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, BLACK &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span> &#123;</span><br><span class="line">    Key key;</span><br><span class="line">    Value value;</span><br><span class="line">    Color color;</span><br><span class="line">    RBTreeNode* parent;</span><br><span class="line">    RBTreeNode* left;</span><br><span class="line">    RBTreeNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTreeNode</span>(Key k, Value v)</span><br><span class="line">        : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">color</span>(RED), <span class="built_in">parent</span>(<span class="literal">nullptr</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="红黑树类"><a href="#红黑树类" class="headerlink" title="红黑树类"></a>红黑树类</h3><p>接下来，我们定义红黑树的主要类，包括插入、删除和遍历功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, BLACK &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span> &#123;</span><br><span class="line">    Key key;</span><br><span class="line">    Value value;</span><br><span class="line">    Color color;</span><br><span class="line">    RBTreeNode* parent;</span><br><span class="line">    RBTreeNode* left;</span><br><span class="line">    RBTreeNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTreeNode</span>(Key k, Value v)</span><br><span class="line">        : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">color</span>(RED), <span class="built_in">parent</span>(<span class="literal">nullptr</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTreeNode&lt;Key, Value&gt;* root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(RBTreeNode&lt;Key, Value&gt;* x)</span> </span>&#123;</span><br><span class="line">        RBTreeNode&lt;Key, Value&gt;* y = x-&gt;right;</span><br><span class="line">        x-&gt;right = y-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            y-&gt;left-&gt;parent = x;</span><br><span class="line"></span><br><span class="line">        y-&gt;parent = x-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == <span class="literal">nullptr</span>)</span><br><span class="line">            root = y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)</span><br><span class="line">            x-&gt;parent-&gt;left = y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x-&gt;parent-&gt;right = y;</span><br><span class="line"></span><br><span class="line">        y-&gt;left = x;</span><br><span class="line">        x-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(RBTreeNode&lt;Key, Value&gt;* y)</span> </span>&#123;</span><br><span class="line">        RBTreeNode&lt;Key, Value&gt;* x = y-&gt;left;</span><br><span class="line">        y-&gt;left = x-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            x-&gt;right-&gt;parent = y;</span><br><span class="line"></span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;parent == <span class="literal">nullptr</span>)</span><br><span class="line">            root = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right)</span><br><span class="line">            y-&gt;parent-&gt;right = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;parent-&gt;left = x;</span><br><span class="line"></span><br><span class="line">        x-&gt;right = y;</span><br><span class="line">        y-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertFixUp</span><span class="params">(RBTreeNode&lt;Key, Value&gt;* z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (z-&gt;parent != <span class="literal">nullptr</span> &amp;&amp; z-&gt;parent-&gt;color == RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">                RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;right; <span class="comment">// 叔叔节点</span></span><br><span class="line">                <span class="keyword">if</span> (y != <span class="literal">nullptr</span> &amp;&amp; y-&gt;color == RED) &#123;</span><br><span class="line">                    <span class="comment">// 情况1</span></span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    y-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    z = z-&gt;parent-&gt;parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;</span><br><span class="line">                        <span class="comment">// 情况2</span></span><br><span class="line">                        z = z-&gt;parent;</span><br><span class="line">                        <span class="built_in">leftRotate</span>(z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况3</span></span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(z-&gt;parent-&gt;parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 父节点是右子节点，情况对称</span></span><br><span class="line">                RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;left; <span class="comment">// 叔叔节点</span></span><br><span class="line">                <span class="keyword">if</span> (y != <span class="literal">nullptr</span> &amp;&amp; y-&gt;color == RED) &#123;</span><br><span class="line">                    <span class="comment">// 情况1</span></span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    y-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    z = z-&gt;parent-&gt;parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                        <span class="comment">// 情况2</span></span><br><span class="line">                        z = z-&gt;parent;</span><br><span class="line">                        <span class="built_in">rightRotate</span>(z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况3</span></span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(z-&gt;parent-&gt;parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderHelper</span><span class="params">(RBTreeNode&lt;Key, Value&gt;* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(node-&gt;left);</span><br><span class="line">        std::cout &lt;&lt; node-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedBlackTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RBTreeNode&lt;Key, Value&gt;* <span class="title">getRoot</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value)</span> </span>&#123;</span><br><span class="line">        RBTreeNode&lt;Key, Value&gt;* z = <span class="keyword">new</span> <span class="built_in">RBTreeNode</span>&lt;Key, Value&gt;(key, value);</span><br><span class="line">        RBTreeNode&lt;Key, Value&gt;* y = <span class="literal">nullptr</span>;</span><br><span class="line">        RBTreeNode&lt;Key, Value&gt;* x = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">                x = x-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        z-&gt;parent = y;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="literal">nullptr</span>)</span><br><span class="line">            root = z;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = z;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = z;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入后修正红黑树性质</span></span><br><span class="line">        <span class="built_in">insertFixUp</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为简化示例，删除操作未实现</span></span><br><span class="line">    <span class="comment">// 完整实现需要包含 deleteFixUp 等步骤</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><p>上述红黑树类包含以下主要功能：</p><ol><li>**插入操作 (<code>insert</code>)**：<ul><li>插入新的键值对，并调用 <code>insertFixUp</code> 进行修正，以保持红黑树的性质。</li></ul></li><li>**旋转操作 (<code>leftRotate</code> 和 <code>rightRotate</code>)**：<ul><li>通过旋转操作重新调整树的结构，确保树的平衡。</li></ul></li><li>**修正插入后的红黑树性质 (<code>insertFixUp</code>)**：<ul><li>根据红黑树的五大性质，通过重新着色和旋转来修正可能的违规情况。</li></ul></li><li>**中序遍历 (<code>inorderTraversal</code>)**：<ul><li>以中序遍历的方式输出树中的键，结果应为升序。</li></ul></li></ol><blockquote><p><strong>注意</strong>：为了简化示例，删除操作 (<code>delete</code>) 及其修正 (<code>deleteFixUp</code>) 未在此实现。如果需要完整的删除功能，请参考之前的详细解释或使用标准库中的实现。</p></blockquote><h2 id="6-红黑树与其他平衡树的比较"><a href="#6-红黑树与其他平衡树的比较" class="headerlink" title="6. 红黑树与其他平衡树的比较"></a>6. 红黑树与其他平衡树的比较</h2><p>红黑树并非唯一的自平衡二叉搜索树，其他常见的平衡树包括 <strong>AVL 树</strong>（Adelson-Velsky和Landis树）和 <strong>Splay 树</strong>。以下是红黑树与 AVL 树的比较：</p><h3 id="红黑树-vs-AVL-树"><a href="#红黑树-vs-AVL-树" class="headerlink" title="红黑树 vs AVL 树"></a>红黑树 vs AVL 树</h3><table><thead><tr><th>特性</th><th>红黑树 (Red-Black Tree)</th><th>AVL 树 (AVL Tree)</th></tr></thead><tbody><tr><td><strong>平衡性</strong></td><td>相对不严格，每个路径上的黑色节点相同。</td><td>更严格，任意节点的左右子树高度差不超过1。</td></tr><tr><td><strong>插入/删除效率</strong></td><td>较快，插入和删除操作较少的旋转，适用于频繁修改的场景。</td><td>较慢，插入和删除可能需要多次旋转，适用于查找操作多于修改的场景。</td></tr><tr><td><strong>查找效率</strong></td><td>O(log n)</td><td>O(log n)，常数因子更小，查找速度略快。</td></tr><tr><td><strong>实现复杂度</strong></td><td>相对简单，旋转操作较少。</td><td>实现较复杂，需严格维护高度平衡。</td></tr><tr><td><strong>应用场景</strong></td><td>操作频繁、需要快速插入和删除的场景。</td><td>查找操作频繁、插入和删除相对较少的场景。</td></tr></tbody></table><h3 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h3><ul><li><strong>红黑树</strong>更适用于需要频繁插入和删除操作，并且查找操作相对较多的场景，因为其插入和删除操作的调整成本较低。</li><li><strong>AVL 树</strong>适用于查找操作极为频繁，而修改操作相对较少的场景，因为其高度更严格，查找效率更高。</li></ul><h2 id="7-红黑树的应用场景"><a href="#7-红黑树的应用场景" class="headerlink" title="7. 红黑树的应用场景"></a>7. 红黑树的应用场景</h2><p>由于红黑树高效的查找、插入和删除性能，它在计算机科学中的多个领域都有广泛的应用：</p><ol><li><strong>标准库中的关联容器</strong>：<ul><li>C++ 标准库中的 <code>std::map</code> 和 <code>std::set</code> 通常基于红黑树实现。</li><li>Java 的 <code>TreeMap</code> 和 <code>TreeSet</code> 也是基于红黑树。</li></ul></li><li><strong>操作系统</strong>：<ul><li>Linux 内核中的调度器和虚拟内存管理使用红黑树来管理进程和内存资源。</li></ul></li><li><strong>数据库系统</strong>：<ul><li>一些数据库索引结构使用红黑树来提高查询效率。</li></ul></li><li><strong>编译器设计</strong>：<ul><li>语法分析树和符号表管理中可能使用红黑树来高效存储和查找符号。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;std-map用法&quot;&gt;&lt;a href=&quot;#std-map用法&quot; class=&quot;headerlink&quot; title=&quot;std::map用法&quot;&gt;&lt;/a&gt;std::map用法&lt;/h1&gt;&lt;p&gt;&lt;code&gt;std::map&lt;/code&gt; 是 C++ 标准模板库（STL）中的</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>手写双端队列</title>
    <link href="http://www.limerence2017.com/2024/12/27/cppbase26/"/>
    <id>http://www.limerence2017.com/2024/12/27/cppbase26/</id>
    <published>2024-12-27T06:10:59.000Z</published>
    <updated>2025-02-15T02:51:05.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-双端队列-Deque-概述"><a href="#1-双端队列-Deque-概述" class="headerlink" title="1. 双端队列 (Deque) 概述"></a>1. 双端队列 (Deque) 概述</h2><p><strong>双端队列</strong>（Double-Ended Queue，简称 <strong>deque</strong>）是一种允许在其两端进行高效插入和删除操作的数据结构。与普通队列（只允许在一端插入和另一端删除）相比，双端队列更为灵活。</p><p>C++ 标准库中已经提供了 <code>std::deque</code>，但通过自行实现一个双端队列，可以更好地理解其内部机制和迭代器的工作原理。</p><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><p>为了实现一个高效的双端队列，我们需要考虑以下几点：</p><ol><li><strong>动态数组</strong>：使用动态数组（如环形缓冲区）来存储元素，以便支持在两端进行常数时间的插入和删除。</li><li><strong>头尾指针</strong>：维护头部和尾部的索引，以便快速访问两端。</li><li><strong>自动扩展</strong>：当容量不足时，自动调整内部缓冲区的大小。</li><li><strong>迭代器支持</strong>：定义一个迭代器类，允许用户使用像 <code>begin()</code> 和 <code>end()</code> 这样的函数进行遍历。</li></ol><p>接下来，我们将一步步实现这些功能。</p><h2 id="3-详细实现"><a href="#3-详细实现" class="headerlink" title="3. 详细实现"></a>3. 详细实现</h2><h3 id="3-1-内部数据结构"><a href="#3-1-内部数据结构" class="headerlink" title="3.1 内部数据结构"></a>3.1 内部数据结构</h3><p>我们将使用一个动态分配的数组作为内部缓冲区，并通过头尾索引来管理队列的前后端。为了支持在两端高效插入和删除，我们将采用<strong>环形缓冲区</strong>的概念，即当索引达到数组的末端时，自动回绕到数组的开头。</p><h3 id="3-2-Deque-类"><a href="#3-2-Deque-类" class="headerlink" title="3.2 Deque 类"></a>3.2 Deque 类</h3><p>下面是 <code>Deque</code> 类的基本结构和关键成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* buffer;               <span class="comment">// 内部缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> capacity;         <span class="comment">// 缓冲区容量</span></span><br><span class="line">    <span class="type">size_t</span> front_idx;        <span class="comment">// 头部索引</span></span><br><span class="line">    <span class="type">size_t</span> back_idx;         <span class="comment">// 尾部索引</span></span><br><span class="line">    <span class="type">size_t</span> count;            <span class="comment">// 当前元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        T* new_buffer = <span class="keyword">new</span> T[new_capacity];</span><br><span class="line">        <span class="comment">// 重新排列元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            new_buffer[i] = buffer[(front_idx + i) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = new_buffer;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">        front_idx = <span class="number">0</span>;</span><br><span class="line">        back_idx = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Deque</span>(<span class="type">size_t</span> initial_capacity = <span class="number">8</span>)</span><br><span class="line">        : <span class="built_in">capacity</span>(initial_capacity), <span class="built_in">front_idx</span>(<span class="number">0</span>), <span class="built_in">back_idx</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        buffer = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Deque</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数和赋值运算符（省略，为简洁起见）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : front_idx - <span class="number">1</span>;</span><br><span class="line">        buffer[front_idx] = value;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[back_idx] = value;</span><br><span class="line">        back_idx = (back_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从前面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        back_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取后端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类将放在这里（见下一部分）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类定义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Deque&lt;T&gt;* deque_ptr;</span><br><span class="line">        <span class="type">size_t</span> index;</span><br><span class="line">        <span class="type">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type        = T;</span><br><span class="line">        <span class="keyword">using</span> difference_type   = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">        <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Iterator</span>(Deque&lt;T&gt;* deque, <span class="type">size_t</span> position)</span><br><span class="line">            : <span class="built_in">deque_ptr</span>(deque), <span class="built_in">pos</span>(position) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> deque_ptr-&gt;buffer[real_idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> &amp;(deque_ptr-&gt;buffer[real_idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递增</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递增</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递减</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递减</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (deque_ptr == other.deque_ptr) &amp;&amp; (pos == other.pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 begin 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 end 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-迭代器类"><a href="#3-3-迭代器类" class="headerlink" title="3.3 迭代器类"></a>3.3 迭代器类</h3><p>在上面的 <code>Deque</code> 类中，我们定义了一个嵌套的 <code>Iterator</code> 类。这个迭代器支持前向和后向遍历，并且可以与标准的 C++ 迭代器兼容。</p><p><strong>关键点解释</strong>：</p><ol><li><strong>成员变量</strong>：<ul><li><code>deque_ptr</code>：指向包含此迭代器的 <code>Deque</code> 实例。</li><li><code>pos</code>：相对于队列头部的位置。</li></ul></li><li><strong>重载运算符</strong>：<ul><li><code>operator*</code> 和 <code>operator-&gt;</code>：用于访问当前元素。</li><li><code>operator++</code> 和 <code>operator--</code>：前置和后置递增和递减，用于移动迭代器。</li><li><code>operator==</code> 和 <code>operator!=</code>：用于比较两个迭代器是否相同。</li></ul></li><li><strong>注意事项</strong>：<ul><li>迭代器并不管理元素的生命周期，只是提供遍历接口。</li><li>迭代器的有效性依赖于队列的修改操作（如插入和删除）。在实际应用中，需要注意迭代器失效的问题。</li></ul></li></ol><h2 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h2><p>下面是一个使用上述 <code>Deque</code> 类及其迭代器的示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 Deque 类已经定义在这里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Deque&lt;std::string&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Elderberry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 大小: &quot;</span> &lt;&lt; dq.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问前端和后端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除元素后的 Deque: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Deque</span> 大小: <span class="number">5</span></span><br><span class="line"><span class="title class_">Deque</span> 元素: <span class="title class_">Elderberry</span> <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> <span class="title class_">Cherry</span> </span><br><span class="line">前端元素: <span class="title class_">Elderberry</span></span><br><span class="line">后端元素: <span class="title class_">Cherry</span></span><br><span class="line">删除元素后的 <span class="title class_">Deque</span>: <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> </span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ol><li><strong>插入操作</strong>：<ul><li>使用 <code>push_back</code> 在队列的后端插入 “Apple”, “Banana”, “Cherry”。</li><li>使用 <code>push_front</code> 在队列的前端插入 “Date”, “Elderberry”。</li><li>最终队列顺序为：Elderberry, Date, Apple, Banana, Cherry</li></ul></li><li><strong>遍历操作</strong>：<ul><li>使用迭代器从 <code>begin()</code> 到 <code>end()</code> 遍历并打印所有元素。</li></ul></li><li><strong>访问元素</strong>：<ul><li>使用 <code>front()</code> 获取队列前端的元素。</li><li>使用 <code>back()</code> 获取队列后端的元素。</li></ul></li><li><strong>删除操作</strong>：<ul><li>使用 <code>pop_front</code> 删除前端元素（”Elderberry”）。</li><li>使用 <code>pop_back</code> 删除后端元素（”Cherry”）。</li><li>删除后，队列顺序为：Date, Apple, Banana</li></ul></li></ol><h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><p>以下是完整的 <code>Deque</code> 类及其使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque 类定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* buffer;               <span class="comment">// 内部缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> capacity;         <span class="comment">// 缓冲区容量</span></span><br><span class="line">    <span class="type">size_t</span> front_idx;        <span class="comment">// 头部索引</span></span><br><span class="line">    <span class="type">size_t</span> back_idx;         <span class="comment">// 尾部索引</span></span><br><span class="line">    <span class="type">size_t</span> count;            <span class="comment">// 当前元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        T* new_buffer = <span class="keyword">new</span> T[new_capacity];</span><br><span class="line">        <span class="comment">// 重新排列元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            new_buffer[i] = buffer[(front_idx + i) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = new_buffer;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">        front_idx = <span class="number">0</span>;</span><br><span class="line">        back_idx = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Deque</span>(<span class="type">size_t</span> initial_capacity = <span class="number">8</span>)</span><br><span class="line">        : <span class="built_in">capacity</span>(initial_capacity), <span class="built_in">front_idx</span>(<span class="number">0</span>), <span class="built_in">back_idx</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        buffer = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Deque</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制构造函数和赋值运算符（为了简洁，可根据需要实现）</span></span><br><span class="line">    <span class="built_in">Deque</span>(<span class="type">const</span> Deque&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Deque&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : front_idx - <span class="number">1</span>;</span><br><span class="line">        buffer[front_idx] = value;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[back_idx] = value;</span><br><span class="line">        back_idx = (back_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从前面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        back_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取后端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类定义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Deque&lt;T&gt;* deque_ptr;</span><br><span class="line">        <span class="type">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type        = T;</span><br><span class="line">        <span class="keyword">using</span> difference_type   = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">        <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Iterator</span>(Deque&lt;T&gt;* deque, <span class="type">size_t</span> position)</span><br><span class="line">            : <span class="built_in">deque_ptr</span>(deque), <span class="built_in">pos</span>(position) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> deque_ptr-&gt;buffer[real_idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> &amp;(deque_ptr-&gt;buffer[real_idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递增</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递增</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递减</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递减</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (deque_ptr == other.deque_ptr) &amp;&amp; (pos == other.pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 begin 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 end 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Deque&lt;std::string&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Elderberry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 大小: &quot;</span> &lt;&lt; dq.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问前端和后端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除元素后的 Deque: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>保存上述代码到一个文件，例如 <code>DequeWithIterator.cpp</code>，然后使用 C++ 编译器进行编译和运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -o DequeWithIterator DequeWithIterator.cpp</span><br><span class="line">./DequeWithIterator</span><br></pre></td></tr></table></figure><h3 id="预期输出-1"><a href="#预期输出-1" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Deque</span> 大小: <span class="number">5</span></span><br><span class="line"><span class="title class_">Deque</span> 元素: <span class="title class_">Elderberry</span> <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> <span class="title class_">Cherry</span> </span><br><span class="line">前端元素: <span class="title class_">Elderberry</span></span><br><span class="line">后端元素: <span class="title class_">Cherry</span></span><br><span class="line">删除元素后的 <span class="title class_">Deque</span>: <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> </span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通过上述步骤，我们成功实现了一个支持双端插入和删除的双端队列（deque），并添加了迭代器支持，使其能够与标准的 C++ 迭代器接口兼容。这个实现包含了以下关键点：</p><ol><li><strong>内部缓冲区管理</strong>：<ul><li>使用动态数组并采用环形缓冲区的方式，支持高效的双端操作。</li><li>自动调整缓冲区的容量，确保在元素数量增加时仍能保持高效。</li></ul></li><li><strong>迭代器实现</strong>：<ul><li>定义了一个嵌套的 <code>Iterator</code> 类，支持前向和后向遍历。</li><li>重载了必要的运算符（如 <code>*</code>, <code>-&gt;</code>, <code>++</code>, <code>--</code>, <code>==</code>, <code>!=</code>），以实现与标准迭代器的兼容。</li></ul></li><li><strong>基本操作</strong>：<ul><li><code>push_front</code> 和 <code>push_back</code>：分别在队列的前端和后端插入元素。</li><li><code>pop_front</code> 和 <code>pop_back</code>：分别从队列的前端和后端删除元素。</li><li><code>front</code> 和 <code>back</code>：访问队列的前端和后端元素。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-双端队列-Deque-概述&quot;&gt;&lt;a href=&quot;#1-双端队列-Deque-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 双端队列 (Deque) 概述&quot;&gt;&lt;/a&gt;1. 双端队列 (Deque) 概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;双端队列</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(25) stl几种容器详解</title>
    <link href="http://www.limerence2017.com/2024/12/22/cppbase25/"/>
    <id>http://www.limerence2017.com/2024/12/22/cppbase25/</id>
    <published>2024-12-22T00:17:32.000Z</published>
    <updated>2025-02-15T02:51:02.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++的标准模板库（STL）提供了多种通用容器，用于存储和管理数据。这些容器各有特点，适用于不同的应用场景。理解每种容器的用法和内部实现原理，对于编写高效且可维护的代码至关重要。本教案将详细介绍几种常用的STL容器，包括<code>vector</code>、<code>list</code>、<code>deque</code>、<code>map</code>、<code>unordered_map</code>、<code>set</code>、<code>unordered_set</code>以及容器适配器如<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。</p><hr><h2 id="vector：动态数组"><a href="#vector：动态数组" class="headerlink" title="vector：动态数组"></a><code>vector</code>：动态数组</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>vector</code>是STL中最常用的序列容器之一，提供了动态大小的数组功能。它支持随机访问，允许在末尾高效地添加和删除元素。</p><h3 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><code>vector</code>在内部使用动态数组（通常是连续的内存块）来存储元素。当需要扩展容量时，它会分配一块更大的内存，将现有元素复制到新内存中，然后释放旧内存。这种策略在平均情况下保证了<code>push_back</code>的常数时间复杂度。</p><h3 id="性能特性"><a href="#性能特性" class="headerlink" title="性能特性"></a>性能特性</h3><ul><li><strong>随机访问</strong>：支持常数时间的随机访问（<code>O(1)</code>）。</li><li><strong>末尾插入/删除</strong>：<code>push_back</code>和<code>pop_back</code>操作在摊销分析下是常数时间（<code>O(1)</code>）。</li><li><strong>中间插入/删除</strong>：在中间位置插入或删除元素需要移动后续元素，时间复杂度为线性时间（<code>O(n)</code>）。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>需要频繁随机访问元素。</li><li>主要在容器末尾进行插入和删除操作。</li><li>当容器大小不需要频繁调整（避免频繁的内存重新分配）。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向vector末尾添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历vector</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    numbers.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的vector</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除最后一个元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">第一个元素: 10</span></span><br><span class="line"><span class="section">所有元素: 10 20 30 </span></span><br><span class="line"><span class="section">删除最后一个元素后: 10 20 </span></span><br></pre></td></tr></table></figure><hr><h2 id="list：双向链表"><a href="#list：双向链表" class="headerlink" title="list：双向链表"></a><code>list</code>：双向链表</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p><code>list</code>是一个实现了双向链表的数据结构，适合在容器中间频繁插入和删除元素。与<code>vector</code>不同，<code>list</code>不支持随机访问，但在任何位置的插入和删除操作都是常数时间。</p><h3 id="内部实现原理-1"><a href="#内部实现原理-1" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><code>list</code>在内部使用双向链表，每个元素包含指向前一个和后一个元素的指针。这使得在已知位置插入或删除元素时，无需移动其他元素，只需更新指针即可。</p><h3 id="性能特性-1"><a href="#性能特性-1" class="headerlink" title="性能特性"></a>性能特性</h3><ul><li><strong>随机访问</strong>：不支持随机访问，访问第<code>n</code>个元素需要线性时间（<code>O(n)</code>）。</li><li><strong>中间插入/删除</strong>：已知位置的插入和删除操作是常数时间（<code>O(1)</code>）。</li><li><strong>遍历</strong>：顺序遍历，适合需要频繁遍历但不需要随机访问的场景。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>需要在容器中间频繁插入或删除元素。</li><li>不需要进行随机访问。</li><li>对内存的局部性要求不高（链表元素在内存中不连续）。</li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数list</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向list末尾添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">200</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向list前端添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_front</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>();</span><br><span class="line">    ++it; <span class="comment">// 指向第二个元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(it, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印插入后的list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;插入元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">remove</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">所有元素: 50 100 200 300 </span></span><br><span class="line"><span class="section">插入元素后: 50 150 100 200 300 </span></span><br><span class="line"><span class="section">删除元素后: 50 150 100 300 </span></span><br></pre></td></tr></table></figure><h2 id="模拟实现一个简化版的-List"><a href="#模拟实现一个简化版的-List" class="headerlink" title="模拟实现一个简化版的 List"></a>模拟实现一个简化版的 <code>List</code></h2><p>为了更好地理解 <code>std::list</code> 的内部工作原理，我们可以尝试模拟实现一个简化版的双向链表。下面将逐步介绍如何设计和实现这个 <code>List</code> 类。</p><h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3><p>我们的 <code>List</code> 类将包含以下组件：</p><ol><li><strong>节点结构体（Node）</strong>：表示链表的每个节点。</li><li><strong>迭代器类（Iterator）</strong>：允许用户遍历链表。</li><li><strong><code>List</code> 类</strong>：管理链表的基本操作，如插入、删除和遍历。</li></ol><h3 id="节点结构体"><a href="#节点结构体" class="headerlink" title="节点结构体"></a>节点结构体</h3><p>每个节点包含数据域和前后指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value = <span class="built_in">T</span>()) : <span class="built_in">data</span>(value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>为了实现双向迭代器，我们需要定义一个 <code>Iterator</code> 类，支持 <code>++</code> 和 <code>--</code> 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> self_type = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Iterator</span>(Node&lt;T&gt;* ptr = <span class="literal">nullptr</span>) : <span class="built_in">node_ptr</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference operator</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> node_ptr-&gt;data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrow operator</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(node_ptr-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-increment</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-increment</span></span><br><span class="line">    self_type <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-decrement</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-decrement</span></span><br><span class="line">    self_type <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr == other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inequality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr != other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* node_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="List-类"><a href="#List-类" class="headerlink" title="List 类"></a><code>List</code> 类</h3><p><code>List</code> 类提供链表的基本功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = Iterator&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">List</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 哨兵节点</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 哨兵节点</span></span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作（简化实现）</span></span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    List&amp; <span class="keyword">operator</span>=(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到迭代器位置之前</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        Node&lt;T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(value);</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line"></span><br><span class="line">        new_node-&gt;next = current;</span><br><span class="line">        new_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = new_node;</span><br><span class="line">        current-&gt;prev = new_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        <span class="keyword">if</span> (current == head || current == tail) &#123;</span><br><span class="line">            <span class="comment">// 不能删除哨兵节点</span></span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line">        Node&lt;T&gt;* next_node = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = next_node;</span><br><span class="line">        next_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            iterator temp = <span class="built_in">end</span>();</span><br><span class="line">            --temp;</span><br><span class="line">            <span class="built_in">erase</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取尾元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;prev-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表大小（O(n)复杂度）</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            Node&lt;T&gt;* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表（辅助函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head; <span class="comment">// 头哨兵</span></span><br><span class="line">    Node&lt;T&gt;* tail; <span class="comment">// 尾哨兵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><p>下面是一个完整的示例，包括创建 <code>List</code> 对象，进行各种操作，并打印结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value = <span class="built_in">T</span>()) : <span class="built_in">data</span>(value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> self_type = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Iterator</span>(Node&lt;T&gt;* ptr = <span class="literal">nullptr</span>) : <span class="built_in">node_ptr</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference operator</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> node_ptr-&gt;data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrow operator</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(node_ptr-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-increment</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-increment</span></span><br><span class="line">    self_type <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-decrement</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-decrement</span></span><br><span class="line">    self_type <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr == other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inequality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr != other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* node_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = Iterator&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">List</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 头哨兵</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 尾哨兵</span></span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作（简化实现）</span></span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    List&amp; <span class="keyword">operator</span>=(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到迭代器位置之前</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        Node&lt;T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(value);</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line"></span><br><span class="line">        new_node-&gt;next = current;</span><br><span class="line">        new_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = new_node;</span><br><span class="line">        current-&gt;prev = new_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        <span class="keyword">if</span> (current == head || current == tail) &#123;</span><br><span class="line">            <span class="comment">// 不能删除哨兵节点</span></span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line">        Node&lt;T&gt;* next_node = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = next_node;</span><br><span class="line">        next_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            iterator temp = <span class="built_in">end</span>();</span><br><span class="line">            --temp;</span><br><span class="line">            <span class="built_in">erase</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取尾元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;prev-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表大小（O(n)复杂度）</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            Node&lt;T&gt;* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表（辅助函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head; <span class="comment">// 头哨兵</span></span><br><span class="line">    Node&lt;T&gt;* tail; <span class="comment">// 尾哨兵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">10</span>);    <span class="comment">// 链表: 10</span></span><br><span class="line">    lst.<span class="built_in">push_front</span>(<span class="number">5</span>);    <span class="comment">// 链表: 5, 10</span></span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">15</span>);    <span class="comment">// 链表: 5, 10, 15</span></span><br><span class="line">    lst.<span class="built_in">insert</span>(++lst.<span class="built_in">begin</span>(), <span class="number">7</span>); <span class="comment">// 链表: 5, 7, 10, 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;链表内容: &quot;</span>;</span><br><span class="line">    lst.<span class="built_in">print</span>(); <span class="comment">// 输出: 5 7 10 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    lst.<span class="built_in">pop_front</span>(); <span class="comment">// 链表: 7, 10, 15</span></span><br><span class="line">    lst.<span class="built_in">pop_back</span>();  <span class="comment">// 链表: 7, 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除头尾后链表内容: &quot;</span>;</span><br><span class="line">    lst.<span class="built_in">print</span>(); <span class="comment">// 输出: 7 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除</span></span><br><span class="line">    <span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>();</span><br><span class="line">    lst.<span class="built_in">insert</span>(it, <span class="number">3</span>);  <span class="comment">// 链表: 3, 7, 10</span></span><br><span class="line">    lst.<span class="built_in">erase</span>(++it);    <span class="comment">// 链表: 3, 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;插入和删除后链表内容: &quot;</span>;</span><br><span class="line">    lst.<span class="built_in">print</span>(); <span class="comment">// 输出: 3 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空链表</span></span><br><span class="line">    lst.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空后，链表是否为空: &quot;</span> &lt;&lt; (lst.<span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p>**节点结构体 <code>Node</code>**：包含数据域 <code>data</code>，前驱指针 <code>prev</code> 和后继指针 <code>next</code>。</p></li><li><p>**迭代器类 <code>Iterator</code>**：</p><ul><li><p><strong>构造函数</strong>：接受一个 <code>Node&lt;T&gt;*</code> 指针。</p></li><li><p>重载操作符</p><p>：</p><ul><li><code>*</code> 和 <code>-&gt;</code> 用于访问节点数据。</li><li><code>++</code> 和 <code>--</code> 支持前向和后向遍历。</li><li><code>==</code> 和 <code>!=</code> 用于比较迭代器。</li></ul></li></ul></li><li><p><strong><code>List</code> 类</strong>：</p><ul><li><p>成员变量</p><p>：</p><ul><li><code>head</code> 和 <code>tail</code> 是头尾哨兵节点。</li></ul></li><li><p><strong>构造函数</strong>：初始化头尾哨兵，并将它们互相连接。</p></li><li><p><strong>析构函数</strong>：清空链表并删除哨兵节点。</p></li><li><p>**<code>insert</code>**：在指定位置前插入新节点。</p></li><li><p>**<code>erase</code>**：删除指定位置的节点。</p></li><li><p>**<code>push_front</code> 和 <code>push_back</code>**：分别在头部和尾部插入元素。</p></li><li><p>**<code>pop_front</code> 和 <code>pop_back</code>**：分别删除头部和尾部元素。</p></li><li><p>**<code>front</code> 和 <code>back</code>**：访问头尾元素。</p></li><li><p>**<code>empty</code> 和 <code>size</code>**：检查链表是否为空和获取链表大小。</p></li><li><p>**<code>clear</code>**：清空链表。</p></li><li><p>**<code>begin</code> 和 <code>end</code>**：返回开始和结束迭代器。</p></li><li><p>**<code>print</code>**：辅助函数，用于打印链表内容。</p></li></ul></li><li><p><strong>测试代码</strong>：创建 <code>List&lt;int&gt;</code> 对象，并执行一系列的插入、删除和遍历操作，验证 <code>List</code> 类的功能。</p></li></ol><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>保存上述代码到一个名为 <code>List.cpp</code> 的文件中，然后使用以下命令编译和运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -o List List.cpp</span><br><span class="line">./List</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">链表内容: 5 7 10 15 </span></span><br><span class="line"><span class="section">删除头尾后链表内容: 7 10 </span></span><br><span class="line"><span class="section">插入和删除后链表内容: 3 10 </span></span><br><span class="line"><span class="section">清空后，链表是否为空: 是</span></span><br></pre></td></tr></table></figure><h2 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h2><h3 id="1-迭代器（Iterator）简介"><a href="#1-迭代器（Iterator）简介" class="headerlink" title="1. 迭代器（Iterator）简介"></a>1. 迭代器（Iterator）简介</h3><p>在 C++ 中，<strong>迭代器</strong> 是一种用于遍历容器（如 <code>std::vector</code>、<code>std::list</code> 等）元素的对象。它们提供了类似指针的接口，使得算法可以独立于具体的容器而工作。迭代器的设计允许算法以统一的方式处理不同类型的容器。</p><hr><h3 id="2-迭代器类别（Iterator-Categories）"><a href="#2-迭代器类别（Iterator-Categories）" class="headerlink" title="2. 迭代器类别（Iterator Categories）"></a>2. 迭代器类别（Iterator Categories）</h3><p>为了使不同类型的迭代器能够支持不同的操作，C++ 标准库将迭代器分为以下几种类别，每种类别支持的操作能力逐级增强：</p><ol><li><strong>输入迭代器（Input Iterator）</strong></li><li><strong>输出迭代器（Output Iterator）</strong></li><li><strong>前向迭代器（Forward Iterator）</strong></li><li><strong>双向迭代器（Bidirectional Iterator）</strong></li><li><strong>随机访问迭代器（Random Access Iterator）</strong></li><li><strong>无效迭代器（Contiguous Iterator）</strong>（C++20 引入）</li></ol><p>每个类别都继承自前一个类别，具备更强的功能。例如，双向迭代器不仅支持前向迭代器的所有操作，还支持反向迭代（即可以向后移动）。</p><p><strong>主要迭代器类别及其特性</strong></p><table><thead><tr><th>类别</th><th>支持的操作</th><th>示例容器</th></tr></thead><tbody><tr><td>输入迭代器</td><td>只读访问、单向前进</td><td>单向链表 <code>std::forward_list</code></td></tr><tr><td>输出迭代器</td><td>只写访问、单向前进</td><td>输出流 <code>std::ostream_iterator</code></td></tr><tr><td>前向迭代器</td><td>读写访问、单向前进</td><td>向量 <code>std::vector</code></td></tr><tr><td>双向迭代器</td><td>读写访问、单向前进和反向迭代</td><td>双向链表 <code>std::list</code></td></tr><tr><td>随机访问迭代器</td><td>读写访问、单向前进、反向迭代、跳跃移动（支持算术运算）</td><td>向量 <code>std::vector</code>、队列 <code>std::deque</code></td></tr><tr><td>无效迭代器（新）</td><td>随机访问迭代器的所有功能，且元素在内存中连续排列</td><td>新的 C++ 容器如 <code>std::span</code></td></tr></tbody></table><hr><h3 id="3-iterator-category-的作用"><a href="#3-iterator-category-的作用" class="headerlink" title="3. iterator_category 的作用"></a>3. <code>iterator_category</code> 的作用</h3><p><code>iterator_category</code> 是迭代器类型中的一个别名，用于标识该迭代器所属的类别。它是标准库中 <strong>迭代器特性（Iterator Traits）</strong> 的一部分，标准算法会根据迭代器的类别优化其行为。</p><h3 id="为什么需要-iterator-category"><a href="#为什么需要-iterator-category" class="headerlink" title="为什么需要 iterator_category"></a>为什么需要 <code>iterator_category</code></h3><p>标准库中的算法（如 <code>std::sort</code>、<code>std::find</code> 等）需要知道迭代器支持哪些操作，以便选择最优的实现方式。例如：</p><ul><li>对于<strong>随机访问迭代器</strong>，可以使用快速的随机访问算法（如快速排序）。</li><li>对于<strong>双向迭代器</strong>，只能使用适用于双向迭代的算法（如归并排序）。</li><li>对于<strong>输入迭代器</strong>，只能进行单次遍历，许多复杂算法无法使用。</li></ul><p>通过指定 <code>iterator_category</code>，你可以让标准算法了解你自定义迭代器的能力，从而选择合适的方法进行操作。</p><h3 id="iterator-category-的声明"><a href="#iterator-category-的声明" class="headerlink" title="iterator_category 的声明"></a><code>iterator_category</code> 的声明</h3><p>在你的自定义迭代器类中，通过以下方式声明迭代器类别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br></pre></td></tr></table></figure><p>这表示该迭代器是一个 <strong>双向迭代器</strong>，支持向前和向后遍历。</p><hr><h3 id="4-std-bidirectional-iterator-tag-详解"><a href="#4-std-bidirectional-iterator-tag-详解" class="headerlink" title="4. std::bidirectional_iterator_tag 详解"></a>4. <code>std::bidirectional_iterator_tag</code> 详解</h3><p><code>std::bidirectional_iterator_tag</code> 是一个标签（Tag），用于标识迭代器类别。C++ 标准库中有多个这样的标签，分别对应不同的迭代器类别：</p><ul><li><code>std::input_iterator_tag</code></li><li><code>std::output_iterator_tag</code></li><li><code>std::forward_iterator_tag</code></li><li><code>std::bidirectional_iterator_tag</code></li><li><code>std::random_access_iterator_tag</code></li><li><code>std::contiguous_iterator_tag</code>（C++20）</li></ul><p>这些标签本质上是空的结构体，用于类型区分。在标准算法中，通常会通过这些标签进行 <strong>重载选择（Overload Resolution）</strong> 或 <strong>特化（Specialization）</strong>，以实现针对不同迭代器类别的优化。</p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>迭代器标签是有继承关系的：</p><ul><li><code>std::forward_iterator_tag</code> 继承自 <code>std::input_iterator_tag</code></li><li><code>std::bidirectional_iterator_tag</code> 继承自 <code>std::forward_iterator_tag</code></li><li><code>std::random_access_iterator_tag</code> 继承自 <code>std::bidirectional_iterator_tag</code></li><li><code>std::contiguous_iterator_tag</code> 继承自 <code>std::random_access_iterator_tag</code></li></ul><p>这种继承关系反映了迭代器类别的能力层级。例如，<strong>双向迭代器</strong> 具备 <strong>前向迭代器</strong> 的所有能力，加上反向遍历的能力。</p><hr><h3 id="5-迭代器特性（Iterator-Traits）详解"><a href="#5-迭代器特性（Iterator-Traits）详解" class="headerlink" title="5. 迭代器特性（Iterator Traits）详解"></a>5. 迭代器特性（Iterator Traits）详解</h3><p>C++ 提供了 <strong>迭代器特性（Iterator Traits）</strong>，通过模板类 <code>std::iterator_traits</code> 来获取迭代器的相关信息。通过这些特性，标准算法可以泛化地处理不同类型的迭代器。</p><h3 id="迭代器特性包含的信息"><a href="#迭代器特性包含的信息" class="headerlink" title="迭代器特性包含的信息"></a>迭代器特性包含的信息</h3><p><code>std::iterator_traits</code> 提供以下信息：</p><ul><li><code>iterator_category</code>：迭代器类别标签。</li><li><code>value_type</code>：迭代器指向的元素类型。</li><li><code>difference_type</code>：迭代器间的距离类型（通常是 <code>std::ptrdiff_t</code>）。</li><li><code>pointer</code>：指向元素的指针类型。</li><li><code>reference</code>：对元素的引用类型。</li></ul><h3 id="自定义迭代器与-iterator-traits"><a href="#自定义迭代器与-iterator-traits" class="headerlink" title="自定义迭代器与 iterator_traits"></a>自定义迭代器与 <code>iterator_traits</code></h3><p>当你定义自己的迭代器时，确保提供这些类型别名，以便标准库算法能够正确识别和使用你的迭代器。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，使用 <code>std::iterator_traits&lt;Iterator&lt;T&gt;&gt;</code> 时，就能正确获取迭代器的特性。</p><hr><h2 id="deque：双端队列"><a href="#deque：双端队列" class="headerlink" title="deque：双端队列"></a><code>deque</code>：双端队列</h2><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p><code>deque</code>（双端队列）是一种支持在两端高效插入和删除元素的序列容器。与<code>vector</code>相比，<code>deque</code>支持在前端和后端均以常数时间进行插入和删除操作。</p><h3 id="内部实现原理-2"><a href="#内部实现原理-2" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><code>deque</code>通常由一系列固定大小的数组块组成，这些块通过一个中央映射数组进行管理。这种结构使得在两端扩展时不需要重新分配整个容器的内存，从而避免了<code>vector</code>在前端插入的高成本。</p><h3 id="性能特性-2"><a href="#性能特性-2" class="headerlink" title="性能特性"></a>性能特性</h3><ul><li><strong>随机访问</strong>：支持常数时间的随机访问（<code>O(1)</code>）。</li><li><strong>前后插入/删除</strong>：在前端和后端插入和删除元素的操作都是常数时间（<code>O(1)</code>）。</li><li><strong>中间插入/删除</strong>：在中间位置插入或删除元素需要移动元素，时间复杂度为线性时间（<code>O(n)</code>）。</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>需要在容器两端频繁插入和删除元素。</li><li>需要随机访问元素。</li><li>不需要频繁在中间位置插入和删除元素。</li></ul><h2 id="双端队列简介"><a href="#双端队列简介" class="headerlink" title="双端队列简介"></a>双端队列简介</h2><p><strong>双端队列（deque）</strong>是一种序列容器，允许在其两端高效地插入和删除元素。与<code>vector</code>不同，<code>deque</code>不仅支持在末尾添加或删除元素（如<code>vector</code>），还支持在头部进行同样的操作。此外，<code>deque</code>提供了随机访问能力，可以像<code>vector</code>一样通过索引访问元素。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li><strong>双端操作</strong>：支持在头部和尾部高效的插入和删除操作。</li><li><strong>随机访问</strong>：可以像数组和<code>vector</code>一样通过索引访问元素。</li><li><strong>动态大小</strong>：可以根据需要增长和收缩，无需预先定义大小。</li></ul><hr><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p><code>deque</code>内部并不使用一个单一的连续内存块，而是将元素分割成多个<strong>固定大小的块</strong>（也称为<strong>缓冲区</strong>或<strong>页面</strong>），并通过一个<strong>中央映射数组</strong>（通常称为<strong>map</strong>）来管理这些块。具体来说，<code>deque</code>的内部结构可以分为以下几个部分：</p><ol><li><strong>中央映射数组（Map）</strong>：<ul><li>一个指针数组，指向各个数据块。</li><li><code>map</code>本身也是动态分配的，可以根据需要增长或收缩。</li><li><code>map</code>允许<code>deque</code>在两端添加新的数据块，而无需移动现有的数据块。</li></ul></li><li><strong>数据块（Blocks）</strong>：<ul><li>每个数据块是一个固定大小的连续内存区域，用于存储元素。</li><li>数据块的大小通常与编译器和平台相关，但在大多数实现中，数据块的大小在运行时是固定的（如512字节或更多，具体取决于元素类型的大小）。</li></ul></li><li><strong>起始和结束指针</strong>：<ul><li><code>deque</code>维护指向中央映射数组中第一个有效数据块的指针以及第一个无效数据块的指针。</li><li>这些指针帮助<code>deque</code>快速地在两端添加或删除数据块。</li></ul></li></ol><p><img src="https://cdn.llfc.club/912f900f6a609de906df07ee849a57f.png" alt="https://cdn.llfc.club/912f900f6a609de906df07ee849a57f.png"></p><h3 id="双端队列的操作实现"><a href="#双端队列的操作实现" class="headerlink" title="双端队列的操作实现"></a>双端队列的操作实现</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p><strong>在末尾插入 (<code>push_back</code>)</strong></p><ol><li><strong>检查当前末端数据块的剩余空间</strong>：<ul><li>如果有空间，直接在当前末端数据块中插入新元素。</li><li>如果没有空间，分配一个新的数据块，并将其指针添加到<code>map</code>中，然后在新块中插入元素。</li></ul></li><li><strong>更新末尾指针</strong>：<ul><li>如果分配了新块，末尾指针指向该块的第一个元素。</li><li>否则，末尾指针移动到当前末端数据块的下一个位置。</li></ul></li></ol><p><strong>在前端插入 (<code>push_front</code>)</strong></p><ol><li><strong>检查当前前端数据块的剩余空间</strong>：<ul><li>如果有空间，直接在当前前端数据块中插入新元素。</li><li>如果没有空间，分配一个新的数据块，并将其指针添加到<code>map</code>的前面，然后在新块中插入元素。</li></ul></li><li><strong>更新前端指针</strong>：<ul><li>如果分配了新块，前端指针指向该块的最后一个元素。</li><li>否则，前端指针移动到当前前端数据块的前一个位置。</li></ul></li></ol><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p><strong>从末尾删除 (<code>pop_back</code>)</strong></p><ol><li><p>检查末端数据块是否有元素</p><p>：</p><ul><li>如果有，移除最后一个元素，并更新末尾指针。</li><li>如果数据块变为空，释放该数据块并从<code>map</code>中移除其指针，然后更新末尾指针指向前一个块。</li></ul></li></ol><p><strong>从前端删除 (<code>pop_front</code>)</strong></p><ol><li><p>检查前端数据块是否有元素</p><p>：</p><ul><li>如果有，移除第一个元素，并更新前端指针。</li><li>如果数据块变为空，释放该数据块并从<code>map</code>中移除其指针，然后更新前端指针指向下一个块。</li></ul></li></ol><h4 id="访问操作"><a href="#访问操作" class="headerlink" title="访问操作"></a>访问操作</h4><p><strong>随机访问</strong></p><p><code>deque</code>支持通过索引进行随机访问，其内部机制如下：</p><ol><li><strong>计算元素的位置</strong>：<ul><li>根据给定的索引，确定对应的<strong>数据块</strong>和<strong>数据块内的偏移量</strong>。</li><li>使用<code>map</code>数组定位到具体的块，然后通过偏移量定位到块内的元素。</li></ul></li><li><strong>访问元素</strong>：<ul><li>一旦定位到具体的位置，即可像数组一样访问元素。</li></ul></li></ol><p><strong>迭代器访问</strong></p><p><code>deque</code>提供双向迭代器，支持使用标准的C++迭代器操作（如<code>++</code>、<code>--</code>等）进行遍历。</p><hr><h3 id="双端队列的性能特性"><a href="#双端队列的性能特性" class="headerlink" title="双端队列的性能特性"></a>双端队列的性能特性</h3><p>理解<code>deque</code>的内部实现有助于理解其性能特性。以下是<code>deque</code>的主要操作及其时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>随机访问（通过索引）</td><td>常数时间（O(1)）</td><td>通过计算块和偏移量直接访问元素</td></tr><tr><td>插入/删除前端</td><td>常数时间（O(1)）</td><td>仅涉及前端指针和可能的数据块分配</td></tr><tr><td>插入/删除末端</td><td>常数时间（O(1)）</td><td>仅涉及末端指针和可能的数据块分配</td></tr><tr><td>中间插入/删除</td><td>线性时间（O(n)）</td><td>需要移动数据块内的元素，可能涉及多个块的操作</td></tr><tr><td>查找元素</td><td>线性时间（O(n)）</td><td>需要遍历元素进行查找</td></tr><tr><td>插入单个元素</td><td>平均常数时间（O(1)）</td><td>在前端或末端插入，通常不需移动大量元素</td></tr><tr><td>插入大量元素</td><td>线性时间（O(n)）</td><td>需要分配新的数据块并进行元素复制</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>双端操作高效</strong>：在两端插入和删除元素非常快速，不需要移动大量元素。</li><li><strong>支持随机访问</strong>：可以像<code>vector</code>一样通过索引高效访问元素。</li><li><strong>动态增长</strong>：无需预先定义大小，可以根据需要自动调整。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>内存碎片</strong>：由于使用多个数据块，可能导致内存碎片，尤其是在大量插入和删除操作后。</li><li><strong>较低的局部性</strong>：元素不连续存储，可能导致缓存未命中率较高，影响性能。</li><li><strong>复杂性较高</strong>：内部实现相对复杂，不如<code>vector</code>直接高效。</li></ul><hr><h2 id="双端队列与其他容器的比较"><a href="#双端队列与其他容器的比较" class="headerlink" title="双端队列与其他容器的比较"></a>双端队列与其他容器的比较</h2><table><thead><tr><th>特性</th><th><code>vector</code></th><th><code>deque</code></th><th><code>list</code></th></tr></thead><tbody><tr><td>内存结构</td><td>单一连续内存块</td><td>多块连续内存，通过映射数组管理</td><td>双向链表</td></tr><tr><td>随机访问</td><td>是，常数时间（O(1)）</td><td>是，常数时间（O(1)）</td><td>否，需要线性时间（O(n)）</td></tr><tr><td>前端插入/删除</td><td>低效，线性时间（O(n)）</td><td>高效，常数时间（O(1)）</td><td>高效，常数时间（O(1)）</td></tr><tr><td>末端插入/删除</td><td>高效，常数时间（O(1)）</td><td>高效，常数时间（O(1)）</td><td>高效，常数时间（O(1)）</td></tr><tr><td>内存碎片</td><td>低，由于单一连续内存块</td><td>较高，由于多块内存管理</td><td>较高，由于节点分散在内存中</td></tr><tr><td>元素隔离</td><td>高，局部性较好</td><td>中等，分块存储提高了部分局部性</td><td>低，元素分散存储，缓存效率低</td></tr><tr><td>应用场景</td><td>需要频繁随机访问、末端操作的场景</td><td>需要频繁在两端插入/删除且偶尔随机访问的场景</td><td>需要频繁在中间插入/删除且不需要随机访问的场景</td></tr></tbody></table><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的deque</span></span><br><span class="line">    std::deque&lt;std::string&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;End1&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;End2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前端添加元素</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Front1&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Front2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历deque</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问首尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;首元素: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尾元素: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除首元素</span></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除尾元素</span></span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的deque</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除首尾元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : dq) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">deque中的元素: Front2 Front1 End1 End2 </span></span><br><span class="line"><span class="section">首元素: Front2</span></span><br><span class="line"><span class="section">尾元素: End2</span></span><br><span class="line"><span class="section">删除首尾元素后: Front1 End1 </span></span><br></pre></td></tr></table></figure><hr><h2 id="map和unordered-map：关联数组"><a href="#map和unordered-map：关联数组" class="headerlink" title="map和unordered_map：关联数组"></a><code>map</code>和<code>unordered_map</code>：关联数组</h2><h3 id="map用法与原理"><a href="#map用法与原理" class="headerlink" title="map用法与原理"></a><code>map</code>用法与原理</h3><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>map</code>是一个关联容器，用于存储键值对（key-value）。它基于键自动排序，且每个键都是唯一的。<code>map</code>提供了快速的查找、插入和删除操作。</p><h4 id="内部实现原理-3"><a href="#内部实现原理-3" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>map</code>通常使用自平衡的二叉搜索树（如红黑树）实现。这确保了所有操作的时间复杂度为对数时间（<code>O(log n)</code>），且元素按照键的顺序排列。</p><h3 id="unordered-map用法与原理"><a href="#unordered-map用法与原理" class="headerlink" title="unordered_map用法与原理"></a><code>unordered_map</code>用法与原理</h3><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>unordered_map</code>也是一种关联容器，用于存储键值对，但它不保证元素的顺序。<code>unordered_map</code>基于哈希表实现，提供了平均常数时间（<code>O(1)</code>）的查找、插入和删除操作。</p><h4 id="内部实现原理-4"><a href="#内部实现原理-4" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>unordered_map</code>使用哈希表来存储元素。键通过哈希函数转换为哈希值，并映射到特定的桶中。如果多个键映射到同一桶，会通过链表或其他方法解决冲突。</p><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th>操作</th><th><code>map</code></th><th><code>unordered_map</code></th></tr></thead><tbody><tr><td>查找</td><td><code>O(log n)</code></td><td>平均 <code>O(1)</code></td></tr><tr><td>插入</td><td><code>O(log n)</code></td><td>平均 <code>O(1)</code></td></tr><tr><td>删除</td><td><code>O(log n)</code></td><td>平均 <code>O(1)</code></td></tr><tr><td>内存使用</td><td>较高</td><td>较低</td></tr><tr><td>元素顺序</td><td>有序</td><td>无序</td></tr></tbody></table><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>**<code>map</code>**：<ul><li>需要按键的顺序遍历元素。</li><li>需要有序的关联数组。</li><li>需要高效的范围查找。</li></ul></li><li>**<code>unordered_map</code>**：<ul><li>对元素顺序没有要求。</li><li>需要极高效的查找、插入和删除操作。</li><li>不需要自定义的排序规则。</li></ul></li></ul><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="map示例"><a href="#map示例" class="headerlink" title="map示例"></a><code>map</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的map，键为string，值为int</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ageMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ageMap.<span class="built_in">find</span>(name) != ageMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 的年龄是 &quot;</span> &lt;&lt; ageMap[name] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有人员和年龄: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ageMap.<span class="built_in">begin</span>(); it != ageMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    ageMap.<span class="built_in">erase</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除Alice后: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : ageMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unordered-map示例"><a href="#unordered-map示例" class="headerlink" title="unordered_map示例"></a><code>unordered_map</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的unordered_map，键为string，值为double</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">double</span>&gt; priceMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    priceMap[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1.2</span>;</span><br><span class="line">    priceMap[<span class="string">&quot;Banana&quot;</span>] = <span class="number">0.5</span>;</span><br><span class="line">    priceMap[<span class="string">&quot;Orange&quot;</span>] = <span class="number">0.8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string fruit = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(priceMap.<span class="built_in">find</span>(fruit) != priceMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; 的价格是 $&quot;</span> &lt;&lt; priceMap[fruit] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到 &quot;</span> &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历unordered_map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有水果和价格: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : priceMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; : $&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    priceMap.<span class="built_in">erase</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的unordered_map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除Apple后: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : priceMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; : $&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><h4 id="map输出"><a href="#map输出" class="headerlink" title="map输出"></a><code>map</code>输出</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Bob</span> <span class="string">的年龄是</span> <span class="number">25</span></span><br><span class="line"><span class="string">所有人员和年龄:</span> </span><br><span class="line"><span class="attr">Alice :</span> <span class="number">30</span></span><br><span class="line"><span class="attr">Bob :</span> <span class="number">25</span></span><br><span class="line"><span class="attr">Charlie :</span> <span class="number">35</span></span><br><span class="line"><span class="string">删除Alice后:</span> </span><br><span class="line"><span class="attr">Bob :</span> <span class="number">25</span></span><br><span class="line"><span class="attr">Charlie :</span> <span class="number">35</span></span><br></pre></td></tr></table></figure><h4 id="unordered-map输出"><a href="#unordered-map输出" class="headerlink" title="unordered_map输出"></a><code>unordered_map</code>输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Banana 的价格是 <span class="variable">$0</span>.5</span><br><span class="line">所有水果和价格: </span><br><span class="line">Apple : <span class="variable">$1</span>.2</span><br><span class="line">Banana : <span class="variable">$0</span>.5</span><br><span class="line">Orange : <span class="variable">$0</span>.8</span><br><span class="line">删除Apple后: </span><br><span class="line">Banana : <span class="variable">$0</span>.5</span><br><span class="line">Orange : <span class="variable">$0</span>.8</span><br></pre></td></tr></table></figure><hr><h2 id="set和unordered-set：集合"><a href="#set和unordered-set：集合" class="headerlink" title="set和unordered_set：集合"></a><code>set</code>和<code>unordered_set</code>：集合</h2><h3 id="set用法与原理"><a href="#set用法与原理" class="headerlink" title="set用法与原理"></a><code>set</code>用法与原理</h3><h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><p><code>set</code>是一个关联容器，用于存储唯一的、有序的元素。<code>set</code>基于键自动排序，且每个元素都是唯一的。</p><h4 id="内部实现原理-5"><a href="#内部实现原理-5" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>set</code>通常使用自平衡的二叉搜索树（如红黑树）实现，保证元素按顺序排列。每次插入元素时，都会自动保持树的平衡，并确保元素的唯一性。</p><h3 id="unordered-set用法与原理"><a href="#unordered-set用法与原理" class="headerlink" title="unordered_set用法与原理"></a><code>unordered_set</code>用法与原理</h3><h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><p><code>unordered_set</code>也是一种集合容器，用于存储唯一的元素，但它不保证元素的顺序。<code>unordered_set</code>基于哈希表实现，提供了平均常数时间（<code>O(1)</code>）的查找、插入和删除操作。</p><h4 id="内部实现原理-6"><a href="#内部实现原理-6" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>unordered_set</code>使用哈希表存储元素。每个元素通过哈希函数转换为哈希值，并映射到特定的桶中。冲突通过链表或其他方法解决。</p><h3 id="性能对比-1"><a href="#性能对比-1" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th>操作</th><th><code>set</code></th><th><code>unordered_set</code></th></tr></thead><tbody><tr><td>查找</td><td><code>O(log n)</code></td><td>平均 <code>O(1)</code></td></tr><tr><td>插入</td><td><code>O(log n)</code></td><td>平均 <code>O(1)</code></td></tr><tr><td>删除</td><td><code>O(log n)</code></td><td>平均 <code>O(1)</code></td></tr><tr><td>内存使用</td><td>较高</td><td>较低</td></tr><tr><td>元素顺序</td><td>有序</td><td>无序</td></tr></tbody></table><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>**<code>set</code>**：<ul><li>需要有序的唯一元素集合。</li><li>需要按顺序遍历元素。</li><li>需要基于区间的操作（如查找、删除某范围的元素）。</li></ul></li><li>**<code>unordered_set</code>**：<ul><li>对元素顺序无要求。</li><li>需要极高效的查找、插入和删除操作。</li><li>不需要自定义的排序规则。</li></ul></li></ul><h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="set示例"><a href="#set示例" class="headerlink" title="set示例"></a><code>set</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数set</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>); <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.<span class="built_in">find</span>(key) != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 在set中存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 不在set中。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除10后set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unordered-set示例"><a href="#unordered-set示例" class="headerlink" title="unordered_set示例"></a><code>unordered_set</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的unordered_set</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>); <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历unordered_set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unordered_set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.<span class="built_in">find</span>(key) != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 在unordered_set中存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 不在unordered_set中。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的unordered_set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除10后unordered_set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><h4 id="set输出"><a href="#set输出" class="headerlink" title="set输出"></a><code>set</code>输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>中的元素: 10 20 30 </span><br><span class="line">20 在<span class="built_in">set</span>中存在。</span><br><span class="line">删除10后<span class="built_in">set</span>中的元素: 20 30 </span><br></pre></td></tr></table></figure><h4 id="unordered-set输出（注意元素顺序可能不同）"><a href="#unordered-set输出（注意元素顺序可能不同）" class="headerlink" title="unordered_set输出（注意元素顺序可能不同）"></a><code>unordered_set</code>输出（注意元素顺序可能不同）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_set中的元素: <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br><span class="line"><span class="number">20</span> 在unordered_set中存在。</span><br><span class="line">删除<span class="number">10</span>后unordered_set中的元素: <span class="number">20</span> <span class="number">30</span> </span><br></pre></td></tr></table></figure><hr><h2 id="stack、queue和priority-queue：容器适配器"><a href="#stack、queue和priority-queue：容器适配器" class="headerlink" title="stack、queue和priority_queue：容器适配器"></a><code>stack</code>、<code>queue</code>和<code>priority_queue</code>：容器适配器</h2><h3 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h3><p>STL中的容器适配器（<code>stack</code>、<code>queue</code>、<code>priority_queue</code>）提供了特定的数据结构接口，这些适配器在内部使用其他容器来存储元素（默认使用<code>deque</code>或<code>vector</code>）。</p><h3 id="内部实现原理-7"><a href="#内部实现原理-7" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><ul><li>**<code>stack</code>**：后进先出（LIFO）数据结构，通常使用<code>deque</code>或<code>vector</code>作为底层容器，通过限制操作接口来实现。</li><li>**<code>queue</code>**：先进先出（FIFO）数据结构，通常使用<code>deque</code>作为底层容器，通过限制操作接口来实现。</li><li>**<code>priority_queue</code>**：基于堆的数据结构，通常使用<code>vector</code>作为底层容器，并通过堆算法（如<code>std::make_heap</code>、<code>std::push_heap</code>、<code>std::pop_heap</code>）维护元素的优先级顺序。</li></ul><h3 id="性能特性-3"><a href="#性能特性-3" class="headerlink" title="性能特性"></a>性能特性</h3><ul><li>**<code>stack</code>**：<ul><li>访问顶部元素：<code>O(1)</code></li><li>插入和删除：<code>O(1)</code></li></ul></li><li>**<code>queue</code>**：<ul><li>访问前端和后端元素：<code>O(1)</code></li><li>插入和删除：<code>O(1)</code></li></ul></li><li>**<code>priority_queue</code>**：<ul><li>访问顶部（最大或最小元素）：<code>O(1)</code></li><li>插入和删除：<code>O(log n)</code></li></ul></li></ul><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>**<code>stack</code>**：<ul><li>实现函数调用栈。</li><li>处理撤销操作。</li><li>深度优先搜索（DFS）。</li></ul></li><li>**<code>queue</code>**：<ul><li>实现任务调度。</li><li>广度优先搜索（BFS）。</li><li>数据流处理。</li></ul></li><li>**<code>priority_queue</code>**：<ul><li>实现优先级调度。</li><li>求解最短路径算法（如Dijkstra）。</li><li>任意需要按优先级处理元素的场景。</li></ul></li></ul><h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="stack示例"><a href="#stack示例" class="headerlink" title="stack示例"></a><code>stack</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的stack，底层使用vector</span></span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;弹出一个元素后，新的栈顶: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈不为空，元素数量: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="queue示例"><a href="#queue示例" class="headerlink" title="queue示例"></a><code>queue</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的queue，底层使用deque</span></span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队元素</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队首元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队首元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队尾元素: &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;出队后新的队首: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列不为空，元素数量: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="priority-queue示例"><a href="#priority-queue示例" class="headerlink" title="priority_queue示例"></a><code>priority_queue</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的priority_queue，默认是最大堆</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问堆顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;优先级最高的元素: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出元素</span></span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;弹出一个元素后，新的堆顶: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历priority_queue（需要复制，因为无法直接遍历）</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; copy = pq;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;剩余的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!copy.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; copy.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        copy.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><h4 id="stack输出"><a href="#stack输出" class="headerlink" title="stack输出"></a><code>stack</code>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">栈顶元素: 3</span></span><br><span class="line"><span class="section">弹出一个元素后，新的栈顶: 2</span></span><br><span class="line"><span class="section">栈不为空，元素数量: 2</span></span><br></pre></td></tr></table></figure><h4 id="queue输出"><a href="#queue输出" class="headerlink" title="queue输出"></a><code>queue</code>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">队首元素: First</span></span><br><span class="line"><span class="section">队尾元素: Third</span></span><br><span class="line"><span class="section">出队后新的队首: Second</span></span><br><span class="line"><span class="section">队列不为空，元素数量: 2</span></span><br></pre></td></tr></table></figure><h4 id="priority-queue输出"><a href="#priority-queue输出" class="headerlink" title="priority_queue输出"></a><code>priority_queue</code>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">优先级最高的元素: 40</span></span><br><span class="line"><span class="section">弹出一个元素后，新的堆顶: 30</span></span><br><span class="line"><span class="section">剩余的元素: 30 20 10 </span></span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ STL提供了丰富多样的容器，适用于各种不同的数据存储和管理需求。理解每种容器的特点、内部实现原理以及性能特性，可以帮助开发者在实际应用中做出最佳的选择，从而编写出高效且可维护的代码。</p><ul><li><strong>序列容器</strong>：<ul><li>**<code>vector</code>**：适用于需要频繁随机访问和在末尾操作的场景。</li><li>**<code>list</code>**：适用于需要在中间频繁插入和删除的场景。</li><li>**<code>deque</code>**：适用于需要在两端频繁插入和删除的场景。</li></ul></li><li><strong>关联容器</strong>：<ul><li>**<code>map</code>*<em>和*</em><code>set</code>**：适用于需要有序存储和快速查找的场景。</li><li>**<code>unordered_map</code>*<em>和*</em><code>unordered_set</code>**：适用于需要高效查找且对元素顺序无要求的场景。</li></ul></li><li><strong>容器适配器</strong>：<ul><li>**<code>stack</code>**：用于LIFO操作。</li><li>**<code>queue</code>**：用于FIFO操作。</li><li>**<code>priority_queue</code>**：用于优先级队列操作。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;C++的标准模板库（STL）提供了多种通用容器，用于存储和管理数据。这些容器各有特点，适用于不同的应用场景。理解每种容器的用法和内部实现原理</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(23) 智能指针</title>
    <link href="http://www.limerence2017.com/2024/12/06/cppbase23/"/>
    <id>http://www.limerence2017.com/2024/12/06/cppbase23/</id>
    <published>2024-12-06T02:57:07.000Z</published>
    <updated>2025-02-15T02:50:54.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 <code>new</code> 和 <code>delete</code> 带来的复杂性和错误。智能指针通过 <code>RAII</code>（资源获取即初始化）机制，在对象生命周期结束时自动释放资源，从而有效防止内存泄漏和资源管理错误。</p><h2 id="2-原生指针-vs-智能指针"><a href="#2-原生指针-vs-智能指针" class="headerlink" title="2. 原生指针 vs 智能指针"></a>2. 原生指针 vs 智能指针</h2><h3 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h3><p>原生指针是 C++ 最基本的指针类型，允许程序员直接管理内存。然而，原生指针存在以下问题：</p><ul><li><strong>内存泄漏</strong>：未释放动态分配的内存。</li><li><strong>悬挂指针</strong>：指针指向已释放或未初始化的内存。</li><li><strong>双重释放</strong>：多次释放同一内存区域。</li></ul><h3 id="智能指针的优势"><a href="#智能指针的优势" class="headerlink" title="智能指针的优势"></a>智能指针的优势</h3><p>智能指针通过封装原生指针，自动管理内存，解决上述问题。主要优势包括：</p><ul><li><strong>自动销毁</strong>：在智能指针生命周期结束时自动释放资源。</li><li><strong>引用计数</strong>：共享智能指针能够跟踪引用数量，确保资源在最后一个引用结束时释放。</li><li><strong>避免内存泄漏</strong>：通过 RAII 机制自动管理资源生命周期。</li><li><strong>类型安全</strong>：提供更严格的类型检查，减少错误。</li></ul><h2 id="3-std-unique-ptr"><a href="#3-std-unique-ptr" class="headerlink" title="3. std::unique_ptr"></a>3. <code>std::unique_ptr</code></h2><h3 id="3-1-定义与用法"><a href="#3-1-定义与用法" class="headerlink" title="3.1 定义与用法"></a>3.1 定义与用法</h3><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，任何时刻只能有一个 <code>unique_ptr</code> 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。</p><p><strong>主要特性</strong>：</p><ul><li><strong>独占所有权</strong>：确保资源在一个所有者下。</li><li><strong>轻量级</strong>：没有引用计数，开销小。</li><li><strong>自动释放</strong>：在指针销毁时自动释放资源。</li></ul><h3 id="3-2-构造函数与赋值"><a href="#3-2-构造函数与赋值" class="headerlink" title="3.2 构造函数与赋值"></a>3.2 构造函数与赋值</h3><p><code>unique_ptr</code> 提供多种构造函数和赋值操作，以支持不同的使用场景。</p><ul><li><strong>默认构造函数</strong>：创建一个空的 <code>unique_ptr</code>。</li><li><strong>指针构造函数</strong>：接受一个裸指针，拥有其所有权。</li><li><strong>移动构造函数</strong>：将一个 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li><li><strong>移动赋值操作符</strong>：将一个 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li></ul><h3 id="3-3-移动语义"><a href="#3-3-移动语义" class="headerlink" title="3.3 移动语义"></a>3.3 移动语义</h3><p>由于 <code>unique_ptr</code> 不能被拷贝，必须通过移动语义转移所有权。这保证了资源的独占性。</p><h3 id="3-4-代码案例"><a href="#3-4-代码案例" class="headerlink" title="3.4 代码案例"></a>3.4 代码案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unique_ptr</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 make_unique（C++14 引入）</span></span><br><span class="line">    <span class="keyword">auto</span> ptr2 = std::<span class="built_in">make_unique</span>&lt;Test&gt;(<span class="number">200</span>);</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动 unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Test&gt; ptr3 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr3-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 unique_ptr</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">300</span>));</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr 自动释放资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">ptr1</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">move.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>ptr1</code> 拥有 <code>Test(100)</code>，<code>ptr2</code> 拥有 <code>Test(200)</code>。</li><li>通过 <code>std::move</code> 将 <code>ptr1</code> 的所有权转移到 <code>ptr3</code>，<code>ptr1</code> 变为空。</li><li><code>ptr2.reset(new Test(300))</code> 释放了原有的 <code>Test(200)</code>，并拥有新的 <code>Test(300)</code>。</li><li>程序结束时，<code>ptr3</code> 和 <code>ptr2</code> 自动释放各自拥有的资源。</li></ul><h2 id="4-std-shared-ptr"><a href="#4-std-shared-ptr" class="headerlink" title="4. std::shared_ptr"></a>4. <code>std::shared_ptr</code></h2><h3 id="4-1-定义与用法"><a href="#4-1-定义与用法" class="headerlink" title="4.1 定义与用法"></a>4.1 定义与用法</h3><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，允许多个 <code>shared_ptr</code> 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。</p><p><strong>主要特性</strong>：</p><ul><li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可以指向同一个对象。</li><li><strong>引用计数</strong>：跟踪有多少 <code>shared_ptr</code> 实例指向同一对象。</li><li><strong>自动释放</strong>：当引用计数为0时，自动释放资源。</li></ul><h3 id="4-2-引用计数与控制块"><a href="#4-2-引用计数与控制块" class="headerlink" title="4.2 引用计数与控制块"></a>4.2 引用计数与控制块</h3><p><code>shared_ptr</code> 背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括：</p><ul><li><strong>强引用计数（<code>use_count</code>）</strong>：表示有多少个 <code>shared_ptr</code> 指向对象。</li><li><strong>弱引用计数（<code>weak_count</code>）</strong>：表示有多少个 <code>weak_ptr</code> 指向对象（不增加强引用计数）。</li></ul><h3 id="4-3-构造函数与赋值"><a href="#4-3-构造函数与赋值" class="headerlink" title="4.3 构造函数与赋值"></a>4.3 构造函数与赋值</h3><p><code>shared_ptr</code> 提供多种构造函数和赋值操作，以支持不同的使用场景。</p><ul><li><strong>默认构造函数</strong>：创建一个空的 <code>shared_ptr</code>。</li><li><strong>指针构造函数</strong>：接受一个裸指针，拥有其所有权。</li><li><strong>拷贝构造函数</strong>：增加引用计数，共享对象所有权。</li><li><strong>移动构造函数</strong>：转移所有权，源 <code>shared_ptr</code> 变为空。</li><li><strong>拷贝赋值操作符</strong>：释放当前资源，增加引用计数，指向新对象。</li><li><strong>移动赋值操作符</strong>：释放当前资源，转移所有权，源 <code>shared_ptr</code> 变为空。</li></ul><h3 id="4-4-代码案例"><a href="#4-4-代码案例" class="headerlink" title="4.4 代码案例"></a>4.4 代码案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sp1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过拷贝构造共享所有权</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp2 = sp1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp2 = sp1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过拷贝赋值共享所有权</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp3;</span><br><span class="line">    sp3 = sp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp3 = sp2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 shared_ptr</span></span><br><span class="line">    sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">200</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp2.reset(new Test(200)):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动释放资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp2</span> <span class="string">=</span> <span class="attr">sp1:</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp3</span> <span class="string">=</span> <span class="attr">sp2:</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">sp3 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp2.reset(new</span> <span class="string">Test(200)):</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">sp3 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">Exiting</span> <span class="string">main...</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><p>创建 <code>sp1</code>，引用计数为1。</p></li><li><p>拷贝构造 <code>sp2</code>，引用计数增加到2。</p></li><li><p>拷贝赋值 <code>sp3</code>，引用计数增加到3。</p></li><li><p>```<br>sp2.reset(new Test(200))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 原 `Test(100)` 的引用计数减少到2。</span><br><span class="line">  - 分配新的 `Test(200)`，`sp2` 拥有它，引用计数为1。</span><br><span class="line"></span><br><span class="line">- 程序结束时：</span><br><span class="line"></span><br><span class="line">  - `sp1` 和 `sp3` 释放 `Test(100)`，引用计数降到0，资源被销毁。</span><br><span class="line">  - `sp2` 释放 `Test(200)`，引用计数为0，资源被销毁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5. `std::weak_ptr`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.1 定义与用法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`std::weak_ptr` 是一种不拥有对象所有权的智能指针，用于观察但不影响对象的生命周期。主要用于解决 `shared_ptr` 之间的循环引用问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**主要特性**：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **非拥有所有权**：不增加引用计数。</span><br><span class="line">- **可从 `shared_ptr` 生成**：通过 `std::weak_ptr` 可以访问 `shared_ptr` 管理的对象。</span><br><span class="line">- **避免循环引用**：适用于双向关联或观察者模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.2 避免循环引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在存在双向关联（如父子关系）时，使用多个 `shared_ptr` 可能导致循环引用，导致内存泄漏。此时，可以使用 `weak_ptr` 来打破循环。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.3 代码案例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 场景：双向关联导致循环引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class B; // 前向声明</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB;</span><br><span class="line"></span><br><span class="line">    A() &#123; std::cout &lt;&lt; &quot;A Constructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~A() &#123; std::cout &lt;&lt; &quot;A Destructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA;</span><br><span class="line"></span><br><span class="line">    B() &#123; std::cout &lt;&lt; &quot;B Constructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~B() &#123; std::cout &lt;&lt; &quot;B Destructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();</span><br><span class="line">        a-&gt;ptrB = b;</span><br><span class="line">        b-&gt;ptrA = a;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> Constructor</span><br><span class="line"><span class="selector-tag">B</span> Constructor</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br><span class="line"><span class="selector-tag">A</span> Destructor</span><br><span class="line"><span class="selector-tag">B</span> Destructor</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：</p><p>虽然 <code>a</code> 和 <code>b</code> 离开作用域，但 <code>A Destructor</code> 和 <code>B Destructor</code> 并未被调用，因为 <code>a</code> 和 <code>b</code> 相互引用，引用计数无法降到0，导致内存泄漏。</p><h4 id="解决方案：使用-weak-ptr"><a href="#解决方案：使用-weak-ptr" class="headerlink" title="解决方案：使用 weak_ptr"></a>解决方案：使用 <code>weak_ptr</code></h4><p>改用 <code>weak_ptr</code> 其中一方（如 <code>B</code> 的 <code>ptrA</code>），打破循环引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; ptrA; <span class="comment">// 使用 weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;ptrB = b;</span><br><span class="line">        b-&gt;ptrA = a;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> Constructor</span><br><span class="line"><span class="selector-tag">B</span> Constructor</span><br><span class="line"><span class="selector-tag">A</span> Destructor</span><br><span class="line"><span class="selector-tag">B</span> Destructor</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>B</code> 使用 <code>weak_ptr</code> 指向 <code>A</code>，不增加引用计数。</li><li><code>a</code> 和 <code>b</code> 离开作用域，引用计数降为0，资源被正确释放。</li><li>防止了循环引用，避免了内存泄漏。</li></ul><h3 id="5-4-访问-weak-ptr-指向的对象"><a href="#5-4-访问-weak-ptr-指向的对象" class="headerlink" title="5.4 访问 weak_ptr 指向的对象"></a>5.4 访问 <code>weak_ptr</code> 指向的对象</h3><p><code>weak_ptr</code> 不能直接访问对象，需要通过 <code>lock()</code> 方法转换为 <code>shared_ptr</code>，并检查对象是否仍然存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *locked &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object no longer exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">// 再次尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *locked &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object no longer exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Value:</span> <span class="number">42</span></span><br><span class="line"><span class="type">Object</span> no longer exists.</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>wp.lock()</code> 返回一个 <code>shared_ptr</code>，如果对象依然存在，则有效。</li><li><code>sp.reset()</code> 释放资源后，<code>wp.lock()</code> 无法获取有效的 <code>shared_ptr</code>。</li></ul><h2 id="6-自定义删除器"><a href="#6-自定义删除器" class="headerlink" title="6. 自定义删除器"></a>6. 自定义删除器</h2><h3 id="6-1-用例与实现"><a href="#6-1-用例与实现" class="headerlink" title="6.1 用例与实现"></a>6.1 用例与实现</h3><p>有时，默认的 <code>delete</code> 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。</p><h3 id="6-2-代码案例"><a href="#6-2-代码案例" class="headerlink" title="6.2 代码案例"></a>6.2 代码案例</h3><h4 id="用例：管理-FILE-资源"><a href="#用例：管理-FILE-资源" class="headerlink" title="用例：管理 FILE* 资源"></a>用例：管理 FILE* 资源</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileDeleter</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Closing file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), FileDeleter())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (filePtr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 使用 filePtr 进行文件操作</span></span><br><span class="line">            <span class="built_in">fprintf</span>(filePtr.<span class="built_in">get</span>(), <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 自动关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully.</span><br><span class="line">Closing file.</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>自定义删除器 <code>FileDeleter</code> 用于在 <code>shared_ptr</code> 被销毁时关闭文件。</li><li>使用 <code>filePtr.get()</code> 获取原生 <code>FILE*</code> 指针进行文件操作。</li><li>离开作用域时，自动调用 <code>FileDeleter</code> 关闭文件。</li></ul><h3 id="6-3-使用-Lambda-表达式作为删除器"><a href="#6-3-使用-Lambda-表达式作为删除器" class="headerlink" title="6.3 使用 Lambda 表达式作为删除器"></a>6.3 使用 Lambda 表达式作为删除器</h3><p>C++11 允许使用 lambda 表达式作为删除器，简化代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fileDeleter = [](FILE* fp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Closing file via lambda.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(fileDeleter)</span>&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), fileDeleter)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (filePtr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fprintf</span>(filePtr.<span class="built_in">get</span>(), <span class="string">&quot;Hello, Lambda!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 自动关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully.</span><br><span class="line">Closing file via lambda.</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>使用 <code>std::unique_ptr</code> 搭配 lambda 删除器管理 <code>FILE*</code>。</li><li>提供了更灵活和简洁的删除器实现。</li></ul><h2 id="7-最佳实践与常见陷阱"><a href="#7-最佳实践与常见陷阱" class="headerlink" title="7. 最佳实践与常见陷阱"></a>7. 最佳实践与常见陷阱</h2><h3 id="7-1-选择合适的智能指针"><a href="#7-1-选择合适的智能指针" class="headerlink" title="7.1 选择合适的智能指针"></a>7.1 选择合适的智能指针</h3><ul><li>**<code>std::unique_ptr</code>**：<ul><li>用于明确的独占所有权场景。</li><li>适用于资源的单一管理者或需要所有权转移的情况。</li><li>更轻量，性能更优。</li></ul></li><li>**<code>std::shared_ptr</code>**：<ul><li>用于共享所有权的场景。</li><li>需要多个指针共同管理同一资源时使用。</li><li>引用计数带来一定的性能开销。</li></ul></li><li>**<code>std::weak_ptr</code>**：<ul><li>用于观察不拥有资源的场景。</li><li>适用于需要避免循环引用或只需临时访问资源的情况。</li></ul></li></ul><h3 id="7-2-避免循环引用"><a href="#7-2-避免循环引用" class="headerlink" title="7.2 避免循环引用"></a>7.2 避免循环引用</h3><p>在使用 <code>shared_ptr</code> 时，特别是在对象间存在双向引用时，容易导致循环引用，内存泄漏。使用 <code>weak_ptr</code> 打破循环引用。</p><h3 id="7-3-使用-make-shared-与-make-unique"><a href="#7-3-使用-make-shared-与-make-unique" class="headerlink" title="7.3 使用 make_shared 与 make_unique"></a>7.3 使用 <code>make_shared</code> 与 <code>make_unique</code></h3><p>优先使用 <code>make_shared</code> 和 <code>make_unique</code> 来创建智能指针，避免直接使用 <code>new</code>，提高效率和异常安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">auto</span> up = std::<span class="built_in">make_unique</span>&lt;Test&gt;(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><h3 id="7-4-不要混用原生指针与智能指针"><a href="#7-4-不要混用原生指针与智能指针" class="headerlink" title="7.4 不要混用原生指针与智能指针"></a>7.4 不要混用原生指针与智能指针</h3><p>避免在智能指针管理的对象上同时使用原生指针进行管理，防止重复释放或不安全访问。</p><h3 id="7-5-理解智能指针的所有权语义"><a href="#7-5-理解智能指针的所有权语义" class="headerlink" title="7.5 理解智能指针的所有权语义"></a>7.5 理解智能指针的所有权语义</h3><p>深入理解不同智能指针的所有权规则，避免误用导致资源管理错误。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>智能指针是 C++ 中强大的资源管理工具，通过封装原生指针，提供自动化的内存管理，极大地减少了内存泄漏和资源管理错误。<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 各有其应用场景，理解它们的差异和使用方法对于编写安全、高效的 C++ 代码至关重要。此外，通过实现自己的智能指针（如 <code>SimpleSharedPtr</code>），可以更深入地理解智能指针的工作原理，为高级 C++ 编程打下坚实基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h2&gt;&lt;p&gt;C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;dele</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(24) 可调用对象function类</title>
    <link href="http://www.limerence2017.com/2024/12/06/cppbase24/"/>
    <id>http://www.limerence2017.com/2024/12/06/cppbase24/</id>
    <published>2024-12-06T02:57:07.000Z</published>
    <updated>2025-02-15T02:50:59.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C++ 提供了多种方式来表示和操作可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code> 和 <code>std::bind</code> 等。这些工具极大地增强了C++的灵活性和表达能力，尤其在处理回调、事件驱动编程和函数式编程时表现尤为出色。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是C++中最基本的可调用对象之一，用于指向普通函数和静态成员函数。</p><h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>函数指针的定义涉及到函数的返回类型和参数列表。例如，定义一个指向返回 <code>int</code> 且接受两个 <code>int</code> 参数的函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给函数指针赋值</span></span><br><span class="line">    funcPtr = &amp;add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">funcPtr</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出: 结果: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点与局限性"><a href="#优点与局限性" class="headerlink" title="优点与局限性"></a>优点与局限性</h3><p><strong>优点:</strong></p><ul><li>简单直观，适用于简单的回调函数。</li></ul><p><strong>局限性:</strong></p><ul><li>不能捕获上下文（如lambda中的闭包）。</li><li>语法相对复杂，尤其是指针的声明和使用。</li></ul><hr><h2 id="仿函数（Functors）"><a href="#仿函数（Functors）" class="headerlink" title="仿函数（Functors）"></a>仿函数（Functors）</h2><p><strong>仿函数（Functors）</strong>，又称<strong>函数对象（Function Objects）</strong>，是在C++中重载了 <code>operator()</code> 的类或结构体实例。仿函数不仅可以像普通函数一样被调用，还能携带状态，提供更大的灵活性和功能性。</p><h3 id="定义与使用-1"><a href="#定义与使用-1" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>仿函数是通过定义一个类或结构体，并重载其调用运算符 <code>operator()</code> 来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="type">int</span> to_add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> value) : <span class="built_in">to_add</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + to_add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">add5</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个添加5的仿函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 10 + 5 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>携带状态：</strong> 仿函数可以拥有内部状态，通过成员变量存储数据，使其在调用时具备上下文信息。</li><li><strong>灵活性高：</strong> 可以根据需要添加更多的成员函数和变量，扩展功能。</li><li><strong>性能优化：</strong> 编译器可以对仿函数进行优化，例如内联展开，提高执行效率。</li></ol><h3 id="高级示例"><a href="#高级示例" class="headerlink" title="高级示例"></a>高级示例</h3><p>仿函数不仅可以执行简单的计算，还可以进行复杂的操作。例如，实现一个可变的仿函数，用于累加多个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变累加器仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Accumulator</span>() : <span class="built_in">sum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Accumulator acc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;总和: &quot;</span> &lt;&lt; acc.sum &lt;&lt; std::endl; <span class="comment">// 输出: 总和: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用仿函数的标准库算法"><a href="#使用仿函数的标准库算法" class="headerlink" title="使用仿函数的标准库算法"></a>使用仿函数的标准库算法</h3><p>许多标准库算法可以接受仿函数作为参数，使得算法的行为更加灵活和可定制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数：判断一个数是否大于某个阈值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsGreaterThan</span> &#123;</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IsGreaterThan</span>(<span class="type">int</span> t) : <span class="built_in">threshold</span>(t) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行筛选</span></span><br><span class="line">    <span class="function">IsGreaterThan <span class="title">greaterThan10</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), greaterThan10);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个大于10的数是: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 输出: 第一个大于10的数是: 15</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于10的数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仿函数与模板"><a href="#仿函数与模板" class="headerlink" title="仿函数与模板"></a>仿函数与模板</h3><p>仿函数与模板相结合，可以实现高度通用和可复用的代码。例如，编写一个通用的比较仿函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用比较仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">Compare</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 5 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仿函数的优势"><a href="#仿函数的优势" class="headerlink" title="仿函数的优势"></a>仿函数的优势</h3><ul><li><strong>可扩展性：</strong> 能够根据需要添加更多功能和状态。</li><li><strong>与Lambda的互补性：</strong> 在需要携带复杂状态或多次调用时，仿函数比Lambda更适合。</li><li><strong>类型安全：</strong> 仿函数是具体的类型，可以在编译期进行类型检查。</li></ul><h3 id="何时使用仿函数"><a href="#何时使用仿函数" class="headerlink" title="何时使用仿函数"></a>何时使用仿函数</h3><ul><li><strong>需要携带状态时：</strong> 当回调函数需要维护内部状态时，仿函数是理想选择。</li><li><strong>复杂操作：</strong> 当简单的函数指针或Lambda难以表达复杂逻辑时。</li><li><strong>性能关键场景：</strong> 由于仿函数可以被编译器优化，适用于性能敏感的代码。</li></ul><hr><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是C++11引入的一种轻量级函数对象，允许在代码中定义匿名函数。它们可以捕获周围的变量，具有更强的表达能力。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[captures](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>captures</strong>: 捕获外部变量的方式，可以是值捕获、引用捕获或者混合捕获。</li><li><strong>parameters</strong>: 参数列表。</li><li><strong>return_type</strong>: 返回类型，可以省略，编译器会自动推导。</li><li><strong>函数体</strong>: 实际执行的代码。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式进行过滤</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">        [threshold](<span class="type">int</span> n) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n &lt; threshold;</span><br><span class="line">        &#125;), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 6 8 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获方式"><a href="#捕获方式" class="headerlink" title="捕获方式"></a>捕获方式</h3><ol><li><strong>值捕获 (<code>[=]</code>)</strong>: 捕获所有外部变量的副本。</li><li><strong>引用捕获 (<code>[&amp;]</code>)</strong>: 捕获所有外部变量的引用。</li><li><strong>混合捕获</strong>: 指定部分变量按值捕获，部分按引用捕获，如 <code>[=, &amp;var]</code> 或 <code>[&amp;, var]</code>。</li><li><strong>无捕获 (<code>[]</code>)</strong>: 不捕获任何外部变量。</li></ol><h3 id="可变Lambda"><a href="#可变Lambda" class="headerlink" title="可变Lambda"></a>可变Lambda</h3><p>默认情况下，Lambda表达式是不可变的（<code>const</code>）。通过<code>mutable</code>关键字，可以允许修改捕获的变量副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [count]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count inside Lambda: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">increment</span>(); <span class="comment">// 输出: Count inside Lambda: 1</span></span><br><span class="line">    <span class="built_in">increment</span>(); <span class="comment">// 输出: Count inside Lambda: 2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count outside Lambda: &quot;</span> &lt;&lt; count &lt;&lt; std::endl; <span class="comment">// 输出: Count outside Lambda: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获成员函数和类变量"><a href="#捕获成员函数和类变量" class="headerlink" title="捕获成员函数和类变量"></a>捕获成员函数和类变量</h3><p>Lambda表达式可以捕获类的成员变量和成员函数，使其在类的上下文中更加灵活。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Processor</span>(<span class="type">int</span> threshold) : <span class="built_in">threshold</span>(threshold) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理前数据: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式进行过滤</span></span><br><span class="line">        data.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">int</span> n) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n &lt; threshold;</span><br><span class="line">            &#125;), data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理后数据: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function">Processor <span class="title">proc</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    proc.<span class="built_in">process</span>(numbers);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    处理前数据: 1 6 3 8 2 7 </span></span><br><span class="line"><span class="comment">    处理后数据: 6 8 7 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda与标准库算法"><a href="#Lambda与标准库算法" class="headerlink" title="Lambda与标准库算法"></a>Lambda与标准库算法</h3><p>Lambda表达式与标准库算法紧密结合，提供了更简洁和直观的代码书写方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式的优势"><a href="#Lambda表达式的优势" class="headerlink" title="Lambda表达式的优势"></a>Lambda表达式的优势</h3><ul><li><strong>简洁性：</strong> 代码更加紧凑，易于理解。</li><li><strong>灵活性：</strong> 能够捕获外部变量，适应更多场景。</li><li><strong>性能优化：</strong> 编译器可以对Lambda进行优化，如内联展开。</li><li><strong>与标准库的良好集成：</strong> 与STL算法无缝结合，简化代码逻辑。</li></ul><hr><h2 id="std-function-对象"><a href="#std-function-对象" class="headerlink" title="std::function 对象"></a><code>std::function</code> 对象</h2><p><code>std::function</code> 是C++11提供的一个通用的可调用包装器，能够封装任何可调用对象，包括普通函数、Lambda表达式、函数对象以及绑定表达式。它实现了类型擦除，使得不同类型的可调用对象可以通过统一的接口进行操作。</p><h3 id="定义与使用-2"><a href="#定义与使用-2" class="headerlink" title="定义与使用"></a>定义与使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func1 = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Add: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装Lambda表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func2 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Subtract: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装函数对象</span></span><br><span class="line">    Multiply multiply;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = multiply;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; <span class="built_in">func3</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Multiply: 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>类型擦除：</strong> 可以存储任何符合签名的可调用对象。</li><li><strong>灵活性：</strong> 支持动态改变存储的可调用对象。</li><li><strong>性能开销：</strong> 相比于直接使用函数指针或Lambda，<code>std::function</code> 可能带来一定的性能开销，尤其是在频繁调用时。</li></ul><h3 id="用法场景"><a href="#用法场景" class="headerlink" title="用法场景"></a>用法场景</h3><ul><li><strong>回调函数的传递。</strong></li><li><strong>事件处理系统。</strong></li><li><strong>策略模式的实现。</strong></li></ul><h3 id="示例：回调机制"><a href="#示例：回调机制" class="headerlink" title="示例：回调机制"></a>示例：回调机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回调类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(Callback cb, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件发生，调用回调</span></span><br><span class="line">    <span class="built_in">cb</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda作为回调</span></span><br><span class="line">    <span class="built_in">triggerEvent</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;事件触发，值为: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;, <span class="number">42</span>); <span class="comment">// 输出: 事件触发，值为: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数作为回调</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Printer打印值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; printer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">triggerEvent</span>(printer, <span class="number">100</span>); <span class="comment">// 输出: Printer打印值: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储和调用不同类型的可调用对象"><a href="#存储和调用不同类型的可调用对象" class="headerlink" title="存储和调用不同类型的可调用对象"></a>存储和调用不同类型的可调用对象</h3><p><code>std::function</code> 可以在容器中存储各种不同类型的可调用对象，只要它们符合指定的签名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同类型的可调用对象</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(add); <span class="comment">// 普通函数</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(<span class="built_in">Multiply</span>()); <span class="comment">// 仿函数</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a - b; &#125;); <span class="comment">// Lambda</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">op</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 15 50 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="std-bind-操作"><a href="#std-bind-操作" class="headerlink" title="std::bind 操作"></a><code>std::bind</code> 操作</h2><p><code>std::bind</code> 是C++11中提供的一个函数适配器，用于绑定函数或可调用对象的部分参数，生成一个新的可调用对象。它允许提前固定某些参数，简化函数调用或适应接口需求。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为10，生成新的函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> add10 = std::<span class="built_in">bind</span>(add, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add10</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 10 + 5 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位符-std-placeholders"><a href="#占位符-std-placeholders" class="headerlink" title="占位符 (std::placeholders)"></a>占位符 (<code>std::placeholders</code>)</h3><p><code>std::bind</code> 使用占位符来表示未绑定的参数，这些占位符决定了在生成的新函数对象中如何传递参数。</p><p>常用的占位符包括：</p><ul><li><code>std::placeholders::_1</code></li><li><code>std::placeholders::_2</code></li><li><code>std::placeholders::_3</code></li><li>等等，根据需要传递的参数数量。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> std::string&amp; msg, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定消息为&quot;Hello&quot;，生成新的函数对象，只需要传递次数</span></span><br><span class="line">    <span class="keyword">auto</span> sayHello = std::<span class="built_in">bind</span>(display, <span class="string">&quot;Hello&quot;</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sayHello</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定次数为2，生成新的函数对象，只需要传递消息</span></span><br><span class="line">    <span class="keyword">auto</span> sayTwice = std::<span class="built_in">bind</span>(display, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">sayTwice</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Hi</span></span><br><span class="line"><span class="comment">    Hi</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与Lambda表达式的对比"><a href="#与Lambda表达式的对比" class="headerlink" title="与Lambda表达式的对比"></a>与Lambda表达式的对比</h3><p><code>std::bind</code> 曾在C++11中广泛使用，但随着Lambda表达式的普及，很多情况下Lambda更为直观和高效。不过，在某些复杂的参数绑定场景下，<code>std::bind</code> 依然有其独特优势。</p><p><strong>使用 <code>std::bind</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为2，生成新的函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = std::<span class="built_in">bind</span>(multiply, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 5 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2 * 5 = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Lambda 表达式:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda表达式绑定第一个参数为2</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = [](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">multiply</span>(<span class="number">2</span>, b);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 5 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2 * 5 = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><strong>可读性：</strong> Lambda表达式通常更具可读性，语法更直观。</li><li><strong>灵活性：</strong> Lambda更易于捕获和使用外部变量。</li><li><strong>性能：</strong> Lambda通常比<code>std::bind</code>更高效，因为<code>std::bind</code>可能引入额外的间接层。</li></ul><hr><h2 id="绑定类的成员函数"><a href="#绑定类的成员函数" class="headerlink" title="绑定类的成员函数"></a>绑定类的成员函数</h2><p>在C++中，成员函数与普通函数不同，因为它们需要一个对象实例来调用。使用 <code>std::bind</code> 或Lambda表达式，可以方便地绑定类的成员函数，生成可调用对象。</p><h3 id="使用-std-bind-绑定成员函数"><a href="#使用-std-bind-绑定成员函数" class="headerlink" title="使用 std::bind 绑定成员函数"></a>使用 <code>std::bind</code> 绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定成员函数multiply，固定第一个参数为5</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy5 = std::<span class="built_in">bind</span>(&amp;Calculator::multiply, &amp;calc, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 * 3 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy5</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5 * 3 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Lambda表达式绑定成员函数"><a href="#使用Lambda表达式绑定成员函数" class="headerlink" title="使用Lambda表达式绑定成员函数"></a>使用Lambda表达式绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Greeter greeter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式绑定成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> greetFunc = [&amp;greeter](<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">        greeter.<span class="built_in">greet</span>(name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">greetFunc</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定静态成员函数"><a href="#绑定静态成员函数" class="headerlink" title="绑定静态成员函数"></a>绑定静态成员函数</h3><p>静态成员函数不依赖于类的实例，可以像普通函数一样使用 <code>std::bind</code> 和 <code>std::function</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用std::bind绑定静态成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> logFunc = std::<span class="built_in">bind</span>(&amp;Logger::log, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logFunc</span>(<span class="string">&quot;This is a static log message.&quot;</span>); <span class="comment">// 输出: Log: This is a static log message.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定带有返回值的成员函数"><a href="#绑定带有返回值的成员函数" class="headerlink" title="绑定带有返回值的成员函数"></a>绑定带有返回值的成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">power</span><span class="params">(<span class="type">double</span> base, <span class="type">double</span> exponent)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(exponent); ++i) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Math mathObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定成员函数power，固定基数为2</span></span><br><span class="line">    <span class="keyword">auto</span> powerOf2 = std::<span class="built_in">bind</span>(&amp;Math::power, &amp;mathObj, <span class="number">2.0</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2^3 = &quot;</span> &lt;&lt; <span class="built_in">powerOf2</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2^3 = 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>对象生命周期：</strong> 绑定成员函数时，确保对象在可调用对象使用期间依然存在，以避免悬空指针问题。</li><li><strong>指针与引用：</strong> 可以通过指针或引用传递对象实例给 <code>std::bind</code> 或Lambda表达式。</li><li><strong>捕获方式：</strong> 在使用Lambda表达式时，选择合适的捕获方式（值捕获或引用捕获）以确保对象的正确访问。</li></ul><hr><h2 id="C-可调用对象的总结"><a href="#C-可调用对象的总结" class="headerlink" title="C++ 可调用对象的总结"></a>C++ 可调用对象的总结</h2><p>C++ 提供了多种方式来定义和操作可调用对象，每种方式有其独特的特点和适用场景。</p><table><thead><tr><th>可调用对象</th><th>描述</th><th>示例用法</th></tr></thead><tbody><tr><td><strong>函数指针</strong></td><td>指向普通函数或静态成员函数的指针</td><td><code>int (*func)(int) = &amp;funcName;</code></td></tr><tr><td><strong>仿函数（Functors）</strong></td><td>重载了 <code>operator()</code> 的类实例，可以携带状态</td><td><code>struct Foo &#123; void operator()(); &#125;;</code></td></tr><tr><td><strong>Lambda表达式</strong></td><td>定义在表达式中的匿名函数，支持捕获上下文变量</td><td><code>[capture](params) &#123; /* code */ &#125;</code></td></tr><tr><td><strong><code>std::function</code></strong></td><td>通用的可调用对象包装器，能够封装任何符合签名的可调用对象</td><td><code>std::function&lt;void(int)&gt; func;</code></td></tr><tr><td><strong><code>std::bind</code></strong></td><td>绑定函数或可调用对象的部分参数，生成新的可调用对象</td><td><code>auto newFunc = std::bind(func, _1);</code></td></tr></tbody></table><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li><strong>简单回调：</strong> 使用函数指针或Lambda表达式。</li><li><strong>需要携带状态或更复杂逻辑：</strong> 使用Lambda表达式或仿函数（Functors）。</li><li><strong>接口要求 <code>std::function</code>：</strong> 使用 <code>std::function</code>，不过要注意可能的性能开销。</li><li><strong>参数预绑定：</strong> 使用 <code>std::bind</code>，但在现代C++中，许多情况下Lambda表达式能达到相同效果且更直观。</li></ul><hr><h2 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h2><p>以下是一个综合示例，展示了函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code>、<code>std::bind</code> 以及绑定类成员函数的使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 仿函数（Functors）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> subtract = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayOperation</span><span class="params">(<span class="type">const</span> std::string&amp; op, <span class="type">int</span> result)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; op &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add (Function Pointer): &quot;</span> &lt;&lt; <span class="built_in">funcPtr</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 仿函数（Functors）</span></span><br><span class="line">    Multiply multiply;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply (Functors): &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Lambda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract (Lambda): &quot;</span> &lt;&lt; <span class="built_in">subtract</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. std::function 封装不同可调用对象</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcAdd = add;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcSubtract = subtract;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcMultiply = multiply;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcAdd</span>(<span class="number">20</span>, <span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcSubtract</span>(<span class="number">20</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcMultiply</span>(<span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. std::bind 绑定部分参数</span></span><br><span class="line">    <span class="keyword">auto</span> add5 = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 10 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = std::<span class="built_in">bind</span>(multiply, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 10 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 绑定类成员函数</span></span><br><span class="line">    Calculator calc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定成员函数 subtract</span></span><br><span class="line">    <span class="keyword">auto</span> boundSubtract = std::<span class="built_in">bind</span>(&amp;Calculator::subtract, &amp;calc, <span class="number">15</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;15 - 5 = &quot;</span> &lt;&lt; <span class="built_in">boundSubtract</span>() &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定成员函数 displayOperation</span></span><br><span class="line">    <span class="keyword">auto</span> displayAdd = std::<span class="built_in">bind</span>(&amp;Calculator::displayOperation, &amp;calc, <span class="string">&quot;Add&quot;</span>, std::placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> displayResult = funcAdd;</span><br><span class="line">    <span class="type">int</span> addResult = <span class="built_in">displayResult</span>(<span class="number">7</span>, <span class="number">8</span>); <span class="comment">// 15</span></span><br><span class="line">    <span class="built_in">displayAdd</span>(addResult); <span class="comment">// 输出: Add结果: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 绑定静态成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> logFunc = std::<span class="built_in">bind</span>(&amp;Logger::log, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">logFunc</span>(<span class="string">&quot;This is a static log message.&quot;</span>); <span class="comment">// 输出: Log: This is a static log message.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 使用 std::function 存储混合可调用对象</span></span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同的操作到容器</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::cout &lt;&lt; <span class="string">&quot;Lambda Operation&quot;</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;Calculator::displayOperation, &amp;calc, <span class="string">&quot;Multiply&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::cout &lt;&lt; <span class="string">&quot;Add5(10): &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; &#125;);</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; Logger::<span class="built_in">log</span>(<span class="string">&quot;Lambda-based log message.&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        <span class="built_in">op</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Lambda Operation</span></span><br><span class="line"><span class="comment">    Multiply结果: 30</span></span><br><span class="line"><span class="comment">    Add5(10): 15</span></span><br><span class="line"><span class="comment">    Log: Lambda-based log message.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释:</strong></p><ol><li><strong>函数指针:</strong> 定义并使用了指向 <code>add</code> 函数的函数指针 <code>funcPtr</code>。</li><li><strong>仿函数（Functors）:</strong> 定义了 <code>Multiply</code> 结构体，并使用其实例 <code>multiply</code> 进行乘法运算。</li><li><strong>Lambda表达式:</strong> 定义了一个用于减法的Lambda <code>subtract</code>。</li><li><strong><code>std::function</code>:</strong> 封装了不同类型的可调用对象，包括普通函数、Lambda和仿函数。</li><li><strong><code>std::bind</code>:</strong> 绑定 <code>add</code> 和 <code>multiply</code> 函数的部分参数，生成新的可调用对象 <code>add5</code> 和 <code>multiplyBy2</code>。</li><li><strong>绑定类成员函数:</strong> 使用 <code>std::bind</code> 绑定 <code>Calculator</code> 类的成员函数 <code>subtract</code> 和 <code>displayOperation</code>。</li><li><strong>绑定静态成员函数:</strong> 使用 <code>std::bind</code> 绑定 <code>Logger</code> 类的静态成员函数 <code>log</code>。</li><li><strong>混合可调用对象容器:</strong> 使用 <code>std::function</code> 和 <code>std::vector</code> 存储并执行不同类型的可调用对象，包括Lambda、绑定成员函数和静态成员函数。</li></ol><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本教案，学生应能够理解并运用C++中的各种可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code> 和 <code>std::bind</code> 等。掌握这些工具不仅有助于编写更灵活和可维护的代码，还为进一步学习函数式编程和设计模式奠定了坚实的基础。在实际编程中，合理选择和组合这些可调用对象，可以大大提升代码的效率和表达力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;C++ 提供了多种方式来表示和操作可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、&lt;code&gt;std::fu</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(22) 内存管理</title>
    <link href="http://www.limerence2017.com/2024/12/05/cppbase22/"/>
    <id>http://www.limerence2017.com/2024/12/05/cppbase22/</id>
    <published>2024-12-05T07:47:53.000Z</published>
    <updated>2025-02-15T02:50:51.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理简介"><a href="#内存管理简介" class="headerlink" title="内存管理简介"></a>内存管理简介</h2><p>详细技术视频请看我的主页</p><p><a href="https://space.bilibili.com/271469206">C++教程视频</a></p><p>C++ 提供了多种内存管理方式，包括传统的 C 风格的 <code>malloc</code> 和 <code>free</code>，以及 C++ 专用的 <code>new</code> 和 <code>delete</code>。</p><p>理解这些内存管理方法对于编写高效、安全的 C++ 程序至关重要。</p><p>本文将详细介绍这些内存管理方法，包含基本用法、复杂操作（如 <code>realloc</code>），并配以实际案例和代码示例。</p><h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><p>在 C++ 程序中，内存主要分为以下几个区域：</p><ul><li><strong>栈（Stack）</strong>：自动管理内存，存储局部变量和函数调用信息。内存分配和释放速度快，但空间有限。</li><li><strong>堆（Heap）</strong>：手动管理内存，用于动态分配内存。内存分配和释放由程序员控制，灵活但易出错（如内存泄漏、悬挂指针）。</li><li><strong>全局/静态区（<code>Data/BSS Segment</code>）</strong>：存储全局变量和静态变量。</li></ul><p>了解栈和堆的区别，以及如何有效地在堆上分配和管理内存，是编写高效且安全的 C++ 程序的基础。</p><h2 id="C-风格内存管理"><a href="#C-风格内存管理" class="headerlink" title="C 风格内存管理"></a>C 风格内存管理</h2><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc 函数"></a><code>malloc</code> 函数</h3><p><code>malloc</code>（memory allocation）用于在堆上分配指定字节数的内存。其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>size</code> - 要分配的内存字节数。</li><li><strong>返回值</strong>：指向分配内存的指针，如果分配失败则返回 <code>nullptr</code>。</li></ul><h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a><code>free</code> 函数</h3><p><code>free</code> 用于释放之前由 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 分配的内存。其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>ptr</code> - 要释放的内存指针。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 malloc 和 free</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>类型转换</strong>：<code>malloc</code> 返回 <code>void*</code>，需要显式转换为所需类型的指针。</li><li><strong>初始化</strong>：<code>malloc</code> 分配的内存未初始化，内容不确定。</li><li><strong>释放对应性</strong>：由 <code>malloc</code> 分配的内存必须使用 <code>free</code> 释放，避免使用 <code>delete</code>。</li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h2><p>C++ 提供了更高层次的内存管理操作符：<code>new</code> 和 <code>delete</code>，它们不仅分配和释放内存，还调用构造函数和析构函数，提供类型安全。</p><h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><strong><code>new</code> 操作符</strong></h3><p>用于在堆上分配对象，并调用其构造函数。</p><p><strong>单个对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* ptr = <span class="keyword">new</span> <span class="built_in">Type</span>(parameters);</span><br></pre></td></tr></table></figure><ul><li><strong>例子</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="keyword">called</span> <span class="keyword">with</span> <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Object <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Destructor <span class="keyword">called</span> <span class="keyword">for</span> <span class="keyword">value</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* array = <span class="keyword">new</span> Type[size];</span><br></pre></td></tr></table></figure><ul><li><strong>例子</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 分配5个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放数组内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr[0] = 0</span><br><span class="line">arr[1] = 10</span><br><span class="line">arr[2] = 20</span><br><span class="line">arr[3] = 30</span><br><span class="line">arr[4] = 40</span><br></pre></td></tr></table></figure><p><strong><code>delete</code> 操作符</strong></p><p>用于释放由 <code>new</code> 分配的内存，并调用析构函数。</p><h3 id="释放单个对象"><a href="#释放单个对象" class="headerlink" title="释放单个对象"></a>释放单个对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure><h3 id="释放数组"><a href="#释放数组" class="headerlink" title="释放数组"></a>释放数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure><h3 id="区别于-malloc-和-free"><a href="#区别于-malloc-和-free" class="headerlink" title="区别于 malloc 和 free"></a>区别于 <code>malloc</code> 和 <code>free</code></h3><ul><li><strong>类型安全</strong>：<code>new</code> 返回正确类型的指针，免去了强制类型转换。</li><li><strong>构造/析构</strong>：<code>new</code> 和 <code>delete</code> 自动调用构造函数和析构函数。</li><li><strong>异常处理</strong>：在分配失败时，<code>new</code> 默认抛出 <code>std::bad_alloc</code> 异常，而 <code>malloc</code> 返回 <code>nullptr</code>。</li></ul><h3 id="异常安全的-new"><a href="#异常安全的-new" class="headerlink" title="异常安全的 new"></a>异常安全的 <code>new</code></h3><p>可以通过 <code>nothrow</code> 参数防止 <code>new</code> 抛出异常，改为返回 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 包含 std::nothrow</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结和对比"><a href="#总结和对比" class="headerlink" title="总结和对比"></a>总结和对比</h2><p>了解 <code>malloc/free</code> 与 <code>new/delete</code> 的区别，有助于在编写 C++ 程序时正确选择内存管理方法。</p><table><thead><tr><th>特性</th><th>malloc/free</th><th>new/delete</th></tr></thead><tbody><tr><td>类型安全</td><td>需要显式类型转换</td><td>自动类型转换，无需显式转换</td></tr><tr><td>构造/析构函数</td><td>不调用对象的构造/析构函数</td><td>调用对象的构造/析构函数</td></tr><tr><td>返回值</td><td><code>void*</code>，需要转换为目标类型</td><td>返回目标类型指针，类型安全</td></tr><tr><td>错误处理</td><td>分配失败返回 <code>nullptr</code></td><td>分配失败抛出 <code>std::bad_alloc</code> 异常</td></tr><tr><td>多态行为</td><td>无</td><td>支持多态，通过虚函数正确调用析构函数</td></tr><tr><td>内存分配与释放对应性</td><td>必须使用 <code>free</code> 释放由 <code>malloc</code> 分配的内存</td><td>必须使用 <code>delete</code> 释放由 <code>new</code> 分配的内存</td></tr></tbody></table><h3 id="示例对比"><a href="#示例对比" class="headerlink" title="示例对比"></a>示例对比</h3><p><strong>使用 <code>malloc</code> 和 <code>free</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">    MyClass* obj = (MyClass*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyClass));</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;malloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调用构造函数（不推荐）</span></span><br><span class="line">    <span class="keyword">new</span>(obj) <span class="built_in">MyClass</span>(<span class="number">20</span>); <span class="comment">// 通过“定位 new”调用构造函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调用析构函数</span></span><br><span class="line">    obj-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 <code>malloc</code> 分配 C++ 对象时，需要手动调用构造函数和析构函数，这非常不便且易出错。因此，推荐使用 <code>new</code> 和 <code>delete</code>。</p><p><strong>使用 <code>new</code> 和 <code>delete</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 new 分配内存并调用构造函数</span></span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 delete 释放内存并调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="keyword">called</span></span><br><span class="line"><span class="keyword">Value</span>: <span class="number">30</span></span><br><span class="line">Destructor <span class="keyword">called</span></span><br></pre></td></tr></table></figure><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li><strong>C++ 类型特性</strong>：<code>new</code> 和 <code>delete</code> 支持 C++ 的类型特性，包括构造函数、析构函数、多态等。</li><li><strong>C 兼容性</strong>：在需要兼容 C 代码或通过 C 接口分配内存时，仍可能需要使用 <code>malloc</code> 和 <code>free</code>。</li></ul><h2 id="高级内存管理"><a href="#高级内存管理" class="headerlink" title="高级内存管理"></a>高级内存管理</h2><h3 id="使用-realloc-进行内存重分配"><a href="#使用-realloc-进行内存重分配" class="headerlink" title="使用 realloc 进行内存重分配"></a>使用 realloc 进行内存重分配</h3><p><code>realloc</code> 用于调整之前分配的内存块大小。这在动态数组等数据结构中非常有用。</p><p><strong>原型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数</p><p>：</p><ul><li><code>ptr</code>：指向之前分配的内存块。</li><li><code>new_size</code>：新的内存大小（以字节为单位）。</li></ul></li><li><p><strong>返回值</strong>：指向重新分配后的内存块的新指针。如果重新分配失败，返回 <code>nullptr</code>，原内存块保持不变。</p></li></ul><p><strong>示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含 memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始分配 3 个整数</span></span><br><span class="line">    <span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Initial malloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配为 5 个整数</span></span><br><span class="line">    <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Realloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">free</span>(arr); <span class="comment">// 释放原内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化新元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = (i + <span class="number">1</span>) * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reallocated array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Initial</span> <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">Reallocated <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">40</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure><h3 id="动态数组管理"><a href="#动态数组管理" class="headerlink" title="动态数组管理"></a>动态数组管理</h3><p>使用 <code>malloc</code> 和 <code>realloc</code> 来手动管理动态数组可以实现可变大小的数组，但需要处理内存分配、释放和数据复制。</p><p><strong>封装动态数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>(<span class="type">size_t</span> initial_size = <span class="number">1</span>)</span><br><span class="line">        : <span class="built_in">size</span>(initial_size), <span class="built_in">data</span>((<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_size)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(data, new_size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">        size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">DynamicArray <span class="title">arr</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Initial array: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整大小</span></span><br><span class="line">        arr.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="number">40</span>;</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resized array: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Initial</span> <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">Resized <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">40</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这种方式需要手动管理内存和数组大小，且缺乏类型安全性和自动化。推荐使用 C++ 标准容器如 <code>std::vector</code> 来代替。</p><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h3 id="案例一：动态数组实现"><a href="#案例一：动态数组实现" class="headerlink" title="案例一：动态数组实现"></a>案例一：动态数组实现</h3><p>实现一个简单的动态数组类，支持添加元素、访问元素和自动扩展。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>()</span><br><span class="line">        : <span class="built_in">capacity</span>(<span class="number">2</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">data</span>((<span class="type">int</span>*)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[size++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(data, new_capacity * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DynamicArray arr;</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">30</span>); <span class="comment">// 触发扩展</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dynamic Array Contents:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr.<span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Array access error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dynamic</span> <span class="keyword">Array</span> Contents:</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br></pre></td></tr></table></figure><h3 id="案例二：自定义内存管理器"><a href="#案例二：自定义内存管理器" class="headerlink" title="案例二：自定义内存管理器"></a>案例二：自定义内存管理器</h3><p>实现一个简单的内存池，用于高效分配和释放固定大小的对象。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> objectSize, <span class="type">size_t</span> poolSize)</span><br><span class="line">        : <span class="built_in">objSize</span>(objectSize), <span class="built_in">totalSize</span>(poolSize), <span class="built_in">pool</span>((<span class="type">char</span>*)<span class="built_in">malloc</span>(objectSize * poolSize)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 free list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; poolSize; ++i) &#123;</span><br><span class="line">            freeList.<span class="built_in">push</span>(pool + i * objectSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (freeList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">void</span>* ptr = freeList.<span class="built_in">top</span>();</span><br><span class="line">        freeList.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        freeList.<span class="built_in">push</span>((<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> objSize;</span><br><span class="line">    <span class="type">size_t</span> totalSize;</span><br><span class="line">    <span class="type">char</span>* pool;</span><br><span class="line">    std::stack&lt;<span class="type">void</span>*&gt; freeList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个能容纳 3 个 MyClass 对象的内存池</span></span><br><span class="line">        <span class="function">MemoryPool <span class="title">pool</span><span class="params">(<span class="keyword">sizeof</span>(MyClass), <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配对象内存</span></span><br><span class="line">        <span class="type">void</span>* mem1 = pool.<span class="built_in">allocate</span>();</span><br><span class="line">        <span class="type">void</span>* mem2 = pool.<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用“定位 new”构造对象</span></span><br><span class="line">        MyClass* obj1 = <span class="built_in">new</span>(mem1) <span class="built_in">MyClass</span>(<span class="number">100</span>);</span><br><span class="line">        MyClass* obj2 = <span class="built_in">new</span>(mem2) <span class="built_in">MyClass</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用对象</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj1 value: &quot;</span> &lt;&lt; obj1-&gt;value &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 value: &quot;</span> &lt;&lt; obj2-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式调用析构函数</span></span><br><span class="line">        obj1-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line">        obj2-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        pool.<span class="built_in">deallocate</span>(mem1);</span><br><span class="line">        pool.<span class="built_in">deallocate</span>(mem2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory pool allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MyClass constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">MyClass constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">obj1 value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">obj2 value:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">MyClass destructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">MyClass destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><strong>MemoryPool</strong> 管理固定大小的内存块，避免频繁调用 <code>malloc</code> 和 <code>free</code>。</li><li>使用“<strong>定位 new</strong>”在预分配的内存上构造对象。</li><li>需要手动调用析构函数和将内存返回给内存池。</li></ul><p><strong>注意</strong>：这种方法适用于大量小对象的高效管理，但需要确保正确使用构造和析构函数。</p><h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h2><p>内存泄漏是指程序分配的内存未被释放，导致内存被浪费，甚至耗尽。避免内存泄漏的策略包括：</p><ul><li>**确保每个 <code>new</code> 有对应的 <code>delete</code>**。</li><li><strong>使用 <code>RAII</code> 和智能指针</strong>：自动管理资源，避免手动管理内存。</li><li><strong>工具辅助</strong>：使用工具如 <code>Valgrind</code> 检测内存泄漏。</li></ul><p><strong>示例：内存泄漏</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 忘记 delete p; 导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 正确释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RAII（资源获取即初始化）"><a href="#RAII（资源获取即初始化）" class="headerlink" title="RAII（资源获取即初始化）"></a><code>RAII</code>（资源获取即初始化）</h2><p><code>RAII</code> 是 C++ 中的一种编程惯用法，通过对象的生命周期管理资源，确保资源在对象构造时获取，析构时释放，避免泄漏。</p><p><strong>示例：<code>RAII</code> 实现类似于<code>shared_ptr</code>智能指针</strong></p><p><code>std::shared_ptr</code> 是 C++ 标准库中功能强大的智能指针之一，提供了共享所有权的能力，使得多个指针可以共同管理同一个动态分配的对象。通过引用计数机制，<code>shared_ptr</code> 确保了对象在最后一个指针被销毁时自动释放，极大地简化了内存管理，防止了内存泄漏和悬挂指针问题。</p><h3 id="SimpleSharedPtr-的基本概念"><a href="#SimpleSharedPtr-的基本概念" class="headerlink" title="SimpleSharedPtr 的基本概念"></a><strong><code>SimpleSharedPtr</code> 的基本概念</strong></h3><p><code>SimpleSharedPtr</code> 是一个简化版的 <code>shared_ptr</code> 实现，旨在帮助理解其核心机制。其基本功能包括：</p><ul><li><strong>共享所有权</strong>：多个 <code>SimpleSharedPtr</code> 实例可以指向同一个对象，共享对该对象的所有权。</li><li><strong>自动管理生命周期</strong>：当最后一个 <code>SimpleSharedPtr</code> 被销毁或指向其他对象时，管理的对象被自动释放。</li><li><strong>引用计数</strong>：内部维护一个引用计数，记录有多少个 <code>SimpleSharedPtr</code> 实例指向同一个对象。</li></ul><h3 id="引用计数控制块的设计"><a href="#引用计数控制块的设计" class="headerlink" title="引用计数控制块的设计"></a><strong>引用计数控制块的设计</strong></h3><p>为了实现引用计数机制，<code>SimpleSharedPtr</code> 需要一个控制块（Control Block），它包含：</p><ul><li><strong>引用计数（<code>ref_count</code>）</strong>：记录有多少个 <code>SimpleSharedPtr</code> 指向同一个对象。</li><li><strong>指向对象的指针（<code>ptr</code>）</strong>：指向实际管理的对象。</li></ul><p>控制块通常与被管理对象一起被分配，但为了简化实现，本示例将它们独立管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count;    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="comment">// 可以扩展为包含自定义删除器等</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SimpleSharedPtr-的实现"><a href="#SimpleSharedPtr-的实现" class="headerlink" title="SimpleSharedPtr 的实现"></a><code>SimpleSharedPtr</code> 的实现</h3><p><strong>类结构</strong></p><p><code>SimpleSharedPtr</code> 是一个模板类，模板参数 <code>T</code> 表示它所管理的对象类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control; <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、析构函数、拷贝与移动操作、操作符重载等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造函数与析构函数</strong></p><ul><li><strong>默认构造函数</strong>：初始化指针和控制块为空。</li><li><strong>参数化构造函数</strong>：接受一个裸指针，初始化控制块，并引用计数为1。</li><li><strong>析构函数</strong>：减少引用计数，若引用计数为0，则释放对象和控制块。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**辅助函数 <code>release</code>**：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (control) &#123;</span><br><span class="line">        control-&gt;ref_count--;</span><br><span class="line">        <span class="keyword">if</span> (control-&gt;ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> control;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    control = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造与拷贝赋值"><a href="#拷贝构造与拷贝赋值" class="headerlink" title="拷贝构造与拷贝赋值"></a>拷贝构造与拷贝赋值</h3><p>拷贝构造函数和拷贝赋值操作符允许多个 <code>SimpleSharedPtr</code> 实例共享同一个对象，共享相同的控制块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">    <span class="keyword">if</span> (control) &#123;</span><br><span class="line">        control-&gt;ref_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制新的资源和控制块</span></span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动构造与移动赋值"><a href="#移动构造与移动赋值" class="headerlink" title="移动构造与移动赋值"></a>移动构造与移动赋值</h3><p>移动语义允许资源所有权从一个 <code>SimpleSharedPtr</code> 转移到另一个，而不增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">    other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    other.control = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值操作符</span></span><br><span class="line">SimpleSharedPtr&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接管 `other` 的资源</span></span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置 `other` 为空</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>重载 <code>*</code> 和 <code>-&gt;</code> 操作符，以便像使用原生指针一样使用 <code>SimpleSharedPtr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头操作符</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h3><ul><li>**<code>use_count</code>**：返回当前引用计数。</li><li>**<code>get</code>**：返回裸指针。</li><li>**<code>reset</code>**：重置指针，指向新对象或 <code>nullptr</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取引用计数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> control ? control-&gt;ref_count : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裸指针</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向新资源</span></span><br><span class="line">    ptr = p;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><p>以下是 <code>SimpleSharedPtr</code> 的完整实现及其使用示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制块结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版的 shared_ptr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control; <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count--;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Decremented ref_count to &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (control-&gt;ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> control;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Resource and ControlBlock destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructed SimpleSharedPtr (nullptr).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Constructed SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copied SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                control-&gt;ref_count++;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Assigned SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved SimpleSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move-assigned SimpleSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> control ? control-&gt;ref_count : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        ptr = p;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Reset SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating default constructed shared_ptr...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    SimpleSharedPtr&lt;Test&gt; ptr1; <span class="comment">// 默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating shared_ptr with resource...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">SimpleSharedPtr&lt;Test&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>; <span class="comment">// 非默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCopying ptr2 to ptr3...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    SimpleSharedPtr&lt;Test&gt; ptr3 = ptr2; <span class="comment">// 拷贝构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr3-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning ptr3 to ptr1...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ptr1 = ptr3; <span class="comment">// 拷贝赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nResetting ptr2...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">200</span>)); <span class="comment">// 重新指向新的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nExiting scope...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// ptr2, ptr1, ptr3 离开作用域</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleUniquePtr-的实现"><a href="#SimpleUniquePtr-的实现" class="headerlink" title="SimpleUniquePtr 的实现"></a><code>SimpleUniquePtr</code> 的实现</h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，确保在任意时刻，只有一个 <code>unique_ptr</code> 实例指向特定资源。它不支持拷贝操作，只支持移动操作。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>首先，定义一个模板类 <code>SimpleUniquePtr</code>，它持有一个指向资源的裸指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleUniquePtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr; <span class="comment">// 指向管理对象的裸指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、析构函数、删除拷贝构造与拷贝赋值</span></span><br><span class="line">    <span class="comment">// 实现移动构造与移动赋值</span></span><br><span class="line">    <span class="comment">// 重载操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul><li><strong>默认构造函数</strong>：初始化指针为空。</li><li><strong>参数化构造函数</strong>：接受一个指向资源的裸指针。</li><li><strong>析构函数</strong>：当 <code>SimpleUniquePtr</code> 被销毁时，释放所管理的资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleUniquePtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">SimpleUniquePtr</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除拷贝构造与拷贝赋值"><a href="#删除拷贝构造与拷贝赋值" class="headerlink" title="删除拷贝构造与拷贝赋值"></a>删除拷贝构造与拷贝赋值</h3><p>为了确保唯一性，禁止拷贝构造和拷贝赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除拷贝构造</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除拷贝赋值</span></span><br><span class="line">SimpleUniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>支持移动构造和移动赋值，以转移所有权：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;</span><br><span class="line">    other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值</span></span><br><span class="line">SimpleUniquePtr&amp; <span class="keyword">operator</span>=(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;     <span class="comment">// 释放当前资源</span></span><br><span class="line">        ptr = other.ptr; <span class="comment">// 转移所有权</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>重载 <code>*</code> 和 <code>-&gt;</code> 操作符，以模拟指针的行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头操作符</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裸指针</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有权，返回裸指针并设为 nullptr</span></span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T* temp = ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设定指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下示例展示了如何使用 <code>SimpleUniquePtr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleUniquePtr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleUniquePtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleUniquePtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleUniquePtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SimpleUniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    SimpleUniquePtr&amp; <span class="keyword">operator</span>=(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权</span></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* temp = ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设定指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 SimpleUniquePtr</span></span><br><span class="line">    <span class="function">SimpleUniquePtr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    (*ptr1).<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动所有权到 ptr2</span></span><br><span class="line">    SimpleUniquePtr&lt;Test&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权</span></span><br><span class="line">    Test* rawPtr = ptr2.<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptr2.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now nullptr after release.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    rawPtr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> rawPtr; <span class="comment">// 手动删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reset</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(); <span class="comment">// 自动删除</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now nullptr after reset.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="string">ptr1</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">move.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="string">ptr2</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">release.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">2</span></span><br><span class="line"><span class="string">ptr2</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">reset.</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>创建 <code>ptr1</code> 并指向一个 <code>Test</code> 对象。</li><li>使用 <code>std::move</code> 将所有权转移到 <code>ptr2</code>，<code>ptr1</code> 变为 <code>nullptr</code>。</li><li>使用 <code>release()</code> 释放 <code>ptr2</code> 的所有权，获取裸指针后需要手动 <code>delete</code>。</li><li>使用 <code>reset()</code> 重新指向一个新的 <code>Test</code> 对象，自动释放之前的资源。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 C++ 中的内存管理方法，包括基础的 <code>malloc</code> 和 <code>free</code>，以及更现代的 C++ 风格的 <code>new</code> 和 <code>delete</code>。通过对比两者的特点，强调了 <code>new</code> 和 <code>delete</code> 在 C++ 中的优势，如类型安全、自动调用构造和析构函数等。</p><p>高级内存管理部分探讨了如何使用 <code>realloc</code> 进行内存重分配，并通过实际案例展示了如何实现动态数组和自定义内存管理器。最后，介绍了最佳实践，强调避免内存泄漏的重要性，以及 <code>RAII</code> 和智能指针对内存管理的帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存管理简介&quot;&gt;&lt;a href=&quot;#内存管理简介&quot; class=&quot;headerlink&quot; title=&quot;内存管理简介&quot;&gt;&lt;/a&gt;内存管理简介&lt;/h2&gt;&lt;p&gt;详细技术视频请看我的主页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://space.bilibili.co</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>聊天项目(31) 单线程文件传输</title>
    <link href="http://www.limerence2017.com/2024/11/24/cpppro31/"/>
    <id>http://www.limerence2017.com/2024/11/24/cpppro31/</id>
    <published>2024-11-24T10:04:18.000Z</published>
    <updated>2025-02-15T02:59:46.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>文件传输必须满足以下几个条件：</p><ul><li>限制文件大小(不超过<code>4G</code>)</li><li>长连接传输(效率高，支持大文件)</li><li>客户端和服务器都知道传输进度，以保证支持断点续传(后续实现)</li><li>先实现服务器单线程处理版本，在实现多线程处理版本</li></ul><p>如遇问题可添加我的微信</p><img src="https://cdn.llfc.club/wechat.jpg" alt="img" style="zoom: 33%;" /><p>也可以去我得哔哩哔哩主页查看项目视频详细讲解</p><p>B站主页 <a href="https://space.bilibili.com/271469206">https://space.bilibili.com/271469206</a></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端还是采用聊天项目客户端封装的<code>TcpClient</code>, 只是修改了发送逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::slot_send_msg</span><span class="params">(quint16 id, QByteArray body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果连接异常则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(_socket-&gt;<span class="built_in">state</span>() != QAbstractSocket::ConnectedState)&#123;</span><br><span class="line">        <span class="function">emit <span class="title">sig_net_error</span><span class="params">(QString(<span class="string">&quot;断开连接无法发送&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取body的长度</span></span><br><span class="line">    quint32 bodyLength = body.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    QByteArray data;</span><br><span class="line">    <span class="comment">//绑定字节数组</span></span><br><span class="line">    <span class="function">QDataStream <span class="title">stream</span><span class="params">(&amp;data, QIODevice::WriteOnly)</span></span>;</span><br><span class="line">    <span class="comment">//设置大端模式</span></span><br><span class="line">    stream.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">    <span class="comment">//写入ID</span></span><br><span class="line">    stream &lt;&lt; id;</span><br><span class="line">    <span class="comment">//写入长度</span></span><br><span class="line">    stream &lt;&lt; bodyLength;</span><br><span class="line">    <span class="comment">//写入包体</span></span><br><span class="line">    data.<span class="built_in">append</span>(body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">     _socket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里着重叙述以下，发送的格式是<code>id + bodyLength + 文件流数据</code></p><p>其中id 为2字节，<code>bodyLength</code>为4字节，之后就是传输的文件流</p><p><img src="https://cdn.llfc.club/1732450428990.jpg" alt="https://cdn.llfc.club/1732450428990.jpg"></p><p><code>slot_send_msg</code>是槽函数，和 <code>sig_send_msg</code>信号连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接 发送数据信号和槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;TcpClient::sig_send_msg, <span class="keyword">this</span>, &amp;TcpClient::slot_send_msg);</span><br></pre></td></tr></table></figure><p>客户端在发送数据的时候调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::sendMsg</span><span class="params">(quint16 id,QByteArray data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发送信号，统一交给槽函数处理，这么做的好处是多线程安全</span></span><br><span class="line">    <span class="function">emit <span class="title">sig_send_msg</span><span class="params">(id, data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端在打开文件对话框后选择文件，接下来，点击发送会将文件切分成固定大小的报文发送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_uploadBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;uploadBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">       <span class="function">QFile <span class="title">file</span><span class="params">(_file_name)</span></span>;</span><br><span class="line">       <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">           <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Could not open file:&quot;</span> &lt;&lt; file.<span class="built_in">errorString</span>();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 保存当前文件指针位置</span></span><br><span class="line">       qint64 originalPos = file.<span class="built_in">pos</span>();</span><br><span class="line">       <span class="function">QCryptographicHash <span class="title">hash</span><span class="params">(QCryptographicHash::Md5)</span></span>;</span><br><span class="line">       <span class="keyword">if</span> (!hash.<span class="built_in">addData</span>(&amp;file)) &#123;</span><br><span class="line">           <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to read data from file:&quot;</span> &lt;&lt; _file_name;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       _file_md5 = hash.<span class="built_in">result</span>().<span class="built_in">toHex</span>(); <span class="comment">// 返回十六进制字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容并发送</span></span><br><span class="line">    QByteArray buffer;</span><br><span class="line">    <span class="type">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QFileInfo <span class="title">fileInfo</span><span class="params">(_file_name)</span></span>; <span class="comment">// 创建 QFileInfo 对象</span></span><br><span class="line"></span><br><span class="line">    QString fileName = fileInfo.<span class="built_in">fileName</span>(); <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件名是：&quot;</span> &lt;&lt; fileName; <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="type">int</span> total_size = fileInfo.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> last_seq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(total_size % MAX_FILE_LEN)&#123;</span><br><span class="line">        last_seq = (total_size/MAX_FILE_LEN)+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        last_seq = total_size/MAX_FILE_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件指针到原来的位置</span></span><br><span class="line">    file.<span class="built_in">seek</span>(originalPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        <span class="comment">//每次读取2048字节发送</span></span><br><span class="line">        buffer = file.<span class="built_in">read</span>(MAX_FILE_LEN);</span><br><span class="line">        QJsonObject jsonObj;</span><br><span class="line">        <span class="comment">// 将文件内容转换为 Base64 编码（可选）</span></span><br><span class="line">        QString base64Data = buffer.<span class="built_in">toBase64</span>();</span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt; &quot;send data is &quot; &lt;&lt; base64Data;</span></span><br><span class="line">        ++seq;</span><br><span class="line">        jsonObj[<span class="string">&quot;md5&quot;</span>] = _file_md5;</span><br><span class="line">        jsonObj[<span class="string">&quot;name&quot;</span>] = fileName;</span><br><span class="line">        jsonObj[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">        jsonObj[<span class="string">&quot;trans_size&quot;</span>] = buffer.<span class="built_in">size</span>() + (seq<span class="number">-1</span>)*MAX_FILE_LEN;</span><br><span class="line">        jsonObj[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">        <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() &lt; MAX_FILE_LEN)&#123;</span><br><span class="line">            jsonObj[<span class="string">&quot;last&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            jsonObj[<span class="string">&quot;last&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonObj[<span class="string">&quot;data&quot;</span>]= base64Data;</span><br><span class="line">        jsonObj[<span class="string">&quot;last_seq&quot;</span>] = last_seq;</span><br><span class="line">        <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(jsonObj)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> send_data = doc.<span class="built_in">toJson</span>();</span><br><span class="line">        TcpClient::<span class="built_in">Inst</span>().<span class="built_in">sendMsg</span>(ID_UPLOAD_FILE_REQ, send_data);</span><br><span class="line">        <span class="comment">//startDelay(500);</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送时数据字段分别为：</p><ul><li><p>文件<code>md5 </code> : 以后用来做断点续传校验</p></li><li><p><code>name</code> : 文件名</p></li><li><p><code>seq</code>:  报文序列号，类似于TCP序列号，自己定义的，服务器根据这个序列号组合数据写入文件。</p></li><li><p><code>trans_size</code>:   当前已经传输的大小</p></li><li><p><code>total_size</code>： 传输文件的总大小。</p></li></ul><p>客户端需要接受服务器返回的消息更新进度条</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受服务器发送的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::slot_ready_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取所有数据</span></span><br><span class="line">    QByteArray data = _socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据缓存起来</span></span><br><span class="line">    _buffer.<span class="built_in">append</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理收到的数据</span></span><br><span class="line">    <span class="built_in">processData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理消息更新进度条</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::processData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(_buffer.<span class="built_in">size</span>() &gt;= TCP_HEAD_LEN)&#123;</span><br><span class="line">        <span class="comment">//先取出八字节头部</span></span><br><span class="line">        <span class="keyword">auto</span> head_byte = _buffer.<span class="built_in">left</span>(TCP_HEAD_LEN);</span><br><span class="line">        <span class="function">QDataStream <span class="title">stream</span><span class="params">(head_byte)</span></span>;</span><br><span class="line">        <span class="comment">//设置为大端模式</span></span><br><span class="line">        stream.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">        <span class="comment">//读取ID</span></span><br><span class="line">        quint16 msg_id;</span><br><span class="line">        stream &gt;&gt; msg_id;</span><br><span class="line">        <span class="comment">//读取长度</span></span><br><span class="line">        quint32 body_length;</span><br><span class="line">        stream &gt;&gt; body_length;</span><br><span class="line">        <span class="keyword">if</span>(_buffer.<span class="built_in">size</span>() &gt;= TCP_HEAD_LEN+body_length)&#123;</span><br><span class="line">            <span class="comment">//完整的消息体已经接受</span></span><br><span class="line">            QByteArray body = _buffer.<span class="built_in">mid</span>(TCP_HEAD_LEN,body_length);</span><br><span class="line">            <span class="comment">//去掉完整的消息包</span></span><br><span class="line">            _buffer = _buffer.<span class="built_in">mid</span>(TCP_HEAD_LEN+body_length);</span><br><span class="line">            <span class="comment">// 解析服务器发过来的消息</span></span><br><span class="line">            QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(body);</span><br><span class="line">            <span class="keyword">if</span>(jsonDoc.<span class="built_in">isNull</span>())&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create JSON doc.&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!jsonDoc.<span class="built_in">isObject</span>())&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;JSON is not an object.&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//qDebug() &lt;&lt; &quot;receive data is &quot; &lt;&lt; body;</span></span><br><span class="line">            <span class="comment">// 获取 JSON 对象</span></span><br><span class="line">            QJsonObject jsonObject = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line">            <span class="function">emit <span class="title">sig_logic_process</span><span class="params">(msg_id, jsonObject)</span></span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//消息未完全接受，所以中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单线程逻辑服务器"><a href="#单线程逻辑服务器" class="headerlink" title="单线程逻辑服务器"></a>单线程逻辑服务器</h2><p>我们先讲解单线程处理收包逻辑的服务器，以后再给大家将多线程的。</p><p>服务器要配合客户端，对报文头部大小做修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部总长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_TOTAL_LEN 6</span></span><br><span class="line"><span class="comment">//头部id长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_ID_LEN 2</span></span><br><span class="line"><span class="comment">//头部数据长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_DATA_LEN 4</span></span><br><span class="line"><span class="comment">// 接受队列最大个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RECVQUE  2000000</span></span><br><span class="line"><span class="comment">// 发送队列最大个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SENDQUE 2000000</span></span><br></pre></td></tr></table></figure><p>其余逻辑和我们在网络编程中讲的<code>IocontextPool</code>模型服务器一样</p><p>服务器收到报文头后调用<code>LogicSystem</code>来处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::AsyncReadBody</span><span class="params">(<span class="type">int</span> total_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="built_in">asyncReadFull</span>(total_len, [self, <span class="keyword">this</span>, total_len](<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transfered) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_session_id);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytes_transfered &lt; total_len) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;read length not match, read [&quot;</span> &lt;&lt; bytes_transfered &lt;&lt; <span class="string">&quot;] , total [&quot;</span></span><br><span class="line">&lt;&lt; total_len&lt;&lt;<span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">_server-&gt;<span class="built_in">ClearSession</span>(_session_id);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data , _data , bytes_transfered);</span><br><span class="line">_recv_msg_node-&gt;_cur_len += bytes_transfered;</span><br><span class="line">_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line"><span class="comment">//此处将消息投递到逻辑队列中</span></span><br><span class="line">LogicSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line"><span class="comment">//继续监听头部接受事件</span></span><br><span class="line"><span class="built_in">AsyncReadHead</span>(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>LogicSystem</code>会将消息投递到队列里，然后单线程处理,  服务器<code>LogicSystem</code>注册上传逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_fun_callbacks[ID_TEST_MSG_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line"><span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line"><span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv test data is  &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">Json::Value  rtvalue;</span><br><span class="line"><span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">session-&gt;Send(return_str, ID_TEST_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">rtvalue[<span class="string">&quot;data&quot;</span>] = data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_fun_callbacks[ID_UPLOAD_FILE_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line"><span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line"><span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;recv file data is  &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">Json::Value  rtvalue;</span><br><span class="line"><span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line">std::string decoded = <span class="built_in">base64_decode</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> seq = root[<span class="string">&quot;seq&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> name = root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"><span class="keyword">auto</span> total_size = root[<span class="string">&quot;total_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> trans_size = root[<span class="string">&quot;trans_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> file_path = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetFileOutPath</span>();</span><br><span class="line"><span class="keyword">auto</span> file_path_str = (file_path / name).<span class="built_in">string</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;file_path_str is &quot;</span> &lt;&lt; file_path_str &lt;&lt; std::endl;</span><br><span class="line">std::ofstream outfile;</span><br><span class="line"><span class="comment">//第一个包</span></span><br><span class="line"><span class="keyword">if</span> (seq == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 打开文件，如果存在则清空，不存在则创建</span></span><br><span class="line">outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::trunc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 保存为文件</span></span><br><span class="line">outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">write</span>(decoded.<span class="built_in">data</span>(), decoded.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;写入文件失败。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">close</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件已成功保存为: &quot;</span> &lt;&lt; name &lt;&lt;  std::endl;</span><br><span class="line"></span><br><span class="line">rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">rtvalue[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">rtvalue[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">rtvalue[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">rtvalue[<span class="string">&quot;trans_size&quot;</span>] = trans_size;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到上传消息后写入文件。</p><h2 id="多线程逻辑服务器"><a href="#多线程逻辑服务器" class="headerlink" title="多线程逻辑服务器"></a>多线程逻辑服务器</h2><p>多线程逻辑服务器主要是为了缓解单线程接受数据造成的瓶颈，因为单线程接收数据，就会影响其他线程接收数据，所以考虑引入线程池处理收到的数据。</p><p>在多线程编程中我们讲过划分多线程设计的几种思路：</p><ol><li>按照任务划分，将不同的任务投递给不同的线程</li><li>按照线程数轮询处理</li><li>按照递归的方式划分</li></ol><p>很明显我们不是做二分查找之类的算法处理，所以不会采用第三种。</p><p>现在考虑第二种，如果客户端发送一个很大的文件，客户端将文件切分为几个小份发送，服务器通过<code>iocontext</code>池接受数据, 将接受的数据投递到线程池。</p><p>我们知道线程池处理任务是不分先后顺序的，只要投递到队列中的都会被无序取出处理。</p><p><img src="https://cdn.llfc.club/1732945106584.jpg" alt="https://cdn.llfc.club/1732945106584.jpg"></p><p>会造成数据包处理的乱序，当然可以最后交给一个线程去组合，统一写入文件，这么做的一个弊端就是如果文件很大，那就要等待完全重组完成才能组合为一个统一的包，如果文件很大，这个时间就会很长，当然也可以暂时缓存这些数据，每次收到后排序组合，比较麻烦。</p><p>所以这里推荐按照任务划分。</p><p>按照任务划分就是按照不同的客户端做区分，一个客户端传输的数据按照文件名字的hash值划分给不同的线程单独处理，也就是一个线程专门处理对应的hash值的任务，这样既能保证有序，又能保证其他线程可以处理其他任务，也有概率会命中hash同样的值投递给一个队列，但也扩充了并发能力。</p><p><img src="https://cdn.llfc.club/1732948742965.jpg" alt="https://cdn.llfc.club/1732948742965.jpg"></p><p>因为我们之前的逻辑处理也是单线程，所以考虑在逻辑层这里做一下解耦合，因为这个服务只是用来处理数据接受，不涉及多个连接互相访问。所以可以讲logic线程扩充为多个，按照<code>sessionid</code>将不同的逻辑分配给不同的线程处理。</p><p><img src="https://cdn.llfc.club/1732952125218.jpg" alt="https://cdn.llfc.club/1732952125218.jpg"></p><h2 id="多线程处理逻辑"><a href="#多线程处理逻辑" class="headerlink" title="多线程处理逻辑"></a>多线程处理逻辑</h2><p>将<code>LogicSystem</code>中添加多个<code>LogicWorker</code>用来处理逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  function&lt;<span class="type">void</span>(shared_ptr&lt;CSession&gt;, <span class="type">const</span> <span class="type">short</span> &amp;msg_id, <span class="type">const</span> string &amp;msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span>:<span class="keyword">public</span> Singleton&lt;LogicSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">LogicSystem</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(shared_ptr &lt; LogicNode&gt; msg, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">LogicSystem</span>();</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;LogicWorker&gt; &gt; _workers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现投递逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LOGIC_WORKER_COUNT; i++) &#123;</span><br><span class="line">_workers.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;LogicWorker&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(shared_ptr &lt; LogicNode&gt; msg, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">_workers[index]-&gt;<span class="built_in">PostTask</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个LogicWorker都包含一个线程，这样LogicWorker可以在独立的线程里处理任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicWorker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LogicWorker</span>();</span><br><span class="line">~<span class="built_in">LogicWorker</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; task)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_callback</span><span class="params">(std::shared_ptr&lt;LogicNode&gt;)</span></span>;</span><br><span class="line">std::thread _work_thread;</span><br><span class="line">std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _task_que;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; _b_stop;</span><br><span class="line">std::mutex  _mtx;</span><br><span class="line">std::condition_variable _cv;</span><br><span class="line">std::unordered_map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LogicWorker启动一个线程处理任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LogicWorker::<span class="built_in">LogicWorker</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RegisterCallBacks</span>();</span><br><span class="line"></span><br><span class="line">_work_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line"><span class="keyword">while</span> (!_b_stop) &#123;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line"><span class="keyword">if</span>(_b_stop) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> task = _task_que.<span class="built_in">front</span>();</span><br><span class="line"><span class="built_in">task_callback</span>(task);</span><br><span class="line">_task_que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然要提前注册好任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicWorker::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_fun_callbacks[ID_TEST_MSG_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line"><span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line"><span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;recv test data is  &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">Json::Value  rtvalue;</span><br><span class="line"><span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">session-&gt;Send(return_str, ID_TEST_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">rtvalue[<span class="string">&quot;data&quot;</span>] = data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_fun_callbacks[ID_UPLOAD_FILE_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line"><span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line">reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line"><span class="keyword">auto</span> seq = root[<span class="string">&quot;seq&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> name = root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line"><span class="keyword">auto</span> total_size = root[<span class="string">&quot;total_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> trans_size = root[<span class="string">&quot;trans_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> last = root[<span class="string">&quot;last&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"><span class="keyword">auto</span> file_data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">Json::Value  rtvalue;</span><br><span class="line"><span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::hash 对字符串进行哈希</span></span><br><span class="line">std::hash&lt;std::string&gt; hash_fn;</span><br><span class="line"><span class="type">size_t</span> hash_value = <span class="built_in">hash_fn</span>(name); <span class="comment">// 生成哈希值</span></span><br><span class="line"><span class="type">int</span> index = hash_value % FILE_WORKER_COUNT;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hash value: &quot;</span> &lt;&lt; hash_value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">FileSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(</span><br><span class="line">std::<span class="built_in">make_shared</span>&lt;FileTask&gt;(session, name, seq, total_size,</span><br><span class="line">trans_size, last, file_data),</span><br><span class="line">index</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">rtvalue[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">rtvalue[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">rtvalue[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">rtvalue[<span class="string">&quot;trans_size&quot;</span>] = trans_size;</span><br><span class="line">rtvalue[<span class="string">&quot;last&quot;</span>] = last;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicWorker::task_callback</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; task-&gt;_recvnode-&gt;_msg_id &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(task-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line"><span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">call_back_iter-&gt;<span class="built_in">second</span>(task-&gt;_session, task-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">std::<span class="built_in">string</span>(task-&gt;_recvnode-&gt;_data, task-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如对于文件上传，<code>ID_UPLOAD_FILE_REQ</code>就调用对应的回调，在回调函数里我们再次将要处理的任务封装好投递到文件系统</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(</span><br><span class="line">std::<span class="built_in">make_shared</span>&lt;FileTask&gt;(session, name, seq, total_size,</span><br><span class="line">trans_size, last, file_data),</span><br><span class="line">index</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>文件系统和逻辑系统类似，包含一堆FileWorker</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> :<span class="keyword">public</span> Singleton&lt;FileSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;FileSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">FileSystem</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(shared_ptr &lt;FileTask&gt; msg, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">FileSystem</span>();</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;FileWorker&gt;&gt;  _file_workers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现投递逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileSystem::~<span class="built_in">FileSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileSystem::PostMsgToQue</span><span class="params">(shared_ptr&lt;FileTask&gt; msg, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_file_workers[index]-&gt;<span class="built_in">PostTask</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileSystem::<span class="built_in">FileSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILE_WORKER_COUNT; i++) &#123;</span><br><span class="line">_file_workers.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;FileWorker&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义文件任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileTask</span> &#123;</span><br><span class="line"><span class="built_in">FileTask</span>(std::shared_ptr&lt;CSession&gt; session, std::string name,</span><br><span class="line"><span class="type">int</span> seq, <span class="type">int</span> total_size, <span class="type">int</span> trans_size, <span class="type">int</span> last, </span><br><span class="line">std::string file_data) :_session(session),</span><br><span class="line">_seq(seq),_name(name),_total_size(total_size),</span><br><span class="line">_trans_size(trans_size),_last(last),_file_data(file_data)</span><br><span class="line">&#123;&#125;</span><br><span class="line">~<span class="built_in">FileTask</span>()&#123;&#125;</span><br><span class="line">std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _seq ;</span><br><span class="line">std::string _name ;</span><br><span class="line"><span class="type">int</span> _total_size ;</span><br><span class="line"><span class="type">int</span> _trans_size ;</span><br><span class="line"><span class="type">int</span> _last ;</span><br><span class="line">std::string _file_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现文件工作者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileWorker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileWorker</span>();</span><br><span class="line">~<span class="built_in">FileWorker</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_callback</span><span class="params">(std::shared_ptr&lt;FileTask&gt;)</span></span>;</span><br><span class="line">std::thread _work_thread;</span><br><span class="line">std::queue&lt;std::shared_ptr&lt;FileTask&gt;&gt; _task_que;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; _b_stop;</span><br><span class="line">std::mutex  _mtx;</span><br><span class="line">std::condition_variable _cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数启动线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FileWorker::<span class="built_in">FileWorker</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">_work_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line"><span class="keyword">while</span> (!_b_stop) &#123;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line"><span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> task = _task_que.<span class="built_in">front</span>();</span><br><span class="line">_task_que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">task_callback</span>(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构需等待线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileWorker::~<span class="built_in">FileWorker</span>()</span><br><span class="line">&#123;</span><br><span class="line">_b_stop = <span class="literal">true</span>;</span><br><span class="line">_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">_work_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投递任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileWorker::PostTask</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">_task_que.<span class="built_in">push</span>(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程会触发回调函数保存文件，所以我们实现回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileWorker::task_callback</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line">std::string decoded = <span class="built_in">base64_decode</span>(task-&gt;_file_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> file_path = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetFileOutPath</span>();</span><br><span class="line"><span class="keyword">auto</span> file_path_str = (file_path / task-&gt;_name).<span class="built_in">string</span>();</span><br><span class="line"><span class="keyword">auto</span> last = task-&gt;_last;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;file_path_str is &quot; &lt;&lt; file_path_str &lt;&lt; std::endl;</span></span><br><span class="line">std::ofstream outfile;</span><br><span class="line"><span class="comment">//第一个包</span></span><br><span class="line"><span class="keyword">if</span> (task-&gt;_seq == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 打开文件，如果存在则清空，不存在则创建</span></span><br><span class="line">outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::trunc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 保存为文件</span></span><br><span class="line">outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">write</span>(decoded.<span class="built_in">data</span>(), decoded.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;写入文件失败。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">if</span> (last) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件已成功保存为: &quot;</span> &lt;&lt; task-&gt;_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p><img src="https://cdn.llfc.club/1732955339237.jpg" alt="https://cdn.llfc.club/1732955339237.jpg"></p><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p><a href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server">https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计思路&quot;&gt;&lt;a href=&quot;#设计思路&quot; class=&quot;headerlink&quot; title=&quot;设计思路&quot;&gt;&lt;/a&gt;设计思路&lt;/h2&gt;&lt;p&gt;文件传输必须满足以下几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制文件大小(不超过&lt;code&gt;4G&lt;/code&gt;)&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C++聊天项目" scheme="http://www.limerence2017.com/categories/cpppro/"/>
    
    
    <category term="C++聊天项目" scheme="http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(21) 类相关面试题</title>
    <link href="http://www.limerence2017.com/2024/11/23/cppbase21/"/>
    <id>http://www.limerence2017.com/2024/11/23/cppbase21/</id>
    <published>2024-11-23T01:47:27.000Z</published>
    <updated>2025-02-15T02:50:47.518Z</updated>
    
    <content type="html"><![CDATA[<p>详细技术视频请看我的主页</p><p><a href="https://space.bilibili.com/271469206">C++教程视频</a></p><h2 id="什么是默认构造"><a href="#什么是默认构造" class="headerlink" title="什么是默认构造"></a>什么是默认构造</h2><p>默认构造就是不带参数的构造函数，如果我们不实现任何构造函数，系统会为我们生成一个默认的构造函数</p><p>比如下面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们可以直接使用默认构造函数构造一个对象，并且打印成员<code>_i</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试默认合成</span></span><br><span class="line">JoiningThread jt;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member _i is -1284874240</span><br></pre></td></tr></table></figure><p>可以看到默认构造函数并不会帮我们初始化类成员变量。</p><h2 id="什么是有参构造"><a href="#什么是有参构造" class="headerlink" title="什么是有参构造"></a>什么是有参构造</h2><p>有参构造就是传递参数的构造函数，可以根据参数构造对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JoiningThread</span>(<span class="type">int</span> i) : _i&#123;i&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过如下方式构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JoiningThread <span class="title">jt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>当我们执行程序，会输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member _i is 1</span><br></pre></td></tr></table></figure><p>但如果这样构造会产生问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JoiningThread jt;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>如果我们实现了参数构造而不实现无参构造，系统将不会为我们实现默认构造，导致无法使用默认构造生成对象。</p></blockquote><p>所以稳妥一点，我们基本都会实现无参构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JoiningThread</span>() :_i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">JoiningThread</span>(<span class="type">int</span> i) : _i&#123;i&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数是什么"><a href="#拷贝构造函数是什么" class="headerlink" title="拷贝构造函数是什么"></a><strong>拷贝构造函数是什么</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><strong>定义</strong>：拷贝构造函数用于创建一个对象，该对象是通过复制另一个同类型对象来初始化的。</p></li><li><p>调用时机</p><p>：</p><ul><li>使用现有对象初始化新对象。</li><li>按值传递对象作为函数参数。</li><li>按值返回对象。</li></ul></li><li><p><strong>默认拷贝构造函数</strong>：成员逐个拷贝。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        <span class="comment">// 复制代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="是否会默认生成拷贝构造"><a href="#是否会默认生成拷贝构造" class="headerlink" title="是否会默认生成拷贝构造"></a>是否会默认生成拷贝构造</h2><p>在 C++ 中，如果你没有为一个类显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。这个默认拷贝构造函数会按成员的逐个拷贝（member-wise copy）方式来复制对象的每个成员变量。</p><h2 id="默认拷贝构造函数的行为"><a href="#默认拷贝构造函数的行为" class="headerlink" title="默认拷贝构造函数的行为"></a>默认拷贝构造函数的行为</h2><ol><li><strong>逐个拷贝</strong>：默认拷贝构造函数会逐个拷贝所有的非静态成员变量。</li><li><strong>指针成员</strong>：如果类中有指针成员，默认拷贝构造函数只会拷贝指针的值（地址），而不会拷贝指针所指向的对象。这可能会导致多个对象指向同一块内存，进而引发问题（如双重释放、内存泄漏等）。</li><li>**<code>const</code> 和<code>引用成员</code>**：如果类中有 <code>const</code> 成员或引用成员，编译器不会生成默认的拷贝构造函数，因为这些成员不能被复制。</li><li>类中包含不可拷贝对象时，无法合成默认拷贝构造函数</li></ol><h2 id="拷贝构造是否必须实现"><a href="#拷贝构造是否必须实现" class="headerlink" title="拷贝构造是否必须实现"></a>拷贝构造是否必须实现</h2><p>当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。</p><p>比如一个类<code>JoiningThread</code>中有成员变量<code>std::thread</code>，<code>std::thread</code>没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。</p><p>比如我们这样调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JoiningThread <span class="title">jt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">JoiningThread <span class="title">jt2</span><span class="params">(jt)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>上面代码报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of deleted function <span class="string">&#x27;std::thread::thread(const std::thread&amp;)&#x27;</span></span><br></pre></td></tr></table></figure><p>所以我们要显示实现拷贝构造，指定一个拷贝规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JoiningThread</span>(<span class="type">const</span> JoiningThread &amp; other): _i(other._i)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是浅拷贝和深拷贝"><a href="#什么是浅拷贝和深拷贝" class="headerlink" title="什么是浅拷贝和深拷贝"></a>什么是浅拷贝和深拷贝</h2><p>类在拷贝构造或者拷贝赋值的时候，将被拷贝的类中的成员值拷贝到目的类，如果被拷贝的类中包含指针成员，只是简单的拷贝指针的值。</p><p>同样析构也要显示编写，等待线程完成。</p><p>除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果</p><p><img src="https://cdn.llfc.club/1731294878994.jpg" alt="https://cdn.llfc.club/1731294878994.jpg"></p><p><img src="https://cdn.llfc.club/1731295328032.jpg-llfc" alt="https://cdn.llfc.club/1731295328032.jpg-llfc"></p><h2 id="构造顺序和析构顺序"><a href="#构造顺序和析构顺序" class="headerlink" title="构造顺序和析构顺序"></a>构造顺序和析构顺序</h2><p>类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？</p><p>如果析构的时候是A先析构还是B先析构呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InnerB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InnerB</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;InnerB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">InnerB</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~InnerB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrapperC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WrapperC</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WrapperC()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">WrapperC</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~WrapperC()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    InnerB _inner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果，先调用B的构造，在调用C的构造。</p><p>析构时，先析构C再析构B</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InnerB</span>()</span><br><span class="line"><span class="built_in">WrapperC</span>()</span><br><span class="line">~<span class="built_in">WrapperC</span>()</span><br><span class="line">~<span class="built_in">InnerB</span>()</span><br></pre></td></tr></table></figure><h2 id="类默认构造是否必须实现"><a href="#类默认构造是否必须实现" class="headerlink" title="类默认构造是否必须实现"></a>类默认构造是否必须实现</h2><p>如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。</p><p>系统提供的合成的默认构造函数不会对成员做初始化操作。</p><p>比如我们之后要学到的继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>: <span class="keyword">public</span> BaseA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedA</span>(std::string name,std::string num) :</span><br><span class="line">    <span class="built_in">BaseA</span>(name), _num(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string _num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DerivedA <span class="title">a</span><span class="params">(<span class="string">&quot;zack&quot;</span>,<span class="string">&quot;1001&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="this-指针的特性和用途"><a href="#this-指针的特性和用途" class="headerlink" title="this 指针的特性和用途"></a><code>this</code> 指针的特性和用途</h2><ol><li><p><strong>指向当前对象</strong>：</p><ul><li><code>this</code> 指针是一个隐式参数，指向调用成员函数的对象。通过 <code>this</code>，你可以访问当前对象的属性和方法。</li></ul></li><li><p><strong>区分成员变量和参数</strong>：</p><ul><li><p>在构造函数或成员函数中，参数名和成员变量可能同名。使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure><p>可以明确指代成员变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>返回当前对象</strong>：</p><ul><li>```<br>this<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以用于返回当前对象的引用，以支持链式调用。例如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    MyClass&amp; setValue(int value) &#123;</span><br><span class="line">        this-&gt;value = value;</span><br><span class="line">        return *this; // 返回当前对象的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.setValue(10).setValue(20); // 链式调用</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>在 const 成员函数中的使用</strong>：</p><ul><li>在 <code>const</code> 成员函数中，<code>this</code> 的类型为 <code>const MyClass*</code>，这意味着你不能通过 <code>this</code> 修改成员变量。这有助于确保对象的状态不被改变。</li></ul></li><li><p><strong>在静态成员函数中的不可用性</strong>：</p><ul><li>静态成员函数没有 <code>this</code> 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。</li></ul></li></ol><p><strong>示例代码</strong></p><p>以下是一个简单的示例，展示了 <code>this</code> 指针的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl; <span class="comment">// 使用 this 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">printValue</span>(); <span class="comment">// 链式调用，输出: Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete和default"><a href="#delete和default" class="headerlink" title="delete和default"></a>delete和default</h2><p><code>C++11</code>用法：</p><p>delete可以删除指定的构造函数。</p><p>default可以指定某个构造函数为系统默认合成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">DefaultClass</span>(<span class="type">const</span> DefaultClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DefaultClass &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DefaultClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;out, <span class="type">const</span> DefaultClass &amp;defaultClass);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _num ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数中调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultClass b;</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出<code>num</code>是一个随机数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultClass num is 331</span><br></pre></td></tr></table></figure><h2 id="什么是移动构造函数？与拷贝构造函数有何不同？"><a href="#什么是移动构造函数？与拷贝构造函数有何不同？" class="headerlink" title="什么是移动构造函数？与拷贝构造函数有何不同？"></a><strong>什么是移动构造函数？与拷贝构造函数有何不同？</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><strong>定义</strong>：移动构造函数用于通过“移动”资源来初始化对象，而不是复制资源。</p></li><li><p><strong>语法</strong>：使用右值引用作为参数 (<code>MyClass(MyClass&amp;&amp; other)</code>).</p></li><li><p>优势</p><p>：</p><ul><li>性能更高，避免不必要的深拷贝。</li><li>适用于临时对象。</li></ul></li><li><p>区别</p><p>：</p><ul><li>拷贝构造函数复制资源，移动构造函数转移资源所有权。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        <span class="comment">// 移动资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="默认构造函数和用户定义的构造函数有什么区别？"><a href="#默认构造函数和用户定义的构造函数有什么区别？" class="headerlink" title="默认构造函数和用户定义的构造函数有什么区别？"></a><strong>默认构造函数和用户定义的构造函数有什么区别？</strong></h2><p><strong>回答要点：</strong></p><ul><li><p>默认构造函数</p><p>：</p><ul><li>无参数的构造函数。</li><li>如果没有用户定义的构造函数，编译器会自动生成一个默认构造函数。</li></ul></li><li><p>用户定义的构造函数</p><p>：</p><ul><li>开发者自定义的构造函数，可以有参数。</li><li>一旦定义了任何构造函数，编译器不会再生成默认构造函数，除非显式声明。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">// 有参数的构造函数</span></span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="什么是初始化列表？为什么在构造函数中使用它？"><a href="#什么是初始化列表？为什么在构造函数中使用它？" class="headerlink" title="什么是初始化列表？为什么在构造函数中使用它？"></a><strong>什么是初始化列表？为什么在构造函数中使用它？</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><strong>定义</strong>：初始化列表是在构造函数的参数列表之后，函数体之前，用于初始化成员变量的语法。</p></li><li><p>优点</p><p>：</p><ul><li>提高性能，特别是对于常量成员或引用成员。</li><li>必须用于初始化常量成员、引用成员以及基类。</li><li>避免对象先默认构造再赋值，减少不必要的操作。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123; <span class="comment">// 初始化列表</span></span><br><span class="line">        <span class="comment">// 其他初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="什么是虚析构函数？为什么需要它？"><a href="#什么是虚析构函数？为什么需要它？" class="headerlink" title="什么是虚析构函数？为什么需要它？"></a><strong>什么是虚析构函数？为什么需要它？</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><strong>定义</strong>：在基类中将析构函数声明为<code>virtual</code>，以确保通过基类指针删除派生类对象时，能正确调用派生类的析构函数。</p></li><li><p>用途</p><p>：</p><ul><li>防止内存泄漏。</li><li>确保派生类的资源被正确释放。</li></ul></li><li><p>不使用虚析构函数的风险</p><p>：</p><ul><li>仅调用基类析构函数，导致派生类资源未释放。</li></ul></li></ul><p><strong>示例：</strong></p><p>如果<code>BaseA</code>的析构不写成虚析构，则主函数开辟子类对象赋值给基类指针，以后<code>delete</code>基类指针的时候会发现没有析构子类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(std::string name):_name(name)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BaseA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>: <span class="keyword">public</span> BaseA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedA</span>(std::string name,std::string num) :</span><br><span class="line">    <span class="built_in">BaseA</span>(name), _num(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DerivedA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数回收内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseA* base = <span class="keyword">new</span> <span class="built_in">DerivedA</span>(<span class="string">&quot;zack&quot;</span>,<span class="string">&quot;1002&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> base;</span><br></pre></td></tr></table></figure><p>会看到只调用了基类<code>BaseA</code>的析构函数。</p><p>当BaseA的析构改为虚析构的时候，才会回收子类DerivedA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(std::string name):_name(name)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="什么是委托构造函数？它是如何工作的？（C-11引入的特性）"><a href="#什么是委托构造函数？它是如何工作的？（C-11引入的特性）" class="headerlink" title="什么是委托构造函数？它是如何工作的？（C++11引入的特性）"></a><strong>什么是委托构造函数？它是如何工作的？（C++11引入的特性）</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><strong>定义</strong>：一个构造函数可以调用同一类中的另一个构造函数，从而委托初始化任务。</p></li><li><p>优点</p><p>：</p><ul><li>避免代码重复，提升代码可维护性。</li></ul></li><li><p><strong>语法</strong>：使用构造函数初始化列表中的类名和参数。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>, <span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="什么是析构函数的顺序？"><a href="#什么是析构函数的顺序？" class="headerlink" title="什么是析构函数的顺序？"></a><strong>什么是析构函数的顺序？</strong></h2><p><strong>回答要点：</strong></p><ul><li><strong>成员变量的析构顺序</strong>：按照声明的逆序析构。</li><li><strong>继承关系的析构顺序</strong>：先析构派生类的成员和资源，再析构基类。</li><li><strong>全局/静态对象</strong>：按照创建的逆序析构。</li></ul><p><strong>示例说明：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    <span class="comment">// 当obj被销毁时，首先调用Derived的析构函数，然后调用Base的析构函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived析构</span><br><span class="line">Base析构</span><br></pre></td></tr></table></figure><hr><h2 id="如何防止对象被复制？"><a href="#如何防止对象被复制？" class="headerlink" title="如何防止对象被复制？"></a><strong>如何防止对象被复制？</strong></h2><p><strong>回答要点：</strong></p><ul><li><strong>C++11及以上</strong>：使用<code>delete</code>关键字显式删除拷贝构造函数和拷贝赋值运算符。</li><li><strong>C++11之前</strong>：将拷贝构造函数和拷贝赋值运算符声明为私有且不实现。</li></ul><p><strong>示例（C++11及以上）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数中抛出异常会发生什么？"><a href="#构造函数中抛出异常会发生什么？" class="headerlink" title="构造函数中抛出异常会发生什么？"></a><strong>构造函数中抛出异常会发生什么？</strong></h2><p><strong>回答要点：</strong></p><ul><li><strong>对象未完全构造</strong>：如果构造函数中抛出异常，析构函数不会被调用，因为对象尚未完全构造。</li><li><strong>资源泄漏风险</strong>：如果在构造函数中分配了资源，需使用RAII（资源获取即初始化）类或智能指针来确保资源被正确释放。</li><li><strong>异常安全</strong>：确保在构造函数抛出异常时，任何已经初始化的成员都会被正确析构。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        data.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;构造函数异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解释RAII及其与构造函数、析构函数的关系"><a href="#解释RAII及其与构造函数、析构函数的关系" class="headerlink" title="解释RAII及其与构造函数、析构函数的关系"></a><strong>解释<code>RAII</code>及其与构造函数、析构函数的关系</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><code>RAII</code>（资源获取即初始化）</p><p>：</p><ul><li>编程范式，通过对象的生命周期管理资源。</li><li>资源在对象构造时获取，在对象析构时释放。</li></ul></li><li><p>关系</p><p>：</p><ul><li>构造函数负责获取资源。</li><li>析构函数负责释放资源。</li></ul></li><li><p>优点</p><p>：</p><ul><li>自动管理资源，防止内存泄漏。</li><li>异常安全，确保资源在异常发生时被释放。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    FILE* file;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        file = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file) <span class="built_in">fclose</span>(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁止拷贝和移动</span></span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    FileHandler&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解释什么是赋值运算符重载？与拷贝构造函数有何不同？"><a href="#解释什么是赋值运算符重载？与拷贝构造函数有何不同？" class="headerlink" title="解释什么是赋值运算符重载？与拷贝构造函数有何不同？"></a><strong>解释什么是赋值运算符重载？与拷贝构造函数有何不同？</strong></h2><p><strong>回答要点：</strong></p><ul><li><p><strong>赋值运算符重载</strong>：通过重载<code>operator=</code>，定义对象之间的赋值行为。</p></li><li><p>区别与拷贝构造函数</p><p>：</p><ul><li>拷贝构造函数用于初始化新对象。</li><li>赋值运算符用于将一个已存在的对象赋值给另一个已存在的对象。</li></ul></li><li><p>常规实现</p><p>：</p><ul><li>检查自赋值。</li><li>释放已有资源。</li><li>复制资源。</li><li>返回<code>*this</code>。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123; <span class="comment">// 赋值运算符重载</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自赋值检查</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 复制资源</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解释静态成员变量在构造和析构中的处理"><a href="#解释静态成员变量在构造和析构中的处理" class="headerlink" title="解释静态成员变量在构造和析构中的处理"></a><strong>解释静态成员变量在构造和析构中的处理</strong></h2><p><strong>回答要点：</strong></p><ul><li><p>静态成员变量</p><p>：</p><ul><li>属于类本身，而非任何对象实例。</li><li>在程序开始时初始化，在程序结束时析构。</li></ul></li><li><p>构造顺序</p><p>：</p><ul><li>单例模式中，静态成员在第一次使用时构造。</li></ul></li><li><p>析构顺序</p><p>：</p><ul><li>按逆序构造顺序析构，确保依赖关系被正确处理。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> MyClass instance;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="string">&quot;构造\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//放在cpp中</span></span><br><span class="line">MyClass MyClass::instance; <span class="comment">// 静态成员变量定义</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造</span><br><span class="line">析构</span><br></pre></td></tr></table></figure><h2 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a><strong>虚函数原理</strong></h2><h2 id="包含虚函数的类构成"><a href="#包含虚函数的类构成" class="headerlink" title="包含虚函数的类构成"></a>包含虚函数的类构成</h2><p>参考我得另一篇文章，<a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73</a></p><h2 id="虚继承与菱形继承问题"><a href="#虚继承与菱形继承问题" class="headerlink" title="虚继承与菱形继承问题"></a><strong>虚继承与菱形继承问题</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string brand;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Device</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">brand</span>(brand_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBrand</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Brand: &quot;</span> &lt;&lt; brand &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Laptop，虚继承 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Laptop</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Tablet，虚继承 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tablet</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tablet</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Convertible</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Convertible</span> : <span class="keyword">public</span> Laptop, <span class="keyword">public</span> Tablet &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Convertible</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_), <span class="built_in">Laptop</span>(brand_), <span class="built_in">Tablet</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Convertible <span class="title">c</span><span class="params">(<span class="string">&quot;TechBrand&quot;</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">showBrand</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Brand: TechBrand</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><ul><li>在无虚继承的情况下，<code>Convertible</code> 类将拥有两份 <code>Device</code> 的成员变量，这会导致二义性问题。</li><li>通过使用虚继承（<code>virtual public</code>），确保 <code>Convertible</code> 类只有一份 <code>Device</code> 的成员。</li><li>在 <code>Convertible</code> 的构造函数中，需要明确调用基类 <code>Device</code> 的构造函数，避免二义性。</li><li>在 <code>main</code> 函数中，创建一个 <code>Convertible</code> 对象，并调用 <code>showBrand()</code> 函数，正确显示品牌名称。</li></ul><p><strong>注意事项：</strong></p><ul><li>菱形继承（多重继承导致的重复基类）可以通过虚继承来解决，确保共享同一份基类成员。</li><li>虚继承会增加一定的开销，需根据具体需求权衡使用。</li></ul><h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p><strong>概念定义</strong></p><ul><li>在 C++ 中，协变返回类型（Covariant Return Types）是一个与函数重写（Override）相关的概念。当一个派生类重写基类的虚函数时，协变返回类型允许派生类的函数返回一个从基类函数返回类型派生而来的类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base cloned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 协变返回类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived cloned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    Base* bClone = b-&gt;<span class="built_in">clone</span>(); <span class="comment">// 输出: Base cloned.</span></span><br><span class="line">    Base* dClone = d-&gt;<span class="built_in">clone</span>(); <span class="comment">// 输出: Derived cloned.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">    <span class="keyword">delete</span> bClone;</span><br><span class="line">    <span class="keyword">delete</span> dClone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base cloned.</span><br><span class="line">Derived cloned.</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><ul><li><p>基类 <code>Base</code> 定义了一个虚函数 <code>clone()</code>，返回 <code>Base*</code> 类型的指针。</p></li><li><p>派生类 <code>Derived</code> 重写了 <code>clone()</code> 函数，返回类型为 <code>Derived*</code>，这是一种协变返回类型。</p></li><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure><p>函数中，通过基类指针调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone()</span><br></pre></td></tr></table></figure><p>函数：</p><ul><li>对于 <code>Base</code> 对象，调用 <code>Base::clone()</code>。</li><li>对于 <code>Derived</code> 对象，由于虚函数机制，调用 <code>Derived::clone()</code>。</li></ul></li><li><p>协变返回类型允许派生类的重写函数返回更具体的类型，增强类型安全性和代码可读性。</p></li></ul><p><strong>注意事项：</strong></p><ul><li>协变返回类型必须满足派生类返回类型是基类返回类型的派生类。</li><li>编译器会检查协变返回类型的正确性，确保类型安全。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详细技术视频请看我的主页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://space.bilibili.com/271469206&quot;&gt;C++教程视频&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是默认构造&quot;&gt;&lt;a href=&quot;#什么是默认构造&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(20) 继承和多态</title>
    <link href="http://www.limerence2017.com/2024/11/23/cppbase20/"/>
    <id>http://www.limerence2017.com/2024/11/23/cppbase20/</id>
    <published>2024-11-23T01:44:32.000Z</published>
    <updated>2025-02-15T02:50:43.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类继承（Class-Inheritance）"><a href="#1-类继承（Class-Inheritance）" class="headerlink" title="1. 类继承（Class Inheritance）"></a>1. 类继承（Class Inheritance）</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>类继承</strong> 是面向对象编程（OOP）中的一个核心概念，允许一个类（派生类）从另一个类（基类）继承属性和行为。通过继承，派生类可以重用基类的代码，并根据需要添加新的成员或重写现有成员。</p><h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedMember;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-代码示例"><a href="#1-3-代码示例" class="headerlink" title="1.3 代码示例"></a>1.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal eats.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        age = a; <span class="comment">// 访问受保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 继承自Animal</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// Dog特有</span></span><br><span class="line"></span><br><span class="line">    myDog.<span class="built_in">setAge</span>(<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog&#x27;s age: &quot;</span> &lt;&lt; myDog.<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-执行结果"><a href="#1-4-执行结果" class="headerlink" title="1.4 执行结果"></a>1.4 执行结果</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal eats.</span><br><span class="line">Dog barks.</span><br><span class="line">Dog<span class="symbol">&#x27;s</span> age: <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="2-虚函数（Virtual-Functions）"><a href="#2-虚函数（Virtual-Functions）" class="headerlink" title="2. 虚函数（Virtual Functions）"></a>2. 虚函数（Virtual Functions）</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><strong>虚函数</strong> 允许派生类重新定义基类中的函数，以实现多态性。在运行时，根据对象的实际类型调用相应的函数版本。</p><h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(<span class="type">const</span> Shape&amp; shape)</span> </span>&#123;</span><br><span class="line">    shape.<span class="built_in">draw</span>(); <span class="comment">// 动态绑定，根据实际对象类型调用对应的draw()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c;</span><br><span class="line">    Square s;</span><br><span class="line">    Shape genericShape;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(c);           <span class="comment">// 输出: Drawing a circle.</span></span><br><span class="line">    <span class="built_in">render</span>(s);           <span class="comment">// 输出: Drawing a square.</span></span><br><span class="line">    <span class="built_in">render</span>(genericShape); <span class="comment">// 输出: Drawing a shape.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-执行结果"><a href="#2-4-执行结果" class="headerlink" title="2.4 执行结果"></a>2.4 执行结果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing <span class="selector-tag">a</span> circle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> square.</span><br><span class="line">Drawing <span class="selector-tag">a</span> shape.</span><br></pre></td></tr></table></figure><hr><h2 id="3-纯虚类与抽象基类（Pure-Virtual-Classes-and-Abstract-Base-Classes）"><a href="#3-纯虚类与抽象基类（Pure-Virtual-Classes-and-Abstract-Base-Classes）" class="headerlink" title="3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）"></a>3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>纯虚函数</strong> 是在基类中声明但不提供实现的虚函数。包含至少一个纯虚函数的类称为 <strong>抽象基类</strong>（Abstract Base Class，ABC）。抽象基类不能被实例化，要求派生类必须实现所有纯虚函数才能被实例化。</p><h3 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printm</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-代码示例"><a href="#3-3-代码示例" class="headerlink" title="3.3 代码示例"></a>3.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vehicle</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car engine started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motorcycle</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Motorcycle engine started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Vehicle v; // 错误: 不能实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    Car car;</span><br><span class="line">    Motorcycle bike;</span><br><span class="line"></span><br><span class="line">    car.<span class="built_in">startEngine</span>();     <span class="comment">// 输出: Car engine started.</span></span><br><span class="line">    bike.<span class="built_in">startEngine</span>();    <span class="comment">// 输出: Motorcycle engine started.</span></span><br><span class="line"></span><br><span class="line">    Vehicle* v1 = &amp;car;</span><br><span class="line">    Vehicle* v2 = &amp;bike;</span><br><span class="line"></span><br><span class="line">    v1-&gt;<span class="built_in">startEngine</span>(); <span class="comment">// 动态绑定，输出: Car engine started.</span></span><br><span class="line">    v2-&gt;<span class="built_in">startEngine</span>(); <span class="comment">// 动态绑定，输出: Motorcycle engine started.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-执行结果"><a href="#3-4-执行结果" class="headerlink" title="3.4 执行结果"></a>3.4 执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car engine started.</span><br><span class="line">Motorcycle engine started.</span><br><span class="line">Car engine started.</span><br><span class="line">Motorcycle engine started.</span><br></pre></td></tr></table></figure><h2 id="4-继承后的访问控制（Access-Control-in-Inheritance）"><a href="#4-继承后的访问控制（Access-Control-in-Inheritance）" class="headerlink" title="4. 继承后的访问控制（Access Control in Inheritance）"></a>4. 继承后的访问控制（Access Control in Inheritance）</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>继承时的 <strong>访问控制</strong> 决定了基类成员在派生类中的可访问性。继承方式主要有三种：<code>public</code>、<code>protected</code> 和 <code>private</code>。它们影响继承成员的访问级别。</p><h3 id="4-2-语法与影响"><a href="#4-2-语法与影响" class="headerlink" title="4.2 语法与影响"></a>4.2 语法与影响</h3><ul><li><strong>公有继承（public inheritance）</strong>：<ul><li>基类的 <code>public</code> 成员在派生类中保持 <code>public</code>。</li><li>基类的 <code>protected</code> 成员在派生类中保持 <code>protected</code>。</li><li>基类的 <code>private</code> 成员在派生类中不可访问。</li></ul></li><li><strong>保护继承（protected inheritance）</strong>：<ul><li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>protected</code>。</li></ul></li><li><strong>私有继承（private inheritance）</strong>：<ul><li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li></ul></li></ul><h3 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicMember;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedMember;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 可访问</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 可访问</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误：privateMember 在派生类中不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerived</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 转为 protected</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 转为 protected</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 转为 private</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 转为 private</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublicDerived pubDer;</span><br><span class="line">    pubDer.publicMember = <span class="number">10</span>; <span class="comment">// 可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProtectedDerived protDer;</span></span><br><span class="line">    <span class="comment">// protDer.publicMember = 10; // 错误：publicMember 在 ProtectedDerived 中为 protected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PrivateDerived privDer;</span></span><br><span class="line">    <span class="comment">// privDer.publicMember = 10; // 错误：publicMember 在 PrivateDerived 中为 private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-继承中类的作用域（Scope-of-Classes-in-Inheritance）"><a href="#5-继承中类的作用域（Scope-of-Classes-in-Inheritance）" class="headerlink" title="5. 继承中类的作用域（Scope of Classes in Inheritance）"></a>5. 继承中类的作用域（Scope of Classes in Inheritance）</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>在继承关系中，类的作用域决定了成员名称的可见性和访问方式。派生类可以访问基类的成员，根据访问控制的不同，还可能需要使用 <strong>作用域解析符</strong> 来访问隐藏的成员。</p><h3 id="5-2-代码示例"><a href="#5-2-代码示例" class="headerlink" title="5.2 代码示例"></a>5.2 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display from Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Show from Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 隐藏基类的 display</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display from Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callBaseDisplay</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">display</span>(); <span class="comment">// 使用作用域解析符调用基类的 display</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 重写 show， show 是虚函数可实现多态</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Show from Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>();          <span class="comment">// 调用 Derived::display</span></span><br><span class="line">    d.<span class="built_in">callBaseDisplay</span>();  <span class="comment">// 调用 Base::display</span></span><br><span class="line">    d.<span class="built_in">show</span>();             <span class="comment">// 调用 Derived::show</span></span><br><span class="line"></span><br><span class="line">    Base* bPtr = &amp;d;</span><br><span class="line">    bPtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Base::display，因为 display 不是虚函数</span></span><br><span class="line">    bPtr-&gt;<span class="built_in">show</span>();    <span class="comment">// show 是虚函数，调用 Derived::show；否则调用 Base::show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-执行结果"><a href="#5-3-执行结果" class="headerlink" title="5.3 执行结果"></a>5.3 执行结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Display <span class="keyword">from</span> Derived</span><br><span class="line">Display <span class="keyword">from</span> Base</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">from</span> Derived</span><br><span class="line">Display <span class="keyword">from</span> Base</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">from</span> Base <span class="operator">/</span><span class="operator">/</span> <span class="keyword">show</span> 是虚函数则输出: <span class="keyword">Show</span> <span class="keyword">from</span> Derived</span><br></pre></td></tr></table></figure><h2 id="6-构造函数与拷贝控制（Constructors-and-Copy-Control-in-Inheritance）"><a href="#6-构造函数与拷贝控制（Constructors-and-Copy-Control-in-Inheritance）" class="headerlink" title="6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）"></a>6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>在继承体系中，类的构造函数和拷贝控制函数（拷贝构造函数、拷贝赋值运算符、析构函数）的调用顺序和行为需要注意。基类的构造函数在派生类之前调用，析构函数则在派生类之后调用。</p><h3 id="6-2-构造函数的调用顺序"><a href="#6-2-构造函数的调用顺序" class="headerlink" title="6.2 构造函数的调用顺序"></a>6.2 构造函数的调用顺序</h3><ol><li>基类的 <strong>默认构造函数</strong> 首先被调用，除非派生类在初始化列表中显式调用其他基类构造函数。</li><li>派生类的成员按照声明顺序被构造。</li><li>派生类的构造函数体被执行。</li></ol><h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base parameterized constructor: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other) : <span class="built_in">name_</span>(other.name_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base copy assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            name_ = other.name_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base</span>(<span class="string">&quot;Default Derived&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value) : <span class="built_in">Base</span>(name), <span class="built_in">value_</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived parameterized constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; other) : <span class="built_in">Base</span>(other), <span class="built_in">value_</span>(other.value_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived copy assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            Base::<span class="keyword">operator</span>=(other);</span><br><span class="line">            value_ = other.value_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating d1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived d1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="string">&quot;Custom Derived&quot;</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCopy constructing d3 from d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived d3 = d2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning d1 = d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    d1 = d2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nExiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-执行结果"><a href="#6-4-执行结果" class="headerlink" title="6.4 执行结果"></a>6.4 执行结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Creating d1:</span><br><span class="line">Base parameterized constructor: <span class="keyword">Default</span> Derived</span><br><span class="line">Derived <span class="keyword">default</span> constructor</span><br><span class="line"></span><br><span class="line">Creating d2:</span><br><span class="line">Base parameterized constructor: Custom Derived</span><br><span class="line">Derived parameterized constructor: <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Copy</span> constructing d3 <span class="keyword">from</span> d2:</span><br><span class="line">Base <span class="keyword">copy</span> constructor</span><br><span class="line">Derived <span class="keyword">copy</span> constructor</span><br><span class="line"></span><br><span class="line">Assigning d1 <span class="operator">=</span> d2:</span><br><span class="line">Derived <span class="keyword">copy</span> assignment</span><br><span class="line">Base <span class="keyword">copy</span> assignment</span><br><span class="line"></span><br><span class="line">Exiting main...</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure><h2 id="7-容器与继承（Containers-and-Inheritance）"><a href="#7-容器与继承（Containers-and-Inheritance）" class="headerlink" title="7. 容器与继承（Containers and Inheritance）"></a>7. 容器与继承（Containers and Inheritance）</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p><strong>C++ 容器（如 <code>std::vector</code>、<code>std::list</code> 等）</strong> 通常存储对象的副本，而非指向对象的指针。因此，当与继承结合使用时，可能导致 <strong>切片（Object Slicing）</strong> 问题，即仅存储基类部分，丢失派生类特有的信息。为了实现多态性，推荐使用指针或智能指针存储对象。</p><h3 id="7-2-切片问题示例"><a href="#7-2-切片问题示例" class="headerlink" title="7.2 切片问题示例"></a>7.2 切片问题示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Base&gt; vec;</span><br><span class="line">    Derived d;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(d); <span class="comment">// 切片发生，派生类特有部分被丢弃</span></span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>].<span class="built_in">show</span>(); <span class="comment">// 输出: Base show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-使用指针避免切片"><a href="#7-3-使用指针避免切片" class="headerlink" title="7.3 使用指针避免切片"></a>7.3 使用指针避免切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived&gt;());</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>]-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-智能指针选择"><a href="#7-5-智能指针选择" class="headerlink" title="7.5 智能指针选择"></a>7.5 智能指针选择</h3><ul><li>**<code>std::unique_ptr</code>**：<ul><li>独占所有权，不可复制，只能移动。</li><li>适用于明确的单一所有权场景。</li></ul></li><li>**<code>std::shared_ptr</code>**：<ul><li>共享所有权，可以被多个指针共享和引用计数。</li><li>适用于需要多个所有者的场景。</li></ul></li></ul><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="1-简单继承与成员访问"><a href="#1-简单继承与成员访问" class="headerlink" title="1. 简单继承与成员访问"></a>1. 简单继承与成员访问</h3><p><strong>题目：</strong></p><p>定义一个基类 <code>Person</code>，包含以下成员：</p><ul><li><p><strong>私有成员变量</strong>：<code>name</code>（字符串类型），<code>age</code>（整数类型）</p></li><li><p>公共成员函数</p><p>：</p><ul><li>构造函数：接受姓名和年龄作为参数并初始化成员变量</li><li><code>displayInfo()</code>：打印姓名和年龄</li></ul></li></ul><p>然后，定义一个派生类 <code>Student</code>，继承自 <code>Person</code>，并添加以下内容：</p><ul><li><p><strong>私有成员变量</strong>：<code>studentID</code>（字符串类型）</p></li><li><p>公共成员函数</p><p>：</p><ul><li>构造函数：接受姓名、年龄和学号作为参数，并调用基类构造函数初始化姓名和年龄</li><li>重写 <code>displayInfo()</code>：除了显示姓名和年龄外，还显示学号</li></ul></li></ul><p><strong>要求：</strong></p><ul><li>在 <code>main</code> 函数中，创建一个 <code>Student</code> 对象，并调用 <code>displayInfo()</code> 函数展示信息。</li></ul><p><strong>示例输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Alice</span></span><br><span class="line"><span class="attr">Age:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">Student ID:</span> <span class="string">S12345</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-虚函数重写与多态性"><a href="#2-虚函数重写与多态性" class="headerlink" title="2. 虚函数重写与多态性"></a>2. 虚函数重写与多态性</h3><p><strong>题目：</strong></p><p>定义一个基类 <code>Shape</code>，包含以下内容：</p><ul><li><p>公共成员函数</p><p>：</p><ul><li>虚函数 <code>draw()</code>：在基类中实现，输出 “Drawing a generic shape.”</li></ul></li></ul><p>然后，定义两个派生类 <code>Circle</code> 和 <code>Rectangle</code>，分别重写 <code>draw()</code> 函数，实现各自的输出：</p><ul><li><code>Circle</code> 的 <code>draw()</code> 输出：”Drawing a circle.”</li><li><code>Rectangle</code> 的 <code>draw()</code> 输出：”Drawing a rectangle.”</li></ul><p><strong>要求：</strong></p><ul><li>在 <code>main</code> 函数中，创建一个 <code>Shape</code> 类型的指针数组，包含不同类型的 <code>Shape</code> 对象（<code>Circle</code> 和 <code>Rectangle</code>）。</li><li>遍历数组，调用每个对象的 <code>draw()</code> 函数，验证多态性的实现。</li></ul><p><strong>示例输出：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing <span class="selector-tag">a</span> circle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> rectangle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> generic shape.</span><br></pre></td></tr></table></figure><hr><h3 id="3-函数重载与隐藏"><a href="#3-函数重载与隐藏" class="headerlink" title="3. 函数重载与隐藏"></a>3. 函数重载与隐藏</h3><p><strong>题目：</strong></p><p>定义一个基类 <code>Calculator</code>，包含以下公共成员函数：</p><ul><li><code>int add(int a, int b)</code>：返回两个整数的和</li><li><code>double add(double a, double b)</code>：返回两个浮点数的和</li></ul><p>然后，定义一个派生类 <code>AdvancedCalculator</code>，继承自 <code>Calculator</code>，并添加以下成员函数：</p><ul><li><code>int add(int a, int b, int c)</code>：返回三个整数的和</li></ul><p><strong>要求：</strong></p><ul><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure><p>函数中，创建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdvancedCalculator</span><br></pre></td></tr></table></figure><p>对象，分别调用以下函数，并观察输出：</p><ul><li><code>add(2, 3)</code></li><li><code>add(2.5, 3.5)</code></li><li><code>add(1, 2, 3)</code></li></ul></li></ul><p><strong>注意：</strong></p><ul><li>观察派生类中新增的 <code>add</code> 函数是否影响基类中的同名函数。</li></ul><p><strong>示例输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><hr><h3 id="4-抽象类与纯虚函数"><a href="#4-抽象类与纯虚函数" class="headerlink" title="4. 抽象类与纯虚函数"></a>4. 抽象类与纯虚函数</h3><p><strong>题目：</strong></p><p>定义一个抽象基类 <code>Animal</code>，包含以下内容：</p><ul><li><p>公共纯虚函数</p><p>：</p><ul><li><code>void makeSound() const</code>：纯虚函数，用于发出动物的叫声</li></ul></li></ul><p>然后，定义两个派生类 <code>Dog</code> 和 <code>Cat</code>，分别实现 <code>makeSound()</code> 函数：</p><ul><li><code>Dog</code> 的 <code>makeSound()</code> 输出：”Woof!”</li><li><code>Cat</code> 的 <code>makeSound()</code> 输出：”Meow!”</li></ul><p><strong>要求：</strong></p><ul><li>在 <code>main</code> 函数中，创建 <code>Dog</code> 和 <code>Cat</code> 对象的基类指针，并调用 <code>makeSound()</code> 函数，展示多态性。</li></ul><p><strong>示例输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Woof!</span><br><span class="line">Meow!</span><br></pre></td></tr></table></figure><hr><h3 id="5-构造函数与析构函数的继承"><a href="#5-构造函数与析构函数的继承" class="headerlink" title="5. 构造函数与析构函数的继承"></a>5. 构造函数与析构函数的继承</h3><p><strong>题目：</strong></p><p>定义一个基类 <code>Vehicle</code>，包含以下内容：</p><ul><li><p>公共成员函数</p><p>：</p><ul><li>构造函数：输出 “Vehicle constructed.”</li><li>析构函数：输出 “Vehicle destructed.”</li></ul></li></ul><p>然后，定义一个派生类 <code>Car</code>，继承自 <code>Vehicle</code>，并添加以下内容：</p><ul><li><p>公共成员函数</p><p>：</p><ul><li>构造函数：输出 “Car constructed.”</li><li>析构函数：输出 “Car destructed.”</li></ul></li></ul><p><strong>要求：</strong></p><ul><li>在 <code>main</code> 函数中，创建一个 <code>Car</code> 对象，并观察构造和析构的调用顺序。</li></ul><p><strong>示例输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vehicle constructed.</span><br><span class="line">Car constructed.</span><br><span class="line">Car destructed.</span><br><span class="line">Vehicle destructed.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-类继承（Class-Inheritance）&quot;&gt;&lt;a href=&quot;#1-类继承（Class-Inheritance）&quot; class=&quot;headerlink&quot; title=&quot;1. 类继承（Class Inheritance）&quot;&gt;&lt;/a&gt;1. 类继承（Class </summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(19) 类基础用法</title>
    <link href="http://www.limerence2017.com/2024/11/09/cppbase19/"/>
    <id>http://www.limerence2017.com/2024/11/09/cppbase19/</id>
    <published>2024-11-09T12:58:32.000Z</published>
    <updated>2025-02-15T02:50:39.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类与对象简介"><a href="#1-类与对象简介" class="headerlink" title="1. 类与对象简介"></a>1. 类与对象简介</h2><h3 id="1-1-什么是类和对象"><a href="#1-1-什么是类和对象" class="headerlink" title="1.1 什么是类和对象"></a>1.1 什么是类和对象</h3><ul><li><strong>类（Class）</strong>是C++中创建用户自定义类型的一种方式，它将数据（成员变量）和操作数据的函数（成员函数）封装在一起。</li><li><strong>对象（Object）</strong>是类的实例化，拥有类定义的所有属性和行为。</li><li><strong>类</strong>更像是汽车图纸，<strong>对象</strong>更像是造出来的汽车。</li></ul><h3 id="1-2-类的作用"><a href="#1-2-类的作用" class="headerlink" title="1.2 类的作用"></a>1.2 类的作用</h3><ul><li><strong>封装（Encapsulation）</strong>：将数据和操作数据的代码绑定在一起，保护数据不被外界直接访问。</li><li><strong>抽象（Abstraction）</strong>：通过类定义抽象出具有共同特性的对象，提高代码的可重用性和可维护性。</li><li><strong>继承（Inheritance）和多态（Polymorphism）</strong>：实现代码的复用与动态绑定。</li></ul><hr><h2 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 受保护成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>创建一个表示学生的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-成员变量与成员函数"><a href="#3-成员变量与成员函数" class="headerlink" title="3. 成员变量与成员函数"></a>3. 成员变量与成员函数</h2><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><ul><li><strong>成员变量（Member Variables）</strong>：用于存储对象的状态信息。</li><li><strong>命名约定</strong>：常用下划线结尾（例如 <code>name_</code>）表示成员变量，避免与局部变量混淆。</li></ul><h3 id="3-2-成员函数"><a href="#3-2-成员函数" class="headerlink" title="3.2 成员函数"></a>3.2 成员函数</h3><ul><li><strong>成员函数（Member Functions）</strong>：定义对象的行为，可以访问和修改成员变量。</li><li><strong>常成员函数（Const Member Functions）</strong>：保证函数不会修改对象的状态。</li></ul><h3 id="3-3-示例实现"><a href="#3-3-示例实现" class="headerlink" title="3.3 示例实现"></a>3.3 示例实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age)</span><br><span class="line">    : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    name_ = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">0</span>)</span><br><span class="line">        age_ = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4. 访问控制"></a>4. 访问控制</h2><h3 id="4-1-访问修饰符"><a href="#4-1-访问修饰符" class="headerlink" title="4.1 访问修饰符"></a>4.1 访问修饰符</h3><ul><li><strong>public</strong>：公有成员，可以被所有代码访问。</li><li><strong>private</strong>：私有成员，仅能被类的成员函数和友元访问。</li><li><strong>protected</strong>：受保护成员，仅能被类的成员函数、友元和派生类访问。</li></ul><h3 id="4-2-例子"><a href="#4-2-例子" class="headerlink" title="4.2 例子"></a>4.2 例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-构造函数与析构函数"><a href="#5-构造函数与析构函数" class="headerlink" title="5. 构造函数与析构函数"></a>5. 构造函数与析构函数</h2><h3 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h3><ul><li><strong>默认构造函数</strong>：没有参数的构造函数。</li><li><strong>参数化构造函数</strong>：接受参数以初始化对象。</li><li><strong>拷贝构造函数</strong>：用一个对象初始化另一个对象。</li><li><strong>移动构造函数（C++11）</strong>：从临时对象“移动”资源。</li></ul><h3 id="5-2-析构函数"><a href="#5-2-析构函数" class="headerlink" title="5.2 析构函数"></a>5.2 析构函数</h3><ul><li><strong>析构函数（Destructor）</strong>：在对象生命周期结束时调用，用于释放资源。</li></ul><h3 id="5-3-示例"><a href="#5-3-示例" class="headerlink" title="5.3 示例"></a>5.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>() : <span class="built_in">data_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> data) : <span class="built_in">data_</span>(data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called with data = &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other) : <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(Example&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.data_ = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for data = &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-4-使用示例"><a href="#5-4-使用示例" class="headerlink" title="5.4 使用示例"></a>5.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example ex1;               <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">Example <span class="title">ex2</span><span class="params">(<span class="number">42</span>)</span></span>;           <span class="comment">// 调用参数化构造函数</span></span><br><span class="line">    Example ex3 = ex2;         <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example ex4 = std::<span class="built_in">move</span>(ex2); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Default <span class="keyword">constructor</span> called.</span><br><span class="line">Parameterized <span class="keyword">constructor</span> called with <span class="keyword">data</span> = <span class="number">42.</span></span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">0.</span></span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">42.</span></span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">42.</span></span><br></pre></td></tr></table></figure><h3 id="5-5-拷贝构造是否必须实现"><a href="#5-5-拷贝构造是否必须实现" class="headerlink" title="5.5 拷贝构造是否必须实现"></a>5.5 拷贝构造是否必须实现</h3><p>当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。比如一个类A中有成员变量<code>std::thread</code>，<code>std::thread</code>没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。</p><p>同样析构也要显示编写，等待线程完成。</p><p>除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果</p><p><img src="https://cdn.llfc.club/1731294878994.jpg" alt="https://cdn.llfc.club/1731294878994.jpg"></p><p><img src="https://cdn.llfc.club/1731295328032.jpg-llfc" alt="https://cdn.llfc.club/1731295328032.jpg-llfc"></p><h3 id="5-6-构造顺序和析构顺序"><a href="#5-6-构造顺序和析构顺序" class="headerlink" title="5.6 构造顺序和析构顺序"></a>5.6 构造顺序和析构顺序</h3><p>类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？</p><p>如果析构的时候是A先析构还是B先析构呢？</p><h3 id="5-7-类默认构造是否必须实现"><a href="#5-7-类默认构造是否必须实现" class="headerlink" title="5.7 类默认构造是否必须实现"></a>5.7 类默认构造是否必须实现</h3><p>如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。</p><p>系统提供的合成的默认构造函数不会对成员做初始化操作。</p><h3 id="5-8-this-指针的特性和用途"><a href="#5-8-this-指针的特性和用途" class="headerlink" title="5.8 this 指针的特性和用途"></a>5.8 <code>this</code> 指针的特性和用途</h3><ol><li><p><strong>指向当前对象</strong>：</p><ul><li><code>this</code> 指针是一个隐式参数，指向调用成员函数的对象。通过 <code>this</code>，你可以访问当前对象的属性和方法。</li></ul></li><li><p><strong>区分成员变量和参数</strong>：</p><ul><li><p>在构造函数或成员函数中，参数名和成员变量可能同名。使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure><p>可以明确指代成员变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>返回当前对象</strong>：</p><ul><li>```<br>this<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以用于返回当前对象的引用，以支持链式调用。例如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    MyClass&amp; setValue(int value) &#123;</span><br><span class="line">        this-&gt;value = value;</span><br><span class="line">        return *this; // 返回当前对象的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.setValue(10).setValue(20); // 链式调用</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>在 const 成员函数中的使用</strong>：</p><ul><li>在 <code>const</code> 成员函数中，<code>this</code> 的类型为 <code>const MyClass*</code>，这意味着你不能通过 <code>this</code> 修改成员变量。这有助于确保对象的状态不被改变。</li></ul></li><li><p><strong>在静态成员函数中的不可用性</strong>：</p><ul><li>静态成员函数没有 <code>this</code> 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。</li></ul></li></ol><p><strong>示例代码</strong></p><p>以下是一个简单的示例，展示了 <code>this</code> 指针的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl; <span class="comment">// 使用 this 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">printValue</span>(); <span class="comment">// 链式调用，输出: Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-9-delete和default"><a href="#5-9-delete和default" class="headerlink" title="5.9 delete和default"></a>5.9 delete和default</h3><p><code>C++11</code>用法：</p><p>delete可以删除指定的构造函数。</p><p>default可以指定某个构造函数为系统默认合成。</p><h2 id="6-拷贝控制"><a href="#6-拷贝控制" class="headerlink" title="6. 拷贝控制"></a>6. 拷贝控制</h2><p><strong>拷贝构造函数与拷贝赋值运算符</strong></p><h3 id="6-1-拷贝构造函数"><a href="#6-1-拷贝构造函数" class="headerlink" title="6.1 拷贝构造函数"></a>6.1 拷贝构造函数</h3><ul><li><strong>定义</strong>：用于创建一个新对象，并复制现有对象的成员。</li><li><strong>语法</strong>：<code>ClassName(const ClassName&amp; other);</code></li></ul><h3 id="6-2-拷贝赋值运算符"><a href="#6-2-拷贝赋值运算符" class="headerlink" title="6.2 拷贝赋值运算符"></a>6.2 拷贝赋值运算符</h3><ul><li><strong>定义</strong>：用于将一个已有对象的值赋给另一个已有对象。</li><li><strong>语法</strong>：<code>ClassName&amp; operator=(const ClassName&amp; other);</code></li></ul><h3 id="6-3-示例"><a href="#6-3-示例" class="headerlink" title="6.3 示例"></a>6.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            size_ = std::<span class="built_in">strlen</span>(str);</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">            std::<span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size_ = <span class="number">0</span>;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) : <span class="built_in">size_</span>(other.size_) &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自赋值检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_; <span class="comment">// 释放现有资源</span></span><br><span class="line"></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    std::<span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-4-使用示例"><a href="#6-4-使用示例" class="headerlink" title="6.4 使用示例"></a>6.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = s1;        <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    MyString s3;</span><br><span class="line">    s3 = s1;                  <span class="comment">// 调用拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s3.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constructor called.</span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Constructor called.</span><br><span class="line">Copy assignment <span class="keyword">operator</span> called.</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure><h2 id="7-移动语义"><a href="#7-移动语义" class="headerlink" title="7. 移动语义"></a>7. 移动语义</h2><h3 id="7-1-什么是移动语义"><a href="#7-1-什么是移动语义" class="headerlink" title="7.1 什么是移动语义"></a>7.1 什么是移动语义</h3><ul><li><strong>移动语义（Move Semantics）</strong>：允许资源的所有权从一个对象转移到另一个对象，避免不必要的拷贝，提高性能。</li></ul><h3 id="7-2-移动构造函数与移动赋值运算符"><a href="#7-2-移动构造函数与移动赋值运算符" class="headerlink" title="7.2 移动构造函数与移动赋值运算符"></a>7.2 移动构造函数与移动赋值运算符</h3><ul><li><strong>移动构造函数</strong>：<code>ClassName(ClassName&amp;&amp; other) noexcept;</code></li><li><strong>移动赋值运算符</strong>：<code>ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept;</code></li></ul><h3 id="7-3-示例"><a href="#7-3-示例" class="headerlink" title="7.3 示例"></a>7.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(<span class="type">const</span> MoveExample&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(MoveExample&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MoveExample&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MoveExample&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MoveExample&amp; <span class="keyword">operator</span>=(MoveExample&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MoveExample</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-4-使用示例"><a href="#7-4-使用示例" class="headerlink" title="7.4 使用示例"></a>7.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MoveExample <span class="title">ex1</span><span class="params">(<span class="number">100</span>)</span></span>;                 <span class="comment">// Constructor</span></span><br><span class="line">    MoveExample ex2 = ex1;                <span class="comment">// Copy Constructor</span></span><br><span class="line">    MoveExample ex3 = <span class="built_in">MoveExample</span>(<span class="number">200</span>);   <span class="comment">// Move Constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MoveExample <span class="title">ex4</span><span class="params">(<span class="number">300</span>)</span></span>;</span><br><span class="line">    ex4 = ex1;                             <span class="comment">// Copy Assignment</span></span><br><span class="line">    ex4 = <span class="built_in">MoveExample</span>(<span class="number">400</span>);                <span class="comment">// Move Assignment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Constructor called.</span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Constructor called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Destructor called.</span><br><span class="line">Constructor called.</span><br><span class="line">Copy assignment <span class="keyword">operator</span> called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Move assignment <span class="keyword">operator</span> called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure><hr><h2 id="8-类的友元"><a href="#8-类的友元" class="headerlink" title="8. 类的友元"></a>8. 类的友元</h2><h3 id="8-1-什么是友元"><a href="#8-1-什么是友元" class="headerlink" title="8.1 什么是友元"></a>8.1 什么是友元</h3><ul><li><strong>友元（Friend）</strong>：可以访问类的私有和保护成员的非成员函数或另一个类。</li></ul><h3 id="8-2-类型"><a href="#8-2-类型" class="headerlink" title="8.2 类型"></a>8.2 类型</h3><ul><li><strong>友元函数</strong>：单个函数可以被声明为友元。</li><li><strong>友元类</strong>：整个类可以被声明为友元。</li></ul><h3 id="8-3-使用示例"><a href="#8-3-使用示例" class="headerlink" title="8.3 使用示例"></a>8.3 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> length, <span class="type">double</span> width, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">length_</span>(length), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span> <span class="title">calculateVolume</span><span class="params">(<span class="type">const</span> Box&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length_;</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">(<span class="type">const</span> Box&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.length_ * b.width_ * b.height_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-使用友元类"><a href="#8-4-使用友元类" class="headerlink" title="8.4 使用友元类"></a>8.4 使用友元类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height) : <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AreaCalculator</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">const</span> Rectangle&amp; rect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rect.width_ * rect.height_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="9-运算符重载"><a href="#9-运算符重载" class="headerlink" title="9. 运算符重载"></a>9. 运算符重载</h2><h3 id="9-1-什么是运算符重载"><a href="#9-1-什么是运算符重载" class="headerlink" title="9.1 什么是运算符重载"></a>9.1 什么是运算符重载</h3><ul><li><strong>运算符重载（Operator Overloading）</strong>：允许对自定义类型使用C++运算符，如 <code>+</code>, <code>-</code>, <code>&lt;&lt;</code> 等。</li></ul><h3 id="9-2-重载运算符的规则"><a href="#9-2-重载运算符的规则" class="headerlink" title="9.2 重载运算符的规则"></a>9.2 重载运算符的规则</h3><ul><li>只能对已有运算符进行重载，不能创建新运算符。</li><li>至少有一个操作数必须是用户定义的类型。</li><li>不能改变运算符的优先级或结合性。</li></ul><h3 id="9-3-示例：重载-运算符"><a href="#9-3-示例：重载-运算符" class="headerlink" title="9.3 示例：重载 + 运算符"></a>9.3 示例：重载 <code>+</code> 运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数重载 +</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x_ + other.x_, y_ + other.y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x_ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y_ &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用友元函数重载 +</span></span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x_ - b.x_, a.y_ - b.y_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1.5</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出： (4.5, 6.5)</span></span><br><span class="line"></span><br><span class="line">    Point p4 = p2 - p1;</span><br><span class="line">    p4.<span class="built_in">print</span>(); <span class="comment">// 输出： (1.5, 1.5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-示例：重载-lt-lt-运算符（输出流）"><a href="#9-4-示例：重载-lt-lt-运算符（输出流）" class="headerlink" title="9.4 示例：重载 &lt;&lt; 运算符（输出流）"></a>9.4 示例：重载 <code>&lt;&lt;</code> 运算符（输出流）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; name, <span class="type">double</span> salary)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">salary_</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数以重载 &lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Employee&amp; emp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">double</span> salary_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的 &lt;&lt;</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Employee&amp; emp) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Employee Name: &quot;</span> &lt;&lt; emp.name_ &lt;&lt; <span class="string">&quot;, Salary: $&quot;</span> &lt;&lt; emp.salary_;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">emp</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">75000</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; emp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Employee Name:</span> <span class="string">John</span> <span class="string">Doe,</span> <span class="attr">Salary:</span> <span class="string">$75000</span></span><br></pre></td></tr></table></figure><h2 id="10-练习示例"><a href="#10-练习示例" class="headerlink" title="10. 练习示例"></a>10. 练习示例</h2><h3 id="项目：实现自定义MyString类"><a href="#项目：实现自定义MyString类" class="headerlink" title="项目：实现自定义MyString类"></a>项目：实现自定义<code>MyString</code>类</h3><p><strong>目标</strong>：创建一个简单的<code>MyString</code>类，支持拷贝构造，默认构造，有参构造，支持输出和比较等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;  <span class="comment">// 动态分配的字符数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]; <span class="comment">// +1 for the null terminator</span></span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.data) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data; <span class="comment">// 释放原有内存</span></span><br><span class="line">            <span class="keyword">if</span> (other.data) &#123;</span><br><span class="line">                data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较运算符重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span> &amp;&amp; other.data == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span> || other.data == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(data, other.data) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyString&amp; myStr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myStr.data) &#123;</span><br><span class="line">            os &lt;&lt; myStr.data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    MyString str2 = str1; <span class="comment">// 拷贝构造</span></span><br><span class="line">    MyString str3;</span><br><span class="line"></span><br><span class="line">    str3 = str1; <span class="comment">// 赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3: &quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li><strong>私有成员</strong>：<ul><li><code>char* data</code>：指向动态分配的字符数组，用于存储字符串。</li></ul></li><li><strong>构造函数</strong>：<ul><li><strong>默认构造函数</strong>：初始化 <code>data</code> 为 <code>nullptr</code>。</li><li><strong>有参构造函数</strong>：接收一个 <code>const char*</code> 类型的字符串，动态分配内存并复制字符串内容。</li><li><strong>拷贝构造函数</strong>：复制另一个 <code>MyString</code> 对象的内容，确保深拷贝。</li></ul></li><li><strong>赋值运算符重载</strong>：支持将一个 <code>MyString</code> 对象赋值给另一个，确保释放原有内存并进行深拷贝。</li><li><strong>比较运算符重载</strong>：支持比较两个 <code>MyString</code> 对象是否相等。</li><li><strong>输出运算符重载</strong>：支持直接使用 <code>std::cout</code> 输出 <code>MyString</code> 对象。</li><li><strong>析构函数</strong>：释放动态分配的内存，防止内存泄漏。</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在 <code>main</code> 函数中，创建了几个 <code>MyString</code> 对象，演示了拷贝构造、赋值和比较的用法。</p><h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p>关于C++的视频教程可参考我的主页</p><p><a href="https://space.bilibili.com/271469206">C++教程视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-类与对象简介&quot;&gt;&lt;a href=&quot;#1-类与对象简介&quot; class=&quot;headerlink&quot; title=&quot;1. 类与对象简介&quot;&gt;&lt;/a&gt;1. 类与对象简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是类和对象&quot;&gt;&lt;a href=&quot;#1-1-什么是类和对象&quot; cla</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(18) 函数用法</title>
    <link href="http://www.limerence2017.com/2024/11/03/cppbase18/"/>
    <id>http://www.limerence2017.com/2024/11/03/cppbase18/</id>
    <published>2024-11-03T03:41:04.000Z</published>
    <updated>2025-02-15T02:50:36.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-函数简介"><a href="#1-函数简介" class="headerlink" title="1. 函数简介"></a>1. 函数简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数是执行特定任务的代码块，可以被程序中的多个地方调用。使用函数可以增加代码的可重用性、可读性和可维护性。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><strong>封装</strong>：将特定功能封装在函数中，便于管理和修改。</li><li><strong>复用</strong>：同一段功能代码可以在程序中多次调用，减少代码重复。</li><li><strong>结构化</strong>：通过函数组织代码，提高程序的结构清晰度。</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 + 3 = 8</span><br></pre></td></tr></table></figure><hr><h2 id="2-函数的声明与定义"><a href="#2-函数的声明与定义" class="headerlink" title="2. 函数的声明与定义"></a>2. 函数的声明与定义</h2><h3 id="函数声明（Function-Declaration）"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h3><p>告诉编译器函数的名称、返回类型和参数类型，但不包含函数体。通常放在头文件中或在使用函数前进行声明。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure><h3 id="函数定义（Function-Definition）"><a href="#函数定义（Function-Definition）" class="headerlink" title="函数定义（Function Definition）"></a>函数定义（Function Definition）</h3><p>提供函数的具体实现，包括函数体。函数定义可以在源文件中或与声明一起在头文件中出现（推荐仅声明在头文件中）。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 函数定义</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数分离编译"><a href="#函数分离编译" class="headerlink" title="函数分离编译"></a>函数分离编译</h3><ul><li><strong>声明</strong>：放在头文件（如 <code>multiply.h</code>）。</li><li><strong>定义</strong>：放在源文件（如 <code>multiply.cpp</code>）。</li></ul><p><strong>multiply.h</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MULTIPLY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIPLY_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>multiply.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiply.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiply.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multiply</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4 * 6 = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令</strong>（假设使用g++）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp multiply.cpp -o program</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 * 6 = 24</span><br></pre></td></tr></table></figure><hr><h2 id="3-函数调用"><a href="#3-函数调用" class="headerlink" title="3. 函数调用"></a>3. 函数调用</h2><h3 id="基本调用"><a href="#基本调用" class="headerlink" title="基本调用"></a>基本调用</h3><p>通过函数名称和必要的参数来调用函数。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p>同一函数可以在程序中被调用多次。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><hr><h2 id="4-参数传递机制"><a href="#4-参数传递机制" class="headerlink" title="4. 参数传递机制"></a>4. 参数传递机制</h2><p>C++中函数参数的传递方式主要有以下三种：</p><ol><li><strong>传值调用（Pass by Value）</strong></li><li><strong>传引用调用（Pass by Reference）</strong></li><li><strong>传指针调用（Pass by Pointer）</strong></li></ol><h3 id="传值调用"><a href="#传值调用" class="headerlink" title="传值调用"></a>传值调用</h3><p><strong>定义</strong>：函数接收参数的副本，函数内对参数的修改不会影响原始数据。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 只修改副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 50</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>changeValue</code>函数修改的是<code>num</code>的副本，原始变量<code>value</code>保持不变。</p><h3 id="传引用调用"><a href="#传引用调用" class="headerlink" title="传引用调用"></a>传引用调用</h3><p><strong>定义</strong>：函数接收参数的引用，函数内对参数的修改会影响原始数据。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 修改原始数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 100</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>changeValue</code>函数通过引用修改了原始变量<code>value</code>的值。</p><h3 id="传指针调用"><a href="#传指针调用" class="headerlink" title="传指针调用"></a>传指针调用</h3><p><strong>定义</strong>：函数接收指向参数的指针，函数内通过指针可以修改原始数据。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>; <span class="comment">// 修改原始数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> *num)</span> </span>&#123;</span><br><span class="line">    *num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(&amp;value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 100</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>changeValue</code>函数通过指针修改了原始变量<code>value</code>的值。</p><h3 id="选择合适的传递方式"><a href="#选择合适的传递方式" class="headerlink" title="选择合适的传递方式"></a>选择合适的传递方式</h3><ul><li><strong>传值调用</strong>：适用于不需要修改原始数据且数据量较小的情况。</li><li><strong>传引用调用</strong>：适用于需要修改原始数据或传递大型数据结构以提高效率。</li><li><strong>传指针调用</strong>：类似传引用调用，但更灵活，可用于传递<code>nullptr</code>或指向动态分配的内存。</li></ul><hr><h2 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h2><p>函数可以通过<code>return</code>语句将结果返回给调用者。返回值的类型可以是基本数据类型、引用、指针、对象等。</p><h3 id="5-1-返回基本数据类型"><a href="#5-1-返回基本数据类型" class="headerlink" title="5.1 返回基本数据类型"></a>5.1 返回基本数据类型</h3><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Sum: 7</span></span><br></pre></td></tr></table></figure><h3 id="5-2-返回引用"><a href="#5-2-返回引用" class="headerlink" title="5.2 返回引用"></a>5.2 返回引用</h3><p><strong>注意</strong>：返回引用需要确保引用的对象在返回后依然有效（避免悬垂引用）。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;max = <span class="built_in">getMax</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max: &quot;</span> &lt;&lt; max &lt;&lt; std::endl;</span><br><span class="line">    max = <span class="number">30</span>; <span class="comment">// 修改引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Max:</span> <span class="number">20</span></span><br><span class="line"><span class="string">After</span> <span class="string">modification,</span> <span class="attr">y:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>getMax</code>函数返回较大的变量的引用，修改<code>max</code>实际上修改了<code>y</code>。</p><h3 id="5-3-返回指针"><a href="#5-3-返回指针" class="headerlink" title="5.3 返回指针"></a>5.3 返回指针</h3><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">allocateArray</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        arr[i] = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>* myArray = <span class="built_in">allocateArray</span>(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        std::cout &lt;&lt; myArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] myArray; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 4 6 8 </span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>allocateArray</code>函数动态分配一个数组并返回指向数组的指针。调用者需负责释放内存。</p><h3 id="5-4-返回对象"><a href="#5-4-返回对象" class="headerlink" title="5.4 返回对象"></a>5.4 返回对象</h3><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">createPerson</span><span class="params">(std::string name, <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(name, age)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="built_in">createPerson</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Alice,</span> <span class="attr">Age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>createPerson</code>函数返回一个<code>Person</code>对象。现代编译器通过返回值优化（RVO）减少对象拷贝，提高效率。</p><hr><h2 id="6-函数重载"><a href="#6-函数重载" class="headerlink" title="6. 函数重载"></a>6. 函数重载</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>函数重载允许在同一个作用域内定义多个名称相同但参数列表不同的函数。编译器通过参数列表的不同来区分调用哪个函数。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>函数名相同。</li><li>参数列表（类型、数量或顺序）不同。</li><li>返回类型不参与重载的区分。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：不同参数数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：不同参数类型</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2, 3) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2, 3, 4) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2.5, 3.5) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">5</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) = <span class="number">9</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) = <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>仅返回类型不同的重载是非法的。</li><li>默认参数可能会与重载产生冲突，使用时需谨慎。</li></ul><p><strong>非法示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冲突重载，仅返回类型不同</span></span><br><span class="line"><span class="comment">// 会导致编译错误</span></span><br><span class="line"><span class="comment">// double add(int a, int b);</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-默认参数"><a href="#7-默认参数" class="headerlink" title="7. 默认参数"></a>7. 默认参数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>函数参数可以指定默认值，调用函数时可以省略这些参数，默认值将被使用。</p><h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><ul><li>默认参数从右到左设置，不能部分设置。</li><li>函数声明和定义中默认参数只需在声明中指定。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明时指定默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(std::string name, <span class="type">int</span> age = <span class="number">18</span>, std::string city = <span class="string">&quot;Unknown&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>, <span class="string">&quot;New York&quot;</span>); <span class="comment">// 全部参数传递</span></span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>);         <span class="comment">// 省略city</span></span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Diana&quot;</span>);               <span class="comment">// 省略age和city</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(std::string name, <span class="type">int</span> age, std::string city)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, City: &quot;</span> &lt;&lt; city &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Bob,</span> <span class="attr">Age:</span> <span class="number">25</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">New</span> <span class="string">York</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">Charlie,</span> <span class="attr">Age:</span> <span class="number">30</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">Unknown</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">Diana,</span> <span class="attr">Age:</span> <span class="number">18</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">Unknown</span></span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>默认参数必须从右端开始，不能跳过中间参数。</li><li>如果同时使用默认参数和重载，可能会产生歧义，需谨慎设计。</li></ul><hr><h2 id="8-内联函数"><a href="#8-内联函数" class="headerlink" title="8. 内联函数"></a>8. 内联函数</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>内联函数通过在函数前加<code>inline</code>关键字，建议编译器将函数代码嵌入到调用处，减少函数调用的开销。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于函数体积小、调用频繁的函数，如访问器（getter）和修改器（setter）等。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square of 5: &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Square of <span class="number">5</span>: <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>减少函数调用的开销（如栈操作）。</li><li>可能提高程序性能。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>使得代码体积增大，可能影响缓存性能。</li><li>编译器可能忽略内联请求，特别是对于复杂函数。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>编译器对<code>inline</code>关键字的处理是建议性质，最终是否内联由编译器决定。</li><li>过度使用内联函数可能导致代码膨胀。</li></ul><hr><h2 id="9-递归函数"><a href="#9-递归函数" class="headerlink" title="9. 递归函数"></a>9. 递归函数</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>递归函数是指在函数体内调用自身的函数。递归通常用于解决可以分解为相似子问题的问题，如阶乘、斐波那契数列、树的遍历等。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>递归函数通常包含两个部分：</p><ol><li><strong>基准情形（Base Case）</strong>：直接返回结果，避免无限递归。</li><li><strong>递归情形（Recursive Case）</strong>：将问题分解为更小的子问题并调用自身。</li></ol><h3 id="示例：计算阶乘"><a href="#示例：计算阶乘" class="headerlink" title="示例：计算阶乘"></a>示例：计算阶乘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误情况</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基准情形</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); <span class="comment">// 递归情形</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">factorial</span>(number);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid input!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br></pre></td></tr></table></figure><h3 id="示例：斐波那契数列"><a href="#示例：斐波那契数列" class="headerlink" title="示例：斐波那契数列"></a>示例：斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> term = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(term) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10) = 55</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>基准情形</strong>：必须正确设置，避免无限递归导致栈溢出（Stack Overflow）。</li><li><strong>效率问题</strong>：一些递归实现可能效率低下（如斐波那契数列），可以通过“记忆化”或改用迭代方法优化。</li><li><strong>堆栈深度</strong>：递归深度过大可能导致栈溢出，需避免深度递归。</li></ul><h3 id="递归优化：尾递归"><a href="#递归优化：尾递归" class="headerlink" title="递归优化：尾递归"></a>递归优化：尾递归</h3><p>尾递归是指递归调用在函数的最后一步，可以被编译器优化为循环，减少堆栈消耗。</p><p><strong>示例：尾递归阶乘</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于尾递归</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorialHelper</span><span class="params">(<span class="type">int</span> n, <span class="type">long</span> <span class="type">long</span> accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorialHelper</span>(n - <span class="number">1</span>, n * accumulator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorialHelper</span>(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(number) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>factorialHelper</code>函数的递归调用是函数的最后一步，编译器可以将其优化为迭代，减少堆栈消耗。</p><hr><h2 id="10-Lambda表达式"><a href="#10-Lambda表达式" class="headerlink" title="10. Lambda表达式"></a>10. Lambda表达式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>Lambda表达式是C++11引入的匿名函数，便于在需要函数对象的地方快速定义和使用函数。它允许定义内联的、小型的可调用对象，无需单独定义函数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ capture_list ] ( parameter_list ) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式打印每个元素</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式计算总和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> x) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line"><span class="section">Sum: 15</span></span><br></pre></td></tr></table></figure><h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ol><li><strong>捕获列表（Capture List）</strong>：指定如何访问外部变量。<ul><li><code>[ ]</code>：不捕获任何外部变量。</li><li><code>[&amp;]</code>：按引用捕获所有外部变量。</li><li><code>[=]</code>：按值捕获所有外部变量。</li><li><code>[x, &amp;y]</code>：按值捕获<code>x</code>，按引用捕获<code>y</code>。</li></ul></li><li><strong>参数列表（Parameter List）</strong>：类似普通函数的参数列表，可以省略类型（C++14及以上支持自动类型推断）。</li><li><strong>返回类型（Return Type）</strong>：可指定返回类型，也可省略，编译器自动推断。</li><li><strong>函数体（Function Body）</strong>：Lambda的具体实现。</li></ol><h3 id="高级示例：捕获并排序"><a href="#高级示例：捕获并排序" class="headerlink" title="高级示例：捕获并排序"></a>高级示例：捕获并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按降序排序，使用Lambda表达式</span></span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted data: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data)</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorted <span class="keyword">data</span>: <span class="number">9</span> <span class="number">6</span> <span class="number">5</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="使用Lambda表达式与标准库"><a href="#使用Lambda表达式与标准库" class="headerlink" title="使用Lambda表达式与标准库"></a>使用Lambda表达式与标准库</h3><p>C++标准库中的许多算法（如<code>std::for_each</code>、<code>std::sort</code>、<code>std::transform</code>等）常用Lambda表达式作为参数，以实现自定义的操作。</p><hr><h2 id="11-函数指针与回调函数"><a href="#11-函数指针与回调函数" class="headerlink" title="11. 函数指针与回调函数"></a>11. 函数指针与回调函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p><strong>定义</strong>：指向函数的指针变量，保存函数的地址，可以通过指针调用函数。</p><h3 id="声明与使用"><a href="#声明与使用" class="headerlink" title="声明与使用"></a>声明与使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from greet!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*funcPtr)() = greet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用函数</span></span><br><span class="line">    <span class="built_in">funcPtr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello <span class="keyword">from</span> greet!</span><br></pre></td></tr></table></figure><h3 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h3><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数，接受函数指针作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">void</span> (*func)())</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 调用传入的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hi!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">execute</span>(sayHi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi!</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>定义</strong>：通过函数指针传递的函数，通常用于在特定事件发生时执行自定义操作。</p><p><strong>示例</strong>：基于函数指针的回调</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接收回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">cb</span>(); <span class="comment">// 执行回调</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Callback executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">registerCallback</span>(myCallback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before callback</span><br><span class="line">Callback executed!</span><br><span class="line">After callback</span><br></pre></td></tr></table></figure><h3 id="与Lambda表达式结合"><a href="#与Lambda表达式结合" class="headerlink" title="与Lambda表达式结合"></a>与Lambda表达式结合</h3><p>函数指针也可以指向Lambda表达式，但仅限于不捕获外部变量的Lambda。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不捕获外部变量的Lambda</span></span><br><span class="line">    Callback cb = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda callback!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeCallback</span>(cb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda callback!</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：捕获外部变量的Lambda无法转换为普通函数指针。</p><hr><h2 id="12-总结与练习"><a href="#12-总结与练习" class="headerlink" title="12. 总结与练习"></a>12. 总结与练习</h2><h3 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h3><ul><li><strong>函数的基本概念</strong>：了解函数的作用、基本结构及使用方法。</li><li><strong>函数声明与定义</strong>：掌握在头文件和源文件中分离声明与定义的方法。</li><li><strong>参数传递机制</strong>：理解传值、传引用和传指针的区别及应用场景。</li><li><strong>返回值</strong>：学习不同类型的返回值及其使用方法。</li><li><strong>函数重载</strong>：掌握函数名相同但参数不同的重载机制。</li><li><strong>默认参数</strong>：学习设定和使用函数的默认参数。</li><li><strong>内联函数</strong>：了解内联函数的概念、优缺点及使用场景。</li><li><strong>递归函数</strong>：理解递归的基本原理、编写方法及优化技巧。</li><li><strong>Lambda表达式</strong>：掌握定义和使用Lambda表达式的方法，及其在标准库中的应用。</li><li><strong>函数指针与回调函数</strong>：了解函数指针的声明、使用以及如何实现回调机制。</li></ul><h2 id="13-课后练习"><a href="#13-课后练习" class="headerlink" title="13. 课后练习"></a>13. 课后练习</h2><h3 id="1-练习1"><a href="#1-练习1" class="headerlink" title="1. 练习1"></a>1. 练习1</h3><p> <strong>编写一个递归函数，计算斐波那契数列的第n项</strong></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>斐波那契数列是由0和1开始，后续的每一项都是前两项的和。数列如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</span><br></pre></td></tr></table></figure><p>编写一个递归函数 <code>fibonacci</code>，接受一个整数 <code>n</code>，返回斐波那契数列的第 <code>n</code> 项。假设 <code>fibonacci(0) = 0</code>，<code>fibonacci(1) = 1</code>。</p><h4 id="答案代码"><a href="#答案代码" class="headerlink" title="答案代码"></a><strong>答案代码</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数列的第n项</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Invalid input: n must be non-negative.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 基准情形1</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基准情形2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> term = <span class="number">10</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">fibonacci</span>(term);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10) = 55</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul><li>函数 <code>fibonacci</code> 定义了两个基准情形：<code>n == 0</code> 返回0，<code>n == 1</code> 返回1。</li><li>对于 <code>n &gt; 1</code>，函数递归调用自身计算 <code>fibonacci(n - 1)</code> 和 <code>fibonacci(n - 2)</code>，并返回它们的和。</li><li>在 <code>main</code> 函数中，计算并输出斐波那契数列的第10项，其值为55。</li></ul><h3 id="2-练习2"><a href="#2-练习2" class="headerlink" title="2. 练习2"></a>2. 练习2</h3><p><strong>使用Lambda表达式和<code>std::sort</code>对一个字符串数组按长度排序</strong></p><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>给定一个字符串数组，使用Lambda表达式和<code>std::sort</code>函数对数组中的字符串按照其长度进行排序。</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a><strong>答案</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; fruits = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式按照字符串长度进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(fruits.<span class="built_in">begin</span>(), fruits.<span class="built_in">end</span>(), [](<span class="type">const</span> std::string &amp;a, <span class="type">const</span> std::string &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fruits sorted by length:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;fruit : fruits)</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a><strong>输出</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruits sorted <span class="keyword">by</span> length:</span><br><span class="line">kiwi grape apple banana pineapple strawberry </span><br></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul><li>定义了一个包含多个水果名称的字符串向量 <code>fruits</code>。</li><li>使用 <code>std::sort</code> 对 <code>fruits</code> 进行排序，第三个参数是一个Lambda表达式，用于指定排序的规则。</li><li>Lambda表达式接收两个字符串 <code>a</code> 和 <code>b</code>，比较它们的长度，以实现按长度升序排序。</li><li>排序完成后，输出排序后的水果名称，按长度从短到长排列。</li></ul><h3 id="3-练习3"><a href="#3-练习3" class="headerlink" title="3. 练习3"></a>3. 练习3</h3><p><strong>实现一个简易的事件系统，允许注册和触发回调函数</strong></p><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>构建一个简单的事件系统，允许用户注册多个回调函数（函数指针或Lambda表达式），并在特定事件触发时调用这些回调函数。</p><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a><strong>答案</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义带参数的回调函数类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件系统类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSystem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Callback&gt; callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(<span class="type">const</span> Callback &amp;cb)</span> </span>&#123;</span><br><span class="line">        callbacks.<span class="built_in">push_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，传递参数给回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event triggered with data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;. Executing callbacks...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cb : callbacks)</span><br><span class="line">            <span class="built_in">cb</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数作为回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function callback received data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventSystem eventSystem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册基于函数指针的回调</span></span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>(onEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册基于Lambda表达式的回调</span></span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda callback received: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册带捕获的Lambda表达式的回调</span></span><br><span class="line">    <span class="type">int</span> multiplier = <span class="number">5</span>;</span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>([multiplier](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda with capture received: &quot;</span> &lt;&lt; x * multiplier &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，传递参数</span></span><br><span class="line">    eventSystem.<span class="built_in">triggerEvent</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Event</span> triggered <span class="keyword">with</span> data = <span class="number">10</span>. Executing callbacks...</span><br><span class="line"><span class="keyword">Function</span> callback received data: <span class="number">10</span></span><br><span class="line">Lambda callback received: <span class="number">20</span></span><br><span class="line">Lambda <span class="keyword">with</span> capture received: <span class="number">50</span></span><br></pre></td></tr></table></figure><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul><li>定义了一个带参数的回调函数类型 <code>std::function&lt;void(int)&gt;</code>，允许回调函数接受一个整数参数。</li><li><code>EventSystem</code> 类的方法 <code>triggerEvent</code> 接受一个整数 <code>data</code>，并将其作为参数传递给每个回调函数。</li><li>在 <code>main</code> 函数中，注册了三个带不同处理逻辑的回调函数，并在触发事件时传递参数 <code>10</code>。</li><li>回调函数根据传入的 <code>data</code> 执行相应的操作，展示了回调函数的灵活性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-函数简介&quot;&gt;&lt;a href=&quot;#1-函数简介&quot; class=&quot;headerlink&quot; title=&quot;1. 函数简介&quot;&gt;&lt;/a&gt;1. 函数简介&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(17) 语句和作用域</title>
    <link href="http://www.limerence2017.com/2024/10/27/cppbase17/"/>
    <id>http://www.limerence2017.com/2024/10/27/cppbase17/</id>
    <published>2024-10-27T01:12:20.000Z</published>
    <updated>2025-02-15T02:50:31.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简单语句"><a href="#1-简单语句" class="headerlink" title="1. 简单语句"></a>1. 简单语句</h2><h3 id="1-1-表达式语句"><a href="#1-1-表达式语句" class="headerlink" title="1.1 表达式语句"></a>1.1 表达式语句</h3><p><strong>描述</strong>：在 C++ 中，最常见的简单语句是表达式语句。它由一个表达式组成，并以分号结束。表达式语句可以包括函数调用、赋值操作、增减操作等。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;          <span class="comment">// 赋值表达式语句</span></span><br><span class="line">    a = a + <span class="number">10</span>;         <span class="comment">// 赋值表达式语句</span></span><br><span class="line">    std::cout &lt;&lt; a;     <span class="comment">// 函数调用表达式语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// return 表达式语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>int a = 5;</code> 初始化变量 <code>a</code>，这是一个赋值表达式语句。</li><li><code>a = a + 10;</code> 更新变量 <code>a</code> 的值。</li><li><code>std::cout &lt;&lt; a;</code> 调用了输出流对象的 <code>&lt;&lt;</code> 运算符函数。</li><li><code>return 0;</code> 从 <code>main</code> 函数返回，结束程序。</li></ul><h3 id="1-2-声明语句"><a href="#1-2-声明语句" class="headerlink" title="1.2 声明语句"></a>1.2 声明语句</h3><p><strong>描述</strong>：声明语句用于声明变量、函数、类等标识符。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>int add(int x, int y);</code> 是一个函数声明语句。</li><li><code>int result = add(3, 4);</code> 在 <code>main</code> 中调用函数并声明变量。</li><li><code>int add(int x, int y) &#123; ... &#125;</code> 是函数定义，提供了函数的实现。</li></ul><hr><h2 id="2-语句作用域"><a href="#2-语句作用域" class="headerlink" title="2. 语句作用域"></a>2. 语句作用域</h2><h3 id="2-1-作用域的基本概念"><a href="#2-1-作用域的基本概念" class="headerlink" title="2.1 作用域的基本概念"></a>2.1 作用域的基本概念</h3><p><strong>描述</strong>：作用域定义了变量或其他标识符在程序中的可见范围。C++ 中主要有以下几种作用域：</p><ul><li>**局部作用域 (Local Scope)**：在函数或代码块内部定义的变量，仅在其所在的块内可见。</li><li>**全局作用域 (Global Scope)**：在所有函数外部定义的变量，在整个文件中可见。</li><li>**命名空间作用域 (Namespace Scope)**：在命名空间内部定义的标识符。</li></ul><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside display() - globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; <span class="string">&quot;, localVar: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main() - globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> mainVar = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main() - mainVar: &quot;</span> &lt;&lt; mainVar &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试访问 display() 中的局部变量（将导致编译错误）</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; localVar; // 错误：未定义标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">In</span> <span class="string">main()</span> <span class="bullet">-</span> <span class="attr">globalVar:</span> <span class="number">10</span></span><br><span class="line"><span class="string">In</span> <span class="string">main()</span> <span class="bullet">-</span> <span class="attr">mainVar:</span> <span class="number">20</span></span><br><span class="line"><span class="string">Inside</span> <span class="string">display()</span> <span class="bullet">-</span> <span class="attr">globalVar:</span> <span class="number">10</span><span class="string">,</span> <span class="attr">localVar:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>globalVar</code> 在所有函数中都可见。</li><li><code>mainVar</code> 仅在 <code>main</code> 函数内部可见。</li><li><code>localVar</code> 仅在 <code>display</code> 函数内部可见。</li><li>尝试在 <code>main</code> 中访问 <code>display</code> 函数的 <code>localVar</code> 将导致编译错误，因为它不在作用域内。</li></ul><h3 id="2-3-代码块作用域"><a href="#2-3-代码块作用域" class="headerlink" title="2.3 代码块作用域"></a>2.3 代码块作用域</h3><p><strong>描述</strong>：通过使用花括号 <code>&#123;&#125;</code>，可以创建新的代码块，从而定义局部作用域。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x before block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新的代码块</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">20</span>; <span class="comment">// 局部变量 x，隐藏外部的 x</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x inside block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 访问外部的 x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x before <span class="keyword">block</span>: <span class="number">10</span></span><br><span class="line">x inside <span class="keyword">block</span>: <span class="number">20</span></span><br><span class="line">x after <span class="keyword">block</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>在内部代码块中重新声明了变量 <code>x</code>，该 <code>x</code> 只在代码块内有效，隐藏了外部的 <code>x</code>。</li><li>离开代码块后，内部的 <code>x</code> 不再可见，外部的 <code>x</code> 依然有效。</li></ul><hr><h2 id="3-条件语句"><a href="#3-条件语句" class="headerlink" title="3. 条件语句"></a>3. 条件语句</h2><p>C++ 提供了多种条件语句，用于根据不同的条件执行不同的代码块。</p><h3 id="3-1-if-语句"><a href="#3-1-if-语句" class="headerlink" title="3.1 if 语句"></a>3.1 <code>if</code> 语句</h3><p><strong>描述</strong>：<code>if</code> 语句用于在条件为真时执行特定的代码块。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The number is positive.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>用户输入一个数字，如果 <code>number</code> 大于 <code>0</code>，则输出 “The number is positive.”。</li></ul><h3 id="3-2-if-else-语句"><a href="#3-2-if-else-语句" class="headerlink" title="3.2 if-else 语句"></a>3.2 <code>if-else</code> 语句</h3><p><strong>描述</strong>：<code>if-else</code> 语句在条件为假时执行另一个代码块。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is even.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is odd.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>判断输入的数字是奇数还是偶数，并输出相应的结果。</li></ul><h3 id="3-3-else-if-语句"><a href="#3-3-else-if-语句" class="headerlink" title="3.3 else if 语句"></a>3.3 <code>else if</code> 语句</h3><p><strong>描述</strong>：<code>else if</code> 允许在多重条件下执行不同的代码块。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// code if condition1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// code if condition1 is false and condition2 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code if both condition1 and condition2 are false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter your score (0-100): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: C&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: D&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: F&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>根据分数范围判断并输出相应的等级。</li></ul><h3 id="3-4-switch-语句"><a href="#3-4-switch-语句" class="headerlink" title="3.4 switch 语句"></a>3.4 <code>switch</code> 语句</h3><p><strong>描述</strong>：<code>switch</code> 语句根据变量的值选择执行的代码块，适用于离散的值。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> grade;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter your grade (A, B, C, D, F): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Excellent!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Good!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Fair!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Poor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Invalid grade.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>根据输入的字母等级输出相应的评价。</li><li><code>break</code> 语句防止代码“掉入”下一个 <code>case</code> 中。</li></ul><hr><h2 id="4-迭代语句"><a href="#4-迭代语句" class="headerlink" title="4. 迭代语句"></a>4. 迭代语句</h2><p>C++ 提供了多种循环结构，用于重复执行代码块。</p><h3 id="4-1-for-循环"><a href="#4-1-for-循环" class="headerlink" title="4.1 for 循环"></a>4.1 <code>for</code> 循环</h3><p><strong>描述</strong>：<code>for</code> 循环用于已知循环次数的情况，结构紧凑。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="selector-tag">from</span> <span class="number">1</span> <span class="selector-tag">to</span> <span class="number">5</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>初始化 <code>int i = 1</code>。</li><li>条件 <code>i &lt;= 5</code> 为真时执行循环体。</li><li>每次循环后执行 <code>++i</code>，增加 <code>i</code> 的值。</li><li>最终输出 1 到 5。</li></ul><h3 id="4-2-while-循环"><a href="#4-2-while-循环" class="headerlink" title="4.2 while 循环"></a>4.2 <code>while</code> 循环</h3><p><strong>描述</strong>：<code>while</code> 循环在循环前判断条件，适合未知循环次数的情况。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5 using while loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">while</span> <span class="keyword">loop</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>初始化 <code>count = 1</code>。</li><li>条件 <code>count &lt;= 5</code> 为真时执行循环体。</li><li>每次循环后 <code>++count</code> 增加 <code>count</code> 的值。</li></ul><h3 id="4-3-do-while-循环"><a href="#4-3-do-while-循环" class="headerlink" title="4.3 do-while 循环"></a>4.3 <code>do-while</code> 循环</h3><p><strong>描述</strong>：<code>do-while</code> 循环在循环后判断条件，保证至少执行一次循环体。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5 using do-while loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt;= <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">do</span>-<span class="keyword">while</span> <span class="keyword">loop</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>无论条件是否为真，<code>do</code> 块中的代码至少执行一次。</li><li>在本例中，<code>count</code> 从 <code>1</code> 开始，逐步增加到 <code>5</code>。</li></ul><h3 id="4-4-嵌套循环"><a href="#4-4-嵌套循环" class="headerlink" title="4.4 嵌套循环"></a>4.4 嵌套循环</h3><p><strong>描述</strong>：一个循环内部嵌套另一个循环，常用于多维数据结构的遍历。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Outer loop iteration &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  Inner loop iteration &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>外层 <code>for</code> 循环控制外层迭代次数。</li><li>内层 <code>for</code> 循环在每次外层循环中执行，控制内层迭代次数。</li></ul><hr><h2 id="5-跳转语句"><a href="#5-跳转语句" class="headerlink" title="5. 跳转语句"></a>5. 跳转语句</h2><p>跳转语句用于改变程序的执行流。C++ 中主要有 <code>break</code>、<code>continue</code>、<code>return</code> 和 <code>goto</code>。</p><h3 id="5-1-break-语句"><a href="#5-1-break-语句" class="headerlink" title="5.1 break 语句"></a>5.1 <code>break</code> 语句</h3><p><strong>描述</strong>：<code>break</code> 用于立即终止最近的循环或 <code>switch</code> 语句。</p><p><strong>示例代码（在循环中使用 <code>break</code>）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nLoop exited when i == 5.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="keyword">Loop</span> exited <span class="keyword">when</span> i == <span class="number">5</span>.</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>当 <code>i</code> 达到 <code>5</code> 时，<code>break</code> 终止循环，停止进一步的迭代。</li></ul><h3 id="5-2-continue-语句"><a href="#5-2-continue-语句" class="headerlink" title="5.2 continue 语句"></a>5.2 <code>continue</code> 语句</h3><p><strong>描述</strong>：<code>continue</code> 用于跳过当前的循环迭代，继续下一次循环。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Even numbers between 1 and 10:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Even numbers <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span>:</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>当 <code>i</code> 是奇数时，<code>continue</code> 跳过本次循环，避免执行 <code>std::cout</code> 语句。</li><li>仅输出偶数。</li></ul><h3 id="5-3-return-语句"><a href="#5-3-return-语句" class="headerlink" title="5.3 return 语句"></a>5.3 <code>return</code> 语句</h3><p><strong>描述</strong>：<code>return</code> 用于从函数中返回一个值或结束函数执行。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，返回两个数中的较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// 返回 a，退出函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b; <span class="comment">// 返回 b，退出函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The maximum of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">max</span>(x, y) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The maximum of <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">is</span> <span class="number">20.</span></span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>max</code> 函数根据条件返回较大的数，并退出函数执行。</li></ul><h3 id="5-4-goto-语句"><a href="#5-4-goto-语句" class="headerlink" title="5.4 goto 语句"></a>5.4 <code>goto</code> 语句</h3><p><strong>描述</strong>：<code>goto</code> 允许无条件跳转到程序中指定的标签。虽然 <code>goto</code> 有时能简化代码，但不推荐频繁使用，因为它会使程序流程难以理解和维护。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a positive number (negative to quit): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> end; <span class="comment">// 跳转到 end 标签，结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program ended.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>（输入为负数）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="selector-tag">a</span> positive number (negative <span class="selector-tag">to</span> quit): -<span class="number">5</span></span><br><span class="line">Program ended.</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>当输入负数时，<code>goto end;</code> 跳转到 <code>end</code> 标签，结束程序。</li><li>尽管可以使用 <code>goto</code>，但建议使用更结构化的控制流，如循环和条件语句。</li></ul><hr><h2 id="6-异常处理语句"><a href="#6-异常处理语句" class="headerlink" title="6. 异常处理语句"></a>6. 异常处理语句</h2><p>异常处理用于应对程序运行过程中可能出现的错误情况，确保程序的健壮性和可靠性。</p><h3 id="6-1-try-catch-和-throw-语句"><a href="#6-1-try-catch-和-throw-语句" class="headerlink" title="6.1 try, catch, 和 throw 语句"></a>6.1 <code>try</code>, <code>catch</code>, 和 <code>throw</code> 语句</h3><p><strong>描述</strong>：</p><ul><li><code>try</code> 块用于包含可能引发异常的代码。</li><li><code>throw</code> 用于抛出异常。</li><li><code>catch</code> 块用于捕获并处理异常。</li></ul><p><strong>基本语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// code that may throw an exception</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// handler for ExceptionType1</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// handler for ExceptionType2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，计算除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Denominator cannot be zero.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num, denom;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter numerator: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter denominator: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; denom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">divide</span>(num, denom);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::invalid_argument &amp;e) &#123; <span class="comment">// 捕获 std::invalid_argument 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues after try-catch.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Enter</span> <span class="attr">numerator</span>: <span class="number">10</span></span><br><span class="line"><span class="title class_">Enter</span> <span class="attr">denominator</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Denominator</span> cannot be zero.</span><br><span class="line"><span class="title class_">Program</span> continues after <span class="keyword">try</span>-<span class="keyword">catch</span>.</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>divide</code> 函数在分母为零时抛出 <code>std::invalid_argument</code> 异常。</li><li><code>try</code> 块尝试执行 <code>divide</code> 函数。</li><li>当异常发生时，执行对应的 <code>catch</code> 块，输出错误信息。</li><li>程序在异常处理后继续执行，而不会异常终止。</li></ul><h3 id="6-2-多重-catch-块"><a href="#6-2-多重-catch-块" class="headerlink" title="6.2 多重 catch 块"></a>6.2 多重 <code>catch</code> 块</h3><p><strong>描述</strong>：可以为 <code>try</code> 块指定多个 <code>catch</code> 块，以处理不同类型的异常。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟不同类型的异常</span></span><br><span class="line">        <span class="type">int</span> choice;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Choose exception to throw (1: bad_alloc, 2: invalid_argument): &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid argument provided.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No exception thrown.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123; <span class="comment">// 处理 bad_alloc 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::invalid_argument &amp;e) &#123; <span class="comment">// 处理 invalid_argument 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::invalid_argument: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues after try-catch.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>（选择 <code>1</code>）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Choose exception to <span class="keyword">throw</span> (<span class="number">1</span>: bad_alloc, <span class="number">2</span>: invalid_argument): <span class="number">1</span></span><br><span class="line">Caught std::<span class="variable constant_">bad_alloc</span>: std::<span class="variable constant_">bad_alloc</span></span><br><span class="line">Program continues after <span class="keyword">try</span>-<span class="keyword">catch</span>.</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li>根据用户输入抛出不同类型的异常。</li><li>对应的 <code>catch</code> 块分别处理不同的异常类型。</li><li>如果未匹配的异常被抛出且没有对应的 <code>catch</code> 块，将导致程序终止（未在此示例中展示）。</li></ul><h3 id="6-3-throw-通常位置"><a href="#6-3-throw-通常位置" class="headerlink" title="6.3 throw 通常位置"></a>6.3 <code>throw</code> 通常位置</h3><p><strong>描述</strong>：<code>throw</code> 语句可以在任何需要引发异常的位置使用，包括函数内部、嵌套调用中等。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，检查数组索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElement</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index is out of range.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter array index (0-4): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="built_in">getElement</span>(myArray, <span class="number">5</span>, index);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element at index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::out_of_range &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>（输入为 <code>3</code>）：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter array <span class="keyword">index</span> (<span class="number">0</span>-<span class="number">4</span>): <span class="number">3</span></span><br><span class="line">Element at <span class="keyword">index</span> <span class="number">3</span> is <span class="number">40</span>.</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>（输入为 <code>5</code>）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Enter array <span class="title">index</span> (<span class="params"><span class="number">0</span><span class="number">-4</span></span>): 5</span></span><br><span class="line"><span class="function">Error: Index <span class="keyword">is</span> <span class="keyword">out</span> of range.</span></span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>getElement</code> 函数检查索引是否有效，如果无效则抛出 <code>std::out_of_range</code> 异常。</li><li><code>main</code> 函数中的 <code>try</code> 块调用 <code>getElement</code>，并在 <code>catch</code> 块中处理异常。</li></ul><h3 id="6-4-rethrow-异常"><a href="#6-4-rethrow-异常" class="headerlink" title="6.4 rethrow 异常"></a>6.4 <code>rethrow</code> 异常</h3><p><strong>描述</strong>：可以在 <code>catch</code> 块中使用 <code>throw</code> 语句重新抛出捕获的异常，以便其他部分处理。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error in func1.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，调用 func1 并重新抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func2() caught an exception and is rethrowing it.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123; <span class="comment">// 在 main 中捕获异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Main caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func2</span>() caught an exception and is rethrowing it.</span><br><span class="line"><span class="selector-tag">Main</span> caught: Error in func1.</span><br></pre></td></tr></table></figure><p><strong>讲解</strong>：</p><ul><li><code>func1</code> 抛出异常。</li><li><code>func2</code> 调用 <code>func1</code>，捕获异常后重新抛出。</li><li><code>main</code> 最终捕获并处理异常。</li></ul><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h2 id="练习题-1：打印九九乘法表"><a href="#练习题-1：打印九九乘法表" class="headerlink" title="练习题 1：打印九九乘法表"></a>练习题 1：打印九九乘法表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，使用嵌套的 <code>for</code> 循环来打印标准的九九乘法表。输出的格式应整齐对齐，便于阅读。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol><li>使用嵌套的 <code>for</code> 循环实现。</li><li>输出的乘法表应从 1×1 到 9×9。</li><li>每行输出一个数字的乘法结果，例如第 3 行包含 <code>3×1=3</code> 到 <code>3×9=27</code>。</li><li>确保输出格式整齐，便于阅读。</li></ol><h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a><strong>示例输出</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1x1=11x2=21x3=31x4=41x5=51x6=61x7=71x8=81x9=9</span><br><span class="line">2x1=22x2=42x3=62x4=82x5=102x6=122x7=142x8=162x9=18</span><br><span class="line">3x1=33x2=63x3=93x4=123x5=153x6=183x7=213x8=243x9=27</span><br><span class="line">4x1=44x2=84x3=124x4=164x5=204x6=244x7=284x8=324x9=36</span><br><span class="line">5x1=55x2=105x3=155x4=205x5=255x6=305x7=355x8=405x9=45</span><br><span class="line">6x1=66x2=126x3=186x4=246x5=306x6=366x7=426x8=486x9=54</span><br><span class="line">7x1=77x2=147x3=217x4=287x5=357x6=427x7=497x8=567x9=63</span><br><span class="line">8x1=88x2=168x3=248x4=328x5=408x6=488x7=568x8=648x9=72</span><br><span class="line">9x1=99x2=189x3=279x4=369x5=459x6=549x7=639x8=729x9=81</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul><li>使用两个嵌套的 <code>for</code> 循环：外层循环控制行数（1 到 9），内层循环控制列数（1 到 9）。</li><li>使用 <code>\t</code> 或者适当的空格来对齐输出结果。</li><li>可以使用 <code>std::cout</code> 进行输出。</li></ul><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><strong>参考答案</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环控制行数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 内层循环控制列数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i * j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题-2：实现冒泡排序"><a href="#练习题-2：实现冒泡排序" class="headerlink" title="练习题 2：实现冒泡排序"></a>练习题 2：实现冒泡排序</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，使用 <strong>冒泡排序算法</strong> 对用户输入的一组整数进行排序。冒泡排序是一种简单的排序算法，通过重复交换相邻的未按顺序排列的元素，将最大或最小的元素“冒泡”到序列的一端。</p><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol><li><strong>输入</strong>：用户输入一组整数，首先输入整数的数量 <code>n</code>，然后输入 <code>n</code> 个整数。</li><li><strong>排序</strong>：使用冒泡排序算法对输入的整数进行升序排序。</li><li><strong>输出</strong>：显示排序前和排序后的整数序列。</li><li><strong>函数封装</strong>：将冒泡排序算法封装在一个独立的函数中，提高代码的模块化和可读性。</li></ol><h3 id="示例输入与输出"><a href="#示例输入与输出" class="headerlink" title="示例输入与输出"></a><strong>示例输入与输出</strong></h3><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 5</span></span><br><span class="line">请输入 5 个整数，用空格分隔: 64 34 25 12 22</span><br><span class="line"><span class="section">排序前的数组: 64 34 25 12 22 </span></span><br><span class="line"><span class="section">排序后的数组: 12 22 25 34 64 </span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 8</span></span><br><span class="line">请输入 8 个整数，用空格分隔: 5 1 4 2 8 0 2 9</span><br><span class="line"><span class="section">排序前的数组: 5 1 4 2 8 0 2 9 </span></span><br><span class="line"><span class="section">排序后的数组: 0 1 2 2 4 5 8 9 </span></span><br></pre></td></tr></table></figure><h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul><li><strong>冒泡排序的基本思想</strong>：通过多次遍历数组，每次比较相邻的元素并交换顺序错误的元素。每一轮遍历后，最大的元素会被移动到数组的末端。</li><li><strong>优化</strong>：如果在某一轮遍历中没有发生任何交换，说明数组已经有序，可以提前终止排序过程。</li><li><strong>函数设计</strong>：可以设计一个 <code>bubbleSort</code> 函数接收数组及其大小作为参数，并对数组进行排序。</li></ul><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><strong>参考答案</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="comment">// 外层循环控制总的遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个元素大于后一个元素，则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在一轮遍历中没有进行任何交换，数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数组大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入整数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数组大小必须为正整数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数组元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 个整数，用空格分隔: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序前的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序前的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行冒泡排序</span></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ol><li><p>**函数 <code>bubbleSort</code>**：</p><ul><li><p><strong>参数</strong>：接收一个整数数组 <code>arr</code> 和数组的大小 <code>n</code>。</p></li><li><p>逻辑</p><p>：</p><ul><li>使用两层 <code>for</code> 循环实现冒泡排序。</li><li>外层循环控制需要进行的遍历次数，总共需要 <code>n-1</code> 轮。</li><li>内层循环进行相邻元素的比较和交换，每一轮内层循环会将当前未排序部分的最大元素移动到数组的末端。</li><li>使用 <code>swapped</code> 标志位优化排序过程，如果一轮内层循环中没有发生任何交换，说明数组已经有序，提前终止排序。</li></ul></li><li><p><strong>交换操作</strong>：使用 <code>std::swap</code> 函数交换两个元素的位置。</p></li></ul></li><li><p>**函数 <code>printArray</code>**：</p><ul><li><strong>功能</strong>：遍历数组并打印每个元素，便于观察排序前后的结果。</li></ul></li><li><p><strong><code>main</code> 函数</strong>：</p><ul><li><p>步骤</p><p>：</p><ol><li><strong>输入数组大小</strong>：提示用户输入要排序的整数数量 <code>n</code>。</li><li><strong>输入数组元素</strong>：动态分配一个大小为 <code>n</code> 的整数数组，并从用户处获取 <code>n</code> 个整数的输入。</li><li><strong>打印排序前的数组</strong>：调用 <code>printArray</code> 函数显示原始数组。</li><li><strong>执行冒泡排序</strong>：调用 <code>bubbleSort</code> 函数对数组进行排序。</li><li><strong>打印排序后的数组</strong>：再次调用 <code>printArray</code> 函数显示排序后的数组。</li><li><strong>内存管理</strong>：使用 <code>delete[]</code> 释放动态分配的内存，避免内存泄漏。</li></ol></li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>判断用户输入的数组大小 <code>n</code> 是否为正整数，否者输出错误信息并终止程序。</li></ul></li></ol><h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a><strong>运行示例</strong></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 5</span></span><br><span class="line">请输入 5 个整数，用空格分隔: 64 34 25 12 22</span><br><span class="line"><span class="section">排序前的数组: 64 34 25 12 22 </span></span><br><span class="line"><span class="section">排序后的数组: 12 22 25 34 64 </span></span><br></pre></td></tr></table></figure><h2 id="练习题-3：生成斐波那契数列"><a href="#练习题-3：生成斐波那契数列" class="headerlink" title="练习题 3：生成斐波那契数列"></a>练习题 3：生成斐波那契数列</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，生成并显示斐波那契数列。程序应允许用户指定生成数列的长度，并使用 <strong>循环结构</strong> 或 <strong>递归方法</strong> 来生成斐波那契数。</p><p>斐波那契数列是一个由 0 和 1 开始，后续的每个数都是前两个数之和的数列。例如：0, 1, 1, 2, 3, 5, 8, 13, …</p><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol><li><strong>输入</strong>：用户输入要生成的斐波那契数的数量 <code>n</code>。</li><li><strong>生成</strong>：使用循环结构（如 <code>for</code> 或 <code>while</code> 循环）生成斐波那契数列。</li><li><strong>输出</strong>：显示生成的斐波那契数列。</li><li><strong>函数封装</strong>：将生成斐波那契数列的逻辑封装在一个独立的函数中。</li></ol><h3 id="示例输入与输出-1"><a href="#示例输入与输出-1" class="headerlink" title="示例输入与输出"></a><strong>示例输入与输出</strong></h3><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 10</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 5</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 </span><br></pre></td></tr></table></figure><h3 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul><li><p>斐波那契数列的定义</p><p>：</p><ul><li>第 0 个斐波那契数是 0。</li><li>第 1 个斐波那契数是 1。</li><li>对于 <code>n &gt;= 2</code>，第 <code>n</code> 个斐波那契数是第 <code>n-1</code> 个数和第 <code>n-2</code> 个数的和。</li></ul></li><li><p>实现方法</p><p>：</p><ul><li><strong>迭代法</strong>：使用循环结构依次计算斐波那契数。</li><li><strong>递归法</strong>（高级）：使用递归函数实现，但效率较低，通常不推荐用于较大的 <code>n</code>。</li></ul></li><li><p><strong>数据类型</strong>：根据 <code>n</code> 的范围选择合适的数据类型，<code>unsigned long long</code> 可以存储较大的斐波那契数。</p></li></ul><h3 id="参考答案（迭代法实现）"><a href="#参考答案（迭代法实现）" class="headerlink" title="参考答案（迭代法实现）"></a><strong>参考答案（迭代法实现）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成斐波那契数列的函数（迭代法）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">generateFibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fib;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空向量</span></span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个斐波那契数</span></span><br><span class="line">    fib.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个斐波那契数</span></span><br><span class="line">    fib.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成后续的斐波那契数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> next = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        fib.<span class="built_in">push_back</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斐波那契数列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFibonacci</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; &amp;fib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fib.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取要生成的斐波那契数的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要生成的斐波那契数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数量不能为负数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fibonacci = <span class="built_in">generateFibonacci</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印斐波那契数列</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;斐波那契数列:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printFibonacci</span>(fibonacci);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ol><li><p>**函数 <code>generateFibonacci</code>**：</p><ul><li><p><strong>参数</strong>：接收一个整数 <code>n</code>，表示要生成的斐波那契数的数量。</p></li><li><p><strong>返回值</strong>：返回一个 <code>std::vector&lt;unsigned long long&gt;</code>，包含生成的斐波那契数列。</p></li><li><p>逻辑</p><p>：</p><ul><li>如果 <code>n &lt;= 0</code>，返回一个空的向量。</li><li>初始化斐波那契数列的前两个数：0 和 1。</li><li>使用一个 <code>for</code> 循环，从第三个数开始，依次计算当前数为前两个数之和，并将其添加到向量中。</li></ul></li></ul></li><li><p>**函数 <code>printFibonacci</code>**：</p><ul><li><strong>参数</strong>：接收一个 <code>const</code> 引用的斐波那契数列向量。</li><li><strong>功能</strong>：遍历并打印斐波那契数列中的每个数，用空格分隔。</li></ul></li><li><p><strong><code>main</code> 函数</strong>：</p><ul><li><p>步骤</p><p>：</p><ol><li><strong>输入数量</strong>：提示用户输入要生成的斐波那契数的数量 <code>n</code>。</li><li><strong>输入验证</strong>：检查 <code>n</code> 是否为负数，若是则输出错误信息并终止程序。</li><li><strong>生成数列</strong>：调用 <code>generateFibonacci</code> 函数生成斐波那契数列。</li><li><strong>打印数列</strong>：调用 <code>printFibonacci</code> 函数显示生成的斐波那契数列。</li></ol></li></ul></li><li><p><strong>数据类型选择</strong>：</p><ul><li>使用 <code>unsigned long long</code> 可以存储较大的斐波那契数，避免整数溢出。但需要注意，<code>unsigned long long</code> 的范围有限，对于非常大的 <code>n</code>，仍然会发生溢出。</li></ul></li></ol><h3 id="运行示例-1"><a href="#运行示例-1" class="headerlink" title="运行示例"></a><strong>运行示例</strong></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 10</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 </span><br></pre></td></tr></table></figure><h3 id="递归实现参考代码（可选）"><a href="#递归实现参考代码（可选）" class="headerlink" title="递归实现参考代码（可选）"></a><strong>递归实现参考代码（可选）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，计算第 n 个斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;n 不能为负数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacciRecursive</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacciRecursive</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成斐波那契数列的函数（递归实现）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">generateFibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fib;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fib.<span class="built_in">push_back</span>(<span class="built_in">fibonacciRecursive</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斐波那契数列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFibonacci</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; &amp;fib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fib.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取要生成的斐波那契数的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要生成的斐波那契数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数量不能为负数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 生成斐波那契数列（递归实现）</span></span><br><span class="line">        std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fibonacci = <span class="built_in">generateFibonacciRecursive</span>(n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印斐波那契数列</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;斐波那契数列:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printFibonacci</span>(fibonacci);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现说明"><a href="#递归实现说明" class="headerlink" title="递归实现说明"></a><strong>递归实现说明</strong></h3><ul><li><p>优点</p><p>：</p><ul><li>代码简洁，符合斐波那契数列的数学定义。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>时间复杂度为指数级 <code>O(2^n)</code>，对于较大的 <code>n</code> 会非常低效。</li><li>递归深度过大可能导致栈溢出。</li></ul></li><li><p><strong>使用场景</strong>：适合学习和理解递归概念，但在实际应用中需谨慎使用。</p></li></ul><h3 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h3><p>动态规划通过存储已计算的值来避免重复计算，提高了效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划实现斐波那契数列</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fibonacci_dynamic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fib</span><span class="params">(n)</span></span>;</span><br><span class="line">    fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入斐波那契数列的项数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; fib = <span class="built_in">fibonacci_dynamic</span>(n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;斐波那契数列的前 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 项为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-简单语句&quot;&gt;&lt;a href=&quot;#1-简单语句&quot; class=&quot;headerlink&quot; title=&quot;1. 简单语句&quot;&gt;&lt;/a&gt;1. 简单语句&lt;/h2&gt;&lt;h3 id=&quot;1-1-表达式语句&quot;&gt;&lt;a href=&quot;#1-1-表达式语句&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
  <entry>
    <title>零基础C++(16) 常见运算符</title>
    <link href="http://www.limerence2017.com/2024/10/26/cppbase16/"/>
    <id>http://www.limerence2017.com/2024/10/26/cppbase16/</id>
    <published>2024-10-26T03:59:11.000Z</published>
    <updated>2025-02-15T02:50:28.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>运算符是编程语言中用于执行特定操作的符号或关键字。在C++中，运算符的使用广泛且多样，掌握运算符的使用对于编写高效、简洁的代码至关重要。本教案旨在全面介绍C++中的各种运算符，帮助学习者深入理解和灵活运用。</p><h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><p><strong>运算符（Operator）</strong> 是用来对变量进行操作的符号或函数。C++中的运算符可分为多种类型，每种运算符具有特定的功能和使用规则。运算符可以单目（仅操作一个操作数）、双目（操作两个操作数）、甚至三目（操作三个操作数）等。</p><h2 id="运算符分类"><a href="#运算符分类" class="headerlink" title="运算符分类"></a>运算符分类</h2><p>C++中的运算符可以根据功能和使用方式分为以下几类：</p><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>用于执行基本的数学计算。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>a + b</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>a - b</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>a * b</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>a / b</code></td></tr><tr><td><code>%</code></td><td>取模（求余数）</td><td><code>a % b</code></td></tr><tr><td><code>++</code></td><td>自增（前缀/后缀）</td><td><code>++a</code>, <code>a++</code></td></tr><tr><td><code>--</code></td><td>自减（前缀/后缀）</td><td><code>--a</code>, <code>a--</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> sum = a + b;    <span class="comment">// 13</span></span><br><span class="line"><span class="type">int</span> diff = a - b;   <span class="comment">// 7</span></span><br><span class="line"><span class="type">int</span> prod = a * b;   <span class="comment">// 30</span></span><br><span class="line"><span class="type">int</span> div = a / b;    <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span> mod = a % b;    <span class="comment">// 1</span></span><br><span class="line">a++;                <span class="comment">// a = 11</span></span><br><span class="line">--b;                <span class="comment">// b = 2</span></span><br></pre></td></tr></table></figure><h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h3><p>用于比较两个值之间的关系，返回布尔值（<code>true</code> 或 <code>false</code>）。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td><td><code>a == b</code></td></tr><tr><td><code>!=</code></td><td>不等于</td><td><code>a != b</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>a &gt; b</code></td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>a &lt; b</code></td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td><td><code>a &gt;= b</code></td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td><td><code>a &lt;= b</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> result1 = (a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">bool</span> result2 = (a &lt; b);  <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> result3 = (a &gt;= b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>用于组合或反转布尔表达式，返回布尔值。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）</td><td><code>a &amp;&amp; b</code></td></tr><tr><td>`</td><td></td><td>`</td></tr><tr><td><code>!</code></td><td>逻辑非（NOT）</td><td><code>!a</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> result1 = a &amp;&amp; b; <span class="comment">// false</span></span><br><span class="line"><span class="type">bool</span> result2 = a || b; <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> result3 = !a;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>用于按位操作整数类型的二进制位。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>a &amp; b</code></td></tr><tr><td>`</td><td>`</td><td>按位或</td></tr><tr><td><code>^</code></td><td>按位异或（不等时为1）</td><td><code>a ^ b</code></td></tr><tr><td><code>~</code></td><td>按位取反</td><td><code>~a</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>a &lt;&lt; 2</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>a &gt;&gt; 2</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 二进制：0101</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 二进制：0011</span></span><br><span class="line"><span class="type">int</span> andResult = a &amp; b; <span class="comment">// 1 (0001)</span></span><br><span class="line"><span class="type">int</span> orResult = a | b;  <span class="comment">// 7 (0111)</span></span><br><span class="line"><span class="type">int</span> xorResult = a ^ b; <span class="comment">// 6 (0110)</span></span><br><span class="line"><span class="type">int</span> notResult = ~a;    <span class="comment">// -6 (补码)</span></span><br><span class="line"><span class="type">int</span> leftShift = a &lt;&lt; <span class="number">1</span>; <span class="comment">// 10 (1010)</span></span><br><span class="line"><span class="type">int</span> rightShift = a &gt;&gt; <span class="number">1</span>; <span class="comment">// 2 (0010)</span></span><br></pre></td></tr></table></figure><h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h3><p>用于向变量赋值。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>=</code></td><td>简单赋值</td><td><code>a = b</code></td></tr><tr><td><code>+=</code></td><td>加后赋值</td><td><code>a += b</code></td></tr><tr><td><code>-=</code></td><td>减后赋值</td><td><code>a -= b</code></td></tr><tr><td><code>*=</code></td><td>乘后赋值</td><td><code>a *= b</code></td></tr><tr><td><code>/=</code></td><td>除后赋值</td><td><code>a /= b</code></td></tr><tr><td><code>%=</code></td><td>取模后赋值</td><td><code>a %= b</code></td></tr><tr><td><code>&amp;=</code></td><td>按位与后赋值</td><td><code>a &amp;= b</code></td></tr><tr><td>`</td><td>=`</td><td>按位或后赋值</td></tr><tr><td><code>^=</code></td><td>按位异或后赋值</td><td><code>a ^= b</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td>左移后赋值</td><td><code>a &lt;&lt;= 2</code></td></tr><tr><td><code>&gt;&gt;=</code></td><td>右移后赋值</td><td><code>a &gt;&gt;= 2</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">a += b; <span class="comment">// a = 8</span></span><br><span class="line">a *= <span class="number">2</span>; <span class="comment">// a = 16</span></span><br><span class="line">a &amp;= b; <span class="comment">// a = 16 &amp; 3 = 0</span></span><br></pre></td></tr></table></figure><h3 id="6-复合赋值运算符"><a href="#6-复合赋值运算符" class="headerlink" title="6. 复合赋值运算符"></a>6. 复合赋值运算符</h3><p>结合赋值与其他运算的运算符（如上表中所示的<code>+=</code>, <code>-=</code>, 等）。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// 等同于 a = a + 5; 结果 a = 15</span></span><br></pre></td></tr></table></figure><h3 id="7-条件运算符"><a href="#7-条件运算符" class="headerlink" title="7. 条件运算符"></a>7. 条件运算符</h3><p>用于基于条件选择值。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>?:</code></td><td>条件（三目）运算符</td><td><code>a ? b : c</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">c = (a &gt; b) ? a : b; <span class="comment">// c = 20</span></span><br></pre></td></tr></table></figure><h3 id="8-递增和递减运算符"><a href="#8-递增和递减运算符" class="headerlink" title="8. 递增和递减运算符"></a>8. 递增和递减运算符</h3><p>用于增加或减少变量的值，前缀和后缀形式。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>++</code></td><td>自增（前缀/后缀）</td><td><code>++a</code>, <code>a++</code></td></tr><tr><td><code>--</code></td><td>自减（前缀/后缀）</td><td><code>--a</code>, <code>a--</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = ++a; <span class="comment">// a = 6, b = 6</span></span><br><span class="line"><span class="type">int</span> c = a--; <span class="comment">// a = 5, c = 6</span></span><br></pre></td></tr></table></figure><h3 id="9-指针运算符"><a href="#9-指针运算符" class="headerlink" title="9. 指针运算符"></a>9. 指针运算符</h3><p>用于操作指针。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>间接访问（解引用）</td><td><code>*ptr</code></td></tr><tr><td><code>&amp;</code></td><td>取地址</td><td><code>&amp;a</code></td></tr><tr><td><code>-&gt;</code></td><td>成员访问（指向对象的指针）</td><td><code>ptr-&gt;member</code></td></tr><tr><td><code>[]</code></td><td>数组下标访问</td><td><code>arr[2]</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// value = 10</span></span><br></pre></td></tr></table></figure><h3 id="10-成员访问运算符"><a href="#10-成员访问运算符" class="headerlink" title="10. 成员访问运算符"></a>10. 成员访问运算符</h3><p>用于访问类或结构体的成员。</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>.</code></td><td>直接成员访问</td><td><code>object.member</code></td></tr><tr><td><code>-&gt;</code></td><td>指向成员的指针访问</td><td><code>ptr-&gt;member</code></td></tr><tr><td><code>::*</code></td><td>指向成员的指针（成员指针操作符）</td><td><code>Class::*ptr</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">Point *ptr = &amp;p;</span><br><span class="line"><span class="type">int</span> a = p.x;      <span class="comment">// 使用 . 运算符</span></span><br><span class="line"><span class="type">int</span> b = ptr-&gt;y;  <span class="comment">// 使用 -&gt; 运算符</span></span><br></pre></td></tr></table></figure><h3 id="11-其他运算符"><a href="#11-其他运算符" class="headerlink" title="11. 其他运算符"></a>11. 其他运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>sizeof</code></td><td>返回变量或类型所占字节数</td><td><code>sizeof(int)</code></td></tr><tr><td><code>?:</code></td><td>条件（三目）运算符</td><td><code>a ? b : c</code></td></tr><tr><td><code>,</code></td><td>逗号运算符</td><td><code>a = (b, c)</code></td></tr><tr><td><code>typeid</code></td><td>运行时类型信息运算符</td><td><code>typeid(a)</code></td></tr><tr><td><code>new</code></td><td>动态内存分配</td><td><code>int *ptr = new int;</code></td></tr><tr><td><code>delete</code></td><td>动态内存释放</td><td><code>delete ptr;</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(a); <span class="comment">// size = 4 (通常)</span></span><br><span class="line"><span class="type">int</span> b, c;</span><br><span class="line">b = (a++, a + <span class="number">2</span>); <span class="comment">// a = 6, b = 8</span></span><br></pre></td></tr></table></figure><hr><h2 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h2><p>运算符的优先级决定了在没有括号明确指定的情况下，哪一个运算符先被计算。结合性则决定了运算符在具有相同优先级时的计算顺序（从左到右或从右到左）。</p><h3 id="优先级表"><a href="#优先级表" class="headerlink" title="优先级表"></a>优先级表</h3><p>以下是C++运算符的优先级从高到低的简要概览：</p><table><thead><tr><th>优先级</th><th>运算符类别</th><th>运算符</th><th>结合性</th><th>备注</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>范围解析运算符</td><td><code>::</code></td><td>左到右</td><td>用于访问命名空间或类的成员</td></tr><tr><td><strong>2</strong></td><td>后缀运算符</td><td><code>()</code>, <code>[]</code>, <code>.</code>, <code>-&gt;</code>, <code>++</code>(后置), <code>--</code>(后置)</td><td>左到右</td><td>包含函数调用、数组下标、成员访问</td></tr><tr><td><strong>3</strong></td><td>一元运算符</td><td><code>+</code>, <code>-</code>, <code>!</code>, <code>~</code>, <code>++</code>(前置), <code>--</code>(前置), <code>*</code>(解引用), <code>&amp;</code>(取地址), <code>sizeof</code>, <code>typeid</code></td><td>右到左</td><td>适用于单个操作数的运算符</td></tr><tr><td><strong>4</strong></td><td>乘法运算符</td><td><code>*</code>, <code>/</code>, <code>%</code></td><td>左到右</td><td>乘法、除法和取模运算</td></tr><tr><td><strong>5</strong></td><td>加法运算符</td><td><code>+</code>, <code>-</code></td><td>左到右</td><td>加法和减法运算</td></tr><tr><td><strong>6</strong></td><td>移位运算符</td><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td>左到右</td><td>位左移和位右移</td></tr><tr><td><strong>7</strong></td><td>关系运算符</td><td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td><td>左到右</td><td>比较运算符</td></tr><tr><td><strong>8</strong></td><td>相等运算符</td><td><code>==</code>, <code>!=</code></td><td>左到右</td><td>判断相等与不相等</td></tr><tr><td><strong>9</strong></td><td>位与运算符</td><td><code>&amp;</code></td><td>左到右</td><td>按位与</td></tr><tr><td><strong>10</strong></td><td>位异或运算符</td><td><code>^</code></td><td>左到右</td><td>按位异或</td></tr><tr><td><strong>11</strong></td><td>位或运算符</td><td>`</td><td>`</td><td>左到右</td></tr><tr><td><strong>12</strong></td><td>逻辑与运算符</td><td><code>&amp;&amp;</code></td><td>左到右</td><td>逻辑与</td></tr><tr><td><strong>13</strong></td><td>逻辑或运算符</td><td>`</td><td></td><td>`</td></tr><tr><td><strong>14</strong></td><td>条件运算符</td><td><code>?:</code></td><td>右到左</td><td>条件（三目）运算符</td></tr><tr><td><strong>15</strong></td><td>赋值运算符</td><td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, `</td><td>=<code>, </code>^=<code>, </code>&lt;&lt;=<code>, </code>&gt;&gt;=`</td><td>右到左</td></tr><tr><td><strong>16</strong></td><td>逗号运算符</td><td><code>,</code></td><td>左到右</td><td>逗号用于表达式中多个操作</td></tr></tbody></table><h3 id="表格说明"><a href="#表格说明" class="headerlink" title="表格说明"></a><strong>表格说明</strong></h3><ul><li><strong>优先级</strong>：数字越小，优先级越高。即优先级为1的运算符最先被计算。</li><li><strong>运算符类别</strong>：运算符的功能分类，帮助理解不同类型运算符的用途。</li><li><strong>运算符</strong>：具体的C++运算符符号。</li><li><strong>结合性</strong>：当表达式中出现多个相同优先级的运算符时，决定运算顺序的规则。<code>左到右</code>表示从左侧的操作数开始，<code>右到左</code>表示从右侧的操作数开始。</li><li><strong>备注</strong>：对运算符类别或特定运算符的简要说明。</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><strong>运算符重载（Operator Overloading）</strong> 允许开发者为自定义类型（如类和结构体）定义或改变运算符的行为，使其表现得像内置类型一样。这提高了代码的可读性和可维护性。</p><h3 id="运算符重载的规则"><a href="#运算符重载的规则" class="headerlink" title="运算符重载的规则"></a>运算符重载的规则</h3><ol><li><strong>可重载运算符</strong>：几乎所有的运算符都可以被重载，但如 <code>::</code>, <code>?:</code>, <code>sizeof</code> 等运算符不能被重载。</li><li><strong>至少一个操作数必须是用户定义类型</strong>：即至少有一个操作数是类、结构体或联合体类型。</li><li><strong>运算符重载不改变运算符的优先级、结合性和操作数数量</strong>。</li></ol><h3 id="运算符重载的基本语法"><a href="#运算符重载的基本语法" class="headerlink" title="运算符重载的基本语法"></a>运算符重载的基本语法</h3><p>运算符可以作为成员函数或友元函数进行重载。</p><p><strong>成员函数重载示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">        Complex temp;</span><br><span class="line">        temp.real = real + c.real;</span><br><span class="line">        temp.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>友元函数重载示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2) &#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = c1.real + c2.real;</span><br><span class="line">    temp.imag = c1.imag + c2.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见的重载运算符"><a href="#常见的重载运算符" class="headerlink" title="常见的重载运算符"></a>常见的重载运算符</h3><ul><li><strong>算术运算符</strong>：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li><li><strong>关系运算符</strong>：<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li><li><strong>逻辑运算符</strong>：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li><li><strong>赋值运算符</strong>：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li><li><strong>输入输出运算符</strong>：<code>&lt;&lt;</code>, <code>&gt;&gt;</code></li><li><strong>索引运算符</strong>：<code>[]</code></li><li><strong>函数调用运算符</strong>：<code>()</code></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, imag + c.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符（作为友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">    out &lt;&lt; c.real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.8</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl; <span class="comment">// 输出: c1 + c2 = 6.8 + 11.2i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1-交换两个数"><a href="#1-交换两个数" class="headerlink" title="1 交换两个数"></a>1 交换两个数</h3><p><strong>题目：</strong> 使用位运算符，交换两个整数变量的值而不使用第三个变量。</p><p><strong>答案：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换操作</span></span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = x ^ y;</span><br><span class="line">    x = x ^ y;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Before swap:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">15</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">27</span></span><br><span class="line"><span class="attr">After swap:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">27</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong> 通过异或运算 <code>^</code> 完成变量值的交换，无需使用临时变量。</p><h3 id="2-函数修改外部变量"><a href="#2-函数修改外部变量" class="headerlink" title="2 函数修改外部变量"></a>2 函数修改外部变量</h3><p><strong>题目：</strong> 编写一个函数，接受一个整数指针，使用解引用运算符修改其值为原值的平方。</p><p><strong>答案：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">square</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = (*ptr) * (*ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">square</span>(&amp;num);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Before: 5</span></span><br><span class="line"><span class="section">After: 25</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong> 通过指针访问并修改原变量的值。</p><h3 id="3-计算范围内所有元素的和"><a href="#3-计算范围内所有元素的和" class="headerlink" title="3 计算范围内所有元素的和"></a>3 计算范围内所有元素的和</h3><p><strong>题目：</strong> 编写一个函数，接受 <code>std::vector&lt;int&gt;</code> 的迭代器范围，计算并返回范围内所有元素的和。</p><p><strong>函数示例：</strong></p><p>须实现如下函数，返回范围内元素求和的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator end)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="built_in">sumRange</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Sum: 30</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong> 函数通过迭代器遍历范围，累加元素值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h2&gt;&lt;p&gt;运算符是编程语言中用于执行特定操作的符号或关键字。在C++中，运算符的使用广泛且多样，掌握运算符的使用对于编写高效、简洁的代码至关重要。本教</summary>
      
    
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/categories/cppbase/"/>
    
    
    <category term="零基础C++" scheme="http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"/>
    
  </entry>
  
</feed>
