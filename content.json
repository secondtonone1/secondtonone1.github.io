[{"title":"零基础C++(33) 单例模式演变","date":"2025-03-01T04:49:27.000Z","path":"2025/03/01/cppbase33/","text":"单例模式概念今天给大家讲讲单例模式演变流程，从C++98到C++11经历了哪些变化？哪一种单例模式更为安全。 单例模式（Singleton Pattern）是一种创建型设计模式，旨在确保一个类在整个应用程序生命周期中仅且只有一个实例，并提供一个全局访问点以获取该实例。设计单例模式的主要原因和作用包括以下几个方面： 1. 控制实例数量单例模式确保一个类只有一个实例，防止在程序中创建多个实例可能导致的资源浪费或状态不一致问题。例如，数据库连接池、配置管理类等通常使用单例模式，以确保全局只有一个连接池或配置实例。 2. 提供全局访问点单例模式通过提供一个全局访问点，使得在程序的任何地方都可以方便地访问该实例。这对于那些需要在多个模块或组件之间共享的资源或服务尤为重要，如日志记录器、缓存管理器等。 3. 延迟实例化单例模式通常采用懒加载的方式，即在第一次需要使用实例时才创建。这有助于节省系统资源，特别是在实例创建成本较高或初期并不需要该实例的情况下。 4. 避免命名冲突通过将单例实例作为一个类的静态成员，可以避免在全局命名空间中引入多个实例，减少命名冲突的风险。 5. 管理共享资源在多线程环境下，单例模式可以有效管理共享资源，确保线程安全。例如，操作系统中的线程池、任务管理器等常使用单例模式，以协调多个线程对资源的访问。 设计单例模式的考虑因素虽然单例模式有诸多优点，但在设计和使用时也需要注意以下几点： 线程安全：在多线程环境下，需要确保单例实例的创建和访问是线程安全的，常用的方法有双重检查锁定（Double-Checked Locking）和使用静态内部类等。 延迟初始化：根据需求选择是否采用延迟初始化，以平衡性能和资源利用。 可测试性：单例模式可能会影响代码的可测试性，特别是在单元测试中，可能需要通过依赖注入等手段来替代单例实例。 限制扩展：单例模式通过限制实例数量可能会限制类的扩展性，需谨慎使用。 适用场景 需要确保全局只有一个实例的场景，如配置管理、日志系统、设备驱动等。 需要全局访问点来协调系统中的多个部分，如缓存、线程池等。 不适用场景 需要多个实例以满足不同需求的场景。 对象的生命周期需要更灵活控制的场合。 总的来说，单例模式通过控制类的实例数量和提供全局访问点，为系统资源管理和状态一致性提供了有效的解决方案。然而，在实际应用中，应根据具体需求和上下文环境，谨慎决定是否使用单例模式，以避免潜在的设计问题。 局部静态变量方式这种方式最简单 1234567891011121314151617//通过静态成员变量实现单例//懒汉式class Single2&#123;private: Single2() &#123; &#125; Single2(const Single2 &amp;) = delete; Single2 &amp;operator=(const Single2 &amp;) = delete;public: static Single2 &amp;GetInst() &#123; static Single2 single; return single; &#125;&#125;; 上述代码通过局部静态成员single实现单例类，原理就是函数的局部静态变量生命周期随着进程结束而结束。上述代码通过懒汉式的方式实现。调用如下 123456void test_single2()&#123; //多线程情况下可能存在问题 cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl; cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl;&#125; 程序输出如下 12sp1 is 0x1304b10sp2 is 0x1304b10 确实生成了唯一实例，在C++98年代，上述单例模式存在隐患，对于多线程方式生成的实例可能时多个。 随着C++ 11的来临，这种方式不再存在线程安全问题，是最为简单也是最适合新手的方式。 静态成员变量指针方式(饿汉式)可以定义一个类的静态成员变量，用来控制实现单例，这种方式依靠静态成员提前初始化保证生成的单例是唯一的。 123456789101112131415161718192021//饿汉式class Single2Hungry&#123;private: Single2Hungry() &#123; &#125; Single2Hungry(const Single2Hungry &amp;) = delete; Single2Hungry &amp;operator=(const Single2Hungry &amp;) = delete;public: static Single2Hungry *GetInst() &#123; if (single == nullptr) &#123; single = new Single2Hungry(); &#125; return single; &#125;private: static Single2Hungry *single;&#125;; 这么做的一个好处是我们可以通过饿汉式的方式避免线程安全问题 1234567891011121314151617181920//饿汉式初始化Single2Hungry *Single2Hungry::single = Single2Hungry::GetInst();void thread_func_s2(int i)&#123; cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;inst is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;&#125;void test_single2hungry()&#123; cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl; cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl; for (int i = 0; i &lt; 3; i++) &#123; thread tid(thread_func_s2, i); tid.join(); &#125;&#125;int main()&#123; test_single2hungry()&#125; 程序输出如下 12345678s1 addr is 0x1e4b00s2 addr is 0x1e4b00this is thread 0inst is 0x1e4b00this is thread 1inst is 0x1e4b00this is thread 2inst is 0x1e4b00 可见无论单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。 饿汉式是在程序启动时就进行单例的初始化，这种方式也可以通过懒汉式调用，无论饿汉式还是懒汉式都存在一个问题，就是什么时候释放内存？ 多线程情况下，释放内存就很难了，还有二次释放内存的风险。 静态成员变量指针方式(懒汉式)我们定义一个单例类并用懒汉式方式调用 12345678910111213141516171819202122232425262728293031//懒汉式指针//即使创建指针类型也存在问题class SinglePointer&#123;private: SinglePointer() &#123; &#125; SinglePointer(const SinglePointer &amp;) = delete; SinglePointer &amp;operator=(const SinglePointer &amp;) = delete;public: static SinglePointer *GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; single = new SinglePointer(); s_mutex.unlock(); return single; &#125;private: static SinglePointer *single; static mutex s_mutex;&#125;; 在cpp文件里初始化静态成员,并定义一个测试函数 123456789101112131415161718192021//懒汉式//在类的cpp文件定义static变量SinglePointer *SinglePointer::single = nullptr;std::mutex SinglePointer::s_mutex;void thread_func_lazy(int i)&#123; cout &lt;&lt; &quot;this is lazy thread &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;inst is &quot; &lt;&lt; SinglePointer::GetInst() &lt;&lt; endl;&#125;void test_singlelazy()&#123; for (int i = 0; i &lt; 3; i++) &#123; thread tid(thread_func_lazy, i); tid.join(); &#125; //何时释放new的对象？造成内存泄漏&#125;int main()&#123; test_singlelazy();&#125; 函数输出如下 123456this is lazy thread 0inst is 0xbc1700this is lazy thread 1inst is 0xbc1700this is lazy thread 2inst is 0xbc1700 此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。 C++11改进 我们可以利用C++11 提供的once_flag实现安全的创建 1234567891011121314151617181920212223242526272829303132#ifndef DAY34_SINGLETON_SINGLETON_H#define DAY34_SINGLETON_SINGLETON_H#include &lt;mutex&gt;#include &lt;iostream&gt;class SingletonOnceFlag&#123;public: static SingletonOnceFlag* getInstance()&#123; static std::once_flag flag; std::call_once(flag, []&#123; _instance = new SingletonOnceFlag(); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance &lt;&lt; std::endl; &#125; ~SingletonOnceFlag() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;private: SingletonOnceFlag() = default; SingletonOnceFlag(const SingletonOnceFlag&amp;) = delete; SingletonOnceFlag&amp; operator=(const SingletonOnceFlag&amp; st) = delete; static SingletonOnceFlag* _instance;&#125;;#endif //DAY34_SINGLETON_SINGLETON_H static成员要在cpp中初始化 1SingletonOnceFlag *SingletonOnceFlag::_instance = nullptr; 测试 123456789101112131415161718192021222324#include &quot;Singleton.h&quot;#include &lt;thread&gt;#include &lt;mutex&gt;int main() &#123; system(&quot;chcp 65001 &gt; nul&quot;); std::mutex mtx; std::thread t1([&amp;]()&#123; SingletonOnceFlag::getInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingletonOnceFlag::getInstance()-&gt;PrintAddress(); &#125;); std::thread t2([&amp;]()&#123; SingletonOnceFlag::getInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingletonOnceFlag::getInstance()-&gt;PrintAddress(); &#125;); t1.join(); t2.join(); return 0;&#125; 测试结果 120x19a74de74200x19a74de7420 智能指针方式(懒汉式)可以利用智能指针自动回收内存的机制设计单例类 123456789101112131415161718192021222324252627282930313233#ifndef DAY34_SINGLETON_SINGLETON_H#define DAY34_SINGLETON_SINGLETON_H#include &lt;mutex&gt;#include &lt;iostream&gt;#include &lt;memory&gt;class SingletonOnceFlag&#123;public: static std::shared_ptr&lt;SingletonOnceFlag&gt; getInstance()&#123; static std::once_flag flag; std::call_once(flag, []&#123; _instance = std::shared_ptr&lt;SingletonOnceFlag&gt;(new SingletonOnceFlag()); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance &lt;&lt; std::endl; &#125; ~SingletonOnceFlag() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;private: SingletonOnceFlag() = default; SingletonOnceFlag(const SingletonOnceFlag&amp;) = delete; SingletonOnceFlag&amp; operator=(const SingletonOnceFlag&amp; st) = delete; static std::shared_ptr&lt;SingletonOnceFlag&gt; _instance;&#125;;#endif //DAY34_SINGLETON_SINGLETON_H 同样在SingletonOnceFlag.cpp中进行单例成员的初始化 123#include &quot;Singleton.h&quot;std::shared_ptr&lt;SingletonOnceFlag&gt; SingletonOnceFlag::_instance = nullptr; 再次测试 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;Singleton.h&quot;#include &lt;thread&gt;#include &lt;mutex&gt;int main() &#123; system(&quot;chcp 65001 &gt; nul&quot;); std::mutex mtx; std::thread t1([&amp;]()&#123; SingletonOnceFlag::getInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingletonOnceFlag::getInstance()-&gt;PrintAddress(); &#125;); std::thread t2([&amp;]()&#123; SingletonOnceFlag::getInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingletonOnceFlag::getInstance()-&gt;PrintAddress(); &#125;); t1.join(); t2.join(); return 0;&#125; 这次输出析构信息 1230x1d620a474200x1d620a47420this is singleton destruct 辅助类智能指针单例模式智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by secon on 2025/3/1.//#ifndef DAY34_SINGLETON_SINGLETON_H#define DAY34_SINGLETON_SINGLETON_H#include &lt;mutex&gt;#include &lt;iostream&gt;#include &lt;memory&gt;class SingleAutoSafe;class SafeDeletor&#123;public: void operator()(SingleAutoSafe *sf) &#123; std::cout &lt;&lt; &quot;this is safe deleter operator()&quot; &lt;&lt; std::endl; delete sf; &#125;&#125;;class SingleAutoSafe&#123;public: static std::shared_ptr&lt;SingleAutoSafe&gt; getInstance()&#123; static std::once_flag flag; std::call_once(flag, []&#123; _instance = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe(), SafeDeletor()); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance &lt;&lt; std::endl; &#125; //定义友元类，通过友元类调用该类析构函数 friend class SafeDeletor;private: SingleAutoSafe() = default; SingleAutoSafe(const SingleAutoSafe&amp;) = delete; SingleAutoSafe&amp; operator=(const SingleAutoSafe&amp; st) = delete; ~SingleAutoSafe() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125; static std::shared_ptr&lt;SingleAutoSafe&gt; _instance;&#125;;#endif //DAY34_SINGLETON_SINGLETON_H 在cpp文件中实现静态成员的定义 1234#include &quot;Singleton.h&quot;std::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::_instance = nullptr; SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。 我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。 并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。 测试 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;Singleton.h&quot;#include &lt;thread&gt;#include &lt;mutex&gt;int main() &#123; system(&quot;chcp 65001 &gt; nul&quot;); std::mutex mtx; std::thread t1([&amp;]()&#123; SingleAutoSafe::getInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingleAutoSafe::getInstance()-&gt;PrintAddress(); &#125;); std::thread t2([&amp;]()&#123; SingleAutoSafe::getInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingleAutoSafe::getInstance()-&gt;PrintAddress(); &#125;); t1.join(); t2.join(); return 0;&#125; 程序输出 1230x1b379b074200x1b379b07420this is safe deleter operator() 通用的单例模板类(CRTP)我们可以通过声明单例的模板类，然后继承这个单例模板类的所有类就是单例类了。达到泛型编程提高效率的目的。 CRTP的概念 CRTP是一种将派生类作为模板参数传递给基类的技术，即一个类继承自一个以自身为模板参数的基类。这种模式常用于实现静态多态、接口的默认实现、编译时策略选择等。 比如 12345678template &lt;typename T&gt;class TempClass &#123; //... &#125;;//CRTPclass RealClass: public TempClass&lt;RealClass&gt;&#123; //... &#125;; 单例基类实现 12345678910111213141516171819202122232425262728293031#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Singleton &#123;protected: Singleton() = default; Singleton(const Singleton&lt;T&gt;&amp;) = delete; Singleton&amp; operator=(const Singleton&lt;T&gt;&amp; st) = delete; static std::shared_ptr&lt;T&gt; _instance;public: static std::shared_ptr&lt;T&gt; GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = shared_ptr&lt;T&gt;(new T); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; endl; &#125; ~Singleton() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr; 我们定义一个网络的单例类，继承上述模板类即可，并将构造和析构设置为私有，同时设置友元保证自己的析构和构造可以被友元类调用. 1234567891011//通过继承方式实现网络模块单例class SingleNet : public Singleton&lt;SingleNet&gt;&#123; friend class Singleton&lt;SingleNet&gt;;private: SingleNet() = default;public: ~SingleNet() &#123; std::cout &lt;&lt; &quot;SingleNet destruct &quot; &lt;&lt; std::endl; &#125;&#125;; 测试案例 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;Singleton.h&quot;#include &lt;thread&gt;#include &lt;mutex&gt;int main() &#123; system(&quot;chcp 65001 &gt; nul&quot;); std::mutex mtx; std::thread t1([&amp;]()&#123; SingleNet::GetInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingleNet::GetInstance()-&gt;PrintAddress(); &#125;); std::thread t2([&amp;]()&#123; SingleNet::GetInstance(); std::lock_guard&lt;std::mutex&gt; lock(mtx); SingleNet::GetInstance()-&gt;PrintAddress(); &#125;); t1.join(); t2.join(); return 0;&#125; 程序输出 12340x212248b74200x212248b7420SingleNet destructthis is singleton destruct 源码和视频视频地址 源码地址","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"引用折叠和原样转发","date":"2025-02-22T01:56:32.000Z","path":"2025/02/22/cppbase32/","text":"1. 左值与右值1.1 定义与分类左值（lvalue）和右值（rvalue）是C++中用于描述表达式值类别的重要概念。 左值（lvalue）： 表示具有持久存储的对象。 可以出现在赋值语句的左侧。 可以被取地址（即，可以使用&amp;运算符）。 示例：变量名、引用等。 右值（rvalue）： 表示临时对象或没有持久存储的值。 通常出现在赋值语句的右侧。 不能被取地址。 示例：字面量、临时对象、表达式结果等。 C++11进一步细化了右值的分类： 纯右值（prvalues）：表示临时对象或字面量，如42、3.14。 将亡值（xvalues，expiring values）：表示即将被移动的对象，如std::move的结果。 1.2 示例代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt;int main() &#123; int a = 10; // a是一个左值 int&amp; b = a; // b是a的左值引用 int&amp;&amp; c = 20; // c是一个右值引用，绑定到临时右值20 int d = a + 5; // (a + 5)是一个纯右值 std::string s1 = &quot;Hello&quot;; // s1是一个左值 std::string s2 = std::string(&quot;World&quot;); // std::string(&quot;World&quot;)是一个纯右值 std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, d: &quot; &lt;&lt; d &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; &quot;, s2: &quot; &lt;&lt; s2 &lt;&lt; std::endl; // 检查类型 std::cout &lt;&lt; std::boolalpha; // 使用 decltype((a)) 获取 a 的类型，包括引用 // `(a)` 是一个左值表达式，所以 decltype((a)) 是 `int&amp;` std::cout &lt;&lt; &quot;a 是左值: &quot; &lt;&lt; std::is_lvalue_reference&lt;decltype((a))&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c 是右值引用: &quot; &lt;&lt; std::is_rvalue_reference&lt;decltype(c)&gt;::value &lt;&lt; std::endl; return 0;&#125; 输出： 1234a: 10, d: 15s1: Hello, s2: Worlda 是左值: truec 是右值引用: true 1.3 类型判断工具C++标准库提供了几个类型特性（type traits）用于判断表达式的值类别： std::is_lvalue_reference&lt;T&gt;：判断类型T是否为左值引用。 std::is_rvalue_reference&lt;T&gt;：判断类型T是否为右值引用。 std::is_lvalue&lt;T&gt;（C++20起）：判断表达式是否为左值。 std::is_rvalue&lt;T&gt;（C++20起）：判断表达式是否为右值。 示例： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;type_traits&gt;void func(int&amp; x) &#123; std::cout &lt;&lt; &quot;func(int&amp;)&quot; &lt;&lt; std::endl;&#125;void func(int&amp;&amp; x) &#123; std::cout &lt;&lt; &quot;func(int&amp;&amp;)&quot; &lt;&lt; std::endl;&#125;int main() &#123; int a = 5; const int&amp; ref = a; // 判断类型 std::cout &lt;&lt; std::boolalpha; // 使用 decltype((a)) 获取 a 的类型，包括引用 // `(a)` 是一个左值表达式，所以 decltype((a)) 是 `int&amp;` std::cout &lt;&lt; &quot;a 是左值: &quot; &lt;&lt; std::is_lvalue_reference&lt;decltype((a))&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ref 是左值引用: &quot; &lt;&lt; std::is_lvalue_reference&lt;decltype(ref)&gt;::value &lt;&lt; std::endl; // 调用函数 func(a); // 调用func(int&amp;) func(10); // 调用func(int&amp;&amp;) return 0;&#125; 输出： 1234a 是左值: trueref 是左值引用: truefunc(int&amp;)func(int&amp;&amp;) 1.4 应用场景理解左值与右值的区别是实现移动语义、完美转发以及高效内存管理的基础。在编写高性能C++代码时，合理利用右值引用和移动语义可以显著提升程序的效率。 2. 模板万能引用（转发引用）2.1 定义与特性模板万能引用（也称为转发引用，英文为forwarding references）是C++11引入的一种引用类型，具有以下特点： 表现形式为T&amp;&amp;，其中T是模板参数。 在特定条件下，编译器会将其解析为左值引用或右值引用。 能够统一处理左值和右值，适用于泛型编程中的参数传递。 重要特性： 当模板参数T被推导为普通类型时，T&amp;&amp;是右值引用。 当模板参数T被推导为引用类型时，T&amp;&amp;会根据引用折叠规则解析为左值引用。 2.2 引用折叠规则引用折叠是C++中的一项规则，用于处理引用类型的嵌套。主要规则如下： &amp; &amp;、&amp; &amp;&amp;、&amp;&amp; &amp; 都折叠为 &amp;（左值引用）。 &amp;&amp; &amp;&amp; 折叠为 &amp;&amp;（右值引用）。 示例： 1234567891011121314151617181920#include &lt;type_traits&gt;#include &lt;iostream&gt;template&lt;typename T&gt;void check_referenc(T&amp;&amp; x)&#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;T is lvalue reference: &quot; &lt;&lt; std::is_lvalue_reference&lt;T&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;T is rvalue reference: &quot; &lt;&lt; std::is_rvalue_reference&lt;T&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;T is rvalue : &quot; &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt; ::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;x is lvalue reference: &quot; &lt;&lt; std::is_lvalue_reference&lt;decltype(x)&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;x is rvalue reference: &quot; &lt;&lt; std::is_rvalue_reference&lt;decltype(x)&gt;::value &lt;&lt; std::endl;&#125;int main() &#123; int a = 10; check_reference(a); // T被推导为 int&amp;， 因此 T&amp;&amp; -&gt; int&amp; &amp;&amp; -&gt; int&amp; check_reference(20); // T被推导为 int， T&amp;&amp; -&gt; int&amp;&amp; return 0;&#125; 输出： 12345678910T is lvalue reference: trueT is rvalue reference: falseT is rvalue : falsex is lvalue reference: truex is rvalue reference: falseT is lvalue reference: falseT is rvalue reference: falseT is rvalue : truex is lvalue reference: falsex is rvalue reference: true 但是要注意，如果如果我这样调用 12int &amp;&amp;c = 100;check_referenc(c); 输出的却是 12345T is lvalue reference: trueT is rvalue reference: falseT is rvalue : falsex is lvalue reference: truex is rvalue reference: false 然而，实际中 T 被推导为 int&amp;，这是因为 命名的右值引用变量在表达式中被视为左值。 关键点： 变量的值类别（Value Category）： 左值（lvalue）：有名称，可以出现在赋值的左侧。 右值（rvalue）：临时的、没有名称的值，一般不能出现在赋值的左侧。 命名的右值引用变量是左值： 虽然 c 的类型是 int&amp;&amp;，但作为一个变量名，它本身是一个左值。 这意味着在表达式中使用 c 时，c 被视为左值，而不是右值。 类型推导规则： 当模板参数使用T&amp;&amp;（被称为转发引用或万能引用）时，类型推导遵循特定规则： 如果传入的是左值，T 被推导为 T&amp;。 如果传入的是右值，T 被推导为 T（非引用类型）。 传入左值（c）： c 是一个命名的右值引用变量，但作为表达式它是左值。 因此，T 被推导为 int&amp;。 T&amp;&amp; 则根据引用折叠规则（int&amp; &amp;&amp; =&gt; int&amp;）。 为了让 T 被推导为右值引用，我们需要传递一个 真正的右值。这可以通过使用 std::move 来实现： 12// std::move(c) 是右值，T 被推导为 intcheck_reference(std::move(c)); 输出 12345T is lvalue reference: falseT is rvalue reference: falseT is rvalue : truex is lvalue reference: falsex is rvalue reference: true **传递右值 std::move(c)**： std::move(c) 将 c 转换为 int&amp;&amp;（右值）。 T 被推导为 int（非引用类型）。 std::is_lvalue_reference&lt;T&gt;::value 为 false。 std::is_rvalue_reference&lt;T&gt;::value 为 false。 std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value 相当于 std::is_rvalue_reference&lt;int&amp;&amp;&gt;::value，为 true。 decltype(x) 相当于 int&amp;&amp;，所以 x 被识别为右值引用。 为什么T被实例化为int而不是int&amp;&amp; 在模板参数中，当一个类型参数 T 以 T&amp;&amp; 的形式出现，并且 T 是模板参数时，T&amp;&amp; 被称为 转发引用（有时称为万能引用）。转发引用具有特殊的类型推导规则： 如果传递的是左值，T 被推导为 T&amp;。 如果传递的是右值，T 被推导为 T（不带引用）。 模板类型推导的具体规则 根据 C++ 标准（C++17 标准草案）： 如果 P 是 T&amp;&amp;，并且 A（实参类型）是一个非引用类型的表达式，则 T 被推导为 A 的类型。 如果 P 是 T&amp;&amp;，并且 A 是一个引用类型的表达式，则去除引用后的类型用于推导。 具体到我们的例子： 传递 c（一个左值，类型 int&amp;&amp;）： 表达式 c 是一个 左值。 当传递左值给 T&amp;&amp; 时，T 被推导为 int&amp;（即 int 加上引用）。 因此，参数类型 T&amp;&amp; 实际上是 int&amp; &amp;&amp;，根据引用折叠规则，int&amp; &amp;&amp; 合并为 int&amp;。 传递 std::move(c)（一个右值，类型 int&amp;&amp;）： 表达式 std::move(c) 是一个 右值。 当传递右值给 T&amp;&amp; 时，T 被推导为 int（不带引用）。 因此，参数类型 T&amp;&amp; 是 int&amp;&amp;。 也可以采用原样转发，达到和move相同的效果 1check_referenc(std::forward&lt;int&amp;&amp;&gt;(c)); 输出 12345T is lvalue reference: falseT is rvalue reference: falseT is rvalue : truex is lvalue reference: falsex is rvalue reference: true 2.3 示例代码以下示例展示了如何使用模板万能引用编写能够接受任意类型参数的函数，并通过转发保持参数的原有值类别。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt;// 目标函数，分别有左值和右值的重载void process(int&amp;x)&#123; std::cout &lt;&lt; &quot;process(int&amp;)&quot; &lt;&lt; std::endl;&#125;void process(int&amp;&amp; x)&#123; std::cout &lt;&lt; &quot;process(int&amp;&amp;)&quot; &lt;&lt; std::endl;&#125;// 通用的包装函数，使用转发引用template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123; process(std::forward&lt;T&gt;(arg)); // 原样转发&#125;int main() &#123; int a = 10; wrapper(a); // 传递左值，调用process(int&amp;) wrapper(20); // 传递右值，调用process(int&amp;&amp;) return 0;&#125; 输出： 12process(int&amp;)process(int&amp;&amp;) 在上述代码中，wrapper函数使用模板万能引用T&amp;&amp;接收参数，通过std::forward&lt;T&gt;(arg)实现原样转发，确保传递给process函数的参数保持其原有的值类别。 如果我们把wrapper改为 12345// 通用的包装函数，使用转发引用template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123; process(arg); // 原样转发&#125; 调用 123456int main() &#123; int a = 10; wrapper(a); // 传递左值，调用process(int&amp;) wrapper(20); // 传递右值，调用process(int&amp;&amp;) return 0;&#125; 则输出 12process(int&amp;)process(int&amp;) 因为虽然wrapper(20)调用时会将T实例化为int类型, arg变为int &amp;&amp; 类型，但是arg本身是一个左值, 所以调用process会选择左值引用版本 1234// 目标函数void process(int&amp;x)&#123; std::cout &lt;&lt; &quot;process(int&amp;)&quot; &lt;&lt; std::endl;&#125; 3. 类型推导（Type Deduction）3.1 类型推导规则在C++模板编程中，类型推导是指编译器根据传入的实参自动推导模板参数的类型。类型推导遵循以下基本规则： 模板参数的推导： 当模板参数与函数参数进行匹配时，编译器会根据实参类型推导出模板参数类型T。 引用的处理： 如果函数参数采用右值引用（如T&amp;&amp;），且传递的是左值，则T会被推导为左值引用类型。 如果传递的是右值，则T会被推导为非引用类型。 cv限定符的去除： 类型推导会去除顶层的const和volatile修饰。 3.2 与引用的关系在模板参数中使用引用类型时，类型推导会涉及引用折叠规则。例如，当一个模板函数参数为T&amp;或T&amp;&amp;时，传入参数的值类别会影响T的推导结果。 示例： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;type_traits&gt;template&lt;typename T&gt;void deduce_type(T&amp;&amp;) &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Is T an lvalue reference? &quot; &lt;&lt; std::is_lvalue_reference&lt;T&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Is T an rvalue reference? &quot; &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value &lt;&lt; std::endl;&#125;int main() &#123; int a = 5; const int&amp; ref = a; deduce_type(a); // T被推导为 int&amp; deduce_type(10); // T被推导为 int deduce_type(ref); // T被推导为 const int&amp; deduce_type(std::move(a)); // T被推导为 int return 0;&#125; 输出： 12345678Is T an lvalue reference? trueIs T an rvalue reference? falseIs T an lvalue reference? falseIs T an rvalue reference? trueIs T an lvalue reference? trueIs T an rvalue reference? falseIs T an lvalue reference? falseIs T an rvalue reference? true 3.3 示例代码以下示例展示了不同情况下模板参数T的推导结果，以及如何利用类型推导编写通用函数。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;type_traits&gt;template&lt;typename T&gt;void display_type(T&amp;&amp; param) &#123; std::cout &lt;&lt; &quot;Type of T: &quot; &lt;&lt; (std::is_lvalue_reference&lt;T&gt;::value ? &quot;lvalue reference&quot; : &quot;rvalue reference&quot;) &lt;&lt; &quot;, &quot; &lt;&lt; (std::is_integral&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value ? &quot;Integral&quot; : &quot;Non-Integral&quot;) &lt;&lt; std::endl;&#125;int main() &#123; int x = 10; const int&amp; y = x; display_type(x); // T被推导为 int&amp; display_type(20); // T被推导为 int&amp;&amp; display_type(y); // T被推导为 const int&amp; display_type(std::move(x)); // T被推导为 int&amp;&amp; return 0;&#125; 输出： 1234Type of T: lvalue reference, IntegralType of T: rvalue reference, IntegralType of T: lvalue reference, IntegralType of T: rvalue reference, Integral 在此示例中，通过模板函数display_type，我们可以观察到不同参数传递方式下，模板参数T的推导结果。 4. 原样转发（Perfect Forwarding）4.1 定义与作用原样转发（Perfect Forwarding）是指在模板函数中，将接收到的参数以其原有的值类别（左值或右值）传递给另一个函数。这项技术确保了泛型代码能够像手写特定代码那样高效和正确地处理参数。 作用： 保持参数的值类别，确保正确调用函数重载。 利用移动语义，避免不必要的拷贝，提升性能。 编写通用、复用性强的代码。 4.2 实现原理原样转发通常结合模板万能引用（转发引用）和std::forward来实现。具体流程如下： 使用模板万能引用（T&amp;&amp;）接收参数。 使用 1std::forward&lt;T&gt;(arg) 将参数转发给目标函数。 std::forward根据T的类型，将参数转换为左值或右值。 如果参数原本是左值，std::forward返回左值引用。 如果参数原本是右值，std::forward返回右值引用。 4.3 为什么需要原样转发在泛型编程中，函数模板可能需要将接收到的参数传递给其他函数。若不使用原样转发，参数会失去原有的值类别信息，可能导致以下问题： 右值参数被当作左值处理，无法利用移动语义，导致性能下降。 无法正确调用目标函数的重载版本。 增加不必要的拷贝开销，影响程序性能。 通过原样转发，可以确保参数在传递过程中保持其原有的左值或右值特性，提升代码的效率和灵活性。 4.4 示例代码以下示例展示了如何实现一个通用的wrapper函数，通过原样转发将参数传递给目标函数，同时保留参数的值类别。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt;// 目标函数，分别有左值和右值的重载void process(const std::string&amp; s) &#123; std::cout &lt;&lt; &quot;Processing lvalue: &quot; &lt;&lt; s &lt;&lt; std::endl;&#125;void process(std::string&amp;&amp; s) &#123; std::cout &lt;&lt; &quot;Processing rvalue: &quot; &lt;&lt; s &lt;&lt; std::endl;&#125;// 通用的包装函数，实现原样转发template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123; process(std::forward&lt;T&gt;(arg));&#125;int main() &#123; std::string name = &quot;Alice&quot;; wrapper(name); // 传递左值，调用process(const std::string&amp;) wrapper(&quot;Bob&quot;); // 传递右值，调用process(std::string&amp;&amp;) wrapper(std::move(name)); // 传递右值，调用process(std::string&amp;&amp;) return 0;&#125; 输出： 123Processing lvalue: AliceProcessing rvalue: BobProcessing rvalue: Alice 在上述代码中： wrapper(name)传递的是左值，T被推导为std::string&amp;，std::forward保持其为左值引用，调用process(const std::string&amp;)。 wrapper(&quot;Bob&quot;)传递的是右值，T被推导为const char*，在process函数重载的选择上，这里简单化处理为调用接收右值的版本（视具体实现而定）。 wrapper(std::move(name))传递的是右值，T被推导为std::string，std::forward将其转换为右值引用，调用process(std::string&amp;&amp;)。 4.5 泛型工厂函数示例以下示例展示了如何使用原样转发实现一个泛型工厂函数，完美转发构造函数的参数，以高效创建对象。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt;// 类的定义class Person &#123;public: std::string name; int age; // 左值引用构造函数 Person(const std::string&amp; n, int a) : name(n), age(a) &#123; std::cout &lt;&lt; &quot;Constructed Person(const std::string&amp;, int)&quot; &lt;&lt; std::endl; &#125; // 右值引用构造函数 Person(std::string&amp;&amp; n, int a) : name(std::move(n)), age(a) &#123; std::cout &lt;&lt; &quot;Constructed Person(std::string&amp;&amp;, int)&quot; &lt;&lt; std::endl; &#125;&#125;;// 工厂函数，使用原样转发构造函数参数template&lt;typename T, typename... Args&gt;T create(Args&amp;&amp;... args) &#123; return T(std::forward&lt;Args&gt;(args)...);&#125;int main() &#123; std::string name = &quot;Alice&quot;; // 传递左值 Person p1 = create&lt;Person&gt;(name, 30); // 传递右值 Person p2 = create&lt;Person&gt;(std::string(&quot;Bob&quot;), 25); return 0;&#125; 输出： 12Constructed Person(const std::string&amp;, int)Constructed Person(std::string&amp;&amp;, int) 在此示例中： create&lt;Person&gt;(name, 30)传递的是左值，调用Person(const std::string&amp;, int)构造函数。 create&lt;Person&gt;(std::string(&quot;Bob&quot;), 25)传递的是右值，调用Person(std::string&amp;&amp;, int)构造函数。 通过原样转发，create函数能够根据传入参数的值类别，调用相应的构造函数，实现高效的对象创建。 4.6 避免不必要的拷贝以下示例展示了如果不使用原样转发，可能导致的多次拷贝问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;// 类的定义class BigObject &#123;public: std::string data; BigObject(const std::string&amp; d) : data(d) &#123; std::cout &lt;&lt; &quot;BigObject constructed with lvalue&quot; &lt;&lt; std::endl; &#125; BigObject(std::string&amp;&amp; d) : data(std::move(d)) &#123; std::cout &lt;&lt; &quot;BigObject constructed with rvalue&quot; &lt;&lt; std::endl; &#125;&#125;;// 处理函数，左值和右值的重载void process(const BigObject&amp; obj) &#123; std::cout &lt;&lt; &quot;Processing lvalue BigObject&quot; &lt;&lt; std::endl;&#125;void process(BigObject&amp;&amp; obj) &#123; std::cout &lt;&lt; &quot;Processing rvalue BigObject&quot; &lt;&lt; std::endl;&#125;// 包装函数，不使用原样转发template&lt;typename T&gt;void bad_wrapper(T&amp;&amp; obj) &#123; process(obj); // 始终以左值形式传递&#125;// 包装函数，使用原样转发template&lt;typename T&gt;void good_wrapper(T&amp;&amp; obj) &#123; process(std::forward&lt;T&gt;(obj)); // 原样转发&#125;int main() &#123; std::string s = &quot;Sample data&quot;; // 使用bad_wrapper BigObject bo1 = BigObject(s); // 使用lvalue构造 BigObject bo2 = BigObject(std::move(s)); // 使用rvalue构造 bad_wrapper(bo1); // 始终作为左值处理 bad_wrapper(BigObject(&quot;Temp&quot;)); // 作为左值处理，浪费移动语义 // 使用good_wrapper good_wrapper(bo1); // 作为左值处理 good_wrapper(BigObject(&quot;Temp&quot;)); // 作为右值处理，利用移动语义 return 0;&#125; 输出： 123456BigObject constructed with lvalueBigObject constructed with rvalueProcessing lvalue BigObjectProcessing lvalue BigObjectBigObject constructed with rvalueProcessing rvalue BigObject 在此示例中： bad_wrapper函数不使用std::forward，导致即使传递的是右值，process函数也以左值形式接收，无法利用移动语义。 good_wrapper函数使用std::forward，正确保持参数的值类别，允许process函数调用右值重载，从而利用移动语义，提高性能。 5. forward源码剖析std::forward之所以能进行原样转发，我们来看一下源码，std::forward实现了两个版本 返回左值引用版本 12345template&lt;typename _Tp&gt; _GLIBCXX_NODISCARD constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept &#123; return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125; 重点解释1. _GLIBCXX_NODISCARD _GLIBCXX_NODISCARD 是一个宏，通常定义在 **libstdc++**（GNU的C++标准库实现）中，用于指示编译器不要忽略函数的返回值。具体来说，它通常被定义为 C++17 引入的 [[nodiscard]] 属性，或者对应的编译器特定属性。 [[nodiscard]] 属性：这是C++17引入的一个属性，用于标记函数的返回值不应该被忽略。如果调用该函数的返回值被忽略，编译器会发出警告。例如： 12345[[nodiscard]] int compute() &#123; return 42; &#125;void example() &#123; compute(); // 编译器会发出警告，因为返回值被忽略&#125; 在_GLIBCXX_NODISCARD中的作用：通过使用这个宏，forward函数的设计者告诉编译器和使用者：调用 forward 时，返回值不应该被忽略，因为它在转发参数时起到了关键作用。如果返回值被忽略，可能会导致意想不到的行为或性能问题。 总结：_GLIBCXX_NODISCARD 确保使用 forward 时，返回的转发结果不会被无意中忽略，增强代码的安全性和正确性。 2. constexpr constexpr 是C++11引入的一个关键字，用于指示一个函数或变量可以在编译时求值。 在函数中的作用： 编译时计算：constexpr 函数可以在编译时被求值，如果传入的参数也都是编译时常量。 优化性能：通过在编译时进行计算，可以减少运行时的开销，提高程序的性能。 在 forward 函数中的作用： 高效实现：forward 是一个轻量级的操作，通常涉及简单的静态类型转换（如 static_cast）。将其定义为 constexpr 允许编译器在可能的情况下在编译时完成这些转换，从而避免不必要的运行时开销。 支持常量表达式：如果在编译时上下文中使用 forward，例如在 constexpr 函数中，它能够在编译时正确地转发参数。 总结：constexpr 使得 forward 函数能够在编译时进行优化，同时确保在运行时不引入额外的开销。 3. remove_reference作用 源码分析 1234567891011template&lt;typename _Tp&gt; struct remove_reference &#123; using type = _Tp; &#125;;template&lt;typename _Tp&gt; struct remove_reference&lt;_Tp&amp;&gt; &#123; using type = _Tp; &#125;;template&lt;typename _Tp&gt; struct remove_reference&lt;_Tp&amp;&amp;&gt; &#123; using type = _Tp; &#125;; 根据模板就近匹配规则，会按照最相似的方式进行匹配，优先匹配特例化版本，比如 remove_reference&lt;int&gt; 会调用第一个版本 remove_reference&lt;int&amp;&gt;会调用第二个版本(特例化) remove_reference&lt;int&amp;&amp;&gt;会调用第三个版本 所以我们对比这三个版本 123remove_reference&lt;int&gt;::type;remove_reference&lt;int&amp;&gt;::type;remove_reference&lt;int&amp;&amp;&gt;::type; 这三个版本的type都为int，这样达到了去引用的效果。 所以带入 1typename std::remove_reference&lt;_Tp&gt;::type&amp; __t 我们可以指导__t一定是个左值引用类型。 原样转发内幕 此时我们考虑对一个左值引用类型(int&amp; )参数执行forward函数 12345template&lt;typename _Tp&gt; _GLIBCXX_NODISCARD constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept &#123; return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125; 函数各部分解释： **模板参数 typename _Tp**： 定义了一个模板类型参数 _Tp，表示要转发的类型。 **typename std::remove_reference&lt;_Tp&gt;::type&amp; __t**： 使用 std::remove_reference 去除 _Tp 的引用性质，然后以左值引用的形式接受参数。 **static_cast&lt;_Tp&amp;&amp;&gt;(__t)**： 通过 static_cast 将参数转换为 _Tp 类型的右值引用。这是实现完美转发的关键步骤，使得被转发的参数保留其原有的值类别。 **noexcept**： 指明函数不会抛出异常，有助于编译器进行优化，并提高代码的异常安全性。 __t为int&amp;类型，TP被实例化为int&amp;, 通过引用折叠 1int&amp; std::forward&lt;int&amp;&gt;(arg) 达到了原样转发的目的。 **模板参数 typename _Tp**： 定义了一个模板类型参数 _Tp，表示要转发的类型。 同样我们分析右值引用类型原样转发原理 返回右值引用版本 123456789template&lt;typename _Tp&gt; _GLIBCXX_NODISCARD constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept &#123; static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;std::forward must not be used to convert an rvalue to an lvalue&quot;); return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125; 这里限制了不能将右值引用转化为左值引用。 __t是右值引用类型，当我们执行如下 1int&amp;&amp; forward&lt;int&amp;&amp;&gt;(args) _Tp被实例化为int&amp;&amp;, 返回类型通过折叠变为int&amp;&amp; , 参数__t变为int&amp;&amp;类型 6. move源码解析std::move源码 12345template&lt;typename _Tp&gt; _GLIBCXX_NODISCARD constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; move(_Tp&amp;&amp; __t) noexcept &#123; return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); &#125; 可以看到move的实现很简单，无论__t是左值引用还是右值引用，都会通过 1static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t) 强制转换为去除引用的type, 再加上&amp;&amp;的类型，也就是具体的右值引用类型。 7. 总结 左值与右值：理解值类别是掌握C++移动语义、资源管理和高效编程的基础。左值代表具有持久存储的对象，而右值通常是临时对象。 模板万能引用（转发引用）：通过T&amp;&amp;形式的模板参数，可以统一处理左值和右值，适用于泛型编程中的参数传递。引用折叠规则决定了T&amp;&amp;在不同上下文中的解析方式。 类型推导：编译器根据实参自动推导模板参数类型，涉及引用类型时需要理解引用折叠规则和类型推导的细节。 原样转发（Perfect Forwarding）：结合模板万能引用和std::forward，确保在泛型函数中将参数以其原有值类别传递给目标函数，避免不必要的拷贝，提升代码效率和灵活性。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"DeepSeek-R1本地部署知识库","date":"2025-02-08T12:08:17.000Z","path":"2025/02/08/AI01/","text":"视频教程考虑大家看文档会比较吃力，可以参考我的视频教程 https://www.bilibili.com/video/BV1GkNyeDEpK/?pop_share=1&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 DeepSeek简介深度求索人工智能基础技术研究有限公司(简称“深度求索”或“DeepSeek”)，成立于2023年，是一家专注于实现AGI的中国公司。 产品DeepSeek为一款AI工具，可以解析文本，生成代码，推理解析等。 模型 &amp; 价格下表所列模型价格以“百万 tokens”为单位。Token 是模型用来表示自然语言文本的的最小单位，可以是一个词、一个数字或一个标点符号等。我们将根据模型输入和输出的总 token 数进行计量计费。 模型(1) 上下文长度 最大思维链长度(2) 最大输出长度(3) 百万tokens 输入价格 （缓存命中）(4) 百万tokens 输入价格 （缓存未命中） 百万tokens 输出价格 输出价格 deepseek-chat 64K - 8K 0.5元 2元 8元 deepseek-reasoner 64K 32K 8K 1元 4元 16元(5) deepseek-chat 模型已经升级为 DeepSeek-V3；deepseek-reasoner 模型为新模型 DeepSeek-R1。 思维链为deepseek-reasoner模型在给出正式回答之前的思考过程，其原理详见推理模型。 如未指定 max_tokens，默认最大输出长度为 4K。请调整 max_tokens 以支持更长的输出。 关于上下文缓存的细节，请参考DeepSeek 硬盘缓存。 deepseek-reasoner的输出 token 数包含了思维链和最终答案的所有 token，其计价相同。 性能对齐 OpenAI-o1 正式版DeepSeek-R1 在后训练阶段大规模使用了强化学习技术，在仅有极少标注数据的情况下，极大提升了模型推理能力。在数学、代码、自然语言推理等任务上，性能比肩 OpenAI o1 正式版。 蒸馏小模型超越 OpenAI o1-mini在开源 DeepSeek-R1-Zero 和 DeepSeek-R1 两个 660B 模型的同时，通过 DeepSeek-R1 的输出，蒸馏了 6 个小模型开源给社区，其中 32B 和 70B 模型在多项能力上实现了对标 OpenAI o1-mini 的效果。 API 及定价DeepSeek-R1 API 服务定价为每百万输入 tokens 1 元（缓存命中）/ 4 元（缓存未命中），每百万输出 tokens 16 元。 详细的 API 调用指南请参考官方文档： https://api-docs.deepseek.com/zh-cn/guides/reasoning_model 本地部署Ollama 官方版：【点击前往】 下载windows版本并安装 我在windows做测试，然后部署 安装命令 1.5B Qwen DeepSeek R1(需4G显存) 1ollama run deepseek-r1:1.5b 7B Qwen DeepSeek R1(4~12G显存) 1ollama run deepseek-r1:7b 8B Llama DeepSeek R1(4~12G显存) 1ollama run deepseek-r1:8b 14B Qwen DeepSeek R1(12~24G显存) 1ollama run deepseek-r1:14b 32B Qwen DeepSeek R1(24G显存) 1ollama run deepseek-r1:32b 70B Llama DeepSeek R1(32G显存以上) 1ollama run deepseek-r1:70b 我们选择1.5b模型安装 安装成功 AnythingLLM 下载 1、Github 开源版 【点击下载】 2、官方版：【点击下载】 我们选择开源版下载，拉到最下面有markdown文档 点击DownloadNow, 选择x64版本下载 下载完成，安装 安装完成 点击完成自动运行 点击Get started，然后一路跳过 记得填写邮箱和使用目的 然后再填写工作区 点击右侧箭头完成，进入使用界面，如果此时使用会出现模型未设置 点击设置按钮，选择聊天选项，接下来选择模型 设置模型为ollama 设置后 记得更新 注意：本地部署也是支持开启联网搜索模式的 点击设置按钮 只需在AnythingLLM的设置界面中，找到“代理技能”选项。 启用Web Search：在代理技能列表中找到 Web Search ，点击开启。 选择搜索引擎即可！ 如下图所示: 测试测试代码生成能力 测试检索能力 测试推理能力","categories":[{"name":"AI","slug":"AI","permalink":"http://www.limerence2017.com/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://www.limerence2017.com/tags/AI/"}]},{"title":"模板详解","date":"2025-01-29T12:43:45.000Z","path":"2025/01/29/cppbase31/","text":"模板基础C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。 函数模板函数模板允许编写通用的函数，通过类型参数化，使其能够处理不同的数据类型。它通过模板参数定义与类型无关的函数。 语法： 1234template &lt;typename T&gt;T functionName(T param) &#123; // 函数体&#125; 示例：最大值函数 12345678910111213#include &lt;iostream&gt;template &lt;typename T&gt;T maxValue(T a, T b) &#123; return (a &gt; b) ? a : b;&#125;int main() &#123; std::cout &lt;&lt; maxValue(3, 7) &lt;&lt; std::endl; // int 类型 std::cout &lt;&lt; maxValue(3.14, 2.72) &lt;&lt; std::endl; // double 类型 std::cout &lt;&lt; maxValue(&#x27;a&#x27;, &#x27;z&#x27;) &lt;&lt; std::endl; // char 类型 return 0;&#125; 输出： 12373.14z 要点： 模板参数列表以 template &lt;typename T&gt; 或 template &lt;class T&gt; 开头，两者等价。 类型推导：编译器根据函数参数自动推导模板参数类型。 类模板类模板允许定义通用的类，通过类型参数化，实现不同类型的对象。 语法： 123456template &lt;typename T&gt;class ClassName &#123;public: T memberVariable; // 构造函数、成员函数等&#125;; 示例：简单的 Pair 类 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename T, typename U&gt;class Pair &#123;public: T first; U second; Pair(T a, U b) : first(a), second(b) &#123;&#125; void print() const &#123; std::cout &lt;&lt; &quot;Pair: &quot; &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Pair&lt;int, double&gt; p1(1, 2.5); p1.print(); // 输出：Pair: 1, 2.5 Pair&lt;std::string, std::string&gt; p2(&quot;Hello&quot;, &quot;World&quot;); p2.print(); // 输出：Pair: Hello, World Pair&lt;std::string, int&gt; p3(&quot;Age&quot;, 30); p3.print(); // 输出：Pair: Age, 30 return 0;&#125; 输出： 123Pair: 1, 2.5Pair: Hello, WorldPair: Age, 30 要点： 类模板可以有多个类型参数。 模板参数可以被用于成员变量和成员函数中。 类模板实例化时指定具体类型，如 Pair&lt;int, double&gt;。 模板参数模板参数决定了模板的泛用性与灵活性。C++ 模板参数种类主要包括类型参数、非类型参数和模板模板参数。 类型参数（Type Parameters）类型参数用于表示任意类型，在模板实例化时被具体的类型替代。 示例： 12345template &lt;typename T&gt;class MyClass &#123;public: T data;&#125;; 非类型参数（Non-Type Parameters）非类型参数允许模板接受非类型的值，如整数、指针或引用。C++17 支持更多非类型参数类型，如 auto。 语法： 12345template &lt;typename T, int N&gt;class FixedArray &#123;public: T data[N];&#125;; 示例：固定大小的数组类 12345678910111213141516171819202122232425#include &lt;iostream&gt;template &lt;typename T, std::size_t N&gt;class FixedArray &#123;public: T data[N]; T&amp; operator[](std::size_t index) &#123; return data[index]; &#125; void print() const &#123; for(std::size_t i = 0; i &lt; N; ++i) std::cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; &#125;&#125;;int main() &#123; FixedArray&lt;int, 5&gt; arr; for(int i = 0; i &lt; 5; ++i) arr[i] = i * 10; arr.print(); // 输出：0 10 20 30 40 return 0;&#125; 输出： 10 10 20 30 40 注意事项： 非类型参数必须是编译期常量。 允许的类型包括整型、枚举、指针、引用等，但不包括浮点数和类类型。 模板模板参数（Template Template Parameters）模板模板参数允许模板接受另一个模板作为参数。这对于抽象容器和策略模式等场景非常有用。 语法： 12template &lt;template &lt;typename, typename&gt; class Container&gt;class MyClass &#123; /* ... */ &#125;; 示例：容器适配器 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;template &lt;template &lt;typename, typename&gt; class Container, typename T&gt;class ContainerPrinter &#123;public: void print(const Container&lt;T, std::allocator&lt;T&gt;&gt;&amp; container) &#123; for(const auto&amp; elem : container) std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;; std::list&lt;int&gt; lst = &#123;10, 20, 30&#125;; ContainerPrinter&lt;std::vector, int&gt; vecPrinter; vecPrinter.print(vec); // 输出：1 2 3 4 5 ContainerPrinter&lt;std::list, int&gt; listPrinter; listPrinter.print(lst); // 输出：10 20 30 return 0;&#125; 输出： 121 2 3 4 5 10 20 30 要点： 模板模板参数需要完全匹配被接受模板的参数列表。 可通过默认模板参数增强灵活性。 模板特化（Template Specialization）模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持全特化（Full Specialization）**和**偏特化（Partial Specialization）**，但需要注意的是，函数模板不支持偏特化**，只能进行全特化。 全特化（Full Specialization）全特化是针对模板参数的完全特定类型组合。它提供了模板的一个特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。 语法1234567891011// 通用模板template &lt;typename T&gt;class MyClass &#123; // 通用实现&#125;;// 全特化template &lt;&gt;class MyClass&lt;SpecificType&gt; &#123; // 针对 SpecificType 的实现&#125;; 示例：类模板全特化123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;// 通用类模板template &lt;typename T&gt;class Printer &#123;public: void print(const T&amp; value) &#123; std::cout &lt;&lt; &quot;General Printer: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;// 类模板全特化template &lt;&gt;class Printer&lt;std::string&gt; &#123;public: void print(const std::string&amp; value) &#123; std::cout &lt;&lt; &quot;String Printer: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Printer&lt;int&gt; intPrinter; intPrinter.print(100); // 输出：General Printer: 100 Printer&lt;std::string&gt; stringPrinter; stringPrinter.print(&quot;Hello, World!&quot;); // 输出：String Printer: Hello, World! return 0;&#125; 输出： 12General Printer: 100String Printer: Hello, World! 解析 通用模板适用于所有类型，在print函数中以通用方式输出值。 全特化模板针对std::string类型进行了专门化，实现了不同的print函数。 当实例化Printer&lt;std::string&gt;时，编译器选择全特化版本而非通用模板。 偏特化（Partial Specialization）偏特化允许模板对部分参数进行特定类型的处理，同时保持其他参数的通用性。对于类模板而言，可以针对模板参数的某些特性进行偏特化；对于函数模板，则仅支持全特化，不支持偏特化。 语法1234567891011// 通用模板template &lt;typename T, typename U&gt;class MyClass &#123; // 通用实现&#125;;// 偏特化：当 U 是指针类型时template &lt;typename T, typename U&gt;class MyClass&lt;T, U*&gt; &#123; // 针对 U* 的实现&#125;; 示例：类模板偏特化1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;// 通用 Pair 类模板template &lt;typename T, typename U&gt;class Pair &#123;public: T first; U second; Pair(T a, U b) : first(a), second(b) &#123;&#125; void print() const &#123; std::cout &lt;&lt; &quot;Pair: &quot; &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; std::endl; &#125;&#125;;// 类模板偏特化：当第二个类型是指针时template &lt;typename T, typename U&gt;class Pair&lt;T, U*&gt; &#123;public: T first; U* second; Pair(T a, U* b) : first(a), second(b) &#123;&#125; void print() const &#123; std::cout &lt;&lt; &quot;Pair with pointer: &quot; &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; *second &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Pair&lt;int, double&gt; p1(1, 2.5); p1.print(); // 输出：Pair: 1, 2.5 double value = 3.14; Pair&lt;std::string, double*&gt; p2(&quot;Pi&quot;, &amp;value); p2.print(); // 输出：Pair with pointer: Pi, 3.14 return 0;&#125; 输出： 12Pair: 1, 2.5Pair with pointer: Pi, 3.14 解析 通用模板处理非指针类型对。 偏特化模板处理第二个类型为指针的情况，打印指针指向的值。 使用偏特化提升了模板的灵活性，使其能够根据部分参数类型进行不同处理。 函数模板的特化与类模板不同，函数模板不支持偏特化，只能进行全特化。当对函数模板进行全特化时，需要显式指定类型。 示例：函数模板全特化123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;// 通用函数模板template &lt;typename T&gt;void printValue(const T&amp; value) &#123; std::cout &lt;&lt; &quot;General print: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;// 函数模板全特化template &lt;&gt;void printValue&lt;std::string&gt;(const std::string&amp; value) &#123; std::cout &lt;&lt; &quot;Specialized print for std::string: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123; printValue(42); // 调用通用模板，输出：General print: 42 printValue(3.14); // 调用通用模板，输出：General print: 3.14 printValue(std::string(&quot;Hello&quot;)); // 调用全特化模板，输出：Specialized print for std::string: Hello return 0;&#125; 输出： 123General print: 42General print: 3.14Specialized print for std::string: Hello 解析 通用函数模板适用于所有类型，提供通用的printValue实现。 全特化函数模板专门处理std::string类型，提供不同的输出格式。 调用printValue时，编译器根据实参类型选择适当的模板版本。 注意事项 优先级：全特化版本的优先级高于通用模板，因此当特化条件满足时，总是选择特化版本。 显式指定类型：函数模板特化需要在调用时显式指定类型，或者确保类型推导可以正确匹配特化版本。 不支持偏特化：无法通过偏特化对函数模板进行部分特化，需要通过其他方法（如重载）实现类似功能。 总结 全特化适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。 偏特化仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。 函数模板仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。 特化模板提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。 变参模板（Variadic Templates）变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 std::tuple、std::variant 等模板库组件的基础。 定义与语法变参模板使用 参数包（Parameter Pack），通过 ... 语法来表示。 语法： 12345template &lt;typename... Args&gt;class MyClass &#123; /* ... */ &#125;;template &lt;typename T, typename... Args&gt;void myFunction(T first, Args... args) &#123; /* ... */ &#125; 递归与展开（Recursion and Expansion）变参模板通常与递归相结合，通过递归地处理参数包，或者使用 折叠表达式（Fold Expressions） 来展开发参数包。 递归示例：打印所有参数 123456789101112131415161718#include &lt;iostream&gt;// 基础情况：无参数void printAll() &#123; std::cout &lt;&lt; std::endl;&#125;// 递归情况：至少一个参数template &lt;typename T, typename... Args&gt;void printAll(const T&amp; first, const Args&amp;... args) &#123; std::cout &lt;&lt; first &lt;&lt; &quot; &quot;; printAll(args...); // 递归调用&#125;int main() &#123; printAll(1, 2.5, &quot;Hello&quot;, &#x27;A&#x27;); // 输出：1 2.5 Hello A return 0;&#125; 输出： 11 2.5 Hello A 折叠表达式版本 1234567891011121314#include &lt;iostream&gt;// 使用折叠表达式的printAlltemplate &lt;typename... Args&gt;void printAll(const Args&amp;... args) &#123; // 使用左折叠展开参数包，并在每个参数之后输出一个空格 ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...); std::cout &lt;&lt; std::endl;&#125;int main() &#123; printAll(1, 2.5, &quot;Hello&quot;, &#x27;A&#x27;); // 输出：1 2.5 Hello A return 0;&#125; 折叠表达式示例：计算总和 C++17 引入了折叠表达式，简化了参数包的处理。 123456789101112#include &lt;iostream&gt;template &lt;typename... Args&gt;auto sum(Args... args) -&gt; decltype((args + ...)) &#123; return (args + ...); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; std::endl; // 输出：10 std::cout &lt;&lt; sum(1.5, 2.5, 3.0) &lt;&lt; std::endl; // 输出：7 return 0;&#125; 输出： 12107 应用示例示例：日志记录器 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;// 基础情况：无参数void log(const std::string&amp; msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl;&#125;// 递归情况：至少一个参数template &lt;typename T, typename... Args&gt;void log(const std::string&amp; msg, const T&amp; first, const Args&amp;... args) &#123; std::cout &lt;&lt; msg &lt;&lt; &quot;: &quot; &lt;&lt; first &lt;&lt; &quot; &quot;; log(&quot;&quot;, args...); // 递归调用，省略消息前缀&#125;int main() &#123; log(&quot;Error&quot;, 404, &quot;Not Found&quot;); // 输出：Error: 404 Not Found log(&quot;Sum&quot;, 10, 20, 30); // 输出：Sum: 10 20 30 return 0;&#125; 输出： 12Error: 404 Not Found Sum: 10 20 30 要点： 变参模板极大地提升了模板的灵活性。 使用递归或折叠表达式处理参数包。 常用于实现通用函数、容器类和元编程工具。 模板折叠（Fold Expressions）1. 折叠表达式的概念与背景在C++中，可变参数模板允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。 折叠表达式的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。 折叠表达式可分为： 一元折叠表达式（Unary Fold）：对参数包中的每个参数应用一个一元操作符。 二元折叠表达式（Binary Fold）：对参数包中的每个参数应用一个二元操作符。 此外，二元折叠表达式可进一步细分为**左折叠（Left Fold）**和**右折叠（Right Fold）**，取决于操作符的结合方向。 2. 一元折叠表达式（Unary Fold）一元折叠表达式用于在参数包的每个参数前或后应用一元操作符。语法形式如下： 前置一元折叠（Unary Prefix Fold） 1(op ... pack) 后置一元折叠（Unary Postfix Fold） 1(pack ... op) 其中，op 是一元操作符，如!（逻辑非）、~（按位取反）等。 示例1：逻辑非操作 12345678#include &lt;iostream&gt;//对每个参数非操作，然后再将这些操作&amp;&amp;//(!args &amp;&amp; ...) 相当于 !a &amp;&amp; !b &amp;&amp; ...template&lt;typename... Args&gt;bool allNot(const Args&amp;... args)&#123; return (!args &amp;&amp; ...);&#125; 3. 二元折叠表达式（Binary Fold）二元折叠表达式用于在参数包的每个参数之间应用一个二元操作符。它们可以分为**二元左折叠（Binary Left Fold）**和**二元右折叠（Binary Right Fold）**，取决于操作符的结合方向。 二元折叠表达式语法 二元左折叠（Left Fold）： 1(init op ... op pack) 或者简化为： 1(pack1 op ... op packN) 二元右折叠（Right Fold）： 1(pack1 op ... op init op ...) 或者简化为： 1(pack1 op ... op packN) 其中，op 是二元操作符，如+、*、&amp;&amp;、||、&lt;&lt; 等。 左折叠与右折叠的区别 二元左折叠（Binary Left Fold）：操作符从左至右结合，等价于 (((a op b) op c) op d)。 二元右折叠（Binary Right Fold）：操作符从右至左结合，等价于 (a op (b op (c op d)))。 示例1：求和（Binary Left Fold） 123456789101112#include &lt;iostream&gt;// 二元左折叠：((arg1 + arg2) + arg3) + ... + argNtemplate&lt;typename... Args&gt;auto sumLeftFold(const Args&amp;... args) &#123; return (args + ...); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; sumLeftFold(1, 2, 3, 4) &lt;&lt; std::endl; // 输出：10 return 0;&#125; 解释： (args + ...) 是一个二元左折叠表达式。 它将+操作符逐个应用于参数，按照左折叠顺序。 即，((1 + 2) + 3) + 4 = 10。 示例2：乘积（Binary Right Fold） 123456789101112#include &lt;iostream&gt;// 二元右折叠：arg1 * (arg2 * (arg3 * ... * argN))template&lt;typename... Args&gt;auto productRightFold(const Args&amp;... args) &#123; return (... * args); // 右折叠&#125;int main() &#123; std::cout &lt;&lt; productRightFold(2, 3, 4) &lt;&lt; std::endl; // 输出：24 return 0;&#125; 解释： (... \\* args) 是一个二元右折叠表达式。 它将*操作符逐个应用于参数，按照右折叠顺序。 即，2 * (3 * 4) = 2 * 12 = 24。 示例3：逻辑与（Binary Left Fold） 12345678910111213#include &lt;iostream&gt;template&lt;typename... Args&gt;bool allTrue(const Args&amp;... args) &#123; return (args &amp;&amp; ...); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; allTrue(true, true, false) &lt;&lt; std::endl; // 输出：false std::cout &lt;&lt; allTrue(true, true, true) &lt;&lt; std::endl; // 输出：true return 0;&#125; 解释： (args &amp;&amp; ...) 是一个二元左折叠表达式。 用于检查所有参数是否为true。 类似于链式的逻辑与运算。 4. 左折叠与右折叠（Left and Right Folds）了解左折叠和右折叠的区别，对于正确选择折叠表达式的形式至关重要。 二元左折叠（Binary Left Fold） 语法： 1(args op ...) 展开方式： 1((arg1 op arg2) op arg3) op ... op argN 适用场景： 当操作符是结合性的且从左侧开始累积操作时（如+、*）。 需要严格的顺序执行时，确保从左到右依次处理参数。 示例： 1(args + ...) // 左折叠求和 二元右折叠（Binary Right Fold） 语法： 1(... op args) 展开方式： 1arg1 op (arg2 op (arg3 op ... op argN)) 适用场景： 当操作符是右结合的，或当需要从右侧开始累积操作时。 某些特定的逻辑和数据结构可能需要右侧先处理。 示例： 1(... + args) // 右折叠求和 嵌套折叠表达式 在某些复杂场景下，可能需要嵌套使用左折叠和右折叠，以达到特定的操作顺序。例如，结合多个不同的操作符。 123456789101112#include &lt;iostream&gt;template&lt;typename... Args&gt;auto complexFold(const Args&amp;... args) &#123; // 先左折叠求和，然后右折叠求乘积 return (args + ...) * (... + args);&#125;int main() &#123; std::cout &lt;&lt; complexFold(1, 2, 3) &lt;&lt; std::endl; // (1+2+3) * (1+2+3) = 6 * 6 = 36 return 0;&#125; 解释： 在此示例中，我们首先对参数进行左折叠求和，然后对参数进行右折叠求和，最后将两者相乘。 这种嵌套用途展示了折叠表达式的灵活性。 5. op 在折叠表达式中的作用在折叠表达式中，op 代表二元操作符，用于定义如何将参数包中的各个参数相互结合。op 可以是任何合法的二元操作符，包括但不限于： 算术操作符：+、-、*、/、% 等。 逻辑操作符：&amp;&amp;、|| 等。 按位操作符：&amp;、|、^、&lt;&lt;、&gt;&gt; 等。 比较操作符：==、!=、&lt;、&gt;、&lt;=、&gt;= 等。 自定义操作符：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。 op 的选择直接影响折叠表达式的行为和结果。选择适当的操作符是实现特定功能的关键。 示例1：使用加法操作符 1234567891011#include &lt;iostream&gt;template&lt;typename... Args&gt;auto addAll(const Args&amp;... args) &#123; return (args + ...); // 使用 &#x27;+&#x27; 进行左折叠&#125;int main() &#123; std::cout &lt;&lt; addAll(1, 2, 3, 4) &lt;&lt; std::endl; // 输出：10 return 0;&#125; 示例2：使用逻辑与操作符 12345678910111213#include &lt;iostream&gt;template&lt;typename... Args&gt;bool allTrue(const Args&amp;... args) &#123; return (args &amp;&amp; ...); // 使用 &#x27;&amp;&amp;&#x27; 进行左折叠&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; allTrue(true, true, false) &lt;&lt; std::endl; // 输出：false std::cout &lt;&lt; allTrue(true, true, true) &lt;&lt; std::endl; // 输出：true return 0;&#125; 示例3：使用左移操作符（流插入） 1234567891011#include &lt;iostream&gt;template&lt;typename... Args&gt;void printAll(const Args&amp;... args) &#123; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; // 使用 &#x27;&lt;&lt;&#x27; 进行左折叠&#125;int main() &#123; printAll(&quot;Hello, &quot;, &quot;world&quot;, &quot;!&quot;, 123); // 输出：Hello, world!123 return 0;&#125; 解释： 在上述示例中，op 分别为 +、&amp;&amp;、&lt;&lt;。 每个操作符定义了如何将参数包中的元素相互结合。 示例4：使用自定义操作符 假设有一个自定义类型Point，并重载了+操作符以支持点的相加。 1234567891011121314151617181920212223#include &lt;iostream&gt;struct Point &#123; int x, y; // 重载 &#x27;+&#x27; 操作符 Point operator+(const Point&amp; other) const &#123; return Point&#123; x + other.x, y + other.y &#125;; &#125;&#125;;// 二元左折叠：((p1 + p2) + p3) + ... + pNtemplate&lt;typename... Args&gt;Point sumPoints(const Args&amp;... args) &#123; return (args + ...); // 使用 &#x27;+&#x27; 进行左折叠&#125;int main() &#123; Point p1&#123;1, 2&#125;, p2&#123;3, 4&#125;, p3&#123;5, 6&#125;; Point result = sumPoints(p1, p2, p3); std::cout &lt;&lt; &quot;Sum of Points: (&quot; &lt;&lt; result.x &lt;&lt; &quot;, &quot; &lt;&lt; result.y &lt;&lt; &quot;)\\n&quot;; // 输出：(9, 12) return 0;&#125; 解释： 通过重载+操作符，sumPoints函数能够将多个Point对象相加，得到累积的结果。 6. 示例代码与应用为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。 示例1：字符串拼接 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;template&lt;typename... Args&gt;std::string concatenate(const Args&amp;... args) &#123; return (std::string&#123;&#125; + ... + args); // 左折叠&#125;int main() &#123; std::string result = concatenate(&quot;Hello, &quot;, &quot;world&quot;, &quot;!&quot;, &quot; Have a nice day.&quot;); std::cout &lt;&lt; result &lt;&lt; std::endl; // 输出：Hello, world! Have a nice day. return 0;&#125; 示例2：计算逻辑与 12345678910111213#include &lt;iostream&gt;template&lt;typename... Args&gt;bool areAllTrue(const Args&amp;... args) &#123; return (args &amp;&amp; ...); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; areAllTrue(true, true, true) &lt;&lt; std::endl; // 输出：true std::cout &lt;&lt; areAllTrue(true, false, true) &lt;&lt; std::endl; // 输出：false return 0;&#125; 示例3：计算最大值 123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;template&lt;typename T, typename... Args&gt;T maxAll(T first, Args... args) &#123; return (std::max)(first, ... , args); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; maxAll(1, 5, 3, 9, 2) &lt;&lt; std::endl; // 输出：9 return 0;&#125; 注意：上述示例中的(std::max)(first, ... , args)是一个非标准用法，需要根据具体情况调整。通常，std::max不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用std::initializer_list或其他方法实现多参数的最大值计算。 示例4：筛选逻辑 假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作： 12345678910111213#include &lt;iostream&gt;template&lt;typename... Args&gt;bool anyTrue(const Args&amp;... args) &#123; return (args || ...); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; anyTrue(false, false, true) &lt;&lt; std::endl; // 输出：true std::cout &lt;&lt; anyTrue(false, false, false) &lt;&lt; std::endl; // 输出：false return 0;&#125; 7. 注意事项与最佳实践1. 操作符的选择 选择合适的操作符（op）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。 2. 操作符的结合性 不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。 3. 参数包的初始化 在二元折叠表达式中，有时需要一个初始值（init）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。 示例： 123456789101112#include &lt;iostream&gt;#include &lt;numeric&gt;template&lt;typename... Args&gt;auto sumWithInit(int init, Args... args) &#123; return (init + ... + args); // 左折叠&#125;int main() &#123; std::cout &lt;&lt; sumWithInit(10, 1, 2, 3) &lt;&lt; std::endl; // 输出：16 (10 + 1 + 2 + 3) return 0;&#125; 4. 参数包为空的情况 如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。 示例： 12345678910111213#include &lt;iostream&gt;// 求和函数，如果参数包为空返回0template&lt;typename... Args&gt;auto sum(Args... args) &#123; return (0 + ... + args); // 左折叠，初始值为0&#125;int main() &#123; std::cout &lt;&lt; sum(1, 2, 3) &lt;&lt; std::endl; // 输出：6 std::cout &lt;&lt; sum() &lt;&lt; std::endl; // 输出：0 return 0;&#125; 5. 与递归模板的比较 折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。 6. 编译器支持 确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括： GCC：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。 Clang：从版本5开始支持C++17。 MSVC（Visual Studio）：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。 7. 性能考虑 折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。 SFINAE（Substitution Failure Is Not An Error）一、什么是SFINAE？SFINAE 是 “Substitution Failure Is Not An Error”（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。 二、SFINAE的工作原理在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。 三、SFINAE的应用场景 函数重载选择：根据参数类型的不同选择不同的函数实现。 类型特性检测：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。 条件编译：根据模板参数的特性决定是否编译某些代码段。 四、SFINAE的基本用法SFINAE通常与std::enable_if、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。 示例一：通过std::enable_if实现函数重载 1234567891011121314151617181920212223#include &lt;type_traits&gt;#include &lt;iostream&gt;// 适用于整数类型template &lt;typename T&gt;typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::typeprint_type(T value) &#123; std::cout &lt;&lt; &quot;Integral type: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;// 适用于浮点类型template &lt;typename T&gt;typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, void&gt;::typeprint_type(T value) &#123; std::cout &lt;&lt; &quot;Floating point type: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123; print_type(10); // 输出: Integral type: 10 print_type(3.14); // 输出: Floating point type: 3.14 // print_type(&quot;Hello&quot;); // 编译错误，没有匹配的函数 return 0;&#125; 解释： std::enable_if 根据条件 std::is_integral&lt;T&gt;::value 或 std::is_floating_point&lt;T&gt;::value 决定是否启用对应的函数模板。 当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。 示例二：检测类型是否具有特定成员 假设我们需要实现一个函数，仅当类型 T 具有成员函数 foo 时才启用该函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;type_traits&gt;#include &lt;iostream&gt;// 辅助类型，检测是否存在成员函数 footemplate &lt;typename T&gt;class has_foo &#123;private: typedef char yes[1]; typedef char no[2]; template &lt;typename U, void (U::*)()&gt; struct SFINAE &#123;&#125;; template &lt;typename U&gt; static yes&amp; test(SFINAE&lt;U, &amp;U::foo&gt;*); template &lt;typename U&gt; static no&amp; test(...);public: static constexpr bool value = sizeof(test&lt;T&gt;(0)) == sizeof(yes);&#125;;// 函数仅在 T 有 foo() 成员时启用template &lt;typename T&gt;typename std::enable_if&lt;has_foo&lt;T&gt;::value, void&gt;::typecall_foo(T&amp; obj) &#123; obj.foo(); std::cout &lt;&lt; &quot;foo() called.&quot; &lt;&lt; std::endl;&#125;class WithFoo &#123;public: void foo() &#123; std::cout &lt;&lt; &quot;WithFoo::foo()&quot; &lt;&lt; std::endl; &#125;&#125;;class WithoutFoo &#123;&#125;;int main() &#123; WithFoo wf; call_foo(wf); // 输出: WithFoo::foo() \\n foo() called. // WithoutFoo wf2; // call_foo(wf2); // 编译错误，没有匹配的函数 return 0;&#125; 解释： has_foo 是一个类型萃取类，用于检测类型 T 是否具有成员函数 foo。 call_foo 函数模板仅在 T 具有 foo 成员时启用。 对于不具有 foo 成员的类型，编译器会忽略 call_foo，从而避免编译错误。 示例三：通过模板特化实现不同的行为 以下是完整的、正确实现 TypePrinter 的代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;type_traits&gt;#include &lt;iostream&gt;// 1. 定义一个 Trait 用于检测 T 是否有非 void 的 `value_type`template &lt;typename T, typename = void&gt;struct has_non_void_value_type : std::false_type &#123;&#125;;// 仅当 T 有 `value_type` 且 `value_type` 不是 void 时，特化为 std::true_typetemplate &lt;typename T&gt;struct has_non_void_value_type&lt;T, std::enable_if_t&lt;!std::is_void_v&lt;typename T::value_type&gt;&gt;&gt; : std::true_type &#123;&#125;;// 2. 定义 TypePrinter 主模板，使用一个布尔参数控制特化template &lt;typename T, bool HasValueType = has_non_void_value_type&lt;T&gt;::value&gt;struct TypePrinter;// 3. 特化：当 HasValueType 为 true 时，表示 T 有非 void 的 `value_type`template &lt;typename T&gt;struct TypePrinter&lt;T, true&gt; &#123; static void print()&#123; std::cout &lt;&lt; &quot;T has a member type &#x27;value_type&#x27;.&quot; &lt;&lt; std::endl; &#125;&#125;;// 特化：当 HasValueType 为 false 时，表示 T 没有 `value_type` 或 `value_type` 是 voidtemplate &lt;typename T&gt;struct TypePrinter&lt;T, false&gt; &#123; static void print()&#123; std::cout &lt;&lt; &quot;hello world! T does not have a member type &#x27;value_type&#x27;.&quot; &lt;&lt; std::endl; &#125;&#125;;// 测试结构体struct WithValueType&#123; using value_type = int;&#125;;struct WithoutValueType&#123;&#125;;struct WithVoidValueType&#123; using value_type = void;&#125;;int main() &#123; TypePrinter&lt;WithValueType&gt;::print(); // 输出: T has a member type &#x27;value_type&#x27;. TypePrinter&lt;WithoutValueType&gt;::print(); // 输出: hello world! T does not have a member type &#x27;value_type&#x27;. TypePrinter&lt;WithVoidValueType&gt;::print(); // 输出: hello world! T does not have a member type &#x27;value_type&#x27;. return 0;&#125; 代码解释 Trait has_non_void_value_type: 主模板：默认情况下，has_non_void_value_type&lt;T&gt; 继承自 std::false_type，表示 T 没有 value_type 或 value_type 是 void。 特化模板：仅当 T 有 value_type 且 value_type 不是 void 时，has_non_void_value_type&lt;T&gt; 继承自 std::true_type。 TypePrinter 模板: 主模板：接受一个类型 T 和一个布尔模板参数 HasValueType，默认为 has_non_void_value_type&lt;T&gt;::value。 **特化版本 TypePrinter&lt;T, true&gt;**：当 HasValueType 为 true 时，表示 T 有非 void 的 value_type，提供相应的 print 实现。 **特化版本 TypePrinter&lt;T, false&gt;**：当 HasValueType 为 false 时，表示 T 没有 value_type 或 value_type 是 void，提供默认的 print 实现。 测试结构体： WithValueType：有一个非 void 的 value_type。 WithoutValueType：没有 value_type。 WithVoidValueType：有一个 value_type，但它是 void。 main 函数： 分别测试了三种情况，验证 TypePrinter 的行为是否符合预期。 五、SFINAE的优缺点优点： 灵活性高：能够根据类型特性选择不同的实现，提升代码的泛化能力。 类型安全：通过编译期检测，避免了运行时错误。 无需额外的运行时开销：所有的类型筛选都在编译期完成。 缺点： 复杂性高：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。 编译器错误信息难以理解：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。 模板实例化深度限制：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。 六、现代C++中的替代方案随着C++11及后续标准的发展，引入了诸如decltype、constexpr、if constexpr、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的概念（Concepts）提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。 示例：使用概念替代SFINAE 123456789101112131415161718#include &lt;concepts&gt;#include &lt;iostream&gt;// 定义一个概念，要求类型 T 是整数类型template &lt;typename T&gt;concept Integral = std::is_integral_v&lt;T&gt;;// 仅当 T 满足 Integral 概念时启用template &lt;Integral T&gt;void print_type(T value) &#123; std::cout &lt;&lt; &quot;Integral type: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123; print_type(42); // 输出: Integral type: 42 // print_type(3.14); // 编译错误，不满足 Integral 概念 return 0;&#125; 解释： 使用概念Integral代替std::enable_if，语法更简洁，代码更易读。 当类型不满足概念时，编译器会给出明确的错误信息，便于调试。 虽然上述方法经典且有效，但在C++11及以后版本，存在更简洁和易读的方式来实现相同的功能。例如，使用std::void_t和更现代的检测技巧，或者直接使用C++20的概念（Concepts），使代码更加清晰。 示例：使用std::void_t简化has_foo 12345678910111213141516171819202122232425262728293031323334#include &lt;type_traits&gt;#include &lt;iostream&gt;// 使用 std::void_t 简化 has_footemplate &lt;typename, typename = std::void_t&lt;&gt;&gt;struct has_foo : std::false_type &#123;&#125;;template &lt;typename T&gt;struct has_foo&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().foo())&gt;&gt; : std::true_type &#123;&#125;;// 函数仅在 T 有 foo() 成员时启用template &lt;typename T&gt;std::enable_if_t&lt;has_foo&lt;T&gt;::value, void&gt;call_foo(T&amp; obj) &#123; obj.foo(); std::cout &lt;&lt; &quot;foo() called.&quot; &lt;&lt; std::endl;&#125;class WithFoo &#123;public: void foo() &#123; std::cout &lt;&lt; &quot;WithFoo::foo()&quot; &lt;&lt; std::endl; &#125;&#125;;class WithoutFoo &#123;&#125;;int main() &#123; WithFoo wf; call_foo(wf); // 输出: WithFoo::foo() // foo() called. // WithoutFoo wf2; // call_foo(wf2); // 编译错误，没有匹配的函数 return 0;&#125; 解释： 利用std::void_t，has_foo结构更为简洁。 decltype(std::declval&lt;T&gt;().foo())尝试在不实例化T对象的情况下检测foo()成员函数。 如果foo()存在，has_foo&lt;T&gt;继承自std::true_type，否则继承自std::false_type。 使用C++20概念 如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。 123456789101112131415161718192021222324252627282930313233#include &lt;concepts&gt;#include &lt;type_traits&gt;#include &lt;iostream&gt;// 定义一个概念，要求类型 T 具有 void foo()template &lt;typename T&gt;concept HasFoo = requires(T t) &#123; &#123; t.foo() &#125; -&gt; std::same_as&lt;void&gt;;&#125;;// 仅当 T 满足 HasFoo 概念时启用template &lt;HasFoo T&gt;void call_foo(T&amp; obj) &#123; obj.foo(); std::cout &lt;&lt; &quot;foo() called.&quot; &lt;&lt; std::endl;&#125;class WithFoo &#123;public: void foo() &#123; std::cout &lt;&lt; &quot;WithFoo::foo()&quot; &lt;&lt; std::endl; &#125;&#125;;class WithoutFoo &#123;&#125;;int main() &#123; WithFoo wf; call_foo(wf); // 输出: WithFoo::foo() // foo() called. // WithoutFoo wf2; // call_foo(wf2); // 编译错误，不满足 HasFoo 概念 return 0;&#125; 解释： HasFoo概念：使用requires表达式检测类型T是否具有void foo()成员函数。 call_foo函数模板：仅当T满足HasFoo概念时，模板被启用。 这种方式更直观，易于理解和维护。 七、总结SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。 综合案例：结合模板特化与折叠表达式为了进一步巩固对模板特化和折叠表达式的理解，本节将通过一个综合案例展示如何将两者结合使用。 案例描述实现一个通用的日志记录器Logger，能够处理任意数量和类型的参数，并根据不同的类型组合调整输出格式。具体需求包括： 对于普通类型，使用通用的打印格式。 对于指针类型，打印指针地址或指向的值。 对于std::string类型，使用专门的格式。 支持可变数量的参数，通过折叠表达式实现参数的逐一打印。 实现步骤 **定义通用类模板Logger**，使用模板特化和偏特化处理不同类型。 实现log函数，使用模板折叠表达式逐一打印参数。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;type_traits&gt;// 通用类模板template &lt;typename T, typename Enable = void&gt;class Logger &#123;public: static void log(const T&amp; value) &#123; std::cout &lt;&lt; &quot;General Logger: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;// 类模板偏特化：当 T 是指针类型template &lt;typename T&gt;class Logger&lt;T, typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; &#123;public: static void log(T value) &#123; if (value) &#123; std::cout &lt;&lt; &quot;Pointer Logger: &quot; &lt;&lt; *value &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Pointer Logger: nullptr&quot; &lt;&lt; std::endl; &#125; &#125;&#125;;// 类模板全特化：当 T 是 std::stringtemplate &lt;&gt;class Logger&lt;std::string&gt; &#123;public: static void log(const std::string&amp; value) &#123; std::cout &lt;&lt; &quot;String Logger: \\&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; &#125;&#125;;// 函数模板，用于递归调用 Logger::logtemplate &lt;typename T&gt;void logOne(const T&amp; value) &#123; Logger&lt;T&gt;::log(value);&#125;// 使用模板折叠表达式实现多参数日志记录template &lt;typename... Args&gt;void logAll(const Args&amp;... args) &#123; (logOne(args), ...); // 左折叠，调用 logOne 对每个参数进行日志记录&#125;int main() &#123; int a = 10; double b = 3.14; std::string s = &quot;Hello, World!&quot;; int* ptr = &amp;a; double* pNull = nullptr; // 使用 Logger 类模板进行特化打印 Logger&lt;int&gt;::log(a); // 输出：General Logger: 10 Logger&lt;double*&gt;::log(pNull); // 输出：Pointer Logger: nullptr Logger&lt;std::string&gt;::log(s); // 输出：String Logger: &quot;Hello, World!&quot; std::cout &lt;&lt; &quot;\\nLogging multiple parameters:&quot; &lt;&lt; std::endl; logAll(a, b, s, ptr, pNull); /* 输出： General Logger: 10 General Logger: 3.14 String Logger: &quot;Hello, World!&quot; Pointer Logger: 10 Pointer Logger: nullptr */ return 0;&#125; 输出： 12345678910General Logger: 10Pointer Logger: nullptrString Logger: &quot;Hello, World!&quot;Logging multiple parameters:General Logger: 10General Logger: 3.14String Logger: &quot;Hello, World!&quot;Pointer Logger: 10Pointer Logger: nullptr 解析 **通用模板Logger&lt;T, Enable&gt;**： 使用第二个模板参数Enable与SFINAE（Substitution Failure Is Not An Error）结合，控制模板特化。 对于非指针类型和非std::string类型，使用通用实现，打印&quot;General Logger: value&quot;。 **类模板偏特化Logger&lt;T, Enable&gt;**： 使用std::enable_if和std::is_pointer，当T是指针类型时，特化模板。 实现指针类型的特殊日志处理，打印指针指向的值或nullptr。 **类模板全特化Logger&lt;std::string&gt;**： 为std::string类型提供全特化版本，使用不同的输出格式。 logOne函数模板： 简化调用过程，调用相应的Logger&lt;T&gt;::log方法。 logAll函数模板： 使用模板折叠表达式(logOne(args), ...)，实现对所有参数的逐一日志记录。 通过左折叠的逗号表达式，确保每个logOne调用依次执行。 main函数： 测试不同类型的日志记录，包括普通类型、指针类型和std::string类型。 调用logAll函数，实现多参数的综合日志记录。 模板元编程（Template Metaprogramming） 什么是模板元编程：模板元编程（Template Metaprogramming）是一种在编译期通过模板机制进行代码生成和计算的编程技术。它利用编译器的模板实例化机制，在编译期间执行代码逻辑，以提高程序的性能和灵活性。 模板元编程的优势： 提高代码的可重用性和泛化能力。 在编译期进行复杂计算，减少运行时开销。 实现类型安全的高级抽象。 模板元编程基础 模板特化（Template Specialization）： 全特化（Full Specialization）：为特定类型提供特定实现。 偏特化（Partial Specialization）：为部分模板参数特定的情况提供实现。 递归模板（Recursive Templates）：利用模板的递归实例化机制，实现编译期计算。 编译期计算模板元编程允许在编译时执行计算，如计算阶乘、斐波那契数列等。 示例：编译期阶乘 12345678910111213141516171819#include &lt;iostream&gt;// 基础情况template &lt;int N&gt;struct Factorial &#123; static const int value = N * Factorial&lt;N - 1&gt;::value;&#125;;// 递归终止template &lt;&gt;struct Factorial&lt;0&gt; &#123; static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; &quot;5! = &quot; &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl; // 输出：5! = 120 std::cout &lt;&lt; &quot;0! = &quot; &lt;&lt; Factorial&lt;0&gt;::value &lt;&lt; std::endl; // 输出：0! = 1 return 0;&#125; 输出： 125! = 1200! = 1 讲解： 基本模板 Factorial定义了一个静态常量value，其值为N * Factorial&lt;N - 1&gt;::value，实现递归计算。 特化模板 Factorial&lt;0&gt;定义递归终止条件，当N=0时，value为1。 在main函数中，通过Factorial&lt;5&gt;::value获取5的阶乘结果，编译期即生成其值。 静态成员变量的基本规则 在 C++ 中，静态成员变量的声明与定义有以下基本规则： 声明（Declaration）：在类内部声明静态成员变量，告诉编译器该类包含这个静态成员。 定义（Definition）：在类外部对静态成员变量进行定义，分配存储空间。 通常，对于非 constexpr 或非 inline 的静态成员变量，必须 在类外进行定义，否则会导致链接器错误（undefined reference）。 特殊情况：static const 整数成员 对于 static const 整数类型 的静态成员变量，C++ 标准做了一些特殊的处理： 类内初始化：你可以在类内部初始化 static const 整数成员变量，例如 static const int value = 42;。 使用场景 ： 不需要类外定义：在某些情况下，编译器在编译阶段可以直接使用类内的初始化值，无需类外定义。 需要类外定义：如果你在程序中对该静态成员变量进行取址（例如，&amp;Factorial&lt;5&gt;::value），或者在其他需要该变量的存储位置时，就需要在类外进行定义。 C++11 及之前的标准 在 C++11 及更早的标准中，对于 static const 整数成员变量： 不需要类外定义的情况 ： 仅在作为编译期常量使用时，不需要类外定义。例如，用于数组大小、模板参数等。 需要类外定义的情况 ： 当你需要对变量进行取址，或者在需要其存储位置时，必须在类外定义。例如： 12345678template&lt;int N&gt;struct Factorial&#123; static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;// 类外定义template&lt;int N&gt;const int Factorial&lt;N&gt;::value; C++17 及更新标准 从 C++17 开始，引入了 内联变量（inline variables），使得在类内定义静态成员变量变得更加灵活： 内联静态成员变量 ： 使用 inline 关键字，可以在类内对静态成员变量进行定义，无需在类外进行单独定义。 这适用于 C++17 及更高版本。 例如，你可以这样编写： 123456789template&lt;int N&gt;struct Factorial&#123; inline static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; inline static const int value = 1;&#125;; 在这种情况下，无需在类外进行定义，因为 inline 确保了该变量在每个翻译单元中都只有一个实例。 在 C++11 及之前的标准 代码： 123456789template&lt;int N&gt;struct Factorial&#123; static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; static const int value = 1;&#125;; 作为编译期常量使用 ： 例如，用于其他模板参数或编译期常量计算时，不需要类外定义。 取址或需要存储位置时 ： 需要在类外进行定义。例如： 12345template&lt;int N&gt;const int Factorial&lt;N&gt;::value;template&lt;&gt;const int Factorial&lt;0&gt;::value; 在 C++17 及更高标准 如果你使用 C++17 及更高版本，可以使用 inline 关键字： 123456789template&lt;int N&gt;struct Factorial&#123; inline static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; inline static const int value = 1;&#125;; 无需类外定义 ： inline 使得在类内的定义成为唯一的定义，即使在多个翻译单元中使用，也不会导致重复定义错误。 实际示例与测试 示例 1：仅作为编译期常量使用 1234567891011121314151617#include &lt;iostream&gt;// 你的 Factorial 模板template&lt;int N&gt;struct Factorial&#123; static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Factorial&lt;5&gt;::value = &quot; &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl; return 0;&#125; C++11 及之前：无需类外定义。 C++17 及更新：同样无需类外定义，且可以使用 inline 进一步优化。 示例 2：取址 12345678910111213141516171819202122232425#include &lt;iostream&gt;// 你的 Factorial 模板template&lt;int N&gt;struct Factorial&#123; static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; static const int value = 1;&#125;;// 类外定义（在 C++11 及之前需要）template&lt;int N&gt;const int Factorial&lt;N&gt;::value;template&lt;&gt;const int Factorial&lt;0&gt;::value;int main() &#123; std::cout &lt;&lt; &quot;Factorial&lt;5&gt;::value = &quot; &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;&amp;Factorial&lt;5&gt;::value = &quot; &lt;&lt; &amp;Factorial&lt;5&gt;::value &lt;&lt; std::endl; return 0;&#125; C++11 及之前：必须提供类外定义，否则会在链接时出现错误。 C++17 及更新：若未使用 inline，仍需提供类外定义；使用 inline 则无需。 示例 3：使用 inline（C++17 及更高） 123456789101112131415161718#include &lt;iostream&gt;// 你的 Factorial 模板（使用 inline）template&lt;int N&gt;struct Factorial&#123; inline static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; inline static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Factorial&lt;5&gt;::value = &quot; &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;&amp;Factorial&lt;5&gt;::value = &quot; &lt;&lt; &amp;Factorial&lt;5&gt;::value &lt;&lt; std::endl; return 0;&#125; C++17 及以上： 无需类外定义。 inline 保证了多重定义的合法性。 详细解析 为什么有这样的特殊处理？ 优化与性能 ： 在编译期常量的情况下，不需要在运行时分配存储空间，编译器可以优化掉相关代码。 兼容性 ： 早期 C++ 标准遵循这种规则，允许在类内初始化静态常量成员变量，便于模板元编程和常量表达式的使用。 inline 变量 ： C++17 引入 inline 关键字用于变量，解决了静态成员变量在多个翻译单元中的定义问题，使得代码更简洁。 是否总是需要定义？ 并非总是需要。关键在于 如何使用 这个静态成员变量： 仅作为编译期常量使用：无需类外定义。 需要存储位置或取址：需要类外定义，除非使用 inline（C++17 及以上）。 编译器与链接器的行为 编译阶段 ： 类内的初始化用于编译期常量计算，不涉及存储分配。 链接阶段 ： 如果没有类外定义，且静态成员被 odr-used（可能需要存储位置），链接器会报错，提示找不到符号定义。 使用 inline 关键字后，编译器处理为内联变量，避免了多重定义问题。 示例：编译期斐波那契数列 123456789101112131415161718192021222324#include &lt;iostream&gt;// 基础情况template &lt;int N&gt;struct Fibonacci &#123; static const long long value = Fibonacci&lt;N - 1&gt;::value + Fibonacci&lt;N - 2&gt;::value;&#125;;// 递归终止template &lt;&gt;struct Fibonacci&lt;0&gt; &#123; static const long long value = 0;&#125;;template &lt;&gt;struct Fibonacci&lt;1&gt; &#123; static const long long value = 1;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Fibonacci&lt;10&gt; = &quot; &lt;&lt; Fibonacci&lt;10&gt;::value &lt;&lt; std::endl; // 输出：Fibonacci&lt;10&gt; = 55 std::cout &lt;&lt; &quot;Fibonacci&lt;20&gt; = &quot; &lt;&lt; Fibonacci&lt;20&gt;::value &lt;&lt; std::endl; // 输出：Fibonacci&lt;20&gt; = 6765 return 0;&#125; 输出： 12Fibonacci&lt;10&gt; = 55Fibonacci&lt;20&gt; = 6765 要点： 模板元编程利用编译期计算提升程序性能。 需要理解模板递归与终止条件。 常与类型特性和模板特化结合使用。 类型计算与SFINAE 类型计算：在编译期进行类型的推导和转换。 SFINAE（Substitution Failure Is Not An Error）：模板实例化过程中，如果某个替换失败，编译器不会报错，而是忽略该模板，并尝试其他匹配。 示例：检测类型是否可加 123456789101112#include &lt;type_traits&gt;// 检测是否可以对T类型进行加法操作template &lt;typename T, typename = void&gt;struct is_addable : std::false_type &#123;&#125;;template &lt;typename T&gt;struct is_addable&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;// 使用static_assert(is_addable&lt;int&gt;::value, &quot;int should be addable&quot;);static_assert(!is_addable&lt;void*&gt;::value, &quot;void* should not be addable&quot;); 讲解： 1. struct is_addable&lt;...&gt; : std::true_type &#123;&#125; 目的：定义一个名为 is_addable 的结构体模板，它继承自 std::true_type。 作用：当特定的模板参数满足条件时，这个特化版本将被选中，表示 T 类型是可加的，即支持 + 操作符。 2. 模板参数解释：&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt; **T**：这是要检查的类型。 **std::declval&lt;T&gt;()**： 用途：std::declval&lt;T&gt;() 是一个用于在不实际创建 T 类型对象的情况下，生成一个 T 类型的右值引用。 作用：它允许我们在编译时模拟 T 类型的对象，以便用于表达式的检测。 **std::declval&lt;T&gt;() + std::declval&lt;T&gt;()**： 表达式：尝试对两个 T 类型的右值引用进行加法运算。 目的：检查 T 类型是否支持 + 操作符。 **void(...)**： 将加法表达式的结果转换为 void 类型。这是为了在 decltype 中仅关心表达式是否有效，而不关心其具体类型。 **decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))**： 作用：如果 T 类型支持加法运算，则该 decltype 表达式的类型为 void，否则会导致替换失败 高级模板元编程技巧 变参模板（Variadic Templates）：支持模板参数包，实现更加灵活的模板定义。 示例：求和模板 123456789101112131415161718192021// 基本递归模板template &lt;int... Ns&gt;struct Sum;// 递归终止template &lt;&gt;struct Sum&lt;&gt; &#123; static const int value = 0;&#125;;// 递归定义template &lt;int N, int... Ns&gt;struct Sum&lt;N, Ns...&gt; &#123; static const int value = N + Sum&lt;Ns...&gt;::value;&#125;;// 使用int main() &#123; int result = Sum&lt;1, 2, 3, 4, 5&gt;::value; // 15 return 0;&#125; 讲解： 基本模板 Sum接受一个整数参数包Ns...。 特化模板 Sum&lt;&gt;定义递归终止条件，value为0。 递归定义 Sum&lt;N, Ns...&gt;将第一个参数N与剩余参数的和相加。 在main函数中，通过Sum&lt;1, 2, 3, 4, 5&gt;::value计算1+2+3+4+5=15。 类型列表（Type Lists）：通过模板参数包管理类型的集合。 示例：类型列表和元素访问 123456789101112131415161718192021// 定义类型列表template &lt;typename... Ts&gt;struct TypeList &#123;&#125;;// 获取类型列表中第N个类型template &lt;typename List, std::size_t N&gt;struct TypeAt;template &lt;typename Head, typename... Tail&gt;struct TypeAt&lt;TypeList&lt;Head, Tail...&gt;, 0&gt; &#123; using type = Head;&#125;;template &lt;typename Head, typename... Tail, std::size_t N&gt;struct TypeAt&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123; using type = typename TypeAt&lt;TypeList&lt;Tail...&gt;, N - 1&gt;::type;&#125;;// 使用using list = TypeList&lt;int, double, char&gt;;using third_type = TypeAt&lt;list, 2&gt;::type; // char 讲解： **TypeList**：定义一个包含多个类型的类型列表。 TypeAt：通过递归模板，从TypeList中获取第N个类型。 当N为0时，类型为Head。 否则，递归获取Tail...中第N-1个类型。 使用：定义list为TypeList&lt;int, double, char&gt;，third_type为第2个类型，即char。 实际应用案例案例1：静态断言与类型检查 12345678910#include &lt;type_traits&gt;template &lt;typename T&gt;struct is_integral_type &#123; static const bool value = std::is_integral&lt;T&gt;::value;&#125;;// 使用static_assert(is_integral_type&lt;int&gt;::value, &quot;int is integral&quot;);static_assert(!is_integral_type&lt;float&gt;::value, &quot;float is not integral&quot;); 案例2：编译期字符串 12345678910111213#include &lt;utility&gt;// 编译期字符串template &lt;char... Cs&gt;struct String &#123; static constexpr char value[sizeof...(Cs) + 1] = &#123; Cs..., &#x27;\\0&#x27; &#125;;&#125;;template &lt;char... Cs&gt;constexpr char String&lt;Cs...&gt;::value[sizeof...(Cs) + 1];// 使用using hello = String&lt;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&gt;; 为什么需要外部定义 value 在 C++ 中，静态成员变量与类的实例无关，它们存在于全局命名空间中。然而，静态成员变量的声明和定义是不同的： 声明：告诉编译器类中存在这个变量。 定义：为这个变量分配存储空间。 对于非 inline 的静态成员变量，即使是 constexpr，都需要在类外部进行定义。否则，链接器在处理多个翻译单元时会因为找不到变量的定义而报错。 具体原因 模板类的静态成员变量： 每当模板实例化时，都会产生一个新的类类型，每个类类型都有自己的一组静态成员变量。 因此，编译器需要知道这些静态成员变量在所有翻译单元中都唯一对应一个定义。 constexpr 静态成员变量： 从 C++17 开始，inline 关键字引入，使得 constexpr 静态成员变量可以在类内定义，并且隐式地具有 inline 属性。这意味着不需要在类外定义它们，因为 inline 确保了在多个翻译单元中有同一份定义。 但在 C++17 之前或不使用 inline 的情况下，即使是 constexpr，仍需在类外定义。 类内声明：static constexpr char value[...] 声明了 value 并给予了初始值。 类外定义：constexpr char String&lt;Cs...&gt;::value[...] 为 value 分配了存储空间。 如果省略类外定义，编译器会在链接阶段找不到 value 的定义，导致链接错误。这尤其适用于 C++14 及更早版本，以及 C++17 中未使用 inline 的情形。 如何避免外部定义 如果你使用的是 C++17 或更高版本，可以通过 inline 关键字将静态成员变量声明为 inline，从而在类内完成定义，无需再在外部定义。例如： 12345678910#include &lt;utility&gt;// 编译期字符串template &lt;char... Cs&gt;struct String &#123; inline static constexpr char value[sizeof...(Cs) + 1] = &#123; Cs..., &#x27;\\0&#x27; &#125;;&#125;;// 使用using hello = String&lt;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&gt;; 在这个版本中，inline 关键字告诉编译器这是一个内联变量，允许在多个翻译单元中存在同一份定义，而不会导致重复定义错误。因此，无需在类外再次定义 value。 完整示例对比 不使用 inline（需要类外定义） 12345678910111213141516171819#include &lt;utility&gt;// 编译期字符串template &lt;char... Cs&gt;struct String &#123; static constexpr char value[sizeof...(Cs) + 1] = &#123; Cs..., &#x27;\\0&#x27; &#125;;&#125;;// 外部定义template &lt;char... Cs&gt;constexpr char String&lt;Cs...&gt;::value[sizeof...(Cs) + 1];// 使用using hello = String&lt;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&gt;;int main() &#123; // 访问 value // std::cout &lt;&lt; hello::value;&#125; 使用 inline（无需类外定义，C++17 起） 123456789101112131415#include &lt;utility&gt;// 编译期字符串template &lt;char... Cs&gt;struct String &#123; inline static constexpr char value[sizeof...(Cs) + 1] = &#123; Cs..., &#x27;\\0&#x27; &#125;;&#125;;// 使用using hello = String&lt;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&gt;;int main() &#123; // 访问 value // std::cout &lt;&lt; hello::value;&#125; C++20 ConceptsC++20 引入了 Concepts，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。 定义与使用定义一个 Concept Concepts 使用 concept 关键字定义，并作为函数或类模板的约束。 12345678#include &lt;concepts&gt;#include &lt;iostream&gt;// 定义一个 Concept：要求类型必须是可输出到 std::ostreamtemplate &lt;typename T&gt;concept Printable = requires(T a) &#123; &#123; std::cout &lt;&lt; a &#125; -&gt; std::same_as&lt;std::ostream&amp;&gt;;&#125;; 使用 Concept 约束模板 123456789101112// 使用 Concepts 约束函数模板template &lt;Printable T&gt;void print(const T&amp; value) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123; print(42); // 正常调用 print(&quot;Hello&quot;); // 正常调用 // print(std::vector&lt;int&gt;&#123;1, 2, 3&#125;); // 编译错误，std::vector&lt;int&gt; 不满足 Printable return 0;&#125; 限制与约束Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。 示例：排序函数中的 Concepts 12345678910111213141516171819202122232425262728#include &lt;concepts&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;// 定义一个可比较的概念template &lt;typename T&gt;concept Comparable = requires(T a, T b) &#123; &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;bool&gt;;&#125;;// 排序函数，约束类型必须可比较template &lt;Comparable T&gt;void sortVector(std::vector&lt;T&gt;&amp; vec) &#123; std::sort(vec.begin(), vec.end());&#125;int main() &#123; std::vector&lt;int&gt; nums = &#123;4, 2, 3, 1&#125;; sortVector(nums); for(auto num : nums) std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // 输出：1 2 3 4 std::cout &lt;&lt; std::endl; // std::vector&lt;std::vector&lt;int&gt;&gt; vecs; // sortVector(vecs); // 编译错误，std::vector&lt;int&gt; 不满足 Comparable return 0;&#125; 输出： 11 2 3 4 要点： Concepts 提供了模板参数的语义约束。 使用 Concepts 提高模板的可读性和可维护性。 生成更友好的编译错误信息，易于调试。 模板实例化与编译器行为理解模板实例化的过程有助于进行有效的模板设计与优化，尤其是在涉及链接和编译时间时。 显式实例化（Explicit Instantiation）显式实例化告诉编译器生成特定类型下的模板代码，主要用于分离模板的声明与定义，减少编译时间。 语法： 12345678910// 声明模板（通常在头文件中）template &lt;typename T&gt;class MyClass;// 定义模板（通常在源文件中）template &lt;typename T&gt;class MyClass &#123; /* ... */ &#125;;// 显式实例化template class MyClass&lt;int&gt;; 示例：分离类模板的声明与定义 MyClass.h 12345678910#ifndef MYCLASS_H#define MYCLASS_Htemplate &lt;typename T&gt;class MyClass &#123;public: void doSomething();&#125;;#endif // MYCLASS_H MyClass.cpp 1234567891011#include &quot;MyClass.h&quot;#include &lt;iostream&gt;template &lt;typename T&gt;void MyClass&lt;T&gt;::doSomething() &#123; std::cout &lt;&lt; &quot;Doing something with &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;&#125;// 显式实例化template class MyClass&lt;int&gt;;template class MyClass&lt;double&gt;; main.cpp 12345678910111213#include &quot;MyClass.h&quot;int main() &#123; MyClass&lt;int&gt; obj1; obj1.doSomething(); // 输出：Doing something with i MyClass&lt;double&gt; obj2; obj2.doSomething(); // 输出：Doing something with d // MyClass&lt;char&gt; obj3; // 链接错误，因为 MyClass&lt;char&gt; 未实例化 return 0;&#125; 输出： 12Doing something with iDoing something with d 注意事项： 显式实例化需要在模板定义后进行。 只有显式实例化的类型在未实例化时可用于模板分离。 未显式实例化的类型可能导致链接错误。 隐式实例化（Implicit Instantiation）隐式实例化是编译器在模板被实际使用时自动生成对应实例代码的过程。通常，模板定义与使用都在头文件中完成。 示例： MyClass.h 123456789101112131415#ifndef MYCLASS_H#define MYCLASS_H#include &lt;iostream&gt;#include &lt;typeinfo&gt;template &lt;typename T&gt;class MyClass &#123;public: void doSomething() &#123; std::cout &lt;&lt; &quot;Doing something with &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl; &#125;&#125;;#endif // MYCLASS_H main.cpp 1234567891011121314#include &quot;MyClass.h&quot;int main() &#123; MyClass&lt;int&gt; obj1; obj1.doSomething(); // 输出：Doing something with i MyClass&lt;double&gt; obj2; obj2.doSomething(); // 输出：Doing something with d MyClass&lt;char&gt; obj3; obj3.doSomething(); // 输出：Doing something with c return 0;&#125; 输出： 123Doing something with iDoing something with dDoing something with c 要点： 隐式实例化不需要显式声明或定义。 模板定义必须在使用前可见，通常通过头文件实现。 容易导致编译时间增加，尤其是大型模板库。 链接时问题与解决方案由于模板是在使用时被实例化，跨源文件使用模板可能导致链接时问题，如重复定义或未定义引用。 解决方案： 内联实现：将模板的定义与声明一起放在头文件中，避免链接时重复定义。 显式实例化：将常用的模板实例化放在源文件中，其他源文件通过 extern 或头文件引用已有实例。 **使用 extern template**：告知编译器某些模板实例已在其他源文件中显式实例化。 示例：使用 extern template MyClass.h 1234567891011121314#ifndef MYCLASS_H#define MYCLASS_Htemplate &lt;typename T&gt;class MyClass &#123;public: void doSomething();&#125;;// 声明模板实例，但不定义extern template class MyClass&lt;int&gt;;extern template class MyClass&lt;double&gt;;#endif // MYCLASS_H MyClass.cpp 123456789101112#include &quot;MyClass.h&quot;#include &lt;iostream&gt;#include &lt;typeinfo&gt;template &lt;typename T&gt;void MyClass&lt;T&gt;::doSomething() &#123; std::cout &lt;&lt; &quot;Doing something with &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;&#125;// 显式实例化template class MyClass&lt;int&gt;;template class MyClass&lt;double&gt;; main.cpp 123456789101112#include &quot;MyClass.h&quot;int main() &#123; MyClass&lt;int&gt; obj1; obj1.doSomething(); // 使用已显式实例化的模板 MyClass&lt;double&gt; obj2; obj2.doSomething(); // 使用已显式实例化的模板 // MyClass&lt;char&gt; obj3; // 链接错误，未实例化 return 0;&#125; 要点： 使用 extern template 声明已在其他源文件中实例化的模板。 减少编译时间和链接大小，防止重复定义。 最佳实践与注意事项掌握模板的最佳实践有助于编写高效、可维护的代码，同时避免常见的陷阱和问题。 模板定义与实现分离对于类模板，通常将模板的声明和定义放在同一头文件中，以确保编译器在实例化模板时能够看到完整的定义。尽管可以尝试将模板定义分离到源文件，但需要结合显式实例化，这会增加复杂性，且不适用于广泛使用的模板。 推荐做法： 类模板：将声明和实现统一在头文件中。 函数模板：同样将声明和实现统一在头文件中，或使用显式实例化。 避免过度模板化虽然模板提供了极大的灵活性，但过度复杂的模板会导致代码难以理解、维护和编译时间增加。 建议： 只在必要时使用模板。 保持模板的简单性和可读性，避免过度嵌套和复杂的特化。 合理使用类型特性和 Concepts 进行约束。 提高编译速度的方法模板的广泛使用可能导致编译时间显著增加。以下方法有助于优化编译速度： 预编译头文件（Precompiled Headers）：将频繁使用的模板库放入预编译头中，加速编译。 显式实例化：通过显式实例化减少模板的重复编译。 模块化编程（C++20 Modules）：利用模块化将模板库进行编译和链接，减少编译时间。 合理分割头文件：避免头文件中的模板定义过大，分割成较小的模块。 代码复用与库设计模板是实现高度复用库组件的有效手段，如标准库（std::vector、std::map 等）广泛使用模板。设计模板库时，需考虑以下因素： 接口的一致性：保持模板库的接口简洁、一致，便于使用者理解和使用。 文档与示例：提供详细的文档和示例代码，帮助使用者理解模板库的用法。 错误信息友好：通过 Concepts、SFINAE 等机制提供清晰的错误信息，降低使用门槛。 性能优化：利用模板的编译期计算和内联等特性，提高库组件的性能。 避免模板错误的困惑模板错误通常复杂且难以理解，以下方法有助于减少模板错误的困惑： 逐步调试：从简单的模板开始，逐步增加复杂性，便于定位错误。 使用编译器警告与工具：开启编译器的警告选项，使用静态分析工具检测模板代码中的问题。 代码注释与文档：详细注释复杂的模板代码，提供文档说明其设计和用途。 总结C++ 模板机制是实现泛型编程的核心工具，通过类型参数化和编译期计算，极大地提升了代码的复用性、灵活性和性能。从基础的函数模板和类模板，到高级的模板特化、变参模板、模板元编程、SFINAE 和 Concepts，掌握模板的各个方面能够帮助开发者编写更高效、更加通用的 C++ 代码。 在实际应用中，合理运用模板不仅可以简化代码结构，还可以提高代码的可维护性和可扩展性。然而，模板的复杂性也要求开发者具备扎实的 C++ 基础和良好的编程习惯，以避免过度复杂化和难以调试的问题。 通过本教案的系统学习，相信您已经具备了全面理解和运用 C++ 模板的能力，能够在实际项目中高效地利用模板特性，编写出更为优秀的代码。 练习与习题练习 1：实现一个通用的 Swap 函数模板要求： 编写一个函数模板 swapValues，可以交换任意类型的两个变量。 在 main 函数中测试 int、double、std::string 类型的交换。 提示： 123456template &lt;typename T&gt;void swapValues(T&amp; a, T&amp; b) &#123; T temp = a; a = b; b = temp;&#125; 练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。要求： 模板参数为类型 T。 提供构造函数、成员变量及访问函数。 在 main 中实例化 Triple&lt;int&gt; 和 Triple&lt;std::string&gt;，进行测试。 练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。要求： 通用模板类 Printer，具有 print 函数，输出 General Printer: value。 全特化 Printer&lt;bool&gt;，输出 Boolean Printer: true 或 Boolean Printer: false。 练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。要求： 使用递归方法实现。 在 main 中测试不同参数组合的调用。 练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。要求： 定义 IsPointer&lt;T&gt;，包含 value 静态常量成员，值为 true 或 false。 使用特化进行实现。 在 main 中使用 static_assert 进行测试。 示例： 12static_assert(IsPointer&lt;int*&gt;::value, &quot;int* is a pointer&quot;);static_assert(!IsPointer&lt;int&gt;::value, &quot;int is not a pointer&quot;); 练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。要求： 使用 std::enable_if 和类型特性检测 size() 成员。 在 main 中测试 std::vector&lt;int&gt;（应启用）和 int（不应启用）。 提示： 12345template &lt;typename T&gt;typename std::enable_if&lt;has_size&lt;T&gt;::value, void&gt;::typeenableIfExample(const T&amp; container) &#123; std::cout &lt;&lt; &quot;Container has size: &quot; &lt;&lt; container.size() &lt;&lt; std::endl;&#125; 练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。要求： 定义 Integral Concept。 编写函数模板 isEven(u)，仅接受满足 Integral 的类型。 在 main 中测试不同类型的调用。 示例： 1234template &lt;Integral T&gt;bool isEven(T value) &#123; return value % 2 == 0;&#125; 练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。要求： 模板参数为类型 T 和 std::size_t N。 提供 push, pop, top 等成员函数。 在 main 中测试 FixedStack&lt;int, 5&gt; 和 FixedStack&lt;std::string, 3&gt;。 练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。要求： 定义 TypeIdentity&lt;T&gt;，包含类型成员 type。 使用 std::is_same 与 static_assert 验证。 示例： 1static_assert(std::is_same&lt;TypeIdentity&lt;int&gt;::type, int&gt;::value, &quot;TypeIdentity&lt;int&gt; should be int&quot;); 练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。要求： 使用 TypeList 模板定义类型列表。 定义 LengthOf&lt;TypeList&lt;...&gt;&gt;::value 表示类型列表的长度。 在 main 中使用 static_assert 进行测试。 提示： 12345678910template &lt;typename... Ts&gt;struct TypeList &#123;&#125;;template &lt;typename List&gt;struct LengthOf;template &lt;typename... Ts&gt;struct LengthOf&lt;TypeList&lt;Ts...&gt;&gt; &#123; static constexpr std::size_t value = sizeof...(Ts);&#125;; 通过上述内容及练习，相信您已全面掌握了 C++ 模板的各个方面。从基础概念到高级技术，模板为 C++ 编程提供了强大的工具。持续练习与应用，将进一步巩固您的模板编程能力。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"运算符重载详解","date":"2025-01-23T11:57:06.000Z","path":"2025/01/23/cppbase30/","text":"运算符重载概述运算符重载（Operator Overloading）允许开发者为自定义类型定义或重新定义运算符的行为，使得自定义类型的对象能够使用与内置类型相同的运算符进行操作。这不仅提高了代码的可读性，还增强了代码的表达能力。 为什么需要运算符重载在面向对象编程中，我们经常需要定义自己的类来表示某些实体（如复数、向量、矩形等）。为了使这些类的对象能够与内置类型一样方便地进行操作，运算符重载显得尤为重要。例如： 对于复数类，使用 + 运算符进行加法运算。 对于字符串类，使用 &lt;&lt; 运算符进行输出。 对于矩阵类，使用 * 运算符进行矩阵乘法。 通过运算符重载，可以使代码更简洁、直观，类似于数学表达式。 运算符重载的规则与限制 不能改变运算符的优先级和结合性：运算符的优先级和结合性在编译阶段就确定，不能通过重载来改变。 不能创建新的运算符：仅能重载C++中已有的运算符，不能定义新的运算符。 至少有一个操作数必须是用户定义的类型：不能对两个内置类型进行运算符重载。 某些运算符不能重载：包括 .（成员选择运算符）、.*、::、?:（条件运算符）等。 重载运算符的优先级和结合性不可改变。 运算符重载的方法在C++中，运算符可以通过成员函数或非成员函数（通常是友元函数）来重载。 成员函数方式运算符作为类的成员函数进行重载时，左操作数是当前对象（this）。因此，对于需要修改左操作数的运算符，成员函数方式通常更直观。 语法示例： 1234class ClassName &#123;public: ClassName operator+(const ClassName&amp; other);&#125;; 非成员函数方式（友元函数）当需要对两个不同类型的对象进行运算，或者左操作数不是当前类的对象时，通常使用非成员函数方式。为了访问类的私有成员，非成员函数通常被声明为类的友元函数。 语法示例： 123class ClassName &#123; friend ClassName operator+(const ClassName&amp; lhs, const ClassName&amp; rhs);&#125;; 1. 算术运算符1.1 + 运算符作用：实现两个对象的加法操作。 示例类：Complex（复数类） 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;class Complex &#123;private: double real; double imag;public: // 构造函数 Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) &#123;&#125; // 重载 + 运算符（成员函数） Complex operator+(const Complex&amp; other) const &#123; return Complex(this-&gt;real + other.real, this-&gt;imag + other.imag); &#125; // 重载 &lt;&lt; 运算符用于输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c) &#123; os &lt;&lt; &quot;(&quot; &lt;&lt; c.real; if (c.imag &gt;= 0) os &lt;&lt; &quot; + &quot; &lt;&lt; c.imag &lt;&lt; &quot;i)&quot;; else os &lt;&lt; &quot; - &quot; &lt;&lt; -c.imag &lt;&lt; &quot;i)&quot;; return os;&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(1.5, -2.5); Complex c3 = c1 + c2; std::cout &lt;&lt; &quot;c1 + c2 = &quot; &lt;&lt; c3 &lt;&lt; std::endl; return 0;&#125; 输出： 1c1 + c2 = (4.5 + 1.5i) 1.2 - 运算符作用：实现两个对象的减法操作。 示例类：Complex（复数类） 123456789101112131415// ...（与上面类似）// 重载 - 运算符（成员函数）Complex operator-(const Complex&amp; other) const &#123; return Complex(this-&gt;real - other.real, this-&gt;imag - other.imag);&#125;// 示例int main() &#123; Complex c1(5.0, 6.0); Complex c2(2.5, -1.5); Complex c4 = c1 - c2; std::cout &lt;&lt; &quot;c1 - c2 = &quot; &lt;&lt; c4 &lt;&lt; std::endl; return 0;&#125; 输出： 1c1 - c2 = (2.5 + 7.5i) 1.3 * 运算符作用：实现对象的乘法操作。 示例类：Complex（复数类） 1234567891011121314151617// ...（与上面类似）// 重载 * 运算符（成员函数）Complex operator*(const Complex&amp; other) const &#123; double r = this-&gt;real * other.real - this-&gt;imag * other.imag; double i = this-&gt;real * other.imag + this-&gt;imag * other.real; return Complex(r, i);&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(1.5, -2.5); Complex c5 = c1 * c2; std::cout &lt;&lt; &quot;c1 * c2 = &quot; &lt;&lt; c5 &lt;&lt; std::endl; return 0;&#125; 输出： 1c1 * c2 = (13.5 + 1i) 1.4 / 运算符作用：实现对象的除法操作。 示例类：Complex（复数类） 123456789101112131415161718192021222324252627#include &lt;stdexcept&gt;// ...（与上面类似）// 重载 / 运算符（成员函数）Complex operator/(const Complex&amp; other) const &#123; double denominator = other.real * other.real + other.imag * other.imag; if (denominator == 0) &#123; throw std::invalid_argument(&quot;除数为零！&quot;); &#125; double r = (this-&gt;real * other.real + this-&gt;imag * other.imag) / denominator; double i = (this-&gt;imag * other.real - this-&gt;real * other.imag) / denominator; return Complex(r, i);&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(1.5, -2.5); try &#123; Complex c6 = c1 / c2; std::cout &lt;&lt; &quot;c1 / c2 = &quot; &lt;&lt; c6 &lt;&lt; std::endl; &#125; catch (const std::invalid_argument&amp; e) &#123; std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 1c1 / c2 = (-0.823529 + 1.64706i) 2. 赋值运算符2.1 = 运算符作用：实现对象的赋值操作。 示例类：Complex（复数类） C++编译器会自动生成默认的拷贝赋值运算符，但当类中包含动态分配内存或需要自定义行为时，需要自行重载。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;class Complex &#123;private: double real; double imag;public: // 构造函数 Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) &#123;&#125; // 拷贝赋值运算符（成员函数） Complex&amp; operator=(const Complex&amp; other) &#123; if (this == &amp;other) return *this; // 防止自赋值 this-&gt;real = other.real; this-&gt;imag = other.imag; return *this; &#125; // 重载 &lt;&lt; 运算符用于输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c) &#123; os &lt;&lt; &quot;(&quot; &lt;&lt; c.real; if (c.imag &gt;= 0) os &lt;&lt; &quot; + &quot; &lt;&lt; c.imag &lt;&lt; &quot;i)&quot;; else os &lt;&lt; &quot; - &quot; &lt;&lt; -c.imag &lt;&lt; &quot;i)&quot;; return os;&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2; c2 = c1; // 使用拷贝赋值运算符 std::cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; c2 &lt;&lt; std::endl; return 0;&#125; 输出： 1c2 = (3 + 4i) 2.2 复合赋值运算符（+=, -=, *=, /=）作用：实现复合赋值操作，如 +=，-= 等。 示例类：Complex（复数类） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ...（与上面类似）// 重载 += 运算符（成员函数）Complex&amp; operator+=(const Complex&amp; other) &#123; this-&gt;real += other.real; this-&gt;imag += other.imag; return *this;&#125;// 重载 -= 运算符（成员函数）Complex&amp; operator-=(const Complex&amp; other) &#123; this-&gt;real -= other.real; this-&gt;imag -= other.imag; return *this;&#125;// 重载 *= 运算符（成员函数）Complex&amp; operator*=(const Complex&amp; other) &#123; double r = this-&gt;real * other.real - this-&gt;imag * other.imag; double i = this-&gt;real * other.imag + this-&gt;imag * other.real; this-&gt;real = r; this-&gt;imag = i; return *this;&#125;// 重载 /= 运算符（成员函数）Complex&amp; operator/=(const Complex&amp; other) &#123; double denominator = other.real * other.real + other.imag * other.imag; if (denominator == 0) &#123; throw std::invalid_argument(&quot;除数为零！&quot;); &#125; double r = (this-&gt;real * other.real + this-&gt;imag * other.imag) / denominator; double i = (this-&gt;imag * other.real - this-&gt;real * other.imag) / denominator; this-&gt;real = r; this-&gt;imag = i; return *this;&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(1.0, 2.0); c1 += c2; std::cout &lt;&lt; &quot;c1 += c2: &quot; &lt;&lt; c1 &lt;&lt; std::endl; c1 -= c2; std::cout &lt;&lt; &quot;c1 -= c2: &quot; &lt;&lt; c1 &lt;&lt; std::endl; c1 *= c2; std::cout &lt;&lt; &quot;c1 *= c2: &quot; &lt;&lt; c1 &lt;&lt; std::endl; try &#123; c1 /= c2; std::cout &lt;&lt; &quot;c1 /= c2: &quot; &lt;&lt; c1 &lt;&lt; std::endl; &#125; catch (const std::invalid_argument&amp; e) &#123; std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 1234c1 += c2: (4 + 6i)c1 -= c2: (3 + 4i)c1 *= c2: (-5 + 10i)c1 /= c2: (2 + 0i) 3. 比较运算符3.1 == 运算符作用：判断两个对象是否相等。 示例类：Complex（复数类） 12345678910111213141516171819202122232425262728// ...（与上面类似）// 重载 == 运算符（友元函数）friend bool operator==(const Complex&amp; lhs, const Complex&amp; rhs);// 实现 == 运算符bool operator==(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return (lhs.real == rhs.real) &amp;&amp; (lhs.imag == rhs.imag);&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(3.0, 4.0); Complex c3(1.5, -2.5); if (c1 == c2) std::cout &lt;&lt; &quot;c1 和 c2 相等&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 和 c2 不相等&quot; &lt;&lt; std::endl; if (c1 == c3) std::cout &lt;&lt; &quot;c1 和 c3 相等&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 和 c3 不相等&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 12c1 和 c2 相等c1 和 c3 不相等 3.2 != 运算符作用：判断两个对象是否不相等。 示例类：Complex（复数类） 12345678910111213141516171819202122232425262728// ...（与上面类似）// 重载 != 运算符（友元函数）friend bool operator!=(const Complex&amp; lhs, const Complex&amp; rhs);// 实现 != 运算符bool operator!=(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return !(lhs == rhs);&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(3.0, 4.0); Complex c3(1.5, -2.5); if (c1 != c2) std::cout &lt;&lt; &quot;c1 和 c2 不相等&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 和 c2 相等&quot; &lt;&lt; std::endl; if (c1 != c3) std::cout &lt;&lt; &quot;c1 和 c3 不相等&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 和 c3 相等&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 12c1 和 c2 相等c1 和 c3 不相等 3.3 &lt;, &gt;, &lt;=, &gt;= 运算符作用：实现对象之间的大小比较。对于复数来说，通常没有自然的大小顺序，但为了示例，可以定义复数的模长进行比较。 示例类：Complex（复数类） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cmath&gt;// ...（与上面类似）// 重载 &lt; 运算符（友元函数）friend bool operator&lt;(const Complex&amp; lhs, const Complex&amp; rhs);// 重载 &gt; 运算符（友元函数）friend bool operator&gt;(const Complex&amp; lhs, const Complex&amp; rhs);// 重载 &lt;= 运算符（友元函数）friend bool operator&lt;=(const Complex&amp; lhs, const Complex&amp; rhs);// 重载 &gt;= 运算符（友元函数）friend bool operator&gt;=(const Complex&amp; lhs, const Complex&amp; rhs);// 实现 &lt; 运算符bool operator&lt;(const Complex&amp; lhs, const Complex&amp; rhs) &#123; double lhs_mod = std::sqrt(lhs.real * lhs.real + lhs.imag * lhs.imag); double rhs_mod = std::sqrt(rhs.real * rhs.real + rhs.imag * rhs.imag); return lhs_mod &lt; rhs_mod;&#125;// 实现 &gt; 运算符bool operator&gt;(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return rhs &lt; lhs;&#125;// 实现 &lt;= 运算符bool operator&lt;=(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return !(rhs &lt; lhs);&#125;// 实现 &gt;= 运算符bool operator&gt;=(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return !(lhs &lt; rhs);&#125;// 示例int main() &#123; Complex c1(3.0, 4.0); // 模长 5 Complex c2(1.0, 2.0); // 模长 sqrt(5) ≈ 2.236 Complex c3(3.0, 4.0); // 模长 5 if (c1 &lt; c2) std::cout &lt;&lt; &quot;c1 的模长小于 c2 的模长&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 的模长不小于 c2 的模长&quot; &lt;&lt; std::endl; if (c1 &gt; c2) std::cout &lt;&lt; &quot;c1 的模长大于 c2 的模长&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 的模长不大于 c2 的模长&quot; &lt;&lt; std::endl; if (c1 &lt;= c3) std::cout &lt;&lt; &quot;c1 的模长小于或等于 c3 的模长&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 的模长大于 c3 的模长&quot; &lt;&lt; std::endl; if (c1 &gt;= c3) std::cout &lt;&lt; &quot;c1 的模长大于或等于 c3 的模长&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 的模长小于 c3 的模长&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 1234c1 的模长不小于 c2 的模长c1 的模长大于 c2 的模长c1 的模长小于或等于 c3 的模长c1 的模长大于或等于 c3 的模长 4. 逻辑运算符4.1 &amp;&amp;, ||, ! 运算符作用：实现逻辑操作。需要注意，C++ 中的 &amp;&amp; 和 || 运算符无法短路地重载，而且通常不建议重载它们，因为会改变其原有的逻辑语义。通常，建议使用类型转换或其他方法来实现逻辑判断。 示例类：Boolean 类（用于示例） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;class Boolean &#123;private: bool value;public: // 构造函数 Boolean(bool val = false) : value(val) &#123;&#125; // 重载逻辑非运算符（!）（成员函数） bool operator!() const &#123; return !value; &#125; // 重载逻辑与运算符（&amp;）（非短路）（成员函数） Boolean operator&amp;(const Boolean&amp; other) const &#123; return Boolean(this-&gt;value &amp; other.value); &#125; // 重载逻辑或运算符（|）（非短路）（成员函数） Boolean operator|(const Boolean&amp; other) const &#123; return Boolean(this-&gt;value | other.value); &#125; // 重载输出运算符 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Boolean&amp; b);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Boolean&amp; b) &#123; os &lt;&lt; (b.value ? &quot;true&quot; : &quot;false&quot;); return os;&#125;// 示例int main() &#123; Boolean b1(true); Boolean b2(false); Boolean b3 = b1 &amp; b2; Boolean b4 = b1 | b2; Boolean b5 = !b1; Boolean b6 = !b2; std::cout &lt;&lt; &quot;b1 &amp; b2 = &quot; &lt;&lt; b3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b1 | b2 = &quot; &lt;&lt; b4 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;!b1 = &quot; &lt;&lt; b5 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;!b2 = &quot; &lt;&lt; b6 &lt;&lt; std::endl; return 0;&#125; 输出： 1234b1 &amp; b2 = falseb1 | b2 = true!b1 = false!b2 = true 说明： 注意：在重载 &amp;&amp; 和 || 运算符时，要明白它们不会具有短路行为。因此，通常不建议重载这两个运算符。 本例中，使用 &amp; 和 | 运算符来模拟逻辑与、或操作。 5. 位运算符5.1 &amp;, |, ^, ~ 运算符作用：实现位级操作，如按位与、按位或、按位异或、按位取反。 示例类：Bitmask 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;class Bitmask &#123;private: unsigned int bits;public: // 构造函数 Bitmask(unsigned int b = 0) : bits(b) &#123;&#125; // 重载 &amp; 运算符（成员函数） Bitmask operator&amp;(const Bitmask&amp; other) const &#123; return Bitmask(this-&gt;bits &amp; other.bits); &#125; // 重载 | 运算符（成员函数） Bitmask operator|(const Bitmask&amp; other) const &#123; return Bitmask(this-&gt;bits | other.bits); &#125; // 重载 ^ 运算符（成员函数） Bitmask operator^(const Bitmask&amp; other) const &#123; return Bitmask(this-&gt;bits ^ other.bits); &#125; // 重载 ~ 运算符（成员函数） Bitmask operator~() const &#123; return Bitmask(~this-&gt;bits); &#125; // 重载 &lt;&lt; 运算符用于输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Bitmask&amp; b);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Bitmask&amp; b) &#123; os &lt;&lt; &quot;0x&quot; &lt;&lt; std::hex &lt;&lt; b.bits &lt;&lt; std::dec; return os;&#125;// 示例int main() &#123; Bitmask bm1(0b10101010); // 0xAA Bitmask bm2(0b11001100); // 0xCC Bitmask bm3 = bm1 &amp; bm2; Bitmask bm4 = bm1 | bm2; Bitmask bm5 = bm1 ^ bm2; Bitmask bm6 = ~bm1; std::cout &lt;&lt; &quot;bm1 &amp; bm2 = &quot; &lt;&lt; bm3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bm1 | bm2 = &quot; &lt;&lt; bm4 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bm1 ^ bm2 = &quot; &lt;&lt; bm5 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;~bm1 = &quot; &lt;&lt; bm6 &lt;&lt; std::endl; return 0;&#125; 输出： 1234bm1 &amp; bm2 = 0x88bm1 | bm2 = 0xeebm1 ^ bm2 = 0x66~bm1 = 0xffffff55 5.2 &lt;&lt;, &gt;&gt; 位移运算符作用：实现位移操作，如左移、右移。 示例类：Bitmask 类 123456789101112131415161718192021222324// ...（与上面类似）// 重载 &lt;&lt; 运算符（左移，成员函数）Bitmask operator&lt;&lt;(int shift) const &#123; return Bitmask(this-&gt;bits &lt;&lt; shift);&#125;// 重载 &gt;&gt; 运算符（右移，成员函数）Bitmask operator&gt;&gt;(int shift) const &#123; return Bitmask(this-&gt;bits &gt;&gt; shift);&#125;// 示例int main() &#123; Bitmask bm1(0b0001); // 0x1 Bitmask bm2 = bm1 &lt;&lt; 3; Bitmask bm3 = bm1 &gt;&gt; 1; std::cout &lt;&lt; &quot;bm1 &lt;&lt; 3 = &quot; &lt;&lt; bm2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bm1 &gt;&gt; 1 = &quot; &lt;&lt; bm3 &lt;&lt; std::endl; return 0;&#125; 输出： 12bm1 &lt;&lt; 3 = 0x8bm1 &gt;&gt; 1 = 0x0 说明： 重载位移运算符时，通常接受一个整型参数，表示位移的位数。 6. 自增自减运算符6.1 前置 ++ 和 -- 运算符作用：实现对象的自增和自减操作。 示例类：Counter 类 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class Counter &#123;private: int count;public: // 构造函数 Counter(int c = 0) : count(c) &#123;&#125; // 前置 ++ 运算符（成员函数） Counter&amp; operator++() &#123; ++count; return *this; &#125; // 前置 -- 运算符（成员函数） Counter&amp; operator--() &#123; --count; return *this; &#125; // 重载 &lt;&lt; 运算符用于输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Counter&amp; c);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Counter&amp; c) &#123; os &lt;&lt; c.count; return os;&#125;// 示例int main() &#123; Counter c(10); std::cout &lt;&lt; &quot;初始值: &quot; &lt;&lt; c &lt;&lt; std::endl; std::cout &lt;&lt; &quot;++c = &quot; &lt;&lt; ++c &lt;&lt; std::endl; std::cout &lt;&lt; &quot;--c = &quot; &lt;&lt; --c &lt;&lt; std::endl; return 0;&#125; 输出： 123初始值: 10++c = 11--c = 10 6.2 后置 ++ 和 -- 运算符作用：实现对象的后置自增和自减操作。 示例类：Counter 类 12345678910111213141516171819202122232425// ...（与上面类似）// 后置 ++ 运算符（成员函数）Counter operator++(int) &#123; Counter temp = *this; ++count; return temp;&#125;// 后置 -- 运算符（成员函数）Counter operator--(int) &#123; Counter temp = *this; --count; return temp;&#125;// 示例int main() &#123; Counter c(10); std::cout &lt;&lt; &quot;初始值: &quot; &lt;&lt; c &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c++ = &quot; &lt;&lt; c++ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c-- = &quot; &lt;&lt; c-- &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前值: &quot; &lt;&lt; c &lt;&lt; std::endl; return 0;&#125; 输出： 1234初始值: 10c++ = 10c-- = 11当前值: 10 说明： 前置运算符：先修改对象，再返回引用。 后置运算符：先保存原值，修改对象，再返回原值。 7. 下标运算符 []作用：实现对象的下标访问，如数组访问。 示例类：Vector 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdexcept&gt;class Vector &#123;private: std::vector&lt;double&gt; components;public: // 构造函数 Vector(const std::vector&lt;double&gt;&amp; comps) : components(comps) &#123;&#125; // 重载 [] 运算符（非 const） double&amp; operator[](size_t index) &#123; if (index &gt;= components.size()) &#123; throw std::out_of_range(&quot;下标越界！&quot;); &#125; return components[index]; &#125; // 重载 [] 运算符（const） const double&amp; operator[](size_t index) const &#123; if (index &gt;= components.size()) &#123; throw std::out_of_range(&quot;下标越界！&quot;); &#125; return components[index]; &#125; // 重载 &lt;&lt; 运算符用于输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&amp; v);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&amp; v) &#123; os &lt;&lt; &quot;(&quot;; for (size_t i = 0; i &lt; v.components.size(); ++i) &#123; os &lt;&lt; v.components[i]; if (i != v.components.size() - 1) os &lt;&lt; &quot;, &quot;; &#125; os &lt;&lt; &quot;)&quot;; return os;&#125;// 示例int main() &#123; Vector v(&#123;1.0, 2.0, 3.0&#125;); std::cout &lt;&lt; &quot;初始向量: &quot; &lt;&lt; v &lt;&lt; std::endl; // 访问元素 try &#123; std::cout &lt;&lt; &quot;v[1] = &quot; &lt;&lt; v[1] &lt;&lt; std::endl; v[1] = 5.0; std::cout &lt;&lt; &quot;修改后向量: &quot; &lt;&lt; v &lt;&lt; std::endl; &#125; catch (const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; // 访问越界 try &#123; std::cout &lt;&lt; &quot;v[3] = &quot; &lt;&lt; v[3] &lt;&lt; std::endl; // 越界 &#125; catch (const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 1234初始向量: (1, 2, 3)v[1] = 2修改后向量: (1, 5, 3)错误: 下标越界！ 说明： 提供了 const 和 非 const 两种重载，以支持不同上下文中的访问。 在访问时进行了边界检查，确保安全性。 8. 函数调用运算符 ()作用：使对象能够像函数一样被调用，常用于函数对象（functors）或仿函数。 示例类：Multiplier 类 1234567891011121314151617181920212223242526#include &lt;iostream&gt;class Multiplier &#123;private: double factor;public: // 构造函数 Multiplier(double f = 1.0) : factor(f) &#123;&#125; // 重载 () 运算符（成员函数） double operator()(double x) const &#123; return x * factor; &#125;&#125;;// 示例int main() &#123; Multiplier double_it(2.0); Multiplier triple_it(3.0); std::cout &lt;&lt; &quot;double_it(5) = &quot; &lt;&lt; double_it(5) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;triple_it(5) = &quot; &lt;&lt; triple_it(5) &lt;&lt; std::endl; return 0;&#125; 输出： 12double_it(5) = 10triple_it(5) = 15 说明： 通过重载 () 运算符，Multiplier 对象可以像函数一样接受参数并进行操作。 常用于需要定制函数行为的场景，如排序时的比较函数。 9. 输入输出运算符 &lt;&lt;, &gt;&gt;作用：实现对象与输入输出流之间的交互。 示例类：Complex（复数类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;stdexcept&gt;class Complex &#123;private: double real; double imag;public: // 构造函数 Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) &#123;&#125; // 重载 &lt;&lt; 运算符（友元函数） friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c); // 重载 &gt;&gt; 运算符（友元函数） friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Complex&amp; c);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c) &#123; os &lt;&lt; &quot;(&quot; &lt;&lt; c.real; if (c.imag &gt;= 0) os &lt;&lt; &quot; + &quot; &lt;&lt; c.imag &lt;&lt; &quot;i)&quot;; else os &lt;&lt; &quot; - &quot; &lt;&lt; -c.imag &lt;&lt; &quot;i)&quot;; return os;&#125;// 实现 &gt;&gt; 运算符std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Complex&amp; c) &#123; // 假设输入格式为：real imag is &gt;&gt; c.real &gt;&gt; c.imag; return is;&#125;// 示例int main() &#123; Complex c1; std::cout &lt;&lt; &quot;请输入复数的实部和虚部，以空格分隔: &quot;; std::cin &gt;&gt; c1; std::cout &lt;&lt; &quot;您输入的复数是: &quot; &lt;&lt; c1 &lt;&lt; std::endl; return 0;&#125; 示例输入： 1请输入复数的实部和虚部，以空格分隔: 3.5 -2.1 输出： 1您输入的复数是: (3.5 - 2.1i) 说明： &lt;&lt; 运算符用于输出对象到流中。 &gt;&gt; 运算符用于从流中输入对象的数据。 一般将这些运算符重载为友元函数，以便访问类的私有成员。 10. 其他运算符10.1 成员访问运算符 -&gt;, -&gt;*说明： 运算符 -&gt; 和 -&gt;* 通常用于代理模式或智能指针的实现，较为复杂。 其重载需要返回一个指针类型，以便进一步访问成员。 通常不建议普通类进行重载，除非有特定需求。 示例类：Proxy 类（代理模式） 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;class RealObject &#123;public: void display() const &#123; std::cout &lt;&lt; &quot;RealObject::display()&quot; &lt;&lt; std::endl; &#125;&#125;;class Proxy &#123;private: RealObject* ptr;public: // 构造函数 Proxy(RealObject* p = nullptr) : ptr(p) &#123;&#125; // 重载 -&gt; 运算符（成员函数） RealObject* operator-&gt;() const &#123; return ptr; &#125;&#125;;// 示例int main() &#123; RealObject real; Proxy proxy(&amp;real); proxy-&gt;display(); // 使用重载的 -&gt; 运算符 return 0;&#125; 输出： 1RealObject::display() 说明： Proxy 类通过重载 -&gt; 运算符，将对 Proxy 对象的成员访问转发给其内部的 RealObject 对象。 这是实现代理模式或智能指针的常见方式。 综合案例：复数（Complex）类中的所有运算符重载为了将上述所有运算符的重载整合在一个类中，以下是一个全面的 Complex 类示例，涵盖了大部分可重载的运算符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;stdexcept&gt;class Complex &#123;private: double real; double imag;public: // 构造函数 Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) &#123;&#125; // 拷贝赋值运算符 Complex&amp; operator=(const Complex&amp; other) &#123; if (this == &amp;other) return *this; this-&gt;real = other.real; this-&gt;imag = other.imag; return *this; &#125; // 重载 + 运算符（成员函数） Complex operator+(const Complex&amp; other) const &#123; return Complex(this-&gt;real + other.real, this-&gt;imag + other.imag); &#125; // 重载 - 运算符（成员函数） Complex operator-(const Complex&amp; other) const &#123; return Complex(this-&gt;real - other.real, this-&gt;imag - other.imag); &#125; // 重载 * 运算符（成员函数） Complex operator*(const Complex&amp; other) const &#123; double r = this-&gt;real * other.real - this-&gt;imag * other.imag; double i = this-&gt;real * other.imag + this-&gt;imag * other.real; return Complex(r, i); &#125; // 重载 / 运算符（成员函数） Complex operator/(const Complex&amp; other) const &#123; double denominator = other.real * other.real + other.imag * other.imag; if (denominator == 0) &#123; throw std::invalid_argument(&quot;除数为零！&quot;); &#125; double r = (this-&gt;real * other.real + this-&gt;imag * other.imag) / denominator; double i = (this-&gt;imag * other.real - this-&gt;real * other.imag) / denominator; return Complex(r, i); &#125; // 重载 += 运算符 Complex&amp; operator+=(const Complex&amp; other) &#123; this-&gt;real += other.real; this-&gt;imag += other.imag; return *this; &#125; // 重载 -= 运算符 Complex&amp; operator-=(const Complex&amp; other) &#123; this-&gt;real -= other.real; this-&gt;imag -= other.imag; return *this; &#125; // 重载 *= 运算符 Complex&amp; operator*=(const Complex&amp; other) &#123; double r = this-&gt;real * other.real - this-&gt;imag * other.imag; double i = this-&gt;real * other.imag + this-&gt;imag * other.real; this-&gt;real = r; this-&gt;imag = i; return *this; &#125; // 重载 /= 运算符 Complex&amp; operator/=(const Complex&amp; other) &#123; double denominator = other.real * other.real + other.imag * other.imag; if (denominator == 0) &#123; throw std::invalid_argument(&quot;除数为零！&quot;); &#125; double r = (this-&gt;real * other.real + this-&gt;imag * other.imag) / denominator; double i = (this-&gt;imag * other.real - this-&gt;real * other.imag) / denominator; this-&gt;real = r; this-&gt;imag = i; return *this; &#125; // 重载 == 运算符 friend bool operator==(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return (lhs.real == rhs.real) &amp;&amp; (lhs.imag == rhs.imag); &#125; // 重载 != 运算符 friend bool operator!=(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return !(lhs == rhs); &#125; // 重载 &lt; 运算符（基于模长） friend bool operator&lt;(const Complex&amp; lhs, const Complex&amp; rhs) &#123; double lhs_mod = std::sqrt(lhs.real * lhs.real + lhs.imag * lhs.imag); double rhs_mod = std::sqrt(rhs.real * rhs.real + rhs.imag * rhs.imag); return lhs_mod &lt; rhs_mod; &#125; // 重载 &gt; 运算符 friend bool operator&gt;(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return rhs &lt; lhs; &#125; // 重载 &lt;= 运算符 friend bool operator&lt;=(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return !(rhs &lt; lhs); &#125; // 重载 &gt;= 运算符 friend bool operator&gt;=(const Complex&amp; lhs, const Complex&amp; rhs) &#123; return !(lhs &lt; rhs); &#125; // 重载 &lt;&lt; 运算符 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; c) &#123; os &lt;&lt; &quot;(&quot; &lt;&lt; c.real; if (c.imag &gt;= 0) os &lt;&lt; &quot; + &quot; &lt;&lt; c.imag &lt;&lt; &quot;i)&quot;; else os &lt;&lt; &quot; - &quot; &lt;&lt; -c.imag &lt;&lt; &quot;i)&quot;; return os; &#125; // 重载 &gt;&gt; 运算符 friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Complex&amp; c) &#123; // 简单输入格式：real imag is &gt;&gt; c.real &gt;&gt; c.imag; return is; &#125; // 重载 ~ 运算符（取反复数） Complex operator~() const &#123; return Complex(this-&gt;real, -this-&gt;imag); &#125; // 重载逻辑非运算符（!） bool operator!() const &#123; return (this-&gt;real == 0 &amp;&amp; this-&gt;imag == 0); &#125; // 重载下标运算符（如 c[0] 返回 real, c[1] 返回 imag） double&amp; operator[](size_t index) &#123; if (index == 0) return real; else if (index == 1) return imag; else throw std::out_of_range(&quot;下标越界！&quot;); &#125; const double&amp; operator[](size_t index) const &#123; if (index == 0) return real; else if (index == 1) return imag; else throw std::out_of_range(&quot;下标越界！&quot;); &#125; // 重载前置 ++ 运算符 Complex&amp; operator++() &#123; ++real; ++imag; return *this; &#125; // 重载后置 ++ 运符 Complex operator++(int) &#123; Complex temp = *this; ++real; ++imag; return temp; &#125; // 重载前置 -- 运算符 Complex&amp; operator--() &#123; --real; --imag; return *this; &#125; // 重载后置 -- 运算符 Complex operator--(int) &#123; Complex temp = *this; --real; --imag; return temp; &#125; // 重载函数调用运算符 double operator()(const std::string&amp; part) const &#123; if (part == &quot;real&quot;) return real; else if (part == &quot;imag&quot;) return imag; else throw std::invalid_argument(&quot;参数错误！&quot;); &#125;&#125;;// 示例int main() &#123; Complex c1(3.0, 4.0); Complex c2(1.5, -2.5); Complex c3; // 赋值运算 c3 = c1; std::cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; c3 &lt;&lt; std::endl; // 加法 Complex c4 = c1 + c2; std::cout &lt;&lt; &quot;c1 + c2 = &quot; &lt;&lt; c4 &lt;&lt; std::endl; // 减法 Complex c5 = c1 - c2; std::cout &lt;&lt; &quot;c1 - c2 = &quot; &lt;&lt; c5 &lt;&lt; std::endl; // 乘法 Complex c6 = c1 * c2; std::cout &lt;&lt; &quot;c1 * c2 = &quot; &lt;&lt; c6 &lt;&lt; std::endl; // 除法 try &#123; Complex c7 = c1 / c2; std::cout &lt;&lt; &quot;c1 / c2 = &quot; &lt;&lt; c7 &lt;&lt; std::endl; &#125; catch (const std::invalid_argument&amp; e) &#123; std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; // 比较运算 if (c1 &gt; c2) std::cout &lt;&lt; &quot;c1 的模长大于 c2&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 的模长不大于 c2&quot; &lt;&lt; std::endl; // 逻辑非运算 Complex c_zero; if (!c1) std::cout &lt;&lt; &quot;c1 是零复数&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c1 不是零复数&quot; &lt;&lt; std::endl; if (!c_zero) std::cout &lt;&lt; &quot;c_zero 是零复数&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;c_zero 不是零复数&quot; &lt;&lt; std::endl; // 取反运算 Complex c_neg = ~c1; std::cout &lt;&lt; &quot;~c1 = &quot; &lt;&lt; c_neg &lt;&lt; std::endl; // 下标运算 try &#123; std::cout &lt;&lt; &quot;c1[0] (real) = &quot; &lt;&lt; c1[0] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c1[1] (imag) = &quot; &lt;&lt; c1[1] &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;c1[2] = &quot; &lt;&lt; c1[2] &lt;&lt; std::endl; // 会抛出异常 &#125; catch (const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; // 自增自减运算符 std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;++c1 = &quot; &lt;&lt; ++c1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c1++ = &quot; &lt;&lt; c1++ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;--c1 = &quot; &lt;&lt; --c1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c1-- = &quot; &lt;&lt; c1-- &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1 &lt;&lt; std::endl; // 函数调用运算符 std::cout &lt;&lt; &quot;c1 的实部: &quot; &lt;&lt; c1(&quot;real&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c1 的虚部: &quot; &lt;&lt; c1(&quot;imag&quot;) &lt;&lt; std::endl; // 输入运算 std::cout &lt;&lt; &quot;请输入一个复数的实部和虚部，以空格分隔: &quot;; Complex c_input; std::cin &gt;&gt; c_input; std::cout &lt;&lt; &quot;您输入的复数是: &quot; &lt;&lt; c_input &lt;&lt; std::endl; return 0;&#125; 示例运行： 12345678910111213141516171819202122c3 = (3 + 4i)c1 + c2 = (4.5 + 1.5i)c1 - c2 = (1.5 + 6.5i)c1 * c2 = (13.5 + 1i)c1 / c2 = (-0.823529 + 1.64706i)c1 的模长大于 c2c1 不是零复数c_zero 是零复数~c1 = (3 - 4i)c1[0] (real) = 3c1[1] (imag) = 4c1 = (3 + 4i)++c1 = (4 + 5i)c1++ = (4 + 5i)c1 = (5 + 6i)--c1 = (4 + 5i)c1-- = (4 + 5i)c1 = (3 + 4i)c1 的实部: 3c1 的虚部: 4请输入一个复数的实部和虚部，以空格分隔: 2.5 -3.5您输入的复数是: (2.5 - 3.5i) 说明： 该类集成了大部分可重载的运算符，包括算术、赋值、比较、逻辑、位运算、自增自减、下标、函数调用以及输入输出运算符。 某些运算符（如 &amp;&amp;, ||, -&gt;*）未在此示例中体现，因为它们的重载较为复杂且不常见。 在实际开发中，应根据需求选择性地重载运算符，避免过度设计。 11. 其他可重载运算符11.1 逗号运算符 ,作用：实现对象在逗号表达式中的行为。 示例类：Logger 类（用于示例） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;class Logger &#123;private: std::string message;public: // 构造函数 Logger(const std::string&amp; msg = &quot;&quot;) : message(msg) &#123;&#125; // 重载逗号运算符（成员函数） Logger operator,(const Logger&amp; other) const &#123; // 简单示例：连接日志消息 return Logger(this-&gt;message + &quot;, &quot; + other.message); &#125; // 重载 &lt;&lt; 运算符用于输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Logger&amp; l);&#125;;// 实现 &lt;&lt; 运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Logger&amp; l) &#123; os &lt;&lt; l.message; return os;&#125;// 示例int main() &#123; Logger log1(&quot;启动&quot;); Logger log2(&quot;加载配置&quot;); Logger log3(&quot;初始化&quot;); Logger combined = (log1, log2, log3); std::cout &lt;&lt; &quot;组合日志: &quot; &lt;&lt; combined &lt;&lt; std::endl; return 0;&#125; 输出： 1组合日志: 启动, 加载配置, 初始化 说明： 重载 , 运算符可以自定义逗号表达式的行为，但在实际应用中不常见，应谨慎使用。 多个逗号运算符的重载会按从左至右的顺序依次调用。 运算符重载注意事项 语义一致性：重载运算符后，其行为应与运算符的传统意义保持一致。例如，+ 应表示加法，避免引起混淆。 效率：尽量避免不必要的对象拷贝，可以通过返回引用或使用移动语义提升效率。 异常安全：在实现运算符重载时，考虑并处理可能的异常情况，确保程序的健壮性。 封装性：保持类的封装性，避免过度暴露内部细节。仅在必要时使用友元函数。 返回类型：根据运算符的用途选择合适的返回类型。例如，算术运算符通常返回新对象，赋值运算符返回引用等。 避免复杂的逻辑：运算符重载应简洁明了，不应包含过于复杂的逻辑，避免使代码难以理解和维护。 可读性：使用适当的注释和文档说明运算符重载的行为，增强代码的可读性。 小结运算符重载是C++中强大的特性，允许开发者为自定义类定义或重新定义运算符的行为，使对象的操作更加直观和符合逻辑。在设计和实现运算符重载时，应遵循语义一致性、效率和封装性等原则，避免滥用。通过本教案中的详细案例，学习者可以全面理解运算符重载的应用，并在实际编程中灵活运用。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"unorderedmap以及手写无序map","date":"2025-01-14T08:18:11.000Z","path":"2025/01/14/cppbase29/","text":"unordermap用法unordered_map 是 C++ 标准库中的关联容器，提供了基于哈希表的键值对存储结构。与 map （基于红黑树实现）不同，unordered_map 提供的是平均常数时间复杂度的查找、插入和删除操作，但不保证元素的顺序。 以下是 unordered_map 的详细用法说明： 1. 头文件要使用 unordered_map，需要包含头文件： 1#include &lt;unordered_map&gt; 2. 基本定义unordered_map 的基本模板定义如下： 1std::unordered_map&lt;KeyType, ValueType, Hash = std::hash&lt;KeyType&gt;, KeyEqual = std::equal_to&lt;KeyType&gt;, Allocator = std::allocator&lt;std::pair&lt;const KeyType, ValueType&gt;&gt;&gt; 常用模板参数： KeyType：键的类型，需要支持哈希运算和相等比较。 ValueType：值的类型。 Hash：哈希函数，默认为 std::hash&lt;KeyType&gt;。 KeyEqual：键相等的比较函数，默认为 std::equal_to&lt;KeyType&gt;。 Allocator：内存分配器，默认为 std::allocator。 3. 常用操作3.1 创建和初始化123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;int main() &#123; // 创建一个空的 unordered_map，键为 string，值为 int std::unordered_map&lt;std::string, int&gt; umap; // 使用初始化列表初始化 std::unordered_map&lt;std::string, int&gt; umap_init = &#123; &#123;&quot;apple&quot;, 3&#125;, &#123;&quot;banana&quot;, 5&#125;, &#123;&quot;orange&quot;, 2&#125; &#125;; // 使用其他容器范围初始化 std::map&lt;std::string, int&gt; ordered_map = &#123;&#123;&quot;carrot&quot;, 4&#125;, &#123;&quot;lettuce&quot;, 1&#125;&#125;; std::unordered_map&lt;std::string, int&gt; umap_from_map(ordered_map.begin(), ordered_map.end()); return 0;&#125; 3.2 插入元素12345678// 方法1：使用下标操作符umap[&quot;grape&quot;] = 7;// 方法2：使用 insertumap.insert(&#123;&quot;melon&quot;, 6&#125;);// 方法3：使用 emplace，直接在容器内部构造元素umap.emplace(&quot;kiwi&quot;, 4); 3.3 访问元素1234567891011121314151617// 使用下标操作符访问或插入int apple_count = umap[&quot;apple&quot;]; // 如果 &quot;apple&quot; 不存在，会插入一个默认值// 使用 at() 方法访问，不存在时会抛出异常try &#123; int banana_count = umap.at(&quot;banana&quot;);&#125; catch (const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;Key not found.&quot; &lt;&lt; std::endl;&#125;// 使用 find() 方法查找auto it = umap.find(&quot;orange&quot;);if (it != umap.end()) &#123; std::cout &lt;&lt; &quot;Orange count: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;&#125; else &#123; std::cout &lt;&lt; &quot;Orange not found.&quot; &lt;&lt; std::endl;&#125; 3.4 删除元素1234567891011// 根据键删除umap.erase(&quot;grape&quot;);// 根据迭代器删除auto it = umap.find(&quot;banana&quot;);if (it != umap.end()) &#123; umap.erase(it);&#125;// 清空整个容器umap.clear(); 3.5 遍历元素12345678for (const auto&amp; pair : umap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;&#125;// 使用迭代器for (auto it = umap.begin(); it != umap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;&#125; 3.6 其他常用方法1234567891011121314// 获取大小size_t size = umap.size();// 检查是否为空bool is_empty = umap.empty();// 获取桶的数量（用于哈希表内部结构）size_t bucket_count = umap.bucket_count();// 重新哈希，调整桶的数量umap.rehash(20);// 从一个容器中移交元素到另一个容器std::unordered_map&lt;std::string, int&gt; umap2 = std::move(umap); 4. 性能优化4.1 预分配桶数如果预先知道元素的大致数量，可以通过 reserve 预分配内存，以减少哈希表的重哈希开销： 1umap.reserve(100); // 预分配足够容纳100个元素的桶 4.2 自定义哈希函数如果键的类型是自定义类型或需要特殊的哈希策略，可以自定义哈希函数。例如，自定义结构体作为键： 1234567891011121314151617181920struct Point &#123; int x; int y; bool operator==(const Point&amp; other) const &#123; return x == other.x &amp;&amp; y == other.y; &#125;&#125;;// 自定义哈希函数struct PointHash &#123; std::size_t operator()(const Point&amp; p) const &#123; return std::hash&lt;int&gt;()(p.x) ^ (std::hash&lt;int&gt;()(p.y) &lt;&lt; 1); &#125;&#125;;// 定义 unordered_map 使用自定义哈希函数std::unordered_map&lt;Point, std::string, PointHash&gt; point_map;point_map[&#123;1, 2&#125;] = &quot;A&quot;;point_map[&#123;3, 4&#125;] = &quot;B&quot;; 4.3 自定义键相等比较如果需要自定义键的比较逻辑，可以提供自定义的 KeyEqual 函数对象： 12345678struct PointEqual &#123; bool operator()(const Point&amp; a, const Point&amp; b) const &#123; return (a.x == b.x) &amp;&amp; (a.y == b.y); &#125;&#125;;// 定义 unordered_map 使用自定义哈希和比较函数std::unordered_map&lt;Point, std::string, PointHash, PointEqual&gt; point_map; 5. 与 map 的比较 底层实现：unordered_map 基于哈希表，实现的操作平均时间复杂度为常数级别；map 基于红黑树，实现的查找、插入、删除操作时间复杂度为对数级别。 元素顺序：unordered_map 不保证元素的顺序；map 按键的顺序（通常是升序）存储元素。 适用场景：当需要快速查找、插入和删除，且不关心元素顺序时，选择 unordered_map；当需要有序存储或按顺序遍历时，选择 map。 6. 完整示例以下是一个使用 unordered_map 的完整示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;// 自定义类型struct Person &#123; std::string name; int age; bool operator==(const Person&amp; other) const &#123; return name == other.name &amp;&amp; age == other.age; &#125;&#125;;// 自定义哈希函数struct PersonHash &#123; std::size_t operator()(const Person&amp; p) const &#123; return std::hash&lt;std::string&gt;()(p.name) ^ (std::hash&lt;int&gt;()(p.age) &lt;&lt; 1); &#125;&#125;;int main() &#123; // 创建一个 unordered_map，键为 string，值为 int std::unordered_map&lt;std::string, int&gt; fruit_count; fruit_count[&quot;apple&quot;] = 5; fruit_count[&quot;banana&quot;] = 3; fruit_count.emplace(&quot;orange&quot;, 2); // 访问元素 std::cout &lt;&lt; &quot;Apple count: &quot; &lt;&lt; fruit_count[&quot;apple&quot;] &lt;&lt; std::endl; // 遍历 for (const auto&amp; pair : fruit_count) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; // 使用自定义类型作为键 std::unordered_map&lt;Person, std::string, PersonHash&gt; person_map; Person p1&#123;&quot;Alice&quot;, 30&#125;; Person p2&#123;&quot;Bob&quot;, 25&#125;; person_map[p1] = &quot;Engineer&quot;; person_map.emplace(p2, &quot;Designer&quot;); // 访问自定义类型键的值 Person p3&#123;&quot;Alice&quot;, 30&#125;; std::cout &lt;&lt; &quot;Alice&#x27;s job: &quot; &lt;&lt; person_map[p3] &lt;&lt; std::endl; return 0;&#125; 输出示例： 12345Apple count: 5banana: 3orange: 2apple: 5Alice&#x27;s job: Engineer 手写unordermap1. 哈希表的基本原理哈希表是一种基于键值对的数据结构，通过哈希函数（Hash Function）将键映射到表中的一个索引位置，以实现快速的数据访问。哈希表的关键特性包括： 哈希函数：将键映射到表中一个特定的桶（Bucket）或槽（Slot）。 冲突解决：当不同的键通过哈希函数映射到同一个桶时，需要一种机制来处理这些冲突。常见的方法有链地址法（Separate Chaining）和开放地址法（Open Addressing）。 负载因子（Load Factor）：表示表中已存储元素的数量与表大小之间的比率。高负载因子可能导致更多的冲突，需要通过扩容来维持性能。 在本实现中，我们将采用链地址法来处理哈希冲突，即每个桶存储一个链表（或其他动态数据结构）来存储具有相同哈希值的元素。 2. 数据结构设计HashNode 结构HashNode 用于存储键值对及相关的指针，以构建链表。每个 HashNode 包含键、值和指向下一个节点的指针。 12345678910111213141516#include &lt;vector&gt;#include &lt;list&gt;#include &lt;utility&gt; // For std::pair#include &lt;functional&gt; // For std::hash#include &lt;iterator&gt; // For iterator_traits#include &lt;stdexcept&gt; // For exceptions// HashNode 结构定义template &lt;typename Key, typename T&gt;struct HashNode &#123; std::pair&lt;const Key, T&gt; data; HashNode* next; HashNode(const Key&amp; key, const T&amp; value) : data(std::make_pair(key, value)), next(nullptr) &#123;&#125;&#125;; MyHashMap 类定义MyHashMap 是我们自定义的哈希表实现，支持基本的 Map 操作和迭代器功能。它使用一个向量（std::vector）来存储桶，每个桶是一个链表，用于处理冲突。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677template &lt;typename Key, typename T, typename Hash = std::hash&lt;Key&gt;&gt;class MyHashMap &#123;public: // 迭代器类前向声明 class Iterator; // 类型定义 using key_type = Key; using mapped_type = T; using value_type = std::pair&lt;const Key, T&gt;; using size_type = size_t; // 构造函数及析构函数 MyHashMap(size_type initial_capacity = 16, double max_load_factor = 0.75); ~MyHashMap(); // 禁止拷贝构造和赋值 MyHashMap(const MyHashMap&amp;) = delete; MyHashMap&amp; operator=(const MyHashMap&amp;) = delete; // 基本操作 void insert(const Key&amp; key, const T&amp; value); T* find(const Key&amp; key); const T* find(const Key&amp; key) const; bool erase(const Key&amp; key); size_type size() const; bool empty() const; void clear(); // 迭代器操作 Iterator begin(); Iterator end(); // 迭代器类 class Iterator &#123; public: // 迭代器别名 using iterator_category = std::forward_iterator_tag; using value_type = std::pair&lt;const Key, T&gt;; using difference_type = std::ptrdiff_t; using pointer = value_type*; using reference = value_type&amp;; // 构造函数 Iterator(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node); // 解引用操作符 reference operator*() const; pointer operator-&gt;() const; // 递增操作符 Iterator&amp; operator++(); Iterator operator++(int); // 比较操作符 bool operator==(const Iterator&amp; other) const; bool operator!=(const Iterator&amp; other) const; private: MyHashMap* map_; size_type bucket_index_; HashNode&lt;Key, T&gt;* current_node_; // 移动到下一个有效节点 void advance(); &#125;;private: std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_; size_type bucket_count_; size_type element_count_; double max_load_factor_; Hash hash_func_; // 辅助函数 void rehash();&#125;; 3. 基本操作实现构造函数及析构函数初始化哈希表，设置初始容量和负载因子。 123456789101112131415// 构造函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::MyHashMap(size_type initial_capacity, double max_load_factor) : bucket_count_(initial_capacity), element_count_(0), max_load_factor_(max_load_factor), hash_func_(Hash()) &#123; buckets_.resize(bucket_count_, nullptr);&#125;// 析构函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::~MyHashMap() &#123; clear();&#125; 插入（Insert）向哈希表中插入键值对。如果键已存在，则更新其值。 1234567891011121314151617181920212223242526template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::insert(const Key&amp; key, const T&amp; value) &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; node-&gt;data.second = value; // 更新值 return; &#125; node = node-&gt;next; &#125; // 键不存在，插入新节点到链表头部 HashNode&lt;Key, T&gt;* new_node = new HashNode&lt;Key, T&gt;(key, value); new_node-&gt;next = buckets_[index]; buckets_[index] = new_node; ++element_count_; // 检查负载因子，可能需要扩容 double load_factor = static_cast&lt;double&gt;(element_count_) / bucket_count_; if (load_factor &gt; max_load_factor_) &#123; rehash(); &#125;&#125; 查找（Find）根据键查找对应的值，返回指向值的指针。如果未找到，则返回 nullptr。 1234567891011121314151617181920212223242526272829template &lt;typename Key, typename T, typename Hash&gt;T* MyHashMap&lt;Key, T, Hash&gt;::find(const Key&amp; key) &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; return &amp;(node-&gt;data.second); &#125; node = node-&gt;next; &#125; return nullptr;&#125;template &lt;typename Key, typename T, typename Hash&gt;const T* MyHashMap&lt;Key, T, Hash&gt;::find(const Key&amp; key) const &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; return &amp;(node-&gt;data.second); &#125; node = node-&gt;next; &#125; return nullptr;&#125; 删除（Erase）根据键删除对应的键值对，返回删除是否成功。 123456789101112131415161718192021222324template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::erase(const Key&amp; key) &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; HashNode&lt;Key, T&gt;* prev = nullptr; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; if (prev == nullptr) &#123; buckets_[index] = node-&gt;next; &#125; else &#123; prev-&gt;next = node-&gt;next; &#125; delete node; --element_count_; return true; &#125; prev = node; node = node-&gt;next; &#125; return false; // 未找到键&#125; 清空（Clear）删除哈希表中的所有元素，释放内存。 12345678910111213template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::clear() &#123; for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; HashNode&lt;Key, T&gt;* node = buckets_[i]; while (node != nullptr) &#123; HashNode&lt;Key, T&gt;* temp = node; node = node-&gt;next; delete temp; &#125; buckets_[i] = nullptr; &#125; element_count_ = 0;&#125; 动态扩容（Rehashing）当负载因子超过阈值时，扩展哈希表容量并重新分配所有元素。 123456789101112131415161718192021222324template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::rehash() &#123; size_type new_bucket_count = bucket_count_ * 2; std::vector&lt;HashNode&lt;Key, T&gt;*&gt; new_buckets(new_bucket_count, nullptr); // 重新分配所有元素 for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; HashNode&lt;Key, T&gt;* node = buckets_[i]; while (node != nullptr) &#123; HashNode&lt;Key, T&gt;* next_node = node-&gt;next; size_type new_index = hash_func_(node-&gt;data.first) % new_bucket_count; // 插入到新桶的头部 node-&gt;next = new_buckets[new_index]; new_buckets[new_index] = node; node = next_node; &#125; &#125; // 替换旧桶 buckets_ = std::move(new_buckets); bucket_count_ = new_bucket_count;&#125; 获取大小和状态123456789template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::size_type MyHashMap&lt;Key, T, Hash&gt;::size() const &#123; return element_count_;&#125;template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::empty() const &#123; return element_count_ == 0;&#125; 4. 迭代器的实现为了支持迭代器操作，使 MyHashMap 能够像标准容器一样被遍历，我们需要实现一个内部的 Iterator 类。 Iterator 类定义Iterator 类需要跟踪当前桶的索引和当前节点指针。它还需要能够找到下一个有效的节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Iterator 构造函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::Iterator::Iterator(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node) : map_(map), bucket_index_(bucket_index), current_node_(node) &#123;&#125;// 解引用操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::Iterator::referenceMyHashMap&lt;Key, T, Hash&gt;::Iterator::operator*() const &#123; if (current_node_ == nullptr) &#123; throw std::out_of_range(&quot;Iterator out of range&quot;); &#125; return current_node_-&gt;data;&#125;// 成员访问操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointerMyHashMap&lt;Key, T, Hash&gt;::Iterator::operator-&gt;() const &#123; if (current_node_ == nullptr) &#123; throw std::out_of_range(&quot;Iterator out of range&quot;); &#125; return &amp;(current_node_-&gt;data);&#125;// 前置递增操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;MyHashMap&lt;Key, T, Hash&gt;::Iterator::operator++() &#123; advance(); return *this;&#125;// 后置递增操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::IteratorMyHashMap&lt;Key, T, Hash&gt;::Iterator::operator++(int) &#123; Iterator temp = *this; advance(); return temp;&#125;// 比较操作符==template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::Iterator::operator==(const Iterator&amp; other) const &#123; return map_ == other.map_ &amp;&amp; bucket_index_ == other.bucket_index_ &amp;&amp; current_node_ == other.current_node_;&#125;// 比较操作符!=template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::Iterator::operator!=(const Iterator&amp; other) const &#123; return !(*this == other);&#125;// advance 函数：移动到下一个有效节点template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::Iterator::advance() &#123; if (current_node_ != nullptr) &#123; current_node_ = current_node_-&gt;next; &#125; while (current_node_ == nullptr &amp;&amp; bucket_index_ + 1 &lt; map_-&gt;bucket_count_) &#123; ++bucket_index_; current_node_ = map_-&gt;buckets_[bucket_index_]; &#125;&#125; 迭代器操作在 MyHashMap 类中实现 begin() 和 end() 函数来返回迭代器。 123456789101112131415161718// begin() 函数template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::IteratorMyHashMap&lt;Key, T, Hash&gt;::begin() &#123; for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; if (buckets_[i] != nullptr) &#123; return Iterator(this, i, buckets_[i]); &#125; &#125; return end();&#125;// end() 函数template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::IteratorMyHashMap&lt;Key, T, Hash&gt;::end() &#123; return Iterator(this, bucket_count_, nullptr);&#125; 5. 完整代码示例以下是完整的 MyHashMap 实现，包括所有上述内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327#include &lt;vector&gt;#include &lt;list&gt;#include &lt;utility&gt; // For std::pair#include &lt;functional&gt; // For std::hash#include &lt;iterator&gt; // For iterator_traits#include &lt;stdexcept&gt; // For exceptions#include &lt;iostream&gt;// HashNode 结构定义template &lt;typename Key, typename T&gt;struct HashNode &#123; std::pair&lt;const Key, T&gt; data; HashNode* next; HashNode(const Key&amp; key, const T&amp; value) : data(std::make_pair(key, value)), next(nullptr) &#123;&#125;&#125;;// MyHashMap 类定义template &lt;typename Key, typename T, typename Hash = std::hash&lt;Key&gt;&gt;class MyHashMap &#123;public: // 迭代器类前向声明 class Iterator; // 类型定义 using key_type = Key; using mapped_type = T; using value_type = std::pair&lt;const Key, T&gt;; using size_type = size_t; // 构造函数及析构函数 MyHashMap(size_type initial_capacity = 16, double max_load_factor = 0.75); ~MyHashMap(); // 禁止拷贝构造和赋值 MyHashMap(const MyHashMap&amp;) = delete; MyHashMap&amp; operator=(const MyHashMap&amp;) = delete; // 基本操作 void insert(const Key&amp; key, const T&amp; value); T* find(const Key&amp; key); const T* find(const Key&amp; key) const; bool erase(const Key&amp; key); size_type size() const; bool empty() const; void clear(); // 迭代器操作 Iterator begin(); Iterator end(); // 迭代器类 class Iterator &#123; public: // 迭代器别名 using iterator_category = std::forward_iterator_tag; using value_type = std::pair&lt;const Key, T&gt;; using difference_type = std::ptrdiff_t; using pointer = value_type*; using reference = value_type&amp;; // 构造函数 Iterator(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node); // 解引用操作符 reference operator*() const; pointer operator-&gt;() const; // 递增操作符 Iterator&amp; operator++(); Iterator operator++(int); // 比较操作符 bool operator==(const Iterator&amp; other) const; bool operator!=(const Iterator&amp; other) const; private: MyHashMap* map_; size_type bucket_index_; HashNode&lt;Key, T&gt;* current_node_; // 移动到下一个有效节点 void advance(); &#125;;private: std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_; size_type bucket_count_; size_type element_count_; double max_load_factor_; Hash hash_func_; // 辅助函数 void rehash();&#125;;// 构造函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::MyHashMap(size_type initial_capacity, double max_load_factor) : bucket_count_(initial_capacity), element_count_(0), max_load_factor_(max_load_factor), hash_func_(Hash()) &#123; buckets_.resize(bucket_count_, nullptr);&#125;// 析构函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::~MyHashMap() &#123; clear();&#125;// 插入函数template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::insert(const Key&amp; key, const T&amp; value) &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; node-&gt;data.second = value; // 更新值 return; &#125; node = node-&gt;next; &#125; // 键不存在，插入新节点到链表头部 HashNode&lt;Key, T&gt;* new_node = new HashNode&lt;Key, T&gt;(key, value); new_node-&gt;next = buckets_[index]; buckets_[index] = new_node; ++element_count_; // 检查负载因子，可能需要扩容 double load_factor = static_cast&lt;double&gt;(element_count_) / bucket_count_; if (load_factor &gt; max_load_factor_) &#123; rehash(); &#125;&#125;// 查找函数（非常量版本）template &lt;typename Key, typename T, typename Hash&gt;T* MyHashMap&lt;Key, T, Hash&gt;::find(const Key&amp; key) &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; return &amp;(node-&gt;data.second); &#125; node = node-&gt;next; &#125; return nullptr;&#125;// 查找函数（常量版本）template &lt;typename Key, typename T, typename Hash&gt;const T* MyHashMap&lt;Key, T, Hash&gt;::find(const Key&amp; key) const &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; return &amp;(node-&gt;data.second); &#125; node = node-&gt;next; &#125; return nullptr;&#125;// 删除函数template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::erase(const Key&amp; key) &#123; size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, T&gt;* node = buckets_[index]; HashNode&lt;Key, T&gt;* prev = nullptr; while (node != nullptr) &#123; if (node-&gt;data.first == key) &#123; if (prev == nullptr) &#123; buckets_[index] = node-&gt;next; &#125; else &#123; prev-&gt;next = node-&gt;next; &#125; delete node; --element_count_; return true; &#125; prev = node; node = node-&gt;next; &#125; return false; // 未找到键&#125;// 清空函数template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::clear() &#123; for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; HashNode&lt;Key, T&gt;* node = buckets_[i]; while (node != nullptr) &#123; HashNode&lt;Key, T&gt;* temp = node; node = node-&gt;next; delete temp; &#125; buckets_[i] = nullptr; &#125; element_count_ = 0;&#125;// 动态扩容函数template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::rehash() &#123; size_type new_bucket_count = bucket_count_ * 2; std::vector&lt;HashNode&lt;Key, T&gt;*&gt; new_buckets(new_bucket_count, nullptr); // 重新分配所有元素 for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; HashNode&lt;Key, T&gt;* node = buckets_[i]; while (node != nullptr) &#123; HashNode&lt;Key, T&gt;* next_node = node-&gt;next; size_type new_index = hash_func_(node-&gt;data.first) % new_bucket_count; // 插入到新桶的头部 node-&gt;next = new_buckets[new_index]; new_buckets[new_index] = node; node = next_node; &#125; &#125; // 替换旧桶 buckets_ = std::move(new_buckets); bucket_count_ = new_bucket_count;&#125;// begin() 函数template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::IteratorMyHashMap&lt;Key, T, Hash&gt;::begin() &#123; for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; if (buckets_[i] != nullptr) &#123; return Iterator(this, i, buckets_[i]); &#125; &#125; return end();&#125;// end() 函数template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::IteratorMyHashMap&lt;Key, T, Hash&gt;::end() &#123; return Iterator(this, bucket_count_, nullptr);&#125;// Iterator 构造函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::Iterator::Iterator(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node) : map_(map), bucket_index_(bucket_index), current_node_(node) &#123;&#125;// 解引用操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::Iterator::referenceMyHashMap&lt;Key, T, Hash&gt;::Iterator::operator*() const &#123; if (current_node_ == nullptr) &#123; throw std::out_of_range(&quot;Iterator out of range&quot;); &#125; return current_node_-&gt;data;&#125;// 成员访问操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointerMyHashMap&lt;Key, T, Hash&gt;::Iterator::operator-&gt;() const &#123; if (current_node_ == nullptr) &#123; throw std::out_of_range(&quot;Iterator out of range&quot;); &#125; return &amp;(current_node_-&gt;data);&#125;// 前置递增操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;MyHashMap&lt;Key, T, Hash&gt;::Iterator::operator++() &#123; advance(); return *this;&#125;// 后置递增操作符template &lt;typename Key, typename T, typename Hash&gt;typename MyHashMap&lt;Key, T, Hash&gt;::IteratorMyHashMap&lt;Key, T, Hash&gt;::Iterator::operator++(int) &#123; Iterator temp = *this; advance(); return temp;&#125;// 比较操作符==template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::Iterator::operator==(const Iterator&amp; other) const &#123; return map_ == other.map_ &amp;&amp; bucket_index_ == other.bucket_index_ &amp;&amp; current_node_ == other.current_node_;&#125;// 比较操作符!=template &lt;typename Key, typename T, typename Hash&gt;bool MyHashMap&lt;Key, T, Hash&gt;::Iterator::operator!=(const Iterator&amp; other) const &#123; return !(*this == other);&#125;// advance 函数：移动到下一个有效节点template &lt;typename Key, typename T, typename Hash&gt;void MyHashMap&lt;Key, T, Hash&gt;::Iterator::advance() &#123; if (current_node_ != nullptr) &#123; current_node_ = current_node_-&gt;next; &#125; while (current_node_ == nullptr &amp;&amp; bucket_index_ + 1 &lt; map_-&gt;bucket_count_) &#123; ++bucket_index_; current_node_ = map_-&gt;buckets_[bucket_index_]; &#125;&#125; 6. 使用示例以下是一个使用 MyHashMap 的示例，展示如何插入、查找、删除以及使用迭代器遍历元素。 12345678910111213141516171819202122232425262728293031323334353637int main() &#123; MyHashMap&lt;std::string, int&gt; myMap; // 插入元素 myMap.insert(&quot;apple&quot;, 3); myMap.insert(&quot;banana&quot;, 5); myMap.insert(&quot;orange&quot;, 2); myMap.insert(&quot;grape&quot;, 7); myMap.insert(&quot;cherry&quot;, 4); // 使用迭代器遍历元素 std::cout &lt;&lt; &quot;Map contents:\\n&quot;; for(auto it = myMap.begin(); it != myMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; &#125; // 查找元素 std::string keyToFind = &quot;banana&quot;; int* value = myMap.find(keyToFind); if(value != nullptr) &#123; std::cout &lt;&lt; &quot;\\nFound &quot; &lt;&lt; keyToFind &lt;&lt; &quot; with value: &quot; &lt;&lt; *value &lt;&lt; &quot;\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;\\n&quot; &lt;&lt; keyToFind &lt;&lt; &quot; not found.\\n&quot;; &#125; // 删除元素 myMap.erase(&quot;apple&quot;); myMap.erase(&quot;cherry&quot;); // 再次遍历 std::cout &lt;&lt; &quot;\\nAfter erasing apple and cherry:\\n&quot;; for(auto it = myMap.begin(); it != myMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 预期输出12345678910111213Map contents:cherry =&gt; 4banana =&gt; 5apple =&gt; 3grape =&gt; 7orange =&gt; 2Found banana with value: 5After erasing apple and cherry:banana =&gt; 5grape =&gt; 7orange =&gt; 2 注意：由于哈希表的桶顺序依赖于哈希函数的实现，输出顺序可能与预期有所不同。 Hash() 在上述 MyHashMap 实现中是一个哈希函数对象。让我们详细解释一下它的含义以及它在代码中的作用。 Hash 是什么？在 MyHashMap 的模板定义中，Hash 是一个模板参数，用于指定键类型 Key 的哈希函数。它有一个默认值 std::hash&lt;Key&gt;，这意味着如果用户在实例化 MyHashMap 时没有提供自定义的哈希函数，std::hash&lt;Key&gt; 将被使用。 1234template &lt;typename Key, typename T, typename Hash = std::hash&lt;Key&gt;&gt;class MyHashMap &#123; // ...&#125;; 默认情况下：std::hash&lt;Key&gt;std::hash 是 C++ 标准库（STL）中提供的一个模板结构，用于为各种内置类型（如 int, std::string 等）生成哈希值。std::hash&lt;Key&gt; 会根据 Key 的类型自动选择合适的哈希函数实现。 例如： 对于 int 类型，std::hash&lt;int&gt; 会生成一个简单的哈希值。 对于 std::string 类型，std::hash&lt;std::string&gt; 会基于字符串内容生成哈希值。 12345std::hash&lt;int&gt; intHasher;size_t hashValue = intHasher(42); // 生成整数 42 的哈希值std::hash&lt;std::string&gt; stringHasher;size_t stringHash = stringHasher(&quot;hello&quot;); // 生成字符串 &quot;hello&quot; 的哈希值 自定义哈希函数除了使用 std::hash，用户还可以自定义哈希函数，以适应特定的需求或优化性能。例如，假设你有一个自定义的键类型 Point： 12345678struct Point &#123; int x; int y; bool operator==(const Point&amp; other) const &#123; return x == other.x &amp;&amp; y == other.y; &#125;&#125;; 你可以定义一个自定义的哈希函数 PointHasher： 123456struct PointHasher &#123; size_t operator()(const Point&amp; p) const &#123; // 简单的哈希组合，实际应用中应选择更好的哈希组合方法 return std::hash&lt;int&gt;()(p.x) ^ (std::hash&lt;int&gt;()(p.y) &lt;&lt; 1); &#125;&#125;; 然后，在实例化 MyHashMap 时使用自定义哈希函数： 123MyHashMap&lt;Point, std::string, PointHasher&gt; pointMap;Point p1&#123;1, 2&#125;;pointMap.insert(p1, &quot;Point1&quot;); Hash() 在代码中的作用在 MyHashMap 的构造函数中，Hash() 用于实例化哈希函数对象，并将其赋值给成员变量 hash_func_： 123456789// 构造函数template &lt;typename Key, typename T, typename Hash&gt;MyHashMap&lt;Key, T, Hash&gt;::MyHashMap(size_type initial_capacity, double max_load_factor) : bucket_count_(initial_capacity), element_count_(0), max_load_factor_(max_load_factor), hash_func_(Hash()) &#123; // 这里的 Hash() 是一个默认构造函数调用 buckets_.resize(bucket_count_, nullptr);&#125; 具体作用： 实例化哈希函数对象： Hash() 会调用 Hash 类型的默认构造函数，创建一个哈希函数对象。 如果 Hash 是 std::hash&lt;Key&gt;，那么就创建一个 std::hash&lt;Key&gt; 对象。 存储哈希函数对象： 生成的哈希函数对象被存储在成员变量 hash_func_ 中，以便在哈希表的各种操作（如插入、查找、删除）中使用。 支持不同的哈希函数： 由于 Hash 是一个模板参数，可以灵活地使用不同的哈希函数，无需修改 MyHashMap 的内部实现。 示例代码解释以下是相关部分的简化示例，帮助理解 Hash 和 Hash() 的作用： 123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;functional&gt; // For std::hashtemplate &lt;typename Key, typename T, typename Hash = std::hash&lt;Key&gt;&gt;class MyHashMap &#123;public: MyHashMap(size_t initial_capacity = 16, double max_load_factor = 0.75) : bucket_count_(initial_capacity), element_count_(0), max_load_factor_(max_load_factor), hash_func_(Hash()) &#123; // 实例化哈希函数对象 buckets_.resize(bucket_count_, nullptr); &#125; void insert(const Key&amp; key, const T&amp; value) &#123; size_t hash_value = hash_func_(key); // 使用哈希函数对象 size_t index = hash_value % bucket_count_; // 插入逻辑... &#125;private: std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_; size_t bucket_count_; size_t element_count_; double max_load_factor_; Hash hash_func_; // 存储哈希函数对象&#125;; 总结 Hash 是模板参数，用于指定键类型 Key 的哈希函数。默认情况下，它使用 C++ 标准库中的 std::hash&lt;Key&gt;。 Hash() 是一个默认构造函数调用，用于实例化哈希函数对象，并将其存储在 hash_func_ 成员变量中，以便在哈希表操作中使用。 用户可以自定义哈希函数，通过提供自定义的哈希函数对象，实现对特定键类型的优化或满足特殊需求。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"手写线程安全智能指针","date":"2024-12-27T06:11:08.000Z","path":"2024/12/27/cppbase27/","text":"现有 SimpleSharedPtr 的线程安全性分析在多线程环境下，确保智能指针的线程安全性主要涉及以下几个方面： 引用计数管理：多个线程可能会同时拷贝、移动或销毁智能指针实例，导致引用计数的修改。若引用计数不是原子操作，则会引发数据竞争和未定义行为。 指针和控制块的访问：多个线程可能会同时访问或修改同一个智能指针实例的 ptr 和 control 成员，这需要同步机制来保护。 当前 SimpleSharedPtr 的问题： 引用计数非原子：ControlBlock::ref_count 是普通的 int 类型，当多个线程同时修改 ref_count 时，会引发竞态条件。 缺乏同步机制：SimpleSharedPtr 的成员函数（如拷贝构造、赋值操作符等）在修改 ptr 和 control 时没有任何同步机制，导致多个线程同时操作同一个 SimpleSharedPtr 实例时不安全。 实现线程安全的 SimpleSharedPtr为了解决上述问题，可以从以下几个方面入手： 方法一：使用 std::atomic 管理引用计数将 ControlBlock::ref_count 从普通的 int 替换为 std::atomic&lt;int&gt;，以确保引用计数的线程安全递增和递减。 优点： 简单高效，避免使用互斥锁带来的性能开销。 类似于标准库中 std::shared_ptr 实现的引用计数管理。 缺点： 只能保证引用计数本身的线程安全，无法保护 ptr 和 control 的同步访问。 方法二：引入互斥锁保护指针操作在 SimpleSharedPtr 中引入 std::mutex，在所有可能修改 ptr 和 control 的操作中加锁。 优点： 确保 ptr 和 control 在多线程访问时的一致性。 提供更全面的线程安全保障。 缺点： 引入锁机制，可能带来性能开销，特别是在高并发场景下。 方法三：组合使用 std::atomic 和互斥锁结合使用 std::atomic&lt;int&gt; 进行引用计数的管理，并使用 std::mutex 保护指针和控制块的访问。 优点： 引用计数管理高效且线程安全。 指针和控制块的访问得到完全的同步保护。 缺点： 复杂性较高，需要同时管理原子操作和互斥锁。 完整线程安全的 ThreadSafeSharedPtr 实现结合上述方法二和方法一，我们可以实现一个名为 ThreadSafeSharedPtr 的类模板，确保在多线程环境下的安全性。以下是具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;mutex&gt;#include &lt;thread&gt;// 控制块结构struct ControlBlock &#123; std::atomic&lt;int&gt; ref_count; ControlBlock() : ref_count(1) &#123;&#125;&#125;;// 线程安全的 shared_ptr 实现template &lt;typename T&gt;class ThreadSafeSharedPtr &#123;private: T* ptr; // 指向管理的对象 ControlBlock* control; // 指向控制块 // 互斥锁，用于保护 ptr 和 control mutable std::mutex mtx; // 释放当前资源 void release() &#123; if (control) &#123; // 原子递减引用计数 if (--(control-&gt;ref_count) == 0) &#123; delete ptr; delete control; std::cout &lt;&lt; &quot;Resource and ControlBlock destroyed.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Decremented ref_count to &quot; &lt;&lt; control-&gt;ref_count.load() &lt;&lt; std::endl; &#125; &#125; ptr = nullptr; control = nullptr; &#125;public: // 默认构造函数 ThreadSafeSharedPtr() : ptr(nullptr), control(nullptr) &#123; std::cout &lt;&lt; &quot;Default constructed ThreadSafeSharedPtr (nullptr).&quot; &lt;&lt; std::endl; &#125; // 参数化构造函数 explicit ThreadSafeSharedPtr(T* p) : ptr(p) &#123; if (p) &#123; control = new ControlBlock(); std::cout &lt;&lt; &quot;Constructed ThreadSafeSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count.load() &lt;&lt; std::endl; &#125; else &#123; control = nullptr; &#125; &#125; // 拷贝构造函数 ThreadSafeSharedPtr(const ThreadSafeSharedPtr&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.mtx); ptr = other.ptr; control = other.control; if (control) &#123; control-&gt;ref_count++; std::cout &lt;&lt; &quot;Copied ThreadSafeSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count.load() &lt;&lt; std::endl; &#125; &#125; // 拷贝赋值操作符 ThreadSafeSharedPtr&amp; operator=(const ThreadSafeSharedPtr&amp; other) &#123; if (this != &amp;other) &#123; // 为避免死锁，使用 std::scoped_lock 同时锁定两个互斥锁 std::scoped_lock lock(mtx, other.mtx); release(); ptr = other.ptr; control = other.control; if (control) &#123; control-&gt;ref_count++; std::cout &lt;&lt; &quot;Assigned ThreadSafeSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count.load() &lt;&lt; std::endl; &#125; &#125; return *this; &#125; // 移动构造函数 ThreadSafeSharedPtr(ThreadSafeSharedPtr&amp;&amp; other) noexcept &#123; std::lock_guard&lt;std::mutex&gt; lock(other.mtx); ptr = other.ptr; control = other.control; other.ptr = nullptr; other.control = nullptr; std::cout &lt;&lt; &quot;Moved ThreadSafeSharedPtr.&quot; &lt;&lt; std::endl; &#125; // 移动赋值操作符 ThreadSafeSharedPtr&amp; operator=(ThreadSafeSharedPtr&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; // 为避免死锁，使用 std::scoped_lock 同时锁定两个互斥锁 std::scoped_lock lock(mtx, other.mtx); release(); ptr = other.ptr; control = other.control; other.ptr = nullptr; other.control = nullptr; std::cout &lt;&lt; &quot;Move-assigned ThreadSafeSharedPtr.&quot; &lt;&lt; std::endl; &#125; return *this; &#125; // 析构函数 ~ThreadSafeSharedPtr() &#123; release(); &#125; // 解引用操作符 T&amp; operator*() const &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); return *ptr; &#125; // 箭头操作符 T* operator-&gt;() const &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); return ptr; &#125; // 获取引用计数 int use_count() const &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); return control ? control-&gt;ref_count.load() : 0; &#125; // 获取裸指针 T* get() const &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); return ptr; &#125; // 重置指针 void reset(T* p = nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); release(); ptr = p; if (p) &#123; control = new ControlBlock(); std::cout &lt;&lt; &quot;Reset ThreadSafeSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count.load() &lt;&lt; std::endl; &#125; else &#123; control = nullptr; &#125; &#125;&#125;;// 测试类class Test &#123;public: Test(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Test Constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;Test Destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void show() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;private: int value;&#125;; 关键改动说明 引用计数原子化： 将 1ControlBlock::ref_count 从普通的 1int 改为 1std::atomic&lt;int&gt; ： 1std::atomic&lt;int&gt; ref_count; 使用原子操作管理引用计数，确保多线程下的安全递增和递减： 12control-&gt;ref_count++;if (--(control-&gt;ref_count) == 0) &#123; ... &#125; 使用 ref_count.load() 获取当前引用计数的值。 引入互斥锁： 在 1ThreadSafeSharedPtr 中引入 1std::mutex mtx ，用于保护 1ptr 和 1control 的访问： 1mutable std::mutex mtx; 在所有可能修改或访问 1ptr 和 1control 的成员函数中加锁，确保同步： 1std::lock_guard&lt;std::mutex&gt; lock(mtx); 在拷贝构造函数和拷贝赋值操作符中，为避免死锁，使用 1std::scoped_lock 同时锁定两个互斥锁： 1std::scoped_lock lock(mtx, other.mtx); 线程安全的成员函数： 对于 operator* 和 operator-&gt;，在返回前锁定互斥锁，确保在多线程环境中的安全访问。 其他成员函数如 use_count、get 和 reset 同样在访问共享资源前加锁。 注意事项 避免死锁：在需要同时锁定多个互斥锁时，使用 std::scoped_lock（C++17 引入）可以同时锁定多个互斥锁，避免死锁风险。 性能开销：引入互斥锁会带来一定的性能开销，尤其是在高并发场景下。根据实际需求，权衡线程安全性和性能之间的关系。 测试线程安全的 ThreadSafeSharedPtr为了验证 ThreadSafeSharedPtr 的线程安全性，我们可以编写一个多线程程序，让多个线程同时拷贝、赋值和销毁智能指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &quot;ThreadSafeSharedPtr.h&quot; // 假设将上述代码保存为该头文件// 测试类class Test &#123;public: Test(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Test Constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;Test Destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void show() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;private: int value;&#125;;void thread_func_copy(ThreadSafeSharedPtr&lt;Test&gt; sptr, int thread_id) &#123; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; thread_id &lt;&lt; &quot; is copying shared_ptr.&quot; &lt;&lt; std::endl; ThreadSafeSharedPtr&lt;Test&gt; local_sptr = sptr; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; thread_id &lt;&lt; &quot; copied shared_ptr, use_count = &quot; &lt;&lt; local_sptr.use_count() &lt;&lt; std::endl; local_sptr-&gt;show();&#125;void thread_func_reset(ThreadSafeSharedPtr&lt;Test&gt;&amp; sptr, int new_val, int thread_id) &#123; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; thread_id &lt;&lt; &quot; is resetting shared_ptr.&quot; &lt;&lt; std::endl; sptr.reset(new Test(new_val)); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; thread_id &lt;&lt; &quot; reset shared_ptr, use_count = &quot; &lt;&lt; sptr.use_count() &lt;&lt; std::endl; sptr-&gt;show();&#125;int main() &#123; std::cout &lt;&lt; &quot;Creating ThreadSafeSharedPtr with Test(100).&quot; &lt;&lt; std::endl; ThreadSafeSharedPtr&lt;Test&gt; sptr(new Test(100)); std::cout &lt;&lt; &quot;Initial use_count: &quot; &lt;&lt; sptr.use_count() &lt;&lt; std::endl; // 创建多个线程进行拷贝操作 const int num_threads = 5; std::vector&lt;std::thread&gt; threads_copy; for(int i = 0; i &lt; num_threads; ++i) &#123; threads_copy.emplace_back(thread_func_copy, sptr, i); &#125; for(auto&amp; t : threads_copy) &#123; t.join(); &#125; std::cout &lt;&lt; &quot;After copy threads, use_count: &quot; &lt;&lt; sptr.use_count() &lt;&lt; std::endl; // 创建多个线程进行 reset 操作 std::vector&lt;std::thread&gt; threads_reset; for(int i = 0; i &lt; num_threads; ++i) &#123; threads_reset.emplace_back(thread_func_reset, std::ref(sptr), 200 + i, i); &#125; for(auto&amp; t : threads_reset) &#123; t.join(); &#125; std::cout &lt;&lt; &quot;After reset threads, final use_count: &quot; &lt;&lt; sptr.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Exiting main.&quot; &lt;&lt; std::endl; return 0;&#125; 预期输出示例（具体顺序可能因线程调度而异）： 123456789101112131415161718192021222324Creating ThreadSafeSharedPtr with Test(100).Test Constructor: 100Constructed ThreadSafeSharedPtr, ref_count = 1Initial use_count: 1Thread 0 is copying shared_ptr.Copied ThreadSafeSharedPtr, ref_count = 2Thread 0 copied shared_ptr, use_count = 2Value: 100Thread 1 is copying shared_ptr.Copied ThreadSafeSharedPtr, ref_count = 3Thread 1 copied shared_ptr, use_count = 3Value: 100...After copy threads, use_count: 6Thread 0 is resetting shared_ptr.Decremented ref_count to 5Resource and ControlBlock destroyed.Test Constructor: 200Reset ThreadSafeSharedPtr, ref_count = 1Value: 200...After reset threads, final use_count: 1Exiting main.Test Destructor: 200 说明： 多个线程同时拷贝 sptr，引用计数正确递增。 多个线程同时重置 sptr，确保引用计数和资源管理的正确性。 最终，只有最新分配的对象存在，引用计数为 1。 注意事项和最佳实践 引用计数的原子性： 使用 std::atomic&lt;int&gt; 来保证引用计数的线程安全递增和递减。 避免使用普通的 int，因为在多线程环境下会导致数据竞争。 互斥锁的使用： 使用 std::mutex 来保护 ptr 和 control 的访问，防止多个线程同时修改智能指针实例。 尽量缩小锁的范围，避免在互斥锁保护的临界区内执行耗时操作，以减少性能开销。 避免死锁： 在需要同时锁定多个互斥锁时，使用 std::scoped_lock 来一次性锁定，确保锁的顺序一致，避免死锁风险。 尽量遵循 RAII 原则： 使用 std::lock_guard 或 std::scoped_lock 等 RAII 机制来管理互斥锁，确保在异常抛出时自动释放锁，防止死锁。 避免多重管理： 确保不通过裸指针绕过智能指针的引用计数管理，避免资源泄漏或重复释放。 性能考虑： 在高并发场景下，频繁的锁操作可能成为性能瓶颈。根据实际需求，可以考虑使用更轻量级的同步机制，如 std::shared_mutex（C++17）用于读多写少的场景。 总结通过将 ControlBlock::ref_count 改为 std::atomic&lt;int&gt;，并在 ThreadSafeSharedPtr 中引入互斥锁来保护 ptr 和 control 的访问，可以实现一个线程安全的智能指针。这种实现确保了在多线程环境下，多个线程可以安全地拷贝、赋值和销毁智能指针，同时正确管理引用计数和资源。 关键点总结： 引用计数的原子性：使用 std::atomic&lt;int&gt; 保证引用计数操作的线程安全。 互斥锁保护：使用 std::mutex 保护智能指针实例的内部状态，防止多个线程同时修改。 RAII 机制：利用 std::lock_guard 和 std::scoped_lock 等 RAII 机制，确保锁的正确管理和释放。 避免死锁：在需要同时锁定多个互斥锁时，使用 std::scoped_lock 以避免死锁风险。 性能优化：平衡线程安全性和性能，避免不必要的锁竞争。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"map用法和手写map","date":"2024-12-27T06:11:08.000Z","path":"2024/12/27/cppbase28/","text":"std::map用法std::map 是 C++ 标准模板库（STL）中的一个关联容器，用于存储键值对（key-value pairs），其中每个键都是唯一的，并且按照特定的顺序（通常是升序）自动排序。std::map 通常基于红黑树实现，提供对元素的高效查找、插入和删除操作。 1. 基本特性 有序性：std::map 中的元素按照键的顺序自动排序，默认使用 &lt; 运算符进行比较。 唯一键：每个键在 std::map 中必须是唯一的，如果尝试插入重复的键，则插入操作会失败。 关联容器：通过键快速访问对应的值，通常具有对数时间复杂度（O(log n)）。 可变性：可以动态地插入和删除元素。 2. 头文件和命名空间要使用 std::map，需要包含头文件 &lt;map&gt; 并使用 std 命名空间： 12345#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; 3. 声明和初始化3.1 声明一个 std::map12345// 键为 int，值为 std::string 的 mapmap&lt;int, string&gt; myMap;// 键为 std::string，值为 double 的 mapmap&lt;string, double&gt; priceMap; 3.2 初始化 std::map可以使用初始化列表或其他方法初始化 map： 12345map&lt;int, string&gt; myMap = &#123; &#123;1, &quot;Apple&quot;&#125;, &#123;2, &quot;Banana&quot;&#125;, &#123;3, &quot;Cherry&quot;&#125;&#125;; 4. 主要操作4.1 插入元素有几种方法可以向 std::map 中插入元素： 4.1.1 使用 insert 函数12345myMap.insert(pair&lt;int, string&gt;(4, &quot;Date&quot;));// 或者使用 `make_pair`myMap.insert(make_pair(5, &quot;Elderberry&quot;));// 或者使用初始化列表myMap.insert(&#123;6, &quot;Fig&quot;&#125;); 4.1.2 使用下标运算符 []123myMap[7] = &quot;Grape&quot;;// 如果键 8 不存在，则会插入键 8 并赋值myMap[8] = &quot;Honeydew&quot;; 注意：使用 [] 运算符时，如果键不存在，会自动插入该键，并将值初始化为类型的默认值。 4.2 访问元素4.2.1 使用下标运算符 []1string fruit = myMap[1]; // 获取键为 1 的值 &quot;Apple&quot; 注意：如果键不存在，[] 会插入该键并返回默认值。 4.2.2 使用 at 成员函数12345try &#123; string fruit = myMap.at(2); // 获取键为 2 的值 &quot;Banana&quot;&#125; catch (const out_of_range&amp; e) &#123; cout &lt;&lt; &quot;Key not found.&quot; &lt;&lt; endl;&#125; at 函数在键不存在时会抛出 std::out_of_range 异常，适合需要异常处理的场景。 4.2.3 使用 find 成员函数123456auto it = myMap.find(3);if (it != myMap.end()) &#123; cout &lt;&lt; &quot;Key 3: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; // 输出 &quot;Cherry&quot;&#125; else &#123; cout &lt;&lt; &quot;Key 3 not found.&quot; &lt;&lt; endl;&#125; find 返回一个迭代器，指向找到的元素，若未找到则返回 map::end()。 4.3 删除元素4.3.1 使用 erase 函数1234567891011// 按键删除myMap.erase(2);// 按迭代器删除auto it = myMap.find(3);if (it != myMap.end()) &#123; myMap.erase(it);&#125;// 删除区间 [first, last)myMap.erase(myMap.begin(), myMap.find(5)); 4.3.2 使用 clear 函数1myMap.clear(); // 删除所有元素 4.4 遍历 std::map4.4.1 使用迭代器123for (map&lt;int, string&gt;::iterator it = myMap.begin(); it != myMap.end(); ++it) &#123; cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;, Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125; 4.4.2 使用基于范围的 for 循环（C++11 及以上）123for (const auto&amp; pair : myMap) &#123; cout &lt;&lt; &quot;Key: &quot; &lt;&lt; pair.first &lt;&lt; &quot;, Value: &quot; &lt;&lt; pair.second &lt;&lt; endl;&#125; 4.5 常用成员函数 **size()**：返回容器中元素的数量。 **empty()**：判断容器是否为空。 **count(key)**：返回具有指定键的元素数量（对于 map，返回 0 或 1）。 lower_bound(key) 和 **upper_bound(key)**：返回迭代器，分别指向第一个不小于和第一个大于指定键的元素。 **equal_range(key)**：返回一个范围，包含所有等于指定键的元素。 5. 自定义键的排序默认情况下，std::map 使用 &lt; 运算符对键进行排序。如果需要自定义排序方式，可以提供一个自定义的比较函数或函数对象。 5.1 使用函数对象12345678910struct Compare &#123; bool operator()(const int&amp; a, const int&amp; b) const &#123; return a &gt; b; // 降序排序 &#125;&#125;;map&lt;int, string, Compare&gt; myMapDesc;myMapDesc[1] = &quot;Apple&quot;;myMapDesc[2] = &quot;Banana&quot;;// ... 5.2 使用 lambda 表达式（C++11 及以上）需要注意，std::map 的第三个模板参数必须是可比较类型，不能直接使用 lambda 表达式作为模板参数。不过，可以使用 std::function 或自定义结构体来包装 lambda。 123456789struct CompareLambda &#123; bool operator()(const int&amp; a, const int&amp; b) const &#123; return a &gt; b; // 降序排序 &#125;&#125;;map&lt;int, string, CompareLambda&gt; myMapDesc;myMapDesc[1] = &quot;Apple&quot;;// ... 6. std::map 与其他关联容器的比较 **std::unordered_map**：基于哈希表实现，提供平均常数时间复杂度的查找、插入和删除操作，但不保证元素的顺序。适用于对顺序无要求且需要高效查找的场景。 **std::multimap**：允许多个相同键的元素，其他特性与 std::map 类似。适用于需要存储重复键值对的场景。 7. 性能考虑 时间复杂度 ： 查找、插入、删除：O(log n) 遍历：O(n) 空间复杂度：std::map 通常需要额外的空间来维护树结构，相比 std::vector 等序列容器，内存开销更大。 选择使用 std::map 还是其他容器，应根据具体需求和性能要求进行权衡。 8. 完整示例以下是一个完整的示例，展示了 std::map 的基本用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main() &#123; // 创建一个 map，键为 int，值为 string map&lt;int, string&gt; myMap; // 插入元素 myMap[1] = &quot;Apple&quot;; myMap[2] = &quot;Banana&quot;; myMap.insert(&#123;3, &quot;Cherry&quot;&#125;); myMap.insert(make_pair(4, &quot;Date&quot;)); // 访问元素 cout &lt;&lt; &quot;Key 1: &quot; &lt;&lt; myMap[1] &lt;&lt; endl; cout &lt;&lt; &quot;Key 2: &quot; &lt;&lt; myMap.at(2) &lt;&lt; endl; // 查找元素 int keyToFind = 3; auto it = myMap.find(keyToFind); if (it != myMap.end()) &#123; cout &lt;&lt; &quot;Found key &quot; &lt;&lt; keyToFind &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Key &quot; &lt;&lt; keyToFind &lt;&lt; &quot; not found.&quot; &lt;&lt; endl; &#125; // 遍历 map cout &lt;&lt; &quot;All elements:&quot; &lt;&lt; endl; for (const auto&amp; pair : myMap) &#123; cout &lt;&lt; &quot;Key: &quot; &lt;&lt; pair.first &lt;&lt; &quot;, Value: &quot; &lt;&lt; pair.second &lt;&lt; endl; &#125; // 删除元素 myMap.erase(2); cout &lt;&lt; &quot;After deleting key 2:&quot; &lt;&lt; endl; for (const auto&amp; pair : myMap) &#123; cout &lt;&lt; &quot;Key: &quot; &lt;&lt; pair.first &lt;&lt; &quot;, Value: &quot; &lt;&lt; pair.second &lt;&lt; endl; &#125; // 检查是否为空 if (!myMap.empty()) &#123; cout &lt;&lt; &quot;Map is not empty. Size: &quot; &lt;&lt; myMap.size() &lt;&lt; endl; &#125; // 清空所有元素 myMap.clear(); cout &lt;&lt; &quot;After clearing, map is &quot; &lt;&lt; (myMap.empty() ? &quot;empty.&quot; : &quot;not empty.&quot;) &lt;&lt; endl; return 0;&#125; 输出： 1234567891011121314Key 1: AppleKey 2: BananaFound key 3: CherryAll elements:Key: 1, Value: AppleKey: 2, Value: BananaKey: 3, Value: CherryKey: 4, Value: DateAfter deleting key 2:Key: 1, Value: AppleKey: 3, Value: CherryKey: 4, Value: DateMap is not empty. Size: 3After clearing, map is empty. BST实现map1. 选择底层数据结构std::map 通常基于平衡的二叉搜索树（如红黑树）实现，以保证操作的时间复杂度为 O(log n)。为了简化实现，本文将采用普通的二叉搜索树，即不进行自平衡处理。不过在实际应用中，为了保证性能，建议使用自平衡的树结构（例如红黑树、AVL 树）。 2. 设计数据结构2.1 节点结构首先，需要定义树的节点结构，每个节点包含键值对以及指向子节点的指针。 123456789101112131415#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;utility&gt; // For std::pair#include &lt;exception&gt;template &lt;typename Key, typename T&gt;struct TreeNode &#123; std::pair&lt;Key, T&gt; data; TreeNode* left; TreeNode* right; TreeNode* parent; TreeNode(const Key&amp; key, const T&amp; value, TreeNode* parentNode = nullptr) : data(std::make_pair(key, value)), left(nullptr), right(nullptr), parent(parentNode) &#123;&#125;&#125;; 2.2 Map 类的定义接下来，定义 MyMap 类，包含根节点和基本操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186template &lt;typename Key, typename T&gt;class MyMap &#123;public: MyMap() : root(nullptr) &#123;&#125; ~MyMap() &#123; clear(root); &#125; // 禁止拷贝构造和赋值 MyMap(const MyMap&amp;) = delete; MyMap&amp; operator=(const MyMap&amp;) = delete; // 插入或更新键值对 void insert(const Key&amp; key, const T&amp; value) &#123; if (root == nullptr) &#123; root = new TreeNode&lt;Key, T&gt;(key, value); return; &#125; TreeNode&lt;Key, T&gt;* current = root; TreeNode&lt;Key, T&gt;* parent = nullptr; while (current != nullptr) &#123; parent = current; if (key &lt; current-&gt;data.first) &#123; current = current-&gt;left; &#125; else if (key &gt; current-&gt;data.first) &#123; current = current-&gt;right; &#125; else &#123; // 键已存在，更新值 current-&gt;data.second = value; return; &#125; &#125; if (key &lt; parent-&gt;data.first) &#123; parent-&gt;left = new TreeNode&lt;Key, T&gt;(key, value, parent); &#125; else &#123; parent-&gt;right = new TreeNode&lt;Key, T&gt;(key, value, parent); &#125; &#125; // 查找元素，返回指向节点的指针 TreeNode&lt;Key, T&gt;* find(const Key&amp; key) const &#123; TreeNode&lt;Key, T&gt;* current = root; while (current != nullptr) &#123; if (key &lt; current-&gt;data.first) &#123; current = current-&gt;left; &#125; else if (key &gt; current-&gt;data.first) &#123; current = current-&gt;right; &#125; else &#123; return current; &#125; &#125; return nullptr; &#125; // 删除元素 void erase(const Key&amp; key) &#123; TreeNode&lt;Key, T&gt;* node = find(key); if (node == nullptr) return; // 没有找到要删除的节点 // 节点有两个子节点 if (node-&gt;left != nullptr &amp;&amp; node-&gt;right != nullptr) &#123; // 找到中序后继 TreeNode&lt;Key, T&gt;* successor = minimum(node-&gt;right); node-&gt;data = successor-&gt;data; // 替换数据 node = successor; // 将要删除的节点指向后继节点 &#125; // 节点有一个或没有子节点 TreeNode&lt;Key, T&gt;* child = (node-&gt;left) ? node-&gt;left : node-&gt;right; if (child != nullptr) &#123; child-&gt;parent = node-&gt;parent; &#125; if (node-&gt;parent == nullptr) &#123; root = child; &#125; else if (node == node-&gt;parent-&gt;left) &#123; node-&gt;parent-&gt;left = child; &#125; else &#123; node-&gt;parent-&gt;right = child; &#125; delete node; &#125; // 清空所有节点 void clear() &#123; clear(root); root = nullptr; &#125; // 获取迭代器 class Iterator &#123; public: Iterator(TreeNode&lt;Key, T&gt;* node = nullptr) : current(node) &#123;&#125; std::pair&lt;const Key, T&gt;&amp; operator*() const &#123; return current-&gt;data; &#125; std::pair&lt;const Key, T&gt;* operator-&gt;() const &#123; return &amp;(current-&gt;data); &#125; // 前置递增 Iterator&amp; operator++() &#123; current = successor(current); return *this; &#125; // 后置递增 Iterator operator++(int) &#123; Iterator temp = *this; current = successor(current); return temp; &#125; bool operator==(const Iterator&amp; other) const &#123; return current == other.current; &#125; bool operator!=(const Iterator&amp; other) const &#123; return current != other.current; &#125; private: TreeNode&lt;Key, T&gt;* current; TreeNode&lt;Key, T&gt;* minimum(TreeNode&lt;Key, T&gt;* node) const &#123; while (node-&gt;left != nullptr) &#123; node = node-&gt;left; &#125; return node; &#125; TreeNode&lt;Key, T&gt;* successor(TreeNode&lt;Key, T&gt;* node) const &#123; if (node-&gt;right != nullptr) &#123; return minimum(node-&gt;right); &#125; TreeNode&lt;Key, T&gt;* p = node-&gt;parent; while (p != nullptr &amp;&amp; node == p-&gt;right) &#123; node = p; p = p-&gt;parent; &#125; return p; &#125; &#125;; Iterator begin() const &#123; return Iterator(minimum(root)); &#125; Iterator end() const &#123; return Iterator(nullptr); &#125;private: TreeNode&lt;Key, T&gt;* root; // 删除树中的所有节点 void clear(TreeNode&lt;Key, T&gt;* node) &#123; if (node == nullptr) return; clear(node-&gt;left); clear(node-&gt;right); delete node; &#125; // 找到最小的节点 TreeNode&lt;Key, T&gt;* minimum(TreeNode&lt;Key, T&gt;* node) const &#123; if (node == nullptr) return nullptr; while (node-&gt;left != nullptr) &#123; node = node-&gt;left; &#125; return node; &#125; // 找到最大的节点 TreeNode&lt;Key, T&gt;* maximum(TreeNode&lt;Key, T&gt;* node) const &#123; if (node == nullptr) return nullptr; while (node-&gt;right != nullptr) &#123; node = node-&gt;right; &#125; return node; &#125;&#125;; 2.3 解释 TreeNode 结构： data: 存储键值对 std::pair&lt;Key, T&gt;。 left 和 right: 指向左子节点和右子节点。 parent: 指向父节点，便于迭代器中查找后继节点。 MyMap 类： 构造与析构 ： 构造函数初始化根节点为空。 析构函数调用 clear 释放所有节点内存。 插入 (insert) ： 从根节点开始，根据键的大小确定插入左子树还是右子树。 如果键已存在，更新对应的值。 查找 (find) ： 按照键的大小在树中查找对应的节点。 删除 (erase) ： 查找到目标节点。 如果节点有两个子节点，找到中序后继节点并替换当前节点的数据，然后删除后继节点。 如果节点有一个或没有子节点，直接替换节点指针并删除节点。 清空 (clear) ： 使用递归方式删除所有节点。 迭代器 ： 定义了嵌套的 Iterator 类，支持前置和后置递增操作。 迭代器通过中序遍历实现，保证键的顺序性。 begin() 返回最小的节点，end() 返回 nullptr。 3. 使用示例下面提供一个使用 MyMap 的示例，展示插入、查找、删除和迭代操作。 12345678910111213141516171819202122232425262728293031323334353637int main() &#123; MyMap&lt;std::string, int&gt; myMap; // 插入元素 myMap.insert(&quot;apple&quot;, 3); myMap.insert(&quot;banana&quot;, 5); myMap.insert(&quot;orange&quot;, 2); myMap.insert(&quot;grape&quot;, 7); myMap.insert(&quot;cherry&quot;, 4); // 使用迭代器遍历元素（按键的字母顺序） std::cout &lt;&lt; &quot;Map contents (in-order):\\n&quot;; for(auto it = myMap.begin(); it != myMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; &#125; // 查找元素 std::string keyToFind = &quot;banana&quot;; auto node = myMap.find(keyToFind); if(node != nullptr) &#123; std::cout &lt;&lt; &quot;\\nFound &quot; &lt;&lt; keyToFind &lt;&lt; &quot; with value: &quot; &lt;&lt; node-&gt;data.second &lt;&lt; &quot;\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;\\n&quot; &lt;&lt; keyToFind &lt;&lt; &quot; not found.\\n&quot;; &#125; // 删除元素 myMap.erase(&quot;apple&quot;); myMap.erase(&quot;cherry&quot;); // 再次遍历 std::cout &lt;&lt; &quot;\\nAfter erasing apple and cherry:\\n&quot;; for(auto it = myMap.begin(); it != myMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 输出结果12345678910111213Map contents (in-order):apple =&gt; 3banana =&gt; 5cherry =&gt; 4grape =&gt; 7orange =&gt; 2Found banana with value: 5After erasing apple and cherry:banana =&gt; 5grape =&gt; 7orange =&gt; 2 4. 迭代器的详细实现为了支持迭代器的正常使用，Iterator 类实现了以下功能： **解引用操作符 (operator\\* 和 operator-&gt;)**： 允许访问键值对，如 it-&gt;first 和 it-&gt;second。 **递增操作符 (operator++)**： 前置递增（++it）和后置递增（it++）用于移动到下一个元素。 通过查找当前节点的中序后继节点实现。 **比较操作符 (operator== 和 operator!=)**： 判断两个迭代器是否指向同一个节点。 中序后继节点的查找迭代器使用中序遍历来确保键的有序性。计算后继节点的步骤如下： 当前节点有右子树： 后继节点是右子树中的最小节点。 当前节点没有右子树： 向上查找，直到找到一个节点是其父节点的左子树，此时父节点即为后继节点。 如果没有后继节点（即当前节点是最大的节点），则返回 nullptr，表示迭代器到达 end()。 5. 扩展功能上述实现是一个基本的 Map，还可以根据需要扩展更多功能，例如： 支持 const 迭代器： 定义 const_iterator，确保在只读操作时数据不被修改。 实现平衡树： 为了提高性能，可以实现红黑树、AVL 树等自平衡二叉搜索树，保证操作的时间复杂度为 O(log n)。 添加更多成员函数： 如 operator[]、count、lower_bound、upper_bound 等，增加容器的功能性。 异常处理： 增加对异常情况的处理，例如在删除不存在的键时抛出异常等。 迭代器的逆向遍历： 实现双向迭代器，支持逆序遍历（rbegin() 和 rend()）。 AVL树AVL树（Adelson-Velsky and Landis树）是一种自平衡的二叉搜索树（BST），它在插入和删除操作后通过旋转来保持树的平衡，从而确保基本操作（如查找、插入和删除）的时间复杂度保持在O(log n)。使用AVL树来实现map（键值对映射）是一个高效的选择，特别适合需要频繁查找、插入和删除操作的场景。 1. 模板化AVL树节点首先，我们需要将AVLNode结构模板化，使其能够处理不同类型的键和值。我们假设键类型KeyType支持operator&lt;进行比较，因为AVL树需要对键进行排序以维护其性质。 首先，我们定义AVL树的节点。每个节点包含一个键（key）、一个值（value）、节点高度（height），以及指向左子节点和右子节点的指针。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // 用于 std::max#include &lt;functional&gt; // 用于 std::function// 模板化的AVL树节点结构template &lt;typename KeyType, typename ValueType&gt;struct AVLNode &#123; KeyType key; ValueType value; int height; AVLNode* left; AVLNode* right; AVLNode(const KeyType&amp; k, const ValueType&amp; val) : key(k), value(val), height(1), left(nullptr), right(nullptr) &#123;&#125;&#125;; 说明： KeyType：键的类型，需要支持比较操作（如 operator&lt;）。 ValueType：值的类型，可以是任何类型。 2. 辅助函数的模板化辅助函数同样需要模板化，以适应不同的AVLNode类型。 获取节点高度获取节点的高度。如果节点为空，则高度为0。 123456template &lt;typename KeyType, typename ValueType&gt;int getHeight(AVLNode&lt;KeyType, ValueType&gt;* node) &#123; if (node == nullptr) return 0; return node-&gt;height;&#125; 获取平衡因子平衡因子（Balance Factor）是左子树高度减去右子树高度。 123456template &lt;typename KeyType, typename ValueType&gt;int getBalance(AVLNode&lt;KeyType, ValueType&gt;* node) &#123; if (node == nullptr) return 0; return getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125; 右旋转右旋转用于处理左子树过高的情况（例如，左左情况）。 12345 y x / \\ / \\ x T3 ==&gt; z y / \\ / \\z T2 T2 T3 实现 12345678910111213141516template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* rightRotate(AVLNode&lt;KeyType, ValueType&gt;* y) &#123; AVLNode&lt;KeyType, ValueType&gt;* x = y-&gt;left; AVLNode&lt;KeyType, ValueType&gt;* T2 = x-&gt;right; // 执行旋转 x-&gt;right = y; y-&gt;left = T2; // 更新高度 y-&gt;height = std::max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1; x-&gt;height = std::max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1; // 返回新的根 return x;&#125; 左旋转左旋转用于处理右子树过高的情况（例如，右右情况）。 12345 x y / \\ / \\T1 y ==&gt; x z / \\ / \\ T2 z T1 T2 具体实现 12345678910111213141516template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* leftRotate(AVLNode&lt;KeyType, ValueType&gt;* x) &#123; AVLNode&lt;KeyType, ValueType&gt;* y = x-&gt;right; AVLNode&lt;KeyType, ValueType&gt;* T2 = y-&gt;left; // 执行旋转 y-&gt;left = x; x-&gt;right = T2; // 更新高度 x-&gt;height = std::max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1; y-&gt;height = std::max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1; // 返回新的根 return y;&#125; 3. AVL树的核心操作模板化插入节点插入操作遵循标准的二叉搜索树插入方式，然后通过旋转保持树的平衡。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* insertNode(AVLNode&lt;KeyType, ValueType&gt;* node, const KeyType&amp; key, const ValueType&amp; value) &#123; // 1. 执行标准的BST插入 if (node == nullptr) return new AVLNode&lt;KeyType, ValueType&gt;(key, value); if (key &lt; node-&gt;key) node-&gt;left = insertNode(node-&gt;left, key, value); else if (key &gt; node-&gt;key) node-&gt;right = insertNode(node-&gt;right, key, value); else &#123; // 如果键已经存在，更新其值 node-&gt;value = value; return node; &#125; // 2. 更新节点高度 node-&gt;height = 1 + std::max(getHeight(node-&gt;left), getHeight(node-&gt;right)); // 3. 获取平衡因子 int balance = getBalance(node); // 4. 根据平衡因子进行旋转 // 左左情况 if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) return rightRotate(node); // 右右情况 if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) return leftRotate(node); // 左右情况 if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123; node-&gt;left = leftRotate(node-&gt;left); return rightRotate(node); &#125; // 右左情况 if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123; node-&gt;right = rightRotate(node-&gt;right); return leftRotate(node); &#125; return node;&#125; 查找节点按键查找节点，返回对应的值。如果键不存在，返回nullptr。 123456789101112template &lt;typename KeyType, typename ValueType&gt;ValueType* searchNode(AVLNode&lt;KeyType, ValueType&gt;* node, const KeyType&amp; key) &#123; if (node == nullptr) return nullptr; if (key == node-&gt;key) return &amp;(node-&gt;value); else if (key &lt; node-&gt;key) return searchNode(node-&gt;left, key); else return searchNode(node-&gt;right, key);&#125; 获取最小值节点用于删除节点时找到中序后继。 1234567template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* getMinValueNode(AVLNode&lt;KeyType, ValueType&gt;* node) &#123; AVLNode&lt;KeyType, ValueType&gt;* current = node; while (current-&gt;left != nullptr) current = current-&gt;left; return current;&#125; 删除节点删除操作分为三种情况：删除节点是叶子节点、有一个子节点或有两个子节点。删除后，通过旋转保持树的平衡。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* deleteNode(AVLNode&lt;KeyType, ValueType&gt;* root, const KeyType&amp; key) &#123; // 1. 执行标准的BST删除 if (root == nullptr) return root; if (key &lt; root-&gt;key) root-&gt;left = deleteNode(root-&gt;left, key); else if (key &gt; root-&gt;key) root-&gt;right = deleteNode(root-&gt;right, key); else &#123; // 节点有一个或没有子节点 if ((root-&gt;left == nullptr) || (root-&gt;right == nullptr)) &#123; AVLNode&lt;KeyType, ValueType&gt;* temp = root-&gt;left ? root-&gt;left : root-&gt;right; // 没有子节点 if (temp == nullptr) &#123; temp = root; root = nullptr; &#125; else // 一个子节点 *root = *temp; // 复制内容 delete temp; &#125; else &#123; // 节点有两个子节点，获取中序后继 AVLNode&lt;KeyType, ValueType&gt;* temp = getMinValueNode(root-&gt;right); // 复制中序后继的内容到此节点 root-&gt;key = temp-&gt;key; root-&gt;value = temp-&gt;value; // 删除中序后继 root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key); &#125; &#125; // 如果树只有一个节点 if (root == nullptr) return root; // 2. 更新节点高度 root-&gt;height = 1 + std::max(getHeight(root-&gt;left), getHeight(root-&gt;right)); // 3. 获取平衡因子 int balance = getBalance(root); // 4. 根据平衡因子进行旋转 // 左左情况 if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &gt;= 0) return rightRotate(root); // 左右情况 if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &lt; 0) &#123; root-&gt;left = leftRotate(root-&gt;left); return rightRotate(root); &#125; // 右右情况 if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &lt;= 0) return leftRotate(root); // 右左情况 if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &gt; 0) &#123; root-&gt;right = rightRotate(root-&gt;right); return leftRotate(root); &#125; return root;&#125; 4. 模板化的AVLMap类现在，我们将所有模板化的函数集成到一个模板类AVLMap中。这个类将提供如下功能： put(const KeyType&amp; key, const ValueType&amp; value)：插入或更新键值对。 get(const KeyType&amp; key)：查找键对应的值，返回指向值的指针，如果键不存在则返回nullptr。 remove(const KeyType&amp; key)：删除指定键的键值对。 inorderTraversal()：中序遍历，返回有序的键值对列表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152template &lt;typename KeyType, typename ValueType&gt;class AVLMap &#123;private: AVLNode&lt;KeyType, ValueType&gt;* root; // 中序遍历辅助函数 void inorderHelper(AVLNode&lt;KeyType, ValueType&gt;* node, std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt;&amp; res) const &#123; if (node != nullptr) &#123; inorderHelper(node-&gt;left, res); res.emplace_back(node-&gt;key, node-&gt;value); inorderHelper(node-&gt;right, res); &#125; &#125;public: AVLMap() : root(nullptr) &#123;&#125; // 插入或更新键值对 void put(const KeyType&amp; key, const ValueType&amp; value) &#123; root = insertNode(root, key, value); &#125; // 查找值，返回指向值的指针，如果键不存在则返回nullptr ValueType* get(const KeyType&amp; key) &#123; return searchNode(root, key); &#125; // 删除键值对 void remove(const KeyType&amp; key) &#123; root = deleteNode(root, key); &#125; // 中序遍历，返回有序的键值对 std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; inorderTraversal() const &#123; std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; res; inorderHelper(root, res); return res; &#125; // 析构函数，释放所有节点的内存 ~AVLMap() &#123; // 使用后序遍历释放节点 std::function&lt;void(AVLNode&lt;KeyType, ValueType&gt;*)&gt; destroy = [&amp;](AVLNode&lt;KeyType, ValueType&gt;* node) &#123; if (node) &#123; destroy(node-&gt;left); destroy(node-&gt;right); delete node; &#125; &#125;; destroy(root); &#125;&#125;; 说明： 模板参数 ： KeyType：键的类型，需要支持operator&lt;进行比较。 ValueType：值的类型，可以是任意类型。 内存管理 ： 析构函数使用后序遍历释放所有动态分配的节点，防止内存泄漏。 异常安全 ： 当前实现没有处理异常情况。如果需要更高的异常安全性，可以进一步增强代码，例如在插入过程中捕获异常并回滚操作。 5. 使用示例下面的示例展示了如何使用模板化的AVLMap类，使用不同类型的键和值。 示例 1：使用int作为键，std::string作为值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;// 假设上面的AVLNode结构、辅助函数和AVLMap类已经定义int main() &#123; AVLMap&lt;int, std::string&gt; avlMap; // 插入键值对 avlMap.put(10, &quot;十&quot;); avlMap.put(20, &quot;二十&quot;); avlMap.put(30, &quot;三十&quot;); avlMap.put(40, &quot;四十&quot;); avlMap.put(50, &quot;五十&quot;); avlMap.put(25, &quot;二十五&quot;); // 中序遍历 std::vector&lt;std::pair&lt;int, std::string&gt;&gt; traversal = avlMap.inorderTraversal(); std::cout &lt;&lt; &quot;中序遍历: &quot;; for (const auto&amp; pair : traversal) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \\&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\\&quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; // 查找键 std::string* val = avlMap.get(20); if (val) std::cout &lt;&lt; &quot;获取键20的值: &quot; &lt;&lt; *val &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键20不存在。&quot; &lt;&lt; std::endl; val = avlMap.get(25); if (val) std::cout &lt;&lt; &quot;获取键25的值: &quot; &lt;&lt; *val &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键25不存在。&quot; &lt;&lt; std::endl; val = avlMap.get(60); if (val) std::cout &lt;&lt; &quot;获取键60的值: &quot; &lt;&lt; *val &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键60不存在。&quot; &lt;&lt; std::endl; // 删除键20 avlMap.remove(20); std::cout &lt;&lt; &quot;删除键20后，中序遍历: &quot;; traversal = avlMap.inorderTraversal(); for (const auto&amp; pair : traversal) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \\&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\\&quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出: 12345中序遍历: (10, &quot;十&quot;) (20, &quot;二十&quot;) (25, &quot;二十五&quot;) (30, &quot;三十&quot;) (40, &quot;四十&quot;) (50, &quot;五十&quot;) 获取键20的值: 二十获取键25的值: 二十五键60不存在。删除键20后，中序遍历: (10, &quot;十&quot;) (25, &quot;二十五&quot;) (30, &quot;三十&quot;) (40, &quot;四十&quot;) (50, &quot;五十&quot;) 示例 2：使用std::string作为键，double作为值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;// 假设上面的AVLNode结构、辅助函数和AVLMap类已经定义int main() &#123; AVLMap&lt;std::string, double&gt; avlMap; // 插入键值对 avlMap.put(&quot;apple&quot;, 1.99); avlMap.put(&quot;banana&quot;, 0.99); avlMap.put(&quot;cherry&quot;, 2.99); avlMap.put(&quot;date&quot;, 3.49); avlMap.put(&quot;elderberry&quot;, 5.99); avlMap.put(&quot;fig&quot;, 2.49); // 中序遍历 std::vector&lt;std::pair&lt;std::string, double&gt;&gt; traversal = avlMap.inorderTraversal(); std::cout &lt;&lt; &quot;中序遍历: &quot;; for (const auto&amp; pair : traversal) &#123; std::cout &lt;&lt; &quot;(\\&quot;&quot; &lt;&lt; pair.first &lt;&lt; &quot;\\&quot;, &quot; &lt;&lt; pair.second &lt;&lt; &quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; // 查找键 double* val = avlMap.get(&quot;banana&quot;); if (val) std::cout &lt;&lt; &quot;获取键\\&quot;banana\\&quot;的值: &quot; &lt;&lt; *val &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键\\&quot;banana\\&quot;不存在。&quot; &lt;&lt; std::endl; val = avlMap.get(&quot;fig&quot;); if (val) std::cout &lt;&lt; &quot;获取键\\&quot;fig\\&quot;的值: &quot; &lt;&lt; *val &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键\\&quot;fig\\&quot;不存在。&quot; &lt;&lt; std::endl; val = avlMap.get(&quot;grape&quot;); if (val) std::cout &lt;&lt; &quot;获取键\\&quot;grape\\&quot;的值: &quot; &lt;&lt; *val &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键\\&quot;grape\\&quot;不存在。&quot; &lt;&lt; std::endl; // 删除键&quot;banana&quot; avlMap.remove(&quot;banana&quot;); std::cout &lt;&lt; &quot;删除键\\&quot;banana\\&quot;后，中序遍历: &quot;; traversal = avlMap.inorderTraversal(); for (const auto&amp; pair : traversal) &#123; std::cout &lt;&lt; &quot;(\\&quot;&quot; &lt;&lt; pair.first &lt;&lt; &quot;\\&quot;, &quot; &lt;&lt; pair.second &lt;&lt; &quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出: 12345中序遍历: (&quot;apple&quot;, 1.99) (&quot;banana&quot;, 0.99) (&quot;cherry&quot;, 2.99) (&quot;date&quot;, 3.49) (&quot;elderberry&quot;, 5.99) (&quot;fig&quot;, 2.49) 获取键&quot;banana&quot;的值: 0.99获取键&quot;fig&quot;的值: 2.49键&quot;grape&quot;不存在。删除键&quot;banana&quot;后，中序遍历: (&quot;apple&quot;, 1.99) (&quot;cherry&quot;, 2.99) (&quot;date&quot;, 3.49) (&quot;elderberry&quot;, 5.99) (&quot;fig&quot;, 2.49) 6. 完整的通用代码以下是模板化的AVLMap的完整实现代码，包括所有辅助函数和类定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // 用于 std::max#include &lt;functional&gt; // 用于 std::function// 模板化的AVL树节点结构template &lt;typename KeyType, typename ValueType&gt;struct AVLNode &#123; KeyType key; ValueType value; int height; AVLNode* left; AVLNode* right; AVLNode(const KeyType&amp; k, const ValueType&amp; val) : key(k), value(val), height(1), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 获取节点高度template &lt;typename KeyType, typename ValueType&gt;int getHeight(AVLNode&lt;KeyType, ValueType&gt;* node) &#123; if (node == nullptr) return 0; return node-&gt;height;&#125;// 获取平衡因子template &lt;typename KeyType, typename ValueType&gt;int getBalance(AVLNode&lt;KeyType, ValueType&gt;* node) &#123; if (node == nullptr) return 0; return getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125;// 右旋转template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* rightRotate(AVLNode&lt;KeyType, ValueType&gt;* y) &#123; AVLNode&lt;KeyType, ValueType&gt;* x = y-&gt;left; AVLNode&lt;KeyType, ValueType&gt;* T2 = x-&gt;right; // 执行旋转 x-&gt;right = y; y-&gt;left = T2; // 更新高度 y-&gt;height = std::max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1; x-&gt;height = std::max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1; // 返回新的根 return x;&#125;// 左旋转template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* leftRotate(AVLNode&lt;KeyType, ValueType&gt;* x) &#123; AVLNode&lt;KeyType, ValueType&gt;* y = x-&gt;right; AVLNode&lt;KeyType, ValueType&gt;* T2 = y-&gt;left; // 执行旋转 y-&gt;left = x; x-&gt;right = T2; // 更新高度 x-&gt;height = std::max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1; y-&gt;height = std::max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1; // 返回新的根 return y;&#125;// 插入节点template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* insertNode(AVLNode&lt;KeyType, ValueType&gt;* node, const KeyType&amp; key, const ValueType&amp; value) &#123; // 1. 执行标准的BST插入 if (node == nullptr) return new AVLNode&lt;KeyType, ValueType&gt;(key, value); if (key &lt; node-&gt;key) node-&gt;left = insertNode(node-&gt;left, key, value); else if (key &gt; node-&gt;key) node-&gt;right = insertNode(node-&gt;right, key, value); else &#123; // 如果键已经存在，更新其值 node-&gt;value = value; return node; &#125; // 2. 更新节点高度 node-&gt;height = 1 + std::max(getHeight(node-&gt;left), getHeight(node-&gt;right)); // 3. 获取平衡因子 int balance = getBalance(node); // 4. 根据平衡因子进行旋转 // 左左情况 if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) return rightRotate(node); // 右右情况 if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) return leftRotate(node); // 左右情况 if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123; node-&gt;left = leftRotate(node-&gt;left); return rightRotate(node); &#125; // 右左情况 if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123; node-&gt;right = rightRotate(node-&gt;right); return leftRotate(node); &#125; return node;&#125;// 查找节点template &lt;typename KeyType, typename ValueType&gt;ValueType* searchNode(AVLNode&lt;KeyType, ValueType&gt;* node, const KeyType&amp; key) &#123; if (node == nullptr) return nullptr; if (key == node-&gt;key) return &amp;(node-&gt;value); else if (key &lt; node-&gt;key) return searchNode(node-&gt;left, key); else return searchNode(node-&gt;right, key);&#125;// 获取最小值节点template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* getMinValueNode(AVLNode&lt;KeyType, ValueType&gt;* node) &#123; AVLNode&lt;KeyType, ValueType&gt;* current = node; while (current-&gt;left != nullptr) current = current-&gt;left; return current;&#125;// 删除节点template &lt;typename KeyType, typename ValueType&gt;AVLNode&lt;KeyType, ValueType&gt;* deleteNode(AVLNode&lt;KeyType, ValueType&gt;* root, const KeyType&amp; key) &#123; // 1. 执行标准的BST删除 if (root == nullptr) return root; if (key &lt; root-&gt;key) root-&gt;left = deleteNode(root-&gt;left, key); else if (key &gt; root-&gt;key) root-&gt;right = deleteNode(root-&gt;right, key); else &#123; // 节点有一个或没有子节点 if ((root-&gt;left == nullptr) || (root-&gt;right == nullptr)) &#123; AVLNode&lt;KeyType, ValueType&gt;* temp = root-&gt;left ? root-&gt;left : root-&gt;right; // 没有子节点 if (temp == nullptr) &#123; temp = root; root = nullptr; &#125; else // 一个子节点 *root = *temp; // 复制内容 delete temp; &#125; else &#123; // 节点有两个子节点，获取中序后继 AVLNode&lt;KeyType, ValueType&gt;* temp = getMinValueNode(root-&gt;right); // 复制中序后继的内容到此节点 root-&gt;key = temp-&gt;key; root-&gt;value = temp-&gt;value; // 删除中序后继 root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key); &#125; &#125; // 如果树只有一个节点 if (root == nullptr) return root; // 2. 更新节点高度 root-&gt;height = 1 + std::max(getHeight(root-&gt;left), getHeight(root-&gt;right)); // 3. 获取平衡因子 int balance = getBalance(root); // 4. 根据平衡因子进行旋转 // 左左情况 if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &gt;= 0) return rightRotate(root); // 左右情况 if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &lt; 0) &#123; root-&gt;left = leftRotate(root-&gt;left); return rightRotate(root); &#125; // 右右情况 if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &lt;= 0) return leftRotate(root); // 右左情况 if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &gt; 0) &#123; root-&gt;right = rightRotate(root-&gt;right); return leftRotate(root); &#125; return root;&#125;// 模板化的AVLMap类template &lt;typename KeyType, typename ValueType&gt;class AVLMap &#123;private: AVLNode&lt;KeyType, ValueType&gt;* root; // 中序遍历辅助函数 void inorderHelper(AVLNode&lt;KeyType, ValueType&gt;* node, std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt;&amp; res) const &#123; if (node != nullptr) &#123; inorderHelper(node-&gt;left, res); res.emplace_back(node-&gt;key, node-&gt;value); inorderHelper(node-&gt;right, res); &#125; &#125;public: AVLMap() : root(nullptr) &#123;&#125; // 插入或更新键值对 void put(const KeyType&amp; key, const ValueType&amp; value) &#123; root = insertNode(root, key, value); &#125; // 查找值，返回指向值的指针，如果键不存在则返回nullptr ValueType* get(const KeyType&amp; key) &#123; return searchNode(root, key); &#125; // 删除键值对 void remove(const KeyType&amp; key) &#123; root = deleteNode(root, key); &#125; // 中序遍历，返回有序的键值对 std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; inorderTraversal() const &#123; std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt; res; inorderHelper(root, res); return res; &#125; // 析构函数，释放所有节点的内存 ~AVLMap() &#123; // 使用后序遍历释放节点 std::function&lt;void(AVLNode&lt;KeyType, ValueType&gt;*)&gt; destroy = [&amp;](AVLNode&lt;KeyType, ValueType&gt;* node) &#123; if (node) &#123; destroy(node-&gt;left); destroy(node-&gt;right); delete node; &#125; &#125;; destroy(root); &#125;&#125;;// 示例主函数int main() &#123; // 示例 1：int 键，std::string 值 std::cout &lt;&lt; &quot;示例 1：int 键，std::string 值\\n&quot;; AVLMap&lt;int, std::string&gt; avlMap1; // 插入键值对 avlMap1.put(10, &quot;十&quot;); avlMap1.put(20, &quot;二十&quot;); avlMap1.put(30, &quot;三十&quot;); avlMap1.put(40, &quot;四十&quot;); avlMap1.put(50, &quot;五十&quot;); avlMap1.put(25, &quot;二十五&quot;); // 中序遍历 std::vector&lt;std::pair&lt;int, std::string&gt;&gt; traversal1 = avlMap1.inorderTraversal(); std::cout &lt;&lt; &quot;中序遍历: &quot;; for (const auto&amp; pair : traversal1) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \\&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\\&quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; // 查找键 std::string* val1 = avlMap1.get(20); if (val1) std::cout &lt;&lt; &quot;获取键20的值: &quot; &lt;&lt; *val1 &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键20不存在。&quot; &lt;&lt; std::endl; val1 = avlMap1.get(25); if (val1) std::cout &lt;&lt; &quot;获取键25的值: &quot; &lt;&lt; *val1 &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键25不存在。&quot; &lt;&lt; std::endl; val1 = avlMap1.get(60); if (val1) std::cout &lt;&lt; &quot;获取键60的值: &quot; &lt;&lt; *val1 &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键60不存在。&quot; &lt;&lt; std::endl; // 删除键20 avlMap1.remove(20); std::cout &lt;&lt; &quot;删除键20后，中序遍历: &quot;; traversal1 = avlMap1.inorderTraversal(); for (const auto&amp; pair : traversal1) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \\&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\\&quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;\\n-----------------------------\\n&quot;; // 示例 2：std::string 键，double 值 std::cout &lt;&lt; &quot;示例 2：std::string 键，double 值\\n&quot;; AVLMap&lt;std::string, double&gt; avlMap2; // 插入键值对 avlMap2.put(&quot;apple&quot;, 1.99); avlMap2.put(&quot;banana&quot;, 0.99); avlMap2.put(&quot;cherry&quot;, 2.99); avlMap2.put(&quot;date&quot;, 3.49); avlMap2.put(&quot;elderberry&quot;, 5.99); avlMap2.put(&quot;fig&quot;, 2.49); // 中序遍历 std::vector&lt;std::pair&lt;std::string, double&gt;&gt; traversal2 = avlMap2.inorderTraversal(); std::cout &lt;&lt; &quot;中序遍历: &quot;; for (const auto&amp; pair : traversal2) &#123; std::cout &lt;&lt; &quot;(\\&quot;&quot; &lt;&lt; pair.first &lt;&lt; &quot;\\&quot;, &quot; &lt;&lt; pair.second &lt;&lt; &quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; // 查找键 double* val2 = avlMap2.get(&quot;banana&quot;); if (val2) std::cout &lt;&lt; &quot;获取键\\&quot;banana\\&quot;的值: &quot; &lt;&lt; *val2 &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键\\&quot;banana\\&quot;不存在。&quot; &lt;&lt; std::endl; val2 = avlMap2.get(&quot;fig&quot;); if (val2) std::cout &lt;&lt; &quot;获取键\\&quot;fig\\&quot;的值: &quot; &lt;&lt; *val2 &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键\\&quot;fig\\&quot;不存在。&quot; &lt;&lt; std::endl; val2 = avlMap2.get(&quot;grape&quot;); if (val2) std::cout &lt;&lt; &quot;获取键\\&quot;grape\\&quot;的值: &quot; &lt;&lt; *val2 &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;键\\&quot;grape\\&quot;不存在。&quot; &lt;&lt; std::endl; // 删除键&quot;banana&quot; avlMap2.remove(&quot;banana&quot;); std::cout &lt;&lt; &quot;删除键\\&quot;banana\\&quot;后，中序遍历: &quot;; traversal2 = avlMap2.inorderTraversal(); for (const auto&amp; pair : traversal2) &#123; std::cout &lt;&lt; &quot;(\\&quot;&quot; &lt;&lt; pair.first &lt;&lt; &quot;\\&quot;, &quot; &lt;&lt; pair.second &lt;&lt; &quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 说明 平衡维护：在每次插入或删除后，都会更新节点的高度并计算平衡因子。如果某个节点的平衡因子超出了[-1, 1]范围，就需要通过旋转来重新平衡树。 查找操作：由于AVL树的高度被保持在O(log n)，查找操作的时间复杂度为O(log n)。 更新操作：如果插入的键已经存在，则更新其对应的值。 遍历操作：中序遍历可以按键的顺序遍历所有键值对。 内存管理：确保在析构函数中正确释放所有动态分配的内存，避免内存泄漏。 泛型支持（可选）：为了使AVLMap更加通用，可以将其模板化，以支持不同类型的键和值。例如： 编译与运行： 假设保存为 avlmap.cpp，使用以下命令编译并运行： 12g++ -std=c++11 -o avlmap avlmap.cpp./avlmap 预期输出： 1234567891011121314示例 1：int 键，std::string 值中序遍历: (10, &quot;十&quot;) (20, &quot;二十&quot;) (25, &quot;二十五&quot;) (30, &quot;三十&quot;) (40, &quot;四十&quot;) (50, &quot;五十&quot;) 获取键20的值: 二十获取键25的值: 二十五键60不存在。删除键20后，中序遍历: (10, &quot;十&quot;) (25, &quot;二十五&quot;) (30, &quot;三十&quot;) (40, &quot;四十&quot;) (50, &quot;五十&quot;) -----------------------------示例 2：std::string 键，double 值中序遍历: (&quot;apple&quot;, 1.99) (&quot;banana&quot;, 0.99) (&quot;cherry&quot;, 2.99) (&quot;date&quot;, 3.49) (&quot;elderberry&quot;, 5.99) (&quot;fig&quot;, 2.49) 获取键&quot;banana&quot;的值: 0.99获取键&quot;fig&quot;的值: 2.49键&quot;grape&quot;不存在。删除键&quot;banana&quot;后，中序遍历: (&quot;apple&quot;, 1.99) (&quot;cherry&quot;, 2.99) (&quot;date&quot;, 3.49) (&quot;elderberry&quot;, 5.99) (&quot;fig&quot;, 2.49) 7. 注意事项与扩展1. 键类型的要求为了使AVLMap正常工作，键类型KeyType必须支持以下操作： 比较操作：必须定义operator&lt;，因为AVL树依赖于它来维护排序。如果使用自定义类型作为键，请确保定义了operator&lt;。 12345678910struct CustomKey &#123; int id; std::string name; bool operator&lt;(const CustomKey&amp; other) const &#123; if (id != other.id) return id &lt; other.id; return name &lt; other.name; &#125;&#125;; 2. 泛型支持与约束在C++20之前，模板并不支持在模板参数上强制施加约束（需要依赖文档和用户理解）。从C++20起，可以使用概念（Concepts）来施加约束。 1234567#include &lt;concepts&gt;template &lt;typename KeyType, typename ValueType&gt;requires std::totally_ordered&lt;KeyType&gt;class AVLMap &#123; // 类定义&#125;; 这样，编译器会在实例化模板时检查KeyType是否满足std::totally_ordered，即是否支持所有必要的比较操作。 3. 性能优化 内存管理：当前实现使用递归进行插入和删除，如果树非常深，可能会导致栈溢出。可以考虑使用迭代方法或优化递归深度。 缓存友好：使用自适应数据结构（如缓存友好的节点布局）可以提升性能。 多线程支持：当前实现不是线程安全的。如果需要在多线程环境中使用，需要添加适当的同步机制。 4. 额外功能根据需求，你可以为AVLMap添加更多功能： 迭代器：实现输入迭代器、中序遍历迭代器，以便支持范围基（range-based）for循环。 查找最小/最大键：提供方法findMin()和findMax()。 前驱/后继查找：在树中查找给定键的前驱和后继节点。 支持不同的平衡因子策略：例如，允许用户指定自定义的平衡策略。 5. 与标准库的比较虽然自己实现AVLMap是一项很好的学习练习，但在实际生产环境中，建议使用C++标准库中已经高度优化和测试过的容器，如std::map（通常实现为红黑树）、std::unordered_map（哈希表）等。 12345678910111213141516171819#include &lt;map&gt;// 使用 std::mapint main() &#123; std::map&lt;int, std::string&gt; stdMap; // 插入键值对 stdMap[10] = &quot;十&quot;; stdMap[20] = &quot;二十&quot;; stdMap[30] = &quot;三十&quot;; // 遍历 for (const auto&amp; pair : stdMap) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \\&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\\&quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; std::map提供了与AVLMap类似的功能，并且经过了高度优化，适用于大多数应用场景。 红黑树红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它通过对节点进行颜色标记（红色或黑色）并遵循特定的规则来保证树的平衡性，从而确保基本操作（如查找、插入、删除）的时间复杂度为 **O(log n)**。红黑树广泛应用于计算机科学中，例如在实现关联容器（如 std::map、std::set）时常用到。 1. 红黑树的五大性质红黑树通过以下 五大性质 维持其平衡性： 节点颜色：每个节点要么是红色，要么是黑色。 根节点颜色：根节点是黑色。 叶子节点颜色：所有叶子节点（NIL 节点，即空节点）都是黑色的。这里的叶子节点不存储实际数据，仅作为树的终端。 红色节点限制：如果一个节点是红色的，则它的两个子节点都是黑色的。也就是说，红色节点不能有红色的子节点。 黑色平衡：从任意节点到其所有后代叶子节点的路径上，包含相同数量的黑色节点。这被称为每条路径上的黑色高度相同。 这些性质的意义 性质1 和 性质2 确保节点颜色的基本规则，便于后续操作中进行颜色判断和调整。 性质3 保证了所有实际节点的子节点（NIL 节点）的统一性，简化了操作逻辑。 性质4 防止了连续的红色节点出现，避免导致过度不平衡。 性质5 保证了树的平衡性，使得树的高度始终保持在 O(log n) 的范围内，从而确保基本操作的高效性。 这些性质共同作用，使得红黑树在最坏情况下也能保持较好的性能表现。 2. 红黑树的插入操作插入操作是红黑树中常见的操作，与标准的二叉搜索树（BST）插入类似，但需要额外的步骤来维护红黑树的性质。 2.1 插入步骤概述插入操作通常分为以下两个主要步骤： 标准二叉搜索树插入：根据键值比较，将新节点插入到合适的位置，初始颜色为红色。 插入后的修正（Insert Fixup）：通过重新着色和旋转操作，恢复红黑树的五大性质。 2.2 插入后的修正（Insert Fixup）插入一个红色节点可能会破坏红黑树的性质，尤其是性质4（红色节点不能连续）。为了修复这些潜在的冲突，需要进行颜色调整和旋转操作。 修正步骤：插入修正的过程通常遵循以下规则（以下描述假设新插入的节点 z 是红色）： 父节点为黑色： 如果 z 的父节点是黑色的，那么插入操作不会破坏红黑树的性质，修正过程结束。 父节点为红色： 情况1：z 的叔叔节点（即 z 的父节点的兄弟节点）也是红色。 将父节点和叔叔节点重新着色为黑色。 将祖父节点重新着色为红色。 将 z 指向祖父节点，继续检查上层节点，防止高层的性质被破坏。 情况2：z 的叔叔节点是黑色，且 z 是其父节点的右子节点。 对 z 的父节点进行左旋转。 将 z 指向其新的左子节点（即原父节点）。 情况3：z 的叔叔节点是黑色，且 z 是其父节点的左子节点。 将父节点重新着色为黑色。 将祖父节点重新着色为红色。 对祖父节点进行右旋转。 旋转操作的重要性在修正过程中，旋转操作用于调整树的局部结构，使得红黑树的性质得以恢复。这些旋转包括左旋转和右旋转，在后续章节中将详细介绍。 插入修正的代码实现示例以下是红黑树插入修正的一个简化版 C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template &lt;typename Key, typename Value&gt;void RedBlackTree&lt;Key, Value&gt;::insertFixUp(RBTreeNode&lt;Key, Value&gt;* z) &#123; while (z-&gt;parent != nullptr &amp;&amp; z-&gt;parent-&gt;color == RED) &#123; if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123; RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;right; // 叔叔节点 if (y != nullptr &amp;&amp; y-&gt;color == RED) &#123; // 情况1：叔叔为红色 z-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; z = z-&gt;parent-&gt;parent; &#125; else &#123; if (z == z-&gt;parent-&gt;right) &#123; // 情况2：z为右子节点 z = z-&gt;parent; leftRotate(z); &#125; // 情况3：z为左子节点 z-&gt;parent-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; rightRotate(z-&gt;parent-&gt;parent); &#125; &#125; else &#123; // 情况对称：父节点是右子节点 RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;left; // 叔叔节点 if (y != nullptr &amp;&amp; y-&gt;color == RED) &#123; // 情况1 z-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; z = z-&gt;parent-&gt;parent; &#125; else &#123; if (z == z-&gt;parent-&gt;left) &#123; // 情况2 z = z-&gt;parent; rightRotate(z); &#125; // 情况3 z-&gt;parent-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; leftRotate(z-&gt;parent-&gt;parent); &#125; &#125; &#125; root-&gt;color = BLACK; // 最终根节点必须为黑色&#125; 3. 红黑树的删除操作删除操作同样重要且复杂，因为它可能破坏红黑树的多个性质。与插入类似，删除操作也需要两个主要步骤： 标准二叉搜索树删除：按照 BST 的规则删除节点。 删除后的修正（Delete Fixup）：通过重新着色和旋转操作，恢复红黑树的性质。 3.1 删除步骤概述删除操作分为以下步骤： 定位要删除的节点： 如果要删除的节点 z 有两个子节点，则找到其中序后继节点 y（即 z 的右子树中的最小节点）。 将 y 的值复制到 z，然后将删除目标转移到 y。此时 y 至多只有一个子节点。 删除节点： 若 y 只有一个子节点 x（可能为 NIL），则用 x 替代 y 的位置。 记录被删除节点的原颜色 y_original_color。 删除修正（仅当 y_original_color 为黑色时）： 因为删除一个黑色节点会影响路径上的黑色数量，需通过多次调整来恢复红黑树的性质。 3.2 删除后的修正（Delete Fixup）删除后的修正较为复杂，涉及多种情况处理。以下为主要的修正步骤和可能遇到的情况： 修正步骤： 初始化：设 x 为替代被删除的节点的位置，x 可能为实际节点或 NIL 节点。 循环修正： 当 x 不是根节点，且 x 的颜色为黑色，进入修正循环。 判断 x 是其父节点的左子节点还是右子节点，并相应地设定兄弟节点 w。 处理不同情况： 情况1：w 是红色的。 将 w 重新着色为黑色。 将 x 的父节点重新着色为红色。 对 x 的父节点进行左旋转或右旋转，取决于是左子节点还是右子节点。 更新 w，继续修正过程。 情况2：w 是黑色，且 w 的两个子节点都是黑色。 将 w 重新着色为红色。 将 x 设为其父节点，继续修正。 情况3：w 是黑色，且 w 的左子节点是红色，右子节点是黑色。 将 w 的左子节点重新着色为黑色。 将 w 重新着色为红色。 对 w 进行右旋转或左旋转，取决于是左子节点还是右子节点。 更新 w，进入情况4。 情况4：w 是黑色，且 w 的右子节点是红色。 将 w 的颜色设为 x 的父节点颜色。 将 x 的父节点重新着色为黑色。 将 w 的右子节点重新着色为黑色。 对 x 的父节点进行左旋转或右旋转，取决于是左子节点还是右子节点。 结束修正。 最终步骤：将 x 设为根节点，并将其颜色设为黑色，确保根节点的颜色为黑色。 删除修正的代码实现示例由于删除修正涉及较多的情况，以下为一个简化版的红黑树删除修正的 C++ 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename Key, typename Value&gt;void RedBlackTree&lt;Key, Value&gt;::deleteFixUp(RBTreeNode&lt;Key, Value&gt;* x) &#123; while (x != root &amp;&amp; (x == nullptr || x-&gt;color == BLACK)) &#123; if (x == x-&gt;parent-&gt;left) &#123; RBTreeNode&lt;Key, Value&gt;* w = x-&gt;parent-&gt;right; // 兄弟节点 if (w-&gt;color == RED) &#123; // 情况1 w-&gt;color = BLACK; x-&gt;parent-&gt;color = RED; leftRotate(x-&gt;parent); w = x-&gt;parent-&gt;right; &#125; if ((w-&gt;left == nullptr || w-&gt;left-&gt;color == BLACK) &amp;&amp; (w-&gt;right == nullptr || w-&gt;right-&gt;color == BLACK)) &#123; // 情况2 w-&gt;color = RED; x = x-&gt;parent; &#125; else &#123; if (w-&gt;right == nullptr || w-&gt;right-&gt;color == BLACK) &#123; // 情况3 if (w-&gt;left != nullptr) w-&gt;left-&gt;color = BLACK; w-&gt;color = RED; rightRotate(w); w = x-&gt;parent-&gt;right; &#125; // 情况4 w-&gt;color = x-&gt;parent-&gt;color; x-&gt;parent-&gt;color = BLACK; if (w-&gt;right != nullptr) w-&gt;right-&gt;color = BLACK; leftRotate(x-&gt;parent); x = root; // 修正完成 &#125; &#125; else &#123; // 情况对称：x 是右子节点 RBTreeNode&lt;Key, Value&gt;* w = x-&gt;parent-&gt;left; // 兄弟节点 if (w-&gt;color == RED) &#123; // 情况1 w-&gt;color = BLACK; x-&gt;parent-&gt;color = RED; rightRotate(x-&gt;parent); w = x-&gt;parent-&gt;left; &#125; if ((w-&gt;right == nullptr || w-&gt;right-&gt;color == BLACK) &amp;&amp; (w-&gt;left == nullptr || w-&gt;left-&gt;color == BLACK)) &#123; // 情况2 w-&gt;color = RED; x = x-&gt;parent; &#125; else &#123; if (w-&gt;left == nullptr || w-&gt;left-&gt;color == BLACK) &#123; // 情况3 if (w-&gt;right != nullptr) w-&gt;right-&gt;color = BLACK; w-&gt;color = RED; leftRotate(w); w = x-&gt;parent-&gt;left; &#125; // 情况4 w-&gt;color = x-&gt;parent-&gt;color; x-&gt;parent-&gt;color = BLACK; if (w-&gt;left != nullptr) w-&gt;left-&gt;color = BLACK; rightRotate(x-&gt;parent); x = root; // 修正完成 &#125; &#125; &#125; if (x != nullptr) x-&gt;color = BLACK;&#125; 4. 旋转操作详解旋转操作是红黑树中用于重新平衡树的关键操作，包括左旋转和右旋转。旋转操作通过调整节点的父子关系，改变树的局部结构，从而保持红黑树的性质。 4.1 左旋转（Left Rotate）左旋转围绕节点 x 进行，其目的是将 x 的右子节点 y 提升为 x 的父节点，x 变为 y 的左子节点，y 的左子节点 b 成为 x 的右子节点。 旋转前： 12345 x / \\a y / \\ b c 旋转后： 12345 y / \\ x c / \\a b 左旋转的代码实现： 123456789101112131415161718template &lt;typename Key, typename Value&gt;void RedBlackTree&lt;Key, Value&gt;::leftRotate(RBTreeNode&lt;Key, Value&gt;* x) &#123; RBTreeNode&lt;Key, Value&gt;* y = x-&gt;right; x-&gt;right = y-&gt;left; if (y-&gt;left != nullptr) y-&gt;left-&gt;parent = x; y-&gt;parent = x-&gt;parent; if (x-&gt;parent == nullptr) root = y; else if (x == x-&gt;parent-&gt;left) x-&gt;parent-&gt;left = y; else x-&gt;parent-&gt;right = y; y-&gt;left = x; x-&gt;parent = y;&#125; 4.2 右旋转（Right Rotate）右旋转是 左旋转 的镜像操作，围绕节点 y 进行，其目的是将 y 的左子节点 x 提升为 y 的父节点，y 变为 x 的右子节点，x 的右子节点 b 成为 y 的左子节点。 旋转前： 12345 y / \\ x c / \\a b 旋转后： 12345 x / \\a y / \\ b c 右旋转的代码实现： 123456789101112131415161718template &lt;typename Key, typename Value&gt;void RedBlackTree&lt;Key, Value&gt;::rightRotate(RBTreeNode&lt;Key, Value&gt;* y) &#123; RBTreeNode&lt;Key, Value&gt;* x = y-&gt;left; y-&gt;left = x-&gt;right; if (x-&gt;right != nullptr) x-&gt;right-&gt;parent = y; x-&gt;parent = y-&gt;parent; if (y-&gt;parent == nullptr) root = x; else if (y == y-&gt;parent-&gt;right) y-&gt;parent-&gt;right = x; else y-&gt;parent-&gt;left = x; x-&gt;right = y; y-&gt;parent = x;&#125; 旋转操作的作用通过旋转操作，可以改变树的高度和形状，确保红黑树的性质在插入和删除后得到维护。旋转不会破坏二叉搜索树的性质，仅改变节点之间的指向关系。 5.简化版红黑树实现节点结构体首先，我们定义红黑树节点的结构体： 12345678910111213141516#include &lt;iostream&gt;enum Color &#123; RED, BLACK &#125;;template &lt;typename Key, typename Value&gt;struct RBTreeNode &#123; Key key; Value value; Color color; RBTreeNode* parent; RBTreeNode* left; RBTreeNode* right; RBTreeNode(Key k, Value v) : key(k), value(v), color(RED), parent(nullptr), left(nullptr), right(nullptr) &#123;&#125;&#125;; 红黑树类接下来，我们定义红黑树的主要类，包括插入、删除和遍历功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;enum Color &#123; RED, BLACK &#125;;template &lt;typename Key, typename Value&gt;struct RBTreeNode &#123; Key key; Value value; Color color; RBTreeNode* parent; RBTreeNode* left; RBTreeNode* right; RBTreeNode(Key k, Value v) : key(k), value(v), color(RED), parent(nullptr), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename Key, typename Value&gt;class RedBlackTree &#123;private: RBTreeNode&lt;Key, Value&gt;* root; void leftRotate(RBTreeNode&lt;Key, Value&gt;* x) &#123; RBTreeNode&lt;Key, Value&gt;* y = x-&gt;right; x-&gt;right = y-&gt;left; if (y-&gt;left != nullptr) y-&gt;left-&gt;parent = x; y-&gt;parent = x-&gt;parent; if (x-&gt;parent == nullptr) root = y; else if (x == x-&gt;parent-&gt;left) x-&gt;parent-&gt;left = y; else x-&gt;parent-&gt;right = y; y-&gt;left = x; x-&gt;parent = y; &#125; void rightRotate(RBTreeNode&lt;Key, Value&gt;* y) &#123; RBTreeNode&lt;Key, Value&gt;* x = y-&gt;left; y-&gt;left = x-&gt;right; if (x-&gt;right != nullptr) x-&gt;right-&gt;parent = y; x-&gt;parent = y-&gt;parent; if (y-&gt;parent == nullptr) root = x; else if (y == y-&gt;parent-&gt;right) y-&gt;parent-&gt;right = x; else y-&gt;parent-&gt;left = x; x-&gt;right = y; y-&gt;parent = x; &#125; void insertFixUp(RBTreeNode&lt;Key, Value&gt;* z) &#123; while (z-&gt;parent != nullptr &amp;&amp; z-&gt;parent-&gt;color == RED) &#123; if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123; RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;right; // 叔叔节点 if (y != nullptr &amp;&amp; y-&gt;color == RED) &#123; // 情况1 z-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; z = z-&gt;parent-&gt;parent; &#125; else &#123; if (z == z-&gt;parent-&gt;right) &#123; // 情况2 z = z-&gt;parent; leftRotate(z); &#125; // 情况3 z-&gt;parent-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; rightRotate(z-&gt;parent-&gt;parent); &#125; &#125; else &#123; // 父节点是右子节点，情况对称 RBTreeNode&lt;Key, Value&gt;* y = z-&gt;parent-&gt;parent-&gt;left; // 叔叔节点 if (y != nullptr &amp;&amp; y-&gt;color == RED) &#123; // 情况1 z-&gt;parent-&gt;color = BLACK; y-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; z = z-&gt;parent-&gt;parent; &#125; else &#123; if (z == z-&gt;parent-&gt;left) &#123; // 情况2 z = z-&gt;parent; rightRotate(z); &#125; // 情况3 z-&gt;parent-&gt;color = BLACK; z-&gt;parent-&gt;parent-&gt;color = RED; leftRotate(z-&gt;parent-&gt;parent); &#125; &#125; &#125; root-&gt;color = BLACK; &#125; void inorderHelper(RBTreeNode&lt;Key, Value&gt;* node) const &#123; if (node == nullptr) return; inorderHelper(node-&gt;left); std::cout &lt;&lt; node-&gt;key &lt;&lt; &quot; &quot;; inorderHelper(node-&gt;right); &#125;public: RedBlackTree() : root(nullptr) &#123;&#125; RBTreeNode&lt;Key, Value&gt;* getRoot() const &#123; return root; &#125; void insert(const Key&amp; key, const Value&amp; value) &#123; RBTreeNode&lt;Key, Value&gt;* z = new RBTreeNode&lt;Key, Value&gt;(key, value); RBTreeNode&lt;Key, Value&gt;* y = nullptr; RBTreeNode&lt;Key, Value&gt;* x = root; while (x != nullptr) &#123; y = x; if (z-&gt;key &lt; x-&gt;key) x = x-&gt;left; else x = x-&gt;right; &#125; z-&gt;parent = y; if (y == nullptr) root = z; else if (z-&gt;key &lt; y-&gt;key) y-&gt;left = z; else y-&gt;right = z; // 插入后修正红黑树性质 insertFixUp(z); &#125; void inorderTraversal() const &#123; inorderHelper(root); std::cout &lt;&lt; std::endl; &#125; // 为简化示例，删除操作未实现 // 完整实现需要包含 deleteFixUp 等步骤&#125;; 简要说明上述红黑树类包含以下主要功能： **插入操作 (insert)**： 插入新的键值对，并调用 insertFixUp 进行修正，以保持红黑树的性质。 **旋转操作 (leftRotate 和 rightRotate)**： 通过旋转操作重新调整树的结构，确保树的平衡。 **修正插入后的红黑树性质 (insertFixUp)**： 根据红黑树的五大性质，通过重新着色和旋转来修正可能的违规情况。 **中序遍历 (inorderTraversal)**： 以中序遍历的方式输出树中的键，结果应为升序。 注意：为了简化示例，删除操作 (delete) 及其修正 (deleteFixUp) 未在此实现。如果需要完整的删除功能，请参考之前的详细解释或使用标准库中的实现。 6. 红黑树与其他平衡树的比较红黑树并非唯一的自平衡二叉搜索树，其他常见的平衡树包括 AVL 树（Adelson-Velsky和Landis树）和 Splay 树。以下是红黑树与 AVL 树的比较： 红黑树 vs AVL 树 特性 红黑树 (Red-Black Tree) AVL 树 (AVL Tree) 平衡性 相对不严格，每个路径上的黑色节点相同。 更严格，任意节点的左右子树高度差不超过1。 插入/删除效率 较快，插入和删除操作较少的旋转，适用于频繁修改的场景。 较慢，插入和删除可能需要多次旋转，适用于查找操作多于修改的场景。 查找效率 O(log n) O(log n)，常数因子更小，查找速度略快。 实现复杂度 相对简单，旋转操作较少。 实现较复杂，需严格维护高度平衡。 应用场景 操作频繁、需要快速插入和删除的场景。 查找操作频繁、插入和删除相对较少的场景。 选择依据 红黑树更适用于需要频繁插入和删除操作，并且查找操作相对较多的场景，因为其插入和删除操作的调整成本较低。 AVL 树适用于查找操作极为频繁，而修改操作相对较少的场景，因为其高度更严格，查找效率更高。 7. 红黑树的应用场景由于红黑树高效的查找、插入和删除性能，它在计算机科学中的多个领域都有广泛的应用： 标准库中的关联容器： C++ 标准库中的 std::map 和 std::set 通常基于红黑树实现。 Java 的 TreeMap 和 TreeSet 也是基于红黑树。 操作系统： Linux 内核中的调度器和虚拟内存管理使用红黑树来管理进程和内存资源。 数据库系统： 一些数据库索引结构使用红黑树来提高查询效率。 编译器设计： 语法分析树和符号表管理中可能使用红黑树来高效存储和查找符号。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"手写双端队列","date":"2024-12-27T06:10:59.000Z","path":"2024/12/27/cppbase26/","text":"1. 双端队列 (Deque) 概述双端队列（Double-Ended Queue，简称 deque）是一种允许在其两端进行高效插入和删除操作的数据结构。与普通队列（只允许在一端插入和另一端删除）相比，双端队列更为灵活。 C++ 标准库中已经提供了 std::deque，但通过自行实现一个双端队列，可以更好地理解其内部机制和迭代器的工作原理。 2. 实现思路为了实现一个高效的双端队列，我们需要考虑以下几点： 动态数组：使用动态数组（如环形缓冲区）来存储元素，以便支持在两端进行常数时间的插入和删除。 头尾指针：维护头部和尾部的索引，以便快速访问两端。 自动扩展：当容量不足时，自动调整内部缓冲区的大小。 迭代器支持：定义一个迭代器类，允许用户使用像 begin() 和 end() 这样的函数进行遍历。 接下来，我们将一步步实现这些功能。 3. 详细实现3.1 内部数据结构我们将使用一个动态分配的数组作为内部缓冲区，并通过头尾索引来管理队列的前后端。为了支持在两端高效插入和删除，我们将采用环形缓冲区的概念，即当索引达到数组的末端时，自动回绕到数组的开头。 3.2 Deque 类下面是 Deque 类的基本结构和关键成员： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;iostream&gt;#include &lt;stdexcept&gt;#include &lt;iterator&gt;template &lt;typename T&gt;class Deque &#123;private: T* buffer; // 内部缓冲区 size_t capacity; // 缓冲区容量 size_t front_idx; // 头部索引 size_t back_idx; // 尾部索引 size_t count; // 当前元素数量 // 调整容量 void resize(size_t new_capacity) &#123; T* new_buffer = new T[new_capacity]; // 重新排列元素 for (size_t i = 0; i &lt; count; ++i) &#123; new_buffer[i] = buffer[(front_idx + i) % capacity]; &#125; delete[] buffer; buffer = new_buffer; capacity = new_capacity; front_idx = 0; back_idx = count; &#125;public: // 构造函数 Deque(size_t initial_capacity = 8) : capacity(initial_capacity), front_idx(0), back_idx(0), count(0) &#123; buffer = new T[capacity]; &#125; // 析构函数 ~Deque() &#123; delete[] buffer; &#125; // 复制构造函数和赋值运算符（省略，为简洁起见） // 检查是否为空 bool empty() const &#123; return count == 0; &#125; // 获取大小 size_t size() const &#123; return count; &#125; // 在前面插入元素 void push_front(const T&amp; value) &#123; if (count == capacity) &#123; resize(capacity * 2); &#125; front_idx = (front_idx == 0) ? capacity - 1 : front_idx - 1; buffer[front_idx] = value; ++count; &#125; // 在后面插入元素 void push_back(const T&amp; value) &#123; if (count == capacity) &#123; resize(capacity * 2); &#125; buffer[back_idx] = value; back_idx = (back_idx + 1) % capacity; ++count; &#125; // 从前面删除元素 void pop_front() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; front_idx = (front_idx + 1) % capacity; --count; &#125; // 从后面删除元素 void pop_back() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; back_idx = (back_idx == 0) ? capacity - 1 : back_idx - 1; --count; &#125; // 获取前端元素 T&amp; front() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; return buffer[front_idx]; &#125; const T&amp; front() const &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; return buffer[front_idx]; &#125; // 获取后端元素 T&amp; back() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; size_t last_idx = (back_idx == 0) ? capacity - 1 : back_idx - 1; return buffer[last_idx]; &#125; const T&amp; back() const &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; size_t last_idx = (back_idx == 0) ? capacity - 1 : back_idx - 1; return buffer[last_idx]; &#125; // 迭代器类将放在这里（见下一部分） // 迭代器类定义 class Iterator &#123; private: Deque&lt;T&gt;* deque_ptr; size_t index; size_t pos; public: using iterator_category = std::bidirectional_iterator_tag; using value_type = T; using difference_type = std::ptrdiff_t; using pointer = T*; using reference = T&amp;; Iterator(Deque&lt;T&gt;* deque, size_t position) : deque_ptr(deque), pos(position) &#123;&#125; // 解引用操作 reference operator*() const &#123; size_t real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity; return deque_ptr-&gt;buffer[real_idx]; &#125; pointer operator-&gt;() const &#123; size_t real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity; return &amp;(deque_ptr-&gt;buffer[real_idx]); &#125; // 前置递增 Iterator&amp; operator++() &#123; ++pos; return *this; &#125; // 后置递增 Iterator operator++(int) &#123; Iterator temp = *this; ++pos; return temp; &#125; // 前置递减 Iterator&amp; operator--() &#123; --pos; return *this; &#125; // 后置递减 Iterator operator--(int) &#123; Iterator temp = *this; --pos; return temp; &#125; // 比较操作 bool operator==(const Iterator&amp; other) const &#123; return (deque_ptr == other.deque_ptr) &amp;&amp; (pos == other.pos); &#125; bool operator!=(const Iterator&amp; other) const &#123; return !(*this == other); &#125; &#125;; // 获取 begin 迭代器 Iterator begin() &#123; return Iterator(this, 0); &#125; // 获取 end 迭代器 Iterator end() &#123; return Iterator(this, count); &#125;&#125;; 3.3 迭代器类在上面的 Deque 类中，我们定义了一个嵌套的 Iterator 类。这个迭代器支持前向和后向遍历，并且可以与标准的 C++ 迭代器兼容。 关键点解释： 成员变量： deque_ptr：指向包含此迭代器的 Deque 实例。 pos：相对于队列头部的位置。 重载运算符： operator* 和 operator-&gt;：用于访问当前元素。 operator++ 和 operator--：前置和后置递增和递减，用于移动迭代器。 operator== 和 operator!=：用于比较两个迭代器是否相同。 注意事项： 迭代器并不管理元素的生命周期，只是提供遍历接口。 迭代器的有效性依赖于队列的修改操作（如插入和删除）。在实际应用中，需要注意迭代器失效的问题。 4. 使用示例下面是一个使用上述 Deque 类及其迭代器的示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;// 假设 Deque 类已经定义在这里int main() &#123; Deque&lt;std::string&gt; dq; // 在后面插入元素 dq.push_back(&quot;Apple&quot;); dq.push_back(&quot;Banana&quot;); dq.push_back(&quot;Cherry&quot;); // 在前面插入元素 dq.push_front(&quot;Date&quot;); dq.push_front(&quot;Elderberry&quot;); // 显示队列大小 std::cout &lt;&lt; &quot;Deque 大小: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl; // 使用迭代器进行遍历 std::cout &lt;&lt; &quot;Deque 元素: &quot;; for (auto it = dq.begin(); it != dq.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 访问前端和后端元素 std::cout &lt;&lt; &quot;前端元素: &quot; &lt;&lt; dq.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;后端元素: &quot; &lt;&lt; dq.back() &lt;&lt; std::endl; // 删除元素 dq.pop_front(); dq.pop_back(); // 再次遍历 std::cout &lt;&lt; &quot;删除元素后的 Deque: &quot;; for (auto it = dq.begin(); it != dq.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 预期输出12345Deque 大小: 5Deque 元素: Elderberry Date Apple Banana Cherry 前端元素: Elderberry后端元素: Cherry删除元素后的 Deque: Date Apple Banana 解释： 插入操作： 使用 push_back 在队列的后端插入 “Apple”, “Banana”, “Cherry”。 使用 push_front 在队列的前端插入 “Date”, “Elderberry”。 最终队列顺序为：Elderberry, Date, Apple, Banana, Cherry 遍历操作： 使用迭代器从 begin() 到 end() 遍历并打印所有元素。 访问元素： 使用 front() 获取队列前端的元素。 使用 back() 获取队列后端的元素。 删除操作： 使用 pop_front 删除前端元素（”Elderberry”）。 使用 pop_back 删除后端元素（”Cherry”）。 删除后，队列顺序为：Date, Apple, Banana 5. 完整代码以下是完整的 Deque 类及其使用示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include &lt;iostream&gt;#include &lt;stdexcept&gt;#include &lt;iterator&gt;// Deque 类定义template &lt;typename T&gt;class Deque &#123;private: T* buffer; // 内部缓冲区 size_t capacity; // 缓冲区容量 size_t front_idx; // 头部索引 size_t back_idx; // 尾部索引 size_t count; // 当前元素数量 // 调整容量 void resize(size_t new_capacity) &#123; T* new_buffer = new T[new_capacity]; // 重新排列元素 for (size_t i = 0; i &lt; count; ++i) &#123; new_buffer[i] = buffer[(front_idx + i) % capacity]; &#125; delete[] buffer; buffer = new_buffer; capacity = new_capacity; front_idx = 0; back_idx = count; &#125;public: // 构造函数 Deque(size_t initial_capacity = 8) : capacity(initial_capacity), front_idx(0), back_idx(0), count(0) &#123; buffer = new T[capacity]; &#125; // 析构函数 ~Deque() &#123; delete[] buffer; &#125; // 禁用复制构造函数和赋值运算符（为了简洁，可根据需要实现） Deque(const Deque&amp; other) = delete; Deque&amp; operator=(const Deque&amp; other) = delete; // 检查是否为空 bool empty() const &#123; return count == 0; &#125; // 获取大小 size_t size() const &#123; return count; &#125; // 在前面插入元素 void push_front(const T&amp; value) &#123; if (count == capacity) &#123; resize(capacity * 2); &#125; front_idx = (front_idx == 0) ? capacity - 1 : front_idx - 1; buffer[front_idx] = value; ++count; &#125; // 在后面插入元素 void push_back(const T&amp; value) &#123; if (count == capacity) &#123; resize(capacity * 2); &#125; buffer[back_idx] = value; back_idx = (back_idx + 1) % capacity; ++count; &#125; // 从前面删除元素 void pop_front() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; front_idx = (front_idx + 1) % capacity; --count; &#125; // 从后面删除元素 void pop_back() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; back_idx = (back_idx == 0) ? capacity - 1 : back_idx - 1; --count; &#125; // 获取前端元素 T&amp; front() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; return buffer[front_idx]; &#125; const T&amp; front() const &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; return buffer[front_idx]; &#125; // 获取后端元素 T&amp; back() &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; size_t last_idx = (back_idx == 0) ? capacity - 1 : back_idx - 1; return buffer[last_idx]; &#125; const T&amp; back() const &#123; if (empty()) &#123; throw std::out_of_range(&quot;Deque is empty&quot;); &#125; size_t last_idx = (back_idx == 0) ? capacity - 1 : back_idx - 1; return buffer[last_idx]; &#125; // 迭代器类定义 class Iterator &#123; private: Deque&lt;T&gt;* deque_ptr; size_t pos; public: using iterator_category = std::bidirectional_iterator_tag; using value_type = T; using difference_type = std::ptrdiff_t; using pointer = T*; using reference = T&amp;; Iterator(Deque&lt;T&gt;* deque, size_t position) : deque_ptr(deque), pos(position) &#123;&#125; // 解引用操作 reference operator*() const &#123; size_t real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity; return deque_ptr-&gt;buffer[real_idx]; &#125; pointer operator-&gt;() const &#123; size_t real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity; return &amp;(deque_ptr-&gt;buffer[real_idx]); &#125; // 前置递增 Iterator&amp; operator++() &#123; ++pos; return *this; &#125; // 后置递增 Iterator operator++(int) &#123; Iterator temp = *this; ++pos; return temp; &#125; // 前置递减 Iterator&amp; operator--() &#123; --pos; return *this; &#125; // 后置递减 Iterator operator--(int) &#123; Iterator temp = *this; --pos; return temp; &#125; // 比较操作 bool operator==(const Iterator&amp; other) const &#123; return (deque_ptr == other.deque_ptr) &amp;&amp; (pos == other.pos); &#125; bool operator!=(const Iterator&amp; other) const &#123; return !(*this == other); &#125; &#125;; // 获取 begin 迭代器 Iterator begin() &#123; return Iterator(this, 0); &#125; // 获取 end 迭代器 Iterator end() &#123; return Iterator(this, count); &#125;&#125;;// 使用示例int main() &#123; Deque&lt;std::string&gt; dq; // 在后面插入元素 dq.push_back(&quot;Apple&quot;); dq.push_back(&quot;Banana&quot;); dq.push_back(&quot;Cherry&quot;); // 在前面插入元素 dq.push_front(&quot;Date&quot;); dq.push_front(&quot;Elderberry&quot;); // 显示队列大小 std::cout &lt;&lt; &quot;Deque 大小: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl; // 使用迭代器进行遍历 std::cout &lt;&lt; &quot;Deque 元素: &quot;; for (auto it = dq.begin(); it != dq.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 访问前端和后端元素 std::cout &lt;&lt; &quot;前端元素: &quot; &lt;&lt; dq.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;后端元素: &quot; &lt;&lt; dq.back() &lt;&lt; std::endl; // 删除元素 dq.pop_front(); dq.pop_back(); // 再次遍历 std::cout &lt;&lt; &quot;删除元素后的 Deque: &quot;; for (auto it = dq.begin(); it != dq.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 编译和运行保存上述代码到一个文件，例如 DequeWithIterator.cpp，然后使用 C++ 编译器进行编译和运行： 12g++ -std=c++11 -o DequeWithIterator DequeWithIterator.cpp./DequeWithIterator 预期输出12345Deque 大小: 5Deque 元素: Elderberry Date Apple Banana Cherry 前端元素: Elderberry后端元素: Cherry删除元素后的 Deque: Date Apple Banana 6. 总结通过上述步骤，我们成功实现了一个支持双端插入和删除的双端队列（deque），并添加了迭代器支持，使其能够与标准的 C++ 迭代器接口兼容。这个实现包含了以下关键点： 内部缓冲区管理： 使用动态数组并采用环形缓冲区的方式，支持高效的双端操作。 自动调整缓冲区的容量，确保在元素数量增加时仍能保持高效。 迭代器实现： 定义了一个嵌套的 Iterator 类，支持前向和后向遍历。 重载了必要的运算符（如 *, -&gt;, ++, --, ==, !=），以实现与标准迭代器的兼容。 基本操作： push_front 和 push_back：分别在队列的前端和后端插入元素。 pop_front 和 pop_back：分别从队列的前端和后端删除元素。 front 和 back：访问队列的前端和后端元素。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(25) stl几种容器详解","date":"2024-12-22T00:17:32.000Z","path":"2024/12/22/cppbase25/","text":"简介C++的标准模板库（STL）提供了多种通用容器，用于存储和管理数据。这些容器各有特点，适用于不同的应用场景。理解每种容器的用法和内部实现原理，对于编写高效且可维护的代码至关重要。本教案将详细介绍几种常用的STL容器，包括vector、list、deque、map、unordered_map、set、unordered_set以及容器适配器如stack、queue和priority_queue。 vector：动态数组用法vector是STL中最常用的序列容器之一，提供了动态大小的数组功能。它支持随机访问，允许在末尾高效地添加和删除元素。 内部实现原理vector在内部使用动态数组（通常是连续的内存块）来存储元素。当需要扩展容量时，它会分配一块更大的内存，将现有元素复制到新内存中，然后释放旧内存。这种策略在平均情况下保证了push_back的常数时间复杂度。 性能特性 随机访问：支持常数时间的随机访问（O(1)）。 末尾插入/删除：push_back和pop_back操作在摊销分析下是常数时间（O(1)）。 中间插入/删除：在中间位置插入或删除元素需要移动后续元素，时间复杂度为线性时间（O(n)）。 应用场景 需要频繁随机访问元素。 主要在容器末尾进行插入和删除操作。 当容器大小不需要频繁调整（避免频繁的内存重新分配）。 代码示例12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; // 创建一个空的整数vector std::vector&lt;int&gt; numbers; // 向vector末尾添加元素 numbers.push_back(10); numbers.push_back(20); numbers.push_back(30); // 通过索引访问元素 std::cout &lt;&lt; &quot;第一个元素: &quot; &lt;&lt; numbers[0] &lt;&lt; std::endl; // 遍历vector std::cout &lt;&lt; &quot;所有元素: &quot;; for(auto it = numbers.begin(); it != numbers.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 删除最后一个元素 numbers.pop_back(); // 打印删除后的vector std::cout &lt;&lt; &quot;删除最后一个元素后: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出123第一个元素: 10所有元素: 10 20 30 删除最后一个元素后: 10 20 list：双向链表用法list是一个实现了双向链表的数据结构，适合在容器中间频繁插入和删除元素。与vector不同，list不支持随机访问，但在任何位置的插入和删除操作都是常数时间。 内部实现原理list在内部使用双向链表，每个元素包含指向前一个和后一个元素的指针。这使得在已知位置插入或删除元素时，无需移动其他元素，只需更新指针即可。 性能特性 随机访问：不支持随机访问，访问第n个元素需要线性时间（O(n)）。 中间插入/删除：已知位置的插入和删除操作是常数时间（O(1)）。 遍历：顺序遍历，适合需要频繁遍历但不需要随机访问的场景。 应用场景 需要在容器中间频繁插入或删除元素。 不需要进行随机访问。 对内存的局部性要求不高（链表元素在内存中不连续）。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;list&gt;int main() &#123; // 创建一个空的整数list std::list&lt;int&gt; numbers; // 向list末尾添加元素 numbers.push_back(100); numbers.push_back(200); numbers.push_back(300); // 向list前端添加元素 numbers.push_front(50); // 遍历list std::cout &lt;&lt; &quot;所有元素: &quot;; for(auto it = numbers.begin(); it != numbers.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 插入元素 auto it = numbers.begin(); ++it; // 指向第二个元素 numbers.insert(it, 150); // 打印插入后的list std::cout &lt;&lt; &quot;插入元素后: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 删除元素 numbers.remove(200); // 打印删除后的list std::cout &lt;&lt; &quot;删除元素后: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出123所有元素: 50 100 200 300 插入元素后: 50 150 100 200 300 删除元素后: 50 150 100 300 模拟实现一个简化版的 List为了更好地理解 std::list 的内部工作原理，我们可以尝试模拟实现一个简化版的双向链表。下面将逐步介绍如何设计和实现这个 List 类。 类设计我们的 List 类将包含以下组件： 节点结构体（Node）：表示链表的每个节点。 迭代器类（Iterator）：允许用户遍历链表。 List 类：管理链表的基本操作，如插入、删除和遍历。 节点结构体每个节点包含数据域和前后指针： 12345678template&lt;typename T&gt;struct Node &#123; T data; Node* prev; Node* next; Node(const T&amp; value = T()) : data(value), prev(nullptr), next(nullptr) &#123;&#125;&#125;; 迭代器实现为了实现双向迭代器，我们需要定义一个 Iterator 类，支持 ++ 和 -- 操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template&lt;typename T&gt;class List;template&lt;typename T&gt;class Iterator &#123;public: using self_type = Iterator&lt;T&gt;; using value_type = T; using reference = T&amp;; using pointer = T*; using iterator_category = std::bidirectional_iterator_tag; using difference_type = std::ptrdiff_t; Iterator(Node&lt;T&gt;* ptr = nullptr) : node_ptr(ptr) &#123;&#125; // Dereference operator reference operator*() const &#123; return node_ptr-&gt;data; &#125; // Arrow operator pointer operator-&gt;() const &#123; return &amp;(node_ptr-&gt;data); &#125; // Pre-increment self_type&amp; operator++() &#123; if (node_ptr) node_ptr = node_ptr-&gt;next; return *this; &#125; // Post-increment self_type operator++(int) &#123; self_type temp = *this; ++(*this); return temp; &#125; // Pre-decrement self_type&amp; operator--() &#123; if (node_ptr) node_ptr = node_ptr-&gt;prev; return *this; &#125; // Post-decrement self_type operator--(int) &#123; self_type temp = *this; --(*this); return temp; &#125; // Equality comparison bool operator==(const self_type&amp; other) const &#123; return node_ptr == other.node_ptr; &#125; // Inequality comparison bool operator!=(const self_type&amp; other) const &#123; return node_ptr != other.node_ptr; &#125;private: Node&lt;T&gt;* node_ptr; friend class List&lt;T&gt;;&#125;; List 类List 类提供链表的基本功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;iostream&gt;template&lt;typename T&gt;class List &#123;public: using iterator = Iterator&lt;T&gt;; using const_iterator = Iterator&lt;T&gt;; // 构造函数 List() &#123; head = new Node&lt;T&gt;(); // 哨兵节点 tail = new Node&lt;T&gt;(); // 哨兵节点 head-&gt;next = tail; tail-&gt;prev = head; &#125; // 析构函数 ~List() &#123; clear(); delete head; delete tail; &#125; // 禁止拷贝构造和赋值操作（简化实现） List(const List&amp; other) = delete; List&amp; operator=(const List&amp; other) = delete; // 插入元素到迭代器位置之前 iterator insert(iterator pos, const T&amp; value) &#123; Node&lt;T&gt;* current = pos.node_ptr; Node&lt;T&gt;* new_node = new Node&lt;T&gt;(value); Node&lt;T&gt;* prev_node = current-&gt;prev; new_node-&gt;next = current; new_node-&gt;prev = prev_node; prev_node-&gt;next = new_node; current-&gt;prev = new_node; return iterator(new_node); &#125; // 删除迭代器指向的元素 iterator erase(iterator pos) &#123; Node&lt;T&gt;* current = pos.node_ptr; if (current == head || current == tail) &#123; // 不能删除哨兵节点 return pos; &#125; Node&lt;T&gt;* prev_node = current-&gt;prev; Node&lt;T&gt;* next_node = current-&gt;next; prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; delete current; return iterator(next_node); &#125; // 在头部插入元素 void push_front(const T&amp; value) &#123; insert(begin(), value); &#125; // 在尾部插入元素 void push_back(const T&amp; value) &#123; insert(end(), value); &#125; // 在头部删除元素 void pop_front() &#123; if (!empty()) &#123; erase(begin()); &#125; &#125; // 在尾部删除元素 void pop_back() &#123; if (!empty()) &#123; iterator temp = end(); --temp; erase(temp); &#125; &#125; // 获取头元素引用 T&amp; front() &#123; return head-&gt;next-&gt;data; &#125; // 获取尾元素引用 T&amp; back() &#123; return tail-&gt;prev-&gt;data; &#125; // 判断是否为空 bool empty() const &#123; return head-&gt;next == tail; &#125; // 获取链表大小（O(n)复杂度） size_t size() const &#123; size_t count = 0; for(auto it = begin(); it != end(); ++it) &#123; ++count; &#125; return count; &#125; // 清空链表 void clear() &#123; Node&lt;T&gt;* current = head-&gt;next; while(current != tail) &#123; Node&lt;T&gt;* temp = current; current = current-&gt;next; delete temp; &#125; head-&gt;next = tail; tail-&gt;prev = head; &#125; // 获取开始迭代器 iterator begin() &#123; return iterator(head-&gt;next); &#125; // 获取结束迭代器 iterator end() &#123; return iterator(tail); &#125; // 打印链表（辅助函数） void print() const &#123; Node&lt;T&gt;* current = head-&gt;next; while(current != tail) &#123; std::cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;; current = current-&gt;next; &#125; std::cout &lt;&lt; std::endl; &#125;private: Node&lt;T&gt;* head; // 头哨兵 Node&lt;T&gt;* tail; // 尾哨兵&#125;; 完整代码示例下面是一个完整的示例，包括创建 List 对象，进行各种操作，并打印结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include &lt;iostream&gt;// 节点结构体template&lt;typename T&gt;struct Node &#123; T data; Node* prev; Node* next; Node(const T&amp; value = T()) : data(value), prev(nullptr), next(nullptr) &#123;&#125;&#125;;// 迭代器类template&lt;typename T&gt;class Iterator &#123;public: using self_type = Iterator&lt;T&gt;; using value_type = T; using reference = T&amp;; using pointer = T*; using iterator_category = std::bidirectional_iterator_tag; using difference_type = std::ptrdiff_t; Iterator(Node&lt;T&gt;* ptr = nullptr) : node_ptr(ptr) &#123;&#125; // Dereference operator reference operator*() const &#123; return node_ptr-&gt;data; &#125; // Arrow operator pointer operator-&gt;() const &#123; return &amp;(node_ptr-&gt;data); &#125; // Pre-increment self_type&amp; operator++() &#123; if (node_ptr) node_ptr = node_ptr-&gt;next; return *this; &#125; // Post-increment self_type operator++(int) &#123; self_type temp = *this; ++(*this); return temp; &#125; // Pre-decrement self_type&amp; operator--() &#123; if (node_ptr) node_ptr = node_ptr-&gt;prev; return *this; &#125; // Post-decrement self_type operator--(int) &#123; self_type temp = *this; --(*this); return temp; &#125; // Equality comparison bool operator==(const self_type&amp; other) const &#123; return node_ptr == other.node_ptr; &#125; // Inequality comparison bool operator!=(const self_type&amp; other) const &#123; return node_ptr != other.node_ptr; &#125;private: Node&lt;T&gt;* node_ptr; friend class List&lt;T&gt;;&#125;;// List 类template&lt;typename T&gt;class List &#123;public: using iterator = Iterator&lt;T&gt;; using const_iterator = Iterator&lt;T&gt;; // 构造函数 List() &#123; head = new Node&lt;T&gt;(); // 头哨兵 tail = new Node&lt;T&gt;(); // 尾哨兵 head-&gt;next = tail; tail-&gt;prev = head; &#125; // 析构函数 ~List() &#123; clear(); delete head; delete tail; &#125; // 禁止拷贝构造和赋值操作（简化实现） List(const List&amp; other) = delete; List&amp; operator=(const List&amp; other) = delete; // 插入元素到迭代器位置之前 iterator insert(iterator pos, const T&amp; value) &#123; Node&lt;T&gt;* current = pos.node_ptr; Node&lt;T&gt;* new_node = new Node&lt;T&gt;(value); Node&lt;T&gt;* prev_node = current-&gt;prev; new_node-&gt;next = current; new_node-&gt;prev = prev_node; prev_node-&gt;next = new_node; current-&gt;prev = new_node; return iterator(new_node); &#125; // 删除迭代器指向的元素 iterator erase(iterator pos) &#123; Node&lt;T&gt;* current = pos.node_ptr; if (current == head || current == tail) &#123; // 不能删除哨兵节点 return pos; &#125; Node&lt;T&gt;* prev_node = current-&gt;prev; Node&lt;T&gt;* next_node = current-&gt;next; prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; delete current; return iterator(next_node); &#125; // 在头部插入元素 void push_front(const T&amp; value) &#123; insert(begin(), value); &#125; // 在尾部插入元素 void push_back(const T&amp; value) &#123; insert(end(), value); &#125; // 在头部删除元素 void pop_front() &#123; if (!empty()) &#123; erase(begin()); &#125; &#125; // 在尾部删除元素 void pop_back() &#123; if (!empty()) &#123; iterator temp = end(); --temp; erase(temp); &#125; &#125; // 获取头元素引用 T&amp; front() &#123; return head-&gt;next-&gt;data; &#125; // 获取尾元素引用 T&amp; back() &#123; return tail-&gt;prev-&gt;data; &#125; // 判断是否为空 bool empty() const &#123; return head-&gt;next == tail; &#125; // 获取链表大小（O(n)复杂度） size_t size() const &#123; size_t count = 0; for(auto it = begin(); it != end(); ++it) &#123; ++count; &#125; return count; &#125; // 清空链表 void clear() &#123; Node&lt;T&gt;* current = head-&gt;next; while(current != tail) &#123; Node&lt;T&gt;* temp = current; current = current-&gt;next; delete temp; &#125; head-&gt;next = tail; tail-&gt;prev = head; &#125; // 获取开始迭代器 iterator begin() &#123; return iterator(head-&gt;next); &#125; // 获取结束迭代器 iterator end() &#123; return iterator(tail); &#125; // 打印链表（辅助函数） void print() const &#123; Node&lt;T&gt;* current = head-&gt;next; while(current != tail) &#123; std::cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;; current = current-&gt;next; &#125; std::cout &lt;&lt; std::endl; &#125;private: Node&lt;T&gt;* head; // 头哨兵 Node&lt;T&gt;* tail; // 尾哨兵&#125;;// 测试代码int main() &#123; List&lt;int&gt; lst; // 插入元素 lst.push_back(10); // 链表: 10 lst.push_front(5); // 链表: 5, 10 lst.push_back(15); // 链表: 5, 10, 15 lst.insert(++lst.begin(), 7); // 链表: 5, 7, 10, 15 // 打印链表 std::cout &lt;&lt; &quot;链表内容: &quot;; lst.print(); // 输出: 5 7 10 15 // 删除元素 lst.pop_front(); // 链表: 7, 10, 15 lst.pop_back(); // 链表: 7, 10 // 打印链表 std::cout &lt;&lt; &quot;删除头尾后链表内容: &quot;; lst.print(); // 输出: 7 10 // 插入和删除 auto it = lst.begin(); lst.insert(it, 3); // 链表: 3, 7, 10 lst.erase(++it); // 链表: 3, 10 // 打印链表 std::cout &lt;&lt; &quot;插入和删除后链表内容: &quot;; lst.print(); // 输出: 3 10 // 清空链表 lst.clear(); std::cout &lt;&lt; &quot;清空后，链表是否为空: &quot; &lt;&lt; (lst.empty() ? &quot;是&quot; : &quot;否&quot;) &lt;&lt; std::endl; return 0;&#125; 代码解释 **节点结构体 Node**：包含数据域 data，前驱指针 prev 和后继指针 next。 **迭代器类 Iterator**： 构造函数：接受一个 Node&lt;T&gt;* 指针。 重载操作符 ： * 和 -&gt; 用于访问节点数据。 ++ 和 -- 支持前向和后向遍历。 == 和 != 用于比较迭代器。 List 类： 成员变量 ： head 和 tail 是头尾哨兵节点。 构造函数：初始化头尾哨兵，并将它们互相连接。 析构函数：清空链表并删除哨兵节点。 **insert**：在指定位置前插入新节点。 **erase**：删除指定位置的节点。 **push_front 和 push_back**：分别在头部和尾部插入元素。 **pop_front 和 pop_back**：分别删除头部和尾部元素。 **front 和 back**：访问头尾元素。 **empty 和 size**：检查链表是否为空和获取链表大小。 **clear**：清空链表。 **begin 和 end**：返回开始和结束迭代器。 **print**：辅助函数，用于打印链表内容。 测试代码：创建 List&lt;int&gt; 对象，并执行一系列的插入、删除和遍历操作，验证 List 类的功能。 编译和运行保存上述代码到一个名为 List.cpp 的文件中，然后使用以下命令编译和运行： 12g++ -std=c++11 -o List List.cpp./List 输出结果： 1234链表内容: 5 7 10 15 删除头尾后链表内容: 7 10 插入和删除后链表内容: 3 10 清空后，链表是否为空: 是 迭代器分类1. 迭代器（Iterator）简介在 C++ 中，迭代器 是一种用于遍历容器（如 std::vector、std::list 等）元素的对象。它们提供了类似指针的接口，使得算法可以独立于具体的容器而工作。迭代器的设计允许算法以统一的方式处理不同类型的容器。 2. 迭代器类别（Iterator Categories）为了使不同类型的迭代器能够支持不同的操作，C++ 标准库将迭代器分为以下几种类别，每种类别支持的操作能力逐级增强： 输入迭代器（Input Iterator） 输出迭代器（Output Iterator） 前向迭代器（Forward Iterator） 双向迭代器（Bidirectional Iterator） 随机访问迭代器（Random Access Iterator） 无效迭代器（Contiguous Iterator）（C++20 引入） 每个类别都继承自前一个类别，具备更强的功能。例如，双向迭代器不仅支持前向迭代器的所有操作，还支持反向迭代（即可以向后移动）。 主要迭代器类别及其特性 类别 支持的操作 示例容器 输入迭代器 只读访问、单向前进 单向链表 std::forward_list 输出迭代器 只写访问、单向前进 输出流 std::ostream_iterator 前向迭代器 读写访问、单向前进 向量 std::vector 双向迭代器 读写访问、单向前进和反向迭代 双向链表 std::list 随机访问迭代器 读写访问、单向前进、反向迭代、跳跃移动（支持算术运算） 向量 std::vector、队列 std::deque 无效迭代器（新） 随机访问迭代器的所有功能，且元素在内存中连续排列 新的 C++ 容器如 std::span 3. iterator_category 的作用iterator_category 是迭代器类型中的一个别名，用于标识该迭代器所属的类别。它是标准库中 迭代器特性（Iterator Traits） 的一部分，标准算法会根据迭代器的类别优化其行为。 为什么需要 iterator_category标准库中的算法（如 std::sort、std::find 等）需要知道迭代器支持哪些操作，以便选择最优的实现方式。例如： 对于随机访问迭代器，可以使用快速的随机访问算法（如快速排序）。 对于双向迭代器，只能使用适用于双向迭代的算法（如归并排序）。 对于输入迭代器，只能进行单次遍历，许多复杂算法无法使用。 通过指定 iterator_category，你可以让标准算法了解你自定义迭代器的能力，从而选择合适的方法进行操作。 iterator_category 的声明在你的自定义迭代器类中，通过以下方式声明迭代器类别： 1using iterator_category = std::bidirectional_iterator_tag; 这表示该迭代器是一个 双向迭代器，支持向前和向后遍历。 4. std::bidirectional_iterator_tag 详解std::bidirectional_iterator_tag 是一个标签（Tag），用于标识迭代器类别。C++ 标准库中有多个这样的标签，分别对应不同的迭代器类别： std::input_iterator_tag std::output_iterator_tag std::forward_iterator_tag std::bidirectional_iterator_tag std::random_access_iterator_tag std::contiguous_iterator_tag（C++20） 这些标签本质上是空的结构体，用于类型区分。在标准算法中，通常会通过这些标签进行 重载选择（Overload Resolution） 或 特化（Specialization），以实现针对不同迭代器类别的优化。 继承关系迭代器标签是有继承关系的： std::forward_iterator_tag 继承自 std::input_iterator_tag std::bidirectional_iterator_tag 继承自 std::forward_iterator_tag std::random_access_iterator_tag 继承自 std::bidirectional_iterator_tag std::contiguous_iterator_tag 继承自 std::random_access_iterator_tag 这种继承关系反映了迭代器类别的能力层级。例如，双向迭代器 具备 前向迭代器 的所有能力，加上反向遍历的能力。 5. 迭代器特性（Iterator Traits）详解C++ 提供了 迭代器特性（Iterator Traits），通过模板类 std::iterator_traits 来获取迭代器的相关信息。通过这些特性，标准算法可以泛化地处理不同类型的迭代器。 迭代器特性包含的信息std::iterator_traits 提供以下信息： iterator_category：迭代器类别标签。 value_type：迭代器指向的元素类型。 difference_type：迭代器间的距离类型（通常是 std::ptrdiff_t）。 pointer：指向元素的指针类型。 reference：对元素的引用类型。 自定义迭代器与 iterator_traits当你定义自己的迭代器时，确保提供这些类型别名，以便标准库算法能够正确识别和使用你的迭代器。例如： 1234567891011template&lt;typename T&gt;class Iterator &#123;public: using iterator_category = std::bidirectional_iterator_tag; using value_type = T; using difference_type = std::ptrdiff_t; using pointer = T*; using reference = T&amp;; // 其他成员函数...&#125;; 这样，使用 std::iterator_traits&lt;Iterator&lt;T&gt;&gt; 时，就能正确获取迭代器的特性。 deque：双端队列用法deque（双端队列）是一种支持在两端高效插入和删除元素的序列容器。与vector相比，deque支持在前端和后端均以常数时间进行插入和删除操作。 内部实现原理deque通常由一系列固定大小的数组块组成，这些块通过一个中央映射数组进行管理。这种结构使得在两端扩展时不需要重新分配整个容器的内存，从而避免了vector在前端插入的高成本。 性能特性 随机访问：支持常数时间的随机访问（O(1)）。 前后插入/删除：在前端和后端插入和删除元素的操作都是常数时间（O(1)）。 中间插入/删除：在中间位置插入或删除元素需要移动元素，时间复杂度为线性时间（O(n)）。 应用场景 需要在容器两端频繁插入和删除元素。 需要随机访问元素。 不需要频繁在中间位置插入和删除元素。 双端队列简介双端队列（deque）是一种序列容器，允许在其两端高效地插入和删除元素。与vector不同，deque不仅支持在末尾添加或删除元素（如vector），还支持在头部进行同样的操作。此外，deque提供了随机访问能力，可以像vector一样通过索引访问元素。 主要特点 双端操作：支持在头部和尾部高效的插入和删除操作。 随机访问：可以像数组和vector一样通过索引访问元素。 动态大小：可以根据需要增长和收缩，无需预先定义大小。 内存分配策略deque内部并不使用一个单一的连续内存块，而是将元素分割成多个固定大小的块（也称为缓冲区或页面），并通过一个中央映射数组（通常称为map）来管理这些块。具体来说，deque的内部结构可以分为以下几个部分： 中央映射数组（Map）： 一个指针数组，指向各个数据块。 map本身也是动态分配的，可以根据需要增长或收缩。 map允许deque在两端添加新的数据块，而无需移动现有的数据块。 数据块（Blocks）： 每个数据块是一个固定大小的连续内存区域，用于存储元素。 数据块的大小通常与编译器和平台相关，但在大多数实现中，数据块的大小在运行时是固定的（如512字节或更多，具体取决于元素类型的大小）。 起始和结束指针： deque维护指向中央映射数组中第一个有效数据块的指针以及第一个无效数据块的指针。 这些指针帮助deque快速地在两端添加或删除数据块。 双端队列的操作实现插入操作在末尾插入 (push_back) 检查当前末端数据块的剩余空间： 如果有空间，直接在当前末端数据块中插入新元素。 如果没有空间，分配一个新的数据块，并将其指针添加到map中，然后在新块中插入元素。 更新末尾指针： 如果分配了新块，末尾指针指向该块的第一个元素。 否则，末尾指针移动到当前末端数据块的下一个位置。 在前端插入 (push_front) 检查当前前端数据块的剩余空间： 如果有空间，直接在当前前端数据块中插入新元素。 如果没有空间，分配一个新的数据块，并将其指针添加到map的前面，然后在新块中插入元素。 更新前端指针： 如果分配了新块，前端指针指向该块的最后一个元素。 否则，前端指针移动到当前前端数据块的前一个位置。 删除操作从末尾删除 (pop_back) 检查末端数据块是否有元素 ： 如果有，移除最后一个元素，并更新末尾指针。 如果数据块变为空，释放该数据块并从map中移除其指针，然后更新末尾指针指向前一个块。 从前端删除 (pop_front) 检查前端数据块是否有元素 ： 如果有，移除第一个元素，并更新前端指针。 如果数据块变为空，释放该数据块并从map中移除其指针，然后更新前端指针指向下一个块。 访问操作随机访问 deque支持通过索引进行随机访问，其内部机制如下： 计算元素的位置： 根据给定的索引，确定对应的数据块和数据块内的偏移量。 使用map数组定位到具体的块，然后通过偏移量定位到块内的元素。 访问元素： 一旦定位到具体的位置，即可像数组一样访问元素。 迭代器访问 deque提供双向迭代器，支持使用标准的C++迭代器操作（如++、--等）进行遍历。 双端队列的性能特性理解deque的内部实现有助于理解其性能特性。以下是deque的主要操作及其时间复杂度： 操作 时间复杂度 说明 随机访问（通过索引） 常数时间（O(1)） 通过计算块和偏移量直接访问元素 插入/删除前端 常数时间（O(1)） 仅涉及前端指针和可能的数据块分配 插入/删除末端 常数时间（O(1)） 仅涉及末端指针和可能的数据块分配 中间插入/删除 线性时间（O(n)） 需要移动数据块内的元素，可能涉及多个块的操作 查找元素 线性时间（O(n)） 需要遍历元素进行查找 插入单个元素 平均常数时间（O(1)） 在前端或末端插入，通常不需移动大量元素 插入大量元素 线性时间（O(n)） 需要分配新的数据块并进行元素复制 优缺点优点 双端操作高效：在两端插入和删除元素非常快速，不需要移动大量元素。 支持随机访问：可以像vector一样通过索引高效访问元素。 动态增长：无需预先定义大小，可以根据需要自动调整。 缺点 内存碎片：由于使用多个数据块，可能导致内存碎片，尤其是在大量插入和删除操作后。 较低的局部性：元素不连续存储，可能导致缓存未命中率较高，影响性能。 复杂性较高：内部实现相对复杂，不如vector直接高效。 双端队列与其他容器的比较 特性 vector deque list 内存结构 单一连续内存块 多块连续内存，通过映射数组管理 双向链表 随机访问 是，常数时间（O(1)） 是，常数时间（O(1)） 否，需要线性时间（O(n)） 前端插入/删除 低效，线性时间（O(n)） 高效，常数时间（O(1)） 高效，常数时间（O(1)） 末端插入/删除 高效，常数时间（O(1)） 高效，常数时间（O(1)） 高效，常数时间（O(1)） 内存碎片 低，由于单一连续内存块 较高，由于多块内存管理 较高，由于节点分散在内存中 元素隔离 高，局部性较好 中等，分块存储提高了部分局部性 低，元素分散存储，缓存效率低 应用场景 需要频繁随机访问、末端操作的场景 需要频繁在两端插入/删除且偶尔随机访问的场景 需要频繁在中间插入/删除且不需要随机访问的场景 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;deque&gt;int main() &#123; // 创建一个空的deque std::deque&lt;std::string&gt; dq; // 在末尾添加元素 dq.push_back(&quot;End1&quot;); dq.push_back(&quot;End2&quot;); // 在前端添加元素 dq.push_front(&quot;Front1&quot;); dq.push_front(&quot;Front2&quot;); // 遍历deque std::cout &lt;&lt; &quot;deque中的元素: &quot;; for(auto it = dq.begin(); it != dq.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 访问首尾元素 std::cout &lt;&lt; &quot;首元素: &quot; &lt;&lt; dq.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;尾元素: &quot; &lt;&lt; dq.back() &lt;&lt; std::endl; // 删除首元素 dq.pop_front(); // 删除尾元素 dq.pop_back(); // 打印删除后的deque std::cout &lt;&lt; &quot;删除首尾元素后: &quot;; for(auto num : dq) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出1234deque中的元素: Front2 Front1 End1 End2 首元素: Front2尾元素: End2删除首尾元素后: Front1 End1 map和unordered_map：关联数组map用法与原理用法map是一个关联容器，用于存储键值对（key-value）。它基于键自动排序，且每个键都是唯一的。map提供了快速的查找、插入和删除操作。 内部实现原理map通常使用自平衡的二叉搜索树（如红黑树）实现。这确保了所有操作的时间复杂度为对数时间（O(log n)），且元素按照键的顺序排列。 unordered_map用法与原理用法unordered_map也是一种关联容器，用于存储键值对，但它不保证元素的顺序。unordered_map基于哈希表实现，提供了平均常数时间（O(1)）的查找、插入和删除操作。 内部实现原理unordered_map使用哈希表来存储元素。键通过哈希函数转换为哈希值，并映射到特定的桶中。如果多个键映射到同一桶，会通过链表或其他方法解决冲突。 性能对比 操作 map unordered_map 查找 O(log n) 平均 O(1) 插入 O(log n) 平均 O(1) 删除 O(log n) 平均 O(1) 内存使用 较高 较低 元素顺序 有序 无序 应用场景 **map**： 需要按键的顺序遍历元素。 需要有序的关联数组。 需要高效的范围查找。 **unordered_map**： 对元素顺序没有要求。 需要极高效的查找、插入和删除操作。 不需要自定义的排序规则。 代码示例map示例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;int main() &#123; // 创建一个空的map，键为string，值为int std::map&lt;std::string, int&gt; ageMap; // 插入键值对 ageMap[&quot;Alice&quot;] = 30; ageMap[&quot;Bob&quot;] = 25; ageMap[&quot;Charlie&quot;] = 35; // 查找元素 std::string name = &quot;Bob&quot;; if(ageMap.find(name) != ageMap.end()) &#123; std::cout &lt;&lt; name &lt;&lt; &quot; 的年龄是 &quot; &lt;&lt; ageMap[name] &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;未找到 &quot; &lt;&lt; name &lt;&lt; std::endl; &#125; // 遍历map std::cout &lt;&lt; &quot;所有人员和年龄: &quot; &lt;&lt; std::endl; for(auto it = ageMap.begin(); it != ageMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl; &#125; // 删除元素 ageMap.erase(&quot;Alice&quot;); // 打印删除后的map std::cout &lt;&lt; &quot;删除Alice后: &quot; &lt;&lt; std::endl; for(auto &amp;[key, value] : ageMap) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; : &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; return 0;&#125; unordered_map示例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;int main() &#123; // 创建一个空的unordered_map，键为string，值为double std::unordered_map&lt;std::string, double&gt; priceMap; // 插入键值对 priceMap[&quot;Apple&quot;] = 1.2; priceMap[&quot;Banana&quot;] = 0.5; priceMap[&quot;Orange&quot;] = 0.8; // 查找元素 std::string fruit = &quot;Banana&quot;; if(priceMap.find(fruit) != priceMap.end()) &#123; std::cout &lt;&lt; fruit &lt;&lt; &quot; 的价格是 $&quot; &lt;&lt; priceMap[fruit] &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;未找到 &quot; &lt;&lt; fruit &lt;&lt; std::endl; &#125; // 遍历unordered_map std::cout &lt;&lt; &quot;所有水果和价格: &quot; &lt;&lt; std::endl; for(auto &amp;[key, value] : priceMap) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; : $&quot; &lt;&lt; value &lt;&lt; std::endl; &#125; // 删除元素 priceMap.erase(&quot;Apple&quot;); // 打印删除后的unordered_map std::cout &lt;&lt; &quot;删除Apple后: &quot; &lt;&lt; std::endl; for(auto &amp;[key, value] : priceMap) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; : $&quot; &lt;&lt; value &lt;&lt; std::endl; &#125; return 0;&#125; 输出map输出12345678Bob 的年龄是 25所有人员和年龄: Alice : 30Bob : 25Charlie : 35删除Alice后: Bob : 25Charlie : 35 unordered_map输出12345678Banana 的价格是 $0.5所有水果和价格: Apple : $1.2Banana : $0.5Orange : $0.8删除Apple后: Banana : $0.5Orange : $0.8 set和unordered_set：集合set用法与原理用法set是一个关联容器，用于存储唯一的、有序的元素。set基于键自动排序，且每个元素都是唯一的。 内部实现原理set通常使用自平衡的二叉搜索树（如红黑树）实现，保证元素按顺序排列。每次插入元素时，都会自动保持树的平衡，并确保元素的唯一性。 unordered_set用法与原理用法unordered_set也是一种集合容器，用于存储唯一的元素，但它不保证元素的顺序。unordered_set基于哈希表实现，提供了平均常数时间（O(1)）的查找、插入和删除操作。 内部实现原理unordered_set使用哈希表存储元素。每个元素通过哈希函数转换为哈希值，并映射到特定的桶中。冲突通过链表或其他方法解决。 性能对比 操作 set unordered_set 查找 O(log n) 平均 O(1) 插入 O(log n) 平均 O(1) 删除 O(log n) 平均 O(1) 内存使用 较高 较低 元素顺序 有序 无序 应用场景 **set**： 需要有序的唯一元素集合。 需要按顺序遍历元素。 需要基于区间的操作（如查找、删除某范围的元素）。 **unordered_set**： 对元素顺序无要求。 需要极高效的查找、插入和删除操作。 不需要自定义的排序规则。 代码示例set示例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;set&gt;int main() &#123; // 创建一个空的整数set std::set&lt;int&gt; numbers; // 插入元素 numbers.insert(10); numbers.insert(20); numbers.insert(30); numbers.insert(20); // 重复元素，不会被插入 // 遍历set std::cout &lt;&lt; &quot;set中的元素: &quot;; for(auto it = numbers.begin(); it != numbers.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 查找元素 int key = 20; if(numbers.find(key) != numbers.end()) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; 在set中存在。&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; key &lt;&lt; &quot; 不在set中。&quot; &lt;&lt; std::endl; &#125; // 删除元素 numbers.erase(10); // 打印删除后的set std::cout &lt;&lt; &quot;删除10后set中的元素: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; unordered_set示例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;unordered_set&gt;int main() &#123; // 创建一个空的unordered_set std::unordered_set&lt;int&gt; numbers; // 插入元素 numbers.insert(10); numbers.insert(20); numbers.insert(30); numbers.insert(20); // 重复元素，不会被插入 // 遍历unordered_set std::cout &lt;&lt; &quot;unordered_set中的元素: &quot;; for(auto it = numbers.begin(); it != numbers.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 查找元素 int key = 20; if(numbers.find(key) != numbers.end()) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; 在unordered_set中存在。&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; key &lt;&lt; &quot; 不在unordered_set中。&quot; &lt;&lt; std::endl; &#125; // 删除元素 numbers.erase(10); // 打印删除后的unordered_set std::cout &lt;&lt; &quot;删除10后unordered_set中的元素: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出set输出123set中的元素: 10 20 30 20 在set中存在。删除10后set中的元素: 20 30 unordered_set输出（注意元素顺序可能不同）123unordered_set中的元素: 10 20 30 20 在unordered_set中存在。删除10后unordered_set中的元素: 20 30 stack、queue和priority_queue：容器适配器用法STL中的容器适配器（stack、queue、priority_queue）提供了特定的数据结构接口，这些适配器在内部使用其他容器来存储元素（默认使用deque或vector）。 内部实现原理 **stack**：后进先出（LIFO）数据结构，通常使用deque或vector作为底层容器，通过限制操作接口来实现。 **queue**：先进先出（FIFO）数据结构，通常使用deque作为底层容器，通过限制操作接口来实现。 **priority_queue**：基于堆的数据结构，通常使用vector作为底层容器，并通过堆算法（如std::make_heap、std::push_heap、std::pop_heap）维护元素的优先级顺序。 性能特性 **stack**： 访问顶部元素：O(1) 插入和删除：O(1) **queue**： 访问前端和后端元素：O(1) 插入和删除：O(1) **priority_queue**： 访问顶部（最大或最小元素）：O(1) 插入和删除：O(log n) 应用场景 **stack**： 实现函数调用栈。 处理撤销操作。 深度优先搜索（DFS）。 **queue**： 实现任务调度。 广度优先搜索（BFS）。 数据流处理。 **priority_queue**： 实现优先级调度。 求解最短路径算法（如Dijkstra）。 任意需要按优先级处理元素的场景。 代码示例stack示例1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;stack&gt;int main() &#123; // 创建一个空的stack，底层使用vector std::stack&lt;int&gt; s; // 压入元素 s.push(1); s.push(2); s.push(3); // 访问栈顶元素 std::cout &lt;&lt; &quot;栈顶元素: &quot; &lt;&lt; s.top() &lt;&lt; std::endl; // 弹出元素 s.pop(); std::cout &lt;&lt; &quot;弹出一个元素后，新的栈顶: &quot; &lt;&lt; s.top() &lt;&lt; std::endl; // 判断栈是否为空 if(!s.empty()) &#123; std::cout &lt;&lt; &quot;栈不为空，元素数量: &quot; &lt;&lt; s.size() &lt;&lt; std::endl; &#125; return 0;&#125; queue示例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;queue&gt;int main() &#123; // 创建一个空的queue，底层使用deque std::queue&lt;std::string&gt; q; // 入队元素 q.push(&quot;First&quot;); q.push(&quot;Second&quot;); q.push(&quot;Third&quot;); // 访问队首元素 std::cout &lt;&lt; &quot;队首元素: &quot; &lt;&lt; q.front() &lt;&lt; std::endl; // 访问队尾元素 std::cout &lt;&lt; &quot;队尾元素: &quot; &lt;&lt; q.back() &lt;&lt; std::endl; // 出队元素 q.pop(); std::cout &lt;&lt; &quot;出队后新的队首: &quot; &lt;&lt; q.front() &lt;&lt; std::endl; // 判断队列是否为空 if(!q.empty()) &#123; std::cout &lt;&lt; &quot;队列不为空，元素数量: &quot; &lt;&lt; q.size() &lt;&lt; std::endl; &#125; return 0;&#125; priority_queue示例1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;int main() &#123; // 创建一个空的priority_queue，默认是最大堆 std::priority_queue&lt;int&gt; pq; // 插入元素 pq.push(30); pq.push(10); pq.push(20); pq.push(40); // 访问堆顶元素 std::cout &lt;&lt; &quot;优先级最高的元素: &quot; &lt;&lt; pq.top() &lt;&lt; std::endl; // 弹出元素 pq.pop(); std::cout &lt;&lt; &quot;弹出一个元素后，新的堆顶: &quot; &lt;&lt; pq.top() &lt;&lt; std::endl; // 遍历priority_queue（需要复制，因为无法直接遍历） std::priority_queue&lt;int&gt; copy = pq; std::cout &lt;&lt; &quot;剩余的元素: &quot;; while(!copy.empty()) &#123; std::cout &lt;&lt; copy.top() &lt;&lt; &quot; &quot;; copy.pop(); &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出stack输出123栈顶元素: 3弹出一个元素后，新的栈顶: 2栈不为空，元素数量: 2 queue输出1234队首元素: First队尾元素: Third出队后新的队首: Second队列不为空，元素数量: 2 priority_queue输出123优先级最高的元素: 40弹出一个元素后，新的堆顶: 30剩余的元素: 30 20 10 总结C++ STL提供了丰富多样的容器，适用于各种不同的数据存储和管理需求。理解每种容器的特点、内部实现原理以及性能特性，可以帮助开发者在实际应用中做出最佳的选择，从而编写出高效且可维护的代码。 序列容器： **vector**：适用于需要频繁随机访问和在末尾操作的场景。 **list**：适用于需要在中间频繁插入和删除的场景。 **deque**：适用于需要在两端频繁插入和删除的场景。 关联容器： **map*和*set**：适用于需要有序存储和快速查找的场景。 **unordered_map*和*unordered_set**：适用于需要高效查找且对元素顺序无要求的场景。 容器适配器： **stack**：用于LIFO操作。 **queue**：用于FIFO操作。 **priority_queue**：用于优先级队列操作。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(23) 智能指针","date":"2024-12-06T02:57:07.000Z","path":"2024/12/06/cppbase23/","text":"1. 引言C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 new 和 delete 带来的复杂性和错误。智能指针通过 RAII（资源获取即初始化）机制，在对象生命周期结束时自动释放资源，从而有效防止内存泄漏和资源管理错误。 2. 原生指针 vs 智能指针原生指针原生指针是 C++ 最基本的指针类型，允许程序员直接管理内存。然而，原生指针存在以下问题： 内存泄漏：未释放动态分配的内存。 悬挂指针：指针指向已释放或未初始化的内存。 双重释放：多次释放同一内存区域。 智能指针的优势智能指针通过封装原生指针，自动管理内存，解决上述问题。主要优势包括： 自动销毁：在智能指针生命周期结束时自动释放资源。 引用计数：共享智能指针能够跟踪引用数量，确保资源在最后一个引用结束时释放。 避免内存泄漏：通过 RAII 机制自动管理资源生命周期。 类型安全：提供更严格的类型检查，减少错误。 3. std::unique_ptr3.1 定义与用法std::unique_ptr 是一种独占所有权的智能指针，任何时刻只能有一个 unique_ptr 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。 主要特性： 独占所有权：确保资源在一个所有者下。 轻量级：没有引用计数，开销小。 自动释放：在指针销毁时自动释放资源。 3.2 构造函数与赋值unique_ptr 提供多种构造函数和赋值操作，以支持不同的使用场景。 默认构造函数：创建一个空的 unique_ptr。 指针构造函数：接受一个裸指针，拥有其所有权。 移动构造函数：将一个 unique_ptr 的所有权转移到另一个 unique_ptr。 移动赋值操作符：将一个 unique_ptr 的所有权转移到另一个 unique_ptr。 3.3 移动语义由于 unique_ptr 不能被拷贝，必须通过移动语义转移所有权。这保证了资源的独占性。 3.4 代码案例123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;memory&gt;class Test &#123;public: Test(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Test Constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;Test Destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void show() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;private: int value;&#125;;int main() &#123; // 创建一个 unique_ptr std::unique_ptr&lt;Test&gt; ptr1(new Test(100)); ptr1-&gt;show(); // 使用 make_unique（C++14 引入） auto ptr2 = std::make_unique&lt;Test&gt;(200); ptr2-&gt;show(); // 移动 unique_ptr std::unique_ptr&lt;Test&gt; ptr3 = std::move(ptr1); if (!ptr1) &#123; std::cout &lt;&lt; &quot;ptr1 is now nullptr after move.&quot; &lt;&lt; std::endl; &#125; ptr3-&gt;show(); // 重置 unique_ptr ptr2.reset(new Test(300)); ptr2-&gt;show(); // unique_ptr 自动释放资源 return 0;&#125; 输出： 1234567891011Test Constructor: 100Value: 100Test Constructor: 200Value: 200ptr1 is now nullptr after move.Value: 100Test Destructor: 100Test Constructor: 300Value: 300Test Destructor: 300Test Destructor: 200 解析： ptr1 拥有 Test(100)，ptr2 拥有 Test(200)。 通过 std::move 将 ptr1 的所有权转移到 ptr3，ptr1 变为空。 ptr2.reset(new Test(300)) 释放了原有的 Test(200)，并拥有新的 Test(300)。 程序结束时，ptr3 和 ptr2 自动释放各自拥有的资源。 4. std::shared_ptr4.1 定义与用法std::shared_ptr 是一种共享所有权的智能指针，允许多个 shared_ptr 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。 主要特性： 共享所有权：多个 shared_ptr 可以指向同一个对象。 引用计数：跟踪有多少 shared_ptr 实例指向同一对象。 自动释放：当引用计数为0时，自动释放资源。 4.2 引用计数与控制块shared_ptr 背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括： 强引用计数（use_count）：表示有多少个 shared_ptr 指向对象。 弱引用计数（weak_count）：表示有多少个 weak_ptr 指向对象（不增加强引用计数）。 4.3 构造函数与赋值shared_ptr 提供多种构造函数和赋值操作，以支持不同的使用场景。 默认构造函数：创建一个空的 shared_ptr。 指针构造函数：接受一个裸指针，拥有其所有权。 拷贝构造函数：增加引用计数，共享对象所有权。 移动构造函数：转移所有权，源 shared_ptr 变为空。 拷贝赋值操作符：释放当前资源，增加引用计数，指向新对象。 移动赋值操作符：释放当前资源，转移所有权，源 shared_ptr 变为空。 4.4 代码案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;memory&gt;class Test &#123;public: Test(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Test Constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;Test Destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void show() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;private: int value;&#125;;int main() &#123; // 创建一个 shared_ptr std::shared_ptr&lt;Test&gt; sp1(new Test(100)); std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; sp1-&gt;show(); // 通过拷贝构造共享所有权 std::shared_ptr&lt;Test&gt; sp2 = sp1; std::cout &lt;&lt; &quot;After sp2 = sp1:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl; // 通过拷贝赋值共享所有权 std::shared_ptr&lt;Test&gt; sp3; sp3 = sp2; std::cout &lt;&lt; &quot;After sp3 = sp2:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp3 use_count: &quot; &lt;&lt; sp3.use_count() &lt;&lt; std::endl; // 重置 shared_ptr sp2.reset(new Test(200)); std::cout &lt;&lt; &quot;After sp2.reset(new Test(200)):&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp3 use_count: &quot; &lt;&lt; sp3.use_count() &lt;&lt; std::endl; sp2-&gt;show(); // 自动释放资源 std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 12345678910111213141516171819Test Constructor: 100sp1 use_count: 1Value: 100After sp2 = sp1:sp1 use_count: 2sp2 use_count: 2After sp3 = sp2:sp1 use_count: 3sp2 use_count: 3sp3 use_count: 3Test Constructor: 200After sp2.reset(new Test(200)):sp1 use_count: 2sp2 use_count: 1sp3 use_count: 2Value: 200Exiting main...Test Destructor: 200Test Destructor: 100 解析： 创建 sp1，引用计数为1。 拷贝构造 sp2，引用计数增加到2。 拷贝赋值 sp3，引用计数增加到3。 ```sp2.reset(new Test(200)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 ： - 原 `Test(100)` 的引用计数减少到2。 - 分配新的 `Test(200)`，`sp2` 拥有它，引用计数为1。- 程序结束时： - `sp1` 和 `sp3` 释放 `Test(100)`，引用计数降到0，资源被销毁。 - `sp2` 释放 `Test(200)`，引用计数为0，资源被销毁。## 5. `std::weak_ptr`### 5.1 定义与用法`std::weak_ptr` 是一种不拥有对象所有权的智能指针，用于观察但不影响对象的生命周期。主要用于解决 `shared_ptr` 之间的循环引用问题。**主要特性**：- **非拥有所有权**：不增加引用计数。- **可从 `shared_ptr` 生成**：通过 `std::weak_ptr` 可以访问 `shared_ptr` 管理的对象。- **避免循环引用**：适用于双向关联或观察者模式。### 5.2 避免循环引用在存在双向关联（如父子关系）时，使用多个 `shared_ptr` 可能导致循环引用，导致内存泄漏。此时，可以使用 `weak_ptr` 来打破循环。### 5.3 代码案例#### 场景：双向关联导致循环引用```cpp#include &lt;iostream&gt;#include &lt;memory&gt;class B; // 前向声明class A &#123;public: std::shared_ptr&lt;B&gt; ptrB; A() &#123; std::cout &lt;&lt; &quot;A Constructor&quot; &lt;&lt; std::endl; &#125; ~A() &#123; std::cout &lt;&lt; &quot;A Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public: std::shared_ptr&lt;A&gt; ptrA; B() &#123; std::cout &lt;&lt; &quot;B Constructor&quot; &lt;&lt; std::endl; &#125; ~B() &#123; std::cout &lt;&lt; &quot;B Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; &#123; std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;(); a-&gt;ptrB = b; b-&gt;ptrA = a; &#125; std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 12345A ConstructorB ConstructorExiting main...A DestructorB Destructor 问题： 虽然 a 和 b 离开作用域，但 A Destructor 和 B Destructor 并未被调用，因为 a 和 b 相互引用，引用计数无法降到0，导致内存泄漏。 解决方案：使用 weak_ptr改用 weak_ptr 其中一方（如 B 的 ptrA），打破循环引用。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;memory&gt;class B; // 前向声明class A &#123;public: std::shared_ptr&lt;B&gt; ptrB; A() &#123; std::cout &lt;&lt; &quot;A Constructor&quot; &lt;&lt; std::endl; &#125; ~A() &#123; std::cout &lt;&lt; &quot;A Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public: std::weak_ptr&lt;A&gt; ptrA; // 使用 weak_ptr B() &#123; std::cout &lt;&lt; &quot;B Constructor&quot; &lt;&lt; std::endl; &#125; ~B() &#123; std::cout &lt;&lt; &quot;B Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; &#123; std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;(); a-&gt;ptrB = b; b-&gt;ptrA = a; &#125; std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 12345A ConstructorB ConstructorA DestructorB DestructorExiting main... 解析： B 使用 weak_ptr 指向 A，不增加引用计数。 a 和 b 离开作用域，引用计数降为0，资源被正确释放。 防止了循环引用，避免了内存泄漏。 5.4 访问 weak_ptr 指向的对象weak_ptr 不能直接访问对象，需要通过 lock() 方法转换为 shared_ptr，并检查对象是否仍然存在。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(42); std::weak_ptr&lt;int&gt; wp = sp; if (auto locked = wp.lock()) &#123; // 尝试获取 shared_ptr std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *locked &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Object no longer exists.&quot; &lt;&lt; std::endl; &#125; sp.reset(); // 释放资源 if (auto locked = wp.lock()) &#123; // 再次尝试获取 shared_ptr std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *locked &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Object no longer exists.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 12Value: 42Object no longer exists. 解析： wp.lock() 返回一个 shared_ptr，如果对象依然存在，则有效。 sp.reset() 释放资源后，wp.lock() 无法获取有效的 shared_ptr。 6. 自定义删除器6.1 用例与实现有时，默认的 delete 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。 6.2 代码案例用例：管理 FILE* 资源1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;struct FileDeleter &#123; void operator()(FILE* fp) const &#123; if (fp) &#123; std::cout &lt;&lt; &quot;Closing file.&quot; &lt;&lt; std::endl; fclose(fp); &#125; &#125;&#125;;int main() &#123; &#123; std::shared_ptr&lt;FILE&gt; filePtr(fopen(&quot;example.txt&quot;, &quot;w&quot;), FileDeleter()); if (filePtr) &#123; std::cout &lt;&lt; &quot;File opened successfully.&quot; &lt;&lt; std::endl; // 使用 filePtr 进行文件操作 fprintf(filePtr.get(), &quot;Hello, World!\\n&quot;); &#125; &#125; // 自动关闭文件 std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 123File opened successfully.Closing file.Exiting main... 解析： 自定义删除器 FileDeleter 用于在 shared_ptr 被销毁时关闭文件。 使用 filePtr.get() 获取原生 FILE* 指针进行文件操作。 离开作用域时，自动调用 FileDeleter 关闭文件。 6.3 使用 Lambda 表达式作为删除器C++11 允许使用 lambda 表达式作为删除器，简化代码。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;int main() &#123; &#123; auto fileDeleter = [](FILE* fp) &#123; if (fp) &#123; std::cout &lt;&lt; &quot;Closing file via lambda.&quot; &lt;&lt; std::endl; fclose(fp); &#125; &#125;; std::unique_ptr&lt;FILE, decltype(fileDeleter)&gt; filePtr(fopen(&quot;example.txt&quot;, &quot;w&quot;), fileDeleter); if (filePtr) &#123; std::cout &lt;&lt; &quot;File opened successfully.&quot; &lt;&lt; std::endl; fprintf(filePtr.get(), &quot;Hello, Lambda!\\n&quot;); &#125; &#125; // 自动关闭文件 std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 123File opened successfully.Closing file via lambda.Exiting main... 解析： 使用 std::unique_ptr 搭配 lambda 删除器管理 FILE*。 提供了更灵活和简洁的删除器实现。 7. 最佳实践与常见陷阱7.1 选择合适的智能指针 **std::unique_ptr**： 用于明确的独占所有权场景。 适用于资源的单一管理者或需要所有权转移的情况。 更轻量，性能更优。 **std::shared_ptr**： 用于共享所有权的场景。 需要多个指针共同管理同一资源时使用。 引用计数带来一定的性能开销。 **std::weak_ptr**： 用于观察不拥有资源的场景。 适用于需要避免循环引用或只需临时访问资源的情况。 7.2 避免循环引用在使用 shared_ptr 时，特别是在对象间存在双向引用时，容易导致循环引用，内存泄漏。使用 weak_ptr 打破循环引用。 7.3 使用 make_shared 与 make_unique优先使用 make_shared 和 make_unique 来创建智能指针，避免直接使用 new，提高效率和异常安全性。 12auto sp = std::make_shared&lt;Test&gt;(100);auto up = std::make_unique&lt;Test&gt;(200); 7.4 不要混用原生指针与智能指针避免在智能指针管理的对象上同时使用原生指针进行管理，防止重复释放或不安全访问。 7.5 理解智能指针的所有权语义深入理解不同智能指针的所有权规则，避免误用导致资源管理错误。 8. 总结智能指针是 C++ 中强大的资源管理工具，通过封装原生指针，提供自动化的内存管理，极大地减少了内存泄漏和资源管理错误。std::unique_ptr、std::shared_ptr 和 std::weak_ptr 各有其应用场景，理解它们的差异和使用方法对于编写安全、高效的 C++ 代码至关重要。此外，通过实现自己的智能指针（如 SimpleSharedPtr），可以更深入地理解智能指针的工作原理，为高级 C++ 编程打下坚实基础。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(24) 可调用对象function类","date":"2024-12-06T02:57:07.000Z","path":"2024/12/06/cppbase24/","text":"引言C++ 提供了多种方式来表示和操作可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、std::function 和 std::bind 等。这些工具极大地增强了C++的灵活性和表达能力，尤其在处理回调、事件驱动编程和函数式编程时表现尤为出色。 函数指针函数指针是C++中最基本的可调用对象之一，用于指向普通函数和静态成员函数。 定义与使用函数指针的定义涉及到函数的返回类型和参数列表。例如，定义一个指向返回 int 且接受两个 int 参数的函数指针： 123456789101112131415161718// 定义函数指针类型int (*funcPtr)(int, int);// 定义一个普通函数int add(int a, int b) &#123; return a + b;&#125;int main() &#123; // 给函数指针赋值 funcPtr = &amp;add; // 调用函数 int result = funcPtr(3, 4); std::cout &lt;&lt; &quot;结果: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出: 结果: 7 return 0;&#125; 优点与局限性优点: 简单直观，适用于简单的回调函数。 局限性: 不能捕获上下文（如lambda中的闭包）。 语法相对复杂，尤其是指针的声明和使用。 仿函数（Functors）仿函数（Functors），又称函数对象（Function Objects），是在C++中重载了 operator() 的类或结构体实例。仿函数不仅可以像普通函数一样被调用，还能携带状态，提供更大的灵活性和功能性。 定义与使用仿函数是通过定义一个类或结构体，并重载其调用运算符 operator() 来实现的。 12345678910111213141516171819202122#include &lt;iostream&gt;// 定义一个仿函数类struct Adder &#123; int to_add; // 构造函数 Adder(int value) : to_add(value) &#123;&#125; // 重载()运算符 int operator()(int x) const &#123; return x + to_add; &#125;&#125;;int main() &#123; Adder add5(5); // 创建一个添加5的仿函数 std::cout &lt;&lt; &quot;10 + 5 = &quot; &lt;&lt; add5(10) &lt;&lt; std::endl; // 输出: 10 + 5 = 15 return 0;&#125; 特点 携带状态： 仿函数可以拥有内部状态，通过成员变量存储数据，使其在调用时具备上下文信息。 灵活性高： 可以根据需要添加更多的成员函数和变量，扩展功能。 性能优化： 编译器可以对仿函数进行优化，例如内联展开，提高执行效率。 高级示例仿函数不仅可以执行简单的计算，还可以进行复杂的操作。例如，实现一个可变的仿函数，用于累加多个值。 12345678910111213141516171819202122232425#include &lt;iostream&gt;// 可变累加器仿函数struct Accumulator &#123; int sum; Accumulator() : sum(0) &#123;&#125; // 重载()运算符 void operator()(int x) &#123; sum += x; &#125;&#125;;int main() &#123; Accumulator acc; acc(10); acc(20); acc(30); std::cout &lt;&lt; &quot;总和: &quot; &lt;&lt; acc.sum &lt;&lt; std::endl; // 输出: 总和: 60 return 0;&#125; 使用仿函数的标准库算法许多标准库算法可以接受仿函数作为参数，使得算法的行为更加灵活和可定制。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 仿函数：判断一个数是否大于某个阈值struct IsGreaterThan &#123; int threshold; IsGreaterThan(int t) : threshold(t) &#123;&#125; bool operator()(int x) const &#123; return x &gt; threshold; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; numbers = &#123;1, 5, 10, 15, 20&#125;; // 使用仿函数进行筛选 IsGreaterThan greaterThan10(10); auto it = std::find_if(numbers.begin(), numbers.end(), greaterThan10); if(it != numbers.end()) &#123; std::cout &lt;&lt; &quot;第一个大于10的数是: &quot; &lt;&lt; *it &lt;&lt; std::endl; // 输出: 第一个大于10的数是: 15 &#125; else &#123; std::cout &lt;&lt; &quot;没有找到大于10的数。&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 仿函数与模板仿函数与模板相结合，可以实现高度通用和可复用的代码。例如，编写一个通用的比较仿函数。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 通用比较仿函数template &lt;typename T&gt;struct Compare &#123; bool operator()(const T&amp; a, const T&amp; b) const &#123; return a &lt; b; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; numbers = &#123;5, 2, 8, 1, 9&#125;; // 使用仿函数进行排序 std::sort(numbers.begin(), numbers.end(), Compare&lt;int&gt;()); std::cout &lt;&lt; &quot;排序后的数字: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // 输出: 1 2 5 8 9 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 仿函数的优势 可扩展性： 能够根据需要添加更多功能和状态。 与Lambda的互补性： 在需要携带复杂状态或多次调用时，仿函数比Lambda更适合。 类型安全： 仿函数是具体的类型，可以在编译期进行类型检查。 何时使用仿函数 需要携带状态时： 当回调函数需要维护内部状态时，仿函数是理想选择。 复杂操作： 当简单的函数指针或Lambda难以表达复杂逻辑时。 性能关键场景： 由于仿函数可以被编译器优化，适用于性能敏感的代码。 Lambda表达式Lambda表达式是C++11引入的一种轻量级函数对象，允许在代码中定义匿名函数。它们可以捕获周围的变量，具有更强的表达能力。 基本语法123[captures](parameters) -&gt; return_type &#123; // 函数体&#125; captures: 捕获外部变量的方式，可以是值捕获、引用捕获或者混合捕获。 parameters: 参数列表。 return_type: 返回类型，可以省略，编译器会自动推导。 函数体: 实际执行的代码。 示例123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; int threshold = 5; std::vector&lt;int&gt; numbers = &#123;1, 6, 3, 8, 2, 7&#125;; // 使用lambda表达式进行过滤 numbers.erase(std::remove_if(numbers.begin(), numbers.end(), [threshold](int n) -&gt; bool &#123; return n &lt; threshold; &#125;), numbers.end()); // 输出结果 for(auto n : numbers) &#123; std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; // 输出: 6 8 7 &#125; return 0;&#125; 捕获方式 值捕获 ([=]): 捕获所有外部变量的副本。 引用捕获 ([&amp;]): 捕获所有外部变量的引用。 混合捕获: 指定部分变量按值捕获，部分按引用捕获，如 [=, &amp;var] 或 [&amp;, var]。 无捕获 ([]): 不捕获任何外部变量。 可变Lambda默认情况下，Lambda表达式是不可变的（const）。通过mutable关键字，可以允许修改捕获的变量副本。 1234567891011121314151617#include &lt;iostream&gt;int main() &#123; int count = 0; auto increment = [count]() mutable &#123; count++; std::cout &lt;&lt; &quot;Count inside Lambda: &quot; &lt;&lt; count &lt;&lt; std::endl; &#125;; increment(); // 输出: Count inside Lambda: 1 increment(); // 输出: Count inside Lambda: 2 std::cout &lt;&lt; &quot;Count outside Lambda: &quot; &lt;&lt; count &lt;&lt; std::endl; // 输出: Count outside Lambda: 0 return 0;&#125; 捕获成员函数和类变量Lambda表达式可以捕获类的成员变量和成员函数，使其在类的上下文中更加灵活。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class Processor &#123;public: Processor(int threshold) : threshold(threshold) &#123;&#125; void process(std::vector&lt;int&gt;&amp; data) &#123; std::cout &lt;&lt; &quot;处理前数据: &quot;; for(auto num : data) std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; // 使用Lambda表达式进行过滤 data.erase(std::remove_if(data.begin(), data.end(), [this](int n) -&gt; bool &#123; return n &lt; threshold; &#125;), data.end()); std::cout &lt;&lt; &quot;处理后数据: &quot;; for(auto num : data) std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; &#125;private: int threshold;&#125;;int main() &#123; std::vector&lt;int&gt; numbers = &#123;1, 6, 3, 8, 2, 7&#125;; Processor proc(5); proc.process(numbers); /* 输出: 处理前数据: 1 6 3 8 2 7 处理后数据: 6 8 7 */ return 0;&#125; Lambda与标准库算法Lambda表达式与标准库算法紧密结合，提供了更简洁和直观的代码书写方式。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; numbers = &#123;4, 2, 5, 1, 3&#125;; // 使用Lambda表达式进行排序 std::sort(numbers.begin(), numbers.end(), [](int a, int b) -&gt; bool &#123; return a &lt; b; &#125;); std::cout &lt;&lt; &quot;排序后的数字: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // 输出: 1 2 3 4 5 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; Lambda表达式的优势 简洁性： 代码更加紧凑，易于理解。 灵活性： 能够捕获外部变量，适应更多场景。 性能优化： 编译器可以对Lambda进行优化，如内联展开。 与标准库的良好集成： 与STL算法无缝结合，简化代码逻辑。 std::function 对象std::function 是C++11提供的一个通用的可调用包装器，能够封装任何可调用对象，包括普通函数、Lambda表达式、函数对象以及绑定表达式。它实现了类型擦除，使得不同类型的可调用对象可以通过统一的接口进行操作。 定义与使用123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;functional&gt;// 普通函数int add(int a, int b) &#123; return a + b;&#125;// 函数对象struct Multiply &#123; int operator()(int a, int b) const &#123; return a * b; &#125;&#125;;int main() &#123; // 封装普通函数 std::function&lt;int(int, int)&gt; func1 = add; std::cout &lt;&lt; &quot;Add: &quot; &lt;&lt; func1(3, 4) &lt;&lt; std::endl; // 输出: Add: 7 // 封装Lambda表达式 std::function&lt;int(int, int)&gt; func2 = [](int a, int b) -&gt; int &#123; return a - b; &#125;; std::cout &lt;&lt; &quot;Subtract: &quot; &lt;&lt; func2(10, 4) &lt;&lt; std::endl; // 输出: Subtract: 6 // 封装函数对象 Multiply multiply; std::function&lt;int(int, int)&gt; func3 = multiply; std::cout &lt;&lt; &quot;Multiply: &quot; &lt;&lt; func3(3, 4) &lt;&lt; std::endl; // 输出: Multiply: 12 return 0;&#125; 特点 类型擦除： 可以存储任何符合签名的可调用对象。 灵活性： 支持动态改变存储的可调用对象。 性能开销： 相比于直接使用函数指针或Lambda，std::function 可能带来一定的性能开销，尤其是在频繁调用时。 用法场景 回调函数的传递。 事件处理系统。 策略模式的实现。 示例：回调机制1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;functional&gt;// 定义回调类型using Callback = std::function&lt;void(int)&gt;;// 触发事件的函数void triggerEvent(Callback cb, int value) &#123; // 事件发生，调用回调 cb(value);&#125;int main() &#123; // 使用Lambda作为回调 triggerEvent([](int x) &#123; std::cout &lt;&lt; &quot;事件触发，值为: &quot; &lt;&lt; x &lt;&lt; std::endl; &#125;, 42); // 输出: 事件触发，值为: 42 // 使用仿函数作为回调 struct Printer &#123; void operator()(int x) const &#123; std::cout &lt;&lt; &quot;Printer打印值: &quot; &lt;&lt; x &lt;&lt; std::endl; &#125; &#125; printer; triggerEvent(printer, 100); // 输出: Printer打印值: 100 return 0;&#125; 存储和调用不同类型的可调用对象std::function 可以在容器中存储各种不同类型的可调用对象，只要它们符合指定的签名。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;vector&gt;int add(int a, int b) &#123; return a + b;&#125;struct Multiply &#123; int operator()(int a, int b) const &#123; return a * b; &#125;&#125;;int main() &#123; std::vector&lt;std::function&lt;int(int, int)&gt;&gt; operations; // 添加不同类型的可调用对象 operations.emplace_back(add); // 普通函数 operations.emplace_back(Multiply()); // 仿函数 operations.emplace_back([](int a, int b) -&gt; int &#123; return a - b; &#125;); // Lambda // 执行所有操作 for(auto&amp; op : operations) &#123; std::cout &lt;&lt; op(10, 5) &lt;&lt; &quot; &quot;; // 输出: 15 50 5 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; std::bind 操作std::bind 是C++11中提供的一个函数适配器，用于绑定函数或可调用对象的部分参数，生成一个新的可调用对象。它允许提前固定某些参数，简化函数调用或适应接口需求。 基本用法12345678910111213141516#include &lt;iostream&gt;#include &lt;functional&gt;// 普通函数int add(int a, int b) &#123; return a + b;&#125;int main() &#123; // 绑定第一个参数为10，生成新的函数对象 auto add10 = std::bind(add, 10, std::placeholders::_1); std::cout &lt;&lt; &quot;10 + 5 = &quot; &lt;&lt; add10(5) &lt;&lt; std::endl; // 输出: 10 + 5 = 15 return 0;&#125; 占位符 (std::placeholders)std::bind 使用占位符来表示未绑定的参数，这些占位符决定了在生成的新函数对象中如何传递参数。 常用的占位符包括： std::placeholders::_1 std::placeholders::_2 std::placeholders::_3 等等，根据需要传递的参数数量。 示例1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;functional&gt;void display(const std::string&amp; msg, int count) &#123; for(int i = 0; i &lt; count; ++i) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;&#125;int main() &#123; // 绑定消息为&quot;Hello&quot;，生成新的函数对象，只需要传递次数 auto sayHello = std::bind(display, &quot;Hello&quot;, std::placeholders::_1); sayHello(3); /* 输出: Hello Hello Hello */ // 绑定次数为2，生成新的函数对象，只需要传递消息 auto sayTwice = std::bind(display, std::placeholders::_1, 2); sayTwice(&quot;Hi&quot;); /* 输出: Hi Hi */ return 0;&#125; 与Lambda表达式的对比std::bind 曾在C++11中广泛使用，但随着Lambda表达式的普及，很多情况下Lambda更为直观和高效。不过，在某些复杂的参数绑定场景下，std::bind 依然有其独特优势。 使用 std::bind: 123456789101112131415#include &lt;iostream&gt;#include &lt;functional&gt;int multiply(int a, int b) &#123; return a * b;&#125;int main() &#123; // 绑定第一个参数为2，生成新的函数对象 auto multiplyBy2 = std::bind(multiply, 2, std::placeholders::_1); std::cout &lt;&lt; &quot;2 * 5 = &quot; &lt;&lt; multiplyBy2(5) &lt;&lt; std::endl; // 输出: 2 * 5 = 10 return 0;&#125; 使用 Lambda 表达式: 1234567891011121314151617#include &lt;iostream&gt;#include &lt;functional&gt;int multiply(int a, int b) &#123; return a * b;&#125;int main() &#123; // 使用Lambda表达式绑定第一个参数为2 auto multiplyBy2 = [](int b) -&gt; int &#123; return multiply(2, b); &#125;; std::cout &lt;&lt; &quot;2 * 5 = &quot; &lt;&lt; multiplyBy2(5) &lt;&lt; std::endl; // 输出: 2 * 5 = 10 return 0;&#125; 总结： 可读性： Lambda表达式通常更具可读性，语法更直观。 灵活性： Lambda更易于捕获和使用外部变量。 性能： Lambda通常比std::bind更高效，因为std::bind可能引入额外的间接层。 绑定类的成员函数在C++中，成员函数与普通函数不同，因为它们需要一个对象实例来调用。使用 std::bind 或Lambda表达式，可以方便地绑定类的成员函数，生成可调用对象。 使用 std::bind 绑定成员函数1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;functional&gt;class Calculator &#123;public: int multiply(int a, int b) const &#123; return a * b; &#125;&#125;;int main() &#123; Calculator calc; // 绑定成员函数multiply，固定第一个参数为5 auto multiplyBy5 = std::bind(&amp;Calculator::multiply, &amp;calc, 5, std::placeholders::_1); std::cout &lt;&lt; &quot;5 * 3 = &quot; &lt;&lt; multiplyBy5(3) &lt;&lt; std::endl; // 输出: 5 * 3 = 15 return 0;&#125; 使用Lambda表达式绑定成员函数12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;functional&gt;class Greeter &#123;public: void greet(const std::string&amp; name) const &#123; std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Greeter greeter; // 使用Lambda表达式绑定成员函数 auto greetFunc = [&amp;greeter](const std::string&amp; name) &#123; greeter.greet(name); &#125;; greetFunc(&quot;Alice&quot;); // 输出: Hello, Alice! return 0;&#125; 绑定静态成员函数静态成员函数不依赖于类的实例，可以像普通函数一样使用 std::bind 和 std::function。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;functional&gt;class Logger &#123;public: static void log(const std::string&amp; message) &#123; std::cout &lt;&lt; &quot;Log: &quot; &lt;&lt; message &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // 使用std::bind绑定静态成员函数 auto logFunc = std::bind(&amp;Logger::log, std::placeholders::_1); logFunc(&quot;This is a static log message.&quot;); // 输出: Log: This is a static log message. return 0;&#125; 绑定带有返回值的成员函数123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;functional&gt;class Math &#123;public: double power(double base, double exponent) const &#123; double result = 1.0; for(int i = 0; i &lt; static_cast&lt;int&gt;(exponent); ++i) &#123; result *= base; &#125; return result; &#125;&#125;;int main() &#123; Math mathObj; // 绑定成员函数power，固定基数为2 auto powerOf2 = std::bind(&amp;Math::power, &amp;mathObj, 2.0, std::placeholders::_1); std::cout &lt;&lt; &quot;2^3 = &quot; &lt;&lt; powerOf2(3) &lt;&lt; std::endl; // 输出: 2^3 = 8 return 0;&#125; 注意事项 对象生命周期： 绑定成员函数时，确保对象在可调用对象使用期间依然存在，以避免悬空指针问题。 指针与引用： 可以通过指针或引用传递对象实例给 std::bind 或Lambda表达式。 捕获方式： 在使用Lambda表达式时，选择合适的捕获方式（值捕获或引用捕获）以确保对象的正确访问。 C++ 可调用对象的总结C++ 提供了多种方式来定义和操作可调用对象，每种方式有其独特的特点和适用场景。 可调用对象 描述 示例用法 函数指针 指向普通函数或静态成员函数的指针 int (*func)(int) = &amp;funcName; 仿函数（Functors） 重载了 operator() 的类实例，可以携带状态 struct Foo &#123; void operator()(); &#125;; Lambda表达式 定义在表达式中的匿名函数，支持捕获上下文变量 [capture](params) &#123; /* code */ &#125; std::function 通用的可调用对象包装器，能够封装任何符合签名的可调用对象 std::function&lt;void(int)&gt; func; std::bind 绑定函数或可调用对象的部分参数，生成新的可调用对象 auto newFunc = std::bind(func, _1); 选择建议 简单回调： 使用函数指针或Lambda表达式。 需要携带状态或更复杂逻辑： 使用Lambda表达式或仿函数（Functors）。 接口要求 std::function： 使用 std::function，不过要注意可能的性能开销。 参数预绑定： 使用 std::bind，但在现代C++中，许多情况下Lambda表达式能达到相同效果且更直观。 完整示例代码以下是一个综合示例，展示了函数指针、仿函数（Functors）、Lambda表达式、std::function、std::bind 以及绑定类成员函数的使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 1. 普通函数int add(int a, int b) &#123; return a + b;&#125;// 2. 仿函数（Functors）struct Multiply &#123; int operator()(int a, int b) const &#123; return a * b; &#125;&#125;;// 3. Lambda表达式auto subtract = [](int a, int b) -&gt; int &#123; return a - b;&#125;;// 4. 类定义class Calculator &#123;public: int subtract(int a, int b) const &#123; return a - b; &#125; void displayOperation(const std::string&amp; op, int result) const &#123; std::cout &lt;&lt; op &lt;&lt; &quot;结果: &quot; &lt;&lt; result &lt;&lt; std::endl; &#125;&#125;;// 5. 静态成员函数class Logger &#123;public: static void log(const std::string&amp; message) &#123; std::cout &lt;&lt; &quot;Log: &quot; &lt;&lt; message &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // 1. 函数指针 int (*funcPtr)(int, int) = &amp;add; std::cout &lt;&lt; &quot;Add (Function Pointer): &quot; &lt;&lt; funcPtr(10, 5) &lt;&lt; std::endl; // 输出: 15 // 2. 仿函数（Functors） Multiply multiply; std::cout &lt;&lt; &quot;Multiply (Functors): &quot; &lt;&lt; multiply(10, 5) &lt;&lt; std::endl; // 输出: 50 // 3. Lambda表达式 std::cout &lt;&lt; &quot;Subtract (Lambda): &quot; &lt;&lt; subtract(10, 5) &lt;&lt; std::endl; // 输出: 5 // 4. std::function 封装不同可调用对象 std::function&lt;int(int, int)&gt; funcAdd = add; std::function&lt;int(int, int)&gt; funcSubtract = subtract; std::function&lt;int(int, int)&gt; funcMultiply = multiply; std::cout &lt;&lt; &quot;Add (std::function): &quot; &lt;&lt; funcAdd(20, 10) &lt;&lt; std::endl; // 输出: 30 std::cout &lt;&lt; &quot;Subtract (std::function): &quot; &lt;&lt; funcSubtract(20, 4) &lt;&lt; std::endl; // 输出: 16 std::cout &lt;&lt; &quot;Multiply (std::function): &quot; &lt;&lt; funcMultiply(4, 5) &lt;&lt; std::endl; // 输出: 20 // 5. std::bind 绑定部分参数 auto add5 = std::bind(add, 5, std::placeholders::_1); std::cout &lt;&lt; &quot;5 + 10 = &quot; &lt;&lt; add5(10) &lt;&lt; std::endl; // 输出: 15 auto multiplyBy2 = std::bind(multiply, 2, std::placeholders::_1); std::cout &lt;&lt; &quot;2 * 10 = &quot; &lt;&lt; multiplyBy2(10) &lt;&lt; std::endl; // 输出: 20 // 6. 绑定类成员函数 Calculator calc; // 使用 std::bind 绑定成员函数 subtract auto boundSubtract = std::bind(&amp;Calculator::subtract, &amp;calc, 15, 5); std::cout &lt;&lt; &quot;15 - 5 = &quot; &lt;&lt; boundSubtract() &lt;&lt; std::endl; // 输出: 10 // 使用 std::bind 绑定成员函数 displayOperation auto displayAdd = std::bind(&amp;Calculator::displayOperation, &amp;calc, &quot;Add&quot;, std::placeholders::_1); auto displayResult = funcAdd; int addResult = displayResult(7, 8); // 15 displayAdd(addResult); // 输出: Add结果: 15 // 7. 绑定静态成员函数 auto logFunc = std::bind(&amp;Logger::log, std::placeholders::_1); logFunc(&quot;This is a static log message.&quot;); // 输出: Log: This is a static log message. // 8. 使用 std::function 存储混合可调用对象 std::vector&lt;std::function&lt;void()&gt;&gt; operations; // 添加不同的操作到容器 operations.emplace_back([&amp;]() &#123; std::cout &lt;&lt; &quot;Lambda Operation&quot; &lt;&lt; std::endl; &#125;); operations.emplace_back(std::bind(&amp;Calculator::displayOperation, &amp;calc, &quot;Multiply&quot;, 30)); operations.emplace_back([&amp;]() &#123; std::cout &lt;&lt; &quot;Add5(10): &quot; &lt;&lt; add5(10) &lt;&lt; std::endl; &#125;); operations.emplace_back([&amp;]() &#123; Logger::log(&quot;Lambda-based log message.&quot;); &#125;); // 执行所有操作 for(auto&amp; op : operations) &#123; op(); &#125; /* 输出: Lambda Operation Multiply结果: 30 Add5(10): 15 Log: Lambda-based log message. */ return 0;&#125; 解释: 函数指针: 定义并使用了指向 add 函数的函数指针 funcPtr。 仿函数（Functors）: 定义了 Multiply 结构体，并使用其实例 multiply 进行乘法运算。 Lambda表达式: 定义了一个用于减法的Lambda subtract。 std::function: 封装了不同类型的可调用对象，包括普通函数、Lambda和仿函数。 std::bind: 绑定 add 和 multiply 函数的部分参数，生成新的可调用对象 add5 和 multiplyBy2。 绑定类成员函数: 使用 std::bind 绑定 Calculator 类的成员函数 subtract 和 displayOperation。 绑定静态成员函数: 使用 std::bind 绑定 Logger 类的静态成员函数 log。 混合可调用对象容器: 使用 std::function 和 std::vector 存储并执行不同类型的可调用对象，包括Lambda、绑定成员函数和静态成员函数。 小结通过本教案，学生应能够理解并运用C++中的各种可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、std::function 和 std::bind 等。掌握这些工具不仅有助于编写更灵活和可维护的代码，还为进一步学习函数式编程和设计模式奠定了坚实的基础。在实际编程中，合理选择和组合这些可调用对象，可以大大提升代码的效率和表达力。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(22) 内存管理","date":"2024-12-05T07:47:53.000Z","path":"2024/12/05/cppbase22/","text":"内存管理简介详细技术视频请看我的主页 C++教程视频 C++ 提供了多种内存管理方式，包括传统的 C 风格的 malloc 和 free，以及 C++ 专用的 new 和 delete。 理解这些内存管理方法对于编写高效、安全的 C++ 程序至关重要。 本文将详细介绍这些内存管理方法，包含基本用法、复杂操作（如 realloc），并配以实际案例和代码示例。 内存管理基础在 C++ 程序中，内存主要分为以下几个区域： 栈（Stack）：自动管理内存，存储局部变量和函数调用信息。内存分配和释放速度快，但空间有限。 堆（Heap）：手动管理内存，用于动态分配内存。内存分配和释放由程序员控制，灵活但易出错（如内存泄漏、悬挂指针）。 全局/静态区（Data/BSS Segment）：存储全局变量和静态变量。 了解栈和堆的区别，以及如何有效地在堆上分配和管理内存，是编写高效且安全的 C++ 程序的基础。 C 风格内存管理malloc 函数malloc（memory allocation）用于在堆上分配指定字节数的内存。其原型如下： 123#include &lt;cstdlib&gt;void* malloc(size_t size); 参数：size - 要分配的内存字节数。 返回值：指向分配内存的指针，如果分配失败则返回 nullptr。 free 函数free 用于释放之前由 malloc、calloc 或 realloc 分配的内存。其原型如下： 1void free(void* ptr); 参数：ptr - 要释放的内存指针。 示例代码123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstdlib&gt; // 包含 malloc 和 freeint main() &#123; // 分配一个整数的内存 int* p = (int*)malloc(sizeof(int)); if (p == nullptr) &#123; std::cerr &lt;&lt; &quot;Memory allocation failed&quot; &lt;&lt; std::endl; return 1; &#125; *p = 42; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *p &lt;&lt; std::endl; // 释放内存 free(p); return 0;&#125; 注意事项 类型转换：malloc 返回 void*，需要显式转换为所需类型的指针。 初始化：malloc 分配的内存未初始化，内容不确定。 释放对应性：由 malloc 分配的内存必须使用 free 释放，避免使用 delete。 C++ 内存管理C++ 提供了更高层次的内存管理操作符：new 和 delete，它们不仅分配和释放内存，还调用构造函数和析构函数，提供类型安全。 new 操作符用于在堆上分配对象，并调用其构造函数。 单个对象 1Type* ptr = new Type(parameters); 例子： 12345678910111213141516171819#include &lt;iostream&gt;class MyClass &#123;public: MyClass(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Constructor called with value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~MyClass() &#123; std::cout &lt;&lt; &quot;Destructor called for value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; int value;&#125;;int main() &#123; MyClass* obj = new MyClass(10); std::cout &lt;&lt; &quot;Object value: &quot; &lt;&lt; obj-&gt;value &lt;&lt; std::endl; delete obj; // 调用析构函数并释放内存 return 0;&#125; 输出： 123Constructor called with value: 10Object value: 10Destructor called for value: 10 数组 1Type* array = new Type[size]; 例子： 12345678910111213#include &lt;iostream&gt;int main() &#123; int* arr = new int[5]; // 分配5个整数 for (int i = 0; i &lt; 5; ++i) &#123; arr[i] = i * 10; &#125; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; &quot;arr[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; arr[i] &lt;&lt; std::endl; &#125; delete[] arr; // 释放数组内存 return 0;&#125; 输出： 12345arr[0] = 0arr[1] = 10arr[2] = 20arr[3] = 30arr[4] = 40 delete 操作符 用于释放由 new 分配的内存，并调用析构函数。 释放单个对象1delete ptr; 释放数组1delete[] ptr; 区别于 malloc 和 free 类型安全：new 返回正确类型的指针，免去了强制类型转换。 构造/析构：new 和 delete 自动调用构造函数和析构函数。 异常处理：在分配失败时，new 默认抛出 std::bad_alloc 异常，而 malloc 返回 nullptr。 异常安全的 new可以通过 nothrow 参数防止 new 抛出异常，改为返回 nullptr。 1234567891011121314#include &lt;iostream&gt;#include &lt;new&gt; // 包含 std::nothrowint main() &#123; int* p = new(std::nothrow) int; if (p == nullptr) &#123; std::cerr &lt;&lt; &quot;Memory allocation failed&quot; &lt;&lt; std::endl; return 1; &#125; *p = 100; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *p &lt;&lt; std::endl; delete p; return 0;&#125; 总结和对比了解 malloc/free 与 new/delete 的区别，有助于在编写 C++ 程序时正确选择内存管理方法。 特性 malloc/free new/delete 类型安全 需要显式类型转换 自动类型转换，无需显式转换 构造/析构函数 不调用对象的构造/析构函数 调用对象的构造/析构函数 返回值 void*，需要转换为目标类型 返回目标类型指针，类型安全 错误处理 分配失败返回 nullptr 分配失败抛出 std::bad_alloc 异常 多态行为 无 支持多态，通过虚函数正确调用析构函数 内存分配与释放对应性 必须使用 free 释放由 malloc 分配的内存 必须使用 delete 释放由 new 分配的内存 示例对比使用 malloc 和 free 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdlib&gt;class MyClass &#123;public: MyClass(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Constructor called&quot; &lt;&lt; std::endl; &#125; ~MyClass() &#123; std::cout &lt;&lt; &quot;Destructor called&quot; &lt;&lt; std::endl; &#125; int value;&#125;;int main() &#123; // 使用 malloc 分配内存 MyClass* obj = (MyClass*)malloc(sizeof(MyClass)); if (obj == nullptr) &#123; std::cerr &lt;&lt; &quot;malloc failed&quot; &lt;&lt; std::endl; return 1; &#125; // 手动调用构造函数（不推荐） new(obj) MyClass(20); // 通过“定位 new”调用构造函数 std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; obj-&gt;value &lt;&lt; std::endl; // 手动调用析构函数 obj-&gt;~MyClass(); // 释放内存 free(obj); return 0;&#125; 注意：使用 malloc 分配 C++ 对象时，需要手动调用构造函数和析构函数，这非常不便且易出错。因此，推荐使用 new 和 delete。 使用 new 和 delete 123456789101112131415161718#include &lt;iostream&gt;class MyClass &#123;public: MyClass(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Constructor called&quot; &lt;&lt; std::endl; &#125; ~MyClass() &#123; std::cout &lt;&lt; &quot;Destructor called&quot; &lt;&lt; std::endl; &#125; int value;&#125;;int main() &#123; // 使用 new 分配内存并调用构造函数 MyClass* obj = new MyClass(30); std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; obj-&gt;value &lt;&lt; std::endl; // 使用 delete 释放内存并调用析构函数 delete obj; return 0;&#125; 输出： 123Constructor calledValue: 30Destructor called 兼容性 C++ 类型特性：new 和 delete 支持 C++ 的类型特性，包括构造函数、析构函数、多态等。 C 兼容性：在需要兼容 C 代码或通过 C 接口分配内存时，仍可能需要使用 malloc 和 free。 高级内存管理使用 realloc 进行内存重分配realloc 用于调整之前分配的内存块大小。这在动态数组等数据结构中非常有用。 原型 123#include &lt;cstdlib&gt;void* realloc(void* ptr, size_t new_size); 参数 ： ptr：指向之前分配的内存块。 new_size：新的内存大小（以字节为单位）。 返回值：指向重新分配后的内存块的新指针。如果重新分配失败，返回 nullptr，原内存块保持不变。 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt; // 包含 memcpyint main() &#123; // 初始分配 3 个整数 int* arr = (int*)malloc(3 * sizeof(int)); if (arr == nullptr) &#123; std::cerr &lt;&lt; &quot;Initial malloc failed&quot; &lt;&lt; std::endl; return 1; &#125; // 初始化数组 for (int i = 0; i &lt; 3; ++i) &#123; arr[i] = i + 1; &#125; std::cout &lt;&lt; &quot;Initial array: &quot;; for (int i = 0; i &lt; 3; ++i) &#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 重新分配为 5 个整数 int* temp = (int*)realloc(arr, 5 * sizeof(int)); if (temp == nullptr) &#123; std::cerr &lt;&lt; &quot;Realloc failed&quot; &lt;&lt; std::endl; free(arr); // 释放原内存 return 1; &#125; arr = temp; // 初始化新元素 for (int i = 3; i &lt; 5; ++i) &#123; arr[i] = (i + 1) * 10; &#125; std::cout &lt;&lt; &quot;Reallocated array: &quot;; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 释放内存 free(arr); return 0;&#125; 输出： 12Initial array: 1 2 3 Reallocated array: 1 2 3 40 50 动态数组管理使用 malloc 和 realloc 来手动管理动态数组可以实现可变大小的数组，但需要处理内存分配、释放和数据复制。 封装动态数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;class DynamicArray &#123;public: DynamicArray(size_t initial_size = 1) : size(initial_size), data((int*)malloc(size * sizeof(int))) &#123; if (data == nullptr) &#123; throw std::bad_alloc(); &#125; &#125; ~DynamicArray() &#123; free(data); &#125; void resize(size_t new_size) &#123; int* temp = (int*)realloc(data, new_size * sizeof(int)); if (temp == nullptr) &#123; throw std::bad_alloc(); &#125; data = temp; size = new_size; &#125; int&amp; operator[](size_t index) &#123; return data[index]; &#125; size_t getSize() const &#123; return size; &#125;private: size_t size; int* data;&#125;;int main() &#123; try &#123; DynamicArray arr(3); // 初始化 for (size_t i = 0; i &lt; arr.getSize(); ++i) &#123; arr[i] = i + 1; &#125; std::cout &lt;&lt; &quot;Initial array: &quot;; for (size_t i = 0; i &lt; arr.getSize(); ++i) &#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 调整大小 arr.resize(5); arr[3] = 40; arr[4] = 50; std::cout &lt;&lt; &quot;Resized array: &quot;; for (size_t i = 0; i &lt; arr.getSize(); ++i) &#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125; catch (const std::bad_alloc&amp; e) &#123; std::cerr &lt;&lt; &quot;Memory allocation error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; return 0;&#125; 输出： 12Initial array: 1 2 3 Resized array: 1 2 3 40 50 注意：这种方式需要手动管理内存和数组大小，且缺乏类型安全性和自动化。推荐使用 C++ 标准容器如 std::vector 来代替。 实际案例案例一：动态数组实现实现一个简单的动态数组类，支持添加元素、访问元素和自动扩展。 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;stdexcept&gt;class DynamicArray &#123;public: DynamicArray() : capacity(2), size(0), data((int*)malloc(capacity * sizeof(int))) &#123; if (data == nullptr) &#123; throw std::bad_alloc(); &#125; &#125; ~DynamicArray() &#123; free(data); &#125; void add(int value) &#123; if (size == capacity) &#123; resize(capacity * 2); &#125; data[size++] = value; &#125; int get(size_t index) const &#123; if (index &gt;= size) &#123; throw std::out_of_range(&quot;Index out of range&quot;); &#125; return data[index]; &#125; size_t getSize() const &#123; return size; &#125;private: void resize(size_t new_capacity) &#123; int* temp = (int*)realloc(data, new_capacity * sizeof(int)); if (temp == nullptr) &#123; throw std::bad_alloc(); &#125; data = temp; capacity = new_capacity; &#125; size_t capacity; size_t size; int* data;&#125;;int main() &#123; try &#123; DynamicArray arr; arr.add(10); arr.add(20); arr.add(30); // 触发扩展 std::cout &lt;&lt; &quot;Dynamic Array Contents:&quot; &lt;&lt; std::endl; for (size_t i = 0; i &lt; arr.getSize(); ++i) &#123; std::cout &lt;&lt; arr.get(i) &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125; catch (const std::bad_alloc&amp; e) &#123; std::cerr &lt;&lt; &quot;Memory allocation error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; catch (const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;Array access error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; return 0;&#125; 输出： 12Dynamic Array Contents:10 20 30 案例二：自定义内存管理器实现一个简单的内存池，用于高效分配和释放固定大小的对象。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;class MemoryPool &#123;public: MemoryPool(size_t objectSize, size_t poolSize) : objSize(objectSize), totalSize(poolSize), pool((char*)malloc(objectSize * poolSize)) &#123; if (pool == nullptr) &#123; throw std::bad_alloc(); &#125; // 初始化 free list for (size_t i = 0; i &lt; poolSize; ++i) &#123; freeList.push(pool + i * objectSize); &#125; &#125; ~MemoryPool() &#123; free(pool); &#125; void* allocate() &#123; if (freeList.empty()) &#123; throw std::bad_alloc(); &#125; void* ptr = freeList.top(); freeList.pop(); return ptr; &#125; void deallocate(void* ptr) &#123; freeList.push((char*)ptr); &#125;private: size_t objSize; size_t totalSize; char* pool; std::stack&lt;void*&gt; freeList;&#125;;class MyClass &#123;public: MyClass(int val) : value(val) &#123; std::cout &lt;&lt; &quot;MyClass constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~MyClass() &#123; std::cout &lt;&lt; &quot;MyClass destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; int value;&#125;;int main() &#123; try &#123; // 创建一个能容纳 3 个 MyClass 对象的内存池 MemoryPool pool(sizeof(MyClass), 3); // 分配对象内存 void* mem1 = pool.allocate(); void* mem2 = pool.allocate(); // 使用“定位 new”构造对象 MyClass* obj1 = new(mem1) MyClass(100); MyClass* obj2 = new(mem2) MyClass(200); // 使用对象 std::cout &lt;&lt; &quot;obj1 value: &quot; &lt;&lt; obj1-&gt;value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;obj2 value: &quot; &lt;&lt; obj2-&gt;value &lt;&lt; std::endl; // 显式调用析构函数 obj1-&gt;~MyClass(); obj2-&gt;~MyClass(); // 释放内存 pool.deallocate(mem1); pool.deallocate(mem2); &#125; catch (const std::bad_alloc&amp; e) &#123; std::cerr &lt;&lt; &quot;Memory pool allocation error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; return 0;&#125; 输出： 123456MyClass constructor: 100MyClass constructor: 200obj1 value: 100obj2 value: 200MyClass destructor: 100MyClass destructor: 200 说明： MemoryPool 管理固定大小的内存块，避免频繁调用 malloc 和 free。 使用“定位 new”在预分配的内存上构造对象。 需要手动调用析构函数和将内存返回给内存池。 注意：这种方法适用于大量小对象的高效管理，但需要确保正确使用构造和析构函数。 避免内存泄漏内存泄漏是指程序分配的内存未被释放，导致内存被浪费，甚至耗尽。避免内存泄漏的策略包括： **确保每个 new 有对应的 delete**。 使用 RAII 和智能指针：自动管理资源，避免手动管理内存。 工具辅助：使用工具如 Valgrind 检测内存泄漏。 示例：内存泄漏 1234567#include &lt;iostream&gt;int main() &#123; int* p = new int(10); // 忘记 delete p; 导致内存泄漏 return 0;&#125; 解决方法： 12345678#include &lt;iostream&gt;int main() &#123; int* p = new int(10); // 正确释放内存 delete p; return 0;&#125; RAII（资源获取即初始化）RAII 是 C++ 中的一种编程惯用法，通过对象的生命周期管理资源，确保资源在对象构造时获取，析构时释放，避免泄漏。 示例：RAII 实现类似于shared_ptr智能指针 std::shared_ptr 是 C++ 标准库中功能强大的智能指针之一，提供了共享所有权的能力，使得多个指针可以共同管理同一个动态分配的对象。通过引用计数机制，shared_ptr 确保了对象在最后一个指针被销毁时自动释放，极大地简化了内存管理，防止了内存泄漏和悬挂指针问题。 SimpleSharedPtr 的基本概念SimpleSharedPtr 是一个简化版的 shared_ptr 实现，旨在帮助理解其核心机制。其基本功能包括： 共享所有权：多个 SimpleSharedPtr 实例可以指向同一个对象，共享对该对象的所有权。 自动管理生命周期：当最后一个 SimpleSharedPtr 被销毁或指向其他对象时，管理的对象被自动释放。 引用计数：内部维护一个引用计数，记录有多少个 SimpleSharedPtr 实例指向同一个对象。 引用计数控制块的设计为了实现引用计数机制，SimpleSharedPtr 需要一个控制块（Control Block），它包含： 引用计数（ref_count）：记录有多少个 SimpleSharedPtr 指向同一个对象。 指向对象的指针（ptr）：指向实际管理的对象。 控制块通常与被管理对象一起被分配，但为了简化实现，本示例将它们独立管理。 123456struct ControlBlock &#123; int ref_count; // 引用计数 // 可以扩展为包含自定义删除器等 ControlBlock() : ref_count(1) &#123;&#125;&#125;; SimpleSharedPtr 的实现类结构 SimpleSharedPtr 是一个模板类，模板参数 T 表示它所管理的对象类型。 123456789template &lt;typename T&gt;class SimpleSharedPtr &#123;private: T* ptr; // 指向管理的对象 ControlBlock* control; // 指向控制块public: // 构造函数、析构函数、拷贝与移动操作、操作符重载等&#125;; 构造函数与析构函数 默认构造函数：初始化指针和控制块为空。 参数化构造函数：接受一个裸指针，初始化控制块，并引用计数为1。 析构函数：减少引用计数，若引用计数为0，则释放对象和控制块。 12345678910111213141516// 默认构造函数SimpleSharedPtr() : ptr(nullptr), control(nullptr) &#123;&#125;// 参数化构造函数explicit SimpleSharedPtr(T* p) : ptr(p) &#123; if (p) &#123; control = new ControlBlock(); &#125; else &#123; control = nullptr; &#125;&#125;// 析构函数~SimpleSharedPtr() &#123; release();&#125; **辅助函数 release**： 123456789101112private:void release() &#123; if (control) &#123; control-&gt;ref_count--; if (control-&gt;ref_count == 0) &#123; delete ptr; delete control; &#125; &#125; ptr = nullptr; control = nullptr;&#125; 拷贝构造与拷贝赋值拷贝构造函数和拷贝赋值操作符允许多个 SimpleSharedPtr 实例共享同一个对象，共享相同的控制块。 12345678910111213141516171819202122// 拷贝构造函数SimpleSharedPtr(const SimpleSharedPtr&amp; other) : ptr(other.ptr), control(other.control) &#123; if (control) &#123; control-&gt;ref_count++; &#125;&#125;// 拷贝赋值操作符SimpleSharedPtr&amp; operator=(const SimpleSharedPtr&amp; other) &#123; if (this != &amp;other) &#123; // 释放当前资源 release(); // 复制新的资源和控制块 ptr = other.ptr; control = other.control; if (control) &#123; control-&gt;ref_count++; &#125; &#125; return *this;&#125; 移动构造与移动赋值移动语义允许资源所有权从一个 SimpleSharedPtr 转移到另一个，而不增加引用计数。 12345678910111213141516171819202122// 移动构造函数SimpleSharedPtr(SimpleSharedPtr&amp;&amp; other) noexcept : ptr(other.ptr), control(other.control) &#123; other.ptr = nullptr; other.control = nullptr;&#125;// 移动赋值操作符SimpleSharedPtr&amp; operator=(SimpleSharedPtr&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; // 释放当前资源 release(); // 接管 `other` 的资源 ptr = other.ptr; control = other.control; // 置 `other` 为空 other.ptr = nullptr; other.control = nullptr; &#125; return *this;&#125; 操作符重载重载 * 和 -&gt; 操作符，以便像使用原生指针一样使用 SimpleSharedPtr。 123456789// 解引用操作符T&amp; operator*() const &#123; return *ptr;&#125;// 箭头操作符T* operator-&gt;() const &#123; return ptr;&#125; 其他成员函数 **use_count**：返回当前引用计数。 **get**：返回裸指针。 **reset**：重置指针，指向新对象或 nullptr。 1234567891011121314151617181920212223// 获取引用计数int use_count() const &#123; return control ? control-&gt;ref_count : 0;&#125;// 获取裸指针T* get() const &#123; return ptr;&#125;// 重置指针void reset(T* p = nullptr) &#123; // 释放当前资源 release(); // 指向新资源 ptr = p; if (p) &#123; control = new ControlBlock(); &#125; else &#123; control = nullptr; &#125;&#125; 完整代码示例以下是 SimpleSharedPtr 的完整实现及其使用示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;iostream&gt;// 控制块结构struct ControlBlock &#123; int ref_count; ControlBlock() : ref_count(1) &#123;&#125;&#125;;// 简化版的 shared_ptr 实现template &lt;typename T&gt;class SimpleSharedPtr &#123;private: T* ptr; // 指向管理的对象 ControlBlock* control; // 指向控制块 // 释放当前资源 void release() &#123; if (control) &#123; control-&gt;ref_count--; std::cout &lt;&lt; &quot;Decremented ref_count to &quot; &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl; if (control-&gt;ref_count == 0) &#123; delete ptr; delete control; std::cout &lt;&lt; &quot;Resource and ControlBlock destroyed.&quot; &lt;&lt; std::endl; &#125; &#125; ptr = nullptr; control = nullptr; &#125;public: // 默认构造函数 SimpleSharedPtr() : ptr(nullptr), control(nullptr) &#123; std::cout &lt;&lt; &quot;Default constructed SimpleSharedPtr (nullptr).&quot; &lt;&lt; std::endl; &#125; // 参数化构造函数 explicit SimpleSharedPtr(T* p) : ptr(p) &#123; if (p) &#123; control = new ControlBlock(); std::cout &lt;&lt; &quot;Constructed SimpleSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl; &#125; else &#123; control = nullptr; &#125; &#125; // 拷贝构造函数 SimpleSharedPtr(const SimpleSharedPtr&amp; other) : ptr(other.ptr), control(other.control) &#123; if (control) &#123; control-&gt;ref_count++; std::cout &lt;&lt; &quot;Copied SimpleSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl; &#125; &#125; // 拷贝赋值操作符 SimpleSharedPtr&amp; operator=(const SimpleSharedPtr&amp; other) &#123; if (this != &amp;other) &#123; release(); ptr = other.ptr; control = other.control; if (control) &#123; control-&gt;ref_count++; std::cout &lt;&lt; &quot;Assigned SimpleSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl; &#125; &#125; return *this; &#125; // 移动构造函数 SimpleSharedPtr(SimpleSharedPtr&amp;&amp; other) noexcept : ptr(other.ptr), control(other.control) &#123; other.ptr = nullptr; other.control = nullptr; std::cout &lt;&lt; &quot;Moved SimpleSharedPtr.&quot; &lt;&lt; std::endl; &#125; // 移动赋值操作符 SimpleSharedPtr&amp; operator=(SimpleSharedPtr&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; release(); ptr = other.ptr; control = other.control; other.ptr = nullptr; other.control = nullptr; std::cout &lt;&lt; &quot;Move-assigned SimpleSharedPtr.&quot; &lt;&lt; std::endl; &#125; return *this; &#125; // 析构函数 ~SimpleSharedPtr() &#123; release(); &#125; // 解引用操作符 T&amp; operator*() const &#123; return *ptr; &#125; // 箭头操作符 T* operator-&gt;() const &#123; return ptr; &#125; // 获取引用计数 int use_count() const &#123; return control ? control-&gt;ref_count : 0; &#125; // 获取裸指针 T* get() const &#123; return ptr; &#125; // 重置指针 void reset(T* p = nullptr) &#123; release(); ptr = p; if (p) &#123; control = new ControlBlock(); std::cout &lt;&lt; &quot;Reset SimpleSharedPtr, ref_count = &quot; &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl; &#125; else &#123; control = nullptr; &#125; &#125;&#125;;// 测试类class Test &#123;public: Test(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Test Constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;Test Destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void show() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;private: int value;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Creating default constructed shared_ptr...&quot; &lt;&lt; std::endl; SimpleSharedPtr&lt;Test&gt; ptr1; // 默认构造 std::cout &lt;&lt; &quot;ptr1 use_count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;\\nCreating shared_ptr with resource...&quot; &lt;&lt; std::endl; SimpleSharedPtr&lt;Test&gt; ptr2(new Test(100)); // 非默认构造 std::cout &lt;&lt; &quot;ptr2 use_count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; ptr2-&gt;show(); std::cout &lt;&lt; &quot;\\nCopying ptr2 to ptr3...&quot; &lt;&lt; std::endl; SimpleSharedPtr&lt;Test&gt; ptr3 = ptr2; // 拷贝构造 std::cout &lt;&lt; &quot;ptr2 use_count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ptr3 use_count: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; std::endl; ptr3-&gt;show(); std::cout &lt;&lt; &quot;\\nAssigning ptr3 to ptr1...&quot; &lt;&lt; std::endl; ptr1 = ptr3; // 拷贝赋值 std::cout &lt;&lt; &quot;ptr1 use_count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ptr2 use_count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ptr3 use_count: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;\\nResetting ptr2...&quot; &lt;&lt; std::endl; ptr2.reset(new Test(200)); // 重新指向新的对象 std::cout &lt;&lt; &quot;ptr2 use_count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; ptr2-&gt;show(); std::cout &lt;&lt; &quot;ptr1 use_count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ptr3 use_count: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;\\nExiting scope...&quot; &lt;&lt; std::endl; &#125; // ptr2, ptr1, ptr3 离开作用域 std::cout &lt;&lt; &quot;End of main.&quot; &lt;&lt; std::endl; return 0;&#125; SimpleUniquePtr 的实现std::unique_ptr 是一种独占所有权的智能指针，确保在任意时刻，只有一个 unique_ptr 实例指向特定资源。它不支持拷贝操作，只支持移动操作。 基本结构首先，定义一个模板类 SimpleUniquePtr，它持有一个指向资源的裸指针： 12345678910template &lt;typename T&gt;class SimpleUniquePtr &#123;private: T* ptr; // 指向管理对象的裸指针public: // 构造函数、析构函数、删除拷贝构造与拷贝赋值 // 实现移动构造与移动赋值 // 重载操作符&#125;; 构造函数与析构函数 默认构造函数：初始化指针为空。 参数化构造函数：接受一个指向资源的裸指针。 析构函数：当 SimpleUniquePtr 被销毁时，释放所管理的资源。 12345678910// 默认构造函数SimpleUniquePtr() : ptr(nullptr) &#123;&#125;// 参数化构造函数explicit SimpleUniquePtr(T* p) : ptr(p) &#123;&#125;// 析构函数~SimpleUniquePtr() &#123; delete ptr;&#125; 删除拷贝构造与拷贝赋值为了确保唯一性，禁止拷贝构造和拷贝赋值： 12345// 删除拷贝构造SimpleUniquePtr(const SimpleUniquePtr&amp;) = delete;// 删除拷贝赋值SimpleUniquePtr&amp; operator=(const SimpleUniquePtr&amp;) = delete; 移动语义支持移动构造和移动赋值，以转移所有权： 1234567891011121314// 移动构造SimpleUniquePtr(SimpleUniquePtr&amp;&amp; other) noexcept : ptr(other.ptr) &#123; other.ptr = nullptr;&#125;// 移动赋值SimpleUniquePtr&amp; operator=(SimpleUniquePtr&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; delete ptr; // 释放当前资源 ptr = other.ptr; // 转移所有权 other.ptr = nullptr; &#125; return *this;&#125; 操作符重载重载 * 和 -&gt; 操作符，以模拟指针的行为： 123456789101112131415161718192021222324252627// 解引用操作符T&amp; operator*() const &#123; return *ptr;&#125;// 箭头操作符T* operator-&gt;() const &#123; return ptr;&#125;// 获取裸指针T* get() const &#123; return ptr;&#125;// 释放所有权，返回裸指针并设为 nullptrT* release() &#123; T* temp = ptr; ptr = nullptr; return temp;&#125;// 重新设定指针void reset(T* p = nullptr) &#123; delete ptr; ptr = p;&#125; 示例代码以下示例展示了如何使用 SimpleUniquePtr： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;// SimpleUniquePtr 实现template &lt;typename T&gt;class SimpleUniquePtr &#123;private: T* ptr;public: // 默认构造函数 SimpleUniquePtr() : ptr(nullptr) &#123;&#125; // 参数化构造函数 explicit SimpleUniquePtr(T* p) : ptr(p) &#123;&#125; // 析构函数 ~SimpleUniquePtr() &#123; delete ptr; &#125; // 删除拷贝构造和拷贝赋值 SimpleUniquePtr(const SimpleUniquePtr&amp;) = delete; SimpleUniquePtr&amp; operator=(const SimpleUniquePtr&amp;) = delete; // 移动构造 SimpleUniquePtr(SimpleUniquePtr&amp;&amp; other) noexcept : ptr(other.ptr) &#123; other.ptr = nullptr; &#125; // 移动赋值 SimpleUniquePtr&amp; operator=(SimpleUniquePtr&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; delete ptr; ptr = other.ptr; other.ptr = nullptr; &#125; return *this; &#125; // 解引用操作符 T&amp; operator*() const &#123; return *ptr; &#125; // 箭头操作符 T* operator-&gt;() const &#123; return ptr; &#125; // 获取裸指针 T* get() const &#123; return ptr; &#125; // 释放所有权 T* release() &#123; T* temp = ptr; ptr = nullptr; return temp; &#125; // 重新设定指针 void reset(T* p = nullptr) &#123; delete ptr; ptr = p; &#125;&#125;;// 测试类class Test &#123;public: Test(int val) : value(val) &#123; std::cout &lt;&lt; &quot;Test Constructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;Test Destructor: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void show() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;private: int value;&#125;;int main() &#123; // 创建一个 SimpleUniquePtr SimpleUniquePtr&lt;Test&gt; ptr1(new Test(1)); ptr1-&gt;show(); (*ptr1).show(); // 移动所有权到 ptr2 SimpleUniquePtr&lt;Test&gt; ptr2 = std::move(ptr1); if (ptr1.get() == nullptr) &#123; std::cout &lt;&lt; &quot;ptr1 is now nullptr after move.&quot; &lt;&lt; std::endl; &#125; ptr2-&gt;show(); // 释放所有权 Test* rawPtr = ptr2.release(); if (ptr2.get() == nullptr) &#123; std::cout &lt;&lt; &quot;ptr2 is now nullptr after release.&quot; &lt;&lt; std::endl; &#125; rawPtr-&gt;show(); delete rawPtr; // 手动删除 // 使用 reset ptr2.reset(new Test(2)); ptr2-&gt;show(); ptr2.reset(); // 自动删除 if (ptr2.get() == nullptr) &#123; std::cout &lt;&lt; &quot;ptr2 is now nullptr after reset.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 123456789101112Test Constructor: 1Value: 1Value: 1ptr1 is now nullptr after move.Value: 1ptr2 is now nullptr after release.Value: 1Test Destructor: 1Test Constructor: 2Value: 2Test Destructor: 2ptr2 is now nullptr after reset. 解释： 创建 ptr1 并指向一个 Test 对象。 使用 std::move 将所有权转移到 ptr2，ptr1 变为 nullptr。 使用 release() 释放 ptr2 的所有权，获取裸指针后需要手动 delete。 使用 reset() 重新指向一个新的 Test 对象，自动释放之前的资源。 总结本文详细介绍了 C++ 中的内存管理方法，包括基础的 malloc 和 free，以及更现代的 C++ 风格的 new 和 delete。通过对比两者的特点，强调了 new 和 delete 在 C++ 中的优势，如类型安全、自动调用构造和析构函数等。 高级内存管理部分探讨了如何使用 realloc 进行内存重分配，并通过实际案例展示了如何实现动态数组和自定义内存管理器。最后，介绍了最佳实践，强调避免内存泄漏的重要性，以及 RAII 和智能指针对内存管理的帮助。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"聊天项目(31) 单线程文件传输","date":"2024-11-24T10:04:18.000Z","path":"2024/11/24/cpppro31/","text":"设计思路文件传输必须满足以下几个条件： 限制文件大小(不超过4G) 长连接传输(效率高，支持大文件) 客户端和服务器都知道传输进度，以保证支持断点续传(后续实现) 先实现服务器单线程处理版本，在实现多线程处理版本 如遇问题可添加我的微信 也可以去我得哔哩哔哩主页查看项目视频详细讲解 B站主页 https://space.bilibili.com/271469206 客户端客户端还是采用聊天项目客户端封装的TcpClient, 只是修改了发送逻辑 1234567891011121314151617181920212223242526272829//发送数据槽函数void TcpClient::slot_send_msg(quint16 id, QByteArray body)&#123; //如果连接异常则直接返回 if(_socket-&gt;state() != QAbstractSocket::ConnectedState)&#123; emit sig_net_error(QString(&quot;断开连接无法发送&quot;)); return; &#125; //获取body的长度 quint32 bodyLength = body.size(); //创建字节数组 QByteArray data; //绑定字节数组 QDataStream stream(&amp;data, QIODevice::WriteOnly); //设置大端模式 stream.setByteOrder(QDataStream::BigEndian); //写入ID stream &lt;&lt; id; //写入长度 stream &lt;&lt; bodyLength; //写入包体 data.append(body); //发送消息 _socket-&gt;write(data);&#125; 这里着重叙述以下，发送的格式是id + bodyLength + 文件流数据 其中id 为2字节，bodyLength为4字节，之后就是传输的文件流 slot_send_msg是槽函数，和 sig_send_msg信号连接 12//连接 发送数据信号和槽函数connect(this, &amp;TcpClient::sig_send_msg, this, &amp;TcpClient::slot_send_msg); 客户端在发送数据的时候调用 12345void TcpClient::sendMsg(quint16 id,QByteArray data)&#123; //发送信号，统一交给槽函数处理，这么做的好处是多线程安全 emit sig_send_msg(id, data);&#125; 客户端在打开文件对话框后选择文件，接下来，点击发送会将文件切分成固定大小的报文发送 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void MainWindow::on_uploadBtn_clicked()&#123; ui-&gt;uploadBtn-&gt;setEnabled(false); // 打开文件 QFile file(_file_name); if (!file.open(QIODevice::ReadOnly)) &#123; qWarning() &lt;&lt; &quot;Could not open file:&quot; &lt;&lt; file.errorString(); return; &#125; // 保存当前文件指针位置 qint64 originalPos = file.pos(); QCryptographicHash hash(QCryptographicHash::Md5); if (!hash.addData(&amp;file)) &#123; qWarning() &lt;&lt; &quot;Failed to read data from file:&quot; &lt;&lt; _file_name; return ; &#125; _file_md5 = hash.result().toHex(); // 返回十六进制字符串 // 读取文件内容并发送 QByteArray buffer; int seq = 0; QFileInfo fileInfo(_file_name); // 创建 QFileInfo 对象 QString fileName = fileInfo.fileName(); // 获取文件名 qDebug() &lt;&lt; &quot;文件名是：&quot; &lt;&lt; fileName; // 输出文件名 int total_size = fileInfo.size(); int last_seq = 0; if(total_size % MAX_FILE_LEN)&#123; last_seq = (total_size/MAX_FILE_LEN)+1; &#125;else&#123; last_seq = total_size/MAX_FILE_LEN; &#125; // 恢复文件指针到原来的位置 file.seek(originalPos); while (!file.atEnd()) &#123; //每次读取2048字节发送 buffer = file.read(MAX_FILE_LEN); QJsonObject jsonObj; // 将文件内容转换为 Base64 编码（可选） QString base64Data = buffer.toBase64(); //qDebug() &lt;&lt; &quot;send data is &quot; &lt;&lt; base64Data; ++seq; jsonObj[&quot;md5&quot;] = _file_md5; jsonObj[&quot;name&quot;] = fileName; jsonObj[&quot;seq&quot;] = seq; jsonObj[&quot;trans_size&quot;] = buffer.size() + (seq-1)*MAX_FILE_LEN; jsonObj[&quot;total_size&quot;] = total_size; if(buffer.size() &lt; MAX_FILE_LEN)&#123; jsonObj[&quot;last&quot;] = 1; &#125;else&#123; jsonObj[&quot;last&quot;] = 0; &#125; jsonObj[&quot;data&quot;]= base64Data; jsonObj[&quot;last_seq&quot;] = last_seq; QJsonDocument doc(jsonObj); auto send_data = doc.toJson(); TcpClient::Inst().sendMsg(ID_UPLOAD_FILE_REQ, send_data); //startDelay(500); &#125; //关闭文件 file.close();&#125; 发送时数据字段分别为： 文件md5 : 以后用来做断点续传校验 name : 文件名 seq: 报文序列号，类似于TCP序列号，自己定义的，服务器根据这个序列号组合数据写入文件。 trans_size: 当前已经传输的大小 total_size： 传输文件的总大小。 客户端需要接受服务器返回的消息更新进度条 123456789101112//接受服务器发送的信息void TcpClient::slot_ready_read()&#123; //读取所有数据 QByteArray data = _socket-&gt;readAll(); //将数据缓存起来 _buffer.append(data); //处理收到的数据 processData();&#125; 处理消息更新进度条 123456789101112131415161718192021222324252627282930313233343536373839404142void TcpClient::processData()&#123; while(_buffer.size() &gt;= TCP_HEAD_LEN)&#123; //先取出八字节头部 auto head_byte = _buffer.left(TCP_HEAD_LEN); QDataStream stream(head_byte); //设置为大端模式 stream.setByteOrder(QDataStream::BigEndian); //读取ID quint16 msg_id; stream &gt;&gt; msg_id; //读取长度 quint32 body_length; stream &gt;&gt; body_length; if(_buffer.size() &gt;= TCP_HEAD_LEN+body_length)&#123; //完整的消息体已经接受 QByteArray body = _buffer.mid(TCP_HEAD_LEN,body_length); //去掉完整的消息包 _buffer = _buffer.mid(TCP_HEAD_LEN+body_length); // 解析服务器发过来的消息 QJsonDocument jsonDoc = QJsonDocument::fromJson(body); if(jsonDoc.isNull())&#123; qDebug() &lt;&lt; &quot;Failed to create JSON doc.&quot;; this-&gt;_socket-&gt;close(); return; &#125; if(!jsonDoc.isObject())&#123; qDebug() &lt;&lt; &quot;JSON is not an object.&quot;; this-&gt;_socket-&gt;close(); return; &#125; //qDebug() &lt;&lt; &quot;receive data is &quot; &lt;&lt; body; // 获取 JSON 对象 QJsonObject jsonObject = jsonDoc.object(); emit sig_logic_process(msg_id, jsonObject); &#125;else&#123; //消息未完全接受，所以中断 break; &#125; &#125;&#125; 单线程逻辑服务器我们先讲解单线程处理收包逻辑的服务器，以后再给大家将多线程的。 服务器要配合客户端，对报文头部大小做修改 12345678910//头部总长度#define HEAD_TOTAL_LEN 6//头部id长度#define HEAD_ID_LEN 2//头部数据长度#define HEAD_DATA_LEN 4// 接受队列最大个数#define MAX_RECVQUE 2000000// 发送队列最大个数#define MAX_SENDQUE 2000000 其余逻辑和我们在网络编程中讲的IocontextPool模型服务器一样 服务器收到报文头后调用LogicSystem来处理 12345678910111213141516171819202122232425262728293031323334void CSession::AsyncReadBody(int total_len)&#123; auto self = shared_from_this(); asyncReadFull(total_len, [self, this, total_len](const boost::system::error_code&amp; ec, std::size_t bytes_transfered) &#123; try &#123; if (ec) &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; ec.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_session_id); return; &#125; if (bytes_transfered &lt; total_len) &#123; std::cout &lt;&lt; &quot;read length not match, read [&quot; &lt;&lt; bytes_transfered &lt;&lt; &quot;] , total [&quot; &lt;&lt; total_len&lt;&lt;&quot;]&quot; &lt;&lt; endl; Close(); _server-&gt;ClearSession(_session_id); return; &#125; memcpy(_recv_msg_node-&gt;_data , _data , bytes_transfered); _recv_msg_node-&gt;_cur_len += bytes_transfered; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //此处将消息投递到逻辑队列中 LogicSystem::GetInstance()-&gt;PostMsgToQue(make_shared&lt;LogicNode&gt;(shared_from_this(), _recv_msg_node)); //继续监听头部接受事件 AsyncReadHead(HEAD_TOTAL_LEN); &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception code is &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; &#125;);&#125; 我们知道LogicSystem会将消息投递到队列里，然后单线程处理, 服务器LogicSystem注册上传逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void LogicSystem::RegisterCallBacks() &#123; _fun_callbacks[ID_TEST_MSG_REQ] = [this](shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto data = root[&quot;data&quot;].asString(); std::cout &lt;&lt; &quot;recv test data is &quot; &lt;&lt; data &lt;&lt; std::endl; Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_TEST_MSG_RSP); &#125;); rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;data&quot;] = data; &#125;; _fun_callbacks[ID_UPLOAD_FILE_REQ] = [this](shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto data = root[&quot;data&quot;].asString(); //std::cout &lt;&lt; &quot;recv file data is &quot; &lt;&lt; data &lt;&lt; std::endl; Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP); &#125;); // 解码 std::string decoded = base64_decode(data); auto seq = root[&quot;seq&quot;].asInt(); auto name = root[&quot;name&quot;].asString(); auto total_size = root[&quot;total_size&quot;].asInt(); auto trans_size = root[&quot;trans_size&quot;].asInt(); auto file_path = ConfigMgr::Inst().GetFileOutPath(); auto file_path_str = (file_path / name).string(); std::cout &lt;&lt; &quot;file_path_str is &quot; &lt;&lt; file_path_str &lt;&lt; std::endl; std::ofstream outfile; //第一个包 if (seq == 1) &#123; // 打开文件，如果存在则清空，不存在则创建 outfile.open(file_path_str, std::ios::binary | std::ios::trunc); &#125; else &#123; // 保存为文件 outfile.open(file_path_str, std::ios::binary | std::ios::app); &#125; if (!outfile) &#123; std::cerr &lt;&lt; &quot;无法打开文件进行写入。&quot; &lt;&lt; std::endl; return 1; &#125; outfile.write(decoded.data(), decoded.size()); if (!outfile) &#123; std::cerr &lt;&lt; &quot;写入文件失败。&quot; &lt;&lt; std::endl; return 1; &#125; outfile.close(); std::cout &lt;&lt; &quot;文件已成功保存为: &quot; &lt;&lt; name &lt;&lt; std::endl; rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;total_size&quot;] = total_size; rtvalue[&quot;seq&quot;] = seq; rtvalue[&quot;name&quot;] = name; rtvalue[&quot;trans_size&quot;] = trans_size; &#125;;&#125; 收到上传消息后写入文件。 多线程逻辑服务器多线程逻辑服务器主要是为了缓解单线程接受数据造成的瓶颈，因为单线程接收数据，就会影响其他线程接收数据，所以考虑引入线程池处理收到的数据。 在多线程编程中我们讲过划分多线程设计的几种思路： 按照任务划分，将不同的任务投递给不同的线程 按照线程数轮询处理 按照递归的方式划分 很明显我们不是做二分查找之类的算法处理，所以不会采用第三种。 现在考虑第二种，如果客户端发送一个很大的文件，客户端将文件切分为几个小份发送，服务器通过iocontext池接受数据, 将接受的数据投递到线程池。 我们知道线程池处理任务是不分先后顺序的，只要投递到队列中的都会被无序取出处理。 会造成数据包处理的乱序，当然可以最后交给一个线程去组合，统一写入文件，这么做的一个弊端就是如果文件很大，那就要等待完全重组完成才能组合为一个统一的包，如果文件很大，这个时间就会很长，当然也可以暂时缓存这些数据，每次收到后排序组合，比较麻烦。 所以这里推荐按照任务划分。 按照任务划分就是按照不同的客户端做区分，一个客户端传输的数据按照文件名字的hash值划分给不同的线程单独处理，也就是一个线程专门处理对应的hash值的任务，这样既能保证有序，又能保证其他线程可以处理其他任务，也有概率会命中hash同样的值投递给一个队列，但也扩充了并发能力。 因为我们之前的逻辑处理也是单线程，所以考虑在逻辑层这里做一下解耦合，因为这个服务只是用来处理数据接受，不涉及多个连接互相访问。所以可以讲logic线程扩充为多个，按照sessionid将不同的逻辑分配给不同的线程处理。 多线程处理逻辑将LogicSystem中添加多个LogicWorker用来处理逻辑 1234567891011typedef function&lt;void(shared_ptr&lt;CSession&gt;, const short &amp;msg_id, const string &amp;msg_data)&gt; FunCallBack;class LogicSystem:public Singleton&lt;LogicSystem&gt;&#123; friend class Singleton&lt;LogicSystem&gt;;public: ~LogicSystem(); void PostMsgToQue(shared_ptr &lt; LogicNode&gt; msg, int index);private: LogicSystem(); std::vector&lt;std::shared_ptr&lt;LogicWorker&gt; &gt; _workers;&#125;; 实现投递逻辑 12345678910111213LogicSystem::LogicSystem()&#123; for (int i = 0; i &lt; LOGIC_WORKER_COUNT; i++) &#123; _workers.push_back(std::make_shared&lt;LogicWorker&gt;()); &#125;&#125;LogicSystem::~LogicSystem()&#123;&#125;void LogicSystem::PostMsgToQue(shared_ptr &lt; LogicNode&gt; msg, int index) &#123; _workers[index]-&gt;PostTask(msg);&#125; 每一个LogicWorker都包含一个线程，这样LogicWorker可以在独立的线程里处理任务 12345678910111213141516class LogicWorker&#123;public: LogicWorker(); ~LogicWorker(); void PostTask(std::shared_ptr&lt;LogicNode&gt; task); void RegisterCallBacks();private: void task_callback(std::shared_ptr&lt;LogicNode&gt;); std::thread _work_thread; std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _task_que; std::atomic&lt;bool&gt; _b_stop; std::mutex _mtx; std::condition_variable _cv; std::unordered_map&lt;short, FunCallBack&gt; _fun_callbacks;&#125;; LogicWorker启动一个线程处理任务 1234567891011121314151617181920212223242526272829303132LogicWorker::LogicWorker():_b_stop(false)&#123; RegisterCallBacks(); _work_thread = std::thread([this]() &#123; while (!_b_stop) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _cv.wait(lock, [this]() &#123; if(_b_stop) &#123; return true; &#125; if (_task_que.empty()) &#123; return false; &#125; return true; &#125;); if (_b_stop) &#123; return; &#125; auto task = _task_que.front(); task_callback(task); _task_que.pop(); &#125; &#125;);&#125; 当然要提前注册好任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void LogicWorker::RegisterCallBacks()&#123; _fun_callbacks[ID_TEST_MSG_REQ] = [this](shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto data = root[&quot;data&quot;].asString(); std::cout &lt;&lt; &quot;recv test data is &quot; &lt;&lt; data &lt;&lt; std::endl; Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_TEST_MSG_RSP); &#125;); rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;data&quot;] = data; &#125;; _fun_callbacks[ID_UPLOAD_FILE_REQ] = [this](shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto seq = root[&quot;seq&quot;].asInt(); auto name = root[&quot;name&quot;].asString(); auto total_size = root[&quot;total_size&quot;].asInt(); auto trans_size = root[&quot;trans_size&quot;].asInt(); auto last = root[&quot;last&quot;].asInt(); auto file_data = root[&quot;data&quot;].asString(); Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP); &#125;); // 使用 std::hash 对字符串进行哈希 std::hash&lt;std::string&gt; hash_fn; size_t hash_value = hash_fn(name); // 生成哈希值 int index = hash_value % FILE_WORKER_COUNT; std::cout &lt;&lt; &quot;Hash value: &quot; &lt;&lt; hash_value &lt;&lt; std::endl; FileSystem::GetInstance()-&gt;PostMsgToQue( std::make_shared&lt;FileTask&gt;(session, name, seq, total_size, trans_size, last, file_data), index ); rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;total_size&quot;] = total_size; rtvalue[&quot;seq&quot;] = seq; rtvalue[&quot;name&quot;] = name; rtvalue[&quot;trans_size&quot;] = trans_size; rtvalue[&quot;last&quot;] = last; &#125;;&#125; 处理逻辑 12345678910void LogicWorker::task_callback(std::shared_ptr&lt;LogicNode&gt; task)&#123; cout &lt;&lt; &quot;recv_msg id is &quot; &lt;&lt; task-&gt;_recvnode-&gt;_msg_id &lt;&lt; endl; auto call_back_iter = _fun_callbacks.find(task-&gt;_recvnode-&gt;_msg_id); if (call_back_iter == _fun_callbacks.end()) &#123; return; &#125; call_back_iter-&gt;second(task-&gt;_session, task-&gt;_recvnode-&gt;_msg_id, std::string(task-&gt;_recvnode-&gt;_data, task-&gt;_recvnode-&gt;_cur_len));&#125; 比如对于文件上传，ID_UPLOAD_FILE_REQ就调用对应的回调，在回调函数里我们再次将要处理的任务封装好投递到文件系统 12345FileSystem::GetInstance()-&gt;PostMsgToQue( std::make_shared&lt;FileTask&gt;(session, name, seq, total_size, trans_size, last, file_data), index ); 文件系统和逻辑系统类似，包含一堆FileWorker 12345678910class FileSystem :public Singleton&lt;FileSystem&gt;&#123; friend class Singleton&lt;FileSystem&gt;;public: ~FileSystem(); void PostMsgToQue(shared_ptr &lt;FileTask&gt; msg, int index);private: FileSystem(); std::vector&lt;std::shared_ptr&lt;FileWorker&gt;&gt; _file_workers;&#125;; 实现投递逻辑 12345678910111213141516FileSystem::~FileSystem()&#123;&#125;void FileSystem::PostMsgToQue(shared_ptr&lt;FileTask&gt; msg, int index)&#123; _file_workers[index]-&gt;PostTask(msg);&#125;FileSystem::FileSystem()&#123; for (int i = 0; i &lt; FILE_WORKER_COUNT; i++) &#123; _file_workers.push_back(std::make_shared&lt;FileWorker&gt;()); &#125;&#125; 定义文件任务 123456789101112131415161718class CSession;struct FileTask &#123; FileTask(std::shared_ptr&lt;CSession&gt; session, std::string name, int seq, int total_size, int trans_size, int last, std::string file_data) :_session(session), _seq(seq),_name(name),_total_size(total_size), _trans_size(trans_size),_last(last),_file_data(file_data) &#123;&#125; ~FileTask()&#123;&#125; std::shared_ptr&lt;CSession&gt; _session; int _seq ; std::string _name ; int _total_size ; int _trans_size ; int _last ; std::string _file_data;&#125;; 实现文件工作者 1234567891011121314class FileWorker&#123;public: FileWorker(); ~FileWorker(); void PostTask(std::shared_ptr&lt;FileTask&gt; task);private: void task_callback(std::shared_ptr&lt;FileTask&gt;); std::thread _work_thread; std::queue&lt;std::shared_ptr&lt;FileTask&gt;&gt; _task_que; std::atomic&lt;bool&gt; _b_stop; std::mutex _mtx; std::condition_variable _cv;&#125;; 构造函数启动线程 12345678910111213141516171819202122232425262728FileWorker::FileWorker():_b_stop(false)&#123; _work_thread = std::thread([this]() &#123; while (!_b_stop) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _cv.wait(lock, [this]() &#123; if (_b_stop) &#123; return true; &#125; if (_task_que.empty()) &#123; return false; &#125; return true; &#125;); if (_b_stop) &#123; break; &#125; auto task = _task_que.front(); _task_que.pop(); task_callback(task); &#125; &#125;);&#125; 析构需等待线程 123456FileWorker::~FileWorker()&#123; _b_stop = true; _cv.notify_one(); _work_thread.join();&#125; 投递任务 123456789void FileWorker::PostTask(std::shared_ptr&lt;FileTask&gt; task)&#123; &#123; std::lock_guard&lt;std::mutex&gt; lock(_mtx); _task_que.push(task); &#125; _cv.notify_one();&#125; 因为线程会触发回调函数保存文件，所以我们实现回调函数 123456789101112131415161718192021222324252627282930313233343536373839void FileWorker::task_callback(std::shared_ptr&lt;FileTask&gt; task)&#123; // 解码 std::string decoded = base64_decode(task-&gt;_file_data); auto file_path = ConfigMgr::Inst().GetFileOutPath(); auto file_path_str = (file_path / task-&gt;_name).string(); auto last = task-&gt;_last; //std::cout &lt;&lt; &quot;file_path_str is &quot; &lt;&lt; file_path_str &lt;&lt; std::endl; std::ofstream outfile; //第一个包 if (task-&gt;_seq == 1) &#123; // 打开文件，如果存在则清空，不存在则创建 outfile.open(file_path_str, std::ios::binary | std::ios::trunc); &#125; else &#123; // 保存为文件 outfile.open(file_path_str, std::ios::binary | std::ios::app); &#125; if (!outfile) &#123; std::cerr &lt;&lt; &quot;无法打开文件进行写入。&quot; &lt;&lt; std::endl; return ; &#125; outfile.write(decoded.data(), decoded.size()); if (!outfile) &#123; std::cerr &lt;&lt; &quot;写入文件失败。&quot; &lt;&lt; std::endl; return ; &#125; outfile.close(); if (last) &#123; std::cout &lt;&lt; &quot;文件已成功保存为: &quot; &lt;&lt; task-&gt;_name &lt;&lt; std::endl; &#125;&#125; 测试效果 源码链接https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"零基础C++(21) 类相关面试题","date":"2024-11-23T01:47:27.000Z","path":"2024/11/23/cppbase21/","text":"详细技术视频请看我的主页 C++教程视频 什么是默认构造默认构造就是不带参数的构造函数，如果我们不实现任何构造函数，系统会为我们生成一个默认的构造函数 比如下面 12345678#include &lt;thread&gt;class JoiningThread &#123;public: int GetIndex() const &#123; return _i; &#125;private: std::thread _t; int _i;&#125;; 所以我们可以直接使用默认构造函数构造一个对象，并且打印成员_i 123//测试默认合成JoiningThread jt;std::cout &lt;&lt; &quot;member _i is &quot; &lt;&lt; jt.GetIndex() &lt;&lt; std::endl; 输出 1member _i is -1284874240 可以看到默认构造函数并不会帮我们初始化类成员变量。 什么是有参构造有参构造就是传递参数的构造函数，可以根据参数构造对象 123456789#include &lt;thread&gt;class JoiningThread &#123;public: JoiningThread(int i) : _i&#123;i&#125; &#123;&#125; int GetIndex() const &#123; return _i; &#125;private: std::thread _t; int _i;&#125;; 我们可以通过如下方式构造 12JoiningThread jt(1);std::cout &lt;&lt; &quot;member _i is &quot; &lt;&lt; jt.GetIndex() &lt;&lt; std::endl; 当我们执行程序，会输出 1member _i is 1 但如果这样构造会产生问题 12JoiningThread jt;std::cout &lt;&lt; &quot;member _i is &quot; &lt;&lt; jt.GetIndex() &lt;&lt; std::endl; 注意 如果我们实现了参数构造而不实现无参构造，系统将不会为我们实现默认构造，导致无法使用默认构造生成对象。 所以稳妥一点，我们基本都会实现无参构造 12345678910#include &lt;thread&gt;class JoiningThread &#123;public: JoiningThread() :_i(0)&#123;&#125; JoiningThread(int i) : _i&#123;i&#125; &#123;&#125; int GetIndex() const &#123; return _i; &#125;private: std::thread _t; int _i;&#125;; 拷贝构造函数是什么回答要点： 定义：拷贝构造函数用于创建一个对象，该对象是通过复制另一个同类型对象来初始化的。 调用时机 ： 使用现有对象初始化新对象。 按值传递对象作为函数参数。 按值返回对象。 默认拷贝构造函数：成员逐个拷贝。 示例： 123456class MyClass &#123;public: MyClass(const MyClass&amp; other) &#123; // 拷贝构造函数 // 复制代码 &#125;&#125;; 是否会默认生成拷贝构造在 C++ 中，如果你没有为一个类显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。这个默认拷贝构造函数会按成员的逐个拷贝（member-wise copy）方式来复制对象的每个成员变量。 默认拷贝构造函数的行为 逐个拷贝：默认拷贝构造函数会逐个拷贝所有的非静态成员变量。 指针成员：如果类中有指针成员，默认拷贝构造函数只会拷贝指针的值（地址），而不会拷贝指针所指向的对象。这可能会导致多个对象指向同一块内存，进而引发问题（如双重释放、内存泄漏等）。 **const 和引用成员**：如果类中有 const 成员或引用成员，编译器不会生成默认的拷贝构造函数，因为这些成员不能被复制。 类中包含不可拷贝对象时，无法合成默认拷贝构造函数 拷贝构造是否必须实现当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。 比如一个类JoiningThread中有成员变量std::thread，std::thread没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。 比如我们这样调用 123JoiningThread jt(1);JoiningThread jt2(jt);std::cout &lt;&lt; &quot;member _i is &quot; &lt;&lt; jt.GetIndex() &lt;&lt; std::endl; 上面代码报错 1error: use of deleted function &#x27;std::thread::thread(const std::thread&amp;)&#x27; 所以我们要显示实现拷贝构造，指定一个拷贝规则 1JoiningThread(const JoiningThread &amp; other): _i(other._i)&#123;&#125; 什么是浅拷贝和深拷贝类在拷贝构造或者拷贝赋值的时候，将被拷贝的类中的成员值拷贝到目的类，如果被拷贝的类中包含指针成员，只是简单的拷贝指针的值。 同样析构也要显示编写，等待线程完成。 除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果 构造顺序和析构顺序类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？ 如果析构的时候是A先析构还是B先析构呢？ 123456789101112131415161718192021class InnerB &#123;public: InnerB() &#123; std::cout &lt;&lt; &quot;InnerB()&quot; &lt;&lt; std::endl; &#125; ~InnerB()&#123; std::cout &lt;&lt; &quot;~InnerB()&quot; &lt;&lt; std::endl; &#125;&#125;;class WrapperC &#123;public: WrapperC()&#123; std::cout &lt;&lt; &quot;WrapperC()&quot; &lt;&lt; std::endl; &#125; ~WrapperC()&#123; std::cout &lt;&lt; &quot;~WrapperC()&quot; &lt;&lt; std::endl; &#125; InnerB _inner;&#125;; 执行结果，先调用B的构造，在调用C的构造。 析构时，先析构C再析构B 1234InnerB()WrapperC()~WrapperC()~InnerB() 类默认构造是否必须实现如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。 系统提供的合成的默认构造函数不会对成员做初始化操作。 比如我们之后要学到的继承 123456789class DerivedA: public BaseA &#123;public: DerivedA(std::string name,std::string num) : BaseA(name), _num(num) &#123; std::cout &lt;&lt; &quot;DerivedA()&quot; &lt;&lt; std::endl; &#125;private: std::string _num;&#125;; 调用 1DerivedA a(&quot;zack&quot;,&quot;1001&quot;); this 指针的特性和用途 指向当前对象： this 指针是一个隐式参数，指向调用成员函数的对象。通过 this，你可以访问当前对象的属性和方法。 区分成员变量和参数： 在构造函数或成员函数中，参数名和成员变量可能同名。使用 1this 可以明确指代成员变量。例如： 12345678class MyClass &#123;private: int value;public: MyClass(int value) &#123; this-&gt;value = value; // 使用 this 指针区分成员变量和参数 &#125;&#125;; 返回当前对象： ```this123456789101112131415161718 可以用于返回当前对象的引用，以支持链式调用。例如：```cppclass MyClass &#123;private: int value;public: MyClass&amp; setValue(int value) &#123; this-&gt;value = value; return *this; // 返回当前对象的引用 &#125;&#125;;MyClass obj;obj.setValue(10).setValue(20); // 链式调用 在 const 成员函数中的使用： 在 const 成员函数中，this 的类型为 const MyClass*，这意味着你不能通过 this 修改成员变量。这有助于确保对象的状态不被改变。 在静态成员函数中的不可用性： 静态成员函数没有 this 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。 示例代码 以下是一个简单的示例，展示了 this 指针的用法： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;class MyClass &#123;private: int value;public: // 构造函数 MyClass(int value) &#123; this-&gt;value = value; // 使用 this 指针区分成员变量和参数 &#125; // 成员函数 MyClass&amp; setValue(int value) &#123; this-&gt;value = value; // 使用 this 指针 return *this; // 返回当前对象的引用 &#125; // 输出值 void printValue() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; this-&gt;value &lt;&lt; std::endl; // 使用 this 指针 &#125;&#125;;int main() &#123; MyClass obj(10); obj.printValue(); // 输出: Value: 10 obj.setValue(20).printValue(); // 链式调用，输出: Value: 20 return 0;&#125; delete和defaultC++11用法： delete可以删除指定的构造函数。 default可以指定某个构造函数为系统默认合成。 12345678910class DefaultClass &#123;public: DefaultClass() = default; ~DefaultClass() = default; DefaultClass(const DefaultClass &amp;) = delete; DefaultClass &amp;operator=(const DefaultClass &amp;) = delete; friend std::ostream&amp; operator &lt;&lt; (std::ostream &amp;out, const DefaultClass &amp;defaultClass);private: int _num ;&#125;; 主函数中调用 12DefaultClass b;std::cout &lt;&lt; b &lt;&lt; std::endl; 输出num是一个随机数 1DefaultClass num is 331 什么是移动构造函数？与拷贝构造函数有何不同？回答要点： 定义：移动构造函数用于通过“移动”资源来初始化对象，而不是复制资源。 语法：使用右值引用作为参数 (MyClass(MyClass&amp;&amp; other)). 优势 ： 性能更高，避免不必要的深拷贝。 适用于临时对象。 区别 ： 拷贝构造函数复制资源，移动构造函数转移资源所有权。 示例： 123456class MyClass &#123;public: MyClass(MyClass&amp;&amp; other) noexcept &#123; // 移动构造函数 // 移动资源 &#125;&#125;; 默认构造函数和用户定义的构造函数有什么区别？回答要点： 默认构造函数 ： 无参数的构造函数。 如果没有用户定义的构造函数，编译器会自动生成一个默认构造函数。 用户定义的构造函数 ： 开发者自定义的构造函数，可以有参数。 一旦定义了任何构造函数，编译器不会再生成默认构造函数，除非显式声明。 示例： 12345678910class MyClass &#123;public: MyClass() &#123; // 默认构造函数 // 初始化代码 &#125; MyClass(int x) &#123; // 有参数的构造函数 // 初始化代码 &#125;&#125;; 什么是初始化列表？为什么在构造函数中使用它？回答要点： 定义：初始化列表是在构造函数的参数列表之后，函数体之前，用于初始化成员变量的语法。 优点 ： 提高性能，特别是对于常量成员或引用成员。 必须用于初始化常量成员、引用成员以及基类。 避免对象先默认构造再赋值，减少不必要的操作。 示例： 12345678class MyClass &#123; int x; const int y;public: MyClass(int a, int b) : x(a), y(b) &#123; // 初始化列表 // 其他初始化代码 &#125;&#125;; 什么是虚析构函数？为什么需要它？回答要点： 定义：在基类中将析构函数声明为virtual，以确保通过基类指针删除派生类对象时，能正确调用派生类的析构函数。 用途 ： 防止内存泄漏。 确保派生类的资源被正确释放。 不使用虚析构函数的风险 ： 仅调用基类析构函数，导致派生类资源未释放。 示例： 如果BaseA的析构不写成虚析构，则主函数开辟子类对象赋值给基类指针，以后delete基类指针的时候会发现没有析构子类 12345678910111213141516171819202122232425262728class BaseA&#123;public: BaseA(std::string name):_name(name)&#123; std::cout &lt;&lt; &quot;BaseA()&quot; &lt;&lt; std::endl; &#125; ~BaseA()&#123; std::cout &lt;&lt; &quot;~BaseA()&quot; &lt;&lt; std::endl; &#125;private: std::string _name;&#125;;class DerivedA: public BaseA &#123;public: DerivedA(std::string name,std::string num) : BaseA(name), _num(num) &#123; std::cout &lt;&lt; &quot;DerivedA()&quot; &lt;&lt; std::endl; &#125; ~DerivedA()&#123; std::cout &lt;&lt; &quot;~DerivedA()&quot; &lt;&lt; std::endl; &#125;private: std::string _num;&#125;; 主函数回收内存 12BaseA* base = new DerivedA(&quot;zack&quot;,&quot;1002&quot;);delete base; 会看到只调用了基类BaseA的析构函数。 当BaseA的析构改为虚析构的时候，才会回收子类DerivedA 12345678910111213class BaseA&#123;public: BaseA(std::string name):_name(name)&#123; std::cout &lt;&lt; &quot;BaseA()&quot; &lt;&lt; std::endl; &#125; virtual ~BaseA()&#123; std::cout &lt;&lt; &quot;~BaseA()&quot; &lt;&lt; std::endl; &#125;private: std::string _name;&#125;; 什么是委托构造函数？它是如何工作的？（C++11引入的特性）回答要点： 定义：一个构造函数可以调用同一类中的另一个构造函数，从而委托初始化任务。 优点 ： 避免代码重复，提升代码可维护性。 语法：使用构造函数初始化列表中的类名和参数。 示例： 12345678class MyClass &#123; int x; int y;public: MyClass() : MyClass(0, 0) &#123; &#125; // 委托构造函数 MyClass(int a, int b) : x(a), y(b) &#123; &#125;&#125;; 什么是析构函数的顺序？回答要点： 成员变量的析构顺序：按照声明的逆序析构。 继承关系的析构顺序：先析构派生类的成员和资源，再析构基类。 全局/静态对象：按照创建的逆序析构。 示例说明： 1234567891011121314class Base &#123;public: ~Base() &#123; cout &lt;&lt; &quot;Base析构\\n&quot;; &#125;&#125;;class Derived : public Base &#123;public: ~Derived() &#123; cout &lt;&lt; &quot;Derived析构\\n&quot;; &#125;&#125;;int main() &#123; Derived obj; // 当obj被销毁时，首先调用Derived的析构函数，然后调用Base的析构函数。&#125; 输出： 12Derived析构Base析构 如何防止对象被复制？回答要点： C++11及以上：使用delete关键字显式删除拷贝构造函数和拷贝赋值运算符。 C++11之前：将拷贝构造函数和拷贝赋值运算符声明为私有且不实现。 示例（C++11及以上）： 123456class NonCopyable &#123;public: NonCopyable() = default; NonCopyable(const NonCopyable&amp;) = delete; // 禁止拷贝构造 NonCopyable&amp; operator=(const NonCopyable&amp;) = delete; // 禁止拷贝赋值&#125;; 构造函数中抛出异常会发生什么？回答要点： 对象未完全构造：如果构造函数中抛出异常，析构函数不会被调用，因为对象尚未完全构造。 资源泄漏风险：如果在构造函数中分配了资源，需使用RAII（资源获取即初始化）类或智能指针来确保资源被正确释放。 异常安全：确保在构造函数抛出异常时，任何已经初始化的成员都会被正确析构。 示例： 12345678910class MyClass &#123; std::vector&lt;int&gt; data;public: MyClass() &#123; data.reserve(100); if (/* some condition */) &#123; throw std::runtime_error(&quot;构造函数异常&quot;); &#125; &#125;&#125;; 解释RAII及其与构造函数、析构函数的关系回答要点： RAII（资源获取即初始化） ： 编程范式，通过对象的生命周期管理资源。 资源在对象构造时获取，在对象析构时释放。 关系 ： 构造函数负责获取资源。 析构函数负责释放资源。 优点 ： 自动管理资源，防止内存泄漏。 异常安全，确保资源在异常发生时被释放。 示例： 1234567891011121314class FileHandler &#123; FILE* file;public: FileHandler(const char* filename) &#123; file = fopen(filename, &quot;r&quot;); if (!file) throw std::runtime_error(&quot;打开文件失败&quot;); &#125; ~FileHandler() &#123; if (file) fclose(file); &#125; // 禁止拷贝和移动 FileHandler(const FileHandler&amp;) = delete; FileHandler&amp; operator=(const FileHandler&amp;) = delete;&#125;; 解释什么是赋值运算符重载？与拷贝构造函数有何不同？回答要点： 赋值运算符重载：通过重载operator=，定义对象之间的赋值行为。 区别与拷贝构造函数 ： 拷贝构造函数用于初始化新对象。 赋值运算符用于将一个已存在的对象赋值给另一个已存在的对象。 常规实现 ： 检查自赋值。 释放已有资源。 复制资源。 返回*this。 示例： 12345678910class MyClass &#123; int* data;public: MyClass&amp; operator=(const MyClass&amp; other) &#123; // 赋值运算符重载 if (this == &amp;other) return *this; // 自赋值检查 delete data; // 释放已有资源 data = new int(*other.data); // 复制资源 return *this; &#125;&#125;; 解释静态成员变量在构造和析构中的处理回答要点： 静态成员变量 ： 属于类本身，而非任何对象实例。 在程序开始时初始化，在程序结束时析构。 构造顺序 ： 单例模式中，静态成员在第一次使用时构造。 析构顺序 ： 按逆序构造顺序析构，确保依赖关系被正确处理。 示例： 12345678class MyClass &#123;public: static MyClass instance; MyClass() &#123; cout &lt;&lt; &quot;构造\\n&quot;; &#125; ~MyClass() &#123; cout &lt;&lt; &quot;析构\\n&quot;; &#125;&#125;;//放在cpp中MyClass MyClass::instance; // 静态成员变量定义 输出： 12构造析构 虚函数原理包含虚函数的类构成参考我得另一篇文章，https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73 虚继承与菱形继承问题1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;// 基类 Deviceclass Device &#123;public: std::string brand; Device(const std::string&amp; brand_) : brand(brand_) &#123;&#125; void showBrand() const &#123; std::cout &lt;&lt; &quot;Brand: &quot; &lt;&lt; brand &lt;&lt; std::endl; &#125;&#125;;// 派生类 Laptop，虚继承 Deviceclass Laptop : virtual public Device &#123;public: Laptop(const std::string&amp; brand_) : Device(brand_) &#123;&#125;&#125;;// 派生类 Tablet，虚继承 Deviceclass Tablet : virtual public Device &#123;public: Tablet(const std::string&amp; brand_) : Device(brand_) &#123;&#125;&#125;;// 派生类 Convertibleclass Convertible : public Laptop, public Tablet &#123;public: Convertible(const std::string&amp; brand_) : Device(brand_), Laptop(brand_), Tablet(brand_) &#123;&#125;&#125;;int main() &#123; Convertible c(&quot;TechBrand&quot;); c.showBrand(); return 0;&#125; 输出： 1Brand: TechBrand 解析： 在无虚继承的情况下，Convertible 类将拥有两份 Device 的成员变量，这会导致二义性问题。 通过使用虚继承（virtual public），确保 Convertible 类只有一份 Device 的成员。 在 Convertible 的构造函数中，需要明确调用基类 Device 的构造函数，避免二义性。 在 main 函数中，创建一个 Convertible 对象，并调用 showBrand() 函数，正确显示品牌名称。 注意事项： 菱形继承（多重继承导致的重复基类）可以通过虚继承来解决，确保共享同一份基类成员。 虚继承会增加一定的开销，需根据具体需求权衡使用。 协变返回类型概念定义 在 C++ 中，协变返回类型（Covariant Return Types）是一个与函数重写（Override）相关的概念。当一个派生类重写基类的虚函数时，协变返回类型允许派生类的函数返回一个从基类函数返回类型派生而来的类型。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;// 基类class Base &#123;public: virtual Base* clone() const &#123; std::cout &lt;&lt; &quot;Base cloned.&quot; &lt;&lt; std::endl; return new Base(*this); &#125; virtual ~Base() &#123;&#125;&#125;;// 派生类class Derived : public Base &#123;public: Derived* clone() const override &#123; // 协变返回类型 std::cout &lt;&lt; &quot;Derived cloned.&quot; &lt;&lt; std::endl; return new Derived(*this); &#125;&#125;;int main() &#123; Base* b = new Base(); Base* d = new Derived(); Base* bClone = b-&gt;clone(); // 输出: Base cloned. Base* dClone = d-&gt;clone(); // 输出: Derived cloned. delete b; delete d; delete bClone; delete dClone; return 0;&#125; 输出： 12Base cloned.Derived cloned. 解析： 基类 Base 定义了一个虚函数 clone()，返回 Base* 类型的指针。 派生类 Derived 重写了 clone() 函数，返回类型为 Derived*，这是一种协变返回类型。 在 1main 函数中，通过基类指针调用 1clone() 函数： 对于 Base 对象，调用 Base::clone()。 对于 Derived 对象，由于虚函数机制，调用 Derived::clone()。 协变返回类型允许派生类的重写函数返回更具体的类型，增强类型安全性和代码可读性。 注意事项： 协变返回类型必须满足派生类返回类型是基类返回类型的派生类。 编译器会检查协变返回类型的正确性，确保类型安全。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(20) 继承和多态","date":"2024-11-23T01:44:32.000Z","path":"2024/11/23/cppbase20/","text":"1. 类继承（Class Inheritance）1.1 概述类继承 是面向对象编程（OOP）中的一个核心概念，允许一个类（派生类）从另一个类（基类）继承属性和行为。通过继承，派生类可以重用基类的代码，并根据需要添加新的成员或重写现有成员。 1.2 语法12345678910111213class Base &#123;public: void baseFunction();protected: int protectedMember;private: int privateMember;&#125;;class Derived : public Base &#123; // 公有继承public: void derivedFunction();&#125;; 1.3 代码示例123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;// 基类class Animal &#123;public: void eat() const &#123; std::cout &lt;&lt; &quot;Animal eats.&quot; &lt;&lt; std::endl; &#125;protected: int age;&#125;;// 派生类class Dog : public Animal &#123;public: void bark() const &#123; std::cout &lt;&lt; &quot;Dog barks.&quot; &lt;&lt; std::endl; &#125; void setAge(int a) &#123; age = a; // 访问受保护成员 &#125; int getAge() const &#123; return age; &#125;&#125;;int main() &#123; Dog myDog; myDog.eat(); // 继承自Animal myDog.bark(); // Dog特有 myDog.setAge(5); std::cout &lt;&lt; &quot;Dog&#x27;s age: &quot; &lt;&lt; myDog.getAge() &lt;&lt; std::endl; return 0;&#125; 1.4 执行结果123Animal eats.Dog barks.Dog&#x27;s age: 5 2. 虚函数（Virtual Functions）2.1 概述虚函数 允许派生类重新定义基类中的函数，以实现多态性。在运行时，根据对象的实际类型调用相应的函数版本。 2.2 语法1234class Base &#123;public: virtual void display();&#125;; 2.3 代码示例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class Shape &#123;public: virtual void draw() const &#123; // 虚函数 std::cout &lt;&lt; &quot;Drawing a shape.&quot; &lt;&lt; std::endl; &#125; virtual ~Shape() &#123;&#125; // 虚析构函数&#125;;class Circle : public Shape &#123;public: void draw() const override &#123; // 重写虚函数 std::cout &lt;&lt; &quot;Drawing a circle.&quot; &lt;&lt; std::endl; &#125;&#125;;class Square : public Shape &#123;public: void draw() const override &#123; // 重写虚函数 std::cout &lt;&lt; &quot;Drawing a square.&quot; &lt;&lt; std::endl; &#125;&#125;;void render(const Shape&amp; shape) &#123; shape.draw(); // 动态绑定，根据实际对象类型调用对应的draw()&#125;int main() &#123; Circle c; Square s; Shape genericShape; render(c); // 输出: Drawing a circle. render(s); // 输出: Drawing a square. render(genericShape); // 输出: Drawing a shape. return 0;&#125; 2.4 执行结果123Drawing a circle.Drawing a square.Drawing a shape. 3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）3.1 概述纯虚函数 是在基类中声明但不提供实现的虚函数。包含至少一个纯虚函数的类称为 抽象基类（Abstract Base Class，ABC）。抽象基类不能被实例化，要求派生类必须实现所有纯虚函数才能被实例化。 3.2 语法12345class Base &#123;public: virtual void pureVirtualFunction() = 0; // 纯虚函数 virtual void printm() = 0;&#125;; 3.3 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;// 抽象基类class Vehicle &#123;public: virtual void startEngine() = 0; // 纯虚函数 virtual ~Vehicle() &#123;&#125; // 虚析构函数&#125;;class Car : public Vehicle &#123;public: void startEngine() override &#123; std::cout &lt;&lt; &quot;Car engine started.&quot; &lt;&lt; std::endl; &#125;&#125;;class Motorcycle : public Vehicle &#123;public: void startEngine() override &#123; std::cout &lt;&lt; &quot;Motorcycle engine started.&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // Vehicle v; // 错误: 不能实例化抽象类 Car car; Motorcycle bike; car.startEngine(); // 输出: Car engine started. bike.startEngine(); // 输出: Motorcycle engine started. Vehicle* v1 = &amp;car; Vehicle* v2 = &amp;bike; v1-&gt;startEngine(); // 动态绑定，输出: Car engine started. v2-&gt;startEngine(); // 动态绑定，输出: Motorcycle engine started. return 0;&#125; 3.4 执行结果1234Car engine started.Motorcycle engine started.Car engine started.Motorcycle engine started. 4. 继承后的访问控制（Access Control in Inheritance）4.1 概述继承时的 访问控制 决定了基类成员在派生类中的可访问性。继承方式主要有三种：public、protected 和 private。它们影响继承成员的访问级别。 4.2 语法与影响 公有继承（public inheritance）： 基类的 public 成员在派生类中保持 public。 基类的 protected 成员在派生类中保持 protected。 基类的 private 成员在派生类中不可访问。 保护继承（protected inheritance）： 基类的 public 和 protected 成员在派生类中都变为 protected。 私有继承（private inheritance）： 基类的 public 和 protected 成员在派生类中都变为 private。 4.3 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;class Base &#123;public: int publicMember;protected: int protectedMember;private: int privateMember;&#125;;class PublicDerived : public Base &#123;public: void accessMembers() &#123; publicMember = 1; // 可访问 protectedMember = 2; // 可访问 // privateMember = 3; // 错误：privateMember 在派生类中不可访问 &#125;&#125;;class ProtectedDerived : protected Base &#123;public: void accessMembers() &#123; publicMember = 1; // 转为 protected protectedMember = 2; // 转为 protected // privateMember = 3; // 错误 &#125;&#125;;class PrivateDerived : private Base &#123;public: void accessMembers() &#123; publicMember = 1; // 转为 private protectedMember = 2; // 转为 private // privateMember = 3; // 错误 &#125;&#125;;int main() &#123; PublicDerived pubDer; pubDer.publicMember = 10; // 可访问 // ProtectedDerived protDer; // protDer.publicMember = 10; // 错误：publicMember 在 ProtectedDerived 中为 protected // PrivateDerived privDer; // privDer.publicMember = 10; // 错误：publicMember 在 PrivateDerived 中为 private return 0;&#125; 5. 继承中类的作用域（Scope of Classes in Inheritance）5.1 概述在继承关系中，类的作用域决定了成员名称的可见性和访问方式。派生类可以访问基类的成员，根据访问控制的不同，还可能需要使用 作用域解析符 来访问隐藏的成员。 5.2 代码示例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class Base &#123;public: void display() const &#123; std::cout &lt;&lt; &quot;Display from Base&quot; &lt;&lt; std::endl; &#125; virtual void show() const &#123; std::cout &lt;&lt; &quot;Show from Base&quot; &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;public: void display() const &#123; // 隐藏基类的 display std::cout &lt;&lt; &quot;Display from Derived&quot; &lt;&lt; std::endl; &#125; void callBaseDisplay() const &#123; Base::display(); // 使用作用域解析符调用基类的 display &#125; void show() const &#123; // 重写 show， show 是虚函数可实现多态 std::cout &lt;&lt; &quot;Show from Derived&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Derived d; d.display(); // 调用 Derived::display d.callBaseDisplay(); // 调用 Base::display d.show(); // 调用 Derived::show Base* bPtr = &amp;d; bPtr-&gt;display(); // 调用 Base::display，因为 display 不是虚函数 bPtr-&gt;show(); // show 是虚函数，调用 Derived::show；否则调用 Base::show return 0;&#125; 5.3 执行结果12345Display from DerivedDisplay from BaseShow from DerivedDisplay from BaseShow from Base // show 是虚函数则输出: Show from Derived 6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）6.1 概述在继承体系中，类的构造函数和拷贝控制函数（拷贝构造函数、拷贝赋值运算符、析构函数）的调用顺序和行为需要注意。基类的构造函数在派生类之前调用，析构函数则在派生类之后调用。 6.2 构造函数的调用顺序 基类的 默认构造函数 首先被调用，除非派生类在初始化列表中显式调用其他基类构造函数。 派生类的成员按照声明顺序被构造。 派生类的构造函数体被执行。 6.3 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;string&gt;class Base &#123;public: Base() &#123; std::cout &lt;&lt; &quot;Base default constructor&quot; &lt;&lt; std::endl; &#125; Base(const std::string&amp; name) : name_(name) &#123; std::cout &lt;&lt; &quot;Base parameterized constructor: &quot; &lt;&lt; name_ &lt;&lt; std::endl; &#125; Base(const Base&amp; other) : name_(other.name_) &#123; std::cout &lt;&lt; &quot;Base copy constructor&quot; &lt;&lt; std::endl; &#125; Base&amp; operator=(const Base&amp; other) &#123; std::cout &lt;&lt; &quot;Base copy assignment&quot; &lt;&lt; std::endl; if (this != &amp;other) &#123; name_ = other.name_; &#125; return *this; &#125; virtual ~Base() &#123; std::cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; std::endl; &#125;protected: std::string name_;&#125;;class Derived : public Base &#123;public: Derived() : Base(&quot;Default Derived&quot;) &#123; std::cout &lt;&lt; &quot;Derived default constructor&quot; &lt;&lt; std::endl; &#125; Derived(const std::string&amp; name, int value) : Base(name), value_(value) &#123; std::cout &lt;&lt; &quot;Derived parameterized constructor: &quot; &lt;&lt; value_ &lt;&lt; std::endl; &#125; Derived(const Derived&amp; other) : Base(other), value_(other.value_) &#123; std::cout &lt;&lt; &quot;Derived copy constructor&quot; &lt;&lt; std::endl; &#125; Derived&amp; operator=(const Derived&amp; other) &#123; std::cout &lt;&lt; &quot;Derived copy assignment&quot; &lt;&lt; std::endl; if (this != &amp;other) &#123; Base::operator=(other); value_ = other.value_; &#125; return *this; &#125; ~Derived() override &#123; std::cout &lt;&lt; &quot;Derived destructor&quot; &lt;&lt; std::endl; &#125;private: int value_;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Creating d1:&quot; &lt;&lt; std::endl; Derived d1; std::cout &lt;&lt; &quot;\\nCreating d2:&quot; &lt;&lt; std::endl; Derived d2(&quot;Custom Derived&quot;, 42); std::cout &lt;&lt; &quot;\\nCopy constructing d3 from d2:&quot; &lt;&lt; std::endl; Derived d3 = d2; std::cout &lt;&lt; &quot;\\nAssigning d1 = d2:&quot; &lt;&lt; std::endl; d1 = d2; std::cout &lt;&lt; &quot;\\nExiting main...&quot; &lt;&lt; std::endl; return 0;&#125; 6.4 执行结果1234567891011121314151617181920212223Creating d1:Base parameterized constructor: Default DerivedDerived default constructorCreating d2:Base parameterized constructor: Custom DerivedDerived parameterized constructor: 42Copy constructing d3 from d2:Base copy constructorDerived copy constructorAssigning d1 = d2:Derived copy assignmentBase copy assignmentExiting main...Derived destructorBase destructorDerived destructorBase destructorDerived destructorBase destructor 7. 容器与继承（Containers and Inheritance）7.1 概述C++ 容器（如 std::vector、std::list 等） 通常存储对象的副本，而非指向对象的指针。因此，当与继承结合使用时，可能导致 切片（Object Slicing） 问题，即仅存储基类部分，丢失派生类特有的信息。为了实现多态性，推荐使用指针或智能指针存储对象。 7.2 切片问题示例1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;class Base &#123;public: virtual void show() const &#123; std::cout &lt;&lt; &quot;Base show&quot; &lt;&lt; std::endl; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public: void show() const override &#123; std::cout &lt;&lt; &quot;Derived show&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::vector&lt;Base&gt; vec; Derived d; vec.push_back(d); // 切片发生，派生类特有部分被丢弃 vec[0].show(); // 输出: Base show return 0;&#125; 7.3 使用指针避免切片1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;memory&gt;class Base &#123;public: virtual void show() const &#123; std::cout &lt;&lt; &quot;Base show&quot; &lt;&lt; std::endl; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public: void show() const override &#123; std::cout &lt;&lt; &quot;Derived show&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; vec; vec.emplace_back(std::make_unique&lt;Derived&gt;()); vec[0]-&gt;show(); // 输出: Derived show return 0;&#125; 7.5 智能指针选择 **std::unique_ptr**： 独占所有权，不可复制，只能移动。 适用于明确的单一所有权场景。 **std::shared_ptr**： 共享所有权，可以被多个指针共享和引用计数。 适用于需要多个所有者的场景。 练习题目1. 简单继承与成员访问题目： 定义一个基类 Person，包含以下成员： 私有成员变量：name（字符串类型），age（整数类型） 公共成员函数 ： 构造函数：接受姓名和年龄作为参数并初始化成员变量 displayInfo()：打印姓名和年龄 然后，定义一个派生类 Student，继承自 Person，并添加以下内容： 私有成员变量：studentID（字符串类型） 公共成员函数 ： 构造函数：接受姓名、年龄和学号作为参数，并调用基类构造函数初始化姓名和年龄 重写 displayInfo()：除了显示姓名和年龄外，还显示学号 要求： 在 main 函数中，创建一个 Student 对象，并调用 displayInfo() 函数展示信息。 示例输出： 123Name: AliceAge: 20Student ID: S12345 2. 虚函数重写与多态性题目： 定义一个基类 Shape，包含以下内容： 公共成员函数 ： 虚函数 draw()：在基类中实现，输出 “Drawing a generic shape.” 然后，定义两个派生类 Circle 和 Rectangle，分别重写 draw() 函数，实现各自的输出： Circle 的 draw() 输出：”Drawing a circle.” Rectangle 的 draw() 输出：”Drawing a rectangle.” 要求： 在 main 函数中，创建一个 Shape 类型的指针数组，包含不同类型的 Shape 对象（Circle 和 Rectangle）。 遍历数组，调用每个对象的 draw() 函数，验证多态性的实现。 示例输出： 123Drawing a circle.Drawing a rectangle.Drawing a generic shape. 3. 函数重载与隐藏题目： 定义一个基类 Calculator，包含以下公共成员函数： int add(int a, int b)：返回两个整数的和 double add(double a, double b)：返回两个浮点数的和 然后，定义一个派生类 AdvancedCalculator，继承自 Calculator，并添加以下成员函数： int add(int a, int b, int c)：返回三个整数的和 要求： 在 1main 函数中，创建一个 1AdvancedCalculator 对象，分别调用以下函数，并观察输出： add(2, 3) add(2.5, 3.5) add(1, 2, 3) 注意： 观察派生类中新增的 add 函数是否影响基类中的同名函数。 示例输出： 123566 4. 抽象类与纯虚函数题目： 定义一个抽象基类 Animal，包含以下内容： 公共纯虚函数 ： void makeSound() const：纯虚函数，用于发出动物的叫声 然后，定义两个派生类 Dog 和 Cat，分别实现 makeSound() 函数： Dog 的 makeSound() 输出：”Woof!” Cat 的 makeSound() 输出：”Meow!” 要求： 在 main 函数中，创建 Dog 和 Cat 对象的基类指针，并调用 makeSound() 函数，展示多态性。 示例输出： 12Woof!Meow! 5. 构造函数与析构函数的继承题目： 定义一个基类 Vehicle，包含以下内容： 公共成员函数 ： 构造函数：输出 “Vehicle constructed.” 析构函数：输出 “Vehicle destructed.” 然后，定义一个派生类 Car，继承自 Vehicle，并添加以下内容： 公共成员函数 ： 构造函数：输出 “Car constructed.” 析构函数：输出 “Car destructed.” 要求： 在 main 函数中，创建一个 Car 对象，并观察构造和析构的调用顺序。 示例输出： 1234Vehicle constructed.Car constructed.Car destructed.Vehicle destructed.","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(19) 类基础用法","date":"2024-11-09T12:58:32.000Z","path":"2024/11/09/cppbase19/","text":"1. 类与对象简介1.1 什么是类和对象 类（Class）是C++中创建用户自定义类型的一种方式，它将数据（成员变量）和操作数据的函数（成员函数）封装在一起。 对象（Object）是类的实例化，拥有类定义的所有属性和行为。 类更像是汽车图纸，对象更像是造出来的汽车。 1.2 类的作用 封装（Encapsulation）：将数据和操作数据的代码绑定在一起，保护数据不被外界直接访问。 抽象（Abstraction）：通过类定义抽象出具有共同特性的对象，提高代码的可重用性和可维护性。 继承（Inheritance）和多态（Polymorphism）：实现代码的复用与动态绑定。 2. 类的定义2.1 基本语法12345678class ClassName &#123;public: // 公有成员private: // 私有成员protected: // 受保护成员&#125;; 2.2 示例创建一个表示学生的类： 12345678910111213141516171819#include &lt;string&gt;class Student &#123;public: // 公有构造函数 Student(const std::string&amp; name, int age); // 公有成员函数 void setName(const std::string&amp; name); std::string getName() const; void setAge(int age); int getAge() const;private: // 私有成员变量 std::string name_; int age_;&#125;; 3. 成员变量与成员函数3.1 成员变量 成员变量（Member Variables）：用于存储对象的状态信息。 命名约定：常用下划线结尾（例如 name_）表示成员变量，避免与局部变量混淆。 3.2 成员函数 成员函数（Member Functions）：定义对象的行为，可以访问和修改成员变量。 常成员函数（Const Member Functions）：保证函数不会修改对象的状态。 3.3 示例实现12345678910111213141516171819202122// Student.cpp#include &quot;Student.h&quot;Student::Student(const std::string&amp; name, int age) : name_(name), age_(age) &#123;&#125;void Student::setName(const std::string&amp; name) &#123; name_ = name;&#125;std::string Student::getName() const &#123; return name_;&#125;void Student::setAge(int age) &#123; if (age &gt; 0) age_ = age;&#125;int Student::getAge() const &#123; return age_;&#125; 4. 访问控制4.1 访问修饰符 public：公有成员，可以被所有代码访问。 private：私有成员，仅能被类的成员函数和友元访问。 protected：受保护成员，仅能被类的成员函数、友元和派生类访问。 4.2 例子1234567891011class Sample &#123;public: void publicFunction();private: int privateVar_; void privateFunction();protected: int protectedVar_;&#125;; 5. 构造函数与析构函数5.1 构造函数 默认构造函数：没有参数的构造函数。 参数化构造函数：接受参数以初始化对象。 拷贝构造函数：用一个对象初始化另一个对象。 移动构造函数（C++11）：从临时对象“移动”资源。 5.2 析构函数 析构函数（Destructor）：在对象生命周期结束时调用，用于释放资源。 5.3 示例123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class Example &#123;public: // 默认构造函数 Example() : data_(0) &#123; std::cout &lt;&lt; &quot;Default constructor called.\\n&quot;; &#125; // 参数化构造函数 Example(int data) : data_(data) &#123; std::cout &lt;&lt; &quot;Parameterized constructor called with data = &quot; &lt;&lt; data_ &lt;&lt; &quot;.\\n&quot;; &#125; // 拷贝构造函数 Example(const Example&amp; other) : data_(other.data_) &#123; std::cout &lt;&lt; &quot;Copy constructor called.\\n&quot;; &#125; // 移动构造函数 Example(Example&amp;&amp; other) noexcept : data_(other.data_) &#123; other.data_ = 0; std::cout &lt;&lt; &quot;Move constructor called.\\n&quot;; &#125; // 析构函数 ~Example() &#123; std::cout &lt;&lt; &quot;Destructor called for data = &quot; &lt;&lt; data_ &lt;&lt; &quot;.\\n&quot;; &#125;private: int data_;&#125;; 5.4 使用示例1234567int main() &#123; Example ex1; // 调用默认构造函数 Example ex2(42); // 调用参数化构造函数 Example ex3 = ex2; // 调用拷贝构造函数 Example ex4 = std::move(ex2); // 调用移动构造函数 return 0;&#125; 输出示例： 1234567Default constructor called.Parameterized constructor called with data = 42.Copy constructor called.Move constructor called.Destructor called for data = 0.Destructor called for data = 42.Destructor called for data = 42. 5.5 拷贝构造是否必须实现当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。比如一个类A中有成员变量std::thread，std::thread没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。 同样析构也要显示编写，等待线程完成。 除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果 5.6 构造顺序和析构顺序类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？ 如果析构的时候是A先析构还是B先析构呢？ 5.7 类默认构造是否必须实现如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。 系统提供的合成的默认构造函数不会对成员做初始化操作。 5.8 this 指针的特性和用途 指向当前对象： this 指针是一个隐式参数，指向调用成员函数的对象。通过 this，你可以访问当前对象的属性和方法。 区分成员变量和参数： 在构造函数或成员函数中，参数名和成员变量可能同名。使用 1this 可以明确指代成员变量。例如： 12345678class MyClass &#123;private: int value;public: MyClass(int value) &#123; this-&gt;value = value; // 使用 this 指针区分成员变量和参数 &#125;&#125;; 返回当前对象： ```this123456789101112131415161718 可以用于返回当前对象的引用，以支持链式调用。例如：```cppclass MyClass &#123;private: int value;public: MyClass&amp; setValue(int value) &#123; this-&gt;value = value; return *this; // 返回当前对象的引用 &#125;&#125;;MyClass obj;obj.setValue(10).setValue(20); // 链式调用 在 const 成员函数中的使用： 在 const 成员函数中，this 的类型为 const MyClass*，这意味着你不能通过 this 修改成员变量。这有助于确保对象的状态不被改变。 在静态成员函数中的不可用性： 静态成员函数没有 this 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。 示例代码 以下是一个简单的示例，展示了 this 指针的用法： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;class MyClass &#123;private: int value;public: // 构造函数 MyClass(int value) &#123; this-&gt;value = value; // 使用 this 指针区分成员变量和参数 &#125; // 成员函数 MyClass&amp; setValue(int value) &#123; this-&gt;value = value; // 使用 this 指针 return *this; // 返回当前对象的引用 &#125; // 输出值 void printValue() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; this-&gt;value &lt;&lt; std::endl; // 使用 this 指针 &#125;&#125;;int main() &#123; MyClass obj(10); obj.printValue(); // 输出: Value: 10 obj.setValue(20).printValue(); // 链式调用，输出: Value: 20 return 0;&#125; 5.9 delete和defaultC++11用法： delete可以删除指定的构造函数。 default可以指定某个构造函数为系统默认合成。 6. 拷贝控制拷贝构造函数与拷贝赋值运算符 6.1 拷贝构造函数 定义：用于创建一个新对象，并复制现有对象的成员。 语法：ClassName(const ClassName&amp; other); 6.2 拷贝赋值运算符 定义：用于将一个已有对象的值赋给另一个已有对象。 语法：ClassName&amp; operator=(const ClassName&amp; other); 6.3 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;class MyString &#123;public: // 构造函数 MyString(const char* str = nullptr) &#123; if (str) &#123; size_ = std::strlen(str); data_ = new char[size_ + 1]; std::strcpy(data_, str); &#125; else &#123; size_ = 0; data_ = new char[1]; data_[0] = &#x27;\\0&#x27;; &#125; std::cout &lt;&lt; &quot;Constructor called.\\n&quot;; &#125; // 拷贝构造函数 MyString(const MyString&amp; other) : size_(other.size_) &#123; data_ = new char[size_ + 1]; std::strcpy(data_, other.data_); std::cout &lt;&lt; &quot;Copy constructor called.\\n&quot;; &#125; // 拷贝赋值运算符 MyString&amp; operator=(const MyString&amp; other) &#123; std::cout &lt;&lt; &quot;Copy assignment operator called.\\n&quot;; if (this == &amp;other) return *this; // 自赋值检查 delete[] data_; // 释放现有资源 size_ = other.size_; data_ = new char[size_ + 1]; std::strcpy(data_, other.data_); return *this; &#125; // 析构函数 ~MyString() &#123; delete[] data_; std::cout &lt;&lt; &quot;Destructor called.\\n&quot;; &#125; void print() const &#123; std::cout &lt;&lt; data_ &lt;&lt; &quot;\\n&quot;; &#125;private: char* data_; std::size_t size_;&#125;; 6.4 使用示例1234567891011int main() &#123; MyString s1(&quot;Hello&quot;); MyString s2 = s1; // 调用拷贝构造函数 MyString s3; s3 = s1; // 调用拷贝赋值运算符 s1.print(); s2.print(); s3.print(); return 0;&#125; 输出示例： 12345678910Constructor called.Copy constructor called.Constructor called.Copy assignment operator called.HelloHelloHelloDestructor called.Destructor called.Destructor called. 7. 移动语义7.1 什么是移动语义 移动语义（Move Semantics）：允许资源的所有权从一个对象转移到另一个对象，避免不必要的拷贝，提高性能。 7.2 移动构造函数与移动赋值运算符 移动构造函数：ClassName(ClassName&amp;&amp; other) noexcept; 移动赋值运算符：ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept; 7.3 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;utility&gt;class MoveExample &#123;public: // 构造函数 MoveExample(int size) : size_(size), data_(new int[size]) &#123; std::cout &lt;&lt; &quot;Constructor called.\\n&quot;; &#125; // 拷贝构造函数 MoveExample(const MoveExample&amp; other) : size_(other.size_), data_(new int[other.size_]) &#123; std::copy(other.data_, other.data_ + size_, data_); std::cout &lt;&lt; &quot;Copy constructor called.\\n&quot;; &#125; // 移动构造函数 MoveExample(MoveExample&amp;&amp; other) noexcept : size_(other.size_), data_(other.data_) &#123; other.size_ = 0; other.data_ = nullptr; std::cout &lt;&lt; &quot;Move constructor called.\\n&quot;; &#125; // 拷贝赋值运算符 MoveExample&amp; operator=(const MoveExample&amp; other) &#123; std::cout &lt;&lt; &quot;Copy assignment operator called.\\n&quot;; if (this == &amp;other) return *this; delete[] data_; size_ = other.size_; data_ = new int[size_]; std::copy(other.data_, other.data_ + size_, data_); return *this; &#125; // 移动赋值运算符 MoveExample&amp; operator=(MoveExample&amp;&amp; other) noexcept &#123; std::cout &lt;&lt; &quot;Move assignment operator called.\\n&quot;; if (this == &amp;other) return *this; delete[] data_; size_ = other.size_; data_ = other.data_; other.size_ = 0; other.data_ = nullptr; return *this; &#125; // 析构函数 ~MoveExample() &#123; delete[] data_; std::cout &lt;&lt; &quot;Destructor called.\\n&quot;; &#125;private: int size_; int* data_;&#125;; 7.4 使用示例1234567891011int main() &#123; MoveExample ex1(100); // Constructor MoveExample ex2 = ex1; // Copy Constructor MoveExample ex3 = MoveExample(200); // Move Constructor MoveExample ex4(300); ex4 = ex1; // Copy Assignment ex4 = MoveExample(400); // Move Assignment return 0;&#125; 输出示例： 12345678910111213Constructor called.Copy constructor called.Constructor called.Move constructor called.Destructor called.Constructor called.Copy assignment operator called.Move constructor called.Move assignment operator called.Destructor called.Destructor called.Destructor called.Destructor called. 8. 类的友元8.1 什么是友元 友元（Friend）：可以访问类的私有和保护成员的非成员函数或另一个类。 8.2 类型 友元函数：单个函数可以被声明为友元。 友元类：整个类可以被声明为友元。 8.3 使用示例1234567891011121314151617181920#include &lt;iostream&gt;class Box &#123;public: Box(double length, double width, double height) : length_(length), width_(width), height_(height) &#123;&#125; // 声明友元函数 friend double calculateVolume(const Box&amp; b);private: double length_; double width_; double height_;&#125;;// 友元函数定义double calculateVolume(const Box&amp; b) &#123; return b.length_ * b.width_ * b.height_;&#125; 8.4 使用友元类123456789101112131415161718class Rectangle &#123;public: Rectangle(double width, double height) : width_(width), height_(height) &#123;&#125;private: double width_; double height_; // 声明友元类 friend class AreaCalculator;&#125;;class AreaCalculator &#123;public: double calculateArea(const Rectangle&amp; rect) &#123; return rect.width_ * rect.height_; &#125;&#125;; 9. 运算符重载9.1 什么是运算符重载 运算符重载（Operator Overloading）：允许对自定义类型使用C++运算符，如 +, -, &lt;&lt; 等。 9.2 重载运算符的规则 只能对已有运算符进行重载，不能创建新运算符。 至少有一个操作数必须是用户定义的类型。 不能改变运算符的优先级或结合性。 9.3 示例：重载 + 运算符123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;class Point &#123;public: Point(double x, double y) : x_(x), y_(y) &#123;&#125; // 成员函数重载 + Point operator+(const Point&amp; other) const &#123; return Point(x_ + other.x_, y_ + other.y_); &#125; void print() const &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x_ &lt;&lt; &quot;, &quot; &lt;&lt; y_ &lt;&lt; &quot;)\\n&quot;; &#125;private: double x_; double y_;&#125;;// 也可以使用友元函数重载 +Point operator-(const Point&amp; a, const Point&amp; b) &#123; return Point(a.x_ - b.x_, a.y_ - b.y_);&#125;int main() &#123; Point p1(1.5, 2.5); Point p2(3.0, 4.0); Point p3 = p1 + p2; p3.print(); // 输出： (4.5, 6.5) Point p4 = p2 - p1; p4.print(); // 输出： (1.5, 1.5) return 0;&#125; 9.4 示例：重载 &lt;&lt; 运算符（输出流）123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;class Employee &#123;public: Employee(const std::string&amp; name, double salary) : name_(name), salary_(salary) &#123;&#125; // 声明友元函数以重载 &lt;&lt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Employee&amp; emp);private: std::string name_; double salary_;&#125;;// 定义重载的 &lt;&lt;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Employee&amp; emp) &#123; os &lt;&lt; &quot;Employee Name: &quot; &lt;&lt; emp.name_ &lt;&lt; &quot;, Salary: $&quot; &lt;&lt; emp.salary_; return os;&#125;int main() &#123; Employee emp(&quot;John Doe&quot;, 75000); std::cout &lt;&lt; emp &lt;&lt; std::endl; return 0;&#125; 输出示例： 1Employee Name: John Doe, Salary: $75000 10. 练习示例项目：实现自定义MyString类目标：创建一个简单的MyString类，支持拷贝构造，默认构造，有参构造，支持输出和比较等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstring&gt;class MyString &#123;private: char* data; // 动态分配的字符数组public: // 默认构造函数 MyString() : data(nullptr) &#123;&#125; // 有参构造函数 MyString(const char* str) &#123; if (str) &#123; data = new char[strlen(str) + 1]; // +1 for the null terminator strcpy(data, str); &#125; else &#123; data = nullptr; &#125; &#125; // 拷贝构造函数 MyString(const MyString&amp; other) &#123; if (other.data) &#123; data = new char[strlen(other.data) + 1]; strcpy(data, other.data); &#125; else &#123; data = nullptr; &#125; &#125; // 赋值运算符重载 MyString&amp; operator=(const MyString&amp; other) &#123; if (this != &amp;other) &#123; delete[] data; // 释放原有内存 if (other.data) &#123; data = new char[strlen(other.data) + 1]; strcpy(data, other.data); &#125; else &#123; data = nullptr; &#125; &#125; return *this; &#125; // 比较运算符重载 bool operator==(const MyString&amp; other) const &#123; if (data == nullptr &amp;&amp; other.data == nullptr) return true; if (data == nullptr || other.data == nullptr) return false; return strcmp(data, other.data) == 0; &#125; // 输出运算符重载 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MyString&amp; myStr) &#123; if (myStr.data) &#123; os &lt;&lt; myStr.data; &#125; return os; &#125; // 析构函数 ~MyString() &#123; delete[] data; // 释放动态分配的内存 &#125;&#125;;int main() &#123; MyString str1(&quot;Hello, World!&quot;); MyString str2 = str1; // 拷贝构造 MyString str3; str3 = str1; // 赋值运算符重载 std::cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;str3: &quot; &lt;&lt; str3 &lt;&lt; std::endl; if (str1 == str2) &#123; std::cout &lt;&lt; &quot;str1 and str2 are equal.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;str1 and str2 are not equal.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 代码说明 私有成员： char* data：指向动态分配的字符数组，用于存储字符串。 构造函数： 默认构造函数：初始化 data 为 nullptr。 有参构造函数：接收一个 const char* 类型的字符串，动态分配内存并复制字符串内容。 拷贝构造函数：复制另一个 MyString 对象的内容，确保深拷贝。 赋值运算符重载：支持将一个 MyString 对象赋值给另一个，确保释放原有内存并进行深拷贝。 比较运算符重载：支持比较两个 MyString 对象是否相等。 输出运算符重载：支持直接使用 std::cout 输出 MyString 对象。 析构函数：释放动态分配的内存，防止内存泄漏。 使用示例在 main 函数中，创建了几个 MyString 对象，演示了拷贝构造、赋值和比较的用法。 视频教程关于C++的视频教程可参考我的主页 C++教程视频","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(18) 函数用法","date":"2024-11-03T03:41:04.000Z","path":"2024/11/03/cppbase18/","text":"1. 函数简介定义函数是执行特定任务的代码块，可以被程序中的多个地方调用。使用函数可以增加代码的可重用性、可读性和可维护性。 功能 封装：将特定功能封装在函数中，便于管理和修改。 复用：同一段功能代码可以在程序中多次调用，减少代码重复。 结构化：通过函数组织代码，提高程序的结构清晰度。 基本语法123return_type function_name(parameter_list) &#123; // function body&#125; 示例： 123456789101112131415#include &lt;iostream&gt;// 函数声明int add(int a, int b);int main() &#123; int result = add(5, 3); std::cout &lt;&lt; &quot;5 + 3 = &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125;// 函数定义int add(int a, int b) &#123; return a + b;&#125; 输出： 15 + 3 = 8 2. 函数的声明与定义函数声明（Function Declaration）告诉编译器函数的名称、返回类型和参数类型，但不包含函数体。通常放在头文件中或在使用函数前进行声明。 语法： 1return_type function_name(parameter_list); 示例： 1int multiply(int a, int b); // 函数声明 函数定义（Function Definition）提供函数的具体实现，包括函数体。函数定义可以在源文件中或与声明一起在头文件中出现（推荐仅声明在头文件中）。 语法： 123return_type function_name(parameter_list) &#123; // function body&#125; 示例： 123int multiply(int a, int b) &#123; // 函数定义 return a * b;&#125; 函数分离编译 声明：放在头文件（如 multiply.h）。 定义：放在源文件（如 multiply.cpp）。 multiply.h: 123456#ifndef MULTIPLY_H#define MULTIPLY_Hint multiply(int a, int b);#endif multiply.cpp: 12345#include &quot;multiply.h&quot;int multiply(int a, int b) &#123; return a * b;&#125; main.cpp: 12345678#include &lt;iostream&gt;#include &quot;multiply.h&quot;int main() &#123; int result = multiply(4, 6); std::cout &lt;&lt; &quot;4 * 6 = &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 编译命令（假设使用g++）： 1g++ main.cpp multiply.cpp -o program 输出： 14 * 6 = 24 3. 函数调用基本调用通过函数名称和必要的参数来调用函数。 示例： 12345678910#include &lt;iostream&gt;void greet() &#123; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;&#125;int main() &#123; greet(); // 调用函数 return 0;&#125; 输出： 1Hello, World! 多次调用同一函数可以在程序中被调用多次。 示例： 123456789101112#include &lt;iostream&gt;void sayHello() &#123; std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; std::endl;&#125;int main() &#123; sayHello(); sayHello(); sayHello(); return 0;&#125; 输出： 123Hello!Hello!Hello! 4. 参数传递机制C++中函数参数的传递方式主要有以下三种： 传值调用（Pass by Value） 传引用调用（Pass by Reference） 传指针调用（Pass by Pointer） 传值调用定义：函数接收参数的副本，函数内对参数的修改不会影响原始数据。 语法： 123void function_name(int a) &#123; a = 10; // 只修改副本&#125; 示例： 12345678910111213#include &lt;iostream&gt;void changeValue(int num) &#123; num = 100; std::cout &lt;&lt; &quot;Inside function: &quot; &lt;&lt; num &lt;&lt; std::endl;&#125;int main() &#123; int value = 50; changeValue(value); std::cout &lt;&lt; &quot;Outside function: &quot; &lt;&lt; value &lt;&lt; std::endl; return 0;&#125; 输出： 12Inside function: 100Outside function: 50 解释：changeValue函数修改的是num的副本，原始变量value保持不变。 传引用调用定义：函数接收参数的引用，函数内对参数的修改会影响原始数据。 语法： 123void function_name(int &amp;a) &#123; a = 10; // 修改原始数据&#125; 示例： 12345678910111213#include &lt;iostream&gt;void changeValue(int &amp;num) &#123; num = 100; std::cout &lt;&lt; &quot;Inside function: &quot; &lt;&lt; num &lt;&lt; std::endl;&#125;int main() &#123; int value = 50; changeValue(value); std::cout &lt;&lt; &quot;Outside function: &quot; &lt;&lt; value &lt;&lt; std::endl; return 0;&#125; 输出： 12Inside function: 100Outside function: 100 解释：changeValue函数通过引用修改了原始变量value的值。 传指针调用定义：函数接收指向参数的指针，函数内通过指针可以修改原始数据。 语法： 123void function_name(int *a) &#123; *a = 10; // 修改原始数据&#125; 示例： 12345678910111213#include &lt;iostream&gt;void changeValue(int *num) &#123; *num = 100; std::cout &lt;&lt; &quot;Inside function: &quot; &lt;&lt; *num &lt;&lt; std::endl;&#125;int main() &#123; int value = 50; changeValue(&amp;value); std::cout &lt;&lt; &quot;Outside function: &quot; &lt;&lt; value &lt;&lt; std::endl; return 0;&#125; 输出： 12Inside function: 100Outside function: 100 解释：changeValue函数通过指针修改了原始变量value的值。 选择合适的传递方式 传值调用：适用于不需要修改原始数据且数据量较小的情况。 传引用调用：适用于需要修改原始数据或传递大型数据结构以提高效率。 传指针调用：类似传引用调用，但更灵活，可用于传递nullptr或指向动态分配的内存。 5. 返回值函数可以通过return语句将结果返回给调用者。返回值的类型可以是基本数据类型、引用、指针、对象等。 5.1 返回基本数据类型示例： 1234567891011#include &lt;iostream&gt;int add(int a, int b) &#123; return a + b;&#125;int main() &#123; int sum = add(3, 4); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 输出： 1Sum: 7 5.2 返回引用注意：返回引用需要确保引用的对象在返回后依然有效（避免悬垂引用）。 示例： 123456789101112131415161718#include &lt;iostream&gt;int&amp; getMax(int &amp;a, int &amp;b) &#123; if(a &gt; b) return a; else return b;&#125;int main() &#123; int x = 10; int y = 20; int &amp;max = getMax(x, y); std::cout &lt;&lt; &quot;Max: &quot; &lt;&lt; max &lt;&lt; std::endl; max = 30; // 修改引用 std::cout &lt;&lt; &quot;After modification, y: &quot; &lt;&lt; y &lt;&lt; std::endl; return 0;&#125; 输出： 12Max: 20After modification, y: 30 解释：getMax函数返回较大的变量的引用，修改max实际上修改了y。 5.3 返回指针示例： 123456789101112131415161718#include &lt;iostream&gt;int* allocateArray(int size) &#123; int* arr = new int[size]; for(int i = 0; i &lt; size; ++i) arr[i] = i * 2; return arr;&#125;int main() &#123; int size = 5; int* myArray = allocateArray(size); for(int i = 0; i &lt; size; ++i) std::cout &lt;&lt; myArray[i] &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; delete[] myArray; // 释放内存 return 0;&#125; 输出： 10 2 4 6 8 解释：allocateArray函数动态分配一个数组并返回指向数组的指针。调用者需负责释放内存。 5.4 返回对象示例： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;class Person &#123;public: std::string name; int age; Person(std::string n, int a) : name(n), age(a) &#123;&#125;&#125;;Person createPerson(std::string name, int age) &#123; Person p(name, age); return p; // 返回对象&#125;int main() &#123; Person person = createPerson(&quot;Alice&quot;, 25); std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; person.age &lt;&lt; std::endl; return 0;&#125; 输出： 1Name: Alice, Age: 25 解释：createPerson函数返回一个Person对象。现代编译器通过返回值优化（RVO）减少对象拷贝，提高效率。 6. 函数重载定义函数重载允许在同一个作用域内定义多个名称相同但参数列表不同的函数。编译器通过参数列表的不同来区分调用哪个函数。 规则 函数名相同。 参数列表（类型、数量或顺序）不同。 返回类型不参与重载的区分。 示例12345678910111213141516171819202122#include &lt;iostream&gt;// 重载函数：不同参数数量int add(int a, int b) &#123; return a + b;&#125;int add(int a, int b, int c) &#123; return a + b + c;&#125;// 重载函数：不同参数类型double add(double a, double b) &#123; return a + b;&#125;int main() &#123; std::cout &lt;&lt; &quot;add(2, 3) = &quot; &lt;&lt; add(2, 3) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;add(2, 3, 4) = &quot; &lt;&lt; add(2, 3, 4) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;add(2.5, 3.5) = &quot; &lt;&lt; add(2.5, 3.5) &lt;&lt; std::endl; return 0;&#125; 输出： 123add(2, 3) = 5add(2, 3, 4) = 9add(2.5, 3.5) = 6 注意事项 仅返回类型不同的重载是非法的。 默认参数可能会与重载产生冲突，使用时需谨慎。 非法示例： 1234567double add(int a, int b) &#123; return a + b + 0.0;&#125;// 冲突重载，仅返回类型不同// 会导致编译错误// double add(int a, int b); 7. 默认参数定义函数参数可以指定默认值，调用函数时可以省略这些参数，默认值将被使用。 规则 默认参数从右到左设置，不能部分设置。 函数声明和定义中默认参数只需在声明中指定。 示例123456789101112131415161718#include &lt;iostream&gt;// 函数声明时指定默认参数void displayInfo(std::string name, int age = 18, std::string city = &quot;Unknown&quot;);int main() &#123; displayInfo(&quot;Bob&quot;, 25, &quot;New York&quot;); // 全部参数传递 displayInfo(&quot;Charlie&quot;, 30); // 省略city displayInfo(&quot;Diana&quot;); // 省略age和city return 0;&#125;// 函数定义void displayInfo(std::string name, int age, std::string city) &#123; std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; &quot;, City: &quot; &lt;&lt; city &lt;&lt; std::endl;&#125; 输出： 123Name: Bob, Age: 25, City: New YorkName: Charlie, Age: 30, City: UnknownName: Diana, Age: 18, City: Unknown 注意事项 默认参数必须从右端开始，不能跳过中间参数。 如果同时使用默认参数和重载，可能会产生歧义，需谨慎设计。 8. 内联函数定义内联函数通过在函数前加inline关键字，建议编译器将函数代码嵌入到调用处，减少函数调用的开销。 使用场景适用于函数体积小、调用频繁的函数，如访问器（getter）和修改器（setter）等。 示例1234567891011#include &lt;iostream&gt;// 内联函数inline int square(int x) &#123; return x * x;&#125;int main() &#123; std::cout &lt;&lt; &quot;Square of 5: &quot; &lt;&lt; square(5) &lt;&lt; std::endl; return 0;&#125; 输出： 1Square of 5: 25 优点 减少函数调用的开销（如栈操作）。 可能提高程序性能。 缺点 使得代码体积增大，可能影响缓存性能。 编译器可能忽略内联请求，特别是对于复杂函数。 注意事项 编译器对inline关键字的处理是建议性质，最终是否内联由编译器决定。 过度使用内联函数可能导致代码膨胀。 9. 递归函数定义递归函数是指在函数体内调用自身的函数。递归通常用于解决可以分解为相似子问题的问题，如阶乘、斐波那契数列、树的遍历等。 基本结构递归函数通常包含两个部分： 基准情形（Base Case）：直接返回结果，避免无限递归。 递归情形（Recursive Case）：将问题分解为更小的子问题并调用自身。 示例：计算阶乘1234567891011121314151617181920#include &lt;iostream&gt;// 递归函数计算阶乘long long factorial(int n) &#123; if(n &lt; 0) return -1; // 错误情况 if(n == 0 || n == 1) return 1; // 基准情形 return n * factorial(n - 1); // 递归情形&#125;int main() &#123; int number = 5; long long result = factorial(number); if(result != -1) std::cout &lt;&lt; number &lt;&lt; &quot;! = &quot; &lt;&lt; result &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;Invalid input!&quot; &lt;&lt; std::endl; return 0;&#125; 输出： 15! = 120 示例：斐波那契数列12345678910111213141516#include &lt;iostream&gt;// 递归函数计算斐波那契数int fibonacci(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2);&#125;int main() &#123; int term = 10; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; term &lt;&lt; &quot;) = &quot; &lt;&lt; fibonacci(term) &lt;&lt; std::endl; return 0;&#125; 输出： 1Fibonacci(10) = 55 注意事项 基准情形：必须正确设置，避免无限递归导致栈溢出（Stack Overflow）。 效率问题：一些递归实现可能效率低下（如斐波那契数列），可以通过“记忆化”或改用迭代方法优化。 堆栈深度：递归深度过大可能导致栈溢出，需避免深度递归。 递归优化：尾递归尾递归是指递归调用在函数的最后一步，可以被编译器优化为循环，减少堆栈消耗。 示例：尾递归阶乘 12345678910111213141516171819#include &lt;iostream&gt;// 辅助函数，用于尾递归long long factorialHelper(int n, long long accumulator) &#123; if(n == 0) return accumulator; return factorialHelper(n - 1, n * accumulator);&#125;// 尾递归函数long long factorial(int n) &#123; return factorialHelper(n, 1);&#125;int main() &#123; int number = 5; std::cout &lt;&lt; number &lt;&lt; &quot;! = &quot; &lt;&lt; factorial(number) &lt;&lt; std::endl; return 0;&#125; 输出： 15! = 120 解释：factorialHelper函数的递归调用是函数的最后一步，编译器可以将其优化为迭代，减少堆栈消耗。 10. Lambda表达式定义Lambda表达式是C++11引入的匿名函数，便于在需要函数对象的地方快速定义和使用函数。它允许定义内联的、小型的可调用对象，无需单独定义函数。 语法123[ capture_list ] ( parameter_list ) -&gt; return_type &#123; // function body&#125; 示例12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;; // 使用Lambda表达式打印每个元素 std::for_each(numbers.begin(), numbers.end(), [](int x) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;); std::cout &lt;&lt; std::endl; // 使用Lambda表达式计算总和 int sum = 0; std::for_each(numbers.begin(), numbers.end(), [&amp;sum](int x) &#123; sum += x; &#125;); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 输出： 121 2 3 4 5 Sum: 15 组件说明 捕获列表（Capture List）：指定如何访问外部变量。 [ ]：不捕获任何外部变量。 [&amp;]：按引用捕获所有外部变量。 [=]：按值捕获所有外部变量。 [x, &amp;y]：按值捕获x，按引用捕获y。 参数列表（Parameter List）：类似普通函数的参数列表，可以省略类型（C++14及以上支持自动类型推断）。 返回类型（Return Type）：可指定返回类型，也可省略，编译器自动推断。 函数体（Function Body）：Lambda的具体实现。 高级示例：捕获并排序12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; data = &#123;5, 2, 9, 1, 5, 6&#125;; // 按降序排序，使用Lambda表达式 std::sort(data.begin(), data.end(), [](int a, int b) -&gt; bool &#123; return a &gt; b; &#125;); std::cout &lt;&lt; &quot;Sorted data: &quot;; for(auto num : data) std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; return 0;&#125; 输出： 1Sorted data: 9 6 5 5 2 1 使用Lambda表达式与标准库C++标准库中的许多算法（如std::for_each、std::sort、std::transform等）常用Lambda表达式作为参数，以实现自定义的操作。 11. 函数指针与回调函数函数指针定义：指向函数的指针变量，保存函数的地址，可以通过指针调用函数。 声明与使用12345678910111213141516#include &lt;iostream&gt;// 普通函数void greet() &#123; std::cout &lt;&lt; &quot;Hello from greet!&quot; &lt;&lt; std::endl;&#125;int main() &#123; // 定义函数指针 void (*funcPtr)() = greet; // 通过指针调用函数 funcPtr(); return 0;&#125; 输出： 1Hello from greet! 函数指针作为参数示例： 12345678910111213141516#include &lt;iostream&gt;// 高阶函数，接受函数指针作为参数void execute(void (*func)()) &#123; func(); // 调用传入的函数&#125;// 被调用的函数void sayHi() &#123; std::cout &lt;&lt; &quot;Hi!&quot; &lt;&lt; std::endl;&#125;int main() &#123; execute(sayHi); return 0;&#125; 输出： 1Hi! 回调函数定义：通过函数指针传递的函数，通常用于在特定事件发生时执行自定义操作。 示例：基于函数指针的回调 123456789101112131415161718192021#include &lt;iostream&gt;// 回调类型定义typedef void (*Callback)();// 函数接收回调void registerCallback(Callback cb) &#123; std::cout &lt;&lt; &quot;Before callback&quot; &lt;&lt; std::endl; cb(); // 执行回调 std::cout &lt;&lt; &quot;After callback&quot; &lt;&lt; std::endl;&#125;// 回调函数void myCallback() &#123; std::cout &lt;&lt; &quot;Callback executed!&quot; &lt;&lt; std::endl;&#125;int main() &#123; registerCallback(myCallback); return 0;&#125; 输出： 123Before callbackCallback executed!After callback 与Lambda表达式结合函数指针也可以指向Lambda表达式，但仅限于不捕获外部变量的Lambda。 示例： 123456789101112131415161718#include &lt;iostream&gt;// 回调类型定义typedef void (*Callback)();void executeCallback(Callback cb) &#123; cb();&#125;int main() &#123; // 不捕获外部变量的Lambda Callback cb = []() &#123; std::cout &lt;&lt; &quot;Lambda callback!&quot; &lt;&lt; std::endl; &#125;; executeCallback(cb); return 0;&#125; 输出： 1Lambda callback! 注意：捕获外部变量的Lambda无法转换为普通函数指针。 12. 总结与练习课程总结 函数的基本概念：了解函数的作用、基本结构及使用方法。 函数声明与定义：掌握在头文件和源文件中分离声明与定义的方法。 参数传递机制：理解传值、传引用和传指针的区别及应用场景。 返回值：学习不同类型的返回值及其使用方法。 函数重载：掌握函数名相同但参数不同的重载机制。 默认参数：学习设定和使用函数的默认参数。 内联函数：了解内联函数的概念、优缺点及使用场景。 递归函数：理解递归的基本原理、编写方法及优化技巧。 Lambda表达式：掌握定义和使用Lambda表达式的方法，及其在标准库中的应用。 函数指针与回调函数：了解函数指针的声明、使用以及如何实现回调机制。 13. 课后练习1. 练习1 编写一个递归函数，计算斐波那契数列的第n项 问题描述斐波那契数列是由0和1开始，后续的每一项都是前两项的和。数列如下： 10, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... 编写一个递归函数 fibonacci，接受一个整数 n，返回斐波那契数列的第 n 项。假设 fibonacci(0) = 0，fibonacci(1) = 1。 答案代码12345678910111213141516171819202122#include &lt;iostream&gt;// 递归函数计算斐波那契数列的第n项long long fibonacci(int n) &#123; if(n &lt; 0) &#123; std::cerr &lt;&lt; &quot;Invalid input: n must be non-negative.&quot; &lt;&lt; std::endl; return -1; // 错误情况 &#125; if(n == 0) return 0; // 基准情形1 if(n == 1) return 1; // 基准情形2 return fibonacci(n - 1) + fibonacci(n - 2); // 递归调用&#125;int main() &#123; int term = 10; long long result = fibonacci(term); if(result != -1) std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; term &lt;&lt; &quot;) = &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 输出1Fibonacci(10) = 55 解释 函数 fibonacci 定义了两个基准情形：n == 0 返回0，n == 1 返回1。 对于 n &gt; 1，函数递归调用自身计算 fibonacci(n - 1) 和 fibonacci(n - 2)，并返回它们的和。 在 main 函数中，计算并输出斐波那契数列的第10项，其值为55。 2. 练习2使用Lambda表达式和std::sort对一个字符串数组按长度排序 问题描述给定一个字符串数组，使用Lambda表达式和std::sort函数对数组中的字符串按照其长度进行排序。 答案123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;int main() &#123; std::vector&lt;std::string&gt; fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;, &quot;strawberry&quot;, &quot;grape&quot;, &quot;pineapple&quot;&#125;; // 使用Lambda表达式按照字符串长度进行排序 std::sort(fruits.begin(), fruits.end(), [](const std::string &amp;a, const std::string &amp;b) -&gt; bool &#123; return a.length() &lt; b.length(); &#125;); // 输出排序后的结果 std::cout &lt;&lt; &quot;Fruits sorted by length:&quot; &lt;&lt; std::endl; for(const auto &amp;fruit : fruits) std::cout &lt;&lt; fruit &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; return 0;&#125; 输出12Fruits sorted by length:kiwi grape apple banana pineapple strawberry 解释 定义了一个包含多个水果名称的字符串向量 fruits。 使用 std::sort 对 fruits 进行排序，第三个参数是一个Lambda表达式，用于指定排序的规则。 Lambda表达式接收两个字符串 a 和 b，比较它们的长度，以实现按长度升序排序。 排序完成后，输出排序后的水果名称，按长度从短到长排列。 3. 练习3实现一个简易的事件系统，允许注册和触发回调函数 问题描述构建一个简单的事件系统，允许用户注册多个回调函数（函数指针或Lambda表达式），并在特定事件触发时调用这些回调函数。 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;// 定义带参数的回调函数类型using Callback = std::function&lt;void(int)&gt;;// 事件系统类class EventSystem &#123;private: std::vector&lt;Callback&gt; callbacks;public: // 注册回调函数 void registerCallback(const Callback &amp;cb) &#123; callbacks.push_back(cb); &#125; // 触发事件，传递参数给回调函数 void triggerEvent(int data) &#123; std::cout &lt;&lt; &quot;Event triggered with data = &quot; &lt;&lt; data &lt;&lt; &quot;. Executing callbacks...&quot; &lt;&lt; std::endl; for(auto &amp;cb : callbacks) cb(data); &#125;&#125;;// 示例函数作为回调void onEvent(int data) &#123; std::cout &lt;&lt; &quot;Function callback received data: &quot; &lt;&lt; data &lt;&lt; std::endl;&#125;int main() &#123; EventSystem eventSystem; // 注册基于函数指针的回调 eventSystem.registerCallback(onEvent); // 注册基于Lambda表达式的回调 eventSystem.registerCallback([](int x) &#123; std::cout &lt;&lt; &quot;Lambda callback received: &quot; &lt;&lt; x * 2 &lt;&lt; std::endl; &#125;); // 注册带捕获的Lambda表达式的回调 int multiplier = 5; eventSystem.registerCallback([multiplier](int x) &#123; std::cout &lt;&lt; &quot;Lambda with capture received: &quot; &lt;&lt; x * multiplier &lt;&lt; std::endl; &#125;); // 触发事件，传递参数 eventSystem.triggerEvent(10); return 0;&#125; 输出 1234Event triggered with data = 10. Executing callbacks...Function callback received data: 10Lambda callback received: 20Lambda with capture received: 50 解释 定义了一个带参数的回调函数类型 std::function&lt;void(int)&gt;，允许回调函数接受一个整数参数。 EventSystem 类的方法 triggerEvent 接受一个整数 data，并将其作为参数传递给每个回调函数。 在 main 函数中，注册了三个带不同处理逻辑的回调函数，并在触发事件时传递参数 10。 回调函数根据传入的 data 执行相应的操作，展示了回调函数的灵活性。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(17) 语句和作用域","date":"2024-10-27T01:12:20.000Z","path":"2024/10/27/cppbase17/","text":"1. 简单语句1.1 表达式语句描述：在 C++ 中，最常见的简单语句是表达式语句。它由一个表达式组成，并以分号结束。表达式语句可以包括函数调用、赋值操作、增减操作等。 示例代码： 12345678#include &lt;iostream&gt;int main() &#123; int a = 5; // 赋值表达式语句 a = a + 10; // 赋值表达式语句 std::cout &lt;&lt; a; // 函数调用表达式语句 return 0; // return 表达式语句&#125; 讲解： int a = 5; 初始化变量 a，这是一个赋值表达式语句。 a = a + 10; 更新变量 a 的值。 std::cout &lt;&lt; a; 调用了输出流对象的 &lt;&lt; 运算符函数。 return 0; 从 main 函数返回，结束程序。 1.2 声明语句描述：声明语句用于声明变量、函数、类等标识符。 示例代码： 123456789101112131415#include &lt;iostream&gt;// 函数声明int add(int x, int y);int main() &#123; int result = add(3, 4); // 调用函数 std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result; return 0;&#125;// 函数定义int add(int x, int y) &#123; return x + y;&#125; 讲解： int add(int x, int y); 是一个函数声明语句。 int result = add(3, 4); 在 main 中调用函数并声明变量。 int add(int x, int y) &#123; ... &#125; 是函数定义，提供了函数的实现。 2. 语句作用域2.1 作用域的基本概念描述：作用域定义了变量或其他标识符在程序中的可见范围。C++ 中主要有以下几种作用域： **局部作用域 (Local Scope)**：在函数或代码块内部定义的变量，仅在其所在的块内可见。 **全局作用域 (Global Scope)**：在所有函数外部定义的变量，在整个文件中可见。 **命名空间作用域 (Namespace Scope)**：在命名空间内部定义的标识符。 2.2 代码示例123456789101112131415161718192021222324#include &lt;iostream&gt;// 全局变量int globalVar = 10;void display() &#123; // 局部变量 int localVar = 5; std::cout &lt;&lt; &quot;Inside display() - globalVar: &quot; &lt;&lt; globalVar &lt;&lt; &quot;, localVar: &quot; &lt;&lt; localVar &lt;&lt; std::endl;&#125;int main() &#123; std::cout &lt;&lt; &quot;In main() - globalVar: &quot; &lt;&lt; globalVar &lt;&lt; std::endl; // 局部变量 int mainVar = 20; std::cout &lt;&lt; &quot;In main() - mainVar: &quot; &lt;&lt; mainVar &lt;&lt; std::endl; display(); // 尝试访问 display() 中的局部变量（将导致编译错误） // std::cout &lt;&lt; localVar; // 错误：未定义标识符 return 0;&#125; 预期输出： 123In main() - globalVar: 10In main() - mainVar: 20Inside display() - globalVar: 10, localVar: 5 讲解： globalVar 在所有函数中都可见。 mainVar 仅在 main 函数内部可见。 localVar 仅在 display 函数内部可见。 尝试在 main 中访问 display 函数的 localVar 将导致编译错误，因为它不在作用域内。 2.3 代码块作用域描述：通过使用花括号 &#123;&#125;，可以创建新的代码块，从而定义局部作用域。 示例代码： 12345678910111213141516#include &lt;iostream&gt;int main() &#123; int x = 10; std::cout &lt;&lt; &quot;x before block: &quot; &lt;&lt; x &lt;&lt; std::endl; &#123; // 新的代码块 int x = 20; // 局部变量 x，隐藏外部的 x std::cout &lt;&lt; &quot;x inside block: &quot; &lt;&lt; x &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;x after block: &quot; &lt;&lt; x &lt;&lt; std::endl; // 访问外部的 x return 0;&#125; 预期输出： 123x before block: 10x inside block: 20x after block: 10 讲解： 在内部代码块中重新声明了变量 x，该 x 只在代码块内有效，隐藏了外部的 x。 离开代码块后，内部的 x 不再可见，外部的 x 依然有效。 3. 条件语句C++ 提供了多种条件语句，用于根据不同的条件执行不同的代码块。 3.1 if 语句描述：if 语句用于在条件为真时执行特定的代码块。 语法： 123if (condition) &#123; // code to execute if condition is true&#125; 示例代码： 12345678910111213#include &lt;iostream&gt;int main() &#123; int number; std::cout &lt;&lt; &quot;Enter a number: &quot;; std::cin &gt;&gt; number; if (number &gt; 0) &#123; std::cout &lt;&lt; &quot;The number is positive.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 讲解： 用户输入一个数字，如果 number 大于 0，则输出 “The number is positive.”。 3.2 if-else 语句描述：if-else 语句在条件为假时执行另一个代码块。 语法： 12345if (condition) &#123; // code to execute if condition is true&#125; else &#123; // code to execute if condition is false&#125; 示例代码： 123456789101112131415#include &lt;iostream&gt;int main() &#123; int number; std::cout &lt;&lt; &quot;Enter a number: &quot;; std::cin &gt;&gt; number; if (number % 2 == 0) &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is even.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is odd.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 讲解： 判断输入的数字是奇数还是偶数，并输出相应的结果。 3.3 else if 语句描述：else if 允许在多重条件下执行不同的代码块。 语法： 1234567if (condition1) &#123; // code if condition1 is true&#125; else if (condition2) &#123; // code if condition1 is false and condition2 is true&#125; else &#123; // code if both condition1 and condition2 are false&#125; 示例代码： 123456789101112131415161718192021#include &lt;iostream&gt;int main() &#123; int score; std::cout &lt;&lt; &quot;Enter your score (0-100): &quot;; std::cin &gt;&gt; score; if (score &gt;= 90) &#123; std::cout &lt;&lt; &quot;Grade: A&quot; &lt;&lt; std::endl; &#125; else if (score &gt;= 80) &#123; std::cout &lt;&lt; &quot;Grade: B&quot; &lt;&lt; std::endl; &#125; else if (score &gt;= 70) &#123; std::cout &lt;&lt; &quot;Grade: C&quot; &lt;&lt; std::endl; &#125; else if (score &gt;= 60) &#123; std::cout &lt;&lt; &quot;Grade: D&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Grade: F&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 讲解： 根据分数范围判断并输出相应的等级。 3.4 switch 语句描述：switch 语句根据变量的值选择执行的代码块，适用于离散的值。 语法： 1234567891011switch (expression) &#123; case constant1: // code break; case constant2: // code break; // ... default: // code&#125; 示例代码： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; char grade; std::cout &lt;&lt; &quot;Enter your grade (A, B, C, D, F): &quot;; std::cin &gt;&gt; grade; switch (grade) &#123; case &#x27;A&#x27;: std::cout &lt;&lt; &quot;Excellent!&quot; &lt;&lt; std::endl; break; case &#x27;B&#x27;: std::cout &lt;&lt; &quot;Good!&quot; &lt;&lt; std::endl; break; case &#x27;C&#x27;: std::cout &lt;&lt; &quot;Fair!&quot; &lt;&lt; std::endl; break; case &#x27;D&#x27;: std::cout &lt;&lt; &quot;Poor!&quot; &lt;&lt; std::endl; break; case &#x27;F&#x27;: std::cout &lt;&lt; &quot;Fail!&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;Invalid grade.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 讲解： 根据输入的字母等级输出相应的评价。 break 语句防止代码“掉入”下一个 case 中。 4. 迭代语句C++ 提供了多种循环结构，用于重复执行代码块。 4.1 for 循环描述：for 循环用于已知循环次数的情况，结构紧凑。 语法： 123for (initialization; condition; increment) &#123; // code to execute&#125; 示例代码： 123456789101112#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Counting from 1 to 5:&quot; &lt;&lt; std::endl; for (int i = 1; i &lt;= 5; ++i) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 预期输出： 12Counting from 1 to 5:1 2 3 4 5 讲解： 初始化 int i = 1。 条件 i &lt;= 5 为真时执行循环体。 每次循环后执行 ++i，增加 i 的值。 最终输出 1 到 5。 4.2 while 循环描述：while 循环在循环前判断条件，适合未知循环次数的情况。 语法： 123while (condition) &#123; // code to execute&#125; 示例代码： 1234567891011121314#include &lt;iostream&gt;int main() &#123; int count = 1; std::cout &lt;&lt; &quot;Counting from 1 to 5 using while loop:&quot; &lt;&lt; std::endl; while (count &lt;= 5) &#123; std::cout &lt;&lt; count &lt;&lt; &quot; &quot;; ++count; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 预期输出： 12Counting from 1 to 5 using while loop:1 2 3 4 5 讲解： 初始化 count = 1。 条件 count &lt;= 5 为真时执行循环体。 每次循环后 ++count 增加 count 的值。 4.3 do-while 循环描述：do-while 循环在循环后判断条件，保证至少执行一次循环体。 语法： 123do &#123; // code to execute&#125; while (condition); 示例代码： 1234567891011121314#include &lt;iostream&gt;int main() &#123; int count = 1; std::cout &lt;&lt; &quot;Counting from 1 to 5 using do-while loop:&quot; &lt;&lt; std::endl; do &#123; std::cout &lt;&lt; count &lt;&lt; &quot; &quot;; ++count; &#125; while (count &lt;= 5); std::cout &lt;&lt; std::endl; return 0;&#125; 预期输出： 12Counting from 1 to 5 using do-while loop:1 2 3 4 5 讲解： 无论条件是否为真，do 块中的代码至少执行一次。 在本例中，count 从 1 开始，逐步增加到 5。 4.4 嵌套循环描述：一个循环内部嵌套另一个循环，常用于多维数据结构的遍历。 示例代码： 1234567891011#include &lt;iostream&gt;int main() &#123; for (int i = 1; i &lt;= 3; ++i) &#123; std::cout &lt;&lt; &quot;Outer loop iteration &quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; std::endl; for (int j = 1; j &lt;= 2; ++j) &#123; std::cout &lt;&lt; &quot; Inner loop iteration &quot; &lt;&lt; j &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 预期输出： 123456789Outer loop iteration 1: Inner loop iteration 1 Inner loop iteration 2Outer loop iteration 2: Inner loop iteration 1 Inner loop iteration 2Outer loop iteration 3: Inner loop iteration 1 Inner loop iteration 2 讲解： 外层 for 循环控制外层迭代次数。 内层 for 循环在每次外层循环中执行，控制内层迭代次数。 5. 跳转语句跳转语句用于改变程序的执行流。C++ 中主要有 break、continue、return 和 goto。 5.1 break 语句描述：break 用于立即终止最近的循环或 switch 语句。 示例代码（在循环中使用 break）： 123456789101112#include &lt;iostream&gt;int main() &#123; for (int i = 1; i &lt;= 10; ++i) &#123; if (i == 5) &#123; break; // 结束循环 &#125; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; &quot;\\nLoop exited when i == 5.&quot; &lt;&lt; std::endl; return 0;&#125; 预期输出： 121 2 3 4 Loop exited when i == 5. 讲解： 当 i 达到 5 时，break 终止循环，停止进一步的迭代。 5.2 continue 语句描述：continue 用于跳过当前的循环迭代，继续下一次循环。 示例代码： 12345678910111213#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Even numbers between 1 and 10:&quot; &lt;&lt; std::endl; for (int i = 1; i &lt;= 10; ++i) &#123; if (i % 2 != 0) &#123; continue; // 跳过奇数 &#125; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 预期输出： 12Even numbers between 1 and 10:2 4 6 8 10 讲解： 当 i 是奇数时，continue 跳过本次循环，避免执行 std::cout 语句。 仅输出偶数。 5.3 return 语句描述：return 用于从函数中返回一个值或结束函数执行。 示例代码： 123456789101112131415#include &lt;iostream&gt;// 函数，返回两个数中的较大者int max(int a, int b) &#123; if (a &gt; b) &#123; return a; // 返回 a，退出函数 &#125; return b; // 返回 b，退出函数&#125;int main() &#123; int x = 10, y = 20; std::cout &lt;&lt; &quot;The maximum of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; max(x, y) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0;&#125; 预期输出： 1The maximum of 10 and 20 is 20. 讲解： max 函数根据条件返回较大的数，并退出函数执行。 5.4 goto 语句描述：goto 允许无条件跳转到程序中指定的标签。虽然 goto 有时能简化代码，但不推荐频繁使用，因为它会使程序流程难以理解和维护。 示例代码： 1234567891011121314151617#include &lt;iostream&gt;int main() &#123; int number; std::cout &lt;&lt; &quot;Enter a positive number (negative to quit): &quot;; std::cin &gt;&gt; number; if (number &lt; 0) &#123; goto end; // 跳转到 end 标签，结束程序 &#125; std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number &lt;&lt; std::endl;end: std::cout &lt;&lt; &quot;Program ended.&quot; &lt;&lt; std::endl; return 0;&#125; 预期输出（输入为负数）： 12Enter a positive number (negative to quit): -5Program ended. 讲解： 当输入负数时，goto end; 跳转到 end 标签，结束程序。 尽管可以使用 goto，但建议使用更结构化的控制流，如循环和条件语句。 6. 异常处理语句异常处理用于应对程序运行过程中可能出现的错误情况，确保程序的健壮性和可靠性。 6.1 try, catch, 和 throw 语句描述： try 块用于包含可能引发异常的代码。 throw 用于抛出异常。 catch 块用于捕获并处理异常。 基本语法： 12345678try &#123; // code that may throw an exception&#125; catch (ExceptionType1 e1) &#123; // handler for ExceptionType1&#125; catch (ExceptionType2 e2) &#123; // handler for ExceptionType2&#125;// ... 示例代码： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;stdexcept&gt;// 函数，计算除法double divide(double numerator, double denominator) &#123; if (denominator == 0) &#123; throw std::invalid_argument(&quot;Denominator cannot be zero.&quot;); // 抛出异常 &#125; return numerator / denominator;&#125;int main() &#123; double num, denom; std::cout &lt;&lt; &quot;Enter numerator: &quot;; std::cin &gt;&gt; num; std::cout &lt;&lt; &quot;Enter denominator: &quot;; std::cin &gt;&gt; denom; try &#123; double result = divide(num, denom); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; &#125; catch (std::invalid_argument &amp;e) &#123; // 捕获 std::invalid_argument 异常 std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Program continues after try-catch.&quot; &lt;&lt; std::endl; return 0;&#125; 预期输出： 1234Enter numerator: 10Enter denominator: 0Error: Denominator cannot be zero.Program continues after try-catch. 讲解： divide 函数在分母为零时抛出 std::invalid_argument 异常。 try 块尝试执行 divide 函数。 当异常发生时，执行对应的 catch 块，输出错误信息。 程序在异常处理后继续执行，而不会异常终止。 6.2 多重 catch 块描述：可以为 try 块指定多个 catch 块，以处理不同类型的异常。 示例代码： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;stdexcept&gt;int main() &#123; try &#123; // 模拟不同类型的异常 int choice; std::cout &lt;&lt; &quot;Choose exception to throw (1: bad_alloc, 2: invalid_argument): &quot;; std::cin &gt;&gt; choice; if (choice == 1) &#123; throw std::bad_alloc(); &#125; else if (choice == 2) &#123; throw std::invalid_argument(&quot;Invalid argument provided.&quot;); &#125; else &#123; std::cout &lt;&lt; &quot;No exception thrown.&quot; &lt;&lt; std::endl; &#125; &#125; catch (std::bad_alloc &amp;e) &#123; // 处理 bad_alloc 异常 std::cerr &lt;&lt; &quot;Caught std::bad_alloc: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; catch (std::invalid_argument &amp;e) &#123; // 处理 invalid_argument 异常 std::cerr &lt;&lt; &quot;Caught std::invalid_argument: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Program continues after try-catch.&quot; &lt;&lt; std::endl; return 0;&#125; 预期输出（选择 1）： 123Choose exception to throw (1: bad_alloc, 2: invalid_argument): 1Caught std::bad_alloc: std::bad_allocProgram continues after try-catch. 讲解： 根据用户输入抛出不同类型的异常。 对应的 catch 块分别处理不同的异常类型。 如果未匹配的异常被抛出且没有对应的 catch 块，将导致程序终止（未在此示例中展示）。 6.3 throw 通常位置描述：throw 语句可以在任何需要引发异常的位置使用，包括函数内部、嵌套调用中等。 示例代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdexcept&gt;// 函数，检查数组索引int getElement(int arr[], int size, int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw std::out_of_range(&quot;Index is out of range.&quot;); // 抛出异常 &#125; return arr[index];&#125;int main() &#123; int myArray[5] = &#123;10, 20, 30, 40, 50&#125;; int index; std::cout &lt;&lt; &quot;Enter array index (0-4): &quot;; std::cin &gt;&gt; index; try &#123; int value = getElement(myArray, 5, index); std::cout &lt;&lt; &quot;Element at index &quot; &lt;&lt; index &lt;&lt; &quot; is &quot; &lt;&lt; value &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; &#125; catch (std::out_of_range &amp;e) &#123; std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 预期输出（输入为 3）： 12Enter array index (0-4): 3Element at index 3 is 40. 预期输出（输入为 5）： 12Enter array index (0-4): 5Error: Index is out of range. 讲解： getElement 函数检查索引是否有效，如果无效则抛出 std::out_of_range 异常。 main 函数中的 try 块调用 getElement，并在 catch 块中处理异常。 6.4 rethrow 异常描述：可以在 catch 块中使用 throw 语句重新抛出捕获的异常，以便其他部分处理。 示例代码： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;stdexcept&gt;// 函数，抛出异常void func1() &#123; throw std::runtime_error(&quot;Error in func1.&quot;);&#125;// 函数，调用 func1 并重新抛出异常void func2() &#123; try &#123; func1(); &#125; catch (...) &#123; // 捕获所有异常 std::cout &lt;&lt; &quot;func2() caught an exception and is rethrowing it.&quot; &lt;&lt; std::endl; throw; // 重新抛出当前异常 &#125;&#125;int main() &#123; try &#123; func2(); &#125; catch (std::exception &amp;e) &#123; // 在 main 中捕获异常 std::cerr &lt;&lt; &quot;Main caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 预期输出： 12func2() caught an exception and is rethrowing it.Main caught: Error in func1. 讲解： func1 抛出异常。 func2 调用 func1，捕获异常后重新抛出。 main 最终捕获并处理异常。 练习题练习题 1：打印九九乘法表题目描述编写一个 C++ 程序，使用嵌套的 for 循环来打印标准的九九乘法表。输出的格式应整齐对齐，便于阅读。 要求 使用嵌套的 for 循环实现。 输出的乘法表应从 1×1 到 9×9。 每行输出一个数字的乘法结果，例如第 3 行包含 3×1=3 到 3×9=27。 确保输出格式整齐，便于阅读。 示例输出1234567891x1=1 1x2=2 1x3=3 1x4=4 1x5=5 1x6=6 1x7=7 1x8=8 1x9=9 2x1=2 2x2=4 2x3=6 2x4=8 2x5=10 2x6=12 2x7=14 2x8=16 2x9=18 3x1=3 3x2=6 3x3=9 3x4=12 3x5=15 3x6=18 3x7=21 3x8=24 3x9=27 4x1=4 4x2=8 4x3=12 4x4=16 4x5=20 4x6=24 4x7=28 4x8=32 4x9=36 5x1=5 5x2=10 5x3=15 5x4=20 5x5=25 5x6=30 5x7=35 5x8=40 5x9=45 6x1=6 6x2=12 6x3=18 6x4=24 6x5=30 6x6=36 6x7=42 6x8=48 6x9=54 7x1=7 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=49 7x8=56 7x9=63 8x1=8 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=64 8x9=72 9x1=9 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81 提示 使用两个嵌套的 for 循环：外层循环控制行数（1 到 9），内层循环控制列数（1 到 9）。 使用 \\t 或者适当的空格来对齐输出结果。 可以使用 std::cout 进行输出。 参考答案12345678910111213#include &lt;iostream&gt;int main() &#123; // 外层循环控制行数 for (int i = 1; i &lt;= 9; ++i) &#123; // 内层循环控制列数 for (int j = 1; j &lt;= 9; ++j) &#123; std::cout &lt;&lt; i &lt;&lt; &quot;x&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; i * j &lt;&lt; &quot;\\t&quot;; &#125; std::cout &lt;&lt; std::endl; // 每行结束后换行 &#125; return 0;&#125; 练习题 2：实现冒泡排序题目描述编写一个 C++ 程序，使用 冒泡排序算法 对用户输入的一组整数进行排序。冒泡排序是一种简单的排序算法，通过重复交换相邻的未按顺序排列的元素，将最大或最小的元素“冒泡”到序列的一端。 要求 输入：用户输入一组整数，首先输入整数的数量 n，然后输入 n 个整数。 排序：使用冒泡排序算法对输入的整数进行升序排序。 输出：显示排序前和排序后的整数序列。 函数封装：将冒泡排序算法封装在一个独立的函数中，提高代码的模块化和可读性。 示例输入与输出示例 1： 1234请输入整数的数量: 5请输入 5 个整数，用空格分隔: 64 34 25 12 22排序前的数组: 64 34 25 12 22 排序后的数组: 12 22 25 34 64 示例 2： 1234请输入整数的数量: 8请输入 8 个整数，用空格分隔: 5 1 4 2 8 0 2 9排序前的数组: 5 1 4 2 8 0 2 9 排序后的数组: 0 1 2 2 4 5 8 9 提示 冒泡排序的基本思想：通过多次遍历数组，每次比较相邻的元素并交换顺序错误的元素。每一轮遍历后，最大的元素会被移动到数组的末端。 优化：如果在某一轮遍历中没有发生任何交换，说明数组已经有序，可以提前终止排序过程。 函数设计：可以设计一个 bubbleSort 函数接收数组及其大小作为参数，并对数组进行排序。 参考答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;// 冒泡排序函数void bubbleSort(int arr[], int n) &#123; bool swapped; // 外层循环控制总的遍历次数 for (int i = 0; i &lt; n - 1; ++i) &#123; swapped = false; // 内层循环进行相邻元素的比较和交换 for (int j = 0; j &lt; n - i - 1; ++j) &#123; // 如果前一个元素大于后一个元素，则交换它们 if (arr[j] &gt; arr[j + 1]) &#123; std::swap(arr[j], arr[j + 1]); swapped = true; &#125; &#125; // 如果在一轮遍历中没有进行任何交换，数组已经有序 if (!swapped) &#123; break; &#125; &#125;&#125;// 打印数组函数void printArray(int arr[], int n) &#123; for (int i = 0; i &lt; n; ++i) &#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; int n; // 获取数组大小 std::cout &lt;&lt; &quot;请输入整数的数量: &quot;; std::cin &gt;&gt; n; if (n &lt;= 0) &#123; std::cerr &lt;&lt; &quot;错误：数组大小必须为正整数。&quot; &lt;&lt; std::endl; return 1; &#125; int *arr = new int[n]; // 获取数组元素 std::cout &lt;&lt; &quot;请输入 &quot; &lt;&lt; n &lt;&lt; &quot; 个整数，用空格分隔: &quot;; for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; arr[i]; &#125; // 打印排序前的数组 std::cout &lt;&lt; &quot;排序前的数组: &quot;; printArray(arr, n); // 执行冒泡排序 bubbleSort(arr, n); // 打印排序后的数组 std::cout &lt;&lt; &quot;排序后的数组: &quot;; printArray(arr, n); // 释放动态分配的内存 delete[] arr; return 0;&#125; 代码解释 **函数 bubbleSort**： 参数：接收一个整数数组 arr 和数组的大小 n。 逻辑 ： 使用两层 for 循环实现冒泡排序。 外层循环控制需要进行的遍历次数，总共需要 n-1 轮。 内层循环进行相邻元素的比较和交换，每一轮内层循环会将当前未排序部分的最大元素移动到数组的末端。 使用 swapped 标志位优化排序过程，如果一轮内层循环中没有发生任何交换，说明数组已经有序，提前终止排序。 交换操作：使用 std::swap 函数交换两个元素的位置。 **函数 printArray**： 功能：遍历数组并打印每个元素，便于观察排序前后的结果。 main 函数： 步骤 ： 输入数组大小：提示用户输入要排序的整数数量 n。 输入数组元素：动态分配一个大小为 n 的整数数组，并从用户处获取 n 个整数的输入。 打印排序前的数组：调用 printArray 函数显示原始数组。 执行冒泡排序：调用 bubbleSort 函数对数组进行排序。 打印排序后的数组：再次调用 printArray 函数显示排序后的数组。 内存管理：使用 delete[] 释放动态分配的内存，避免内存泄漏。 错误处理： 判断用户输入的数组大小 n 是否为正整数，否者输出错误信息并终止程序。 运行示例1234请输入整数的数量: 5请输入 5 个整数，用空格分隔: 64 34 25 12 22排序前的数组: 64 34 25 12 22 排序后的数组: 12 22 25 34 64 练习题 3：生成斐波那契数列题目描述编写一个 C++ 程序，生成并显示斐波那契数列。程序应允许用户指定生成数列的长度，并使用 循环结构 或 递归方法 来生成斐波那契数。 斐波那契数列是一个由 0 和 1 开始，后续的每个数都是前两个数之和的数列。例如：0, 1, 1, 2, 3, 5, 8, 13, … 要求 输入：用户输入要生成的斐波那契数的数量 n。 生成：使用循环结构（如 for 或 while 循环）生成斐波那契数列。 输出：显示生成的斐波那契数列。 函数封装：将生成斐波那契数列的逻辑封装在一个独立的函数中。 示例输入与输出示例 1： 123请输入要生成的斐波那契数的数量: 10斐波那契数列:0 1 1 2 3 5 8 13 21 34 示例 2： 123请输入要生成的斐波那契数的数量: 5斐波那契数列:0 1 1 2 3 提示 斐波那契数列的定义 ： 第 0 个斐波那契数是 0。 第 1 个斐波那契数是 1。 对于 n &gt;= 2，第 n 个斐波那契数是第 n-1 个数和第 n-2 个数的和。 实现方法 ： 迭代法：使用循环结构依次计算斐波那契数。 递归法（高级）：使用递归函数实现，但效率较低，通常不推荐用于较大的 n。 数据类型：根据 n 的范围选择合适的数据类型，unsigned long long 可以存储较大的斐波那契数。 参考答案（迭代法实现）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;// 生成斐波那契数列的函数（迭代法）std::vector&lt;unsigned long long&gt; generateFibonacci(int n) &#123; std::vector&lt;unsigned long long&gt; fib; if (n &lt;= 0) &#123; // 返回空向量 return fib; &#125; // 第一个斐波那契数 fib.push_back(0); if (n == 1) &#123; return fib; &#125; // 第二个斐波那契数 fib.push_back(1); // 生成后续的斐波那契数 for (int i = 2; i &lt; n; ++i) &#123; unsigned long long next = fib[i - 1] + fib[i - 2]; fib.push_back(next); &#125; return fib;&#125;// 打印斐波那契数列的函数void printFibonacci(const std::vector&lt;unsigned long long&gt; &amp;fib) &#123; for (size_t i = 0; i &lt; fib.size(); ++i) &#123; std::cout &lt;&lt; fib[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; int n; // 获取要生成的斐波那契数的数量 std::cout &lt;&lt; &quot;请输入要生成的斐波那契数的数量: &quot;; std::cin &gt;&gt; n; if (n &lt; 0) &#123; std::cerr &lt;&lt; &quot;错误：数量不能为负数。&quot; &lt;&lt; std::endl; return 1; &#125; // 生成斐波那契数列 std::vector&lt;unsigned long long&gt; fibonacci = generateFibonacci(n); // 打印斐波那契数列 std::cout &lt;&lt; &quot;斐波那契数列:&quot; &lt;&lt; std::endl; printFibonacci(fibonacci); return 0;&#125; 代码解释 **函数 generateFibonacci**： 参数：接收一个整数 n，表示要生成的斐波那契数的数量。 返回值：返回一个 std::vector&lt;unsigned long long&gt;，包含生成的斐波那契数列。 逻辑 ： 如果 n &lt;= 0，返回一个空的向量。 初始化斐波那契数列的前两个数：0 和 1。 使用一个 for 循环，从第三个数开始，依次计算当前数为前两个数之和，并将其添加到向量中。 **函数 printFibonacci**： 参数：接收一个 const 引用的斐波那契数列向量。 功能：遍历并打印斐波那契数列中的每个数，用空格分隔。 main 函数： 步骤 ： 输入数量：提示用户输入要生成的斐波那契数的数量 n。 输入验证：检查 n 是否为负数，若是则输出错误信息并终止程序。 生成数列：调用 generateFibonacci 函数生成斐波那契数列。 打印数列：调用 printFibonacci 函数显示生成的斐波那契数列。 数据类型选择： 使用 unsigned long long 可以存储较大的斐波那契数，避免整数溢出。但需要注意，unsigned long long 的范围有限，对于非常大的 n，仍然会发生溢出。 运行示例123请输入要生成的斐波那契数的数量: 10斐波那契数列:0 1 1 2 3 5 8 13 21 34 递归实现参考代码（可选）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdexcept&gt;// 递归函数，计算第 n 个斐波那契数unsigned long long fibonacciRecursive(int n) &#123; if (n &lt; 0) &#123; throw std::invalid_argument(&quot;n 不能为负数。&quot;); &#125; if (n == 0) return 0; if (n == 1) return 1; return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);&#125;// 生成斐波那契数列的函数（递归实现）std::vector&lt;unsigned long long&gt; generateFibonacciRecursive(int n) &#123; std::vector&lt;unsigned long long&gt; fib; for (int i = 0; i &lt; n; ++i) &#123; fib.push_back(fibonacciRecursive(i)); &#125; return fib;&#125;// 打印斐波那契数列的函数void printFibonacci(const std::vector&lt;unsigned long long&gt; &amp;fib) &#123; for (size_t i = 0; i &lt; fib.size(); ++i) &#123; std::cout &lt;&lt; fib[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; int n; // 获取要生成的斐波那契数的数量 std::cout &lt;&lt; &quot;请输入要生成的斐波那契数的数量: &quot;; std::cin &gt;&gt; n; if (n &lt; 0) &#123; std::cerr &lt;&lt; &quot;错误：数量不能为负数。&quot; &lt;&lt; std::endl; return 1; &#125; try &#123; // 生成斐波那契数列（递归实现） std::vector&lt;unsigned long long&gt; fibonacci = generateFibonacciRecursive(n); // 打印斐波那契数列 std::cout &lt;&lt; &quot;斐波那契数列:&quot; &lt;&lt; std::endl; printFibonacci(fibonacci); &#125; catch (const std::invalid_argument &amp;e) &#123; std::cerr &lt;&lt; &quot;错误：&quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 递归实现说明 优点 ： 代码简洁，符合斐波那契数列的数学定义。 缺点 ： 时间复杂度为指数级 O(2^n)，对于较大的 n 会非常低效。 递归深度过大可能导致栈溢出。 使用场景：适合学习和理解递归概念，但在实际应用中需谨慎使用。 动态规划方法动态规划通过存储已计算的值来避免重复计算，提高了效率。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;// 动态规划实现斐波那契数列std::vector&lt;int&gt; fibonacci_dynamic(int n) &#123; std::vector&lt;int&gt; fib(n); fib[0] = 0; if (n &gt; 1) &#123; fib[1] = 1; &#125; for (int i = 2; i &lt; n; ++i) &#123; fib[i] = fib[i - 1] + fib[i - 2]; &#125; return fib;&#125;int main() &#123; int n; std::cout &lt;&lt; &quot;请输入斐波那契数列的项数: &quot;; std::cin &gt;&gt; n; std::vector&lt;int&gt; fib = fibonacci_dynamic(n); std::cout &lt;&lt; &quot;斐波那契数列的前 &quot; &lt;&lt; n &lt;&lt; &quot; 项为: &quot;; for (int i = 0; i &lt; n; ++i) &#123; std::cout &lt;&lt; fib[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(16) 常见运算符","date":"2024-10-26T03:59:11.000Z","path":"2024/10/26/cppbase16/","text":"导言运算符是编程语言中用于执行特定操作的符号或关键字。在C++中，运算符的使用广泛且多样，掌握运算符的使用对于编写高效、简洁的代码至关重要。本教案旨在全面介绍C++中的各种运算符，帮助学习者深入理解和灵活运用。 运算符概述运算符（Operator） 是用来对变量进行操作的符号或函数。C++中的运算符可分为多种类型，每种运算符具有特定的功能和使用规则。运算符可以单目（仅操作一个操作数）、双目（操作两个操作数）、甚至三目（操作三个操作数）等。 运算符分类C++中的运算符可以根据功能和使用方式分为以下几类： 1. 算术运算符用于执行基本的数学计算。 运算符 描述 示例 + 加法 a + b - 减法 a - b * 乘法 a * b / 除法 a / b % 取模（求余数） a % b ++ 自增（前缀/后缀） ++a, a++ -- 自减（前缀/后缀） --a, a-- 示例： 12345678int a = 10, b = 3;int sum = a + b; // 13int diff = a - b; // 7int prod = a * b; // 30int div = a / b; // 3int mod = a % b; // 1a++; // a = 11--b; // b = 2 2. 关系运算符用于比较两个值之间的关系，返回布尔值（true 或 false）。 运算符 描述 示例 == 等于 a == b != 不等于 a != b &gt; 大于 a &gt; b &lt; 小于 a &lt; b &gt;= 大于或等于 a &gt;= b &lt;= 小于或等于 a &lt;= b 示例： 1234int a = 5, b = 10;bool result1 = (a == b); // falsebool result2 = (a &lt; b); // truebool result3 = (a &gt;= b); // false 3. 逻辑运算符用于组合或反转布尔表达式，返回布尔值。 运算符 描述 示例 &amp;&amp; 逻辑与（AND） a &amp;&amp; b ` ` ! 逻辑非（NOT） !a 示例： 1234bool a = true, b = false;bool result1 = a &amp;&amp; b; // falsebool result2 = a || b; // truebool result3 = !a; // false 4. 位运算符用于按位操作整数类型的二进制位。 运算符 描述 示例 &amp; 按位与 a &amp; b ` ` 按位或 ^ 按位异或（不等时为1） a ^ b ~ 按位取反 ~a &lt;&lt; 左移 a &lt;&lt; 2 &gt;&gt; 右移 a &gt;&gt; 2 示例： 12345678int a = 5; // 二进制：0101int b = 3; // 二进制：0011int andResult = a &amp; b; // 1 (0001)int orResult = a | b; // 7 (0111)int xorResult = a ^ b; // 6 (0110)int notResult = ~a; // -6 (补码)int leftShift = a &lt;&lt; 1; // 10 (1010)int rightShift = a &gt;&gt; 1; // 2 (0010) 5. 赋值运算符用于向变量赋值。 运算符 描述 示例 = 简单赋值 a = b += 加后赋值 a += b -= 减后赋值 a -= b *= 乘后赋值 a *= b /= 除后赋值 a /= b %= 取模后赋值 a %= b &amp;= 按位与后赋值 a &amp;= b ` =` 按位或后赋值 ^= 按位异或后赋值 a ^= b &lt;&lt;= 左移后赋值 a &lt;&lt;= 2 &gt;&gt;= 右移后赋值 a &gt;&gt;= 2 示例： 12345int a = 5;int b = 3;a += b; // a = 8a *= 2; // a = 16a &amp;= b; // a = 16 &amp; 3 = 0 6. 复合赋值运算符结合赋值与其他运算的运算符（如上表中所示的+=, -=, 等）。 示例： 12int a = 10;a += 5; // 等同于 a = a + 5; 结果 a = 15 7. 条件运算符用于基于条件选择值。 运算符 描述 示例 ?: 条件（三目）运算符 a ? b : c 示例： 12int a = 10, b = 20, c;c = (a &gt; b) ? a : b; // c = 20 8. 递增和递减运算符用于增加或减少变量的值，前缀和后缀形式。 运算符 描述 示例 ++ 自增（前缀/后缀） ++a, a++ -- 自减（前缀/后缀） --a, a-- 示例： 123int a = 5;int b = ++a; // a = 6, b = 6int c = a--; // a = 5, c = 6 9. 指针运算符用于操作指针。 运算符 描述 示例 * 间接访问（解引用） *ptr &amp; 取地址 &amp;a -&gt; 成员访问（指向对象的指针） ptr-&gt;member [] 数组下标访问 arr[2] 示例： 123int a = 10;int *ptr = &amp;a;int value = *ptr; // value = 10 10. 成员访问运算符用于访问类或结构体的成员。 运算符 描述 示例 . 直接成员访问 object.member -&gt; 指向成员的指针访问 ptr-&gt;member ::* 指向成员的指针（成员指针操作符） Class::*ptr 示例： 123456789struct Point &#123; int x; int y;&#125;;Point p = &#123;10, 20&#125;;Point *ptr = &amp;p;int a = p.x; // 使用 . 运算符int b = ptr-&gt;y; // 使用 -&gt; 运算符 11. 其他运算符 运算符 描述 示例 sizeof 返回变量或类型所占字节数 sizeof(int) ?: 条件（三目）运算符 a ? b : c , 逗号运算符 a = (b, c) typeid 运行时类型信息运算符 typeid(a) new 动态内存分配 int *ptr = new int; delete 动态内存释放 delete ptr; 示例： 1234int a = 5;int size = sizeof(a); // size = 4 (通常)int b, c;b = (a++, a + 2); // a = 6, b = 8 运算符优先级与结合性运算符的优先级决定了在没有括号明确指定的情况下，哪一个运算符先被计算。结合性则决定了运算符在具有相同优先级时的计算顺序（从左到右或从右到左）。 优先级表以下是C++运算符的优先级从高到低的简要概览： 优先级 运算符类别 运算符 结合性 备注 1 范围解析运算符 :: 左到右 用于访问命名空间或类的成员 2 后缀运算符 (), [], ., -&gt;, ++(后置), --(后置) 左到右 包含函数调用、数组下标、成员访问 3 一元运算符 +, -, !, ~, ++(前置), --(前置), *(解引用), &amp;(取地址), sizeof, typeid 右到左 适用于单个操作数的运算符 4 乘法运算符 *, /, % 左到右 乘法、除法和取模运算 5 加法运算符 +, - 左到右 加法和减法运算 6 移位运算符 &lt;&lt;, &gt;&gt; 左到右 位左移和位右移 7 关系运算符 &lt;, &lt;=, &gt;, &gt;= 左到右 比较运算符 8 相等运算符 ==, != 左到右 判断相等与不相等 9 位与运算符 &amp; 左到右 按位与 10 位异或运算符 ^ 左到右 按位异或 11 位或运算符 ` ` 左到右 12 逻辑与运算符 &amp;&amp; 左到右 逻辑与 13 逻辑或运算符 ` ` 14 条件运算符 ?: 右到左 条件（三目）运算符 15 赋值运算符 =, +=, -=, *=, /=, %=, &amp;=, ` =, ^=, &lt;&lt;=, &gt;&gt;=` 右到左 16 逗号运算符 , 左到右 逗号用于表达式中多个操作 表格说明 优先级：数字越小，优先级越高。即优先级为1的运算符最先被计算。 运算符类别：运算符的功能分类，帮助理解不同类型运算符的用途。 运算符：具体的C++运算符符号。 结合性：当表达式中出现多个相同优先级的运算符时，决定运算顺序的规则。左到右表示从左侧的操作数开始，右到左表示从右侧的操作数开始。 备注：对运算符类别或特定运算符的简要说明。 运算符重载运算符重载（Operator Overloading） 允许开发者为自定义类型（如类和结构体）定义或改变运算符的行为，使其表现得像内置类型一样。这提高了代码的可读性和可维护性。 运算符重载的规则 可重载运算符：几乎所有的运算符都可以被重载，但如 ::, ?:, sizeof 等运算符不能被重载。 至少一个操作数必须是用户定义类型：即至少有一个操作数是类、结构体或联合体类型。 运算符重载不改变运算符的优先级、结合性和操作数数量。 运算符重载的基本语法运算符可以作为成员函数或友元函数进行重载。 成员函数重载示例： 1234567891011class Complex &#123;public: double real, imag; Complex operator+(const Complex &amp;c) &#123; Complex temp; temp.real = real + c.real; temp.imag = imag + c.imag; return temp; &#125;&#125;; 友元函数重载示例： 12345678910111213class Complex &#123;public: double real, imag; friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);&#125;;Complex operator+(const Complex &amp;c1, const Complex &amp;c2) &#123; Complex temp; temp.real = c1.real + c2.real; temp.imag = c1.imag + c2.imag; return temp;&#125; 常见的重载运算符 算术运算符：+, -, *, /, % 关系运算符：==, !=, &lt;, &gt;, &lt;=, &gt;= 逻辑运算符：&amp;&amp;, ||, ! 赋值运算符：=, +=, -=, *=, /= 输入输出运算符：&lt;&lt;, &gt;&gt; 索引运算符：[] 函数调用运算符：() 示例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Complex &#123;public: double real, imag; Complex(double r = 0, double i = 0) : real(r), imag(i) &#123;&#125; // 重载 + 运算符 Complex operator+(const Complex &amp;c) &#123; return Complex(real + c.real, imag + c.imag); &#125; // 重载 &lt;&lt; 运算符（作为友元函数） friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const Complex &amp;c);&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;out, const Complex &amp;c) &#123; out &lt;&lt; c.real &lt;&lt; &quot; + &quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; return out;&#125;int main() &#123; Complex c1(1.2, 3.4); Complex c2(5.6, 7.8); Complex c3 = c1 + c2; cout &lt;&lt; &quot;c1 + c2 = &quot; &lt;&lt; c3 &lt;&lt; endl; // 输出: c1 + c2 = 6.8 + 11.2i return 0;&#125; 练习题1 交换两个数题目： 使用位运算符，交换两个整数变量的值而不使用第三个变量。 答案： 12345678910111213141516#include &lt;iostream&gt;int main() &#123; int x = 15; int y = 27; std::cout &lt;&lt; &quot;Before swap: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl; // 交换操作 x = x ^ y; y = x ^ y; x = x ^ y; std::cout &lt;&lt; &quot;After swap: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl; return 0;&#125; 预期输出： 12Before swap: x = 15, y = 27After swap: x = 27, y = 15 解析： 通过异或运算 ^ 完成变量值的交换，无需使用临时变量。 2 函数修改外部变量题目： 编写一个函数，接受一个整数指针，使用解引用运算符修改其值为原值的平方。 答案： 123456789101112#include &lt;iostream&gt;void square(int* ptr) &#123; *ptr = (*ptr) * (*ptr);&#125;int main() &#123; int num = 5; std::cout &lt;&lt; &quot;Before: &quot; &lt;&lt; num &lt;&lt; std::endl; square(&amp;num); std::cout &lt;&lt; &quot;After: &quot; &lt;&lt; num &lt;&lt; std::endl; return 0;&#125; 预期输出： 12Before: 5After: 25 解析： 通过指针访问并修改原变量的值。 3 计算范围内所有元素的和题目： 编写一个函数，接受 std::vector&lt;int&gt; 的迭代器范围，计算并返回范围内所有元素的和。 函数示例： 须实现如下函数，返回范围内元素求和的结果 1int sumRange(std::vector&lt;int&gt;::iterator start, std::vector&lt;int&gt;::iterator end); 答案： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int sumRange(std::vector&lt;int&gt;::iterator start, std::vector&lt;int&gt;::iterator end) &#123; int sum = 0; while (start != end) &#123; sum += *start; ++start; &#125; return sum;&#125;int main() &#123; std::vector&lt;int&gt; numbers = &#123;2, 4, 6, 8, 10&#125;; int total = sumRange(numbers.begin(), numbers.end()); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; total &lt;&lt; std::endl; return 0;&#125; 预期输出： 1Sum: 30 解析： 函数通过迭代器遍历范围，累加元素值。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(15) 多维数组","date":"2024-10-22T11:01:13.000Z","path":"2024/10/22/cppbase15/","text":"多维数组更多资料可查阅官方博客，官方博客地址：https://llfc.club/ 严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。 当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小： 12// 大小为3的数组，每个元素是大小为4的数组int ia[3][4]; 按照由内而外的顺序阅读此类定义有助于更好地理解其真实含义。 在第一条语句中，我们定义的名字是ia，显然ia是一个含有3个元素的数组。 接着观察右边发现，ia的元素也有自己的维度，所以ia的元素本身又都是含有4个元素的数组。 再观察左边知道，真正存储的元素是整数。因此最后可以明确第一条语句的含义：它定义了一个大小为3的数组，该数组的每个元素都是含有4个整数的数组。 上面的代码可以理解为下面的形式 也可以初始化为 12// 这些数组的元素是含有30个整数的数组int arr[10][20][30] = &#123;0&#125; 使用同样的方式理解arr的定义。 首先arr是一个大小为10的数组，它的每个元素都是大小为20的数组，这些数组的元素又都是含有30个整数的数组。 实际上，定义数组时对下标运算符的数量并没有限制，因此只要愿意就可以定义这样一个数组：它的元素还是数组，下一级数组的元素还是数组，再下一级数组的元素还是数组，以此类推。对于二维数组来说，常把第一个维度称作行，第二个维度称作列。 多维数组的初始化 允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来： 123456789//三个元素，每个元素是大小为4的数组int ia[3][4] =&#123; //第一行的初始值 &#123;0,1,2,3&#125;, //第二行初始值 &#123;4,5,6,7&#125;, //第三行初始值 &#123;8,9,10,11&#125;&#125;; 其中内层嵌套着的花括号并非必需的，例如下面的初始化语句，形式上更为简洁，完成的功能和上面这段代码完全一样： 1int ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;; 类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可： 12//初始化每一行的首元素int ia2[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;; 其他未列出的元素执行默认值初始化，这个过程和一维数组一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了。 12//值初始化第一i行int ix[3][4] = &#123;0,3,5,9&#125;; 含义发生了变化，它初始化的是第一行的4个元素，其他元素被初始化为0。 多维数组的下标引用可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。 如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素； 反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组： 12345678int ia[3][4] = &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;;int arr[1][1][1] = &#123;&#123;&#123;1&#125;&#125;&#125;;// 用arr的首元素为ia的最后一个元素赋值ia[2][3] = arr[0][0][0];//row是一个4维数组的引用,将row绑定到ia的第二个元素(4维数组)上int (&amp;row)[4] = ia[1]; 使用for循环 我们可以使用for循环构建数组 12345678910constexpr size_t rowCnt = 3, colCnt=4;//12 个未初始化的元素int ia[rowCnt][colCnt];//对于每一行for(size_t i = 0; i != rowCnt; ++i)&#123; //对于行内的每一列 for( size_t j = 0; j != colCnt; ++j)&#123; ia[i][j] = i*colCnt + j; &#125;&#125; C++11风格处理多维数组 由于C++11新标准增加了范围for语句，所以前一个程序可以简化为 12345678910constexpr size_t rowCnt = 3, colCnt=4;//12 个未初始化的元素int ia[rowCnt][colCnt];size_t cnt = 0;for(auto &amp;row: ia)&#123; for(auto &amp; col : row)&#123; col = cnt; ++cnt; &#125;&#125; 输出每一个元素 123456for(const auto &amp; row: ia)&#123; for(auto col : row)&#123; std::cout &lt;&lt; col &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125; 输出 1230 1 2 34 5 6 78 9 10 11 指针和多维数组当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 新手雷区 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。 因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针： 123456//大小为3的数组，每个元素是含有4个整数的数组int ia[3][4];//p指向含有4个整数的数组int(*p)[4] = ia;//将p修改为指向ia数组的尾部p = &amp;ia[2]; 随着C++11新标准的提出，通过使用auto或者decltype就能尽可能地避免在数组前面加上一个指针类型了： 12345678910111213// ia数组int ia[3][4] = &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;;//输出ia中每个元素的值,每个内存数组各占一行//p指向含有4个整数的数组for(auto p = ia; p != ia + 3; ++p)&#123; //q指向4个整数的数组的首元素 for(auto q = *p; q != *p + 4; ++q)&#123; std::cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; std::endl;&#125; 使用C++11提供的std::begin也能实现类似的功能 1234567891011121314// ia数组int ia[3][4] = &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;;// p指向ia的第一个数组for(auto p = std::begin(ia); p != std::end(ia); ++p)&#123; // q指向内存数组的首元素 for( auto q = std::begin(*p); q != std::end(*p); ++q)&#123; // 输出q所指的整数值 std::cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; std::endl;&#125; 类型别名简化多维数组指针 可以使用using 进行类型别名的声明，或者使用typedef声明类型的别名 123456789101112131415// ia数组int ia[3][4] = &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;;// 新标准下类型别名的声明using int_array = int[4];// 使用typedef 声明类型的别名typedef int int_array_t[4];for(int_array * p = ia; p != ia + 3; ++p)&#123; for(int *q = *p ; q != *p+4; ++q)&#123; std::cout &lt;&lt; *q &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125; 练习题1：矩阵加法题目描述编写一个C++程序，输入两个2x3的矩阵，计算它们的和，并输出结果矩阵。 示例代码框架123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int main() &#123; const int ROW = 2; const int COL = 3; int matrix1[ROW][COL]; int matrix2[ROW][COL]; int sum[ROW][COL]; // 输入第一个矩阵 std::cout &lt;&lt; &quot;请输入第一个2x3矩阵的元素（共6个整数）:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; // 在此输入元素 &#125; &#125; // 输入第二个矩阵 std::cout &lt;&lt; &quot;请输入第二个2x3矩阵的元素（共6个整数）:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; // 在此输入元素 &#125; &#125; // 计算两个矩阵的和 // 在此实现加法逻辑 // 输出结果矩阵 std::cout &lt;&lt; &quot;两个矩阵的和为:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; // 在此输出sum[i][j] &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125; 预期输出（示例）1234567请输入第一个2x3矩阵的元素（共6个整数）:1 2 3 4 5 6请输入第二个2x3矩阵的元素（共6个整数）:6 5 4 3 2 1两个矩阵的和为:7 7 77 7 7 答案12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;int main() &#123; const int ROW = 2; const int COL = 3; int matrix1[ROW][COL]; int matrix2[ROW][COL]; int sum[ROW][COL]; // 输入第一个矩阵 std::cout &lt;&lt; &quot;请输入第一个2x3矩阵的元素（共6个整数）:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; std::cin &gt;&gt; matrix1[i][j]; &#125; &#125; // 输入第二个矩阵 std::cout &lt;&lt; &quot;请输入第二个2x3矩阵的元素（共6个整数）:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; std::cin &gt;&gt; matrix2[i][j]; &#125; &#125; // 计算两个矩阵的和 for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; sum[i][j] = matrix1[i][j] + matrix2[i][j]; &#125; &#125; // 输出结果矩阵 std::cout &lt;&lt; &quot;两个矩阵的和为:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; std::cout &lt;&lt; sum[i][j] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125; 练习题2：矩阵转置题目描述编写一个C++程序，输入一个3x3的矩阵，计算其转置矩阵，并输出结果。 示例代码框架1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; const int SIZE = 3; int matrix[SIZE][SIZE]; int transpose[SIZE][SIZE]; // 输入原始矩阵 std::cout &lt;&lt; &quot;请输入一个3x3矩阵的元素（共9个整数）:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; SIZE; ++i) &#123; for(int j = 0; j &lt; SIZE; ++j) &#123; // 在此输入matrix[i][j] &#125; &#125; // 计算转置矩阵 // 在此实现转置逻辑 // 输出转置后的矩阵 std::cout &lt;&lt; &quot;矩阵的转置为:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; SIZE; ++i) &#123; for(int j = 0; j &lt; SIZE; ++j) &#123; // 在此输出transpose[i][j] &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125; 预期输出（示例）123456请输入一个3x3矩阵的元素（共9个整数）:1 2 3 4 5 6 7 8 9矩阵的转置为:1 4 72 5 83 6 9 答案123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int main() &#123; const int SIZE = 3; int matrix[SIZE][SIZE]; int transpose[SIZE][SIZE]; // 输入原始矩阵 std::cout &lt;&lt; &quot;请输入一个3x3矩阵的元素（共9个整数）:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; SIZE; ++i) &#123; for(int j = 0; j &lt; SIZE; ++j) &#123; std::cin &gt;&gt; matrix[i][j]; &#125; &#125; // 计算转置矩阵 for(int i = 0; i &lt; SIZE; ++i) &#123; for(int j = 0; j &lt; SIZE; ++j) &#123; transpose[j][i] = matrix[i][j]; &#125; &#125; // 输出转置后的矩阵 std::cout &lt;&lt; &quot;矩阵的转置为:&quot; &lt;&lt; std::endl; for(int i = 0; i &lt; SIZE; ++i) &#123; for(int j = 0; j &lt; SIZE; ++j) &#123; std::cout &lt;&lt; transpose[i][j] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125; 赞赏感谢支持","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(14) 数组知识","date":"2024-10-20T03:24:09.000Z","path":"2024/10/20/cppbase14/","text":"数组概念数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。 与vector对比 相同点 与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。 不同点 与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。 友情提示 如果不清楚元素的确切个数，请使用vector。 定义和初始化内置数组数组是一种复合类型。数组的声明形如 1类型 a[d]; 其中a是数组的名字，d是数组的维度。 维度说明了数组中元素的个数，因此必须大于0。 数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式 关于常量表达式我们可以复习一下 1234//不是常量表达式unsigned int cnt = 42;//常量表达式, 用constexpr修饰constexpr unsigned sz = 42; 定义数组 1234567891011121314int main() &#123; //不是常量表达式 unsigned cnt = 42; //常量表达式, 用constexpr修饰 constexpr unsigned sz = 42; //包含10个整数的数组 int arr[10]; //含有42个整数指针的数组 int *parr[sz]; //定义字符串数组，错误！cnt不是常量表达式,但是部分编译器可通过 std::string bad[cnt]; return 0;&#125; 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 注意 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，此时允许忽略数组的维度。 如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来； 相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值： 1234567891011const unsigned sz = 3;// 含有3个元素的数组，元素值分别是0，1，2int ial[sz] = &#123;0,1,2&#125;;// 维度是3的数组int a2[] = &#123;0,1,2&#125;;//等价于a3[] = &#123;0,1,2,0,0&#125;int a3[5] = &#123;0,1,2&#125;;//等价于a4[] = &#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;std::string a4[3] = &#123;&quot;hi&quot;,&quot;bye&quot;&#125;;//错误，初始值过多//int a5[2] = &#123;0,1,2&#125;; 不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： 1234//含有三个整数的数组int a[] = &#123;0,1,2&#125;;// 错误，不允许使用一个数组初始化另一个数组// int a2[] = a; 友情提示 一些编译器支持数组的赋值，这就是所谓的编译器扩展（compiler extension）。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。 理解复杂的数组声明和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。 在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了： 123456789//ptrs是含有10个整数指针的数组int *ptrs[10];//错误, 不存在引用的数组//int&amp; refs[10] = /*?*/;//Parray指向一个含有10个整数的数组int arr[10] =&#123;0,1,2,3,4,5,6,7,8,9&#125;;int (*Parray)[10] = &amp;arr;//arrRef 引用一个含有10个整数的数组int (&amp;arrRef)[10] = arr; 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 访问数组元素与标准库类型vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问。数组的索引从0开始，以一个包含10个元素的数组为例，它的索引从0到9，而非从1到10。 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。 12345int arr[10] =&#123;0,1,2,3,4,5,6,7,8,9&#125;;for(size_t i = 0; i &lt; sizeof(arr)/sizeof(int); ++i)&#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl; 数组的大小可以用sizeof(arr)获取，要进一步计算获取其中的元素个数，我们可以使用sizeof(arr)/sizeof(int) 防止越界 数组不具备越界检测，所以在使用下标访问数组元素的时候，一定要注意防止越界，不要超过或等于数组元素个数 指针和数组在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。 数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针： 1234567int arr[10] =&#123;0,1,2,3,4,5,6,7,8,9&#125;;// 第一个元素地址std::cout &lt;&lt; &quot;first element: address is &quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;// 数组首地址std::cout &lt;&lt; &quot;arr address is &quot; &lt;&lt; arr &lt;&lt; std::endl;// 数组首地址std::cout &lt;&lt; &quot;arr address is &quot; &lt;&lt; &amp;arr &lt;&lt; std::endl; 数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针： 123//等价于 int * first_elem_addr = &amp;arr[0];int* first_elem_addr = arr;std::cout &lt;&lt; &quot;first element address is &quot; &lt;&lt; first_elem_addr &lt;&lt; std::endl; 在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组 12//ia2是一个int类型的指针,指向ia的第一个元素auto ia2(arr); 当使用decltype关键字时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组： 1234//ia3是一个含有10个整数的数组decltype(arr) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;//错误，不能用整数指针给数组赋值//ia3 = ia2; 指针也是迭代器介绍的内容相比，指向数组元素的指针拥有更多功能。 vector和string的迭代器。支持的运算，数组的指针全都支持。 例如，允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上： 12345int arr[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;//p指向arr的第一个元素int *p = arr;//p指向arr[1]++p; 奇技淫巧 就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。 123456789int arr[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;// e指向arr[10],也就是最后一个元素的下一个位置int *e = arr+10;for(int* b = arr; b != e; ++b)&#123; std::cout &lt;&lt; *b &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl; C++11的改进 为了方便遍历数组，C++11提供了获取最后元素的下一个位置的指针，以及指向首元素的指针 123456int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int * beg = std::begin(ia);int * end = std::end(ia);for(auto it = beg; it != end; ++it)&#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125; 指针运算指向数组元素的指针可以执行的运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。 给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置： 123456constexpr size_t sz = 5;int arr[sz] = &#123;0,1,2,3,4&#125;;//等价于int *ip = &amp;arr[0];int *ip = arr;//ip2int * ip2 = ip + 4; 和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素： 123//计算数组元素个数auto n = std::end(arr) - std::begin(arr);std::cout &lt;&lt; &quot;n is &quot; &lt;&lt; n &lt;&lt; std::endl; 解引用和指针运算的交互指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针： 123int ia[] = &#123;0,2,4,6,8&#125;;int last = *(ia+4);std::cout &lt;&lt; &quot;last is &quot; &lt;&lt; last &lt;&lt; std::endl; 表达式＊（ia+4）计算ia前进4个元素后的新地址，解引用该结果指针的效果等价于表达式ia[4]。 如果写成下面的形式： 123int ia[] = &#123;0,2,4,6,8&#125;;//等价于ia[0] + 4int value = *ia + 4; 下标和指针的关系对数组执行下标运算其实是对指向数组元素的指针解引用 123int ia[] = &#123;0,2,4,6,8&#125;;//等价于ia[1]int value = *(ia+1); C风格字符串 尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。 字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串（C-style character string）。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\\0’）。一般利用指针来操作这些字符串。 1char* msg = &quot;hello world!&quot;; C标准库函数 这些函数可用于操作C风格字符串，它们定义在cstring头文件中，cstring是C语言头文件string.h的C++版本。 函数示例 功能解释 strlen(p) 返回p的长度，空字符不计算在内 strcmp(p1,p2) 比较p1和p2的是否相等，如果相等返回0，如果p1&gt;p2返回一个正值，如果p1&lt;p2返回一个负值 strcat(p1,p2) 将p2附加到p1之后，返回p1 strcpy(p1,p2) 将p2拷贝给p1，返回p1 新手雷区 传入此类函数的指针必须指向以空字符作为结束的数组： 1234char ca[] = &#123;&#x27;C&#x27;,&#x27;P&#x27;,&#x27;P&#x27;&#125;;//有风险，因为ca没有以\\0结束，所以strlen可能访问越界int len = strlen(ca);std::cout &lt;&lt; &quot;len is &quot; &lt;&lt; len &lt;&lt; std::endl; 此例中，ca虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下来。 比较字符串 比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符： 1234567std::string s1 = &quot;A string example&quot;;std::string s2 = &quot;A different string example&quot;;if(s1 &lt; s2)&#123; std::cout &lt;&lt; &quot;s1 is less than s2&quot; &lt;&lt; std::endl;&#125;else&#123; std::cout &lt;&lt; &quot;s1 is not less than s2&quot; &lt;&lt; std::endl;&#125; 如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身： 123456const char ca1[] = &quot;A string example&quot;;const char ca2[] = &quot;A different string example&quot;;//未定义的，视图比较两个无关地址if(ca1 &lt; ca2)&#123;&#125; 要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。如果两个字符串相等，strcmp返回0；如果前面的字符串较大，返回正值；如果后面的字符串较大，返回负值： 123456//和两个string比较大小功能一样if(strcmp(ca1, ca2) &lt; 0)&#123; std::cout &lt;&lt; &quot;ca1 is less than ca2&quot; &lt;&lt; std::endl;&#125;else&#123; std::cout &lt;&lt; &quot;ca1 is not less than ca2&quot; &lt;&lt; std::endl;&#125; 字符串拼接 字符串拼接可采用strcpy 123456char dest[20] = &quot;Hello, &quot;; // 确保有足够的空间const char *src = &quot;World!&quot;;// 使用strcpystrcpy(dest + strlen(dest), src); // 从dest的末尾开始复制srcstd::cout &lt;&lt; &quot;After strcpy: &quot; &lt;&lt; dest &lt;&lt; std::endl; strcat连接 12345// 另一个例子，直接使用strcatconst char *src = &quot;World!&quot;;char anotherDest[40] = &quot;Hello, &quot;;strcat(anotherDest, src);std::cout &lt;&lt; &quot;After strcat: &quot; &lt;&lt; anotherDest &lt;&lt; std::endl; 与旧代码衔接很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和vector类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此，现代的C++程序不得不与那些充满了数组和/或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。 混用string对象和C风格字符串 123std::string s(&quot;Hello World&quot;);//注意返回const char *const char *str = s.c_str(); 顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char＊，从而确保我们不会改变字符数组的内容。 我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。 使用数组初始化vector对象 介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。 相反的，允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了： 12345int int_arr[] = &#123;0,1,2,3,4,5&#125;;std::vector&lt;int&gt; ivec(std::begin(int_arr), std::end(int_arr));for(auto e : ivec)&#123; std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;&#125; 练习题1：题目描述编写一个函数 my_strcpy，其功能与标准库函数 strcpy 类似，用于将源字符串复制到目标字符串中。 函数原型1char* my_strcpy(char* dest, const char* src); 要求 禁止使用标准库中的字符串操作函数（如 strcpy、strlen 等）。 函数应能够正确处理所有合法的C风格字符串，包括空字符串。 确保目标字符串有足够的内存来存放源字符串。 函数应返回目标字符串的指针。 示例代码框架123456789101112131415161718#include &lt;iostream&gt;// 自定义的字符串复制函数char* my_strcpy(char* dest, const char* src) &#123; // 在此实现函数逻辑&#125;int main() &#123; const char* source = &quot;Hello, World!&quot;; char destination[50]; // 确保目标有足够的空间 my_strcpy(destination, source); std::cout &lt;&lt; &quot;Source: &quot; &lt;&lt; source &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Destination: &quot; &lt;&lt; destination &lt;&lt; std::endl; return 0;&#125; 预期输出12Source: Hello, World!Destination: Hello, World! 提示 遍历源字符串，逐个字符复制到目标字符串，直到遇到字符串结束符&#39;\\0&#39;。 不要忘记在目标字符串末尾添加结束符&#39;\\0&#39;。 答案实现12345678910111213141516171819202122232425262728#include &lt;iostream&gt;// 自定义的字符串复制函数char* my_strcpy(char* dest, const char* src) &#123; // 使用一个指针遍历源字符串 char* original_dest = dest; // 保存目标字符串的起始地址 while (*src != &#x27;\\0&#x27;) &#123; // 当源字符不是结束符 *dest = *src; // 复制字符 dest++; // 移动目标指针 src++; // 移动源指针 &#125; *dest = &#x27;\\0&#x27;; // 在目标字符串末尾添加结束符 return original_dest; // 返回目标字符串的起始地址&#125;int main() &#123; const char* source = &quot;Hello, World!&quot;; char destination[50]; // 确保目标有足够的空间 my_strcpy(destination, source); std::cout &lt;&lt; &quot;Source: &quot; &lt;&lt; source &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Destination: &quot; &lt;&lt; destination &lt;&lt; std::endl; return 0;&#125; 代码解释 函数原型: 1char* my_strcpy(char* dest, const char* src); 参数 : dest: 目标字符串的指针，指向预先分配好的足够空间的字符数组。 src: 源字符串的指针，指向需要复制的字符串。 返回值: 返回目标字符串的指针，以便于链式调用。 实现细节: 使用一个临时指针 original_dest 保存 dest 的起始地址，以便在函数结束时返回。 使用一个 while 循环遍历源字符串，逐个字符复制到目标字符串。 当源字符串的当前字符为 &#39;\\0&#39; 时，结束复制，并在目标字符串末尾添加 &#39;\\0&#39; 确保字符串终止。 返回 original_dest 指针。 主函数: 定义一个源字符串 source。 定义一个足够大的目标字符数组 destination。 调用 my_strcpy 函数进行复制。 输出源字符串和目标字符串以验证复制的正确性。 预期输出12Source: Hello, World!Destination: Hello, World! 注意事项 内存分配: 确保 dest 指向的内存区域足够大，以容纳源字符串和结束符 &#39;\\0&#39;。 安全性: 本实现没有进行边界检查。在实际应用中，建议使用更安全的方法，如strncpy，以防止缓冲区溢出。 练习题2：题目描述编写一个函数 my_strcat，其功能与标准库函数 strcat 类似，用于将源字符串追加到目标字符串的末尾。 函数原型1char* my_strcat(char* dest, const char* src); 要求 禁止使用标准库中的字符串操作函数（如 strcat、strlen 等）。 函数应能够正确处理所有合法的C风格字符串，包括空字符串。 确保目标字符串有足够的内存来存放追加后的字符串。 函数应返回目标字符串的指针。 示例代码框架1234567891011121314151617#include &lt;iostream&gt;// 自定义的字符串连接函数char* my_strcat(char* dest, const char* src) &#123; // 在此实现函数逻辑&#125;int main() &#123; char destination[100] = &quot;Hello, &quot;; // 初始内容 const char* source = &quot;World!&quot;; my_strcat(destination, source); std::cout &lt;&lt; &quot;After concatenation: &quot; &lt;&lt; destination &lt;&lt; std::endl; return 0;&#125; 预期输出1After concatenation: Hello, World! 提示 首先找到目标字符串中的结束符&#39;\\0&#39;，然后从那里开始复制源字符串的内容。 确保在追加完成后，目标字符串依然以&#39;\\0&#39;结尾。 答案实现123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;// 自定义的字符串连接函数char* my_strcat(char* dest, const char* src) &#123; char* original_dest = dest; // 保存目标字符串的起始地址 // 找到目标字符串的结束位置 while (*dest != &#x27;\\0&#x27;) &#123; dest++; &#125; // 从源字符串复制字符到目标字符串末尾 while (*src != &#x27;\\0&#x27;) &#123; *dest = *src; dest++; src++; &#125; *dest = &#x27;\\0&#x27;; // 在连接后的字符串末尾添加结束符 return original_dest; // 返回目标字符串的起始地址&#125;int main() &#123; char destination[100] = &quot;Hello, &quot;; // 初始内容 const char* source = &quot;World!&quot;; my_strcat(destination, source); std::cout &lt;&lt; &quot;After concatenation: &quot; &lt;&lt; destination &lt;&lt; std::endl; return 0;&#125; 代码解释 函数原型: 1char* my_strcat(char* dest, const char* src); 参数 : dest: 目标字符串的指针，指向预先分配好的足够空间的字符数组，并且该数组包含一个以 &#39;\\0&#39; 结尾的合法C风格字符串。 src: 源字符串的指针，指向需要追加的字符串。 返回值: 返回目标字符串的指针，以便于链式调用。 实现细节: 使用一个临时指针 original_dest 保存 dest 的起始地址，以便在函数结束时返回。 首先，使用一个 while 循环找到目标字符串 dest 的结束符 &#39;\\0&#39;，使指针 dest 指向字符串的末尾。 然后，使用另一个 while 循环将源字符串 src 的字符一个个复制到 dest 的末尾。 在复制结束后，添加 &#39;\\0&#39; 结束符。 返回 original_dest 指针。 主函数: 初始化目标字符数组 destination 为 &quot;Hello, &quot;，并确保其有足够的空间容纳追加的内容。 定义一个源字符串 source 为 &quot;World!&quot;。 调用 my_strcat 函数将 source 追加到 destination。 输出连接后的字符串以验证结果。 预期输出1After concatenation: Hello, World! 注意事项 内存分配: 确保 dest 指向的内存区域足够大，以容纳原始字符串、追加的字符串以及结束符 &#39;\\0&#39;。 字符串终止: 在追加完成后，务必在目标字符串末尾添加 &#39;\\0&#39;，以确保字符串正确终止。 安全性: 本实现没有进行边界检查。在实际应用中，建议使用更安全的方法，如strncat，以防止缓冲区溢出。 赞赏感谢支持","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(13) 迭代器用法","date":"2024-10-12T03:39:34.000Z","path":"2024/10/12/cppbase13/","text":"迭代器简介迭代器（Iterator）是C++标准模板库（STL）中的一个重要概念，它提供了一种方法，按顺序访问容器（如vector, list, map等）中的元素，而无需暴露容器的内部表示。迭代器就像是一个指针，但它比指针更加安全，因为它只能访问容器内的元素，并且它的类型与容器紧密相关。 使用迭代器和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器。如有下述语句： 1auto b = v.begin(), e = v.end(); //b和e的类型相同 end成员则负责返回指向容器（或string对象）“尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后（off the end）”元素。 这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。 特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。 一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。在上面的例子中，使用auto关键字定义变量b和e，这两个变量的类型也就是begin和end的返回值类型，之后将对相关内容做更详细的介绍。 迭代器运算符表3.6列举了迭代器支持的一些运算。使用==和！=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否则就说这两个迭代器不相等。 和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素。 试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。举个例子，利用下标运算符把string对象的第一个字母改为了大写形式，下面利用迭代器实现同样的功能： 比较运算1234567std::string s(&quot;some string&quot;);//确保s非空if(s.begin() != s.end())&#123; //第一个字母改为大写 auto it = s.begin(); *it = toupper(*it);&#125; 本例和原来的程序一样，首先检查s是否为空，显然通过检查begin和end返回的结果是否一致就能做到这一点。如果返回的结果一样，说明s为空； 如果返回的结果不一样，说明s不为空，此时s中至少包含一个字符。 我们在if内部，声明了一个迭代器变量it并把begin返回的结果赋给它，这样就得到了指示s中第一个字符的迭代器，接下来通过解引用运算符将第一个字符更改为大写形式。 和原来的程序一样，输出结果将是： 1Some string 自增运算 将迭代器从一个元素移动到另外一个元素迭代器使用递增（++）运算符。 来从一个元素移动到下一个元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递增是在整数值上“加1”，迭代器的递增则是将迭代器“向前移动一个位置”。 注意 因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。 把字符串中的第一个单词改为大写 123456std::string s2 = &quot;another string&quot;;for(auto it = s2.begin(); it != s2.end() &amp;&amp; !isspace(*it); ++it) &#123; *it = toupper(*it);&#125;std::cout &lt;&lt; s2 &lt;&lt; std::endl; 输出 1ANOTHER string 循环首先用s.begin的返回值来初始化it，意味着it指示的是s中的第一个字符（如果有的话）。 条件部分检查是否已到达s的尾部，如果尚未到达，则将it解引用的结果传入isspace函数检查是否遇到了空白。 每次迭代的最后，执行++it令迭代器前移一个位置以访问s的下一个字符。 循环体内部和上一个程序if语句内的最后一句话一样，先解引用it，然后将结果传入toupper函数得到该字母对应的大写形式，再把这个大写字母重新赋值给it所指示的字符。 关键概念：泛型编程原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非&lt;进行判断有点儿奇怪， C++程序员习惯性地使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。 之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用的到底是哪种容器类型。 迭代器类型就像不知道string和vector的size_type成员到底是什么类型一样，一般来说我们无须知道迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型： 12345678// 迭代器it, it能读写vector&lt;int&gt;的元素std::vector&lt;int&gt;::iterator it;// it2能读写string对象的字符std::string::iterator it2;// it3只能读元素，不能写元素std::vector&lt;int&gt;::const_iterator it3;// it4只能读字符,不能写字符std::string::const_iterator it4; const_iterator和指向常量的指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。 如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。 12345678std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;// 使用 const_iterator 遍历std::vector&lt;int&gt;::const_iterator it;for (it = numbers.cbegin(); it != numbers.cend(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 读取元素值&#125;std::cout &lt;&lt; std::endl; 术语：迭代器和迭代器类型迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象。 重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。 每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。 begin和end运算符begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator： 123456std::vector&lt;int&gt; v;const std::vector&lt;int&gt; cv;//it1是 vector&lt;int&gt;的迭代器，auto it1 = v.begin();//it2是const vector&lt;int&gt;的迭代器auto it2 = cv.begin(); c++11 如果一个容器非常量，我们也可以通过分别是cbegin和cend：获取对应的常量迭代器 12//it3的类型是vector&lt;int&gt;::const_iteratorauto it3 = v.cbegin(); 结合解引用和成员访问操作解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下所示： 1(*it).empty() (*it).empty()中的圆括号必不可少，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符。 如果不加圆括号，点运算符将由it来执行将报错 完整案例 1234567std::vector&lt;std::string&gt; vs = &#123;&quot;hello&quot;, &quot;world&quot;&#125;;for(auto it = vs.begin(); it != vs.end(); ++it)&#123; //(*it)解引用获取string对象，再次调用empty()方法判断为空 if((*it).empty())&#123; std::cout &lt;&lt; &quot;empty string&quot; &lt;&lt; std::endl; &#125;&#125; 为了简化上述表达式，C++语言定义了箭头运算符（-&gt;）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it-&gt;mem和(*it).mem表达的意思相同。 例如，假设用一个名为text的字符串向量存放文本文件中的数据，其中的元素或者是一句话或者是一个用于表示段落分隔的空字符串。如果要输出text中第一段的内容，可以利用迭代器写一个循环令其遍历text，直到遇到空字符串的元素为止： 123456789//依次输出text的每一行直到遇到第一个空行为止std::vector&lt;std::string&gt; text = &#123; &quot;hello&quot;, &quot;&quot;, &quot;world&quot;,&#125;;for(auto it = text.cbegin(); it != text.cend() &amp;&amp; !it-&gt;empty(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; std::endl;&#125; 我们首先初始化it令其指向text的第一个元素，循环重复执行直至处理完了text的所有元素或者发现某个元素为空。 每次迭代时只要发现还有元素并且尚未遇到空元素，就输出当前正在处理的元素。 值得注意的是，因为循环从头到尾只是读取text的元素而未向其中写值，所以使用了cbegin和cend来控制整个迭代过程。 迭代器失效曾经介绍过，虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。 12345//注意下面逻辑错误，在for循环中push元素导致死循环std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;for(auto i = 0; i &lt; numbers.size(); ++i) &#123; numbers.push_back(i);&#125; 也不要在循环中执行push操作 1234//注意下面逻辑错误，在for循环中push元素导致迭代器失效,也会导致死循环for(auto it = numbers.begin(); it != numbers.end(); ++it) &#123; numbers.push_back(1);&#125; 同样我们执行删除操作也要注意，我们可以通过vector的erase操作删除迭代器指向的元素 12//删除第一个元素numbers.erase(numbers.begin() ); erase会返回删除元素的下一个元素的迭代器 面试题 vector容器存储了一系列数字，在循环中遍历每一个元素，并且删除其中的奇数，要求循环结束，vector元素为偶数，要求时间复杂度o(n) 12345678910111213141516std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;//循环遍历,并删除其中奇数for(auto it = numbers.begin(); it != numbers.end(); ) &#123; // 删除奇数 if(*it % 2 != 0)&#123; it = numbers.erase(it); continue; &#125; ++it;&#125;for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl; 迭代器运算迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算的迭代器。 类似的，也能用==和！=对任意标准库类型的两个有效迭代器，进行比较。 string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算（iterator arithmetic）。 迭代器的算术运算 可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。 执行这样的操作时，结果迭代器或者指示原vector对象（或string对象）内的一个元素，或者指示原vector对象（或string对象）尾元素的下一位置。 举个例子，下面的代码得到一个迭代器，它指向某vector对象中间位置的元素： 123456789std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;//中间位置的迭代器auto mid = numbers.begin() + numbers.size()/2;//判断迭代器是否有效if(mid != numbers.end())&#123; std::cout &lt;&lt; *mid &lt;&lt; std::endl;&#125;else&#123; std::cout &lt;&lt; &quot;mid is end&quot; &lt;&lt; std::endl;&#125; mid指向了中间的元素3 使用迭代器运算使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。 二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜索完成； 如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素； 假如该元素大于要找的元素，则在序列的前半部分继续搜索。 在缩小的范围中计算一个新的中间元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。 下面的程序使用迭代器完成了二分搜索： 123456789101112131415161718192021std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;//二分查找4所在的迭代器为止auto beg = numbers.begin(), end = numbers.end();auto mid = beg + (end - beg) / 2;//二分查找while(mid != end &amp;&amp; *mid != 4)&#123; //4在mid的右边 if(*mid &lt; 4)&#123; beg = mid + 1; &#125;else&#123; //4在mid的左边 end = mid; &#125; mid = beg + (end - beg) / 2;&#125;if(mid != end)&#123; std::cout &lt;&lt; &quot;4 is found&quot; &lt;&lt; std::endl;&#125;else&#123; std::cout &lt;&lt; &quot;4 is not found&quot; &lt;&lt; std::endl;&#125; 程序的一开始定义了三个迭代器：beg指向搜索范围内的第一个元素、end指向尾元素的下一位置、mid指向中间的那个元素。 初始状态下，搜索范围是名为numbers的vector&lt;int&gt;的全部范围。 循环部分先检查搜索范围是否为空，如果mid和end的当前值相等，说明已经找遍了所有元素。 此时条件不满足，循环终止。当搜索范围不为空时，可知mid指向了某个元素，检查该元素是否就是我们所要搜索的，如果是，也终止循环。 当进入到循环体内部后，程序通过某种规则移动beg或者end来缩小搜索的范围。 如果mid所指的元素比要找的元素4大，可推测若numbers含有4，则必出现在mid所指元素的前面。此时，可以忽略mid后面的元素不再查找，并把mid赋给end即可。 另一种情况，如果＊mid比4小，则要找的元素必出现在mid所指元素的后面。此时，通过令beg指向mid的下一个位置即可改变搜索范围。因为已经验证过mid不是我们要找的对象，所以在接下来的搜索中不必考虑它。 循环过程终止时，mid或者等于end或者指向要找的元素。如果mid等于end，说明numbers中没有我们要找的元素。 练习题1 相邻元素的和题目描述： 编写一个程序，读取一组整数到一个 std::vector 中，并打印每对相邻元素的和。例如，给定输入 1 2 3 4，输出应为 3 5 7。 代码示例： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; numbers; int num; std::cout &lt;&lt; &quot;请输入一组整数（以 -1 结束）: &quot;; while (std::cin &gt;&gt; num &amp;&amp; num != -1) &#123; numbers.push_back(num); &#125; std::cout &lt;&lt; &quot;相邻元素的和: &quot;; for (auto it = numbers.begin(); it + 1 != numbers.end(); ++it) &#123; std::cout &lt;&lt; (*it + *(it + 1)) &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 答案： 输入示例：1 2 3 4 -1 输出示例：相邻元素的和: 3 5 7 2 反向打印描述： 编写一个程序，从用户输入一组整数到一个 std::vector 中，然后使用迭代器反向打印这些元素。 代码： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; numbers; int input; std::cout &lt;&lt; &quot;请输入一组整数（输入-1结束输入）：\\n&quot;; while (std::cin &gt;&gt; input &amp;&amp; input != -1) &#123; numbers.push_back(input); &#125; std::cout &lt;&lt; &quot;反向打印结果：&quot;; for (std::vector&lt;int&gt;::reverse_iterator it = numbers.rbegin(); it != numbers.rend(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 示例输入： 11 2 3 4 5 -1 示例输出： 1反向打印结果：5 4 3 2 1 3 合并两个 vector描述： 编写一个程序，创建两个 std::vector，从用户输入填充它们。使用迭代器将这两个 vector 合并为一个新 vector。 代码： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vector1, vector2, mergedVector; int input; std::cout &lt;&lt; &quot;请输入第一个向量的整数（输入-1结束输入）：\\n&quot;; while (std::cin &gt;&gt; input &amp;&amp; input != -1) &#123; vector1.push_back(input); &#125; std::cout &lt;&lt; &quot;请输入第二个向量的整数（输入-1结束输入）：\\n&quot;; while (std::cin &gt;&gt; input &amp;&amp; input != -1) &#123; vector2.push_back(input); &#125; // 合并两个向量 mergedVector.insert(mergedVector.end(), vector1.begin(), vector1.end()); mergedVector.insert(mergedVector.end(), vector2.begin(), vector2.end()); std::cout &lt;&lt; &quot;合并后的向量结果：&quot;; for (std::vector&lt;int&gt;::iterator it = mergedVector.begin(); it != mergedVector.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 示例输入： 121 2 3 -14 5 6 -1 示例输出： 1合并后的向量结果：1 2 3 4 5 6","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(12) vector类用法","date":"2024-10-04T04:50:11.000Z","path":"2024/10/04/cppbase12/","text":"1. 引言什么是向量（Vector）？向量（Vector）是 C++ 标准模板库（STL）中的一种序列容器，能够动态地管理可变大小的数组。与传统的固定大小的数组不同，向量可以根据需要随时调整其大小，提供更高的灵活性和便利性。 向量与数组的比较 特性 数组（Array） 向量（Vector） 大小 固定大小（编译时或运行时） 动态可变大小 内存管理 手动管理（需要预留足够空间） 自动管理（自动扩展或收缩） 支持的操作 限制较多 丰富的成员函数和操作 安全性 较低（易发生缓冲区溢出） 较高（通过成员函数进行边界检查） 与 STL 算法的兼容性 低 高 2. std::vector 基础2.1 包含头文件使用 std::vector 需要包含 &lt;vector&gt; 头文件： 1#include &lt;vector&gt; 2.2 定义与初始化定义一个整数向量： 1std::vector&lt;int&gt; numbers; 定义一个字符串向量： 1234#include &lt;vector&gt;#include &lt;string&gt;std::vector&lt;std::string&gt; words; 初始化向量： 默认初始化： 1std::vector&lt;int&gt; vec1; // 空向量 指定大小和默认值： 1std::vector&lt;int&gt; vec2(5, 10); // 5个元素，值均为10 使用初始化列表： 1std::vector&lt;int&gt; vec3 = &#123;1, 2, 3, 4, 5&#125;; 拷贝构造： 1std::vector&lt;int&gt; vec4(vec3); // 复制vec3 移动构造： 1std::vector&lt;int&gt; vec5(std::move(vec4)); // 移动vec4到vec5 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; // 默认初始化 std::vector&lt;int&gt; vec1; // 指定大小和默认值 std::vector&lt;int&gt; vec2(5, 10); // 使用初始化列表 std::vector&lt;int&gt; vec3 = &#123;1, 2, 3, 4, 5&#125;; // 拷贝构造 std::vector&lt;int&gt; vec4(vec3); // 移动构造 std::vector&lt;int&gt; vec5(std::move(vec4)); // 输出vec2 std::cout &lt;&lt; &quot;vec2: &quot;; for(auto num : vec2) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出vec3 std::cout &lt;&lt; &quot;vec3: &quot;; for(auto num : vec3) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出vec5 std::cout &lt;&lt; &quot;vec5: &quot;; for(auto num : vec5) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出： 123vec2: 10 10 10 10 10 vec3: 1 2 3 4 5 vec5: 1 2 3 4 5 2.3 向量的大小与容量 **size()**：返回向量中元素的数量。 **capacity()**：返回向量目前为止分配的存储容量。 **empty()**：检查向量是否为空。 示例代码： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;; std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; vec.size() &lt;&lt; std::endl; // 输出: 3 std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 输出: 3（或更大，取决于实现） std::cout &lt;&lt; &quot;Is empty? &quot; &lt;&lt; (vec.empty() ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; std::endl; // 输出: No vec.reserve(10); // 预留容量 std::cout &lt;&lt; &quot;After reserve(10), Capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 输出: 10 vec.shrink_to_fit(); // 收缩到适合大小 std::cout &lt;&lt; &quot;After shrink_to_fit(), Capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 输出: 3 return 0;&#125; 输出示例： 12345Size: 3Capacity: 3Is empty? NoAfter reserve(10), Capacity: 10After shrink_to_fit(), Capacity: 3 注意： capacity() 并不一定精确匹配 size()，它表示在需要重新分配内存之前，向量可以容纳的元素数量。 3. 向量的基本操作3.1 添加与删除元素 **push_back()**：在向量末尾添加一个元素。 **pop_back()**：移除向量末尾的元素。 **insert()**：在指定位置插入元素。 **erase()**：移除指定位置的元素或范围内的元素。 **clear()**：移除所有元素。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec; // 使用push_back添加元素 vec.push_back(10); vec.push_back(20); vec.push_back(30); std::cout &lt;&lt; &quot;After push_back: &quot;; for(auto num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 10 20 30 // 使用pop_back移除最后一个元素 vec.pop_back(); std::cout &lt;&lt; &quot;After pop_back: &quot;; for(auto num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 10 20 // 在第二个位置插入25 vec.insert(vec.begin() + 1, 25); std::cout &lt;&lt; &quot;After insert: &quot;; for(auto num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 10 25 20 // 删除第二个元素（25） vec.erase(vec.begin() + 1); std::cout &lt;&lt; &quot;After erase: &quot;; for(auto num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 10 20 // 清空向量 vec.clear(); std::cout &lt;&lt; &quot;After clear, size: &quot; &lt;&lt; vec.size() &lt;&lt; std::endl; // 输出: 0 return 0;&#125; 输出： 12345After push_back: 10 20 30 After pop_back: 10 20 After insert: 10 25 20 After erase: 10 20 After clear, size: 0 3.2 访问元素 **operator[]**：通过索引访问元素。 **at()**：通过索引访问元素，带边界检查。 **front()**：访问第一个元素。 **back()**：访问最后一个元素。 示例代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;std::string&gt; fruits = &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;&#125;; // 使用operator[]访问元素 std::cout &lt;&lt; &quot;First fruit: &quot; &lt;&lt; fruits[0] &lt;&lt; std::endl; // 输出: Apple // 使用at()访问元素 try &#123; std::cout &lt;&lt; &quot;Second fruit: &quot; &lt;&lt; fruits.at(1) &lt;&lt; std::endl; // 输出: Banana std::cout &lt;&lt; &quot;Invalid fruit: &quot; &lt;&lt; fruits.at(5) &lt;&lt; std::endl; // 抛出异常 &#125; catch(const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; // 使用front()和back() std::cout &lt;&lt; &quot;Front: &quot; &lt;&lt; fruits.front() &lt;&lt; std::endl; // 输出: Apple std::cout &lt;&lt; &quot;Back: &quot; &lt;&lt; fruits.back() &lt;&lt; std::endl; // 输出: Cherry return 0;&#125; 输出： 12345First fruit: AppleSecond fruit: BananaException: vector::_M_range_check: __n (which is 5) &gt;= this-&gt;size() (which is 3)Front: AppleBack: Cherry 3.3 遍历向量 使用范围 for 循环 使用传统 for 循环 使用迭代器 示例代码： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;; // 使用范围 for 循环 std::cout &lt;&lt; &quot;Using range-based for loop: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 使用传统 for 循环 std::cout &lt;&lt; &quot;Using traditional for loop: &quot;; for(size_t i = 0; i &lt; numbers.size(); ++i) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 使用迭代器 std::cout &lt;&lt; &quot;Using iterators: &quot;; for(auto it = numbers.begin(); it != numbers.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出： 123Using range-based for loop: 1 2 3 4 5 Using traditional for loop: 1 2 3 4 5 Using iterators: 1 2 3 4 5 3.4 修改元素 通过索引或迭代器修改 使用 assign() 重新赋值 替换整个向量内容 示例代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;10, 20, 30, 40, 50&#125;; // 通过索引修改元素 vec[2] = 35; // 使用 at() 修改元素 vec.at(4) = 55; // 使用迭代器修改元素 for(auto it = vec.begin(); it != vec.end(); ++it) &#123; if(*it == 20) &#123; *it = 25; &#125; &#125; // 输出修改后的向量 std::cout &lt;&lt; &quot;Modified vector: &quot;; for(auto num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 10 25 35 40 55 return 0;&#125; 输出： 1Modified vector: 10 25 35 40 55 4. 向量的高级用法4.1 嵌套向量（二维向量）向量可以包含其他向量，形成多维数组结构。 示例代码：二维向量 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; // 定义一个3x4的二维向量，初始化为0 std::vector&lt;std::vector&lt;int&gt;&gt; matrix(3, std::vector&lt;int&gt;(4, 0)); // 填充矩阵 for(int i = 0; i &lt; 3; ++i) &#123; for(int j = 0; j &lt; 4; ++j) &#123; matrix[i][j] = i * 4 + j + 1; &#125; &#125; // 输出矩阵 std::cout &lt;&lt; &quot;Matrix:&quot; &lt;&lt; std::endl; for(auto row : matrix) &#123; for(auto elem : row) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot;\\t&quot;; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 1234Matrix:1 2 3 4 5 6 7 8 9 10 11 12 4.2 向量与其他数据结构结合向量可以与结构体、类等其他数据结构结合使用，增强数据组织能力。 示例代码：向量与结构体结合 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;// 定义学生结构体struct Student &#123; int id; std::string name; float grade;&#125;;int main() &#123; // 定义一个学生向量 std::vector&lt;Student&gt; students; // 添加学生 students.push_back(&#123;1001, &quot;Alice&quot;, 89.5&#125;); students.push_back(&#123;1002, &quot;Bob&quot;, 92.0&#125;); students.push_back(&#123;1003, &quot;Charlie&quot;, 85.0&#125;); // 遍历并输出学生信息 for(const auto&amp; student : students) &#123; std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; student.id &lt;&lt; &quot;, Name: &quot; &lt;&lt; student.name &lt;&lt; &quot;, Grade: &quot; &lt;&lt; student.grade &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 123ID: 1001, Name: Alice, Grade: 89.5ID: 1002, Name: Bob, Grade: 92ID: 1003, Name: Charlie, Grade: 85 4.3 使用迭代器操作向量迭代器是一种指针类型，用于遍历和操作容器中的元素。 示例代码：使用迭代器 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;10, 20, 30, 40, 50&#125;; // 使用迭代器遍历并修改元素 for(auto it = vec.begin(); it != vec.end(); ++it) &#123; *it += 5; &#125; // 输出修改后的向量 std::cout &lt;&lt; &quot;After modifying: &quot;; for(auto it = vec.begin(); it != vec.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 15 25 35 45 55 return 0;&#125; 输出： 1After modifying: 15 25 35 45 55 5. 常用算法与向量5.1 排序可以使用 &lt;algorithm&gt; 头文件中的 sort() 函数对向量进行排序。 示例代码：对整数向量排序 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; numbers = &#123;50, 20, 40, 10, 30&#125;; // 排序前 std::cout &lt;&lt; &quot;Before sorting: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 使用sort()排序 std::sort(numbers.begin(), numbers.end()); // 排序后 std::cout &lt;&lt; &quot;After sorting: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出： 12Before sorting: 50 20 40 10 30 After sorting: 10 20 30 40 50 自定义排序规则：降序 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; numbers = &#123;50, 20, 40, 10, 30&#125;; // 使用sort()并传入lambda表达式进行降序排序 std::sort(numbers.begin(), numbers.end(), [](int a, int b) &#123; return a &gt; b; &#125;); // 输出排序后的向量 std::cout &lt;&lt; &quot;After sorting in descending order: &quot;; for(auto num : numbers) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出： 1After sorting in descending order: 50 40 30 20 10 5.2 反转使用 reverse() 函数可以反转向量中的元素顺序。 示例代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;char&gt; letters = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;&#125;; std::cout &lt;&lt; &quot;Before reversing: &quot;; for(auto c : letters) &#123; std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 反转向量 std::reverse(letters.begin(), letters.end()); std::cout &lt;&lt; &quot;After reversing: &quot;; for(auto c : letters) &#123; std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出： 12Before reversing: A B C D E After reversing: E D C B A 5.3 查找使用 find() 函数可以在向量中查找特定元素。 示例代码： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;std::string&gt; fruits = &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;, &quot;Date&quot;&#125;; std::string target = &quot;Cherry&quot;; // 使用find()查找元素 auto it = std::find(fruits.begin(), fruits.end(), target); if(it != fruits.end()) &#123; std::cout &lt;&lt; target &lt;&lt; &quot; found at position &quot; &lt;&lt; std::distance(fruits.begin(), it) &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; target &lt;&lt; &quot; not found.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 1Cherry found at position 2 6. 向量的性能与优化6.1 内存管理向量会动态地管理内存，自动调整其容量以适应新增或删除的元素。频繁的内存分配可能会影响性能。 6.2 预留空间使用 reserve() 可以提前为向量分配足够的内存，减少内存重新分配的次数，提高性能。 示例代码： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec; // 预留空间 vec.reserve(1000); std::cout &lt;&lt; &quot;Capacity after reserve(1000): &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 添加元素 for(int i = 0; i &lt; 1000; ++i) &#123; vec.push_back(i); &#125; std::cout &lt;&lt; &quot;Size after adding elements: &quot; &lt;&lt; vec.size() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Capacity after adding elements: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; return 0;&#125; 输出示例： 123Capacity after reserve(1000): 1000Size after adding elements: 1000Capacity after adding elements: 1000 6.3 收缩容量使用 shrink_to_fit() 可以请求收缩向量的容量以匹配其大小，释放多余的内存。 示例代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec; // 预留较大的空间 vec.reserve(1000); std::cout &lt;&lt; &quot;Capacity before adding: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 添加少量元素 vec.push_back(1); vec.push_back(2); vec.push_back(3); std::cout &lt;&lt; &quot;Size after adding: &quot; &lt;&lt; vec.size() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Capacity after adding: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 收缩容量 vec.shrink_to_fit(); std::cout &lt;&lt; &quot;Capacity after shrink_to_fit: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; return 0;&#125; 输出示例： 1234Capacity before adding: 1000Size after adding: 3Capacity after adding: 1000Capacity after shrink_to_fit: 3 7. 示例项目示例项目1：学生信息管理系统需求分析： 创建一个程序，管理学生的信息，包括添加、删除、显示和查找学生。每个学生包含ID、姓名和成绩。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;// 定义学生结构体struct Student &#123; int id; std::string name; float grade;&#125;;// 打印学生信息void printStudent(const Student&amp; student) &#123; std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; student.id &lt;&lt; &quot;, Name: &quot; &lt;&lt; student.name &lt;&lt; &quot;, Grade: &quot; &lt;&lt; student.grade &lt;&lt; std::endl;&#125;// 添加学生void addStudent(std::vector&lt;Student&gt;&amp; students) &#123; Student s; std::cout &lt;&lt; &quot;Enter Student ID: &quot;; std::cin &gt;&gt; s.id; std::cout &lt;&lt; &quot;Enter Student Name: &quot;; std::cin.ignore(); // 忽略之前输入的换行符 std::getline(std::cin, s.name); std::cout &lt;&lt; &quot;Enter Student Grade: &quot;; std::cin &gt;&gt; s.grade; students.push_back(s); std::cout &lt;&lt; &quot;Student added successfully.\\n&quot;;&#125;// 删除学生void deleteStudent(std::vector&lt;Student&gt;&amp; students) &#123; int id; std::cout &lt;&lt; &quot;Enter Student ID to delete: &quot;; std::cin &gt;&gt; id; auto it = std::find_if(students.begin(), students.end(), [id](const Student&amp; s) &#123; return s.id == id; &#125;); if(it != students.end()) &#123; students.erase(it); std::cout &lt;&lt; &quot;Student deleted successfully.\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Student with ID &quot; &lt;&lt; id &lt;&lt; &quot; not found.\\n&quot;; &#125;&#125;// 显示所有学生void displayStudents(const std::vector&lt;Student&gt;&amp; students) &#123; if(students.empty()) &#123; std::cout &lt;&lt; &quot;No students available.\\n&quot;; return; &#125; std::cout &lt;&lt; &quot;Student List:\\n&quot;; for(const auto&amp; s : students) &#123; printStudent(s); &#125;&#125;// 查找学生void findStudent(const std::vector&lt;Student&gt;&amp; students) &#123; int id; std::cout &lt;&lt; &quot;Enter Student ID to find: &quot;; std::cin &gt;&gt; id; auto it = std::find_if(students.begin(), students.end(), [id](const Student&amp; s) &#123; return s.id == id; &#125;); if(it != students.end()) &#123; std::cout &lt;&lt; &quot;Student Found:\\n&quot;; printStudent(*it); &#125; else &#123; std::cout &lt;&lt; &quot;Student with ID &quot; &lt;&lt; id &lt;&lt; &quot; not found.\\n&quot;; &#125;&#125;int main() &#123; std::vector&lt;Student&gt; students; int choice; do &#123; std::cout &lt;&lt; &quot;\\n=== Student Management System ===\\n&quot;; std::cout &lt;&lt; &quot;1. Add Student\\n&quot;; std::cout &lt;&lt; &quot;2. Delete Student\\n&quot;; std::cout &lt;&lt; &quot;3. Display All Students\\n&quot;; std::cout &lt;&lt; &quot;4. Find Student by ID\\n&quot;; std::cout &lt;&lt; &quot;5. Exit\\n&quot;; std::cout &lt;&lt; &quot;Enter your choice (1-5): &quot;; std::cin &gt;&gt; choice; switch(choice) &#123; case 1: addStudent(students); break; case 2: deleteStudent(students); break; case 3: displayStudents(students); break; case 4: findStudent(students); break; case 5: std::cout &lt;&lt; &quot;Exiting the system.\\n&quot;; break; default: std::cout &lt;&lt; &quot;Invalid choice. Please choose between 1-5.\\n&quot;; &#125; &#125; while(choice != 5); return 0;&#125; 运行示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354=== Student Management System ===1. Add Student2. Delete Student3. Display All Students4. Find Student by ID5. ExitEnter your choice (1-5): 1Enter Student ID: 1001Enter Student Name: AliceEnter Student Grade: 89.5Student added successfully.=== Student Management System ===1. Add Student2. Delete Student3. Display All Students4. Find Student by ID5. ExitEnter your choice (1-5): 1Enter Student ID: 1002Enter Student Name: BobEnter Student Grade: 92Student added successfully.=== Student Management System ===1. Add Student2. Delete Student3. Display All Students4. Find Student by ID5. ExitEnter your choice (1-5): 3Student List:ID: 1001, Name: Alice, Grade: 89.5ID: 1002, Name: Bob, Grade: 92=== Student Management System ===1. Add Student2. Delete Student3. Display All Students4. Find Student by ID5. ExitEnter your choice (1-5): 4Enter Student ID to find: 1001Student Found:ID: 1001, Name: Alice, Grade: 89.5=== Student Management System ===1. Add Student2. Delete Student3. Display All Students4. Find Student by ID5. ExitEnter your choice (1-5): 5Exiting the system. 代码解析： 结构体定义： 定义了一个 Student 结构体，包含 id、name 和 grade。 功能函数： addStudent：添加新学生。 deleteStudent：根据 ID 删除学生。 displayStudents：显示所有学生的信息。 findStudent：根据 ID 查找并显示学生信息。 主函数： 提供一个菜单驱动的用户界面，允许用户选择不同的操作。 示例项目2：动态库存管理系统需求分析： 创建一个程序，管理库存中的商品信息，包括添加、删除、更新和显示商品。每个商品包含商品ID、名称和数量。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;// 定义商品结构体struct Product &#123; int id; std::string name; int quantity;&#125;;// 打印商品信息void printProduct(const Product&amp; product) &#123; std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; product.id &lt;&lt; &quot;, Name: &quot; &lt;&lt; product.name &lt;&lt; &quot;, Quantity: &quot; &lt;&lt; product.quantity &lt;&lt; std::endl;&#125;// 添加商品void addProduct(std::vector&lt;Product&gt;&amp; products) &#123; Product p; std::cout &lt;&lt; &quot;Enter Product ID: &quot;; std::cin &gt;&gt; p.id; std::cout &lt;&lt; &quot;Enter Product Name: &quot;; std::cin.ignore(); // 忽略之前输入的换行符 std::getline(std::cin, p.name); std::cout &lt;&lt; &quot;Enter Product Quantity: &quot;; std::cin &gt;&gt; p.quantity; products.push_back(p); std::cout &lt;&lt; &quot;Product added successfully.\\n&quot;;&#125;// 删除商品void deleteProduct(std::vector&lt;Product&gt;&amp; products) &#123; int id; std::cout &lt;&lt; &quot;Enter Product ID to delete: &quot;; std::cin &gt;&gt; id; auto it = std::find_if(products.begin(), products.end(), [id](const Product&amp; p) &#123; return p.id == id; &#125;); if(it != products.end()) &#123; products.erase(it); std::cout &lt;&lt; &quot;Product deleted successfully.\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Product with ID &quot; &lt;&lt; id &lt;&lt; &quot; not found.\\n&quot;; &#125;&#125;// 更新商品数量void updateProductQuantity(std::vector&lt;Product&gt;&amp; products) &#123; int id, newQty; std::cout &lt;&lt; &quot;Enter Product ID to update: &quot;; std::cin &gt;&gt; id; auto it = std::find_if(products.begin(), products.end(), [id](const Product&amp; p) &#123; return p.id == id; &#125;); if(it != products.end()) &#123; std::cout &lt;&lt; &quot;Enter new quantity: &quot;; std::cin &gt;&gt; newQty; it-&gt;quantity = newQty; std::cout &lt;&lt; &quot;Product quantity updated successfully.\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Product with ID &quot; &lt;&lt; id &lt;&lt; &quot; not found.\\n&quot;; &#125;&#125;// 显示所有商品void displayProducts(const std::vector&lt;Product&gt;&amp; products) &#123; if(products.empty()) &#123; std::cout &lt;&lt; &quot;No products available.\\n&quot;; return; &#125; std::cout &lt;&lt; &quot;Product List:\\n&quot;; for(const auto&amp; p : products) &#123; printProduct(p); &#125;&#125;int main() &#123; std::vector&lt;Product&gt; products; int choice; do &#123; std::cout &lt;&lt; &quot;\\n=== Inventory Management System ===\\n&quot;; std::cout &lt;&lt; &quot;1. Add Product\\n&quot;; std::cout &lt;&lt; &quot;2. Delete Product\\n&quot;; std::cout &lt;&lt; &quot;3. Update Product Quantity\\n&quot;; std::cout &lt;&lt; &quot;4. Display All Products\\n&quot;; std::cout &lt;&lt; &quot;5. Exit\\n&quot;; std::cout &lt;&lt; &quot;Enter your choice (1-5): &quot;; std::cin &gt;&gt; choice; switch(choice) &#123; case 1: addProduct(products); break; case 2: deleteProduct(products); break; case 3: updateProductQuantity(products); break; case 4: displayProducts(products); break; case 5: std::cout &lt;&lt; &quot;Exiting the system.\\n&quot;; break; default: std::cout &lt;&lt; &quot;Invalid choice. Please choose between 1-5.\\n&quot;; &#125; &#125; while(choice != 5); return 0;&#125; 运行示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465=== Inventory Management System ===1. Add Product2. Delete Product3. Update Product Quantity4. Display All Products5. ExitEnter your choice (1-5): 1Enter Product ID: 2001Enter Product Name: LaptopEnter Product Quantity: 50Product added successfully.=== Inventory Management System ===1. Add Product2. Delete Product3. Update Product Quantity4. Display All Products5. ExitEnter your choice (1-5): 1Enter Product ID: 2002Enter Product Name: SmartphoneEnter Product Quantity: 150Product added successfully.=== Inventory Management System ===1. Add Product2. Delete Product3. Update Product Quantity4. Display All Products5. ExitEnter your choice (1-5): 4Product List:ID: 2001, Name: Laptop, Quantity: 50ID: 2002, Name: Smartphone, Quantity: 150=== Inventory Management System ===1. Add Product2. Delete Product3. Update Product Quantity4. Display All Products5. ExitEnter your choice (1-5): 3Enter Product ID to update: 2001Enter new quantity: 45Product quantity updated successfully.=== Inventory Management System ===1. Add Product2. Delete Product3. Update Product Quantity4. Display All Products5. ExitEnter your choice (1-5): 4Product List:ID: 2001, Name: Laptop, Quantity: 45ID: 2002, Name: Smartphone, Quantity: 150=== Inventory Management System ===1. Add Product2. Delete Product3. Update Product Quantity4. Display All Products5. ExitEnter your choice (1-5): 5Exiting the system. 代码解析： 结构体定义： 定义了一个 Product 结构体，包含 id、name 和 quantity。 功能函数： addProduct：添加新商品。 deleteProduct：根据 ID 删除商品。 updateProductQuantity：根据 ID 更新商品数量。 displayProducts：显示所有商品的信息。 主函数： 提供一个菜单驱动的用户界面，允许用户选择不同的操作。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(11) string类用法","date":"2024-10-03T05:03:31.000Z","path":"2024/10/03/cppbase11/","text":"1. 引言什么是字符串？字符串是由一系列字符组成的序列，用于表示文本信息。它在编程中被广泛应用于用户交互、文件处理、数据解析等场景。 C 风格字符串 vs std::string在 C++ 中，有两种主要的字符串类型： C 风格字符串（C-strings）：基于字符数组，以空字符 (&#39;\\0&#39;) 结尾。 C++ std::string 类：更高级、功能更丰富的字符串类，封装了字符串操作的复杂性。 C 风格字符串示例： 1char cstr[] = &quot;Hello, World!&quot;; std::string 示例： 123#include &lt;string&gt;std::string str = &quot;Hello, World!&quot;; 2. std::string 基础定义与初始化std::string 是 C++ 标准库中的一个类，位于 &lt;string&gt; 头文件中。它封装了字符序列，并提供了丰富的成员函数用于操作字符串。 初始化有很多中方式，如下图 包含头文件： 1#include &lt;string&gt; 初始化示例： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // 默认构造函数 std::string str1; // 使用字符串字面值初始化 std::string str2 = &quot;Hello&quot;; // 使用拷贝构造函数 std::string str3(str2); // 使用部分初始化 std::string str4(str2, 0, 3); // &quot;Hel&quot; // 使用重复字符初始化 std::string str5(5, &#x27;A&#x27;); // &quot;AAAAA&quot; std::cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;str3: &quot; &lt;&lt; str3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;str4: &quot; &lt;&lt; str4 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;str5: &quot; &lt;&lt; str5 &lt;&lt; std::endl; return 0;&#125; 输出： 12345str1:str2: Hellostr3: Hellostr4: Helstr5: AAAAA 字符串输入与输出输出字符串： 12345678#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string greeting = &quot;Hello, C++ Strings!&quot;; std::cout &lt;&lt; greeting &lt;&lt; std::endl; return 0;&#125; 从用户输入字符串： 12345678910#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string input; std::cout &lt;&lt; &quot;请输入一个字符串：&quot;; std::cin &gt;&gt; input; // 读取直到第一个空白字符 std::cout &lt;&lt; &quot;您输入的字符串是：&quot; &lt;&lt; input &lt;&lt; std::endl; return 0;&#125; 读取包含空格的整行字符串： 12345678910#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string line; std::cout &lt;&lt; &quot;请输入一行文本：&quot;; std::getline(std::cin, line); std::cout &lt;&lt; &quot;您输入的文本是：&quot; &lt;&lt; line &lt;&lt; std::endl; return 0;&#125; 3. 字符串操作常用的字符串操作如下： 3.1 拼接与连接使用 + 运算符： 12345678910#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string first = &quot;Hello, &quot;; std::string second = &quot;World!&quot;; std::string combined = first + second; std::cout &lt;&lt; combined &lt;&lt; std::endl; // 输出: Hello, World! return 0;&#125; 使用 append() 函数： 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;Hello&quot;; str.append(&quot;, World!&quot;); std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: Hello, World! return 0;&#125; 使用 += 运算符： 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;Data&quot;; str += &quot; Structures&quot;; std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: Data Structures return 0;&#125; 3.2 比较字符串关于字符串的比较，其实是逐个位置按照字符比较，计算机中字符存储的方式是ASCII码表，每个字符对应一个ASCII码值，比较字符就是比较ASCII码值的大小 一些控制字符也是通过ASCII码存储的 使用 ==, !=, &lt;, &gt;, &lt;=, &gt;= 运算符： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string a = &quot;apple&quot;; std::string b = &quot;banana&quot;; if (a == b) &#123; std::cout &lt;&lt; &quot;a 和 b 相等&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;a 和 b 不相等&quot; &lt;&lt; std::endl; &#125; if (a &lt; b) &#123; std::cout &lt;&lt; &quot;a 在字典序中小于 b&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;a 在字典序中不小于 b&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 12a 和 b 不相等a 在字典序中小于 b 3.3 查找与替换使用 find() 查找子字符串： 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string text = &quot;The quick brown fox jumps over the lazy dog.&quot;; std::string word = &quot;fox&quot;; size_t pos = text.find(word); if (pos != std::string::npos) &#123; std::cout &lt;&lt; &quot;找到 &#x27;&quot; &lt;&lt; word &lt;&lt; &quot;&#x27; 在位置: &quot; &lt;&lt; pos &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; word &lt;&lt; &quot;&#x27; 未找到。&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 替换子字符串： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string text = &quot;I like cats.&quot;; std::string from = &quot;cats&quot;; std::string to = &quot;dogs&quot;; size_t pos = text.find(from); if (pos != std::string::npos) &#123; text.replace(pos, from.length(), to); std::cout &lt;&lt; &quot;替换后: &quot; &lt;&lt; text &lt;&lt; std::endl; // 输出: I like dogs. &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; from &lt;&lt; &quot;&#x27; 未找到。&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 3.4 子字符串与切片使用 substr() 获取子字符串： 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;Hello, World!&quot;; std::string sub = str.substr(7, 5); // 从位置7开始，长度5 std::cout &lt;&lt; sub &lt;&lt; std::endl; // 输出: World return 0;&#125; 注意： 如果省略第二个参数，substr() 会返回从起始位置到字符串末尾的所有字符。 12std::string sub = str.substr(7); // 从位置7开始直到结束std::cout &lt;&lt; sub &lt;&lt; std::endl; // 输出: World! 4. 字符串的常用成员函数4.1 长度与容量获取字符串长度： 12345678910#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;C++ Programming&quot;; std::cout &lt;&lt; &quot;字符串长度: &quot; &lt;&lt; str.length() &lt;&lt; std::endl; // 输出: 14 // 或者使用 size() std::cout &lt;&lt; &quot;字符串大小: &quot; &lt;&lt; str.size() &lt;&lt; std::endl; // 输出: 14 return 0;&#125; 获取字符串容量： 每个 std::string 对象都有一个容量（capacity），表示它当前能够持有的最大字符数，而不需要重新分配内存。 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;Hello&quot;; std::cout &lt;&lt; &quot;初始容量: &quot; &lt;&lt; str.capacity() &lt;&lt; std::endl; str += &quot;, World!&quot;; std::cout &lt;&lt; &quot;追加后的容量: &quot; &lt;&lt; str.capacity() &lt;&lt; std::endl; return 0;&#125; 输出示例： 12初始容量: 15追加后的容量: 15 注意： 容量可能因实现而异，并不保证它等于长度。 4.2 访问字符对字符串中的字符操作，有如下方法, 切记需包含头文件 使用索引访问单个字符： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;ABCDE&quot;; // 正向索引 for (size_t i = 0; i &lt; str.length(); ++i) &#123; std::cout &lt;&lt; &quot;字符 &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; str[i] &lt;&lt; std::endl; &#125; //反向遍历 for(int i = str.length() - 1; i &gt;= 0 ; i --)&#123; std::cout &lt;&lt; &quot;下标为 &quot; &lt;&lt; i &lt;&lt; &quot;的字符为&quot; &lt;&lt; str[i] &lt;&lt; std::endl; &#125; return 0;&#125; 使用 at() 函数（包含边界检查）： 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;ABCDE&quot;; try &#123; char c = str.at(10); // 超出范围，会抛出异常 &#125; catch (const std::out_of_range&amp; e) &#123; std::cout &lt;&lt; &quot;异常捕获: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 1异常捕获: basic_string::at: __n (which is 10) &gt;= this-&gt;size() (which is 5) 4.3 转换大小写C++ 标准库中的 std::toupper 和 std::tolower 可以用于转换字符的大小写。结合 std::transform，可以实现整个字符串的大小写转换。 转换为大写： 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;int main() &#123; std::string str = &quot;Hello, World!&quot;; std::transform(str.begin(), str.end(), str.begin(), [](unsigned char c) &#123; return std::toupper(c); &#125;); std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: HELLO, WORLD! return 0;&#125; 转换为小写： 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;int main() &#123; std::string str = &quot;Hello, World!&quot;; std::transform(str.begin(), str.end(), str.begin(), [](unsigned char c) &#123; return std::tolower(c); &#125;); std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: hello, world! return 0;&#125; 4.4 其他有用的函数 **empty()**：检查字符串是否为空。 1234std::string str;if (str.empty()) &#123; std::cout &lt;&lt; &quot;字符串为空。&quot; &lt;&lt; std::endl;&#125; **clear()**：清空字符串内容。 123std::string str = &quot;Clear me!&quot;;str.clear();std::cout &lt;&lt; &quot;str: &quot; &lt;&lt; str &lt;&lt; std::endl; // 输出为空 **erase()**：删除字符串的部分内容。 123std::string str = &quot;Hello, World!&quot;;str.erase(5, 7); // 从位置5开始，删除7个字符std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: Hello! **insert()**：在指定位置插入字符串或字符。 123std::string str = &quot;Hello World&quot;;str.insert(5, &quot;,&quot;);std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: Hello, World **replace()**：替换字符串的部分内容（前面已示例）。 **find_first_of(), find_last_of()**：查找字符集合中的任何一个字符。 123std::string str = &quot;apple, banana, cherry&quot;;size_t pos = str.find_first_of(&quot;, &quot;);std::cout &lt;&lt; &quot;第一个逗号或空格的位置: &quot; &lt;&lt; pos &lt;&lt; std::endl; // 输出: 5 5. 高级用法5.1 字符串流（stringstream）std::stringstream 是 C++ 标准库中第 &lt;sstream&gt; 头文件提供的一个类，用于在内存中进行字符串的读写操作，类似于文件流。 基本用法示例： 12345678910111213#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;int main() &#123; std::stringstream ss; ss &lt;&lt; &quot;Value: &quot; &lt;&lt; 42 &lt;&lt; &quot;, &quot; &lt;&lt; 3.14; std::string result = ss.str(); std::cout &lt;&lt; result &lt;&lt; std::endl; // 输出: Value: 42, 3.14 return 0;&#125; 从字符串流中读取数据： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;int main() &#123; std::string data = &quot;123 45.67 Hello&quot;; std::stringstream ss(data); int a; double b; std::string c; ss &gt;&gt; a &gt;&gt; b &gt;&gt; c; std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; &quot;, c: &quot; &lt;&lt; c &lt;&lt; std::endl; // 输出: a: 123, b: 45.67, c: Hello return 0;&#125; 5.2 字符串与其他数据类型的转换将其他类型转换为 std::string： 使用 std::to_string()： 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int num = 100; double pi = 3.14159; std::string str1 = std::to_string(num); std::string str2 = std::to_string(pi); std::cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; &quot;, str2: &quot; &lt;&lt; str2 &lt;&lt; std::endl; // 输出: str1: 100, str2: 3.141590 return 0;&#125; 将 std::string 转换为其他类型： 使用字符串流： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;int main() &#123; std::string numStr = &quot;256&quot;; std::string piStr = &quot;3.14&quot;; int num; double pi; std::stringstream ss1(numStr); ss1 &gt;&gt; num; std::stringstream ss2(piStr); ss2 &gt;&gt; pi; std::cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; &quot;, pi: &quot; &lt;&lt; pi &lt;&lt; std::endl; // 输出: num: 256, pi: 3.14 return 0;&#125; 使用 std::stoi(), std::stod() 等函数（C++11 及以上）： 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string numStr = &quot;256&quot;; std::string piStr = &quot;3.14&quot;; int num = std::stoi(numStr); double pi = std::stod(piStr); std::cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; &quot;, pi: &quot; &lt;&lt; pi &lt;&lt; std::endl; // 输出: num: 256, pi: 3.14 return 0;&#125; 5.3 正则表达式与字符串匹配C++ 标准库提供了 &lt;regex&gt; 头文件，用于支持正则表达式。 关于正则表达式的规则可以参考菜鸟教程文档https://www.runoob.com/regexp/regexp-syntax.html 基本用法示例： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;int main() &#123; std::string text = &quot;The quick brown fox jumps over the lazy dog.&quot;; std::regex pattern(R&quot;(\\b\\w&#123;5&#125;\\b)&quot;); // 匹配所有5个字母的单词 std::sregex_iterator it(text.begin(), text.end(), pattern); std::sregex_iterator end; std::cout &lt;&lt; &quot;5个字母的单词有:&quot; &lt;&lt; std::endl; while (it != end) &#123; std::cout &lt;&lt; (*it).str() &lt;&lt; std::endl; ++it; &#125; return 0;&#125; 输出： 123455个字母的单词有:quickbrownjumpsleazy 说明： \\b 匹配单词边界。 \\w&#123;5&#125; 匹配恰好5个字母的单词。 注意： 使用原始字符串字面值（R&quot;()&quot;）以简化正则表达式的编写。 6. 字符串与 C 风格字符串的转换6.1 从 C 风格字符串转换为 std::string通过 std::string 的构造函数，可以轻松将 C 风格字符串转换为 std::string。 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; const char* cstr = &quot;Hello, C-strings!&quot;; std::string str(cstr); std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: Hello, C-strings! return 0;&#125; 6.2 从 std::string 转换为 C 风格字符串使用 c_str() 成员函数，可以获取 C 风格字符串指针。 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = &quot;Hello, std::string!&quot;; const char* cstr = str.c_str(); std::cout &lt;&lt; cstr &lt;&lt; std::endl; // 输出: Hello, std::string! return 0;&#125; 注意： 返回的指针是只读的，且指向的内存由 std::string 管理，确保在 std::string 对象有效期间使用。 7. 示例项目示例项目1：简易文本分析器需求分析： 创建一个程序，接受用户输入的一段文本，并提供以下功能： 统计单词数量 统计每个单词出现的次数 查找指定单词的出现次数 输出最长的单词 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;int main() &#123; std::string text; std::cout &lt;&lt; &quot;请输入一段文本（结束请输入Ctrl+D/Ctrl+Z）：\\n&quot;; // 读取整段文本 std::ostringstream oss; std::string line; while (std::getline(std::cin, line)) &#123; oss &lt;&lt; line &lt;&lt; &quot; &quot;; &#125; text = oss.str(); // 使用字符串流分割单词 std::stringstream ss(text); std::string word; std::map&lt;std::string, int&gt; wordCount; size_t totalWords = 0; std::string longestWord; while (ss &gt;&gt; word) &#123; // 去除标点符号（简单处理） word.erase(std::remove_if(word.begin(), word.end(), [](char c) &#123; return ispunct(c); &#125;), word.end()); // 转为小写 std::transform(word.begin(), word.end(), word.begin(), ::tolower); if (!word.empty()) &#123; wordCount[word]++; totalWords++; if (word.length() &gt; longestWord.length()) &#123; longestWord = word; &#125; &#125; &#125; std::cout &lt;&lt; &quot;\\n统计结果:\\n&quot;; std::cout &lt;&lt; &quot;总单词数: &quot; &lt;&lt; totalWords &lt;&lt; std::endl; std::cout &lt;&lt; &quot;每个单词出现的次数:\\n&quot;; for (const auto&amp; pair : wordCount) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;最长的单词: &quot; &lt;&lt; longestWord &lt;&lt; std::endl; // 查找指定单词的出现次数 std::string searchWord; std::cout &lt;&lt; &quot;\\n请输入要查找的单词: &quot;; std::cin &gt;&gt; searchWord; // 转为小写 std::transform(searchWord.begin(), searchWord.end(), searchWord.begin(), ::tolower); auto it = wordCount.find(searchWord); if (it != wordCount.end()) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; searchWord &lt;&lt; &quot;&#x27; 出现了 &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot; 次。&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; searchWord &lt;&lt; &quot;&#x27; 未在文本中找到。&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 运行示例： 12345678910111213141516171819202122请输入一段文本（结束请输入Ctrl+D/Ctrl+Z）：Hello, world! Hello C++.This is a simple text analyzer. Analyzing text is fun.统计结果:总单词数: 10每个单词出现的次数:hello: 2world: 1c: 1this: 1is: 2a: 1simple: 1text: 2analyzer: 1analyzing: 1fun: 1最长的单词: analyzer请输入要查找的单词: text&#x27;text&#x27; 出现了 2 次。 代码解析： 读取用户输入的文本：使用 std::ostringstream 和 std::getline 读取用户输入的多行文本，直到用户输入结束（Ctrl+D 或 Ctrl+Z）。 分割单词并统计： 使用 std::stringstream 将文本分割为单词。 使用 std::map 存储每个单词出现的次数。 计算总单词数和最长单词。 查找指定单词：用户输入要查找的单词，程序查找并输出出现次数。 示例项目2：用户输入验证工具需求分析： 编写一个程序，接受用户输入的电子邮件地址，并验证其格式是否正确。简单的验证标准： 包含一个 @ 符号 @ 后面有一个 . 符号 不包含空格 代码实现： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;bool isValidEmail(const std::string&amp; email) &#123; // 简单的正则表达式，匹配基本的邮件格式 const std::regex pattern(R&quot;((\\w+)(\\.?\\w+)*@(\\w+)(\\.\\w+)+)&quot;); return std::regex_match(email, pattern);&#125;int main() &#123; std::string email; std::cout &lt;&lt; &quot;请输入您的电子邮件地址: &quot;; std::cin &gt;&gt; email; if (isValidEmail(email)) &#123; std::cout &lt;&lt; &quot;电子邮件地址有效。&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;电子邮件地址无效。&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 运行示例： 12请输入您的电子邮件地址: user@example.com电子邮件地址有效。 12请输入您的电子邮件地址: userexample.com电子邮件地址无效。 代码解析： **定义验证函数 isValidEmail**： 使用正则表达式 (\\w+)(\\.?\\w+)*@(\\w+)(\\.\\w+)+ 来匹配基本的邮箱格式。 该正则表达式匹配如下部分： 用户名部分：由字母数字字符组成，可以包含点号。 @ 符号。 域名部分：由字母数字字符组成，至少包含一个点号后跟字母数字字符。 主函数： 提示用户输入邮箱地址。 调用 isValidEmail 函数进行验证，并输出结果。 注意： 这个正则表达式只是一个基础的验证，实际应用中可能需要更复杂的正则表达式来处理更多的邮件格式。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(10) 命名空间","date":"2024-10-03T04:23:44.000Z","path":"2024/10/03/cppbase10/","text":"命名空间的using声明目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。 例如，std::cin表示从标准输入中读取内容。此处使用作用域操作符(::)的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。 因此，std::cin的意思就是要使用命名空间std中的名字cin。 上面的方法显得比较烦琐，然而幸运的是，通过更简单的途径也能使用到命名空间中的成员。 本节将学习其中一种简单的方法，使用using声明（using declaration），有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式： 1using namespace::name; 一旦声明了上述语句，就可以直接访问命名空间中的名字: 1234567891011using std::cin;int main() &#123; int i ; //正确,cin和std::cin含义相同 cin &gt;&gt; i; //错误,没有对应的using声明，必须使用完整的名字 //cout &lt;&lt; i; //正确，显示地从std中使用cout std::cout &lt;&lt; i; return 0;&#125; 每个名字都需要独立的using声明按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using声明的形式表示出来，程序如下： 123456789101112using std::cin;using std::endl;int main() &#123; int i ; //正确,cin和std::cin含义相同 cin &gt;&gt; i; //错误,没有对应的using声明，必须使用完整的名字 //cout &lt;&lt; i; //正确，显示地从std中使用cout std::cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; 头文件不应包含using声明位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(9) 结构体类型","date":"2024-10-01T06:32:04.000Z","path":"2024/10/01/cppbase09/","text":"什么是结构体？结构体（structure，简称 struct）是一种用户自定义的数据类型，用于将多个不同类型的数据组合在一起。它允许在一个单一的单元中存储多个相关的数据项，使代码更具组织性和可读性。 结构体在编程中的应用场景 数据组织：将相关的数据组合，如学生信息、坐标点、日期等。 传递数据：在函数之间传递多个相关的数据项。 复杂数据处理：管理更复杂的数据结构，如链表、树、图等。 结构体的基本使用定义和声明结构体在 C++ 中，使用 struct 关键字定义一个结构体。基本语法如下： 123456struct StructName &#123; // 成员变量 dataType1 member1; dataType2 member2; // ...&#125;; 示例：定义一个学生结构体 12345struct Student &#123; int id; std::string name; float grade;&#125;; 创建结构体变量定义结构体后，可以创建结构体类型的变量。 12Student student1;Student student2; 访问结构体成员使用点运算符（.）访问结构体成员。 1234567student1.id = 1001;student1.name = &quot;Alice&quot;;student1.grade = 89.5f;std::cout &lt;&lt; &quot;学生ID: &quot; &lt;&lt; student1.id &lt;&lt; std::endl;std::cout &lt;&lt; &quot;学生姓名: &quot; &lt;&lt; student1.name &lt;&lt; std::endl;std::cout &lt;&lt; &quot;学生成绩: &quot; &lt;&lt; student1.grade &lt;&lt; std::endl; 结构体初始化可以在创建结构体变量时进行初始化。 方法一：直观初始化 1Student student3 = &#123;1002, &quot;Bob&quot;, 92.0f&#125;; 方法二：逐个赋值 1234Student student4;student4.id = 1003;student4.name = &quot;Charlie&quot;;student4.grade = 85.0f; 方法三：使用自定义构造函数 虽然结构体的主要用途是数据存储，但在 C++ 中，结构体可以像类一样拥有构造函数。 123456789101112struct Student &#123; int id; std::string name; float grade; // 构造函数 Student(int studentId, std::string studentName, float studentGrade) : id(studentId), name(studentName), grade(studentGrade) &#123;&#125;&#125;;// 使用构造函数初始化Student student5(1004, &quot;Daisy&quot;, 95.0f); 结构体与类的比较在 C++ 中，struct 和 class 有很多相似之处，但也有一些关键区别。 类与结构体的相似之处 都可以包含成员变量和成员函数。 都支持访问控制（public、protected、private）。 都可以使用继承和多态。 类与结构体的区别默认访问控制 结构体（struct）：默认成员访问权限为 public。 类（class）：默认成员访问权限为 private。 例子 1234567struct StructExample &#123; int x; // 默认 public&#125;;class ClassExample &#123; int y; // 默认 private&#125;; 用途习惯 结构体（struct）：通常用于纯数据结构，主要存储数据，成员通常是公开的。 类（class）：用于包含数据和操作数据的函数，支持更加复杂的封装。 实例比较 1234567891011121314151617181920212223242526272829303132struct Point &#123; int x; int y;&#125;;class Rectangle &#123;private: int width; int height;public: void setDimensions(int w, int h) &#123; width = w; height = h; &#125; int area() const &#123; return width * height; &#125; int get_width()&#123; return width; &#125;&#125;;int main()&#123; Rectangle rt; //错误，不能直接访问私有成员 rt.width; //正确，可以通过公有成员函数访问 rt.get_width();&#125; 结构体的高级用法嵌套结构体结构体可以包含其他结构体作为成员。 示例：嵌套地址结构体 123456789101112131415161718192021222324252627struct Address &#123; std::string city; std::string street; int houseNumber;&#125;;struct Person &#123; std::string name; int age; Address address; // 嵌套结构体&#125;;int main() &#123; Person person; person.name = &quot;Eve&quot;; person.age = 30; person.address.city = &quot;New York&quot;; person.address.street = &quot;5th Avenue&quot;; person.address.houseNumber = 101; std::cout &lt;&lt; person.name &lt;&lt; &quot; lives at &quot; &lt;&lt; person.address.houseNumber &lt;&lt; &quot; &quot; &lt;&lt; person.address.street &lt;&lt; &quot;, &quot; &lt;&lt; person.address.city &lt;&lt; std::endl; return 0;&#125; 输出： 1Eve lives at 101 5th Avenue, New York 结构体数组可以创建包含多个结构体的数组，用于存储多个相同类型的数据项。 示例：存储多个学生信息的数组 12345678910111213141516171819202122struct Student &#123; int id; std::string name; float grade;&#125;;int main() &#123; // 创建包含3个学生信息的数组 Student students[3] = &#123; &#123;1001, &quot;Alice&quot;, 89.5f&#125;, &#123;1002, &quot;Bob&quot;, 92.0f&#125;, &#123;1003, &quot;Charlie&quot;, 85.0f&#125; &#125;; for (int i = 0; i &lt; 3; ++i) &#123; std::cout &lt;&lt; &quot;学生ID: &quot; &lt;&lt; students[i].id &lt;&lt; &quot;, 姓名: &quot; &lt;&lt; students[i].name &lt;&lt; &quot;, 成绩: &quot; &lt;&lt; students[i].grade &lt;&lt; std::endl; &#125; return 0;&#125; 输出： 123学生ID: 1001, 姓名: Alice, 成绩: 89.5学生ID: 1002, 姓名: Bob, 成绩: 92学生ID: 1003, 姓名: Charlie, 成绩: 85 结构体指针可以创建指向结构体的指针，并通过指针访问结构体成员。 示例：使用结构体指针 12345678910111213141516struct Car &#123; std::string brand; std::string model; int year;&#125;;int main() &#123; Car car = &#123;&quot;Toyota&quot;, &quot;Camry&quot;, 2020&#125;; Car* carPtr = &amp;car; std::cout &lt;&lt; &quot;品牌: &quot; &lt;&lt; carPtr-&gt;brand &lt;&lt; std::endl; std::cout &lt;&lt; &quot;型号: &quot; &lt;&lt; carPtr-&gt;model &lt;&lt; std::endl; std::cout &lt;&lt; &quot;年份: &quot; &lt;&lt; carPtr-&gt;year &lt;&lt; std::endl; return 0;&#125; 输出： 123品牌: Toyota型号: Camry年份: 2020 使用 typedef 简化结构体定义使用 typedef（或 using 关键字）可以为结构体类型创建别名，使代码更简洁。 示例：使用 typedef 123456789101112typedef struct &#123; int id; std::string name; float grade;&#125; Student;// 或者使用 `using`（C++11 及以上）using Student = struct &#123; int id; std::string name; float grade;&#125;; 应用： 1234567int main() &#123; Student s1 = &#123;1004, &quot;Daisy&quot;, 95.0f&#125;; std::cout &lt;&lt; &quot;学生ID: &quot; &lt;&lt; s1.id &lt;&lt; &quot;, 姓名: &quot; &lt;&lt; s1.name &lt;&lt; &quot;, 成绩: &quot; &lt;&lt; s1.grade &lt;&lt; std::endl; return 0;&#125; 输出： 1学生ID: 1004, 姓名: Daisy, 成绩: 95 5. 结构体中的函数虽然结构体主要用于存储数据，但在 C++ 中，结构体也可以包含成员函数。这使得结构体更具面向对象的特性。 示例：在结构体中定义成员函数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;struct Book &#123; std::string title; std::string author; int pages; // 成员函数 void printInfo() const &#123; std::cout &lt;&lt; &quot;书名: &quot; &lt;&lt; title &lt;&lt; &quot;, 作者: &quot; &lt;&lt; author &lt;&lt; &quot;, 页数: &quot; &lt;&lt; pages &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Book myBook = &#123;&quot;C++ Primer&quot;, &quot;Stanley B. Lippman&quot;, 976&#125;; myBook.printInfo(); return 0;&#125; 输出： 1书名: C++ Primer, 作者: Stanley B. Lippman, 页数: 976 使用结构体作为函数参数和返回值传递结构体给函数 12345678910111213141516171819202122232425struct Point &#123; int x; int y;&#125;;// 通过值传递void printPoint(Point p) &#123; std::cout &lt;&lt; &quot;Point(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#125;// 通过引用传递void movePoint(Point&amp; p, int dx, int dy) &#123; p.x += dx; p.y += dy;&#125;int main() &#123; Point p1 = &#123;10, 20&#125;; printPoint(p1); movePoint(p1, 5, -5); printPoint(p1); return 0;&#125; 输出： 12Point(10, 20)Point(15, 15) 从函数返回结构体 1234567891011121314151617181920212223struct Rectangle &#123; int width; int height;&#125;;// 计算面积的结构体struct Area &#123; int value;&#125;;// 函数返回结构体Area calculateArea(Rectangle rect) &#123; Area area; area.value = rect.width * rect.height; return area;&#125;int main() &#123; Rectangle rect = &#123;5, 10&#125;; Area rectArea = calculateArea(rect); std::cout &lt;&lt; &quot;矩形面积: &quot; &lt;&lt; rectArea.value &lt;&lt; std::endl; return 0;&#125; 输出： 1矩形面积: 50 6. 示例项目示例项目：简单学生信息管理系统这个项目将结合前面的知识点，创建一个简单的学生信息管理系统，允许添加、显示和查找学生信息。 需求分析 添加新学生的信息（ID、姓名、成绩） 显示所有学生的信息 根据学生ID查找学生信息 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;// 定义学生结构体struct Student &#123; int id; std::string name; float grade; // 成员函数打印学生信息 void printInfo() const &#123; std::cout &lt;&lt; &quot;学生ID: &quot; &lt;&lt; id &lt;&lt; &quot;, 姓名: &quot; &lt;&lt; name &lt;&lt; &quot;, 成绩: &quot; &lt;&lt; grade &lt;&lt; std::endl; &#125;&#125;;// 添加学生void addStudent(std::vector&lt;Student&gt;&amp; students, int id, const std::string&amp; name, float grade) &#123; Student newStudent = &#123;id, name, grade&#125;; students.push_back(newStudent); std::cout &lt;&lt; &quot;添加学生成功。&quot; &lt;&lt; std::endl;&#125;// 显示所有学生void displayStudents(const std::vector&lt;Student&gt;&amp; students) &#123; if (students.empty()) &#123; std::cout &lt;&lt; &quot;没有学生信息。&quot; &lt;&lt; std::endl; return; &#125; std::cout &lt;&lt; &quot;所有学生信息：&quot; &lt;&lt; std::endl; for (const auto&amp; student : students) &#123; student.printInfo(); &#125;&#125;// 根据ID查找学生void findStudentById(const std::vector&lt;Student&gt;&amp; students, int id) &#123; for (const auto&amp; student : students) &#123; if (student.id == id) &#123; std::cout &lt;&lt; &quot;找到学生：&quot; &lt;&lt; std::endl; student.printInfo(); return; &#125; &#125; std::cout &lt;&lt; &quot;未找到ID为 &quot; &lt;&lt; id &lt;&lt; &quot; 的学生。&quot; &lt;&lt; std::endl;&#125;int main() &#123; std::vector&lt;Student&gt; students; int choice; do &#123; std::cout &lt;&lt; &quot;\\n===== 学生信息管理系统 =====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;1. 添加学生&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2. 显示所有学生&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;3. 根据ID查找学生&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;4. 退出&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;请选择（1-4）：&quot;; std::cin &gt;&gt; choice; if (choice == 1) &#123; int id; std::string name; float grade; std::cout &lt;&lt; &quot;输入学生ID: &quot;; std::cin &gt;&gt; id; std::cout &lt;&lt; &quot;输入学生姓名: &quot;; std::cin &gt;&gt; name; std::cout &lt;&lt; &quot;输入学生成绩: &quot;; std::cin &gt;&gt; grade; addStudent(students, id, name, grade); &#125; else if (choice == 2) &#123; displayStudents(students); &#125; else if (choice == 3) &#123; int searchId; std::cout &lt;&lt; &quot;输入要查找的学生ID: &quot;; std::cin &gt;&gt; searchId; findStudentById(students, searchId); &#125; else if (choice == 4) &#123; std::cout &lt;&lt; &quot;退出系统。&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;无效选择，请重新输入。&quot; &lt;&lt; std::endl; &#125; &#125; while (choice != 4); return 0;&#125; 代码解析 结构体定义：定义了一个 Student 结构体，包含 id、name 和 grade，并有一个成员函数 printInfo 来打印学生信息。 功能函数： addStudent：向学生列表中添加一个新的学生。 displayStudents：显示所有学生的信息。 findStudentById：根据学生ID查找并显示学生信息。 用户交互：使用 do-while 循环和 switch-case 来处理用户的选择，实现添加、显示和查找学生信息的功能。 运行示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849===== 学生信息管理系统 =====1. 添加学生2. 显示所有学生3. 根据ID查找学生4. 退出请选择（1-4）：1输入学生ID: 1001输入学生姓名: Alice输入学生成绩: 89.5添加学生成功。===== 学生信息管理系统 =====1. 添加学生2. 显示所有学生3. 根据ID查找学生4. 退出请选择（1-4）：1输入学生ID: 1002输入学生姓名: Bob输入学生成绩: 92.0添加学生成功。===== 学生信息管理系统 =====1. 添加学生2. 显示所有学生3. 根据ID查找学生4. 退出请选择（1-4）：2所有学生信息：学生ID: 1001, 姓名: Alice, 成绩: 89.5学生ID: 1002, 姓名: Bob, 成绩: 92===== 学生信息管理系统 =====1. 添加学生2. 显示所有学生3. 根据ID查找学生4. 退出请选择（1-4）：3输入要查找的学生ID: 1001找到学生：学生ID: 1001, 姓名: Alice, 成绩: 89.5===== 学生信息管理系统 =====1. 添加学生2. 显示所有学生3. 根据ID查找学生4. 退出请选择（1-4）：4退出系统。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(8) 处理类型","date":"2024-09-28T02:42:12.000Z","path":"2024/09/28/cppbase08/","text":"类型别名类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。 有两种方法可用于定义类型别名。传统的方法是使用关键字typedef： 1234//wages 是double的同义词typedef double wages;//base是double的同义词,p是double*的同义词typedef wages base, *p; C++11 新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名： 12//64位整型using int64_t = long long; 这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。 12//定义变量a为64位整型int64_t a = 10; 指针、常量和类型别名如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。 例如下面的声明语句用到了类型pstring，它实际上是类型char＊的别名： 123typedef char * pstring;const pstring cstr = 0;const pstring *ps; 上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。 pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。 auto类型说明符编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。 然而要做到这一点并非那么容易，有时甚至根本做不到。 为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。 和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值： 1234//计算求和int age1 = 20;int age2 = 35;auto age_add = age1+age2; auto很有作用，后期我们会学习尾置类型推导，以后再讲。 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样： 1234//正确, i是整数，p是整型指针auto i= 0, * p= &amp;i;//错误, sz是整型，pi是double//auto sz = 0, pi = 3.14; 复合类型、常量和auto编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。 首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。 此时编译器以引用对象的类型作为auto的类型： 123int i = 0, &amp;r = i;// a是一个整数，类型是r所引用的类型auto a = r; auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时： 123456789101112131415&#123; int i = 0, &amp;r = i; // a是一个整数，类型是r所引用的类型 auto a = r; // cr是一个常量引用，ci是int类型的常量 const int ci = i, &amp;cr = ci; // b是一个整数，ci顶层const被忽略了 auto b = ci; // c是一个整数，cr是ci的别名，ci本身是一个顶层const auto c = cr; // d 是一个整型指针，i是整型 auto d = &amp;i; // e是一个指向整数常量的指针，对常量对象取地址是一种底层const auto e = &amp;ci;&#125; 如果希望推断出的auto类型是一个顶层const，需要明确指出： 12//顶层const可显示指定,f是一个const int类型const auto f = ci; 还可以将引用的类型设为auto，此时原来的初始化规则仍然适用： 123456// g是一个整型常量引用，绑定到ciauto &amp;g = ci;//错误，非常量引用不能绑定字面量//auto &amp;h = 42;//正确,常量引用可以绑定字面量const auto &amp;j = 42; 要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型： 1234567//i为int类型， ci为const int类型， 但是k是int类型，l是int&amp;类型auto k = ci, &amp;l = i;//m是对常量的引用，p是指向整数常量的指针// p为const int*类型auto &amp;m = ci, *p = &amp;ci;//错误, i为int类型，&amp;ci的类型为const int*//auto &amp;n = i, *p2 = &amp;ci; decltype类型指示符C++11 有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值： 1decltype(f()) sum = x; //sum的类型就是函数f的返回值的类型 编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。 decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）： 1234567const int ci = 0, &amp;cj = ci;//x是const int类型decltype(ci) x = 0;//y是一个const int&amp;类型，y绑定到xdecltype(cj) y = x;//错误，z是一个引用,引用必须初始化//decltype(cj) z; 因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。 需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。 decltype和引用如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。 有些表达式将向decltype返回一个引用类型。 一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值： 12345678&#123; //decltype的结果可以是引用各类型 int i = 42, *p = &amp;i, &amp;r = i; //正确，假发的结果是int，因此b是一个未初始化的int decltype(r + 0) b; //错误，c是int&amp;，必须初始化 //decltype(*p) c;&#125; 因为r是一个引用，因此decltype（r）的结果是引用类型。 如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。 另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。 因此，decltype（*p）的结果类型就是int&amp;，而非int。decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切相关。 有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。 如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型； 如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型： 12345//decltype的表达式如果加上了括号的变量，结果就是引用//错误，d是int&amp;，必须初始化//decltype((i)) d;//正确,e是一个未被初始化的int类型值decltype(r) e = i; 切记：decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。 工作中的应用工作中会利用auto和decltype配合使用，结合模板做类型推导返回动态类型，比如我们在并发编程系列课程中封装提交任务 12345678910111213141516template &lt;class F, class... Args&gt;auto commit(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))&gt; &#123; using RetType = decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...)); if (stop_.load()) return std::future&lt;RetType&gt;&#123;&#125;; auto task = std::make_shared&lt;std::packaged_task&lt;RetType()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)); std::future&lt;RetType&gt; ret = task-&gt;get_future(); &#123; std::lock_guard&lt;std::mutex&gt; cv_mt(cv_mt_); tasks_.emplace([task] &#123; (*task)(); &#125;); &#125; cv_lock_.notify_one(); return ret;&#125; 这段代码大家要学习模板，以及万能引用后才能完全吸收，我们留个伏笔，以后的剧情中会触发。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(7) 引用类型","date":"2024-09-21T03:37:12.000Z","path":"2024/09/21/cppbase07/","text":"const限定符1 const 的定义与作用const 是 C++ 关键字，用于指示变量的值不可修改。通过使用 const，可以提高代码的安全性与可读性，防止无意中修改变量的值。 2 const 在变量声明中的位置const 关键字通常放在变量类型之前，例如： 1const int a = 10; 也可以放在类型之后，但这种用法较少见： 1int const a = 10; 可以用一个变量初始化常量， 也可以将一个常量赋值给一个变量 12345//可以用一个变量初始化常量int i1 = 10;const int i2 = i1;//也可以将一个常量赋值给一个变量int i3 = i2; const变量必须初始化 12//错误用法，const变量必须初始化//const int i4; 3 编译器如何处理 const 修饰的变量const 修饰的变量在编译时会被视为只读，尝试修改其值会导致编译错误。此外，编译器可能会对 const 变量进行优化，如将其存储在只读内存区域。 注意 默认状态下，const对象仅在文件内有效 当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： 1const int bufSize = 512; 编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 为了执行上述替换，编译器必须知道变量的初始值。 如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义. 为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。 我们创建一个global.h文件和global.cpp文件, 我们知道头文件只做变量的声明，之前我们在头文件添加变量的定义会导致连接错误。 那如果我们添加const变量的定义 1234#ifndef DAY08_CONST_GLOBAL_H#define DAY08_CONST_GLOBAL_Hconst int bufSize = 100;#endif //DAY08_CONST_GLOBAL_H 在main.cpp和global.cpp中包含global.h，发现可以编译通过，虽然main.cpp和global.cpp中包含了同名的bufSize，但却是不同的变量，运行程序可以编译通过。 有时候我们不想定义不同的const变量，可以在global.h中用extern声明bufSize 1extern const int bufSize2; 在global.cpp中定义 1const int bufSize2 = 10; 同样可以编译通过。 为了验证我们的说法，我们可以在global.h中声明一个函数,用来打印两个变量的地址 12//打印bufSize地址和bufSize2地址extern void PrintBufAddress(); 在global.cpp中实现PrintBufAddress() 1234void PrintBufAddress()&#123; std::cout &lt;&lt; &quot;global.cpp buf address: &quot; &lt;&lt; &amp;bufSize &lt;&lt; std::endl; std::cout &lt;&lt; &quot;global.cpp buf2 address: &quot; &lt;&lt; &amp;bufSize2 &lt;&lt; std::endl;&#125; 然后我们在main.cpp中调用PrintBufAddress()函数，并且在main.cpp中打印两个变量地址 12345PrintBufAddress();//输出bufSize地址std::cout &lt;&lt; &quot;main.cpp buf address is &quot; &lt;&lt; &amp;bufSize &lt;&lt; std::endl;//输出bufSize2地址std::cout &lt;&lt; &quot;main.cpp buf2 address is &quot; &lt;&lt; &amp;bufSize2 &lt;&lt; std::endl; 程序输出 1234global.cpp buf address: 0x7ff67a984040global.cpp buf2 address: 0x7ff67a984044main.cpp buf address is 0x7ff67a984000main.cpp buf2 address is 0x7ff67a984044 可以看出global.cpp中的bufSize和main.cpp中的bufSize不是同一个变量 技巧 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。 const的引用可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象： 1234//定义常量const int ci = 1024;//用常量引用绑定常量const int &amp;r1 = ci; 不能修改常量引用的值 12//不能修改常量引用的值//r1 = 2048; 也不能用非常量引用指向一个常量对象 12//也不能用非常量引用指向一个常量对象//int&amp; r2 = ci; 术语 常量引用是对const的引用 企业中，C++程序员们经常把词组“对const的引用”简称为“常量引用 允许将const引用绑定一个非const变量 123int i5 = 1024;//允许将const int&amp; 绑定到一个普通的int对象上const int &amp;r5 = i5; 常量引用绑定字面量 12//常量引用绑定字面量const int &amp;r6 = 1024; 常量引用绑定表达式计算的值 123//常量引用绑定表达式计算的值const int &amp;r7 = r6 * 2;const int &amp;r8 = i5 * 2 + 10; 思考1 下面的代码能编译通过吗？ 12double dval = 3.14;int &amp; rd = dval; 答案 123//错误用法，类型不匹配double dval = 3.14;int &amp; rd = dval; 思考2 下面的代码能编译通过吗？ 12double dval = 3.14;const int &amp; ri = dval; 答案 123//编译通过double dval = 3.14;const int &amp; ri = dval; 上面的代码相当于 123//上面代码会做隐士转换,相当于下面代码const int temp = dval;const int &amp;rt = temp; 在这种情况下，ri绑定了一个临时量（temporary）对象。 所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 C++程序员们常常把临时量对象简称为临时量。 对const的引用可能引用一个并非const的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值： 1234567int i9 = 1024;//非常量引用绑定i9int &amp;r9 = i9;//常量引用绑定一个变量const int &amp;r10 = i9;//可以同过非常量引用修改i9的值r9 = 2048; 指针和const指向常量的指针(pointer to const)可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const）不能用于改变其所指对象的值。 要想存放常量对象的地址，只能使用指向常量的指针： 12345678//PI 是一个常量,它的值不能改变const double PI = 3.14;//错误，ptr是一个普通指针//double * ptr = &amp;PI;//正确,cptr可以指向一个双精度常量const double *cptr = &amp;PI;//错误，不能给*ptr赋值//*cptr = 3.14; 指针的类型必须与其所指对象的类型一致，但是允许令一个指向常量的指针指向一个非常量对象 1234//可以用指向常量的指针指向一个非常量int i10 = 2048;//ptr指向i10int *cptr2 = &amp;i10; const指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。 常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。 把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值： 123456int errNumb = 0;//curErr是一个常量指针，指向errNumbint * const curErr = &amp;errNumb;const double pi2 = 3.14;//pip 是一个指向常量对象的常量指针const double *const pip = &amp;pi2; 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型 123456//错误，pip是一个指向常量的指针//*pip = 2.72;//可以修改常量指针指向的内容*curErr = 1024;//可以修改常量指针指向的地址//curErr = &amp;i10; 顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题 用名词顶层const（top-level const）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。 顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。 底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显： 1234567891011int i = 0;//不能改变p1的值，这是一个顶层constint * const pi = &amp;i;//不能改变ci的值，这是一个顶层constconst int ci = 42;//允许改变p2的值，这是一个底层constconst int * p2 = &amp;ci;//靠右边的const是顶层const，靠左边的const是底层constconst int * const p3 = p2;//用于声明引用的const都是底层constconst int &amp;r = ci; 底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换 123//指针赋值要注意关注底层const//p2拥有底层const,p4无底层const，所以无法赋值//int * p4 = p2; constexpr和常量表达式常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。 我们先在global.h中声明一个全局函数返回固定大小 1extern int GetSize(); 在global.cpp中实现 123int GetSize()&#123; return 20;&#125; 然后我们用const定义一些常量表达式 一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如 12345678910&#123; //max_files是一个常量表达式 const int max_files = 20; //limit是一个常量表达式 const int limit = max_files + 10; //staff_size不是常量表达式,无const声明 int staff_size = 20; //sz不是常量表达式,运行时计算才得知 const int sz = GetSize();&#125; 尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。 另一方面，尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。 在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。 当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。 C++11新标准 C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化： 123456//20是一个常量表达式constexpr int mf = 20;//mf+1是一个常量表达式constexpr int limit = mf + 10;//错误，GetSize()不是一个常量表达式，需要运行才能返回//constexpr int sz = GetSize(); 尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。 这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。 我们在global.h中定义一个constexpr函数 123inline constexpr int GetSizeConst() &#123; return 1;&#125; 为了避免在多个源文件中包含同一个头文件而导致的多重定义错误，可以将 constexpr 函数声明为 inline。 inline 关键字允许在多个翻译单元中定义同一个函数，而不会引起链接错误。 接下来在定义一个constexpr变量就行了 1constexpr int sz = GetSizeConst(); 指针和constexpr 必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关： 1234//p是一个指向整形常量的指针const int * p = nullptr;//q是一个指向整数的常量指针constexpr int *q = nullptr; 一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。 定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针 global_i是一个全局变量 12345//constexpr指针只能绑定固定地址//constexpr int *p = &amp;mvalue;constexpr int *p = nullptr;//可以绑定全局变量，全局变量地址固定constexpr int *cp = &amp;global_i; 可以修改constexpr指向的内容 123constexpr int *p = &amp;global_i;//修改p指向的内容数据*p = 1024; 问题 global_i是一个全局变量，下面这个指针是什么类型？能否修改cp指向的数据的内容(*cp = 200)？ 1constexpr const int * cp = &amp;global_i;","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(6) 指针类型","date":"2024-09-17T00:38:52.000Z","path":"2024/09/17/cppbase06/","text":"指针基础在C++中，指针是一种特殊的变量，它存储的是另一个变量的内存地址，而不是数据本身。通过使用指针，我们可以直接访问和操作内存中的数据。指针也叫做地址。 和引用的区别指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。 其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 123456//声明一个指向整数的指针，可以不赋初值int *ptr;//ip1和ip2都是指向int类型对象的指针int *ip1, *ip2;//dp2是指向double类型对象的指针,dp是double型对象double dp, *dp2; 这里，ptr 是一个指针变量，它可以存储一个整数的内存地址。 指针赋值我们可以通过如下方式(&amp;变量)获取一个变量的地址 1变量地址 = &amp;变量名 指针可以通过两种方式赋值： 直接赋值内存地址：这通常不是常规做法，因为直接操作内存地址可能会导致未定义行为。 赋值变量的地址：这是更常见的做法，使用取地址运算符（&amp;）来获取变量的地址，并将其赋值给指针。 123//定义ptr2并且赋值，指向var地址int var = 10;int *ptr2 = &amp;var; 这里，ptr 被赋值为 var 的内存地址。 我们对上述代码进行图解： ptr2指向var的地址，也就是ptr2存储的是var的地址0x2be3。因为ptr2也是对象，所以计算机也会为它开辟空间，ptr2自己的地址为0x3f2b. 所以指针的地址也可以用另一个指针变量存储 123456789//定义ptr2并且赋值，指向var地址int var = 10;int *ptr2 = &amp;var;//ptr_address 存储ptr2的地址int** ptr_address = &amp;ptr2;std::cout &lt;&lt; &quot;var 的地址为: &quot; &lt;&lt; &amp;var &lt;&lt; std::endl;std::cout &lt;&lt; &quot;ptr2 存储的值为: &quot; &lt;&lt; ptr2 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;ptr2 地址为: &quot; &lt;&lt; &amp;ptr2 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;ptr_address 的值为: &quot; &lt;&lt; ptr_address &lt;&lt; std::endl; 上述代码打印结果为 1234var 的地址为: 0xad6a5ffc24ptr2 存储的值为: 0xad6a5ffc24ptr2 地址为: 0xad6a5ffc18ptr_address 的值为: 0xad6a5ffc18 可以看到我们通过ptr_address 可以存储ptr2的地址, ptr_address存储的是指针的地址，所以它是一个指针的指针类型(int**)，也叫做二级指针。 类型匹配因为在声明语句中指针的类型实际上被用于指定它所指向的对象的类型，所以二者必须匹配。 如果指针指向了一个其他类型的对象，那么会产生错误。 123456789double dval = 3.14;//正确，初始值是double类型的对象的地址double *pd = &amp;dval;//正确，初始值是指向double对象的指针double *pd2 = pd;//错误,pi的类型和pd类型不匹配//int * pi = pd;//错误，视图把double型对象的地址赋值给int型指针//int * pi = &amp;dval; 指针值指针的值（即地址）应属下列4种状态之一： 1.指向一个对象。 2.指向紧邻对象所占空间的下一个位置。 3.空指针，意味着指针没有指向任何对象。 4.无效指针，也就是上述情况之外的其他值。 试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。 访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。 尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。 利用指针访问对象我们可以利用*(解引用操作符)获取指针所指向的对象的数据，写法如下 1数据变量 = *指针 我们看下这个例子 123456//访问对象int ival = 42;//p_int存放着ival的地址，或者说p_int是指向变量ival的指针int * p_int = &amp;ival;//由符号*得到指针p所指向的对象，输出42std::cout &lt;&lt; *p_int ; 上面的例子通过*p_int获取p_int所指向的对象ival的值。输出42 利用指针修改对象因为指针存储的是对象的地址，通过解引用获取对象的数据，我们也可以通过解引用修改对象的值，基本格式为 1234567891011//访问对象int ival = 42;//p_int存放着ival的地址，或者说p_int是指向变量ival的指针int * p_int = &amp;ival;//由符号*得到指针p所指向的对象，输出42std::cout &lt;&lt; *p_int &lt;&lt; std::endl;//由符号*得到指针p所指向的对象，即可经由p_int为变量ival赋值*p_int = 0;std::cout &lt;&lt; * p_int &lt;&lt; std::endl;//打印ival的值std::cout &lt;&lt; &quot;ival 的值为&quot; &lt;&lt; ival &lt;&lt; std::endl; 注意 解引用操作仅适用于那些确实指向了某个对象的有效指针 1234//初始化一个空指针int* empty_pointer = nullptr;//打印空指针数据,非法//std::cout &lt;&lt; &quot;空指针指向数据是 &quot; &lt;&lt; *empty_pointer &lt;&lt; std::endl; 符号的多重含义像&amp;和＊这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义： 123456789101112//符号的多重含义int ival2 = 42;//&amp; 紧跟着类型名出现，因此是声明的一部分，r是一个引用int &amp;r = ival2;//* 紧跟着类型名出现，因此是声明的一部分，p是一个指针int *p;// &amp;出现在表达式中，是一个取地址符号p = &amp;ival2;// * 出现在表达式中，是一个解引用符号*p = ival2;//&amp; 是声明的一部分，*是一个解引用符号int &amp;r2 = *p; 空指针空指针包含几种定义方式 1234567891011//空指针定义方式//C++11 最推荐方式int *p1 = nullptr;//直接将p2初始化为字面量0int *p2 = 0;//需要使用#include&lt;cstdlib&gt;//等价于int * p3 = 0;int *p3 = NULL;std::cout &lt;&lt; &quot;p1: &quot; &lt;&lt; p1 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;p2: &quot; &lt;&lt; p2 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;p3: &quot; &lt;&lt; p3 &lt;&lt; std::endl; 得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。 nullptr是一种特殊类型的字面值。 另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。 过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。 注意事项 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行 12int zero = 0;pi = zero; 地址变换我们可以修改指针指向的地址，进而达到指向其他变量的目的. 指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。 一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。 指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象： 12345678910int ival3 = 42;//pval3 被初始化，但没有指向任何对象int *pval3 = 0;//pval4被初始化，指向ival3的地址int* pval4 = &amp;ival3;//将pval3的指向改为pval4的指向，二者同时指向ival3pval3 = pval4;std::cout &lt;&lt;&quot;ival3 的地址为：&quot; &lt;&lt; &amp;ival3 &lt;&lt; std::endl;std::cout &lt;&lt;&quot;pval3 指向的地址为 &quot; &lt;&lt; pval3 &lt;&lt; std::endl;std::cout &lt;&lt;&quot;pval4 指向的地址为 &quot; &lt;&lt; pval4 &lt;&lt; std::endl; 运行上述程序可以看到输出 123ival3 的地址为：0xf8329ff7a4pval3 指向的地址为 0xf8329ff7a4pval4 指向的地址为 0xf8329ff7a4 指针判空有时候我们需要判断指针是否为空，可以通过if判断，if大家没学，此处仅作演示和理解。 在C++ 中0为false，非0为true，所以一个空指针通过if判断，是false， 非空指针为true 1234567891011//空指针判断int * empty_pointer2 = nullptr;if(!empty_pointer)&#123; std::cout &lt;&lt; &quot;empty_pointer is empty&quot; &lt;&lt; std::endl;&#125;int test = 100;int * normal_pointer2 = &amp;test;if(normal_pointer2)&#123; std::cout &lt;&lt; &quot;normal pointer is not empty&quot; &lt;&lt; std::endl;&#125; 指针同样可以支持比较运算,判断相等（==），判断不等(!=)。 1234//判断指针是否相等if(normal_pointer2 != empty_pointer)&#123; std::cout &lt;&lt; &quot;normal_pointer 和 empty_pointer 不相等&quot;&lt;&lt; std::endl;&#125; 万能指针void＊是一种特殊的指针类型，可用于存放任意对象的地址。一个void＊指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： 123456//万能指针double obj = 3.14, *obj_pd = &amp;obj;//void 可以存放任何类型的对象的地址void * pv = &amp;obj;//pv 可以存储任意类型的地址pv = obj_pd; 利用void＊指针能做的事儿比较有限： 拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void＊指针。 不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 指向指针的指针以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。通过＊的个数可以区分指针的级别。也就是说，＊＊表示指向指针的指针，＊＊＊表示指向指针的指针的指针，以此类推： 1234567891011121314//以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，// 因此允许把指针的地址再存放到另一个指针当中。通过＊的个数可以区分指针的级别。// 也就是说，＊＊表示指向指针的指针，＊＊＊表示指向指针的指针的指针，以此类推：int ival4= 1024;// pival4指向了int型的数int *pival4 = &amp;ival4;//ppi指向了一个int型的指针int ** ppi = &amp;pival4;std::cout &lt;&lt; &quot;The value of ival\\n&quot; &lt;&lt; &quot;direct value: &quot; &lt;&lt; ival4 &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;indirect value: &quot; &lt;&lt; *pival4 &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;doubly indirect value : &quot; &lt;&lt; **ppi &lt;&lt; std::endl; 该程序使用三种不同的方式输出了变量ival的值：第一种直接输出；第二种通过int型指针pi输出；第三种两次解引用ppi，取得ival的值。 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用： 1234567891011//引用本身不是一个对象，因此不能定义指向引用的指针。// 但指针是对象，所以存在对指针的引用int init = 42;// pinit是一个int型的指针int *pinit;// rpinit是一个对指针pinit的引用int *&amp; rpinit = pinit;// rpinit引用了一个指针，因此给rpinit赋值&amp;init就是令pinit指向initrpinit = &amp;init;//解引用rpinit得到i,也就是p指向的对象，将init改为0*rpinit = 0; 指针运算指针可以进行算术运算，如递增（++）和递减（–），这些操作会改变指针所指向的内存地址。但是，这种操作仅限于指向数组元素的指针。 指针和数组在C++中，数组名在表达式中通常被当作指向数组首元素的指针。 12345678910111213//指针可以进行算术运算，如递增（++）和递减（--），// 这些操作会改变指针所指向的内存地址。但是，这种操作仅限于指向数组元素的指针。int arr[5] = &#123;1, 2, 3, 4, 5&#125;;int *ptr_arr = arr;std::cout &lt;&lt; &quot;ptr_arr is : &quot; &lt;&lt; ptr_arr &lt;&lt; std::endl;int firstElement = *ptr_arr;std::cout &lt;&lt; &quot;firstElement is &quot; &lt;&lt; firstElement &lt;&lt; std::endl;// 递增指针++ptr_arr; // ptr 现在指向 arr[1]std::cout &lt;&lt; &quot;ptr_arr is : &quot; &lt;&lt; ptr_arr &lt;&lt; std::endl;// 访问新位置的值int secondElement = *ptr_arr; // secondElement 等于 2std::cout &lt;&lt; &quot;secondElement is &quot; &lt;&lt; secondElement; 上述程序输出 1234ptr_arr is : 0x3160fffa30firstElement is 1ptr_arr is : 0x3160fffa34secondElement is 2 注意事项 指针必须在使用前被初始化，否则它们可能包含垃圾值，导致未定义行为。 指针运算（如递增和递减）仅适用于指向数组元素的指针。 指针的解引用操作必须确保指针不是空指针（nullptr），否则会导致运行时错误。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(5) 引用类型","date":"2024-09-16T00:38:52.000Z","path":"2024/09/16/cppbase05/","text":"类型分类1. 内置类型（基本类型）内置类型是C++语言自带的基本数据类型，主要包括以下几种： 整型（Integer Types） int：标准整型，通常为4字节。 short：短整型，通常为2字节。 long：长整型，通常为4或8字节（取决于平台）。 long long：更长的整型，通常为8字节。 unsigned：无符号整型，不支持负数。 unsigned short、unsigned long、unsigned long long：对应的无符号版本。 字符型（Character Types） char：字符型，通常为1字节。 wchar_t：宽字符型，通常为2或4字节（用于表示Unicode字符）。 char16_t、char32_t：用于表示UTF-16和UTF-32编码的字符。 浮点型（Floating Point Types） float：单精度浮点型，通常为4字节。 double：双精度浮点型，通常为8字节。 long double：扩展精度浮点型，通常为8字节或16字节（取决于平台）。 布尔型（Boolean Type） bool：布尔型，表示真（true）或假（false）。 2. 复合类型复合类型是由内置类型或其他复合类型组合而成的类型，主要包括以下几种： 数组（Array） 一组相同类型的数据元素，可以通过索引访问。 结构体（Struct） 一种用户定义的数据类型，可以包含不同类型的数据成员。 联合体（Union） 与结构体类似，但所有成员共享同一内存位置，只有一个成员可以在任何给定时间存储值。 枚举（Enum） 一种用户定义的类型，用于定义一组命名的整型常量。 类（Class） C++的面向对象编程特性，允许定义包含数据和成员函数的复杂数据类型。 指针（Pointer） 指向其他类型的内存地址，可以用来动态分配内存和实现复杂的数据结构。 引用（Reference） 对现有变量的别名，提供了对变量的另一种访问方式。 引用类型定义C++ 中的引用类型是一种复合类型，它是对另一个变量的别名。在C++中使用引用，可以让我们直接访问和操作另一个变量的内存地址，而不需要通过指针的解引用操作。引用在语法上比指针更简洁，且在许多情况下更安全。 变量内存演示上面的定义很多人看起来很吃力，那我们回想一下变量的存储。 上面的图表示： 定义一个变量a，并且初始化为100，编译器会为变量a开辟空间，绿色的是开辟的空间，存储100，这个空间的首地址为0x2be3,也就是变量a的地址。 地址大家可以裂解为门牌号，我们可以通过门牌号找到绿色的家，a是绿色的家的名字，进而取出家里的物品，数据100可以理解为物品。 执行b = a，将a赋值给b后，编译器又开辟了一块空间，存储100，这个空间的首地址为0x3f2b。 打个比方，我们又创建了一个家，家的名字是b，家里也存储了100这个物品，但是这个家的地址和a的不一样。 引用内存演示 我们同样定义了一个变量a，并为它开辟空间，存储100，空间的首地址为0x2be3 我们定义了一个引用b，它是a的别名，所以b的地址和a的地址都一样，都是0x2be3 从上述图形可以看出，引用是变量的别名。 写法引用的基本写法 1234// 定义变量aint a = 100;// 定义引用b并且指向a, b就是a的别名int &amp;b = a; 大家能看到，在定义引用b的时候在int和b之间我们加了&amp;符号, 这个int &amp;表示的就是b是int类型的引用变量。 这里再提前告诉大家一个方法查看a和b地址是否相同， 当我们想输出a和b的地址的时候，只需要在a和b前加&amp;即可输出他们的地址 12std::cout &lt;&lt; &quot;a的地址为：&quot; &lt;&lt; &amp;a &lt;&lt; std::endl;std::cout &lt;&lt; &quot;b的地址为: &quot; &lt;&lt; &amp;b &lt;&lt; std::endl; 上面输出 12a的地址为：0x7ff65cae3000b的地址为: 0x7ff65cae3000 可以看到a和b的地址相同。也证明了a和b是指向同一个地址空间。所以我们修改a的值，b的值也会变 123456789101112// 定义变量aint a = 100;// 定义引用b并且指向a, b就是a的别名int &amp;b = a;// 输出a和b的值std::cout &lt;&lt; &quot;a的值:&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; &quot;b的值: &quot; &lt;&lt; b &lt;&lt; std::endl;// a和b是指向同一个变量。所以我们修改a的值，b的值也会变a = 200;std::cout &lt;&lt; &quot;修改a的值后，a和b的值分别为:\\n&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; b &lt;&lt; std::endl; 程序输出如下 12345a的值:100b的值: 100修改a的值后，a和b的值分别为:200200 可以看到修改了a的值，b也跟着变化了，接下来我们修改b的值 1234// 修改b的值，a的值也会变b = 300;std::cout &lt;&lt; &quot;修改b的值后，a和b的值分别为:\\n&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; b &lt;&lt; std::endl; 程序输出 123修改b的值后，a和b的值分别为:300300 可以看到b的值修改了，a的值也变化了 12345678// 定义c，存储a的值int c = a;std::cout &lt;&lt; &quot;c的值:&quot; &lt;&lt; c &lt;&lt; std::endl;// 修改c的值c = 400;std::cout &lt;&lt; &quot;修改c的值后，c为:&quot; &lt;&lt; c &lt;&lt; std::endl;std::cout &lt;&lt; &quot;修改c的值后，a和b的值分别为:\\n&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; b &lt;&lt; std::endl; 程序输出如下 1234修改c的值后，c为:400修改c的值后，a和b的值分别为:300300 可以看到c为a的副本，修改c不影响到a和b。 特性 必须初始化：引用在创建时必须被初始化，它必须指向某个已存在的对象。 一旦绑定，不可改变：引用一旦被初始化后，它将一直保持与其初始对象的绑定，不能改变为另一个对象的引用。 没有空引用：引用必须指向某个对象，不能存在空引用。 看下面的例子 123456789101112131415161718#include &lt;iostream&gt;int main() &#123; int a = 100; int &amp;b = a; // b是a的引用 std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl; // 输出: a = 100, b = 100 b = 200; // 更改b的值也会更改a的值 std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl; // 输出: a = 200, b = 200 // int c = 300; // 表示修改b的值为c的值 // b = c; return 0;&#125; 注意事项 引用主要用于函数参数和返回值，以及类的成员变量等场景，以提供对原始数据的直接访问，从而提高程序的效率和可读性。 引用可以是const的，这表示你不能通过引用来修改它所指向的对象的值。 引用在内部实现上通常是通过指针来实现的，但它们在语法和用途上与指针有显著的不同。引用提供了更直观、更安全的访问方式。 左值引用和右值引用在C++中，左值（lvalue）和右值（rvalue）是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。左值通常指的是具有持久状态的对象，它们有明确的内存地址，可以被多次赋值。而右值通常是临时的、没有持久状态的值，它们通常没有内存地址，或者其内存地址在表达式结束后就变得无效。 C++11引入了右值引用（rvalue reference），用T&amp;&amp;表示，作为对左值引用（lvalue reference，用T&amp;表示）的补充。这一特性极大地增强了C++的表达能力，特别是在资源管理和性能方面。 左值引用左值引用是C++98就有的特性，它允许我们为已存在的对象创建一个别名。左值引用必须被初始化为一个左值，即一个具有持久状态的对象。 12int a = 10;int&amp; b = a; // b是a的左值引用 右值引用右值引用是C++11新增的特性，它允许我们为右值（即临时对象或即将被销毁的对象）创建一个引用。这样，我们就可以对右值进行更复杂的操作，比如移动语义（move semantics）。 1234567int&amp;&amp; c = 20; // c是整数字面量20的右值引用（但这种情况不常见，通常用于函数参数或返回值）std::string foo() &#123; return std::string(&quot;Hello, World!&quot;); // 返回的临时字符串是一个右值&#125;std::string &amp;&amp;d = foo(); // d是foo()返回的临时字符串的右值引用 但请注意，直接绑定一个右值到右值引用（如int&amp;&amp; c = 20;）并不是右值引用的主要用途。右值引用的主要用途是作为函数参数（实现移动语义）和返回值（允许链式调用等）。 移动语义和完美转发右值引用的引入主要是为了支持移动语义（move semantics），它允许我们在对象被销毁前“窃取”其资源（如动态分配的内存、文件句柄等），而不是进行深拷贝。这可以显著提高性能，特别是在处理大型对象或容器时。 完美转发（perfect forwarding）是另一个与右值引用相关的概念，它允许我们将参数原封不动地传递给另一个函数，无论是左值还是右值。这通过模板和std::forward函数实现。 总结 左值引用（T&amp;）是C++98就有的特性，用于为已存在的对象创建别名。 右值引用（T&amp;&amp;）是C++11新增的特性，用于为右值（即临时对象）创建引用，支持移动语义和完美转发等高级特性。 右值引用的主要用途不是直接绑定到字面量或简单的右值表达式上，而是在函数参数和返回值中，以实现更高效的资源管理和更灵活的代码编写方式。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(4) extern的作用","date":"2024-09-14T09:10:54.000Z","path":"2024/09/14/cppbase04/","text":"重定义问题如何解决产生原因前文我们说过头文件只能用来做文件的声明，源文件用来做文件的实现。如果我们在头文件中定义变量会怎么样呢？ 假设我们在global.h中定义了两个变量 123456#ifndef DAY05_EXTERN_GLOBAL_H#define DAY05_EXTERN_GLOBAL_H#include &lt;string&gt;int global_age = 10;std::string global_name = &quot;llfc&quot;;#endif //DAY05_EXTERN_GLOBAL_H 然后我们创建global.cpp包含global.h 1#include &quot;global.h&quot; 然后我们在main.cpp中包含global.h 12345678#include &lt;iostream&gt;#include &quot;global.h&quot;int main() &#123; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;globbal name is&quot; &lt;&lt; global_name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;global age is &quot; &lt;&lt; global_age &lt;&lt; std::endl; return 0;&#125; 我们运行上述代码, 程序编译并未产生问题,但是链接产生问题了 1234[1/3] Building CXX object CMakeFiles/day05_extern.dir/global.cpp.obj[2/3] Building CXX object CMakeFiles/day05_extern.dir/main.cpp.obj[3/3] Linking CXX executable day05_extern.exeFAILED: day05_extern.exe 再往下看 12multiple definition of `global_age&#x27;; CMakeFiles/day05_extern.dir/main.cpp.obj: /global.h:8: first defined heremultiple definition of `global_name[abi:cxx11]&#x27;; CMakeFiles/day05_extern.dir/main.cpp.obj:/global.h:9: first defined here 上述报错的意思是在链接main.cpp.obj时发现global_age重定义，第一次定义在global.h这里。 同样链接mian.cpp.obj时发现global_name重定义，第一次定义在global.h。 因为global.h中定义了global_age，根据我们之前学习的预编译知识，只要是包含global.h的文件都会展开global.h，main.cpp展开了一次，global.cpp展开了一次 解决办法extern的作用在C++中，extern 关键字用于声明一个变量或函数是在另一个文件或同一个文件的其他位置定义的。这主要用于处理全局变量或函数声明，确保在多个源文件中能够正确地链接到这些全局变量或函数的定义。 解决办法可以采用extern关键字声明变量，然后将变量的定义放在global.cpp中, 这样main.cpp包含global.h就只会展开声明。声明可以重复声明，不会有问题。 在global.h中用extern声明两个变量 123456#ifndef DAY05_EXTERN_GLOBAL_H#define DAY05_EXTERN_GLOBAL_H#include &lt;string&gt;extern int global_age ;extern std::string global_name ;#endif //DAY05_EXTERN_GLOBAL_H 在global.cpp中定义这些变量 12345#include &quot;global.h&quot;#include &lt;string&gt;// 定义全局变量std::string global_name = &quot;John Doe&quot;;int global_age = 30; 在main.cpp中包含global.h 12345678#include &lt;iostream&gt;#include &quot;global.h&quot;int main() &#123; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;globbal name is&quot; &lt;&lt; global_name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;global age is &quot; &lt;&lt; global_age &lt;&lt; std::endl; return 0;&#125; 再次编译，运行成功 123Hello, World!globbal name isJohn Doeglobal age is 30 总结 头文件只做变量的声明，不能做变量的定义 头文件声明变量可以采用extern的方式","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(3) 认识头文件和源文件","date":"2024-09-08T01:14:44.000Z","path":"2024/09/08/cppbase03/","text":"头文件和源文件在C++中，头文件（.h 或 .hpp 文件）和源文件（.cpp 文件）是组织代码的重要部分，它们共同工作以构建程序。这种分离有助于模块化和代码重用，同时也使得编译过程更加高效。 头文件（.h 或 .hpp）头文件主要用于声明（declarations），包括： 类（class）的声明 函数（functions）的原型（prototypes） 模板（templates）的声明 宏定义（#define） 外部变量（extern variables）的声明 内联函数（inline functions） 头文件通常包含预处理指令如 #ifndef、#define 和 #endif，这些指令用于防止头文件被重复包含（也称为“头文件保护”或“包含卫士”）。 示例头文件（example.h）: 12345678910#ifndef EXAMPLE_H#define EXAMPLE_Hclass MyClass &#123;public: MyClass(); // 构造函数声明 void myFunction(); // 成员函数声明&#125;;#endif 源文件（.cpp）源文件包含实际的代码实现，即函数体、类的成员函数的实现等。源文件通常包括必要的头文件，以便编译器知道它们正在使用的函数、类等是如何声明的。 示例源文件（example.cpp）: 12345678910#include &quot;example.h&quot;#include &lt;iostream&gt;MyClass::MyClass() &#123; // 构造函数实现&#125;void MyClass::myFunction() &#123; std::cout &lt;&lt; &quot;Hello from MyClass::myFunction!&quot; &lt;&lt; std::endl;&#125; 编译过程在编译C++程序时，编译器会首先处理源文件（.cpp 文件）。对于源文件中的每个 #include 指令，编译器都会查找并包含相应的头文件（.h 或 .hpp 文件）。然后，编译器将处理源文件中的所有实现代码，并将它们与从头文件中获取的声明进行匹配。 注意事项 头文件应该只包含声明，源文件应该包含实现。 使用头文件保护来避免头文件被重复包含。 在大型项目中，合理组织头文件和源文件可以提高项目的可维护性和可扩展性。 在编译时，确保所有的源文件都被编译，并且所有的头文件都被正确包含。 通过这种方式，C++程序的结构变得更加清晰和模块化，有利于多人协作和代码重用。 #pragma once 和 宏定义（如 #ifndef, #define, #endif）都是用来防止头文件被重复包含的机制，但它们在工作方式和使用场景上存在一些区别。 pragma oncepragma once作用 工作方式：#pragma once 是一个非标准的但广泛支持的预处理指令，它告诉编译器该头文件在单个编译过程中只应被包含一次。编译器在第一次遇到 #pragma once 时会记住该文件名，并在后续的包含操作中忽略它。 优点：简单、直观、易于使用。不需要生成唯一的宏名，减少了出错的可能性。 缺点：不是 C++ 标准的一部分，尽管大多数现代编译器都支持它，但在某些旧的或特定的编译器中可能不受支持。 使用场景：在支持 #pragma once 的编译器中，推荐使用它作为防止头文件重复包含的首选方法。 宏定义（#ifndef, #define, #endif） 工作方式：通过宏定义（通常称为“包含卫士”或“头文件保护”）来防止头文件被重复包含。首先检查一个特定的宏是否已定义，如果没有定义，则定义它并包含头文件的其余部分。如果宏已经定义，则跳过头文件的其余部分。 优点：是 C++ 标准的一部分，因此在所有 C++ 编译器中都是可用的。 缺点：需要为每个头文件生成一个唯一的宏名，这可能会增加出错的机会（例如，如果两个头文件不小心使用了相同的宏名）。 使用场景：在需要确保代码与所有 C++ 编译器兼容时，或者在不支持 #pragma once 的编译器中，使用宏定义来防止头文件重复包含。 总结尽管 #pragma once 和 宏定义在功能上相似，但它们在实现方式和使用场景上有所不同。在大多数现代 C++ 项目中，推荐使用 #pragma once，因为它更简单、更直观，并且大多数现代编译器都支持它。然而，在需要确保与所有 C++ 编译器兼容的情况下，或者在不支持 #pragma once 的环境中，仍然需要使用宏定义来防止头文件被重复包含。 程序如何编译的g++编译 g++是GNU（GNU’s Not Unix）项目开发的C++编译器，它是GCC（GNU Compiler Collection，GNU编译器套件）的一个重要组成部分。GCC是一个支持多种编程语言的编译器集合，而g++则专门用于编译C++代码。 在使用g++编译C++程序时，可能需要安装GCC或g++编译器。在大多数Linux发行版和Unix系统中，GCC和g++通常作为标准软件包的一部分进行安装。在Windows系统中，则可能需要下载并安装MinGW或Cygwin等工具来提供GCC和g++的支持。 当使用 g++ 编译器编译 main.cpp 并希望包含相关的头文件时，你实际上不需要在编译命令中直接指定头文件。编译器会在编译过程中自动查找并包含你在 main.cpp 或其他已包含的头文件中通过 #include 指令指定的头文件。 然而，如果你的头文件位于非标准路径（即不在编译器的默认搜索路径中），你可能需要使用 -I 选项来指定额外的头文件搜索路径。 假设你的头文件 example.h 位于与 main.cpp 相同的目录下，或者位于编译器默认搜索的头文件路径中，你可以简单地使用以下命令来编译 main.cpp： 1g++ main.cpp -o myprogram 这里，-o myprogram 指定了输出文件的名称（在这个例子中是 myprogram）。如果你没有指定 -o 选项，编译器通常会生成一个名为 a.out 的可执行文件（在 Unix-like 系统中）。 如果你的头文件位于不同的目录，比如 include 目录，并且 main.cpp 中包含了 #include &quot;example.h&quot;，你需要使用 -I 选项来告诉编译器在哪里查找这个头文件： 1g++ -Iinclude main.cpp -o myprogram 在这个例子中，-Iinclude 告诉编译器在 include 目录下查找头文件。注意，-I 选项后面紧跟的是目录名，而不是文件名。 如果你的项目包含多个源文件（.cpp 文件）和/或多个头文件，并且它们位于不同的目录中， 你可能还需要使用 -L 选项来指定库文件的搜索路径（如果你链接了外部库的话），以及使用 -l 选项来指定要链接的库名（去掉前缀 lib 和后缀 .so 或 .a）。但是，对于仅包含头文件和源文件的简单项目，通常只需要上述的编译命令即可。 CMake跨平台编译CMake是一个跨平台的自动化构建系统，它使用CMakeLists.txt文件来描述构建过程。下面是一个CMake的基本写法示例，这将指导你如何编写一个简单的CMakeLists.txt文件来构建一个可执行文件。 示例：构建单个可执行文件假设你有一个C++源文件main.cpp，你想用CMake来构建它。首先，你需要创建一个名为CMakeLists.txt的文件，通常这个文件位于你的项目根目录下。 123456789# 设置CMake最小版本要求cmake_minimum_required(VERSION 3.10)# 设置项目名称和版本project(MyProject VERSION 1.0)# 添加一个可执行文件# 语法：add_executable(目标名 源文件...)add_executable(MyExecutable main.cpp) 在这个例子中： cmake_minimum_required(VERSION 3.10)：这行设置了CMake构建系统的最小版本要求。你需要确保你的CMake版本至少是3.10或更高。 project(MyProject VERSION 1.0)：这行设置了项目的名称（MyProject）和版本（1.0）。这个命令也会创建一个变量$&#123;PROJECT_NAME&#125;和$&#123;MyProject_VERSION&#125;，尽管直接使用MyProject_VERSION不是强制的，因为CMake通常建议使用$&#123;PROJECT_VERSION&#125;来引用版本。 add_executable(MyExecutable main.cpp)：这行定义了一个可执行文件目标。它告诉CMake你想将main.cpp编译成一个名为MyExecutable的可执行文件。构建时，CMake将自动找到适合你的平台的编译器和编译选项，并将main.cpp编译成可执行文件。 构建项目在命令行中，首先进入包含CMakeLists.txt的目录，然后运行以下命令来配置CMake项目（这将生成一个构建系统，如Makefile）： 123mkdir build # 创建一个名为build的目录（不是必须的，但推荐）cd buildcmake .. # 使用上级目录中的CMakeLists.txt配置项目 配置完成后，你可以使用生成的构建系统来构建项目。如果你使用的是Makefile（大多数Unix-like系统），则可以运行： 1make 这将编译你的项目，并生成可执行文件（在这个例子中是MyExecutable）。如果你是在Windows上，并且CMake配置的是生成Visual Studio项目文件，那么你需要使用Visual Studio来打开生成的项目文件并构建项目。 注意 CMake是一个非常强大的构建系统，支持多种编程语言、复杂的目标关系、库依赖、条件编译等高级功能。上面的例子仅展示了最基础的用法。 总是建议使用一个单独的构建目录（如上面的build目录），这样就不会污染你的源代码目录。 CMake提供了大量的命令和变量，可以用来精确控制构建过程。建议查阅CMake的官方文档以了解更多信息。","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"项目难点和面试技巧","date":"2024-09-06T23:58:19.000Z","path":"2024/09/07/cpppro30/","text":"简介项目第一季完结了，本文做一个整理，介绍面试将被问到的相关问题和技术难点，以及第二季将涉及的开发内容。 下面先介绍项目如何描述。 项目如何描述按照HR搜索简历的方式，基本都是采用关键字搜索，所以要在简历中暴露项目中的技术亮点。 为了让面试官通过简历快速的了解项目和采用的技术，需在项目介绍时融入技术细节，让项目描述更饱满一点。 可增加个人业绩或者个人成长，让面试官了解到项目的意义等。 所以综上所述，简单做个总结，一个项目的描述需包含如下几点： 项目描述 项目亮点 项目价值 项目描述 前端基于QT实现气泡聊天对话框，通过QListWidget实现好友列表，利用GridLayout和QPainter封装气泡聊天框，基于QT network模块封装http和tcp服务。支持添加好友，好友通信，聊天记录展示等功能，仿微信布局并使用qss优化界面 后端采用分布式设计，分为GateServer网关服务，多个ChatServer聊天服务，StatusServer状态服务以及VerifyServer验证服务。 各服务通过grpc通信，支持断线重连。GateServer网关对外采用http服务，负责处理用户登录和注册功能。登录时GateServer从StatusServer查询聊天服务达到负载均衡，ChatServer聊天服务采用asio实现tcp可靠长链接异步通信和转发, 采用多线程模式封装iocontext池提升并发性能。数据存储采用mysql服务，并基于mysqlconnector库封装连接池，同时封装redis连接池处理缓存数据，以及grpc连接池保证多服务并发访问。 经测试单服务器支持8000连接，多服务器分布部署可支持1W~2W活跃用户。 技术点 asio 网络库，grpc，Node.js，多线程，Redis, MySql，Qt 信号槽，网络编程，设计模式 项目意义 关于项目意义可结合自身讨论，比如项目解决了高并发场景下单个服务连接数吃紧的情况，提升了自己对并发和异步的认知和处理能力等。 考察点1 如何利用asio实现的tcp服务 利用asio 的多线程模式，根据cpu核数封装连接池，每个连接池跑在独立线程，采用异步async_read和assync_write方式读写，通过消息回调完成数据收发。每个连接通过session类管理，底层绑定用户id和session关联，回调函数可根据session反向查找用户进行消息推送。通过tlv方式封装消息包防止粘包。通过心跳机制检测连接可用性。 2 如何保证服务高可用 故障检测与自动恢复： 实施监控系统，实时检测服务的健康状况。 配置自动重启或故障转移机制，确保在故障发生时能够迅速恢复服务。 分布式架构： 采用微服务架构，将应用拆分为多个独立的服务，降低单个服务故障对整体系统的影响。 数据备份与恢复： 定期备份数据，并进行恢复演练，确保在数据丢失或损坏时能够快速恢复。 多活部署： 在不同地理位置部署多个活跃的数据中心，确保在某个数据中心发生故障时，其他数据中心可以继续提供服务。 3 为何封装Mysql连接池​ 首先多个线程使用同一个mysql连接是不安全的，所以要为每个线程分配独立连接，而连接数不能随着线程数无线增加，所以考虑连接池，每个线程想要操作mysql的时候从连接池取出连接进行数据访问。Mysql连接池封装包括Mgr管理层和Dao数据访问层，Mgr管理层是单例模式，Dao层包含了一个连接池，采用生产者消费者模式管理可用连接，并且通过心跳定时访问mysql保活连接。 4 如何测试性能​ 测试性能分为三个方面： 压力测试，测试服务器连接上限 测试一定连接数下，收发效率稳定性 采用pingpong协议，收发效率稳定在10ms下，连接数上限 压力测试，看服务器性能，客户端初始多个线程定时间隔连接，单服务节点连接上限两w以上稳定连接，并未出现掉线情况 测试稳定性，单服务节点连接数1W情况下，收发稳定未出现丢包和短线，并且延迟稳定在10ms 保证10ms延迟情况下，增加连接数，测下连接数上限，这个看机器性能，8000~2W连接不等。 5 用到哪些设计模式和思想 生产者消费者模式（涉及线程池） 单例模式(网络管理和数据库管理类) RAII思想(defer 回收连接) 代理模式(数据库，redis等通过代理对接应用层调用，底层线程池隐藏技术细节) MVC控制思想，客户端通过MVC三层结构设计 线程分离，网络线程，数据处理线程，以及UI渲染线程分离 心跳服务 数据序列化压缩发送(Protobuf) 队列解耦合，服务器采用发送队列保证异步顺序，通过接受队列缓存收到数据，通过逻辑队列处理数据。 分布式设计，多服务通过grpc通信，支持断线重连 C++11 现代化技术，智能指针，模板类型推导，线程池等 6 描述线程池封装​ 描述线程池封装，线程池采用C++ 11 风格编写，整体来说线程池通过单例封装，内部初始化N个线程，采用生产者消费者方式管理线程，包含任务队列，任务队列采用package_task打包存储，提供对外接口commit提交任务，采用bind语法实现任务提交在commit内部自行绑定，通过智能指针伪闭包方式保证任务生命周期。同时使用C++ 11 future特性，允许外部等待任务执行完成。 第二季待完成内容待开发内容 未实现资源服务器及断点续传 客户端和聊天服务的心跳机制 实现断线重连和踢人操作(未完全实现，目前仅支持客户端重新登录，服务器重新绑定连接，原连接未踢掉) 未完整实现用户离线后数据清空操作 客户端未实现信息编辑，头像上传等UI和逻辑 未实现文本，图片，语音等信息传输 未实现语音，视频实时通信","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"零基础C++(2) 作用域和存储空间","date":"2024-08-31T02:08:55.000Z","path":"2024/08/31/cppbase02/","text":"变量计算 整型， 浮点，双精度等变量支持计算，所谓计算就是我们熟悉的 + ,-,*,/,%等 12345678910111213141516171819202122232425void calculate()&#123; //整形变量支持计算，所谓计算就是我们熟悉的 `+` ,`-`,`*`,`/`,`%`等 int a = 10; int b = 20; std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a+b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a - b = &quot; &lt;&lt; a-b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a * b = &quot; &lt;&lt; a*b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a / b = &quot; &lt;&lt; a/b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a % b = &quot; &lt;&lt; a%b &lt;&lt; std::endl; //浮点型变量支持计算，所谓计算就是我们熟悉的 `+` ,`-`,`*`,`/`等 float c = 10.5; float d = 20.3; std::cout &lt;&lt; &quot;c + d = &quot; &lt;&lt; c+d &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c - d = &quot; &lt;&lt; c-d &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c * d = &quot; &lt;&lt; c*d &lt;&lt; std::endl; std::cout &lt;&lt; &quot;c / d = &quot; &lt;&lt; c/d &lt;&lt; std::endl; //浮点型变量支持计算，所谓计算就是我们熟悉的 `+` ,`-`,`*`,`/`等 double e = 10.5; double f = 20.3; std::cout &lt;&lt; &quot;e + f = &quot; &lt;&lt; e+f &lt;&lt; std::endl; std::cout &lt;&lt; &quot;e - f = &quot; &lt;&lt; e-f &lt;&lt; std::endl; std::cout &lt;&lt; &quot;e * f = &quot; &lt;&lt; e*f &lt;&lt; std::endl; std::cout &lt;&lt; &quot;e / f = &quot; &lt;&lt; e/f &lt;&lt; std::endl;&#125; ASCII码表计算机中字符是用ASCII码记录的，ASCII码为128字符（0-127）分配了唯一的数字编码，包括英文字母（大小写）、数字、标点符号和一些控制字符（如换行、回车等）。 比如字符‘A’ 对应十进制的65，字符‘a&#39;对应十进制的97. 所以字符也可以计算 1234567//字符变量支持计算，所谓计算就是我们熟悉的 `+` ,`-`,`*`,`/`等char g = &#x27;a&#x27;;char h = &#x27;b&#x27;;std::cout &lt;&lt; &quot;g + h = &quot; &lt;&lt; (int)(g+h) &lt;&lt; std::endl;std::cout &lt;&lt; &quot;g - h = &quot; &lt;&lt; (int)(g-h) &lt;&lt; std::endl;std::cout &lt;&lt; &quot;g * h = &quot; &lt;&lt; (int)(g*h) &lt;&lt; std::endl;std::cout &lt;&lt; &quot;g / h = &quot; &lt;&lt; (int)(g/h) &lt;&lt; std::endl; 类型划分 各种数据类型可以支持转换，double, float，int, char 这种C++给我们提供的基本类型也叫做内置类型。 我们以后学习了结构体struct和class等自定义类型后，这些类型叫做复合类型，引用和指针也属于复合类型。 变量大小前文提过变量是存储在存储单元中，那么计算机为不同的变量分配的大小也不一样, 可以通过sizeof计算类型的大小 1234567void sizeofnum()&#123; std::cout &lt;&lt; &quot;Size of char: &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; bytes\\n&quot;; std::cout &lt;&lt; &quot;Size of int: &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; bytes\\n&quot;; std::cout &lt;&lt; &quot;Size of float: &quot; &lt;&lt; sizeof(float) &lt;&lt; &quot; bytes\\n&quot;; std::cout &lt;&lt; &quot;Size of double: &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; bytes\\n&quot;; std::cout &lt;&lt; &quot;Size of long long: &quot; &lt;&lt; sizeof(long long) &lt;&lt; &quot; bytes\\n&quot;;&#125; 12345Size of char: 1 bytesSize of int: 4 bytesSize of float: 4 bytesSize of double: 8 bytesSize of long long: 8 bytes 类型转换这里仅看下内置类型转换，C++会自动推导转换, 复合类型之后再介绍。 1B = 8bit 最大能表示127 123456789char a = 100; // 100 是int类型，然后赋值给 char， int是四字节，char 是1字节，如果数字过大会损失精度。int b = a; // char 转换为 int类型，不会损失数据double c = b; // int 转换为 double（算数转换）std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; static_cast&lt;int&gt;(a) &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;// 注意：下面的转换可能会导致数据丢失unsigned int d = -1; // int 转换为 unsigned int，导致数据丢失std::cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; std::endl; // 输出一个很大的数 变量作用域在C++中，变量作用域（Scope）指的是程序中变量可以被访问的代码区域。作用域决定了变量的生命周期和可见性。 我可以解释几种常见的变量作用域类型： 全局作用域：在函数外部声明的变量具有全局作用域。它们可以在程序的任何地方被访问，但通常建议在需要时才使用全局变量，因为它们可能导致代码难以理解和维护。 局部作用域：在函数内部、代码块（如if语句、for循环等）内部声明的变量具有局部作用域。它们只能在声明它们的代码块内被访问。一旦离开该代码块，这些变量就不再可见。 命名空间作用域：在命名空间中声明的变量（实际上是实体，如变量、函数等）具有命名空间作用域。它们只能在相应的命名空间内被直接访问，但可以通过使用命名空间的名称作为前缀来从外部访问。 类作用域：在类内部声明的成员变量和成员函数具有类作用域。成员变量和成员函数可以通过类的对象来访问，或者在某些情况下（如静态成员）可以通过类名直接访问。 块作用域：这是局部作用域的一个特例，指的是由大括号&#123;&#125;包围的代码块内部声明的变量。这些变量只能在该代码块内被访问。 全局作用域1234567891011121314#include &lt;iostream&gt;// 全局变量，具有全局作用域int globalVar = 42;void func() &#123; std::cout &lt;&lt; &quot;Inside func: globalVar = &quot; &lt;&lt; globalVar &lt;&lt; std::endl;&#125;int main() &#123; std::cout &lt;&lt; &quot;Inside main: globalVar = &quot; &lt;&lt; globalVar &lt;&lt; std::endl; func(); // 访问全局变量 return 0;&#125; 局部作用域123456789101112131415#include &lt;iostream&gt;void func() &#123; // 局部变量，具有局部作用域 int localVar = 10; std::cout &lt;&lt; &quot;Inside func: localVar = &quot; &lt;&lt; localVar &lt;&lt; std::endl; // localVar 在这里之后就不再可见&#125;int main() &#123; // 尝试访问 localVar 会导致编译错误 // std::cout &lt;&lt; &quot;localVar = &quot; &lt;&lt; localVar &lt;&lt; std::endl; // 错误 func(); // 局部变量仅在func函数内部可见 return 0;&#125; 命名空间作用域12345678910111213141516171819202122232425#include &lt;iostream&gt;// 定义一个命名空间namespace MyNamespace &#123; // 命名空间内的变量，具有命名空间作用域 int namespaceVar = 20; void printVar() &#123; std::cout &lt;&lt; &quot;Inside MyNamespace: namespaceVar = &quot; &lt;&lt; namespaceVar &lt;&lt; std::endl; &#125; int globalVar = 0;&#125;namespace MyNamespace2 &#123; int globalVar = 0;&#125;int main() &#123; // 使用命名空间前缀访问变量 std::cout &lt;&lt; &quot;Outside MyNamespace: namespaceVar = &quot; &lt;&lt; MyNamespace::namespaceVar &lt;&lt; std::endl; MyNamespace::printVar(); // 访问命名空间内的函数 return 0;&#125; 类作用域123456789101112131415161718192021#include &lt;iostream&gt;class MyClass &#123;public: // 成员变量，具有类作用域 int classVar; // 成员函数，也可以访问类作用域内的成员变量 void printVar() &#123; std::cout &lt;&lt; &quot;Inside MyClass: classVar = &quot; &lt;&lt; classVar &lt;&lt; std::endl; &#125;&#125;;int main() &#123; MyClass obj; obj.classVar = 30; // 通过对象访问成员变量 obj.printVar(); // 访问成员函数 // 尝试直接访问 classVar 会导致编译错误 // std::cout &lt;&lt; &quot;classVar = &quot; &lt;&lt; classVar &lt;&lt; std::endl; // 错误 return 0;&#125; 块作用域1234567891011121314151617#include &lt;iostream&gt;void func() &#123; &#123; // 块内局部变量，具有块作用域 int blockVar = 5; std::cout &lt;&lt; &quot;Inside block: blockVar = &quot; &lt;&lt; blockVar &lt;&lt; std::endl; // blockVar 在这个代码块之后就不再可见 &#125; // 尝试访问 blockVar 会导致编译错误 // std::cout &lt;&lt; &quot;blockVar = &quot; &lt;&lt; blockVar &lt;&lt; std::endl; // 错误&#125;int main() &#123; func(); // 访问块作用域变量仅在func函数内部的代码块内有效 return 0;&#125; 存储区域在C++中，内存存储通常可以大致分为几个区域，这些区域根据存储的数据类型、生命周期和作用域来划分。这些区域主要包括： 代码区（Code Segment/Text Segment）： 存储程序执行代码（即机器指令）的内存区域。这部分内存是共享的，只读的，且在程序执行期间不会改变。 举例说明：当你编译一个C++程序时，所有的函数定义、控制结构等都会被转换成机器指令，并存储在代码区。 全局/静态存储区（Global/Static Storage Area）： 存储全局变量和静态变量的内存区域。这些变量在程序的整个运行期间都存在，但它们的可见性和生命周期取决于声明它们的作用域。 举例说明：全局变量（在函数外部声明的变量）和静态变量（使用static关键字声明的变量，无论是在函数内部还是外部）都会存储在这个区域。 栈区（Stack Segment）： 存储局部变量、函数参数、返回地址等的内存区域。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用和自动变量。 举例说明：在函数内部声明的变量（不包括静态变量）通常存储在栈上。当函数被调用时，其参数和局部变量会被推入栈中；当函数返回时，这些变量会从栈中弹出，其占用的内存也随之释放。 堆区（Heap Segment）： 由程序员通过动态内存分配函数（如new和malloc）分配的内存区域。堆区的内存分配和释放是手动的，因此程序员需要负责管理内存，以避免内存泄漏或野指针等问题。 举例说明：当你使用new操作符在C++中动态分配一个对象或数组时，分配的内存就来自堆区。同样，使用delete操作符可以释放堆区中的内存。 常量区（Constant Area）： 存储常量（如字符串常量、const修饰的全局变量等）的内存区域。这部分内存也是只读的，且通常在程序执行期间不会改变。 举例说明：在C++中，使用双引号括起来的字符串字面量通常存储在常量区。此外，使用const关键字声明的全局变量，如果其值在编译时就已确定，也可能存储在常量区。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt; // 用于strlen// 全局变量，存储在全局/静态存储区int globalVar = 10;// 静态变量，也存储在全局/静态存储区，但仅在其声明的文件或函数内部可见static int staticVar = 20;void func() &#123; // 局部变量，存储在栈区 int localVar = 30; // 静态局部变量，虽然声明在函数内部，但存储在全局/静态存储区，且只在第一次调用时初始化 static int staticLocalVar = 40; std::cout &lt;&lt; &quot;Inside func:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;localVar = &quot; &lt;&lt; localVar &lt;&lt; std::endl; std::cout &lt;&lt; &quot;staticLocalVar = &quot; &lt;&lt; staticLocalVar &lt;&lt; std::endl; // 尝试通过动态内存分配在堆区分配内存 int* heapVar = new int(50); std::cout &lt;&lt; &quot;heapVar = &quot; &lt;&lt; *heapVar &lt;&lt; std::endl; // 释放堆区内存（重要：实际使用中不要忘记释放不再使用的堆内存） delete heapVar;&#125;int main() &#123; // 访问全局变量 std::cout &lt;&lt; &quot;Inside main:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;globalVar = &quot; &lt;&lt; globalVar &lt;&lt; std::endl; std::cout &lt;&lt; &quot;staticVar = &quot; &lt;&lt; staticVar &lt;&lt; std::endl; // 注意：staticVar在外部不可见（除非在同一个文件中或通过特殊方式） // 调用函数，展示栈区和堆区的使用 func(); // 字符串常量通常存储在常量区，但直接访问其内存地址并不是标准C++的做法 // 这里我们仅通过指针来展示其存在 const char* strConst = &quot;Hello, World!&quot;; // 注意：不要尝试修改strConst指向的内容，因为它是只读的 std::cout &lt;&lt; &quot;strConst = &quot; &lt;&lt; strConst &lt;&lt; std::endl; // 尝试获取字符串常量的长度（这不会修改常量区的内容） std::cout &lt;&lt; &quot;Length of strConst = &quot; &lt;&lt; strlen(strConst) &lt;&lt; std::endl; return 0;&#125; 在这个示例中，我使用了全局变量、静态变量、局部变量、静态局部变量以及通过new操作符在堆上分配的内存来展示不同内存区域的使用。同时，我也提到了字符串常量，但请注意，直接访问其内存地址并不是C++编程中的标准做法，因为字符串常量通常是只读的，并且其存储位置取决于编译器和操作系统的实现。 另外，请注意，我在func函数中分配了堆内存并通过delete操作符释放了它。这是管理堆内存时的一个重要实践，以避免内存泄漏。然而，在实际应用中，更复杂的内存管理策略（如智能指针）可能更为合适。 当您编译这个程序时，编译器会将main函数和func函数的代码转换成机器指令，并将这些指令存储在可执行文件的代码区中（尽管实际上是在磁盘上的可执行文件中，但在程序运行时，操作系统会将这些指令加载到内存的代码区中）。然后，当您运行这个程序时，CPU会从内存的代码区中读取这些指令并执行它们。 程序编译过程C++程序的编译过程是一个相对复杂但有序的过程，它涉及将高级语言（C++）代码转换为机器可以执行的低级指令。在这个过程中，通常会生成几个中间文件，包括.i（预处理文件）、.s（汇编文件）和.o（目标文件或对象文件）。下面是这个过程的详细解释： 1. 预处理（Preprocessing） 输入：C++源代码文件（通常以.cpp或.cxx为后缀）。 处理：预处理器（通常是cpp）读取源代码文件，并对其进行宏展开、条件编译、文件包含（#include）等处理。 输出：生成预处理后的文件，通常具有.i后缀（尽管这个步骤可能不是所有编译器都会自动生成.i文件，或者可能需要特定的编译器选项来生成）。 2. 编译（Compilation） 输入：预处理后的文件（如果有的话，否则直接是源代码文件）。 处理：编译器（如g++、clang++等）将预处理后的文件或源代码文件转换为汇编语言代码。这个步骤是编译过程的核心，它执行词法分析、语法分析、语义分析、中间代码生成、代码优化等任务。 输出：生成汇编文件，通常具有.s或.asm后缀。 3. 汇编（Assembly） 输入：汇编文件。 处理：汇编器（如as、gas等）将汇编语言代码转换为机器语言指令（即目标代码），但这些指令仍然是针对特定架构的，并且尚未被链接成可执行文件。 输出：生成目标文件（或对象文件），通常具有.o、.obj或.out后缀。 4. 链接（Linking） 输入：一个或多个目标文件，以及可能需要的库文件（如C++标准库）。 处理：链接器（如ld、lld等）将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用（即函数和变量的调用），并将它们链接到正确的地址。 输出：生成可执行文件（在Unix-like系统中通常是.out、.exe或没有特定后缀，在Windows系统中是.exe）。 我们将代码的CMakeList中设置编译选项，保存临时文件 12set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -save-temps=obj&quot;)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -save-temps=obj&quot;) 点击Clion中的build，可以看到目录中生成了临时文件，包括 .i 文件表示预处理文件 .s（汇编文件） .o（目标文件或对象文件） 总结 .i文件是预处理后的文件，包含了所有宏展开、条件编译和文件包含的结果。 .s文件是汇编文件，包含了将C++代码转换为汇编语言后的结果。 .o文件是目标文件或对象文件，包含了汇编器生成的机器语言指令，但尚未被链接成可执行文件。 这些文件在编译过程中扮演了重要的角色，帮助开发者理解和调试代码，同时也是编译链中不可或缺的一部分。不过，值得注意的是，并非所有编译器都会默认生成.i和.s文件，这可能需要特定的编译器选项来启用。 赞赏感谢支持","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"零基础C++(1) 变量和输出","date":"2024-08-31T02:08:48.000Z","path":"2024/08/31/cppbase01/","text":"变量变量定义在C++中，变量是用来存储数据值的一种实体。每个变量都有一个类型，这个类型决定了变量可以存储的数据的种类以及变量在内存中所占的空间大小。 通俗例子 我们家中会有收纳柜，收纳柜存储的是我们的物品。物品就相当于数据，收纳柜就相当于变量，不同的柜子有不同的类型，有的装内衣，有的装袜子。 装内衣的柜子一般不会装螺丝刀，一个柜子在定义好用来做什么，它存储的内容就确定了。 补充知识计算机中数据是按照二进制存储的，一个字节占8bit, bit就是位的意思，比如数字2会转化为二进制00000010, 然后将这个00000010放到计算机为我们分配好的存储单元里，这个存储单元本身还有一个地址，假设存储单元的地址为5，转化为二进制就是00000101. 当我们想要取出数据00000010时，需要先访问地址00000101找到存储单元，然后取出存储单元存储的数据。 再次理解以下，存储单元可以理解为一个变量，存储了数据00000010，变量的地址为00000101。理解这个，之后我们会介绍指针的概念。 变量的声明与初始化在C++中，你首先需要声明一个变量，然后（可选地）可以初始化它。声明变量时，你需要指定变量的类型和名称。 12345678// 声明一个整型变量age，未初始化int age; // 声明并初始化一个整型变量heightint height = 175; // 声明并初始化一个双精度浮点型变量weightdouble weight = 65.5; // 声明并初始化一个字符型变量genderchar gender = &#x27;M&#x27;; 变量命名规则在C++中，变量名可以包含字母、数字和下划线（_），但不能以数字开头。此外，C++是大小写敏感的，因此age和Age被视为两个不同的变量。 变量类型C++支持多种基本数据类型，包括整型（int、short、long、long long）、浮点型（float、double、long double）、字符型（char）、布尔型（bool）等。此外，C++还支持枚举（enum）、结构体（struct）、联合体（union）和类（class）等复合数据类型。 示例：使用变量1234567891011#include &lt;iostream&gt;int main() &#123; //初始化变量a和b int a = 5, b = 10; //a+b的值赋值给sum int sum = a + b; //输出求和的结果 std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 在这个示例中，我们声明了三个整型变量a、b和sum，并将a和b的值分别初始化为5和10。然后，我们计算a和b的和，并将结果存储在变量sum中。最后，我们使用std::cout输出计算结果。 1The sum of 5 and 10 is 15 输出运算符在C++中，输出通常是通过标准输出流（std::cout）来完成的。std::cout 是C++标准库中的一个对象，它代表标准输出设备，通常是屏幕。为了使用 std::cout 来输出数据，你需要包含头文件 &lt;iostream&gt;。 下面是一个简单的C++程序示例，展示了如何使用 std::cout 来输出文本和数字 12345678910111213141516171819202122232425#include &lt;iostream&gt; // 包含标准输入输出流库int main() &#123; // 输出字符串 std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; // 输出数字 int number = 42; std::cout &lt;&lt; &quot;The number is: &quot; &lt;&lt; number &lt;&lt; std::endl; // 输出浮点数 double pi = 3.14159; std::cout &lt;&lt; &quot;The value of pi is approximately: &quot; &lt;&lt; pi &lt;&lt; std::endl; // 输出字符 char ch = &#x27;A&#x27;; std::cout &lt;&lt; &quot;The character is: &quot; &lt;&lt; ch &lt;&lt; std::endl; // 输出布尔值（C++11及以后） bool truth = true; std::cout &lt;&lt; std::boolalpha; // 启用布尔值的true/false输出 std::cout &lt;&lt; &quot;The truth is: &quot; &lt;&lt; truth &lt;&lt; std::endl; return 0;&#125; 在这个例子中，&lt;&lt; 是插入运算符，用于将右侧的数据发送到左侧的流对象（在这个例子中是 std::cout）。std::endl 是一个操纵符，用于在输出后插入换行符，并刷新输出缓冲区，确保立即在屏幕上显示输出。 12345Hello, World!The number is: 42The value of pi is approximately: 3.14159The character is: AThe truth is: true 理解即可 注意，为了输出布尔值 true 和 false 而不是整数 1 和 0，我们使用了 std::boolalpha 操纵符。这是C++11及以后版本中引入的，用于控制布尔值的输出格式。 此外，C++还支持格式化输出，但这通常涉及更复杂的语法，如使用 std::iomanip 头文件中定义的操纵符（如 std::setw 和 std::setprecision或使用C++20引入的新特性（如格式化库 std::format，尽管这不是通过 std::cout 直接使用的，而是用于生成格式化字符串）。 练习定义初始化一个变量pai_val数值为 3.14， 初始化一个int类型的变量int_val变量值为5，分别输出这两个变量的值。 初始化一个bool变量数值为-100，输出bool变量的值，看看是true还是false。 赞赏感谢支持","categories":[{"name":"零基础C++","slug":"cppbase","permalink":"http://www.limerence2017.com/categories/cppbase/"}],"tags":[{"name":"零基础C++","slug":"零基础C","permalink":"http://www.limerence2017.com/tags/%E9%9B%B6%E5%9F%BA%E7%A1%80C/"}]},{"title":"C++ 全栈聊天项目(1)架构概述和登录界面","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro1/","text":"简介本项目为C++全栈聊天项目实战，包括PC端QT界面编程，asio异步服务器设计，beast网络库搭建http网关，nodejs搭建验证服务，各服务间用grpc通信，server和client用asio通信等，也包括用户信息的录入等。实现跨平台设计，先设计windows的server，之后再考虑移植到windows中。较为全面的展示C++ 在实际项目中的应用，可作为项目实践学习案例，也可写在简历中。 架构设计一个概要的结构设计如下图 GateServer为网关服务，主要应对客户端的连接和注册请求，因为服务器是是分布式，所以GateServer收到用户连接请求后会查询状态服务选择一个负载较小的Server地址给客户端，客户端拿着这个地址直接和Server通信建立长连接。 当用户注册时会发送给GateServer, GateServer调用VarifyServer验证注册的合理性并发送验证码给客户端，客户端拿着这个验证码去GateServer注册即可。 StatusServer， ServerA， ServerB都可以直接访问Redis和Mysql服务。 创建应用我们先创建客户端的登录界面，先用qt创建qt application widgets 项目名称叫做llfcchat，位置大家自己选择。 接下来一路同意，最后生成项目。 为了增加项目可读性，我们增加注释模板 选择“工具”-&gt;“选项”，再次选择“文本编辑器”-&gt;“片段”-&gt;“添加”，按照下面的模板编排 123456789/****************************************************************************** * * @file %&#123;CurrentDocument:FileName&#125; * @brief XXXX Function * * @author 恋恋风辰 * @date %&#123;CurrentDate:yyyy\\/MM\\/dd&#125; * @history *****************************************************************************/ 如下图 以后输入header custom就可以弹出注释模板了. 修改mainwindow.ui属性,长宽改为300*500 将window title 改为llfcchat 大家自己找个icon.ico文件放到项目根目录，或者用我的也行，然后在项目pro里添加输出目录文件和icon图标 12RC_ICONS = icon.icoDESTDIR = ./bin 将图片资源添加ice.png添加到文件夹res里，然后右键项目选择添加新文件，选择qt resource files， 添加qt的资源文件，名字设置为rc。 添加成功后邮件rc.qrc选择添加现有资源文件， 选择res文件夹下的ice.png，这样ice.png就导入项目工程了。 创建登录界面右键项目，选择创建，点击设计师界面类 选择 dialog without buttons 创建的名字就叫做LoginDialog 将LoginDialog.ui修改为如下布局 在mainwindow.h中添加LoginDialog指针成员，然后在构造函数将LoginDialog设置为中心部件 12345678910MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); //创建一个CentralWidget, 并将其设置为MainWindow的中心部件 _login_dlg = new LoginDialog(); setCentralWidget(_login_dlg); _login_dlg-&gt;show();&#125; 创建注册界面注册界面创建方式和登录界面类似，我们创建的界面如下: 创建好界面后接下来在LoginDialog类声明里添加信号切换注册界面 12signals: void switchRegister(); 在LoginDialog的构造函数里连接按钮点击事件 1connect(ui-&gt;reg_btn, &amp;QPushButton::clicked, this, &amp;LoginDialog::switchRegister); 按钮点击后LoginDialog发出switchRegister信号，该信号发送给MainWindow用来切换界面。 我们在MainWindow里声明注册类变量 12private: RegisterDialog* _reg_dlg; 在其构造函数中添加注册类对象的初始化以及连接switchRegister信号 12345//创建和注册消息的链接connect(_login_dlg, &amp;LoginDialog::switchRegister, this, &amp;MainWindow::SlotSwitchReg);_reg_dlg = new RegisterDialog(); 接下来实现槽函数SlotSwitchReg 12345void MainWindow::SlotSwitchReg()&#123; setCentralWidget(_reg_dlg); _login_dlg-&gt;hide(); _reg_dlg-&gt;show();&#125; 这样启动程序主界面优先显示登录界面，点击注册后跳转到注册界面 优化样式我们在项目根目录下创建style文件夹，在文件夹里创建stylesheet.qss文件，然后在qt项目中的rc.qrc右键添加现有文件，选择stylesheet.qss，这样qss就被导入到项目中了。 在主程序启动后加载qss 123456789101112131415161718192021int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QFile qss(&quot;:/style/stylesheet.qss&quot;); if( qss.open(QFile::ReadOnly)) &#123; qDebug(&quot;open success&quot;); QString style = QLatin1String(qss.readAll()); a.setStyleSheet(style); qss.close(); &#125;else&#123; qDebug(&quot;Open failed&quot;); &#125; MainWindow w; w.show(); return a.exec();&#125; 然后我们写qss样式美化界面 123QDialog#LoginDialog&#123;background-color:rgb(255,255,255)&#125; 主界面有一道灰色的是toolbar造成的，去mainwindow.ui里把那个toolbar删了就行了。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(10) 使用iocontext连接池提高并发","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro10/","text":"VerifyServer增加redis我们为了让验证码有一个过期时间，可以利用redis实现，在Verify文件夹用npm安装redis服务。 1npm install ioredis 完善config.json 123456789101112131415161718&#123; &quot;email&quot;: &#123; &quot;user&quot;: &quot;secondtonone1@163.com&quot;, &quot;pass&quot;: &quot;CRWTAZOSNCWDDQQTllfc&quot; &#125;, &quot;mysql&quot;: &#123; &quot;host&quot;: &quot;81.68.86.146&quot;, &quot;port&quot;: 3308, &quot;passwd&quot;: &quot;123456&quot; &#125;, &quot;redis&quot;:&#123; &quot;host&quot;: &quot;81.68.86.146&quot;, &quot;port&quot;: 6380, &quot;passwd&quot;: &quot;123456&quot; &#125;&#125; 服务里添加redis模块，封装redis操作在redis.js中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const config_module = require(&#x27;./config&#x27;)const Redis = require(&quot;ioredis&quot;);// 创建Redis客户端实例const RedisCli = new Redis(&#123; host: config_module.redis_host, // Redis服务器主机名 port: config_module.redis_port, // Redis服务器端口号 password: config_module.redis_passwd, // Redis密码&#125;);/** * 监听错误信息 */RedisCli.on(&quot;error&quot;, function (err) &#123; console.log(&quot;RedisCli connect error&quot;); RedisCli.quit();&#125;);/** * 根据key获取value * @param &#123;*&#125; key * @returns */async function GetRedis(key) &#123; try&#123; const result = await RedisCli.get(key) if(result === null)&#123; console.log(&#x27;result:&#x27;,&#x27;&lt;&#x27;+result+&#x27;&gt;&#x27;, &#x27;This key cannot be find...&#x27;) return null &#125; console.log(&#x27;Result:&#x27;,&#x27;&lt;&#x27;+result+&#x27;&gt;&#x27;,&#x27;Get key success!...&#x27;); return result &#125;catch(error)&#123; console.log(&#x27;GetRedis error is&#x27;, error); return null &#125; &#125;/** * 根据key查询redis中是否存在key * @param &#123;*&#125; key * @returns */async function QueryRedis(key) &#123; try&#123; const result = await RedisCli.exists(key) // 判断该值是否为空 如果为空返回null if (result === 0) &#123; console.log(&#x27;result:&lt;&#x27;,&#x27;&lt;&#x27;+result+&#x27;&gt;&#x27;,&#x27;This key is null...&#x27;); return null &#125; console.log(&#x27;Result:&#x27;,&#x27;&lt;&#x27;+result+&#x27;&gt;&#x27;,&#x27;With this value!...&#x27;); return result &#125;catch(error)&#123; console.log(&#x27;QueryRedis error is&#x27;, error); return null &#125; &#125;/** * 设置key和value，并过期时间 * @param &#123;*&#125; key * @param &#123;*&#125; value * @param &#123;*&#125; exptime * @returns */async function SetRedisExpire(key,value, exptime)&#123; try&#123; // 设置键和值 await RedisCli.set(key,value) // 设置过期时间（以秒为单位） await RedisCli.expire(key, exptime); return true; &#125;catch(error)&#123; console.log(&#x27;SetRedisExpire error is&#x27;, error); return false; &#125;&#125;/** * 退出函数 */function Quit()&#123; RedisCli.quit();&#125;module.exports = &#123;GetRedis, QueryRedis, Quit, SetRedisExpire,&#125; server.js中包含redis.js 1const redis_module = require(&#x27;./redis&#x27;) 获取验证码之前可以先查询redis，如果没查到就生成uid并且写入redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950async function GetVarifyCode(call, callback) &#123; console.log(&quot;email is &quot;, call.request.email) try&#123; let query_res = await redis_module.GetRedis(const_module.code_prefix+call.request.email); console.log(&quot;query_res is &quot;, query_res) if(query_res == null)&#123; &#125; let uniqueId = query_res; if(query_res ==null)&#123; uniqueId = uuidv4(); if (uniqueId.length &gt; 4) &#123; uniqueId = uniqueId.substring(0, 4); &#125; let bres = await redis_module.SetRedisExpire(const_module.code_prefix+call.request.email, uniqueId,600) if(!bres)&#123; callback(null, &#123; email: call.request.email, error:const_module.Errors.RedisErr &#125;); return; &#125; &#125; console.log(&quot;uniqueId is &quot;, uniqueId) let text_str = &#x27;您的验证码为&#x27;+ uniqueId +&#x27;请三分钟内完成注册&#x27; //发送邮件 let mailOptions = &#123; from: &#x27;secondtonone1@163.com&#x27;, to: call.request.email, subject: &#x27;验证码&#x27;, text: text_str, &#125;; let send_res = await emailModule.SendMail(mailOptions); console.log(&quot;send res is &quot;, send_res) callback(null, &#123; email: call.request.email, error:const_module.Errors.Success &#125;); &#125;catch(error)&#123; console.log(&quot;catch error is &quot;, error) callback(null, &#123; email: call.request.email, error:const_module.Errors.Exception &#125;); &#125; &#125; 验证服务联调开启VerifyServer和GateServer，再启动客户端，点击获取验证码，客户端就会发送请求给GateServer，GateServer再调用内部服务VerifyServer。最后将请求返回客户端，完成了验证码发送的流程。 如果10分钟之内多次请求，因为验证码被缓存在redis中，所以会被复用返回给客户端。 看起来客户端收到服务器的回复了，我们去邮箱看看是否收到验证码 确实收到了验证码。好的多服务调用实现了，大家可以把这个功能理解下，接下来去实现注册逻辑。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(12) C++封装redis连接池","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro12/","text":"增加定时按钮点击获取验证码后需要让按钮显示倒计时，然后倒计时结束后再次可点击。添加TimberBtn类 12345678910111213141516171819#ifndef TIMERBTN_H#define TIMERBTN_H#include &lt;QPushButton&gt;#include &lt;QTimer&gt;class TimerBtn : public QPushButton&#123;public: TimerBtn(QWidget *parent = nullptr); ~ TimerBtn(); // 重写mouseReleaseEvent virtual void mouseReleaseEvent(QMouseEvent *e) override;private: QTimer *_timer; int _counter;&#125;;#endif // TIMERBTN_H 添加实现 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;timerbtn.h&quot;#include &lt;QMouseEvent&gt;#include &lt;QDebug&gt;TimerBtn::TimerBtn(QWidget *parent):QPushButton(parent),_counter(10)&#123; _timer = new QTimer(this); connect(_timer, &amp;QTimer::timeout, [this]()&#123; _counter--; if(_counter &lt;= 0)&#123; _timer-&gt;stop(); _counter = 10; this-&gt;setText(&quot;获取&quot;); this-&gt;setEnabled(true); return; &#125; this-&gt;setText(QString::number(_counter)); &#125;);&#125;TimerBtn::~TimerBtn()&#123; _timer-&gt;stop();&#125;void TimerBtn::mouseReleaseEvent(QMouseEvent *e)&#123; if (e-&gt;button() == Qt::LeftButton) &#123; // 在这里处理鼠标左键释放事件 qDebug() &lt;&lt; &quot;MyButton was released!&quot;; this-&gt;setEnabled(false); this-&gt;setText(QString::number(_counter)); _timer-&gt;start(1000); emit clicked(); &#125; // 调用基类的mouseReleaseEvent以确保正常的事件处理（如点击效果） QPushButton::mouseReleaseEvent(e);&#125; 然后将注册界面获取按钮升级为TimerBtn 调整输入框错误提示在RegisterDialog构造函数中删除原来的输入框editing信号和逻辑，添加editingFinished信号和处理逻辑。 12345678910111213141516171819202122//day11 设定输入框输入后清空字符串ui-&gt;err_tip-&gt;clear();connect(ui-&gt;user_edit,&amp;QLineEdit::editingFinished,this,[this]()&#123; checkUserValid();&#125;);connect(ui-&gt;email_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkEmailValid();&#125;);connect(ui-&gt;pass_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkPassValid();&#125;);connect(ui-&gt;confirm_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkConfirmValid();&#125;);connect(ui-&gt;varify_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkVarifyValid();&#125;); global.h中添加TipErr定义 123456789enum TipErr&#123; TIP_SUCCESS = 0, TIP_EMAIL_ERR = 1, TIP_PWD_ERR = 2, TIP_CONFIRM_ERR = 3, TIP_PWD_CONFIRM = 4, TIP_VARIFY_ERR = 5, TIP_USER_ERR = 6&#125;; RegisterDialog声明中添加 1QMap&lt;TipErr, QString&gt; _tip_errs; _tip_errs用来缓存各个输入框输入完成后提示的错误，如果该输入框错误清除后就显示剩余的错误，每次只显示一条 实现添加错误和删除错误 12345678910111213141516void ResetDialog::AddTipErr(TipErr te, QString tips)&#123; _tip_errs[te] = tips; showTip(tips, false);&#125;void ResetDialog::DelTipErr(TipErr te)&#123; _tip_errs.remove(te); if(_tip_errs.empty())&#123; ui-&gt;err_tip-&gt;clear(); return; &#125; showTip(_tip_errs.first(), false);&#125; 实现错误检测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768bool ResetDialog::checkUserValid()&#123; if(ui-&gt;user_edit-&gt;text() == &quot;&quot;)&#123; AddTipErr(TipErr::TIP_USER_ERR, tr(&quot;用户名不能为空&quot;)); return false; &#125; DelTipErr(TipErr::TIP_USER_ERR); return true;&#125;bool ResetDialog::checkPassValid()&#123; auto pass = ui-&gt;pwd_edit-&gt;text(); if(pass.length() &lt; 6 || pass.length()&gt;15)&#123; //提示长度不准确 AddTipErr(TipErr::TIP_PWD_ERR, tr(&quot;密码长度应为6~15&quot;)); return false; &#125; // 创建一个正则表达式对象，按照上述密码要求 // 这个正则表达式解释： // ^[a-zA-Z0-9!@#$%^&amp;*]&#123;6,15&#125;$ 密码长度至少6，可以是字母、数字和特定的特殊字符 QRegularExpression regExp(&quot;^[a-zA-Z0-9!@#$%^&amp;*]&#123;6,15&#125;$&quot;); bool match = regExp.match(pass).hasMatch(); if(!match)&#123; //提示字符非法 AddTipErr(TipErr::TIP_PWD_ERR, tr(&quot;不能包含非法字符&quot;)); return false;; &#125; DelTipErr(TipErr::TIP_PWD_ERR); return true;&#125;bool ResetDialog::checkEmailValid()&#123; //验证邮箱的地址正则表达式 auto email = ui-&gt;email_edit-&gt;text(); // 邮箱地址的正则表达式 QRegularExpression regex(R&quot;((\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+)&quot;); bool match = regex.match(email).hasMatch(); // 执行正则表达式匹配 if(!match)&#123; //提示邮箱不正确 AddTipErr(TipErr::TIP_EMAIL_ERR, tr(&quot;邮箱地址不正确&quot;)); return false; &#125; DelTipErr(TipErr::TIP_EMAIL_ERR); return true;&#125;bool ResetDialog::checkVarifyValid()&#123; auto pass = ui-&gt;varify_edit-&gt;text(); if(pass.isEmpty())&#123; AddTipErr(TipErr::TIP_VARIFY_ERR, tr(&quot;验证码不能为空&quot;)); return false; &#125; DelTipErr(TipErr::TIP_VARIFY_ERR); return true;&#125; 除此之外修改之前点击确认按钮的逻辑，改为检测所有条件成立后再发送请求 12345678910111213141516171819202122232425262728293031void ResetDialog::on_sure_btn_clicked()&#123; bool valid = checkUserValid(); if(!valid)&#123; return; &#125; valid = checkEmailValid(); if(!valid)&#123; return; &#125; valid = checkPassValid(); if(!valid)&#123; return; &#125; valid = checkVarifyValid(); if(!valid)&#123; return; &#125; //发送http重置用户请求 QJsonObject json_obj; json_obj[&quot;user&quot;] = ui-&gt;user_edit-&gt;text(); json_obj[&quot;email&quot;] = ui-&gt;email_edit-&gt;text(); json_obj[&quot;passwd&quot;] = xorString(ui-&gt;pwd_edit-&gt;text()); json_obj[&quot;varifycode&quot;] = ui-&gt;varify_edit-&gt;text(); HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(gate_url_prefix+&quot;/reset_pwd&quot;), json_obj, ReqId::ID_RESET_PWD,Modules::RESETMOD);&#125; 隐藏和显示密码我们在输入密码时希望能通过点击可见还是不可见，显示密码和隐藏密码，这里先添加图片放入资源中，然后在Register.ui中添加两个label，分别命名为pass_visible和confirm_visible, 用来占据位置。 因为我们要做的点击后图片要有状态切换，以及浮动显示不一样的效果等，所以我们重写ClickedLabel,继承自QLabel. 1234567891011121314151617181920212223242526272829303132333435#ifndef CLICKEDLABEL_H#define CLICKEDLABEL_H#include &lt;QLabel&gt;#include &quot;global.h&quot;class ClickedLabel:public QLabel&#123; Q_OBJECTpublic: ClickedLabel(QWidget* parent); virtual void mousePressEvent(QMouseEvent *ev) override; virtual void enterEvent(QEvent* event) override; virtual void leaveEvent(QEvent* event) override; void SetState(QString normal=&quot;&quot;, QString hover=&quot;&quot;, QString press=&quot;&quot;, QString select=&quot;&quot;, QString select_hover=&quot;&quot;, QString select_press=&quot;&quot;); ClickLbState GetCurState();protected:private: QString _normal; QString _normal_hover; QString _normal_press; QString _selected; QString _selected_hover; QString _selected_press; ClickLbState _curstate;signals: void clicked(void);&#125;;#endif // CLICKEDLABEL_H 一个Label有六种状态，普通状态，普通的悬浮状态，普通的点击状态，选中状态，选中的悬浮状态，选中的点击状态。 当Label处于普通状态，被点击后，切换为选中状态，再次点击又切换为普通状态。 ClickLbState定义在global.h中，包含两种状态一个是普通状态，一个是选中状态。而Label中的六种状态就是基于这两种状态嵌套实现的。 1234enum ClickLbState&#123; Normal = 0, Selected = 1&#125;; 六种状态用qss写好，这样我们只需要根据鼠标事件切换不同的qss就可以实现样式变换。 1234567891011121314151617181920212223242526272829303132#pass_visible[state=&#x27;unvisible&#x27;]&#123; border-image: url(:/res/unvisible.png);&#125;#pass_visible[state=&#x27;unvisible_hover&#x27;]&#123; border-image: url(:/res/unvisible_hover.png);&#125;#pass_visible[state=&#x27;visible&#x27;]&#123; border-image: url(:/res/visible.png);&#125;#pass_visible[state=&#x27;visible_hover&#x27;]&#123; border-image: url(:/res/visible_hover.png);&#125;#confirm_visible[state=&#x27;unvisible&#x27;]&#123; border-image: url(:/res/unvisible.png);&#125;#confirm_visible[state=&#x27;unvisible_hover&#x27;]&#123; border-image: url(:/res/unvisible_hover.png);&#125;#confirm_visible[state=&#x27;visible&#x27;]&#123; border-image: url(:/res/visible.png);&#125;#confirm_visible[state=&#x27;visible_hover&#x27;]&#123; border-image: url(:/res/visible_hover.png);&#125; 我们实现ClickedLabel功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &quot;clickedlabel.h&quot;#include &lt;QMouseEvent&gt;ClickedLabel::ClickedLabel(QWidget* parent):QLabel (parent),_curstate(ClickLbState::Normal)&#123;&#125;// 处理鼠标点击事件void ClickedLabel::mousePressEvent(QMouseEvent* event) &#123; if (event-&gt;button() == Qt::LeftButton) &#123; if(_curstate == ClickLbState::Normal)&#123; qDebug()&lt;&lt;&quot;clicked , change to selected hover: &quot;&lt;&lt; _selected_hover; _curstate = ClickLbState::Selected; setProperty(&quot;state&quot;,_selected_hover); repolish(this); update(); &#125;else&#123; qDebug()&lt;&lt;&quot;clicked , change to normal hover: &quot;&lt;&lt; _normal_hover; _curstate = ClickLbState::Normal; setProperty(&quot;state&quot;,_normal_hover); repolish(this); update(); &#125; emit clicked(); &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QLabel::mousePressEvent(event);&#125;// 处理鼠标悬停进入事件void ClickedLabel::enterEvent(QEvent* event) &#123; // 在这里处理鼠标悬停进入的逻辑 if(_curstate == ClickLbState::Normal)&#123; qDebug()&lt;&lt;&quot;enter , change to normal hover: &quot;&lt;&lt; _normal_hover; setProperty(&quot;state&quot;,_normal_hover); repolish(this); update(); &#125;else&#123; qDebug()&lt;&lt;&quot;enter , change to selected hover: &quot;&lt;&lt; _selected_hover; setProperty(&quot;state&quot;,_selected_hover); repolish(this); update(); &#125; QLabel::enterEvent(event);&#125;// 处理鼠标悬停离开事件void ClickedLabel::leaveEvent(QEvent* event)&#123; // 在这里处理鼠标悬停离开的逻辑 if(_curstate == ClickLbState::Normal)&#123; qDebug()&lt;&lt;&quot;leave , change to normal : &quot;&lt;&lt; _normal; setProperty(&quot;state&quot;,_normal); repolish(this); update(); &#125;else&#123; qDebug()&lt;&lt;&quot;leave , change to normal hover: &quot;&lt;&lt; _selected; setProperty(&quot;state&quot;,_selected); repolish(this); update(); &#125; QLabel::leaveEvent(event);&#125;void ClickedLabel::SetState(QString normal, QString hover, QString press, QString select, QString select_hover, QString select_press)&#123; _normal = normal; _normal_hover = hover; _normal_press = press; _selected = select; _selected_hover = select_hover; _selected_press = select_press; setProperty(&quot;state&quot;,normal); repolish(this);&#125;ClickLbState ClickedLabel::GetCurState()&#123; return _curstate;&#125; 将label升级为ClickedLabel，然后在RegisterDialog的构造函数中添加label点击的响应函数 12345678910111213141516171819202122232425262728293031//设置浮动显示手形状ui-&gt;pass_visible-&gt;setCursor(Qt::PointingHandCursor);ui-&gt;confirm_visible-&gt;setCursor(Qt::PointingHandCursor);ui-&gt;pass_visible-&gt;SetState(&quot;unvisible&quot;,&quot;unvisible_hover&quot;,&quot;&quot;,&quot;visible&quot;, &quot;visible_hover&quot;,&quot;&quot;);ui-&gt;confirm_visible-&gt;SetState(&quot;unvisible&quot;,&quot;unvisible_hover&quot;,&quot;&quot;,&quot;visible&quot;, &quot;visible_hover&quot;,&quot;&quot;);//连接点击事件connect(ui-&gt;pass_visible, &amp;ClickedLabel::clicked, this, [this]() &#123; auto state = ui-&gt;pass_visible-&gt;GetCurState(); if(state == ClickLbState::Normal)&#123; ui-&gt;pass_edit-&gt;setEchoMode(QLineEdit::Password); &#125;else&#123; ui-&gt;pass_edit-&gt;setEchoMode(QLineEdit::Normal); &#125; qDebug() &lt;&lt; &quot;Label was clicked!&quot;;&#125;);connect(ui-&gt;confirm_visible, &amp;ClickedLabel::clicked, this, [this]() &#123; auto state = ui-&gt;confirm_visible-&gt;GetCurState(); if(state == ClickLbState::Normal)&#123; ui-&gt;confirm_edit-&gt;setEchoMode(QLineEdit::Password); &#125;else&#123; ui-&gt;confirm_edit-&gt;setEchoMode(QLineEdit::Normal); &#125; qDebug() &lt;&lt; &quot;Label was clicked!&quot;;&#125;); 这样就实现了通过点击切换密码的显示和隐藏。 注册成功提示页面注册成功后要切换到提示页面，所以在initHandlers函数内实现收到服务器注册回复的请求 12345678910111213//注册注册用户回包逻辑_handlers.insert(ReqId::ID_REG_USER, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); return; &#125; auto email = jsonObj[&quot;email&quot;].toString(); showTip(tr(&quot;用户注册成功&quot;), true); qDebug()&lt;&lt; &quot;email is &quot; &lt;&lt; email ; qDebug()&lt;&lt; &quot;user uuid is &quot; &lt;&lt; jsonObj[&quot;uuid&quot;].toString(); ChangeTipPage();&#125;); 页面切换逻辑 12345678void RegisterDialog::ChangeTipPage()&#123; _countdown_timer-&gt;stop(); ui-&gt;stackedWidget-&gt;setCurrentWidget(ui-&gt;page_2); // 启动定时器，设置间隔为1000毫秒（1秒） _countdown_timer-&gt;start(1000);&#125; 在RegisterDialog.ui中stackwidget的page2添加标签和返回按钮 在RegisterDialog构造函数中添加定时器回调 12345678910111213// 创建定时器_countdown_timer = new QTimer(this);// 连接信号和槽connect(_countdown_timer, &amp;QTimer::timeout, [this]()&#123; if(_countdown==0)&#123; _countdown_timer-&gt;stop(); emit sigSwitchLogin(); return; &#125; _countdown--; auto str = QString(&quot;注册成功，%1 s后返回登录&quot;).arg(_countdown); ui-&gt;tip_lb-&gt;setText(str);&#125;); 除此之外在返回按钮的槽函数中停止定时器并发送切换登录的信号 12345void RegisterDialog::on_return_btn_clicked()&#123; _countdown_timer-&gt;stop(); emit sigSwitchLogin();&#125; 取消注册也发送切换登录信号 12345void RegisterDialog::on_cancel_btn_clicked()&#123; _countdown_timer-&gt;stop(); emit sigSwitchLogin();&#125; 界面跳转回到mainwindow，构造函数简化，只做登录界面初始化 123456789101112131415MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); //创建一个CentralWidget, 并将其设置为MainWindow的中心部件 _login_dlg = new LoginDialog(this); _login_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint); setCentralWidget(_login_dlg); //连接登录界面注册信号 connect(_login_dlg, &amp;LoginDialog::switchRegister, this, &amp;MainWindow::SlotSwitchReg); //连接登录界面忘记密码信号 connect(_login_dlg, &amp;LoginDialog::switchReset, this, &amp;MainWindow::SlotSwitchReset);&#125; 在点击注册按钮的槽函数中 12345678910111213void MainWindow::SlotSwitchReg()&#123; _reg_dlg = new RegisterDialog(this); _reg_dlg-&gt;hide(); _reg_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint); //连接注册界面返回登录信号 connect(_reg_dlg, &amp;RegisterDialog::sigSwitchLogin, this, &amp;MainWindow::SlotSwitchLogin); setCentralWidget(_reg_dlg); _login_dlg-&gt;hide(); _reg_dlg-&gt;show();&#125; 切换登录界面 123456789101112131415//从注册界面返回登录界面void MainWindow::SlotSwitchLogin()&#123; //创建一个CentralWidget, 并将其设置为MainWindow的中心部件 _login_dlg = new LoginDialog(this); _login_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint); setCentralWidget(_login_dlg); _reg_dlg-&gt;hide(); _login_dlg-&gt;show(); //连接登录界面注册信号 connect(_login_dlg, &amp;LoginDialog::switchRegister, this, &amp;MainWindow::SlotSwitchReg); //连接登录界面忘记密码信号 connect(_login_dlg, &amp;LoginDialog::switchReset, this, &amp;MainWindow::SlotSwitchReset);&#125; 这样登录界面和注册界面的切换逻辑就写完了。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(13) 实现验证码服务和用户注册功能","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro13/","text":"重置密码label当我们在登录忘记密码的时候可以支持重置密码，重置密码label也要实现浮动和点击效果，以及未点击效果。所以我们复用之前的ClickedLabel,在登录界面中升级forget_label为ClickedLabel。 12345678910LoginDialog::LoginDialog(QWidget *parent) : QDialog(parent), ui(new Ui::LoginDialog)&#123; ui-&gt;setupUi(this); connect(ui-&gt;reg_btn, &amp;QPushButton::clicked, this, &amp;LoginDialog::switchRegister); ui-&gt;forget_label-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;&quot;,&quot;selected&quot;,&quot;selected_hover&quot;,&quot;&quot;); ui-&gt;forget_label-&gt;setCursor(Qt::PointingHandCursor); connect(ui-&gt;forget_label, &amp;ClickedLabel::clicked, this, &amp;LoginDialog::slot_forget_pwd);&#125; 点击忘记密码发送对应的信号 12345void LoginDialog::slot_forget_pwd()&#123; qDebug()&lt;&lt;&quot;slot forget pwd&quot;; emit switchReset();&#125; 我们在mainwindow中连接了重置密码的信号和槽 12//连接登录界面忘记密码信号connect(_login_dlg, &amp;LoginDialog::switchReset, this, &amp;MainWindow::SlotSwitchReset); 实现SlotSwitchReset 123456789101112void MainWindow::SlotSwitchReset()&#123; //创建一个CentralWidget, 并将其设置为MainWindow的中心部件 _reset_dlg = new ResetDialog(this); _reset_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint); setCentralWidget(_reset_dlg); _login_dlg-&gt;hide(); _reset_dlg-&gt;show(); //注册返回登录信号和槽函数 connect(_reset_dlg, &amp;ResetDialog::switchLogin, this, &amp;MainWindow::SlotSwitchLogin2);&#125; ResetDialog是我们添加的界面类，新建ResetDialog界面类，界面布局如下 重置界面123456789101112131415161718192021222324252627282930313233343536#include &quot;resetdialog.h&quot;#include &quot;ui_resetdialog.h&quot;#include &lt;QDebug&gt;#include &lt;QRegularExpression&gt;#include &quot;global.h&quot;#include &quot;httpmgr.h&quot;ResetDialog::ResetDialog(QWidget *parent) : QDialog(parent), ui(new Ui::ResetDialog)&#123; ui-&gt;setupUi(this); connect(ui-&gt;user_edit,&amp;QLineEdit::editingFinished,this,[this]()&#123; checkUserValid(); &#125;); connect(ui-&gt;email_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkEmailValid(); &#125;); connect(ui-&gt;pwd_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkPassValid(); &#125;); connect(ui-&gt;varify_edit, &amp;QLineEdit::editingFinished, this, [this]()&#123; checkVarifyValid(); &#125;); //连接reset相关信号和注册处理回调 initHandlers(); connect(HttpMgr::GetInstance().get(), &amp;HttpMgr::sig_reset_mod_finish, this, &amp;ResetDialog::slot_reset_mod_finish);&#125; 下面是检测逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283bool ResetDialog::checkUserValid()&#123; if(ui-&gt;user_edit-&gt;text() == &quot;&quot;)&#123; AddTipErr(TipErr::TIP_USER_ERR, tr(&quot;用户名不能为空&quot;)); return false; &#125; DelTipErr(TipErr::TIP_USER_ERR); return true;&#125;bool ResetDialog::checkPassValid()&#123; auto pass = ui-&gt;pwd_edit-&gt;text(); if(pass.length() &lt; 6 || pass.length()&gt;15)&#123; //提示长度不准确 AddTipErr(TipErr::TIP_PWD_ERR, tr(&quot;密码长度应为6~15&quot;)); return false; &#125; // 创建一个正则表达式对象，按照上述密码要求 // 这个正则表达式解释： // ^[a-zA-Z0-9!@#$%^&amp;*]&#123;6,15&#125;$ 密码长度至少6，可以是字母、数字和特定的特殊字符 QRegularExpression regExp(&quot;^[a-zA-Z0-9!@#$%^&amp;*]&#123;6,15&#125;$&quot;); bool match = regExp.match(pass).hasMatch(); if(!match)&#123; //提示字符非法 AddTipErr(TipErr::TIP_PWD_ERR, tr(&quot;不能包含非法字符&quot;)); return false;; &#125; DelTipErr(TipErr::TIP_PWD_ERR); return true;&#125;bool ResetDialog::checkEmailValid()&#123; //验证邮箱的地址正则表达式 auto email = ui-&gt;email_edit-&gt;text(); // 邮箱地址的正则表达式 QRegularExpression regex(R&quot;((\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+)&quot;); bool match = regex.match(email).hasMatch(); // 执行正则表达式匹配 if(!match)&#123; //提示邮箱不正确 AddTipErr(TipErr::TIP_EMAIL_ERR, tr(&quot;邮箱地址不正确&quot;)); return false; &#125; DelTipErr(TipErr::TIP_EMAIL_ERR); return true;&#125;bool ResetDialog::checkVarifyValid()&#123; auto pass = ui-&gt;varify_edit-&gt;text(); if(pass.isEmpty())&#123; AddTipErr(TipErr::TIP_VARIFY_ERR, tr(&quot;验证码不能为空&quot;)); return false; &#125; DelTipErr(TipErr::TIP_VARIFY_ERR); return true;&#125;void ResetDialog::AddTipErr(TipErr te, QString tips)&#123; _tip_errs[te] = tips; showTip(tips, false);&#125;void ResetDialog::DelTipErr(TipErr te)&#123; _tip_errs.remove(te); if(_tip_errs.empty())&#123; ui-&gt;err_tip-&gt;clear(); return; &#125; showTip(_tip_errs.first(), false);&#125; 显示接口 123456789101112void ResetDialog::showTip(QString str, bool b_ok)&#123; if(b_ok)&#123; ui-&gt;err_tip-&gt;setProperty(&quot;state&quot;,&quot;normal&quot;); &#125;else&#123; ui-&gt;err_tip-&gt;setProperty(&quot;state&quot;,&quot;err&quot;); &#125; ui-&gt;err_tip-&gt;setText(str); repolish(ui-&gt;err_tip);&#125; 获取验证码 123456789101112131415void ResetDialog::on_varify_btn_clicked()&#123; qDebug()&lt;&lt;&quot;receive varify btn clicked &quot;; auto email = ui-&gt;email_edit-&gt;text(); auto bcheck = checkEmailValid(); if(!bcheck)&#123; return; &#125; //发送http请求获取验证码 QJsonObject json_obj; json_obj[&quot;email&quot;] = email; HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(gate_url_prefix+&quot;/get_varifycode&quot;), json_obj, ReqId::ID_GET_VARIFY_CODE,Modules::RESETMOD);&#125; 初始化回包处理逻辑 123456789101112131415161718192021222324252627void ResetDialog::initHandlers()&#123; //注册获取验证码回包逻辑 _handlers.insert(ReqId::ID_GET_VARIFY_CODE, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); return; &#125; auto email = jsonObj[&quot;email&quot;].toString(); showTip(tr(&quot;验证码已发送到邮箱，注意查收&quot;), true); qDebug()&lt;&lt; &quot;email is &quot; &lt;&lt; email ; &#125;); //注册注册用户回包逻辑 _handlers.insert(ReqId::ID_RESET_PWD, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); return; &#125; auto email = jsonObj[&quot;email&quot;].toString(); showTip(tr(&quot;重置成功,点击返回登录&quot;), true); qDebug()&lt;&lt; &quot;email is &quot; &lt;&lt; email ; qDebug()&lt;&lt; &quot;user uuid is &quot; &lt;&lt; jsonObj[&quot;uuid&quot;].toString(); &#125;);&#125; 根据返回的id调用不同的回报处理逻辑 123456789101112131415161718192021222324252627void ResetDialog::slot_reset_mod_finish(ReqId id, QString res, ErrorCodes err)&#123; if(err != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;网络请求错误&quot;),false); return; &#125; // 解析 JSON 字符串,res需转化为QByteArray QJsonDocument jsonDoc = QJsonDocument::fromJson(res.toUtf8()); //json解析错误 if(jsonDoc.isNull())&#123; showTip(tr(&quot;json解析错误&quot;),false); return; &#125; //json解析错误 if(!jsonDoc.isObject())&#123; showTip(tr(&quot;json解析错误&quot;),false); return; &#125; //调用对应的逻辑,根据id回调。 _handlers[id](jsonDoc.object()); return;&#125; 这里实现发送逻辑 12345678910111213141516171819202122232425262728293031void ResetDialog::on_sure_btn_clicked()&#123; bool valid = checkUserValid(); if(!valid)&#123; return; &#125; valid = checkEmailValid(); if(!valid)&#123; return; &#125; valid = checkPassValid(); if(!valid)&#123; return; &#125; valid = checkVarifyValid(); if(!valid)&#123; return; &#125; //发送http重置用户请求 QJsonObject json_obj; json_obj[&quot;user&quot;] = ui-&gt;user_edit-&gt;text(); json_obj[&quot;email&quot;] = ui-&gt;email_edit-&gt;text(); json_obj[&quot;passwd&quot;] = xorString(ui-&gt;pwd_edit-&gt;text()); json_obj[&quot;varifycode&quot;] = ui-&gt;varify_edit-&gt;text(); HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(gate_url_prefix+&quot;/reset_pwd&quot;), json_obj, ReqId::ID_RESET_PWD,Modules::RESETMOD);&#125; 注册、重置、登录切换我们要实现注册、重置、登录三个界面的替换，就需要在MainWindow中添加SlotSwitchLogin2的实现 123456789101112131415//从重置界面返回登录界面void MainWindow::SlotSwitchLogin2()&#123; //创建一个CentralWidget, 并将其设置为MainWindow的中心部件 _login_dlg = new LoginDialog(this); _login_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint); setCentralWidget(_login_dlg); _reset_dlg-&gt;hide(); _login_dlg-&gt;show(); //连接登录界面忘记密码信号 connect(_login_dlg, &amp;LoginDialog::switchReset, this, &amp;MainWindow::SlotSwitchReset); //连接登录界面注册信号 connect(_login_dlg, &amp;LoginDialog::switchRegister, this, &amp;MainWindow::SlotSwitchReg);&#125; 服务端响应重置在LogicSystem的构造函数中增加注册逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//重置回调逻辑RegPost(&quot;/reset_pwd&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; auto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; connection-&gt;_response.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::Error_Json; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; auto email = src_root[&quot;email&quot;].asString(); auto name = src_root[&quot;user&quot;].asString(); auto pwd = src_root[&quot;passwd&quot;].asString(); //先查找redis中email对应的验证码是否合理 std::string varify_code; bool b_get_varify = RedisMgr::GetInstance()-&gt;Get(CODEPREFIX + src_root[&quot;email&quot;].asString(), varify_code); if (!b_get_varify) &#123; std::cout &lt;&lt; &quot; get varify code expired&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::VarifyExpired; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; if (varify_code != src_root[&quot;varifycode&quot;].asString()) &#123; std::cout &lt;&lt; &quot; varify code error&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::VarifyCodeErr; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //查询数据库判断用户名和邮箱是否匹配 bool email_valid = MysqlMgr::GetInstance()-&gt;CheckEmail(name, email); if (!email_valid) &#123; std::cout &lt;&lt; &quot; user email not match&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::EmailNotMatch; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //更新密码为最新密码 bool b_up = MysqlMgr::GetInstance()-&gt;UpdatePwd(name, pwd); if (!b_up) &#123; std::cout &lt;&lt; &quot; update pwd failed&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::PasswdUpFailed; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; std::cout &lt;&lt; &quot;succeed to update password&quot; &lt;&lt; pwd &lt;&lt; std::endl; root[&quot;error&quot;] = 0; root[&quot;email&quot;] = email; root[&quot;user&quot;] = name; root[&quot;passwd&quot;] = pwd; root[&quot;varifycode&quot;] = src_root[&quot;varifycode&quot;].asString(); std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125;); 在Mysql中新增CheckEmail和UpdatePwd函数 1234567bool MysqlMgr::CheckEmail(const std::string&amp; name, const std::string&amp; email) &#123; return _dao.CheckEmail(name, email);&#125;bool MysqlMgr::UpdatePwd(const std::string&amp; name, const std::string&amp; pwd) &#123; return _dao.UpdatePwd(name, pwd);&#125; DAO这一层写具体的逻辑, 检测邮箱是否合理 123456789101112131415161718192021222324252627282930313233343536bool MysqlDao::CheckEmail(const std::string&amp; name, const std::string&amp; email) &#123; auto con = pool_-&gt;getConnection(); try &#123; if (con == nullptr) &#123; pool_-&gt;returnConnection(std::move(con)); return false; &#125; // 准备查询语句 std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(con-&gt;prepareStatement(&quot;SELECT email FROM user WHERE name = ?&quot;)); // 绑定参数 pstmt-&gt;setString(1, name); // 执行查询 std::unique_ptr&lt;sql::ResultSet&gt; res(pstmt-&gt;executeQuery()); // 遍历结果集 while (res-&gt;next()) &#123; std::cout &lt;&lt; &quot;Check Email: &quot; &lt;&lt; res-&gt;getString(&quot;email&quot;) &lt;&lt; std::endl; if (email != res-&gt;getString(&quot;email&quot;)) &#123; pool_-&gt;returnConnection(std::move(con)); return false; &#125; pool_-&gt;returnConnection(std::move(con)); return true; &#125; &#125; catch (sql::SQLException&amp; e) &#123; pool_-&gt;returnConnection(std::move(con)); std::cerr &lt;&lt; &quot;SQLException: &quot; &lt;&lt; e.what(); std::cerr &lt;&lt; &quot; (MySQL error code: &quot; &lt;&lt; e.getErrorCode(); std::cerr &lt;&lt; &quot;, SQLState: &quot; &lt;&lt; e.getSQLState() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl; return false; &#125;&#125; 更新密码 123456789101112131415161718192021222324252627282930bool MysqlDao::UpdatePwd(const std::string&amp; name, const std::string&amp; newpwd) &#123; auto con = pool_-&gt;getConnection(); try &#123; if (con == nullptr) &#123; pool_-&gt;returnConnection(std::move(con)); return false; &#125; // 准备查询语句 std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(con-&gt;prepareStatement(&quot;UPDATE user SET pwd = ? WHERE name = ?&quot;)); // 绑定参数 pstmt-&gt;setString(2, name); pstmt-&gt;setString(1, newpwd); // 执行更新 int updateCount = pstmt-&gt;executeUpdate(); std::cout &lt;&lt; &quot;Updated rows: &quot; &lt;&lt; updateCount &lt;&lt; std::endl; pool_-&gt;returnConnection(std::move(con)); return true; &#125; catch (sql::SQLException&amp; e) &#123; pool_-&gt;returnConnection(std::move(con)); std::cerr &lt;&lt; &quot;SQLException: &quot; &lt;&lt; e.what(); std::cerr &lt;&lt; &quot; (MySQL error code: &quot; &lt;&lt; e.getErrorCode(); std::cerr &lt;&lt; &quot;, SQLState: &quot; &lt;&lt; e.getSQLState() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl; return false; &#125;&#125;","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(15) 实现自定义可点击Label以及定时按钮","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro15/","text":"客户端TCP管理者因为聊天服务要维持一个长链接，方便服务器和客户端双向通信，那么就需要一个TCPMgr来管理TCP连接。 而实际开发中网络模块一般以单例模式使用，那我们就基于单例基类和可被分享类创建一个自定义的TcpMgr类，在QT工程中新建TcpMgr类，会生成头文件和源文件，头文件修改如下 12345678910111213141516171819202122232425262728#ifndef TCPMGR_H#define TCPMGR_H#include &lt;QTcpSocket&gt;#include &quot;singleton.h&quot;#include &quot;global.h&quot;class TcpMgr:public QObject, public Singleton&lt;TcpMgr&gt;, public std::enable_shared_from_this&lt;TcpMgr&gt;&#123; Q_OBJECTpublic: TcpMgr();private: QTcpSocket _socket; QString _host; uint16_t _port; QByteArray _buffer; bool _b_recv_pending; quint16 _message_id; quint16 _message_len;public slots: void slot_tcp_connect(ServerInfo); void slot_send_data(ReqId reqId, QString data);signals: void sig_con_success(bool bsuccess); void sig_send_data(ReqId reqId, QString data);&#125;;#endif // TCPMGR_H 接下来我们在构造函数中连接网络请求的各种信号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293TcpMgr::TcpMgr():_host(&quot;&quot;),_port(0),_b_recv_pending(false),_message_id(0),_message_len(0)&#123; QObject::connect(&amp;_socket, &amp;QTcpSocket::connected, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Connected to server!&quot;; // 连接建立后发送消息 emit sig_con_success(true); &#125;); QObject::connect(&amp;_socket, &amp;QTcpSocket::readyRead, [&amp;]() &#123; // 当有数据可读时，读取所有数据 // 读取所有数据并追加到缓冲区 _buffer.append(_socket.readAll()); QDataStream stream(&amp;_buffer, QIODevice::ReadOnly); stream.setVersion(QDataStream::Qt_5_0); forever &#123; //先解析头部 if(!_b_recv_pending)&#123; // 检查缓冲区中的数据是否足够解析出一个消息头（消息ID + 消息长度） if (_buffer.size() &lt; static_cast&lt;int&gt;(sizeof(quint16) * 2)) &#123; return; // 数据不够，等待更多数据 &#125; // 预读取消息ID和消息长度，但不从缓冲区中移除 stream &gt;&gt; _message_id &gt;&gt; _message_len; //将buffer 中的前四个字节移除 _buffer = _buffer.mid(sizeof(quint16) * 2); // 输出读取的数据 qDebug() &lt;&lt; &quot;Message ID:&quot; &lt;&lt; _message_id &lt;&lt; &quot;, Length:&quot; &lt;&lt; _message_len; &#125; //buffer剩余长读是否满足消息体长度，不满足则退出继续等待接受 if(_buffer.size() &lt; _message_len)&#123; _b_recv_pending = true; return; &#125; _b_recv_pending = false; // 读取消息体 QByteArray messageBody = _buffer.mid(0, _message_len); qDebug() &lt;&lt; &quot;receive body msg is &quot; &lt;&lt; messageBody ; _buffer = _buffer.mid(_message_len); &#125; &#125;); //5.15 之后版本// QObject::connect(&amp;_socket, QOverload&lt;QAbstractSocket::SocketError&gt;::of(&amp;QTcpSocket::errorOccurred), [&amp;](QAbstractSocket::SocketError socketError) &#123;// Q_UNUSED(socketError)// qDebug() &lt;&lt; &quot;Error:&quot; &lt;&lt; _socket.errorString();// &#125;); // 处理错误（适用于Qt 5.15之前的版本） QObject::connect(&amp;_socket, static_cast&lt;void (QTcpSocket::*)(QTcpSocket::SocketError)&gt;(&amp;QTcpSocket::error), [&amp;](QTcpSocket::SocketError socketError) &#123; qDebug() &lt;&lt; &quot;Error:&quot; &lt;&lt; _socket.errorString() ; switch (socketError) &#123; case QTcpSocket::ConnectionRefusedError: qDebug() &lt;&lt; &quot;Connection Refused!&quot;; emit sig_con_success(false); break; case QTcpSocket::RemoteHostClosedError: qDebug() &lt;&lt; &quot;Remote Host Closed Connection!&quot;; break; case QTcpSocket::HostNotFoundError: qDebug() &lt;&lt; &quot;Host Not Found!&quot;; emit sig_con_success(false); break; case QTcpSocket::SocketTimeoutError: qDebug() &lt;&lt; &quot;Connection Timeout!&quot;; emit sig_con_success(false); break; case QTcpSocket::NetworkError: qDebug() &lt;&lt; &quot;Network Error!&quot;; break; default: qDebug() &lt;&lt; &quot;Other Error!&quot;; break; &#125; &#125;); // 处理连接断开 QObject::connect(&amp;_socket, &amp;QTcpSocket::disconnected, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Disconnected from server.&quot;; &#125;); QObject::connect(this, &amp;TcpMgr::sig_send_data, this, &amp;TcpMgr::slot_send_data);&#125; 连接对端服务器 123456789void TcpMgr::slot_tcp_connect(ServerInfo si)&#123; qDebug()&lt;&lt; &quot;receive tcp connect signal&quot;; // 尝试连接到服务器 qDebug() &lt;&lt; &quot;Connecting to server...&quot;; _host = si.Host; _port = static_cast&lt;uint16_t&gt;(si.Port.toUInt()); _socket.connectToHost(si.Host, _port);&#125; 因为客户端发送数据可能在任何线程，为了保证线程安全，我们在要发送数据时发送TcpMgr的sig_send_data信号，然后实现接受这个信号的槽函数 1234567891011121314151617181920212223242526void TcpMgr::slot_send_data(ReqId reqId, QString data)&#123; uint16_t id = reqId; // 将字符串转换为UTF-8编码的字节数组 QByteArray dataBytes = data.toUtf8(); // 计算长度（使用网络字节序转换） quint16 len = static_cast&lt;quint16&gt;(data.size()); // 创建一个QByteArray用于存储要发送的所有数据 QByteArray block; QDataStream out(&amp;block, QIODevice::WriteOnly); // 设置数据流使用网络字节序 out.setByteOrder(QDataStream::BigEndian); // 写入ID和长度 out &lt;&lt; id &lt;&lt; len; // 添加字符串数据 block.append(data); // 发送数据 _socket.write(block);&#125; 然后修改LoginDialog中的initHandlers中的收到服务器登陆回复后的逻辑，这里发送信号准备发起长链接到聊天服务器 1234567891011121314151617181920212223242526void LoginDialog::initHttpHandlers()&#123; //注册获取登录回包逻辑 _handlers.insert(ReqId::ID_LOGIN_USER, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); enableBtn(true); return; &#125; auto user = jsonObj[&quot;user&quot;].toString(); //发送信号通知tcpMgr发送长链接 ServerInfo si; si.Uid = jsonObj[&quot;uid&quot;].toInt(); si.Host = jsonObj[&quot;host&quot;].toString(); si.Port = jsonObj[&quot;port&quot;].toString(); si.Token = jsonObj[&quot;token&quot;].toString(); _uid = si.Uid; _token = si.Token; qDebug()&lt;&lt; &quot;user is &quot; &lt;&lt; user &lt;&lt; &quot; uid is &quot; &lt;&lt; si.Uid &lt;&lt;&quot; host is &quot; &lt;&lt; si.Host &lt;&lt; &quot; Port is &quot; &lt;&lt; si.Port &lt;&lt; &quot; Token is &quot; &lt;&lt; si.Token; emit sig_connect_tcp(si); &#125;);&#125; 在LoginDialog构造函数中连接信号，包括建立tcp连接，以及收到TcpMgr连接成功或者失败的信号处理 1234//连接tcp连接请求的信号和槽函数 connect(this, &amp;LoginDialog::sig_connect_tcp, TcpMgr::GetInstance().get(), &amp;TcpMgr::slot_tcp_connect);//连接tcp管理者发出的连接成功信号connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_con_success, this, &amp;LoginDialog::slot_tcp_con_finish); LoginDialog收到连接结果的槽函数 123456789101112131415161718192021void LoginDialog::slot_tcp_con_finish(bool bsuccess)&#123; if(bsuccess)&#123; showTip(tr(&quot;聊天服务连接成功，正在登录...&quot;),true); QJsonObject jsonObj; jsonObj[&quot;uid&quot;] = _uid; jsonObj[&quot;token&quot;] = _token; QJsonDocument doc(jsonObj); QString jsonString = doc.toJson(QJsonDocument::Indented); //发送tcp请求给chat server TcpMgr::GetInstance()-&gt;sig_send_data(ReqId::ID_CHAT_LOGIN, jsonString); &#125;else&#123; showTip(tr(&quot;网络异常&quot;),false); enableBtn(true); &#125;&#125; 在这个槽函数中我们发送了sig_send_data信号并且通知TcpMgr将数据发送给服务器。 这样TcpMgr发送完数据收到服务器的回复后就可以进一步根据解析出来的信息处理不同的情况了。我们先到此为止。具体如何处理后续再讲。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(16) 重置密码功能","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro16/","text":"ChatServer一个TCP服务器必然会有连接的接收，维持，收发数据等逻辑。那我们就要基于asio完成这个服务的搭建。主服务是这个样子的 1234567891011121314151617181920212223242526272829303132#include &quot;LogicSystem.h&quot;#include &lt;csignal&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &quot;AsioIOServicePool.h&quot;#include &quot;CServer.h&quot;#include &quot;ConfigMgr.h&quot;using namespace std;bool bstop = false;std::condition_variable cond_quit;std::mutex mutex_quit;int main()&#123; try &#123; auto &amp;cfg = ConfigMgr::Inst(); auto pool = AsioIOServicePool::GetInstance(); boost::asio::io_context io_context; boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); signals.async_wait([&amp;io_context, pool](auto, auto) &#123; io_context.stop(); pool-&gt;Stop(); &#125;); auto port_str = cfg[&quot;SelfServer&quot;][&quot;Port&quot;]; CServer s(io_context, atoi(port_str.c_str())); io_context.run(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125; CServer类的声明 12345678910111213141516171819202122#include &lt;boost/asio.hpp&gt;#include &quot;CSession.h&quot;#include &lt;memory.h&gt;#include &lt;map&gt;#include &lt;mutex&gt;using namespace std;using boost::asio::ip::tcp;class CServer&#123;public: CServer(boost::asio::io_context&amp; io_context, short port); ~CServer(); void ClearSession(std::string);private: void HandleAccept(shared_ptr&lt;CSession&gt;, const boost::system::error_code &amp; error); void StartAccept(); boost::asio::io_context &amp;_io_context; short _port; tcp::acceptor _acceptor; std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions; std::mutex _mutex;&#125;; 构造函数中监听对方连接 123456CServer::CServer(boost::asio::io_context&amp; io_context, short port):_io_context(io_context), _port(port),_acceptor(io_context, tcp::endpoint(tcp::v4(),port))&#123; cout &lt;&lt; &quot;Server start success, listen on port : &quot; &lt;&lt; _port &lt;&lt; endl; StartAccept();&#125; 接受连接的函数 12345void CServer::StartAccept() &#123; auto &amp;io_context = AsioIOServicePool::GetInstance()-&gt;GetIOService(); shared_ptr&lt;CSession&gt; new_session = make_shared&lt;CSession&gt;(io_context, this); _acceptor.async_accept(new_session-&gt;GetSocket(), std::bind(&amp;CServer::HandleAccept, this, new_session, placeholders::_1));&#125; AsioIOServicePool从AsioIOServicePool中返回一个可用的iocontext构造Session，然后将接受的新链接的socket写入这个Session保管。 AsioIOServicePool已经在前面讲解很多次了，它的声明如下 1234567891011121314151617181920212223#include &lt;vector&gt;#include &lt;boost/asio.hpp&gt;#include &quot;Singleton.h&quot;class AsioIOServicePool:public Singleton&lt;AsioIOServicePool&gt;&#123; friend Singleton&lt;AsioIOServicePool&gt;;public: using IOService = boost::asio::io_context; using Work = boost::asio::io_context::work; using WorkPtr = std::unique_ptr&lt;Work&gt;; ~AsioIOServicePool(); AsioIOServicePool(const AsioIOServicePool&amp;) = delete; AsioIOServicePool&amp; operator=(const AsioIOServicePool&amp;) = delete; // 使用 round-robin 的方式返回一个 io_service boost::asio::io_context&amp; GetIOService(); void Stop();private: AsioIOServicePool(std::size_t size = std::thread::hardware_concurrency()); std::vector&lt;IOService&gt; _ioServices; std::vector&lt;WorkPtr&gt; _works; std::vector&lt;std::thread&gt; _threads; std::size_t _nextIOService;&#125;; AsioIOServicePool具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;AsioIOServicePool.h&quot;#include &lt;iostream&gt;using namespace std;AsioIOServicePool::AsioIOServicePool(std::size_t size):_ioServices(size),_works(size), _nextIOService(0)&#123; for (std::size_t i = 0; i &lt; size; ++i) &#123; _works[i] = std::unique_ptr&lt;Work&gt;(new Work(_ioServices[i])); &#125; //遍历多个ioservice，创建多个线程，每个线程内部启动ioservice for (std::size_t i = 0; i &lt; _ioServices.size(); ++i) &#123; _threads.emplace_back([this, i]() &#123; _ioServices[i].run(); &#125;); &#125;&#125;AsioIOServicePool::~AsioIOServicePool() &#123; std::cout &lt;&lt; &quot;AsioIOServicePool destruct&quot; &lt;&lt; endl;&#125;boost::asio::io_context&amp; AsioIOServicePool::GetIOService() &#123; auto&amp; service = _ioServices[_nextIOService++]; if (_nextIOService == _ioServices.size()) &#123; _nextIOService = 0; &#125; return service;&#125;void AsioIOServicePool::Stop()&#123; //因为仅仅执行work.reset并不能让iocontext从run的状态中退出 //当iocontext已经绑定了读或写的监听事件后，还需要手动stop该服务。 for (auto&amp; work : _works) &#123; //把服务先停止 work-&gt;get_io_context().stop(); work.reset(); &#125; for (auto&amp; t : _threads) &#123; t.join(); &#125;&#125; CServer的处理连接逻辑 123456789101112void CServer::HandleAccept(shared_ptr&lt;CSession&gt; new_session, const boost::system::error_code&amp; error)&#123; if (!error) &#123; new_session-&gt;Start(); lock_guard&lt;mutex&gt; lock(_mutex); _sessions.insert(make_pair(new_session-&gt;GetUuid(), new_session)); &#125; else &#123; cout &lt;&lt; &quot;session accept failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; &#125; StartAccept();&#125; Session层上面的逻辑接受新链接后执行Start函数，新链接接受数据，然后Server继续监听新的连接 123void CSession::Start()&#123; AsyncReadHead(HEAD_TOTAL_LEN);&#125; 先读取头部数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void CSession::AsyncReadHead(int total_len)&#123; auto self = shared_from_this(); asyncReadFull(HEAD_TOTAL_LEN, [self, this](const boost::system::error_code&amp; ec, std::size_t bytes_transfered) &#123; try &#123; if (ec) &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; ec.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); return; &#125; if (bytes_transfered &lt; HEAD_TOTAL_LEN) &#123; std::cout &lt;&lt; &quot;read length not match, read [&quot; &lt;&lt; bytes_transfered &lt;&lt; &quot;] , total [&quot; &lt;&lt; HEAD_TOTAL_LEN &lt;&lt; &quot;]&quot; &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); return; &#125; _recv_head_node-&gt;Clear(); memcpy(_recv_head_node-&gt;_data, _data, bytes_transfered); //获取头部MSGID数据 short msg_id = 0; memcpy(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN); //网络字节序转化为本地字节序 msg_id = boost::asio::detail::socket_ops::network_to_host_short(msg_id); std::cout &lt;&lt; &quot;msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; //id非法 if (msg_id &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return; &#125; short msg_len = 0; memcpy(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN); //网络字节序转化为本地字节序 msg_len = boost::asio::detail::socket_ops::network_to_host_short(msg_len); std::cout &lt;&lt; &quot;msg_len is &quot; &lt;&lt; msg_len &lt;&lt; endl; //id非法 if (msg_len &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; msg_len &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return; &#125; _recv_msg_node = make_shared&lt;RecvNode&gt;(msg_len, msg_id); AsyncReadBody(msg_len); &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception code is &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; &#125;);&#125; 上面的逻辑里调用asyncReadFull读取整个长度，然后解析收到的数据，前两个字节为id，之后两个字节为长度，最后n个长度字节为消息内容。 123456//读取完整长度void CSession::asyncReadFull(std::size_t maxLength, std::function&lt;void(const boost::system::error_code&amp;, std::size_t)&gt; handler )&#123; ::memset(_data, 0, MAX_LENGTH); asyncReadLen(0, maxLength, handler);&#125; 读取指定长度 1234567891011121314151617181920212223//读取指定字节数void CSession::asyncReadLen(std::size_t read_len, std::size_t total_len, std::function&lt;void(const boost::system::error_code&amp;, std::size_t)&gt; handler)&#123; auto self = shared_from_this(); _socket.async_read_some(boost::asio::buffer(_data + read_len, total_len-read_len), [read_len, total_len, handler, self](const boost::system::error_code&amp; ec, std::size_t bytesTransfered) &#123; if (ec) &#123; // 出现错误，调用回调函数 handler(ec, read_len + bytesTransfered); return; &#125; if (read_len + bytesTransfered &gt;= total_len) &#123; //长度够了就调用回调函数 handler(ec, read_len + bytesTransfered); return; &#125; // 没有错误，且长度不足则继续读取 self-&gt;asyncReadLen(read_len + bytesTransfered, total_len, handler); &#125;);&#125; 读取头部成功后，其回调函数内部调用了读包体的逻辑 12345678910111213141516171819202122232425262728293031323334void CSession::AsyncReadBody(int total_len)&#123; auto self = shared_from_this(); asyncReadFull(total_len, [self, this, total_len](const boost::system::error_code&amp; ec, std::size_t bytes_transfered) &#123; try &#123; if (ec) &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; ec.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); return; &#125; if (bytes_transfered &lt; total_len) &#123; std::cout &lt;&lt; &quot;read length not match, read [&quot; &lt;&lt; bytes_transfered &lt;&lt; &quot;] , total [&quot; &lt;&lt; total_len&lt;&lt;&quot;]&quot; &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); return; &#125; memcpy(_recv_msg_node-&gt;_data , _data , bytes_transfered); _recv_msg_node-&gt;_cur_len += bytes_transfered; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //此处将消息投递到逻辑队列中 LogicSystem::GetInstance()-&gt;PostMsgToQue(make_shared&lt;LogicNode&gt;(shared_from_this(), _recv_msg_node)); //继续监听头部接受事件 AsyncReadHead(HEAD_TOTAL_LEN); &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception code is &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; &#125;);&#125; 读取包体完成后，在回调中继续读包头。以此循环往复直到读完所有数据。如果对方不发送数据，则回调函数就不会触发。不影响程序执行其他工作，因为我们采用的是asio异步的读写操作。 当然我们解析完包体后会调用LogicSystem单例将解析好的消息封装为逻辑节点传递给逻辑层进行处理。 LogicSystem我们在逻辑层处理 123456789101112131415void LogicSystem::RegisterCallBacks() &#123; _fun_callbacks[MSG_CHAT_LOGIN] = std::bind(&amp;LogicSystem::LoginHandler, this, placeholders::_1, placeholders::_2, placeholders::_3);&#125;void LogicSystem::LoginHandler(shared_ptr&lt;CSession&gt; session, const short &amp;msg_id, const string &amp;msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); std::cout &lt;&lt; &quot;user login uid is &quot; &lt;&lt; root[&quot;uid&quot;].asInt() &lt;&lt; &quot; user token is &quot; &lt;&lt; root[&quot;token&quot;].asString() &lt;&lt; endl; std::string return_str = root.toStyledString(); session-&gt;Send(return_str, msg_id);&#125; 并在构造函数中注册这些处理流程 1234LogicSystem::LogicSystem():_b_stop(false)&#123; RegisterCallBacks(); _worker_thread = std::thread (&amp;LogicSystem::DealMsg, this);&#125; 总结到此，完成了ChatServer收到QT客户端发送过来的长链接请求，并解析读取的数据，将收到的数据通过tcp发送给对端。接下来还要做ChatServer到GateServer的token验证，判断是否合理，这个教给之后的文章处理。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(17) 登录验证和状态服务","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro17/","text":"完善proto在proto文件里新增登陆验证服务 123456789101112131415message LoginReq&#123; int32 uid = 1; string token= 2;&#125;message LoginRsp &#123; int32 error = 1; int32 uid = 2; string token = 3;&#125;service StatusService &#123; rpc GetChatServer (GetChatServerReq) returns (GetChatServerRsp) &#123;&#125; rpc Login(LoginReq) returns(LoginRsp);&#125; 接下来是调用grpc命令生成新的pb文件覆盖原有的，并且也拷贝给StatusServer一份 我们完善登陆逻辑，先去StatusServer验证token是否合理，如果合理再从内存中寻找用户信息，如果没找到则从数据库加载一份。 1234567891011121314151617181920212223242526272829303132333435363738394041void LogicSystem::LoginHandler(shared_ptr&lt;CSession&gt; session, const short &amp;msg_id, const string &amp;msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid = root[&quot;uid&quot;].asInt(); std::cout &lt;&lt; &quot;user login uid is &quot; &lt;&lt; uid &lt;&lt; &quot; user token is &quot; &lt;&lt; root[&quot;token&quot;].asString() &lt;&lt; endl; //从状态服务器获取token匹配是否准确 auto rsp = StatusGrpcClient::GetInstance()-&gt;Login(uid, root[&quot;token&quot;].asString()); Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, MSG_CHAT_LOGIN_RSP); &#125;); rtvalue[&quot;error&quot;] = rsp.error(); if (rsp.error() != ErrorCodes::Success) &#123; return; &#125; //内存中查询用户信息 auto find_iter = _users.find(uid); std::shared_ptr&lt;UserInfo&gt; user_info = nullptr; if (find_iter == _users.end()) &#123; //查询数据库 user_info = MysqlMgr::GetInstance()-&gt;GetUser(uid); if (user_info == nullptr) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; return; &#125; _users[uid] = user_info; &#125; else &#123; user_info = find_iter-&gt;second; &#125; rtvalue[&quot;uid&quot;] = uid; rtvalue[&quot;token&quot;] = rsp.token(); rtvalue[&quot;name&quot;] = user_info-&gt;name;&#125; StatusServer验证token在StatusServer验证token之前，我们需要在StatusServer中的GetServer的服务里将token写入内存 1234567891011Status StatusServiceImpl::GetChatServer(ServerContext* context, const GetChatServerReq* request, GetChatServerRsp* reply)&#123; std::string prefix(&quot;llfc status server has received : &quot;); const auto&amp; server = getChatServer(); reply-&gt;set_host(server.host); reply-&gt;set_port(server.port); reply-&gt;set_error(ErrorCodes::Success); reply-&gt;set_token(generate_unique_string()); insertToken(request-&gt;uid(), reply-&gt;token()); return Status::OK;&#125; 接下来我们实现登陆验证服务 12345678910111213141516171819Status StatusServiceImpl::Login(ServerContext* context, const LoginReq* request, LoginRsp* reply)&#123; auto uid = request-&gt;uid(); auto token = request-&gt;token(); std::lock_guard&lt;std::mutex&gt; guard(_token_mtx); auto iter = _tokens.find(uid); if (iter == _tokens.end()) &#123; reply-&gt;set_error(ErrorCodes::UidInvalid); return Status::OK; &#125; if (iter-&gt;second != token) &#123; reply-&gt;set_error(ErrorCodes::TokenInvalid); return Status::OK; &#125; reply-&gt;set_error(ErrorCodes::Success); reply-&gt;set_uid(uid); reply-&gt;set_token(token); return Status::OK;&#125; 这样当GateServer访问StatusServer的Login服务做验证后，就可以将数据返回给QT前端了。 客户端处理登陆回包QT 的客户端TcpMgr收到请求后要进行对应的逻辑处理。所以我们在TcpMgr的构造函数中调用initHandlers注册消息 123456789101112131415161718192021222324252627282930313233343536void TcpMgr::initHandlers()&#123; //auto self = shared_from_this(); _handlers.insert(ID_CHAT_LOGIN_RSP, [this](ReqId id, int len, QByteArray data)&#123; qDebug()&lt;&lt; &quot;handle id is &quot;&lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if(jsonDoc.isNull())&#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if(!jsonObj.contains(&quot;error&quot;))&#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Login Failed, err is Json Parse Err&quot; &lt;&lt; err ; emit sig_login_failed(err); return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if(err != ErrorCodes::SUCCESS)&#123; qDebug() &lt;&lt; &quot;Login Failed, err is &quot; &lt;&lt; err ; emit sig_login_failed(err); return; &#125; UserMgr::GetInstance()-&gt;SetUid(jsonObj[&quot;uid&quot;].toInt()); UserMgr::GetInstance()-&gt;SetName(jsonObj[&quot;name&quot;].toString()); UserMgr::GetInstance()-&gt;SetToken(jsonObj[&quot;token&quot;].toString()); emit sig_swich_chatdlg(); &#125;);&#125; 并且增加处理请求 12345678910void TcpMgr::handleMsg(ReqId id, int len, QByteArray data)&#123; auto find_iter = _handlers.find(id); if(find_iter == _handlers.end())&#123; qDebug()&lt;&lt; &quot;not found id [&quot;&lt;&lt; id &lt;&lt; &quot;] to handle&quot;; return ; &#125; find_iter.value()(id,len,data);&#125; 用户管理为管理用户数据，需要创建一个UserMgr类，统一管理用户数据，我们这么声明 123456789101112131415161718192021222324#ifndef USERMGR_H#define USERMGR_H#include &lt;QObject&gt;#include &lt;memory&gt;#include &lt;singleton.h&gt;class UserMgr:public QObject,public Singleton&lt;UserMgr&gt;, public std::enable_shared_from_this&lt;UserMgr&gt;&#123; Q_OBJECTpublic: friend class Singleton&lt;UserMgr&gt;; ~ UserMgr(); void SetName(QString name); void SetUid(int uid); void SetToken(QString token);private: UserMgr(); QString _name; QString _token; int _uid;&#125;;#endif // USERMGR_H 简单实现几个功能 1234567891011121314151617181920212223242526#include &quot;usermgr.h&quot;UserMgr::~UserMgr()&#123;&#125;void UserMgr::SetName(QString name)&#123; _name = name;&#125;void UserMgr::SetUid(int uid)&#123; _uid = uid;&#125;void UserMgr::SetToken(QString token)&#123; _token = token;&#125;UserMgr::UserMgr()&#123;&#125; 详细和复杂的管理后续不断往这里补充就行了。 登陆界面登陆界面响应TcpMgr返回的登陆请求，在其构造函数中添加 12//连接tcp管理者发出的登陆失败信号 connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_login_failed, this, &amp;LoginDialog::slot_login_failed); 并实现槽函数 1234567void LoginDialog::slot_login_failed(int err)&#123; QString result = QString(&quot;登录失败, err is %1&quot;) .arg(err); showTip(result,false); enableBtn(true);&#125; 到此完成了登陆的请求和响应，接下来要实现响应登陆成功后跳转到聊天界面。下一篇先实现聊天布局。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(18) 聊天界面布局以及可点击按钮的实现","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro18/","text":"聊天界面整体展示我们先看下整体的聊天界面，方便以后逐个功能添加 QT Designer中 ui 设计如下 将聊天对话框分为几个部分： 1 处为左侧功能切换区域，包括聊天，联系人等。 2 处为搜索区域，可以搜索联系人，聊天记录等， 搜索框后面的按钮是快速拉人创建群聊的功能。 3 处为近期聊天联系列表 4 处为搜索结果列表，包括匹配到的联系人，聊天记录，以及添加联系人的按钮。 5 处为聊天对象名称和头像的显示区域，这里先做简单演示写死。 6 处为聊天记录区域。 7 处为工具栏区域。 8 处为输入区域 9 处为发送按钮区域。 大家可以按照这个布局拖动和修改，达到我的布局效果。 创建ChatDialog右键项目，选择创建设计师界面类，选择创建QDialog without buttons。对话框的名字为ChatDialog 创建完成后，在之前登录成功的回调里，跳转到这个对话框。在MainWindow里添加槽函数 12345678910void MainWindow::SlotSwitchChat()&#123; _chat_dlg = new ChatDialog(); _chat_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint); setCentralWidget(_chat_dlg); _chat_dlg-&gt;show(); _login_dlg-&gt;hide(); this-&gt;setMinimumSize(QSize(1050,900)); this-&gt;setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);&#125; 在MainWindow的构造函数中添加信号和槽的链接 123//连接创建聊天界面信号connect(TcpMgr::GetInstance().get(),&amp;TcpMgr::sig_swich_chatdlg, this, &amp;MainWindow::SlotSwitchChat); 并且在TcpMgr中添加信号 1void sig_swich_chatdlg(); 为了方便测试，我们在MainWindow的构造函数中直接发送sig_switch_chatdlg信号，这样程序运行起来就会直接跳转到聊天界面 ChatDialog ui文件ui文件的结构可以参考我的源码中的结构，这里我们可以简单看下 按照这个布局拖动并设置宽高即可，接下来需要设置下qss调整颜色 123#side_bar&#123; background-color:rgb(46,46,46);&#125; 重写点击按钮为了实现点击效果，我们继承QPushButton实现按钮的点击效果，包括普通状态，悬浮状态，以及按下状态 1234567891011121314151617class ClickedBtn:public QPushButton&#123; Q_OBJECTpublic: ClickedBtn(QWidget * parent = nullptr); ~ClickedBtn(); void SetState(QString nomal, QString hover, QString press);protected: virtual void enterEvent(QEvent *event) override; // 鼠标进入 virtual void leaveEvent(QEvent *event) override;// 鼠标离开 virtual void mousePressEvent(QMouseEvent *event) override; // 鼠标按下 virtual void mouseReleaseEvent(QMouseEvent *event) override; // 鼠标释放private: QString _normal; QString _hover; QString _press;&#125;; 接下来实现其按下，离开进入等资源加载，并且重写这些事件 123456789101112131415161718192021222324252627282930313233343536373839404142ClickedBtn::ClickedBtn(QWidget *parent):QPushButton (parent)&#123; setCursor(Qt::PointingHandCursor); // 设置光标为小手&#125;ClickedBtn::~ClickedBtn()&#123;&#125;void ClickedBtn::SetState(QString normal, QString hover, QString press)&#123; _hover = hover; _normal = normal; _press = press; setProperty(&quot;state&quot;,normal); repolish(this); update();&#125;void ClickedBtn::enterEvent(QEvent *event)&#123; setProperty(&quot;state&quot;,_hover); repolish(this); update(); QPushButton::enterEvent(event);&#125;void ClickedBtn::mousePressEvent(QMouseEvent *event)&#123; setProperty(&quot;state&quot;,_press); repolish(this); update(); QPushButton::mousePressEvent(event);&#125;void ClickedBtn::mouseReleaseEvent(QMouseEvent *event)&#123; setProperty(&quot;state&quot;,_hover); repolish(this); update(); QPushButton::mouseReleaseEvent(event);&#125; 回到chatdialog.ui文件，将add_btn升级为ClickedBtn 接着在qss文件中添加样式 123456789101112#add_btn[state=&#x27;normal&#x27;]&#123; border-image: url(:/res/add_friend_normal.png);&#125;#add_btn[state=&#x27;hover&#x27;]&#123; border-image: url(:/res/add_friend_hover.png);&#125;#add_btn[state=&#x27;press&#x27;]&#123; border-image: url(:/res/add_friend_hover.png);&#125; add_btn的样式一定要显示设置一下三个样式，所以我们回到ChatDialog的构造函数中设置样式 1ui-&gt;add_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); 再次启动运行，可以看到添加群组的按钮样式和sidebar的样式生效了。 为了美观显示，我们去mainwindow.ui中移除状态栏和菜单栏。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(19) 实现搜索框和聊天列表","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro19/","text":"搜索框我们需要实现如下效果 输入框默认不显示关闭按钮，当输入文字后显示关闭按钮，点击关闭按钮清空文字 添加CustomizeEdit类，头文件 1234567891011121314151617181920212223242526272829303132333435363738394041#ifndef CUSTOMIZEEDIT_H#define CUSTOMIZEEDIT_H#include &lt;QLineEdit&gt;#include &lt;QDebug&gt;class CustomizeEdit: public QLineEdit&#123; Q_OBJECTpublic: CustomizeEdit(QWidget *parent = nullptr); void SetMaxLength(int maxLen);protected: void focusOutEvent(QFocusEvent *event) override &#123; // 执行失去焦点时的处理逻辑 //qDebug() &lt;&lt; &quot;CustomizeEdit focusout&quot;; // 调用基类的focusOutEvent()方法，保证基类的行为得到执行 QLineEdit::focusOutEvent(event); //发送失去焦点得信号 emit sig_foucus_out(); &#125;private: void limitTextLength(QString text) &#123; if(_max_len &lt;= 0)&#123; return; &#125; QByteArray byteArray = text.toUtf8(); if (byteArray.size() &gt; _max_len) &#123; byteArray = byteArray.left(_max_len); this-&gt;setText(QString::fromUtf8(byteArray)); &#125; &#125; int _max_len;signals: void sig_foucus_out();&#125;;#endif // CUSTOMIZEEDIT_H 源文件 1234567891011#include &quot;customizeedit.h&quot;CustomizeEdit::CustomizeEdit(QWidget *parent):QLineEdit (parent),_max_len(0)&#123; connect(this, &amp;QLineEdit::textChanged, this, &amp;CustomizeEdit::limitTextLength);&#125;void CustomizeEdit::SetMaxLength(int maxLen)&#123; _max_len = maxLen;&#125; 设计师界面类里将ui-&gt;search_edit提升为CustomizeEdit 在ChatDialog的构造函数中设置输入的长度限制以及关闭等图标的配置 123456789101112131415161718192021222324252627282930313233QAction *searchAction = new QAction(ui-&gt;search_edit);searchAction-&gt;setIcon(QIcon(&quot;:/res/search.png&quot;));ui-&gt;search_edit-&gt;addAction(searchAction,QLineEdit::LeadingPosition);ui-&gt;search_edit-&gt;setPlaceholderText(QStringLiteral(&quot;搜索&quot;));// 创建一个清除动作并设置图标QAction *clearAction = new QAction(ui-&gt;search_edit);clearAction-&gt;setIcon(QIcon(&quot;:/res/close_transparent.png&quot;));// 初始时不显示清除图标// 将清除动作添加到LineEdit的末尾位置ui-&gt;search_edit-&gt;addAction(clearAction, QLineEdit::TrailingPosition);// 当需要显示清除图标时，更改为实际的清除图标connect(ui-&gt;search_edit, &amp;QLineEdit::textChanged, [clearAction](const QString &amp;text) &#123; if (!text.isEmpty()) &#123; clearAction-&gt;setIcon(QIcon(&quot;:/res/close_search.png&quot;)); &#125; else &#123; clearAction-&gt;setIcon(QIcon(&quot;:/res/close_transparent.png&quot;)); // 文本为空时，切换回透明图标 &#125;&#125;);// 连接清除动作的触发信号到槽函数，用于清除文本connect(clearAction, &amp;QAction::triggered, [this, clearAction]() &#123; ui-&gt;search_edit-&gt;clear(); clearAction-&gt;setIcon(QIcon(&quot;:/res/close_transparent.png&quot;)); // 清除文本后，切换回透明图标 ui-&gt;search_edit-&gt;clearFocus(); //清除按钮被按下则不显示搜索框 //ShowSearch(false);&#125;);ui-&gt;search_edit-&gt;SetMaxLength(15); stylesheet.qss 中修改样式 1234567#search_wid&#123; background-color:rgb(247,247,247);&#125;#search_edit &#123; border: 2px solid #f1f1f1;&#125; 聊天记录列表创建C++ 类ChatUserList 123456789101112131415161718192021#ifndef CHATUSERLIST_H#define CHATUSERLIST_H#include &lt;QListWidget&gt;#include &lt;QWheelEvent&gt;#include &lt;QEvent&gt;#include &lt;QScrollBar&gt;#include &lt;QDebug&gt;class ChatUserList: public QListWidget&#123; Q_OBJECTpublic: ChatUserList(QWidget *parent = nullptr);protected: bool eventFilter(QObject *watched, QEvent *event) override;signals: void sig_loading_chat_user();&#125;;#endif // CHATUSERLIST_H 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &quot;chatuserlist.h&quot;ChatUserList::ChatUserList(QWidget *parent):QListWidget(parent)&#123; Q_UNUSED(parent); this-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); // 安装事件过滤器 this-&gt;viewport()-&gt;installEventFilter(this);&#125;bool ChatUserList::eventFilter(QObject *watched, QEvent *event)&#123; // 检查事件是否是鼠标悬浮进入或离开 if (watched == this-&gt;viewport()) &#123; if (event-&gt;type() == QEvent::Enter) &#123; // 鼠标悬浮，显示滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); &#125; else if (event-&gt;type() == QEvent::Leave) &#123; // 鼠标离开，隐藏滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); &#125; &#125; // 检查事件是否是鼠标滚轮事件 if (watched == this-&gt;viewport() &amp;&amp; event-&gt;type() == QEvent::Wheel) &#123; QWheelEvent *wheelEvent = static_cast&lt;QWheelEvent*&gt;(event); int numDegrees = wheelEvent-&gt;angleDelta().y() / 8; int numSteps = numDegrees / 15; // 计算滚动步数 // 设置滚动幅度 this-&gt;verticalScrollBar()-&gt;setValue(this-&gt;verticalScrollBar()-&gt;value() - numSteps); // 检查是否滚动到底部 QScrollBar *scrollBar = this-&gt;verticalScrollBar(); int maxScrollValue = scrollBar-&gt;maximum(); int currentValue = scrollBar-&gt;value(); //int pageSize = 10; // 每页加载的联系人数量 if (maxScrollValue - currentValue &lt;= 0) &#123; // 滚动到底部，加载新的联系人 qDebug()&lt;&lt;&quot;load more chat user&quot;; //发送信号通知聊天界面加载更多聊天内容 emit sig_loading_chat_user(); &#125; return true; // 停止事件传递 &#125; return QListWidget::eventFilter(watched, event);&#125; 在设计师界面类里提升ui-&gt;chat_user_list为ChatUserList 在ChatDialog构造函数和搜索清除按钮的回调中增加 1ShowSearch(false); 该函数的具体实现 12345678910111213141516171819void ChatDialog::ShowSearch(bool bsearch)&#123; if(bsearch)&#123; ui-&gt;chat_user_list-&gt;hide(); ui-&gt;con_user_list-&gt;hide(); ui-&gt;search_list-&gt;show(); _mode = ChatUIMode::SearchMode; &#125;else if(_state == ChatUIMode::ChatMode)&#123; ui-&gt;chat_user_list-&gt;show(); ui-&gt;con_user_list-&gt;hide(); ui-&gt;search_list-&gt;hide(); _mode = ChatUIMode::ChatMode; &#125;else if(_state == ChatUIMode::ContactMode)&#123; ui-&gt;chat_user_list-&gt;hide(); ui-&gt;search_list-&gt;hide(); ui-&gt;con_user_list-&gt;show(); _mode = ChatUIMode::ContactMode; &#125;&#125; ChatDialog类中声明添加 123ChatUIMode _mode;ChatUIMode _state;bool _b_loading; 构造函数的初始化列表初始化这些模式和状态 1234ChatDialog::ChatDialog(QWidget *parent) : QDialog(parent), ui(new Ui::ChatDialog),_mode(ChatUIMode::ChatMode), _state(ChatUIMode::ChatMode),_b_loading(false)&#123;//...&#125; 为了让用户聊天列表更美观，修改qss文件 1234567891011121314151617181920212223242526#chat_user_wid&#123; background-color:rgb(0,0,0);&#125;#chat_user_list &#123; background-color: rgb(247,247,248); border: none;&#125;#chat_user_list::item:selected &#123; background-color: #d3d7d4; border: none; outline: none;&#125;#chat_user_list::item:hover &#123; background-color: rgb(206,207,208); border: none; outline: none;&#125;#chat_user_list::focus &#123; border: none; outline: none;&#125; 添加聊天item我们要为聊天列表添加item，每个item包含的样式为 对于这样的列表元素，我们采用设计师界面类设计非常方便, 新建设计师界面类ChatUserWid, 在ChatUserWid.ui中拖动布局如下 我们定义一个基类ListItemBase 12345678910111213141516171819202122232425#ifndef LISTITEMBASE_H#define LISTITEMBASE_H#include &lt;QWidget&gt;#include &quot;global.h&quot;class ListItemBase : public QWidget&#123; Q_OBJECTpublic: explicit ListItemBase(QWidget *parent = nullptr); void SetItemType(ListItemType itemType); ListItemType GetItemType();private: ListItemType _itemType;public slots:signals:&#125;;#endif // LISTITEMBASE_H 我们实现这个基类 12345678910111213141516#include &quot;listitembase.h&quot;ListItemBase::ListItemBase(QWidget *parent) : QWidget(parent)&#123;&#125;void ListItemBase::SetItemType(ListItemType itemType)&#123; _itemType = itemType;&#125;ListItemType ListItemBase::GetItemType()&#123; return _itemType;&#125; 我们实现ChatUserWid 1234567891011121314151617181920212223242526272829303132#ifndef CHATUSERWID_H#define CHATUSERWID_H#include &lt;QWidget&gt;#include &quot;listitembase.h&quot;namespace Ui &#123;class ChatUserWid;&#125;class ChatUserWid : public ListItemBase&#123; Q_OBJECTpublic: explicit ChatUserWid(QWidget *parent = nullptr); ~ChatUserWid(); QSize sizeHint() const override &#123; return QSize(250, 70); // 返回自定义的尺寸 &#125; void SetInfo(QString name, QString head, QString msg);private: Ui::ChatUserWid *ui; QString _name; QString _head; QString _msg;&#125;;#endif // CHATUSERWID_H 具体实现 12345678910111213141516171819202122232425262728293031#include &quot;chatuserwid.h&quot;#include &quot;ui_chatuserwid.h&quot;ChatUserWid::ChatUserWid(QWidget *parent) : ListItemBase(parent), ui(new Ui::ChatUserWid)&#123; ui-&gt;setupUi(this); SetItemType(ListItemType::CHAT_USER_ITEM);&#125;ChatUserWid::~ChatUserWid()&#123; delete ui;&#125;void ChatUserWid::SetInfo(QString name, QString head, QString msg)&#123; _name = name; _head = head; _msg = msg; // 加载图片 QPixmap pixmap(_head); // 设置图片自动缩放 ui-&gt;icon_lb-&gt;setPixmap(pixmap.scaled(ui-&gt;icon_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation)); ui-&gt;icon_lb-&gt;setScaledContents(true); ui-&gt;user_name_lb-&gt;setText(_name); ui-&gt;user_chat_lb-&gt;setText(_msg);&#125; 在ChatDialog里定义一些全局的变量用来做测试 123456789101112131415161718192021222324std::vector&lt;QString&gt; strs =&#123;&quot;hello world !&quot;, &quot;nice to meet u&quot;, &quot;New year，new life&quot;, &quot;You have to love yourself&quot;, &quot;My love is written in the wind ever since the whole world is you&quot;&#125;;std::vector&lt;QString&gt; heads = &#123; &quot;:/res/head_1.jpg&quot;, &quot;:/res/head_2.jpg&quot;, &quot;:/res/head_3.jpg&quot;, &quot;:/res/head_4.jpg&quot;, &quot;:/res/head_5.jpg&quot;&#125;;std::vector&lt;QString&gt; names = &#123; &quot;llfc&quot;, &quot;zack&quot;, &quot;golang&quot;, &quot;cpp&quot;, &quot;java&quot;, &quot;nodejs&quot;, &quot;python&quot;, &quot;rust&quot;&#125;; 这些数据只是测试数据，实际数据是后端传输过来的，我们目前只测试界面功能，用测试数据即可，写一个函数根据上面的数据添加13条item记录 123456789101112131415161718void ChatDialog::addChatUserList()&#123; // 创建QListWidgetItem，并设置自定义的widget for(int i = 0; i &lt; 13; i++)&#123; int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int str_i = randomValue%strs.size(); int head_i = randomValue%heads.size(); int name_i = randomValue%names.size(); auto *chat_user_wid = new ChatUserWid(); chat_user_wid-&gt;SetInfo(names[name_i], heads[head_i], strs[str_i]); QListWidgetItem *item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(chat_user_wid-&gt;sizeHint()); ui-&gt;chat_user_list-&gt;addItem(item); ui-&gt;chat_user_list-&gt;setItemWidget(item, chat_user_wid); &#125;&#125; 在ChatDialog构造函数中添加 1addChatUserList(); 完善界面效果，新增qss 123456789101112131415161718192021222324252627282930313233343536373839404142434445ChatUserWid &#123; background-color:rgb(247,247,247); border: none;&#125;#user_chat_lb&#123; color:rgb(153,153,153); font-size: 12px; font-family: &quot;Microsoft YaHei&quot;;&#125;#user_name_lb&#123; color:rgb(0,0,0); font-size: 14px; font-weight: normal; font-family: &quot;Microsoft YaHei&quot;;&#125;#time_wid #time_lb&#123; color:rgb(140,140,140); font-size: 12px; font-family: &quot;Microsoft YaHei&quot;;&#125;QScrollBar:vertical &#123; background: transparent; /* 将轨道背景设置为透明 */ width: 8px; /* 滚动条宽度，根据需要调整 */ margin: 0px; /* 移除滚动条与滑块之间的间距 */&#125;QScrollBar::handle:vertical &#123; background: rgb(173,170,169); /* 滑块颜色 */ min-height: 10px; /* 滑块最小高度，根据需要调整 */ border-radius: 4px; /* 滑块边缘圆角，调整以形成椭圆形状 */&#125;QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical &#123; height: 0px; /* 移除上下按钮 */ border: none; /* 移除边框 */ background: transparent; /* 背景透明 */&#125;QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical &#123; background: none; /* 页面滚动部分背景透明 */&#125; 测试效果 源码链接https://gitee.com/secondtonone1/llfcchat 视频链接https://www.bilibili.com/video/BV13Z421W7WA/?spm_id_from=333.788&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(2) 内存泄漏修复和qss样式切换","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro2/","text":"完善注册类界面先在注册类构造函数里添加lineEdit的模式为密码模式 12ui-&gt;lineEdit_Passwd-&gt;setEchoMode(QLineEdit::Password);ui-&gt;lineEdit_Confirm-&gt;setEchoMode(QLineEdit::Password); 我们在注册界面的ui里添加一个widget，widget内部包含一个tip居中显示，用来提示错误。设置label的显示为文字居中。 我们在qss里添加err_tip样式，根据不同的状态做字体显示 1234567#err_tip[state=&#x27;normal&#x27;]&#123; color: green;&#125;#err_tip[state=&#x27;err&#x27;]&#123; color: red;&#125; 接下来项目中添加global.h和global.cpp文件，global.h声明repolish函数，global.cpp用来定义这个函数。 .h中的声明 12345678#ifndef GLOBAL_H#define GLOBAL_H#include &lt;QWidget&gt;#include &lt;functional&gt;#include &quot;QStyle&quot;extern std::function&lt;void(QWidget*)&gt; repolish;#endif // GLOBAL_H .cpp中的定义 1234567#include &quot;global.h&quot;std::function&lt;void(QWidget*)&gt; repolish =[](QWidget *w)&#123; w-&gt;style()-&gt;unpolish(w); w-&gt;style()-&gt;polish(w);&#125;; 在Register的构造函数中添加样式设置。 12ui-&gt;err_tip-&gt;setProperty(&quot;state&quot;,&quot;normal&quot;);repolish(ui-&gt;err_tip); 接下来实现获取验证码的逻辑,ui里关联get_code按钮的槽事件，并实现槽函数 1234567891011121314void RegisterDialog::on_get_code_clicked()&#123; //验证邮箱的地址正则表达式 auto email = ui-&gt;email_edit-&gt;text(); // 邮箱地址的正则表达式 QRegularExpression regex(R&quot;((\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+)&quot;); bool match = regex.match(email).hasMatch(); // 执行正则表达式匹配 if(match)&#123; //发送http请求获取验证码 &#125;else&#123; //提示邮箱不正确 showTip(tr(&quot;邮箱地址不正确&quot;)); &#125;&#125; 在RegisterDialog中添加showTip函数 123456void RegisterDialog::showTip(QString str)&#123; ui-&gt;err_tip-&gt;setText(str); ui-&gt;err_tip-&gt;setProperty(&quot;state&quot;,&quot;err&quot;); repolish(ui-&gt;err_tip);&#125; 好了，这样就完成了。测试提示功能正确，下面要实现判断邮箱正确后发送http请求。 单例类封装网络请求类要做成一个单例类，这样方便在任何需要发送http请求的时候调用，我们先实现单例类,添加singleton.h实现如下 12345678910111213141516171819202122232425262728293031#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Singleton &#123;protected: Singleton() = default; Singleton(const Singleton&lt;T&gt;&amp;) = delete; Singleton&amp; operator=(const Singleton&lt;T&gt;&amp; st) = delete; static std::shared_ptr&lt;T&gt; _instance;public: static std::shared_ptr&lt;T&gt; GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = shared_ptr&lt;T&gt;(new T); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; endl; &#125; ~Singleton() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr; http管理类http管理类主要用来管理http发送接收等请求得，我们需要在pro中添加网络库 1QT += core gui network 在pro中添加C++类，命名为HttpMgr，然后头文件如下 1234567891011121314151617181920212223#include &quot;singleton.h&quot;#include &lt;QString&gt;#include &lt;QUrl&gt;#include &lt;QObject&gt;#include &lt;QNetworkAccessManager&gt;#include &quot;global.h&quot;#include &lt;memory&gt;#include &lt;QJsonObject&gt;#include &lt;QJsonDocument&gt;class HttpMgr:public QObject, public Singleton&lt;HttpMgr&gt;, public std::enable_shared_from_this&lt;HttpMgr&gt;&#123; Q_OBJECTpublic: ~HttpMgr();private: friend class Singleton&lt;HttpMgr&gt;; HttpMgr(); QNetworkAccessManager _manager;signals: void sig_http_finish();&#125;; 我们先实现PostHttpReq请求的函数，也就是发送http的post请求, 发送请求要用到请求的url，请求的数据(json或者protobuf序列化)，以及请求的id，以及哪个模块发出的请求mod，那么一个请求接口应该是这样的 1void PostHttpReq(QUrl url, QJsonObject json, ReqId req_id, Modules mod); 我们去global.h定义ReqId枚举类型 1234enum ReqId&#123; ID_GET_VARIFY_CODE = 1001, //获取验证码 ID_REG_USER = 1002, //注册用户&#125;; 在global.h定义ErrorCodes 12345enum ErrorCodes&#123; SUCCESS = 0, ERR_JSON = 1, //Json解析失败 ERR_NETWORK = 2,&#125;; 在global.h中定义模块 123enum Modules&#123; REGISTERMOD = 0,&#125;; 还需要修改下要发送的信号，在HttpMgr的头文件里，让他携带参数 1void sig_http_finish(ReqId id, QString res, ErrorCodes err, Modules mod); 我们实现PostHttpReq 12345678910111213141516171819202122232425262728293031void HttpMgr::PostHttpReq(QUrl url, QJsonObject json, ReqId req_id, Modules mod)&#123; //创建一个HTTP POST请求，并设置请求头和请求体 QByteArray data = QJsonDocument(json).toJson(); //通过url构造请求 QNetworkRequest request(url); request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/json&quot;); request.setHeader(QNetworkRequest::ContentLengthHeader, QByteArray::number(data.length())); //发送请求，并处理响应, 获取自己的智能指针，构造伪闭包并增加智能指针引用计数 auto self = shared_from_this(); QNetworkReply * reply = _manager.post(request, data); //设置信号和槽等待发送完成 QObject::connect(reply, &amp;QNetworkReply::finished, [reply, self, req_id, mod]()&#123; //处理错误的情况 if(reply-&gt;error() != QNetworkReply::NoError)&#123; qDebug() &lt;&lt; reply-&gt;errorString(); //发送信号通知完成 emit self-&gt;sig_http_finish(req_id, &quot;&quot;, ErrorCodes::ERR_NETWORK, mod); reply-&gt;deleteLater(); return; &#125; //无错误则读回请求 QString res = reply-&gt;readAll(); //发送信号通知完成 emit self-&gt;sig_http_finish(req_id, res, ErrorCodes::SUCCESS,mod); reply-&gt;deleteLater(); return; &#125;);&#125; 加下来HttpMgr内实现一个slot_http_finish的槽函数用来接收sig_http_finish信号。 1234567void HttpMgr::slot_http_finish(ReqId id, QString res, ErrorCodes err, Modules mod)&#123; if(mod == Modules::REGISTERMOD)&#123; //发送信号通知指定模块http响应结束 emit sig_reg_mod_finish(id, res, err); &#125;&#125; 我们在HttpMgr.h中添加信号sig_reg_mod_finish， 1234567891011class HttpMgr:public QObject, public Singleton&lt;HttpMgr&gt;, public std::enable_shared_from_this&lt;HttpMgr&gt;&#123; Q_OBJECTpublic: //...省略signals: void sig_http_finish(ReqId id, QString res, ErrorCodes err, Modules mod); void sig_reg_mod_finish(ReqId id, QString res, ErrorCodes err);&#125;; 并且在cpp文件中连接slot_http_finish和sig_http_finish. 12345HttpMgr::HttpMgr()&#123; //连接http请求和完成信号，信号槽机制保证队列消费 connect(this, &amp;HttpMgr::sig_http_finish, this, &amp;HttpMgr::slot_http_finish);&#125; 我们在注册界面连接sig_reg_mod_finish信号 1234567RegisterDialog::RegisterDialog(QWidget *parent) : QDialog(parent), ui(new Ui::RegisterDialog)&#123; //省略... connect(HttpMgr::GetInstance().get(), &amp;HttpMgr::sig_reg_mod_finish, this, &amp;RegisterDialog::slot_reg_mod_finish);&#125; 接下俩实现slot_reg_mod_finish函数 1234567891011121314151617181920212223242526void RegisterDialog::slot_reg_mod_finish(ReqId id, QString res, ErrorCodes err)&#123; if(err != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;网络请求错误&quot;),false); return; &#125; // 解析 JSON 字符串,res需转化为QByteArray QJsonDocument jsonDoc = QJsonDocument::fromJson(res.toUtf8()); //json解析错误 if(jsonDoc.isNull())&#123; showTip(tr(&quot;json解析错误&quot;),false); return; &#125; //json解析错误 if(!jsonDoc.isObject())&#123; showTip(tr(&quot;json解析错误&quot;),false); return; &#125; QJsonObject jsonObj = jsonDoc.object(); //调用对应的逻辑 return;&#125; showTip逻辑稍作修改，增加bool类型参数 123456789101112void RegisterDialog::showTip(QString str, bool b_ok)&#123; if(b_ok)&#123; ui-&gt;err_tip-&gt;setProperty(&quot;state&quot;,&quot;err&quot;); &#125;else&#123; ui-&gt;err_tip-&gt;setProperty(&quot;state&quot;,&quot;normal&quot;); &#125; ui-&gt;err_tip-&gt;setText(str); repolish(ui-&gt;err_tip);&#125; 注册消息处理我们需要对RegisterDialog注册消息处理，头文件声明 1QMap&lt;ReqId, std::function&lt;void(const QJsonObject&amp;)&gt;&gt; _handlers; 在RegisterDialog中添加注册消息处理的声明和定义 1234567891011121314void RegisterDialog::initHttpHandlers()&#123; //注册获取验证码回包逻辑 _handlers.insert(ReqId::ID_GET_VARIFY_CODE, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); return; &#125; auto email = jsonObj[&quot;email&quot;].toString(); showTip(tr(&quot;验证码已发送到邮箱，注意查收&quot;), true); qDebug()&lt;&lt; &quot;email is &quot; &lt;&lt; email ; &#125;);&#125; 回到slot_reg_mod_finish函数添加根据id调用函数处理对应逻辑 12345678void RegisterDialog::slot_reg_mod_finish(ReqId id, QString res, ErrorCodes err)&#123; //前面逻辑省略... //调用对应的逻辑,根据id回调。 _handlers[id](jsonDoc.object()); return;&#125;","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(20) 动态加载聊天列表","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro20/","text":"聊天列表动态加载如果要动态加载聊天列表内容，我们可以在列表的滚动区域捕获鼠标滑轮事件，并且在滚动到底部的时候我们发送一个加载聊天用户的信号 12345678910111213141516171819202122232425262728293031323334353637383940bool ChatUserList::eventFilter(QObject *watched, QEvent *event)&#123; // 检查事件是否是鼠标悬浮进入或离开 if (watched == this-&gt;viewport()) &#123; if (event-&gt;type() == QEvent::Enter) &#123; // 鼠标悬浮，显示滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); &#125; else if (event-&gt;type() == QEvent::Leave) &#123; // 鼠标离开，隐藏滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); &#125; &#125; // 检查事件是否是鼠标滚轮事件 if (watched == this-&gt;viewport() &amp;&amp; event-&gt;type() == QEvent::Wheel) &#123; QWheelEvent *wheelEvent = static_cast&lt;QWheelEvent*&gt;(event); int numDegrees = wheelEvent-&gt;angleDelta().y() / 8; int numSteps = numDegrees / 15; // 计算滚动步数 // 设置滚动幅度 this-&gt;verticalScrollBar()-&gt;setValue(this-&gt;verticalScrollBar()-&gt;value() - numSteps); // 检查是否滚动到底部 QScrollBar *scrollBar = this-&gt;verticalScrollBar(); int maxScrollValue = scrollBar-&gt;maximum(); int currentValue = scrollBar-&gt;value(); //int pageSize = 10; // 每页加载的联系人数量 if (maxScrollValue - currentValue &lt;= 0) &#123; // 滚动到底部，加载新的联系人 qDebug()&lt;&lt;&quot;load more chat user&quot;; //发送信号通知聊天界面加载更多聊天内容 emit sig_loading_chat_user(); &#125; return true; // 停止事件传递 &#125; return QListWidget::eventFilter(watched, event);&#125; 回到ChatDialog类里添加槽函数 1234567891011121314151617void ChatDialog::slot_loading_chat_user()&#123; if(_b_loading)&#123; return; &#125; _b_loading = true; LoadingDlg *loadingDialog = new LoadingDlg(this); loadingDialog-&gt;setModal(true); loadingDialog-&gt;show(); qDebug() &lt;&lt; &quot;add new data to list.....&quot;; addChatUserList(); // 加载完成后关闭对话框 loadingDialog-&gt;deleteLater(); _b_loading = false;&#125; 槽函数中我们添加了LoadingDlg类，这个类也是个QT 设计师界面类，ui如下 添加stackwidget管理界面ChatDialog界面里添加stackedWidget，然后添加两个页面 回头我们将这两个界面升级为我们自定义的界面 我们先添加一个自定义的QT设计师界面类ChatPage,然后将原来放在ChatDialog.ui中的chat_data_wid这个widget移动到ChatPage中ui布局如下 布局属性如下 然后我们将ChatDialog.ui中的chat_page 升级为ChatPage。 接着我们将ChatPage中的一些控件比如emo_lb, file_lb升级为ClickedLabel, receive_btn, send_btn升级为ClickedBtn 如下图： 然后我们在ChatPage的构造函数中添加按钮样式的编写 12345678910111213ChatPage::ChatPage(QWidget *parent) : QWidget(parent), ui(new Ui::ChatPage)&#123; ui-&gt;setupUi(this); //设置按钮样式 ui-&gt;receive_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); ui-&gt;send_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); //设置图标样式 ui-&gt;emo_lb-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;,&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); ui-&gt;file_lb-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;,&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;);&#125; 因为我们继承了QWidget,我们想实现样式更新，需要重写paintEvent 1234567void ChatPage::paintEvent(QPaintEvent *event)&#123; QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);&#125; 类似的，我们的ListItemBase 1234567void ListItemBase::paintEvent(QPaintEvent *event)&#123; QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);&#125; ClickedLabel完善我们希望ClickedLabel在按下的时候显示按下状态的资源，在抬起的时候显示抬起的资源，所以修改按下事件和抬起事件 12345678910111213141516171819202122void ClickedLabel::mousePressEvent(QMouseEvent *event)&#123; if (event-&gt;button() == Qt::LeftButton) &#123; if(_curstate == ClickLbState::Normal)&#123; qDebug()&lt;&lt;&quot;clicked , change to selected hover: &quot;&lt;&lt; _selected_hover; _curstate = ClickLbState::Selected; setProperty(&quot;state&quot;,_selected_press); repolish(this); update(); &#125;else&#123; qDebug()&lt;&lt;&quot;clicked , change to normal hover: &quot;&lt;&lt; _normal_hover; _curstate = ClickLbState::Normal; setProperty(&quot;state&quot;,_normal_press); repolish(this); update(); &#125; return; &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QLabel::mousePressEvent(event);&#125; 抬起事件 123456789101112131415161718192021void ClickedLabel::mouseReleaseEvent(QMouseEvent *event)&#123; if (event-&gt;button() == Qt::LeftButton) &#123; if(_curstate == ClickLbState::Normal)&#123; // qDebug()&lt;&lt;&quot;ReleaseEvent , change to normal hover: &quot;&lt;&lt; _normal_hover; setProperty(&quot;state&quot;,_normal_hover); repolish(this); update(); &#125;else&#123; // qDebug()&lt;&lt;&quot;ReleaseEvent , change to select hover: &quot;&lt;&lt; _selected_hover; setProperty(&quot;state&quot;,_selected_hover); repolish(this); update(); &#125; emit clicked(); return; &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QLabel::mousePressEvent(event);&#125; qss美化我们添加qss美化一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112LoadingDlg&#123; background: #f2eada;&#125;#title_lb&#123; font-family: &quot;Microsoft YaHei&quot;; font-size: 18px; font-weight: normal;&#125;#chatEdit&#123; background: #ffffff; border: none; /* 隐藏边框 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ font-size: 18px; /* 设置字体大小 */ padding: 5px; /* 设置内边距 */&#125;#send_wid&#123; background: #ffffff; border: none; /* 隐藏边框 */&#125;#add_btn[state=&#x27;normal&#x27;]&#123; border-image: url(:/res/add_friend_normal.png);&#125;#add_btn[state=&#x27;hover&#x27;]&#123; border-image: url(:/res/add_friend_hover.png);&#125;#add_btn[state=&#x27;press&#x27;]&#123; border-image: url(:/res/add_friend_hover.png);&#125;#receive_btn[state=&#x27;normal&#x27;]&#123; background: #f0f0f0; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#receive_btn[state=&#x27;hover&#x27;]&#123; background: #d2d2d2; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#receive_btn[state=&#x27;press&#x27;]&#123; background: #c6c6c6; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#send_btn[state=&#x27;normal&#x27;]&#123; background: #f0f0f0; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#send_btn[state=&#x27;hover&#x27;]&#123; background: #d2d2d2; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#send_btn[state=&#x27;press&#x27;]&#123; background: #c6c6c6; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#tool_wid&#123; background: #ffffff; border-bottom: 0.5px solid #ececec; /* 设置下边框颜色和宽度 */&#125;#emo_lb[state=&#x27;normal&#x27;]&#123; border-image: url(:/res/smile.png);&#125;#emo_lb[state=&#x27;hover&#x27;]&#123; border-image: url(:/res/smile_hover.png);&#125;#emo_lb[state=&#x27;press&#x27;]&#123; border-image: url(:/res/smile_press.png);&#125;#file_lb[state=&#x27;normal&#x27;]&#123; border-image: url(:/res/filedir.png);&#125;#file_lb[state=&#x27;hover&#x27;]&#123; border-image: url(:/res/filedir_hover.png);&#125;#file_lb[state=&#x27;press&#x27;]&#123; border-image: url(:/res/filedir_press.png);&#125; 效果最后整体运行一下看看效果, 下一节我们实现红框内的内容 视频链接https://www.bilibili.com/video/BV13Z421W7WA/?spm_id_from=333.788&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接https://gitee.com/secondtonone1/llfcchat","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(21) 滚动聊天布局设计","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro21/","text":"滚动聊天布局设计我们的聊天布局如下图最外层的是一个chatview（黑色）， chatview内部在添加一个MainLayout（蓝色），MainLayout内部添加一个scrollarea(红色)，scrollarea内部包含一个widget（绿色），同时也包含一个HLayout（紫色）用来浮动显示滚动条。widget内部包含一个垂直布局Vlayout(黄色),黄色布局内部包含一个粉色的widget，widget占据拉伸比一万，保证充满整个布局。 代码实现我们对照上面的图手写代码，在项目中添加ChatView类，然后先实现类的声明 123456789101112131415161718192021class ChatView: public QWidget&#123; Q_OBJECTpublic: ChatView(QWidget *parent = Q_NULLPTR); void appendChatItem(QWidget *item); //尾插 void prependChatItem(QWidget *item); //头插 void insertChatItem(QWidget *before, QWidget *item);//中间插protected: bool eventFilter(QObject *o, QEvent *e) override; void paintEvent(QPaintEvent *event) override;private slots: void onVScrollBarMoved(int min, int max);private: void initStyleSheet();private: //QWidget *m_pCenterWidget; QVBoxLayout *m_pVl; QScrollArea *m_pScrollArea; bool isAppended;&#125;; 接下来实现其函数定义, 先实现构造函数 1234567891011121314151617181920212223242526272829303132333435ChatView::ChatView(QWidget *parent) : QWidget(parent) , isAppended(false)&#123; QVBoxLayout *pMainLayout = new QVBoxLayout(); this-&gt;setLayout(pMainLayout); pMainLayout-&gt;setMargin(0); m_pScrollArea = new QScrollArea(); m_pScrollArea-&gt;setObjectName(&quot;chat_area&quot;); pMainLayout-&gt;addWidget(m_pScrollArea); QWidget *w = new QWidget(this); w-&gt;setObjectName(&quot;chat_bg&quot;); w-&gt;setAutoFillBackground(true); QVBoxLayout *pVLayout_1 = new QVBoxLayout(); pVLayout_1-&gt;addWidget(new QWidget(), 100000); w-&gt;setLayout(pVLayout_1); m_pScrollArea-&gt;setWidget(w); m_pScrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); QScrollBar *pVScrollBar = m_pScrollArea-&gt;verticalScrollBar(); connect(pVScrollBar, &amp;QScrollBar::rangeChanged,this, &amp;ChatView::onVScrollBarMoved); //把垂直ScrollBar放到上边 而不是原来的并排 QHBoxLayout *pHLayout_2 = new QHBoxLayout(); pHLayout_2-&gt;addWidget(pVScrollBar, 0, Qt::AlignRight); pHLayout_2-&gt;setMargin(0); m_pScrollArea-&gt;setLayout(pHLayout_2); pVScrollBar-&gt;setHidden(true); m_pScrollArea-&gt;setWidgetResizable(true); m_pScrollArea-&gt;installEventFilter(this); initStyleSheet();&#125; 再实现添加条目到聊天背景 123456void ChatView::appendChatItem(QWidget *item)&#123; QVBoxLayout *vl = qobject_cast&lt;QVBoxLayout *&gt;(m_pScrollArea-&gt;widget()-&gt;layout()); vl-&gt;insertWidget(vl-&gt;count()-1, item); isAppended = true;&#125; 重写事件过滤器 12345678910111213141516bool ChatView::eventFilter(QObject *o, QEvent *e)&#123; /*if(e-&gt;type() == QEvent::Resize &amp;&amp; o == ) &#123; &#125; else */if(e-&gt;type() == QEvent::Enter &amp;&amp; o == m_pScrollArea) &#123; m_pScrollArea-&gt;verticalScrollBar()-&gt;setHidden(m_pScrollArea-&gt;verticalScrollBar()-&gt;maximum() == 0); &#125; else if(e-&gt;type() == QEvent::Leave &amp;&amp; o == m_pScrollArea) &#123; m_pScrollArea-&gt;verticalScrollBar()-&gt;setHidden(true); &#125; return QWidget::eventFilter(o, e);&#125; 重写paintEvent支持子类绘制 1234567void ChatView::paintEvent(QPaintEvent *event)&#123; QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);&#125; 监听滚动区域变化的槽函数 12345678910111213void ChatView::onVScrollBarMoved(int min, int max)&#123; if(isAppended) //添加item可能调用多次 &#123; QScrollBar *pVScrollBar = m_pScrollArea-&gt;verticalScrollBar(); pVScrollBar-&gt;setSliderPosition(pVScrollBar-&gt;maximum()); //500毫秒内可能调用多次 QTimer::singleShot(500, [this]() &#123; isAppended = false; &#125;); &#125;&#125; 本节先到这里，完成聊天布局基本的构造 视频链接https://www.bilibili.com/video/BV1xz421h7Ad/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接https://gitee.com/secondtonone1/llfcchat","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(22) 实现气泡聊天对话框","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro22/","text":"气泡聊天框设计我们期待实现如下绿色的气泡对话框 对于我们自己发出的信息，我们可以实现这样一个网格布局管理 NameLabel用来显示用户的名字，Bubble用来显示聊天信息，Spacer是个弹簧，保证将NameLabel,IconLabel，Bubble等挤压到右侧。 如果是别人发出的消息，我们设置这样一个网格布局 下面是实现布局的核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041ChatItemBase::ChatItemBase(ChatRole role, QWidget *parent) : QWidget(parent) , m_role(role)&#123; m_pNameLabel = new QLabel(); m_pNameLabel-&gt;setObjectName(&quot;chat_user_name&quot;); QFont font(&quot;Microsoft YaHei&quot;); font.setPointSize(9); m_pNameLabel-&gt;setFont(font); m_pNameLabel-&gt;setFixedHeight(20); m_pIconLabel = new QLabel(); m_pIconLabel-&gt;setScaledContents(true); m_pIconLabel-&gt;setFixedSize(42, 42); m_pBubble = new QWidget(); QGridLayout *pGLayout = new QGridLayout(); pGLayout-&gt;setVerticalSpacing(3); pGLayout-&gt;setHorizontalSpacing(3); pGLayout-&gt;setMargin(3); QSpacerItem*pSpacer = new QSpacerItem(40, 20, QSizePolicy::Expanding, QSizePolicy::Minimum); if(m_role == ChatRole::Self) &#123; m_pNameLabel-&gt;setContentsMargins(0,0,8,0); m_pNameLabel-&gt;setAlignment(Qt::AlignRight); pGLayout-&gt;addWidget(m_pNameLabel, 0,1, 1,1); pGLayout-&gt;addWidget(m_pIconLabel, 0, 2, 2,1, Qt::AlignTop); pGLayout-&gt;addItem(pSpacer, 1, 0, 1, 1); pGLayout-&gt;addWidget(m_pBubble, 1,1, 1,1); pGLayout-&gt;setColumnStretch(0, 2); pGLayout-&gt;setColumnStretch(1, 3); &#125;else&#123; m_pNameLabel-&gt;setContentsMargins(8,0,0,0); m_pNameLabel-&gt;setAlignment(Qt::AlignLeft); pGLayout-&gt;addWidget(m_pIconLabel, 0, 0, 2,1, Qt::AlignTop); pGLayout-&gt;addWidget(m_pNameLabel, 0,1, 1,1); pGLayout-&gt;addWidget(m_pBubble, 1,1, 1,1); pGLayout-&gt;addItem(pSpacer, 2, 2, 1, 1); pGLayout-&gt;setColumnStretch(1, 3); pGLayout-&gt;setColumnStretch(2, 2); &#125; this-&gt;setLayout(pGLayout);&#125; 设置用户名和头像 123456789void ChatItemBase::setUserName(const QString &amp;name)&#123; m_pNameLabel-&gt;setText(name);&#125;void ChatItemBase::setUserIcon(const QPixmap &amp;icon)&#123; m_pIconLabel-&gt;setPixmap(icon);&#125; 因为我们还要定制化实现气泡widget，所以要写个函数更新这个widget 1234567void ChatItemBase::setWidget(QWidget *w)&#123; QGridLayout *pGLayout = (qobject_cast&lt;QGridLayout *&gt;)(this-&gt;layout()); pGLayout-&gt;replaceWidget(m_pBubble, w); delete m_pBubble; m_pBubble = w;&#125; 聊天气泡我们的消息分为几种，文件，文本，图片等。所以先实现BubbleFrame作为基类 123456789101112131415class BubbleFrame : public QFrame&#123; Q_OBJECTpublic: BubbleFrame(ChatRole role, QWidget *parent = nullptr); void setMargin(int margin); //inline int margin()&#123;return margin;&#125; void setWidget(QWidget *w);protected: void paintEvent(QPaintEvent *e);private: QHBoxLayout *m_pHLayout; ChatRole m_role; int m_margin;&#125;; BubbleFrame基类构造函数创建一个布局，要根据是自己发送的消息还是别人发送的，做margin分布 1234567891011121314const int WIDTH_SANJIAO = 8; //三角宽BubbleFrame::BubbleFrame(ChatRole role, QWidget *parent) :QFrame(parent) ,m_role(role) ,m_margin(3)&#123; m_pHLayout = new QHBoxLayout(); if(m_role == ChatRole::Self) m_pHLayout-&gt;setContentsMargins(m_margin, m_margin, WIDTH_SANJIAO + m_margin, m_margin); else m_pHLayout-&gt;setContentsMargins(WIDTH_SANJIAO + m_margin, m_margin, m_margin, m_margin); this-&gt;setLayout(m_pHLayout);&#125; 将气泡框内设置文本内容，或者图片内容，所以实现了下面的函数 12345678void BubbleFrame::setWidget(QWidget *w)&#123; if(m_pHLayout-&gt;count() &gt; 0) return ; else&#123; m_pHLayout-&gt;addWidget(w); &#125;&#125; 接下来绘制气泡 123456789101112131415161718192021222324252627282930313233343536373839void BubbleFrame::paintEvent(QPaintEvent *e)&#123; QPainter painter(this); painter.setPen(Qt::NoPen); if(m_role == ChatRole::Other) &#123; //画气泡 QColor bk_color(Qt::white); painter.setBrush(QBrush(bk_color)); QRect bk_rect = QRect(WIDTH_SANJIAO, 0, this-&gt;width()-WIDTH_SANJIAO, this-&gt;height()); painter.drawRoundedRect(bk_rect,5,5); //画小三角 QPointF points[3] = &#123; QPointF(bk_rect.x(), 12), QPointF(bk_rect.x(), 10+WIDTH_SANJIAO +2), QPointF(bk_rect.x()-WIDTH_SANJIAO, 10+WIDTH_SANJIAO-WIDTH_SANJIAO/2), &#125;; painter.drawPolygon(points, 3); &#125; else &#123; QColor bk_color(158,234,106); painter.setBrush(QBrush(bk_color)); //画气泡 QRect bk_rect = QRect(0, 0, this-&gt;width()-WIDTH_SANJIAO, this-&gt;height()); painter.drawRoundedRect(bk_rect,5,5); //画三角 QPointF points[3] = &#123; QPointF(bk_rect.x()+bk_rect.width(), 12), QPointF(bk_rect.x()+bk_rect.width(), 12+WIDTH_SANJIAO +2), QPointF(bk_rect.x()+bk_rect.width()+WIDTH_SANJIAO, 10+WIDTH_SANJIAO-WIDTH_SANJIAO/2), &#125;; painter.drawPolygon(points, 3); &#125; return QFrame::paintEvent(e);&#125; 绘制的过程很简单，先创建QPainter，然后设置NoPen,表示不绘制轮廓线，接下来用设置指定颜色的画刷绘制图形，我们先绘制矩形再绘制三角形。 对于文本消息的绘制 123456789101112131415TextBubble::TextBubble(ChatRole role, const QString &amp;text, QWidget *parent) :BubbleFrame(role, parent)&#123; m_pTextEdit = new QTextEdit(); m_pTextEdit-&gt;setReadOnly(true); m_pTextEdit-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); m_pTextEdit-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); m_pTextEdit-&gt;installEventFilter(this); QFont font(&quot;Microsoft YaHei&quot;); font.setPointSize(12); m_pTextEdit-&gt;setFont(font); setPlainText(text); setWidget(m_pTextEdit); initStyleSheet();&#125; setPlainText设置文本最大宽度 1234567891011121314151617181920void TextBubble::setPlainText(const QString &amp;text)&#123; m_pTextEdit-&gt;setPlainText(text); //m_pTextEdit-&gt;setHtml(text); //找到段落中最大宽度 qreal doc_margin = m_pTextEdit-&gt;document()-&gt;documentMargin(); int margin_left = this-&gt;layout()-&gt;contentsMargins().left(); int margin_right = this-&gt;layout()-&gt;contentsMargins().right(); QFontMetricsF fm(m_pTextEdit-&gt;font()); QTextDocument *doc = m_pTextEdit-&gt;document(); int max_width = 0; //遍历每一段找到 最宽的那一段 for (QTextBlock it = doc-&gt;begin(); it != doc-&gt;end(); it = it.next()) //字体总长 &#123; int txtW = int(fm.width(it.text())); max_width = max_width &lt; txtW ? txtW : max_width; //找到最长的那段 &#125; //设置这个气泡的最大宽度 只需要设置一次 setMaximumWidth(max_width + doc_margin * 2 + (margin_left + margin_right)); //设置最大宽度&#125; 我们拉伸的时候要调整气泡的高度,这里重写事件过滤器 12345678bool TextBubble::eventFilter(QObject *o, QEvent *e)&#123; if(m_pTextEdit == o &amp;&amp; e-&gt;type() == QEvent::Paint) &#123; adjustTextHeight(); //PaintEvent中设置 &#125; return BubbleFrame::eventFilter(o, e);&#125; 调整高度 12345678910111213141516void TextBubble::adjustTextHeight()&#123; qreal doc_margin = m_pTextEdit-&gt;document()-&gt;documentMargin(); //字体到边框的距离默认为4 QTextDocument *doc = m_pTextEdit-&gt;document(); qreal text_height = 0; //把每一段的高度相加=文本高 for (QTextBlock it = doc-&gt;begin(); it != doc-&gt;end(); it = it.next()) &#123; QTextLayout *pLayout = it.layout(); QRectF text_rect = pLayout-&gt;boundingRect(); //这段的rect text_height += text_rect.height(); &#125; int vMargin = this-&gt;layout()-&gt;contentsMargins().top(); //设置这个气泡需要的高度 文本高+文本边距+TextEdit边框到气泡边框的距离 setFixedHeight(text_height + doc_margin *2 + vMargin*2 );&#125; 设置样式表 1234void TextBubble::initStyleSheet()&#123; m_pTextEdit-&gt;setStyleSheet(&quot;QTextEdit&#123;background:transparent;border:none&#125;&quot;);&#125; 对于图像的旗袍对话框类似，只是计算图像的宽高即可 1234567891011121314151617#define PIC_MAX_WIDTH 160#define PIC_MAX_HEIGHT 90PictureBubble::PictureBubble(const QPixmap &amp;picture, ChatRole role, QWidget *parent) :BubbleFrame(role, parent)&#123; QLabel *lb = new QLabel(); lb-&gt;setScaledContents(true); QPixmap pix = picture.scaled(QSize(PIC_MAX_WIDTH, PIC_MAX_HEIGHT), Qt::KeepAspectRatio); lb-&gt;setPixmap(pix); this-&gt;setWidget(lb); int left_margin = this-&gt;layout()-&gt;contentsMargins().left(); int right_margin = this-&gt;layout()-&gt;contentsMargins().right(); int v_margin = this-&gt;layout()-&gt;contentsMargins().bottom(); setFixedSize(pix.width()+left_margin + right_margin, pix.height() + v_margin *2);&#125; 发送测试接下来在发送处实现文本和图片消息的展示，点击发送按钮根据不同的类型创建不同的气泡消息 12345678910111213141516171819202122232425262728293031323334void ChatPage::on_send_btn_clicked()&#123; auto pTextEdit = ui-&gt;chatEdit; ChatRole role = ChatRole::Self; QString userName = QStringLiteral(&quot;恋恋风辰&quot;); QString userIcon = &quot;:/res/head_1.jpg&quot;; const QVector&lt;MsgInfo&gt;&amp; msgList = pTextEdit-&gt;getMsgList(); for(int i=0; i&lt;msgList.size(); ++i) &#123; QString type = msgList[i].msgFlag; ChatItemBase *pChatItem = new ChatItemBase(role); pChatItem-&gt;setUserName(userName); pChatItem-&gt;setUserIcon(QPixmap(userIcon)); QWidget *pBubble = nullptr; if(type == &quot;text&quot;) &#123; pBubble = new TextBubble(role, msgList[i].content); &#125; else if(type == &quot;image&quot;) &#123; pBubble = new PictureBubble(QPixmap(msgList[i].content) , role); &#125; else if(type == &quot;file&quot;) &#123; &#125; if(pBubble != nullptr) &#123; pChatItem-&gt;setWidget(pBubble); ui-&gt;chat_data_list-&gt;appendChatItem(pChatItem); &#125; &#125;&#125; 效果展示 源码和视频https://www.bilibili.com/video/BV1Mz4218783/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接https://gitee.com/secondtonone1/llfcchat","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(23) 侧边栏切换和搜索列表","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro23/","text":"侧边栏按钮我们接下来实现侧边栏按钮功能，希望点击一个按钮，清空其他按钮的选中状态。而我们又希望按钮上面能在有新的通知的时候出现红点的图标，所以不能用简单的按钮，要用自定义的一个widget实现点击效果 我们自定义StateWidget ，声明如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344class StateWidget : public QWidget&#123; Q_OBJECTpublic: explicit StateWidget(QWidget *parent = nullptr); void SetState(QString normal=&quot;&quot;, QString hover=&quot;&quot;, QString press=&quot;&quot;, QString select=&quot;&quot;, QString select_hover=&quot;&quot;, QString select_press=&quot;&quot;); ClickLbState GetCurState(); void ClearState(); void SetSelected(bool bselected); void AddRedPoint(); void ShowRedPoint(bool show=true);protected: void paintEvent(QPaintEvent* event); virtual void mousePressEvent(QMouseEvent *ev) override; virtual void mouseReleaseEvent(QMouseEvent *ev) override; virtual void enterEvent(QEvent* event) override; virtual void leaveEvent(QEvent* event) override;private: QString _normal; QString _normal_hover; QString _normal_press; QString _selected; QString _selected_hover; QString _selected_press; ClickLbState _curstate; QLabel * _red_point;signals: void clicked(void);signals:public slots:&#125;; 接下来实现定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163StateWidget::StateWidget(QWidget *parent): QWidget(parent),_curstate(ClickLbState::Normal)&#123; setCursor(Qt::PointingHandCursor); //添加红点 AddRedPoint();&#125;void StateWidget::SetState(QString normal, QString hover, QString press, QString select, QString select_hover, QString select_press)&#123; _normal = normal; _normal_hover = hover; _normal_press = press; _selected = select; _selected_hover = select_hover; _selected_press = select_press; setProperty(&quot;state&quot;,normal); repolish(this);&#125;ClickLbState StateWidget::GetCurState()&#123; return _curstate;&#125;void StateWidget::ClearState()&#123; _curstate = ClickLbState::Normal; setProperty(&quot;state&quot;,_normal); repolish(this); update();&#125;void StateWidget::SetSelected(bool bselected)&#123; if(bselected)&#123; _curstate = ClickLbState::Selected; setProperty(&quot;state&quot;,_selected); repolish(this); update(); return; &#125; _curstate = ClickLbState::Normal; setProperty(&quot;state&quot;,_normal); repolish(this); update(); return;&#125;void StateWidget::AddRedPoint()&#123; //添加红点示意图 _red_point = new QLabel(); _red_point-&gt;setObjectName(&quot;red_point&quot;); QVBoxLayout* layout2 = new QVBoxLayout; _red_point-&gt;setAlignment(Qt::AlignCenter); layout2-&gt;addWidget(_red_point); layout2-&gt;setMargin(0); this-&gt;setLayout(layout2); _red_point-&gt;setVisible(false);&#125;void StateWidget::ShowRedPoint(bool show)&#123; _red_point-&gt;setVisible(true);&#125;void StateWidget::paintEvent(QPaintEvent *event)&#123; QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this); return;&#125;void StateWidget::mousePressEvent(QMouseEvent *event)&#123; if (event-&gt;button() == Qt::LeftButton) &#123; if(_curstate == ClickLbState::Selected)&#123; qDebug()&lt;&lt;&quot;PressEvent , already to selected press: &quot;&lt;&lt; _selected_press; //emit clicked(); // 调用基类的mousePressEvent以保证正常的事件处理 QWidget::mousePressEvent(event); return; &#125; if(_curstate == ClickLbState::Normal)&#123; qDebug()&lt;&lt;&quot;PressEvent , change to selected press: &quot;&lt;&lt; _selected_press; _curstate = ClickLbState::Selected; setProperty(&quot;state&quot;,_selected_press); repolish(this); update(); &#125; return; &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QWidget::mousePressEvent(event);&#125;void StateWidget::mouseReleaseEvent(QMouseEvent *event)&#123; if (event-&gt;button() == Qt::LeftButton) &#123; if(_curstate == ClickLbState::Normal)&#123; //qDebug()&lt;&lt;&quot;ReleaseEvent , change to normal hover: &quot;&lt;&lt; _normal_hover; setProperty(&quot;state&quot;,_normal_hover); repolish(this); update(); &#125;else&#123; //qDebug()&lt;&lt;&quot;ReleaseEvent , change to select hover: &quot;&lt;&lt; _selected_hover; setProperty(&quot;state&quot;,_selected_hover); repolish(this); update(); &#125; emit clicked(); return; &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QWidget::mousePressEvent(event);&#125;void StateWidget::enterEvent(QEvent *event)&#123; // 在这里处理鼠标悬停进入的逻辑 if(_curstate == ClickLbState::Normal)&#123; //qDebug()&lt;&lt;&quot;enter , change to normal hover: &quot;&lt;&lt; _normal_hover; setProperty(&quot;state&quot;,_normal_hover); repolish(this); update(); &#125;else&#123; //qDebug()&lt;&lt;&quot;enter , change to selected hover: &quot;&lt;&lt; _selected_hover; setProperty(&quot;state&quot;,_selected_hover); repolish(this); update(); &#125; QWidget::enterEvent(event);&#125;void StateWidget::leaveEvent(QEvent *event)&#123; // 在这里处理鼠标悬停离开的逻辑 if(_curstate == ClickLbState::Normal)&#123; // qDebug()&lt;&lt;&quot;leave , change to normal : &quot;&lt;&lt; _normal; setProperty(&quot;state&quot;,_normal); repolish(this); update(); &#125;else&#123; // qDebug()&lt;&lt;&quot;leave , change to select normal : &quot;&lt;&lt; _selected; setProperty(&quot;state&quot;,_selected); repolish(this); update(); &#125; QWidget::leaveEvent(event);&#125; 为了让按钮好看一点，我们修改下qss文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#chat_user_name &#123; color:rgb(153,153,153); font-size: 14px; font-family: &quot;Microsoft YaHei&quot;;&#125;#side_chat_lb[state=&#x27;normal&#x27;]&#123; border-image: url(:/res/chat_icon.png);&#125;#side_chat_lb[state=&#x27;hover&#x27;]&#123; border-image: url(:/res/chat_icon_hover.png);&#125;#side_chat_lb[state=&#x27;pressed&#x27;]&#123; border-image: url(:/res/chat_icon_press.png);&#125;#side_chat_lb[state=&#x27;selected_normal&#x27;]&#123; border-image: url(:/res/chat_icon_press.png);&#125;#side_chat_lb[state=&#x27;selected_hover&#x27;]&#123; border-image: url(:/res/chat_icon_press.png);&#125;#side_chat_lb[state=&#x27;selected_pressed&#x27;]&#123; border-image: url(:/res/chat_icon_press.png);&#125;#side_contact_lb[state=&#x27;normal&#x27;]&#123; border-image: url(:/res/contact_list.png);&#125;#side_contact_lb[state=&#x27;hover&#x27;]&#123; border-image: url(:/res/contact_list_hover.png);&#125;#side_contact_lb[state=&#x27;pressed&#x27;]&#123; border-image: url(:/res/contact_list_press.png);&#125;#side_contact_lb[state=&#x27;selected_normal&#x27;]&#123; border-image: url(:/res/contact_list_press.png);&#125;#side_contact_lb[state=&#x27;selected_hover&#x27;]&#123; border-image: url(:/res/contact_list_press.png);&#125;#side_contact_lb[state=&#x27;selected_pressed&#x27;]&#123; border-image: url(:/res/contact_list_press.png);&#125; 回到ChatDialog.ui中，将side_chat_lb改为StateWidget，side_contact_lb改为StateWidget。 接下来回到ChatDialog.cpp中构造函数中添加 1234567891011121314151617QPixmap pixmap(&quot;:/res/head_1.jpg&quot;); ui-&gt;side_head_lb-&gt;setPixmap(pixmap); // 将图片设置到QLabel上 QPixmap scaledPixmap = pixmap.scaled( ui-&gt;side_head_lb-&gt;size(), Qt::KeepAspectRatio); // 将图片缩放到label的大小 ui-&gt;side_head_lb-&gt;setPixmap(scaledPixmap); // 将缩放后的图片设置到QLabel上 ui-&gt;side_head_lb-&gt;setScaledContents(true); // 设置QLabel自动缩放图片内容以适应大小 ui-&gt;side_chat_lb-&gt;setProperty(&quot;state&quot;,&quot;normal&quot;); ui-&gt;side_chat_lb-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;pressed&quot;,&quot;selected_normal&quot;,&quot;selected_hover&quot;,&quot;selected_pressed&quot;); ui-&gt;side_contact_lb-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;pressed&quot;,&quot;selected_normal&quot;,&quot;selected_hover&quot;,&quot;selected_pressed&quot;); AddLBGroup(ui-&gt;side_chat_lb); AddLBGroup(ui-&gt;side_contact_lb); connect(ui-&gt;side_chat_lb, &amp;StateWidget::clicked, this, &amp;ChatDialog::slot_side_chat); connect(ui-&gt;side_contact_lb, &amp;StateWidget::clicked, this, &amp;ChatDialog::slot_side_contact); 切换函数中实现如下 12345678void ChatDialog::slot_side_chat()&#123; qDebug()&lt;&lt; &quot;receive side chat clicked&quot;; ClearLabelState(ui-&gt;side_chat_lb); ui-&gt;stackedWidget-&gt;setCurrentWidget(ui-&gt;chat_page); _state = ChatUIMode::ChatMode; ShowSearch(false);&#125; 上述函数我们实现了清楚其他标签选中状态，只将被点击的标签设置为选中的效果,核心功能是下面 12345678910void ChatDialog::ClearLabelState(StateWidget *lb)&#123; for(auto &amp; ele: _lb_list)&#123; if(ele == lb)&#123; continue; &#125; ele-&gt;ClearState(); &#125;&#125; 我们在构造函数里将要管理的标签通过AddGroup函数加入_lb_list实现管理 1234void ChatDialog::AddLBGroup(StateWidget *lb)&#123; _lb_list.push_back(lb);&#125; 搜索列表类在pro中添加我们自定义一个搜索列表类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class SearchList: public QListWidget&#123; Q_OBJECTpublic: SearchList(QWidget *parent = nullptr); void CloseFindDlg(); void SetSearchEdit(QWidget* edit);protected: bool eventFilter(QObject *watched, QEvent *event) override &#123; // 检查事件是否是鼠标悬浮进入或离开 if (watched == this-&gt;viewport()) &#123; if (event-&gt;type() == QEvent::Enter) &#123; // 鼠标悬浮，显示滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); &#125; else if (event-&gt;type() == QEvent::Leave) &#123; // 鼠标离开，隐藏滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); &#125; &#125; // 检查事件是否是鼠标滚轮事件 if (watched == this-&gt;viewport() &amp;&amp; event-&gt;type() == QEvent::Wheel) &#123; QWheelEvent *wheelEvent = static_cast&lt;QWheelEvent*&gt;(event); int numDegrees = wheelEvent-&gt;angleDelta().y() / 8; int numSteps = numDegrees / 15; // 计算滚动步数 // 设置滚动幅度 this-&gt;verticalScrollBar()-&gt;setValue(this-&gt;verticalScrollBar()-&gt;value() - numSteps); return true; // 停止事件传递 &#125; return QListWidget::eventFilter(watched, event); &#125;private: void waitPending(bool pending = true); bool _send_pending; void addTipItem(); std::shared_ptr&lt;QDialog&gt; _find_dlg; QWidget* _search_edit; LoadingDlg * _loadingDialog;private slots: void slot_item_clicked(QListWidgetItem *item); void slot_user_search(std::shared_ptr&lt;SearchInfo&gt; si);signals:&#125;; 然后在构造函数中初始化条目列表 1234567891011121314SearchList::SearchList(QWidget *parent):QListWidget(parent),_find_dlg(nullptr), _search_edit(nullptr), _send_pending(false)&#123; Q_UNUSED(parent); this-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); // 安装事件过滤器 this-&gt;viewport()-&gt;installEventFilter(this); //连接点击的信号和槽 connect(this, &amp;QListWidget::itemClicked, this, &amp;SearchList::slot_item_clicked); //添加条目 addTipItem(); //连接搜索条目 connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_user_search, this, &amp;SearchList::slot_user_search);&#125; addTipItem是用来添加一个一个条目的 12345678910111213141516171819void SearchList::addTipItem()&#123; auto *invalid_item = new QWidget(); QListWidgetItem *item_tmp = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item_tmp-&gt;setSizeHint(QSize(250,10)); this-&gt;addItem(item_tmp); invalid_item-&gt;setObjectName(&quot;invalid_item&quot;); this-&gt;setItemWidget(item_tmp, invalid_item); item_tmp-&gt;setFlags(item_tmp-&gt;flags() &amp; ~Qt::ItemIsSelectable); auto *add_user_item = new AddUserItem(); QListWidgetItem *item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(add_user_item-&gt;sizeHint()); this-&gt;addItem(item); this-&gt;setItemWidget(item, add_user_item);&#125; sig_user_search可以先在TcpMgr中声明信号 1void sig_user_search(std::shared_ptr&lt;SearchInfo&gt;); SearchInfo定义在userdata.h中 123456789class SearchInfo &#123;public: SearchInfo(int uid, QString name, QString nick, QString desc, int sex); int _uid; QString _name; QString _nick; QString _desc; int _sex;&#125;; 接下来实现我们自定义的AddUserItem, 在pro中添加qt设计师界面类AddUserItem 123456789101112131415class AddUserItem : public ListItemBase&#123; Q_OBJECTpublic: explicit AddUserItem(QWidget *parent = nullptr); ~AddUserItem(); QSize sizeHint() const override &#123; return QSize(250, 70); // 返回自定义的尺寸 &#125;protected:private: Ui::AddUserItem *ui;&#125;; 实现 123456789101112AddUserItem::AddUserItem(QWidget *parent) : ListItemBase(parent), ui(new Ui::AddUserItem)&#123; ui-&gt;setupUi(this); SetItemType(ListItemType::ADD_USER_TIP_ITEM);&#125;AddUserItem::~AddUserItem()&#123; delete ui;&#125; 我们将ChatDialog.ui中将search_list升级为SearchList类型 美化界面我们用qss美化界面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#search_edit &#123; border: 2px solid #f1f1f1;&#125;/* 搜索框列表*/#search_list &#123; background-color: rgb(247,247,248); border: none;&#125;#search_list::item:selected &#123; background-color: #d3d7d4; border: none; outline: none;&#125;#search_list::item:hover &#123; background-color: rgb(206,207,208); border: none; outline: none;&#125;#search_list::focus &#123; border: none; outline: none;&#125;#invalid_item &#123; background-color: #eaeaea; border: none;&#125;#add_tip &#123; border-image: url(:/res/addtip.png);&#125;#right_tip&#123; border-image: url(:/res/right_tip.png);&#125;#message_tip&#123; text-align: center; font-family: &quot;Microsoft YaHei&quot;; font-size: 12pt;&#125; 我们在ChatDialog的构造函数中添加 12//链接搜索框输入变化 connect(ui-&gt;search_edit, &amp;QLineEdit::textChanged, this, &amp;ChatDialog::slot_text_changed); slot_text_changed槽函数中实现 1234567void ChatDialog::slot_text_changed(const QString &amp;str)&#123; //qDebug()&lt;&lt; &quot;receive slot text changed str is &quot; &lt;&lt; str; if (!str.isEmpty()) &#123; ShowSearch(true); &#125;&#125; 源码和视频再次启动后在输入框输入文字，就会显示搜索框 视频https://www.bilibili.com/video/BV1uM4m1U7MP/?spm_id_from=333.999.0.0&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接https://gitee.com/secondtonone1/llfcchat","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(24) EventFilter实现搜索隐藏","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro24/","text":"事件过滤器我们为了实现点击界面某个位置判断是否隐藏搜索框的功能。我们期待当鼠标点击搜索列表之外的区域时显示隐藏搜索框恢复聊天界面。点击搜索列表则不隐藏搜索框。可以通过重载ChatDialog的EventFilter函数实现点击功能 12345678bool ChatDialog::eventFilter(QObject *watched, QEvent *event)&#123; if (event-&gt;type() == QEvent::MouseButtonPress) &#123; QMouseEvent *mouseEvent = static_cast&lt;QMouseEvent*&gt;(event); handleGlobalMousePress(mouseEvent); &#125; return QDialog::eventFilter(watched, event);&#125; 具体判断全局鼠标按下位置和功能 1234567891011121314151617void ChatDialog::handleGlobalMousePress(QMouseEvent *event)&#123; // 实现点击位置的判断和处理逻辑 // 先判断是否处于搜索模式，如果不处于搜索模式则直接返回 if( _mode != ChatUIMode::SearchMode)&#123; return; &#125; // 将鼠标点击位置转换为搜索列表坐标系中的位置 QPoint posInSearchList = ui-&gt;search_list-&gt;mapFromGlobal(event-&gt;globalPos()); // 判断点击位置是否在聊天列表的范围内 if (!ui-&gt;search_list-&gt;rect().contains(posInSearchList)) &#123; // 如果不在聊天列表内，清空输入框 ui-&gt;search_edit-&gt;clear(); ShowSearch(false); &#125;&#125; 在ChatDialog构造函数中添加事件过滤器 12345//检测鼠标点击位置判断是否要清空搜索框this-&gt;installEventFilter(this); // 安装事件过滤器//设置聊天label选中状态ui-&gt;side_chat_lb-&gt;SetSelected(true); 这样就可以实现在ChatDialog中点击其他位置隐藏SearchList列表了。 查找结果在项目中添加FindSuccessDlg设计师界面类，其布局如下 属性管理界面如下 FindSuccessDlg声明如下 12345678910111213141516class FindSuccessDlg : public QDialog&#123; Q_OBJECTpublic: explicit FindSuccessDlg(QWidget *parent = nullptr); ~FindSuccessDlg(); void SetSearchInfo(std::shared_ptr&lt;SearchInfo&gt; si);private slots: void on_add_friend_btn_clicked();private: Ui::FindSuccessDlg *ui; QWidget * _parent; std::shared_ptr&lt;SearchInfo&gt; _si;&#125;; FindSuccessDlg实现如下 12345678910111213141516171819202122232425262728293031323334353637FindSuccessDlg::FindSuccessDlg(QWidget *parent) : QDialog(parent), ui(new Ui::FindSuccessDlg)&#123; ui-&gt;setupUi(this); // 设置对话框标题 setWindowTitle(&quot;添加&quot;); // 隐藏对话框标题栏 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); // 获取当前应用程序的路径 QString app_path = QCoreApplication::applicationDirPath(); QString pix_path = QDir::toNativeSeparators(app_path + QDir::separator() + &quot;static&quot;+QDir::separator()+&quot;head_1.jpg&quot;); QPixmap head_pix(pix_path); head_pix = head_pix.scaled(ui-&gt;head_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation); ui-&gt;head_lb-&gt;setPixmap(head_pix); ui-&gt;add_friend_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); this-&gt;setModal(true);&#125;FindSuccessDlg::~FindSuccessDlg()&#123; qDebug()&lt;&lt;&quot;FindSuccessDlg destruct&quot;; delete ui;&#125;void FindSuccessDlg::SetSearchInfo(std::shared_ptr&lt;SearchInfo&gt; si)&#123; ui-&gt;name_lb-&gt;setText(si-&gt;_name); _si = si;&#125;void FindSuccessDlg::on_add_friend_btn_clicked()&#123; //todo... 添加好友界面弹出&#125; 在SearchList 的slot_item_clicked函数中添加点击条目处理逻辑 1234567891011121314151617181920212223242526272829303132333435void SearchList::slot_item_clicked(QListWidgetItem *item)&#123; QWidget *widget = this-&gt;itemWidget(item); //获取自定义widget对象 if(!widget)&#123; qDebug()&lt;&lt; &quot;slot item clicked widget is nullptr&quot;; return; &#125; // 对自定义widget进行操作， 将item 转化为基类ListItemBase ListItemBase *customItem = qobject_cast&lt;ListItemBase*&gt;(widget); if(!customItem)&#123; qDebug()&lt;&lt; &quot;slot item clicked widget is nullptr&quot;; return; &#125; auto itemType = customItem-&gt;GetItemType(); if(itemType == ListItemType::INVALID_ITEM)&#123; qDebug()&lt;&lt; &quot;slot invalid item clicked &quot;; return; &#125; if(itemType == ListItemType::ADD_USER_TIP_ITEM)&#123; //todo ... _find_dlg = std::make_shared&lt;FindSuccessDlg&gt;(this); auto si = std::make_shared&lt;SearchInfo&gt;(0,&quot;llfc&quot;,&quot;llfc&quot;,&quot;hello , my friend!&quot;,0); (std::dynamic_pointer_cast&lt;FindSuccessDlg&gt;(_find_dlg))-&gt;SetSearchInfo(si); _find_dlg-&gt;show(); return; &#125; //清楚弹出框 CloseFindDlg();&#125; 这样我们在输入框输入文字，点击搜索列表中搜索添加好友的item，就能弹出搜索结果对话框了。这里只做界面演示，之后会改为像服务器发送请求获取搜索结果。 pro的改写我们对项目的pro做了调整，更新了static文件夹的拷贝以及编码utf-8的设定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143QT += core gui networkgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = llfcchatTEMPLATE = appRC_ICONS = icon.icoDESTDIR = ./binDEFINES += QT_DEPRECATED_WARNINGSCONFIG += c++11SOURCES += \\ adduseritem.cpp \\ bubbleframe.cpp \\ chatdialog.cpp \\ chatitembase.cpp \\ chatpage.cpp \\ chatuserlist.cpp \\ chatuserwid.cpp \\ chatview.cpp \\ clickedbtn.cpp \\ clickedlabel.cpp \\ customizeedit.cpp \\ findsuccessdlg.cpp \\ global.cpp \\ httpmgr.cpp \\ listitembase.cpp \\ loadingdlg.cpp \\ logindialog.cpp \\ main.cpp \\ mainwindow.cpp \\ messagetextedit.cpp \\ picturebubble.cpp \\ registerdialog.cpp \\ resetdialog.cpp \\ searchlist.cpp \\ statewidget.cpp \\ tcpmgr.cpp \\ textbubble.cpp \\ timerbtn.cpp \\ userdata.cpp \\ usermgr.cppHEADERS += \\ adduseritem.h \\ bubbleframe.h \\ chatdialog.h \\ chatitembase.h \\ chatpage.h \\ chatuserlist.h \\ chatuserwid.h \\ chatview.h \\ clickedbtn.h \\ clickedlabel.h \\ customizeedit.h \\ findsuccessdlg.h \\ global.h \\ httpmgr.h \\ listitembase.h \\ loadingdlg.h \\ logindialog.h \\ mainwindow.h \\ messagetextedit.h \\ picturebubble.h \\ registerdialog.h \\ resetdialog.h \\ searchlist.h \\ singleton.h \\ statewidget.h \\ tcpmgr.h \\ textbubble.h \\ timerbtn.h \\ userdata.h \\ usermgr.hFORMS += \\ adduseritem.ui \\ chatdialog.ui \\ chatpage.ui \\ chatuserwid.ui \\ findsuccessdlg.ui \\ loadingdlg.ui \\ logindialog.ui \\ mainwindow.ui \\ registerdialog.ui \\ resetdialog.ui# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += targetRESOURCES += \\ rc.qrcDISTFILES += \\ config.iniCONFIG(debug, debug | release) &#123; #指定要拷贝的文件目录为工程目录下release目录下的所有dll、lib文件，例如工程目录在D:\\QT\\Test #PWD就为D:/QT/Test，DllFile = D:/QT/Test/release/*.dll TargetConfig = $$&#123;PWD&#125;/config.ini #将输入目录中的&quot;/&quot;替换为&quot;\\&quot; TargetConfig = $$replace(TargetConfig, /, \\\\) #将输出目录中的&quot;/&quot;替换为&quot;\\&quot; OutputDir = $$&#123;OUT_PWD&#125;/$$&#123;DESTDIR&#125; OutputDir = $$replace(OutputDir, /, \\\\) //执行copy命令 QMAKE_POST_LINK += copy /Y \\&quot;$$TargetConfig\\&quot; \\&quot;$$OutputDir\\&quot; &amp; # 首先，定义static文件夹的路径 StaticDir = $$&#123;PWD&#125;/static # 将路径中的&quot;/&quot;替换为&quot;\\&quot; StaticDir = $$replace(StaticDir, /, \\\\) #message($$&#123;StaticDir&#125;) # 使用xcopy命令拷贝文件夹，/E表示拷贝子目录及其内容，包括空目录。/I表示如果目标不存在则创建目录。/Y表示覆盖现有文件而不提示。 QMAKE_POST_LINK += xcopy /Y /E /I \\&quot;$$StaticDir\\&quot; \\&quot;$$OutputDir\\\\static\\\\\\&quot;&#125;else&#123; #release message(&quot;release mode&quot;) #指定要拷贝的文件目录为工程目录下release目录下的所有dll、lib文件，例如工程目录在D:\\QT\\Test #PWD就为D:/QT/Test，DllFile = D:/QT/Test/release/*.dll TargetConfig = $$&#123;PWD&#125;/config.ini #将输入目录中的&quot;/&quot;替换为&quot;\\&quot; TargetConfig = $$replace(TargetConfig, /, \\\\) #将输出目录中的&quot;/&quot;替换为&quot;\\&quot; OutputDir = $$&#123;OUT_PWD&#125;/$$&#123;DESTDIR&#125; OutputDir = $$replace(OutputDir, /, \\\\) //执行copy命令 QMAKE_POST_LINK += copy /Y \\&quot;$$TargetConfig\\&quot; \\&quot;$$OutputDir\\&quot; # 首先，定义static文件夹的路径 StaticDir = $$&#123;PWD&#125;/static # 将路径中的&quot;/&quot;替换为&quot;\\&quot; StaticDir = $$replace(StaticDir, /, \\\\) #message($$&#123;StaticDir&#125;) # 使用xcopy命令拷贝文件夹，/E表示拷贝子目录及其内容，包括空目录。/I表示如果目标不存在则创建目录。/Y表示覆盖现有文件而不提示。 QMAKE_POST_LINK += xcopy /Y /E /I \\&quot;$$StaticDir\\&quot; \\&quot;$$OutputDir\\\\static\\\\\\&quot;&#125;win32-msvc*:QMAKE_CXXFLAGS += /wd&quot;4819&quot; /utf-8 视频https://www.bilibili.com/video/BV1ww4m1e72G/ 源码链接https://gitee.com/secondtonone1/llfcchat","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(27) 分布式聊天服务设计","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro27/","text":"简介本文介绍如何将chatserver设置为分布式服务，并且实现statusserver的负载均衡处理，根据每个chatserver现有的连接数匹配最小的chatserver返回给GateServer并返回给客户端。 为了实现这一系列分布式设计，我们需要先完善chatserver，增加grpc客户端和服务端。这样能实现两个chatserver之间端对端的通信。 visual studio中右键chatserver项目选择添加新文件ChatGrpcClient, 会为我们生成ChatGrpcClient.h和ChatGrpcClient.cpp文件。 连接池客户端先实现ChatConPool连接池 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class ChatConPool &#123;public: ChatConPool(size_t poolSize, std::string host, std::string port): poolSize_(poolSize), host_(host),port_(port),b_stop_(false)&#123; for (size_t i = 0; i &lt; poolSize_; ++i) &#123; std::shared_ptr&lt;Channel&gt; channel = grpc::CreateChannel(host + &quot;:&quot; + port, grpc::InsecureChannelCredentials()); connections_.push(ChatService::NewStub(channel)); &#125; &#125; ~ChatConPool() &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); Close(); while (!connections_.empty()) &#123; connections_.pop(); &#125; &#125; std::unique_ptr&lt;ChatService::Stub&gt; getConnection() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); cond_.wait(lock, [this] &#123; if (b_stop_) &#123; return true; &#125; return !connections_.empty(); &#125;); //如果停止则直接返回空指针 if (b_stop_) &#123; return nullptr; &#125; auto context = std::move(connections_.front()); connections_.pop(); return context; &#125; void returnConnection(std::unique_ptr&lt;ChatService::Stub&gt; context) &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); if (b_stop_) &#123; return; &#125; connections_.push(std::move(context)); cond_.notify_one(); &#125; void Close() &#123; b_stop_ = true; cond_.notify_all(); &#125;private: atomic&lt;bool&gt; b_stop_; size_t poolSize_; std::string host_; std::string port_; std::queue&lt;std::unique_ptr&lt;ChatService::Stub&gt; &gt; connections_; std::mutex mutex_; std::condition_variable cond_;&#125;; 然后利用单例模式实现grpc通信的客户端 1234567891011121314151617class ChatGrpcClient: public Singleton&lt;ChatGrpcClient&gt;&#123; friend class Singleton&lt;ChatGrpcClient&gt;;public: ~ChatGrpcClient() &#123; &#125; AddFriendRsp NotifyAddFriend(std::string server_ip, const AddFriendReq&amp; req); AuthFriendRsp NotifyAuthFriend(std::string server_ip, const AuthFriendReq&amp; req); bool GetBaseInfo(std::string base_key, int uid, std::shared_ptr&lt;UserInfo&gt;&amp; userinfo); TextChatMsgRsp NotifyTextChatMsg(std::string server_ip, const TextChatMsgReq&amp; req, const Json::Value&amp; rtvalue);private: ChatGrpcClient(); unordered_map&lt;std::string, std::unique_ptr&lt;ChatConPool&gt;&gt; _pools;&#125;; 实现具体的ChatGrpcClient 12345678910111213141516171819202122232425262728293031323334353637383940414243ChatGrpcClient::ChatGrpcClient()&#123; auto&amp; cfg = ConfigMgr::Inst(); auto server_list = cfg[&quot;PeerServer&quot;][&quot;Servers&quot;]; std::vector&lt;std::string&gt; words; std::stringstream ss(server_list); std::string word; while (std::getline(ss, word, &#x27;,&#x27;)) &#123; words.push_back(word); &#125; for (auto&amp; word : words) &#123; if (cfg[word][&quot;Name&quot;].empty()) &#123; continue; &#125; _pools[cfg[word][&quot;Name&quot;]] = std::make_unique&lt;ChatConPool&gt;(5, cfg[word][&quot;Host&quot;], cfg[word][&quot;Port&quot;]); &#125;&#125;AddFriendRsp ChatGrpcClient::NotifyAddFriend(std::string server_ip, const AddFriendReq&amp; req) &#123; AddFriendRsp rsp; return rsp;&#125;AuthFriendRsp ChatGrpcClient::NotifyAuthFriend(std::string server_ip, const AuthFriendReq&amp; req) &#123; AuthFriendRsp rsp; return rsp;&#125;bool ChatGrpcClient::GetBaseInfo(std::string base_key, int uid, std::shared_ptr&lt;UserInfo&gt;&amp; userinfo) &#123; return true;&#125;TextChatMsgRsp ChatGrpcClient::NotifyTextChatMsg(std::string server_ip, const TextChatMsgReq&amp; req, const Json::Value&amp; rtvalue) &#123; TextChatMsgRsp rsp; return rsp;&#125; 连接池服务端向ChatServer中添加ChatServiceImpl类，自动生成头文件和源文件 1234567891011121314151617class ChatServiceImpl final : public ChatService::Service&#123;public: ChatServiceImpl(); Status NotifyAddFriend(ServerContext* context, const AddFriendReq* request, AddFriendRsp* reply) override; Status NotifyAuthFriend(ServerContext* context, const AuthFriendReq* request, AuthFriendRsp* response) override; Status NotifyTextChatMsg(::grpc::ServerContext* context, const TextChatMsgReq* request, TextChatMsgRsp* response) override; bool GetBaseInfo(std::string base_key, int uid, std::shared_ptr&lt;UserInfo&gt;&amp; userinfo);private:&#125;; 实现服务逻辑,先简单写成不处理直接返回。 1234567891011121314151617181920212223ChatServiceImpl::ChatServiceImpl()&#123;&#125;Status ChatServiceImpl::NotifyAddFriend(ServerContext* context, const AddFriendReq* request, AddFriendRsp* reply) &#123; return Status::OK;&#125;Status ChatServiceImpl::NotifyAuthFriend(ServerContext* context, const AuthFriendReq* request, AuthFriendRsp* response) &#123; return Status::OK;&#125;Status ChatServiceImpl::NotifyTextChatMsg(::grpc::ServerContext* context, const TextChatMsgReq* request, TextChatMsgRsp* response) &#123; return Status::OK;&#125;bool ChatServiceImpl::GetBaseInfo(std::string base_key, int uid, std::shared_ptr&lt;UserInfo&gt;&amp; userinfo) &#123; return true;&#125; 并且完善chatserver配置 1234567891011121314151617181920212223242526272829[GateServer]Port = 8080[VarifyServer]Host = 127.0.0.1Port = 50051[StatusServer]Host = 127.0.0.1Port = 50052[SelfServer]Name = chatserver1Host = 0.0.0.0Port = 8090RPCPort = 50055[Mysql]Host = 81.68.86.146Port = 3308User = rootPasswd = 123456.Schema = llfc[Redis]Host = 81.68.86.146Port = 6380Passwd = 123456[PeerServer]Servers = chatserver2[chatserver2]Name = chatserver2Host = 127.0.0.1Port = 50056 增加了PeerServer字段，存储对端server列表，通过逗号分隔，可以通过逗号切割对端服务器名字，再根据名字去配置里查找对应字段。 对应的chatserver复制一份，改名为chatserver2，然后修改config.ini配置。要和server1配置不同，实现端对端的配置。具体详见服务器代码。 服务器连接数管理每当服务器chatserver启动后，都要重新设置一下用户连接数管理,并且我们每个chatserver既要有tcp服务监听也要有grpc服务监听 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using namespace std;bool bstop = false;std::condition_variable cond_quit;std::mutex mutex_quit;int main()&#123; auto&amp; cfg = ConfigMgr::Inst(); auto server_name = cfg[&quot;SelfServer&quot;][&quot;Name&quot;]; try &#123; auto pool = AsioIOServicePool::GetInstance(); //将登录数设置为0 RedisMgr::GetInstance()-&gt;HSet(LOGIN_COUNT, server_name, &quot;0&quot;); //定义一个GrpcServer std::string server_address(cfg[&quot;SelfServer&quot;][&quot;Host&quot;] + &quot;:&quot; + cfg[&quot;SelfServer&quot;][&quot;RPCPort&quot;]); ChatServiceImpl service; grpc::ServerBuilder builder; // 监听端口和添加服务 builder.AddListeningPort(server_address, grpc::InsecureServerCredentials()); builder.RegisterService(&amp;service); // 构建并启动gRPC服务器 std::unique_ptr&lt;grpc::Server&gt; server(builder.BuildAndStart()); std::cout &lt;&lt; &quot;RPC Server listening on &quot; &lt;&lt; server_address &lt;&lt; std::endl; //单独启动一个线程处理grpc服务 std::thread grpc_server_thread([&amp;server]() &#123; server-&gt;Wait(); &#125;); boost::asio::io_context io_context; boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); signals.async_wait([&amp;io_context, pool, &amp;server](auto, auto) &#123; io_context.stop(); pool-&gt;Stop(); server-&gt;Shutdown(); &#125;); auto port_str = cfg[&quot;SelfServer&quot;][&quot;Port&quot;]; CServer s(io_context, atoi(port_str.c_str())); io_context.run(); RedisMgr::GetInstance()-&gt;HDel(LOGIN_COUNT, server_name); RedisMgr::GetInstance()-&gt;Close(); grpc_server_thread.join(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125; 我们在服务器启动后将本服务器的登录数量设置为0. 同样的道理，我们将服务器关闭后，也要删除对应key。 用户连接管理因为我们用户登录后，要将连接(session)和用户uid绑定。为以后登陆踢人做准备。所以新增UserMgr管理类. 其声明如下 123456789101112131415class CSession;class UserMgr : public Singleton&lt;UserMgr&gt;&#123; friend class Singleton&lt;UserMgr&gt;;public: ~UserMgr(); std::shared_ptr&lt;CSession&gt; GetSession(int uid); void SetUserSession(int uid, std::shared_ptr&lt;CSession&gt; session); void RmvUserSession(int uid);private: UserMgr(); std::mutex _session_mtx; std::unordered_map&lt;int, std::shared_ptr&lt;CSession&gt;&gt; _uid_to_session;&#125;; 其实现如下 12345678910111213141516171819202122232425262728293031323334353637383940UserMgr:: ~UserMgr() &#123; _uid_to_session.clear();&#125;std::shared_ptr&lt;CSession&gt; UserMgr::GetSession(int uid)&#123; std::lock_guard&lt;std::mutex&gt; lock(_session_mtx); auto iter = _uid_to_session.find(uid); if (iter == _uid_to_session.end()) &#123; return nullptr; &#125; return iter-&gt;second;&#125;void UserMgr::SetUserSession(int uid, std::shared_ptr&lt;CSession&gt; session)&#123; std::lock_guard&lt;std::mutex&gt; lock(_session_mtx); _uid_to_session[uid] = session;&#125;void UserMgr::RmvUserSession(int uid)&#123; auto uid_str = std::to_string(uid); //因为再次登录可能是其他服务器，所以会造成本服务器删除key，其他服务器注册key的情况 // 有可能其他服务登录，本服删除key造成找不到key的情况 //RedisMgr::GetInstance()-&gt;Del(USERIPPREFIX + uid_str); &#123; std::lock_guard&lt;std::mutex&gt; lock(_session_mtx); _uid_to_session.erase(uid); &#125;&#125;UserMgr::UserMgr()&#123;&#125; RmvUserSession 暂时屏蔽，以后做登录踢人后能保证有序移除用户ip操作。 当有连接异常时，可以调用移除用户Session的接口 12345678910111213void CServer::ClearSession(std::string session_id) &#123; if (_sessions.find(session_id) != _sessions.end()) &#123; //移除用户和session的关联 UserMgr::GetInstance()-&gt;RmvUserSession(_sessions[session_id]-&gt;GetUserId()); &#125; &#123; lock_guard&lt;mutex&gt; lock(_mutex); _sessions.erase(session_id); &#125;&#125; 聊天服务完善用户登录，当用户登录后, 设置其uid对应的serverip。以及更新其所在服务器的连接数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677void LogicSystem::LoginHandler(shared_ptr&lt;CSession&gt; session, const short &amp;msg_id, const string &amp;msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid = root[&quot;uid&quot;].asInt(); auto token = root[&quot;token&quot;].asString(); std::cout &lt;&lt; &quot;user login uid is &quot; &lt;&lt; uid &lt;&lt; &quot; user token is &quot; &lt;&lt; token &lt;&lt; endl; Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, MSG_CHAT_LOGIN_RSP); &#125;); //从redis获取用户token是否正确 std::string uid_str = std::to_string(uid); std::string token_key = USERTOKENPREFIX + uid_str; std::string token_value = &quot;&quot;; bool success = RedisMgr::GetInstance()-&gt;Get(token_key, token_value); if (!success) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; return; &#125; if (token_value != token) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::TokenInvalid; return; &#125; rtvalue[&quot;error&quot;] = ErrorCodes::Success; std::string base_key = USER_BASE_INFO + uid_str; auto user_info = std::make_shared&lt;UserInfo&gt;(); bool b_base = GetBaseInfo(base_key, uid, user_info); if (!b_base) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; return; &#125; rtvalue[&quot;uid&quot;] = uid; rtvalue[&quot;pwd&quot;] = user_info-&gt;pwd; rtvalue[&quot;name&quot;] = user_info-&gt;name; rtvalue[&quot;email&quot;] = user_info-&gt;email; rtvalue[&quot;nick&quot;] = user_info-&gt;nick; rtvalue[&quot;desc&quot;] = user_info-&gt;desc; rtvalue[&quot;sex&quot;] = user_info-&gt;sex; rtvalue[&quot;icon&quot;] = user_info-&gt;icon; //从数据库获取申请列表 //获取好友列表 auto server_name = ConfigMgr::Inst().GetValue(&quot;SelfServer&quot;, &quot;Name&quot;); //将登录数量增加 auto rd_res = RedisMgr::GetInstance()-&gt;HGet(LOGIN_COUNT, server_name); int count = 0; if (!rd_res.empty()) &#123; count = std::stoi(rd_res); &#125; count++; auto count_str = std::to_string(count); RedisMgr::GetInstance()-&gt;HSet(LOGIN_COUNT, server_name, count_str); //session绑定用户uid session-&gt;SetUserId(uid); //为用户设置登录ip server的名字 std::string ipkey = USERIPPREFIX + uid_str; RedisMgr::GetInstance()-&gt;Set(ipkey, server_name); //uid和session绑定管理,方便以后踢人操作 UserMgr::GetInstance()-&gt;SetUserSession(uid, session); return;&#125; 状态服务状态服务更新配置 1234567891011121314151617181920212223[StatusServer]Port = 50052Host = 0.0.0.0[Mysql]Host = 81.68.86.146Port = 3308User = rootPasswd = 123456.Schema = llfc[Redis]Host = 81.68.86.146Port = 6380Passwd = 123456[chatservers]Name = chatserver1,chatserver2[chatserver1]Name = chatserver1Host = 127.0.0.1Port = 8090[chatserver2]Name = chatserver2Host = 127.0.0.1Port = 8091 配置文件同样增加了chatservers列表，用来管理多个服务，接下来实现根据连接数动态返回chatserverip的功能 123456789101112Status StatusServiceImpl::GetChatServer(ServerContext* context, const GetChatServerReq* request, GetChatServerRsp* reply)&#123; std::string prefix(&quot;llfc status server has received : &quot;); const auto&amp; server = getChatServer(); reply-&gt;set_host(server.host); reply-&gt;set_port(server.port); reply-&gt;set_error(ErrorCodes::Success); reply-&gt;set_token(generate_unique_string()); insertToken(request-&gt;uid(), reply-&gt;token()); return Status::OK;&#125; getChatServer用来获取最小连接数的chatserver 名字 1234567891011121314151617181920212223242526272829303132333435ChatServer StatusServiceImpl::getChatServer() &#123; std::lock_guard&lt;std::mutex&gt; guard(_server_mtx); auto minServer = _servers.begin()-&gt;second; auto count_str = RedisMgr::GetInstance()-&gt;HGet(LOGIN_COUNT, minServer.name); if (count_str.empty()) &#123; //不存在则默认设置为最大 minServer.con_count = INT_MAX; &#125; else &#123; minServer.con_count = std::stoi(count_str); &#125; // 使用范围基于for循环 for (auto&amp; server : _servers) &#123; if (server.second.name == minServer.name) &#123; continue; &#125; auto count_str = RedisMgr::GetInstance()-&gt;HGet(LOGIN_COUNT, server.second.name); if (count_str.empty()) &#123; server.second.con_count = INT_MAX; &#125; else &#123; server.second.con_count = std::stoi(count_str); &#125; if (server.second.con_count &lt; minServer.con_count) &#123; minServer = server.second; &#125; &#125; return minServer;&#125; 测试分别启动两个chatserver，gateserver，以及statusserver，并且启动两个客户端登录， 分别查看登录信息，发现两个客户端被分配到不同的chatserver了，说明我们实现了负载均衡的分配方式。 源码连接https://gitee.com/secondtonone1/llfcchat 视频连接https://www.bilibili.com/video/BV17r421K7Px/?spm_id_from=333.999.0.0&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(3) CRTP实现Http管理者","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro3/","text":"GateServer网关服务器主要应答客户端基本的连接请求，包括根据服务器负载情况选择合适服务器给客户端登录，注册，获取验证服务等，接收http请求并应答。 boost库安装boost库的安装分为Windows和Linux两部分，Linux部分放在后面再讲解。因为Windows比较直观，便于我们编写代码，所以优先在windows平台搭建环境并编写代码，测试无误后再移植到linux。 boost官网地址： Boost库官网https://www.boost.org/，首先进入官网下载对应的Boost库文件。点击下图所示红框中Download进入下载页面。更多版本点击链接下载。 点击进入页面后，接下来选择7z或者zip文件都可以。 如果下载缓慢，大家可以去我的网盘下载链接：https://pan.baidu.com/s/1Uf-7gZxWpCOl7dnYzlYRHg?pwd=xt01 提取码：xt01 我的是boost_1_81_0版本，大家可以和我的版本匹配，也可以自己用最新版。 下载好后解压, 其中booststrap.bat点击后生成编译程序 点击后，生成b2.exe，我们执行如下命令 1.\\b2.exe install --toolset=msvc-14.2 --build-type=complete --prefix=&quot;D:\\cppsoft\\boost_1_81_0&quot; link=static runtime-link=shared threading=multi debug release 先逐一解释各参数含义 install可以更改为stage, stage表示只生成库(dll和lib), install还会生成包含头文件的include目录。一般来说用stage就可以了，我们将生成的lib和下载的源码包的include头文件夹放到项目要用的地方即可。 toolset 指定编译器，gcc用来编译生成linux用的库，msvc-14.2（VS2019）用来编译windows使用的库，版本号看你的编译器比如msvc-10.0（VS2010），我的是VS2019所以是msvc-14.2。 如果选择的是install 命令，指定生成的库文件夹要用--prefix，如果使用的是stage命令，需要用--stagedir指定。 link 表示生成动态库还是静态库，static表示生成lib库，shared表示生成dll库。 runtime-link 表示用于指定运行时链接方式为静态库还是动态库，指定为static就是MT模式，指定shared就是MD模式。MD 和 MT 是微软 Visual C++ 编译器的选项，用于指定运行时库的链接方式。这两个选项有以下区别： /MD：表示使用多线程 DLL（Dynamic Link Library）版本的运行时库。这意味着你的应用程序将使用动态链接的运行时库（MSVCRT.dll）。这样的设置可以减小最终可执行文件的大小，并且允许应用程序与其他使用相同运行时库版本的程序共享代码和数据。 /MT：表示使用多线程静态库（Static Library）版本的运行时库。这意味着所有的运行时函数将被静态链接到应用程序中，使得应用程序不再依赖于动态链接的运行时库。这样可以确保应用程序在没有额外依赖的情况下独立运行，但可能会导致最终可执行文件的体积增大。 执行上述命令后就会在指定目录生成lib库了，我们将lib库拷贝到要使用的地方即可。 一句话简化上面的含义，就是我们生成的是lib库，运行时采用的md加载模式。 下面是编译界面 编译后生成如下目录和文件, 我的是D盘 cppsoft目录下的boost文件夹，大家可以根据自己的设置去指定文件夹查看。 为了兼容我之前做的旧项目，我创建了一个stage文件夹，将lib文件夹和内容移动到stage中了。然后将include文件夹下的boost文件夹移出到boost_1_81_0目录下，整体看就就是如下 接下来我们创建项目并配置boost 配置boost打开visual studio 创建项目 接下来配置boost到项目中,右键项目选择属性，配置VC++包含目录，添加D:\\cppsoft\\boost_1_81_0（根据你自己的boost目录配置） 再配置VC++库目录, 添加D:\\cppsoft\\boost_1_81_0\\stage\\lib 写个代码测试一下 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;boost/lexical_cast.hpp&quot;int main()&#123; using namespace std; cout &lt;&lt; &quot;Enter your weight: &quot;; float weight; cin &gt;&gt; weight; string gain = &quot;A 10% increase raises &quot;; string wt = boost::lexical_cast&lt;string&gt; (weight); gain = gain + wt + &quot; to &quot;; // string operator() weight = 1.1 * weight; gain = gain + boost::lexical_cast&lt;string&gt;(weight) + &quot;.&quot;; cout &lt;&lt; gain &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 运行成功，可以看到弹出了窗口 配置jsoncpp因为要用到json解析，所以我们选择jsoncpp来做后端json解析工作 jsoncpp下载地址：https://github.com/open-source-parsers/jsoncpp官方文档：http://jsoncpp.sourceforge.net/old.html 选择windows版本的下载。 如果下载速度很慢，可以去我的网盘地址下载https://pan.baidu.com/s/1Yg9Usdc3T-CYhyr9GiePCw?pwd=ng6x 验证码ng6x下载后我们解压文件夹，解压后文件夹如下图 然后进行编译，编译需要进入makefile文件夹下 找到jsoncpp.sln文件，用visual studio打开，因为我的是visual studio2019版本，所以会提示我升级。 点击确定升级，之后我们选择编译lib_json即可，当然偷懒可以选择编译整个解决方案。 然后我们配置编译属性，我想要用x64位的，所以配置编译平台为X64位，编译模式为debug模式，大家最好把release版和debug版都编译一遍。 右键lib_json属性里选择C++，再选择代码生成，之后在右侧选择运行库，选择md(release版), mdd(debug版). 编译生成后，我们的json库生成在项目同级目录的x64文件夹下的debug目录下 接下来我们在D盘cppsoft新建一个文件夹libjson，然后在其内部分别建立include和lib文件夹 将jsoncpp-src-0.5.0源码文件夹下include文件夹里的内容copy到libjson下的include文件夹内。 将jsoncpp-src-0.5.0源码文件夹下x64位debug文件夹和Release文件夹下生成的库copy到libjson下的lib文件夹内。 我们生成的是mdd和md版本的库，但是名字却是mt，这个是visual studio生成的小bug先不管了。 接下来我们新建一个项目，在项目属性中配置jsoncpp 项目属性中，VC++包含目录设置为 D:\\cppsoft\\libjson\\include 库目录选择为 VC++库目录设置为 D:\\cppsoft\\libjson\\lib 另外我们还要设置链接器-&gt;输入-&gt;附加依赖项里设置json_vc71_libmtd.lib 我们写个程序测试一下json库安装的情况 123456789101112131415161718#include &lt;iostream&gt;#include &lt;json/json.h&gt;#include &lt;json/value.h&gt;#include &lt;json/reader.h&gt;int main()&#123; Json::Value root; root[&quot;id&quot;] = 1001; root[&quot;data&quot;] = &quot;hello world&quot;; std::string request = root.toStyledString(); std::cout &lt;&lt; &quot;request is &quot; &lt;&lt; request &lt;&lt; std::endl; Json::Value root2; Json::Reader reader; reader.parse(request, root2); std::cout &lt;&lt; &quot;msg id is &quot; &lt;&lt; root2[&quot;id&quot;] &lt;&lt; &quot; msg is &quot; &lt;&lt; root2[&quot;data&quot;] &lt;&lt; std::endl;&#125; 从这段代码中，我们先将root序列化为字符串，再将字符串反序列化为root2. 输出如下","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(4) visualstudio配置boost与jsoncpp","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro4/","text":"绑定和监听连接我们利用visual studio创建一个空项目，项目名字为GateServer，然后按照day03的方法配置boost库和jsoncpp配置好后，我们添加一个新的类，名字叫CServer。添加成功后生成的CServer.h和CServer.cpp也会自动加入到项目中。 CServer类构造函数接受一个端口号，创建acceptor接受新到来的链接。 CServer.h包含必要的头文件，以及简化作用域声明 12345678#include &lt;boost/beast/http.hpp&gt;#include &lt;boost/beast.hpp&gt;#include &lt;boost/asio.hpp&gt;namespace beast = boost::beast; // from &lt;boost/beast.hpp&gt;namespace http = beast::http; // from &lt;boost/beast/http.hpp&gt;namespace net = boost::asio; // from &lt;boost/asio.hpp&gt;using tcp = boost::asio::ip::tcp; // from &lt;boost/asio/ip/tcp.hpp&gt; CServer.h中声明acceptor, 以及用于事件循环的上下文iocontext,和构造函数 12345678910class CServer:public std::enable_shared_from_this&lt;CServer&gt;&#123;public: CServer(boost::asio::io_context&amp; ioc, unsigned short&amp; port); void Start();private: tcp::acceptor _acceptor; net::io_context&amp; _ioc; boost::asio::ip::tcp::socket _socket;&#125;; cpp中实现构造函数如下 1234CServer::CServer(boost::asio::io_context&amp; ioc, unsigned short&amp; port) :_ioc(ioc),_acceptor(ioc, tcp::endpoint(tcp::v4(), port)),_socket(ioc) &#123;&#125; 接下来我们实现Start函数，用来监听新链接 12345678910111213141516171819202122void CServer::Start()&#123; auto self = shared_from_this(); _acceptor.async_accept(_socket, [self](beast::error_code ec) &#123; try &#123; //出错则放弃这个连接，继续监听新链接 if (ec) &#123; self-&gt;Start(); return; &#125; //处理新链接，创建HpptConnection类管理新连接 std::make_shared&lt;HttpConnection&gt;(std::move(self-&gt;_socket))-&gt;Start(); //继续监听 self-&gt;Start(); &#125; catch (std::exception&amp; exp) &#123; std::cout &lt;&lt; &quot;exception is &quot; &lt;&lt; exp.what() &lt;&lt; std::endl; self-&gt;Start(); &#125; &#125;);&#125; Start函数内创建HttpConnection类型智能指针，将_socket内部数据转移给HttpConnection管理，_socket继续用来接受写的链接。 我们创建const.h将文件件和一些作用于声明放在const.h里，这样以后创建的文件包含这个const.h即可，不用写那么多头文件了。 12345678#include &lt;boost/beast/http.hpp&gt;#include &lt;boost/beast.hpp&gt;#include &lt;boost/asio.hpp&gt;namespace beast = boost::beast; // from &lt;boost/beast.hpp&gt;namespace http = beast::http; // from &lt;boost/beast/http.hpp&gt;namespace net = boost::asio; // from &lt;boost/asio.hpp&gt;using tcp = boost::asio::ip::tcp; // from &lt;boost/asio/ip/tcp.hpp&gt; 新建HttpConnection类文件，在头文件添加声明 123456789101112131415161718192021222324252627#include &quot;const.h&quot;class HttpConnection: public std::enable_shared_from_this&lt;HttpConnection&gt;&#123; friend class LogicSystem;public: HttpConnection(tcp::socket socket); void Start(); private: void CheckDeadline(); void WriteResponse(); void HandleReq(); tcp::socket _socket; // The buffer for performing reads. beast::flat_buffer _buffer&#123; 8192 &#125;; // The request message. http::request&lt;http::dynamic_body&gt; _request; // The response message. http::response&lt;http::dynamic_body&gt; _response; // The timer for putting a deadline on connection processing. net::steady_timer deadline_&#123; _socket.get_executor(), std::chrono::seconds(60) &#125;;&#125;; _buffer 用来接受数据 _request 用来解析请求 _response 用来回应客户端 _deadline 用来做定时器判断请求是否超时 实现HttpConnection构造函数 123HttpConnection::HttpConnection(tcp::socket socket) : _socket(std::move(socket)) &#123;&#125; 我们考虑在HttpConnection::Start内部调用http::async_read函数，其源码为 12345async_read( AsyncReadStream&amp; stream, DynamicBuffer&amp; buffer, basic_parser&lt;isRequest&gt;&amp; parser, ReadHandler&amp;&amp; handler) 第一个参数为异步可读的数据流，大家可以理解为socket. 第二个参数为一个buffer，用来存储接受的数据，因为http可接受文本，图像，音频等多种资源文件，所以是Dynamic动态类型的buffer。 第三个参数是请求参数，我们一般也要传递能接受多种资源类型的请求参数。 第四个参数为回调函数，接受成功或者失败，都会触发回调函数，我们用lambda表达式就可以了。 我们已经将1,2,3这几个参数写到HttpConnection类的成员声明里了 实现HttpConnection的Start函数 12345678910111213141516171819202122void HttpConnection::Start()&#123; auto self = shared_from_this(); http::async_read(_socket, _buffer, _request, [self](beast::error_code ec, std::size_t bytes_transferred) &#123; try &#123; if (ec) &#123; std::cout &lt;&lt; &quot;http read err is &quot; &lt;&lt; ec.what() &lt;&lt; std::endl; return; &#125; //处理读到的数据 boost::ignore_unused(bytes_transferred); self-&gt;HandleReq(); self-&gt;CheckDeadline(); &#125; catch (std::exception&amp; exp) &#123; std::cout &lt;&lt; &quot;exception is &quot; &lt;&lt; exp.what() &lt;&lt; std::endl; &#125; &#125; );&#125; 我们实现HandleReq 12345678910111213141516171819202122void HttpConnection::HandleReq() &#123; //设置版本 _response.version(_request.version()); //设置为短链接 _response.keep_alive(false); if (_request.method() == http::verb::get) &#123; bool success = LogicSystem::GetInstance()-&gt;HandleGet(_request.target(), shared_from_this()); if (!success) &#123; _response.result(http::status::not_found); _response.set(http::field::content_type, &quot;text/plain&quot;); beast::ostream(_response.body()) &lt;&lt; &quot;url not found\\r\\n&quot;; WriteResponse(); return; &#125; _response.result(http::status::ok); _response.set(http::field::server, &quot;GateServer&quot;); WriteResponse(); return; &#125;&#125; 为了方便我们先实现Get请求的处理，根据请求类型为get调用LogicSystem的HandleGet接口处理get请求，根据处理成功还是失败回应数据包给对方。 我们先实现LogicSystem，采用单例模式，单例基类之前讲解过了 123456789101112131415161718192021222324252627282930#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;template &lt;typename T&gt;class Singleton &#123;protected: Singleton() = default; Singleton(const Singleton&lt;T&gt;&amp;) = delete; Singleton&amp; operator=(const Singleton&lt;T&gt;&amp; st) = delete; static std::shared_ptr&lt;T&gt; _instance;public: static std::shared_ptr&lt;T&gt; GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = shared_ptr&lt;T&gt;(new T); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; endl; &#125; ~Singleton() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr; 实现LogicSystem单例类 12345678910111213141516171819#include &quot;Singleton.h&quot;#include &lt;functional&gt;#include &lt;map&gt;#include &quot;const.h&quot;class HttpConnection;typedef std::function&lt;void(std::shared_ptr&lt;HttpConnection&gt;)&gt; HttpHandler;class LogicSystem :public Singleton&lt;LogicSystem&gt;&#123; friend class Singleton&lt;LogicSystem&gt;;public: ~LogicSystem(); bool HandleGet(std::string, std::shared_ptr&lt;HttpConnection&gt;); void RegGet(std::string, HttpHandler handler);private: LogicSystem(); std::map&lt;std::string, HttpHandler&gt; _post_handlers; std::map&lt;std::string, HttpHandler&gt; _get_handlers;&#125;; _post_handlers和_get_handlers分别是post请求和get请求的回调函数map，key为路由，value为回调函数。 我们实现RegGet函数，接受路由和回调函数作为参数 123void LogicSystem::RegGet(std::string url, HttpHandler handler) &#123; _get_handlers.insert(make_pair(url, handler));&#125; 在构造函数中实现具体的消息注册 12345LogicSystem::LogicSystem() &#123; RegGet(&quot;/get_test&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;receive get_test req&quot;; &#125;);&#125; 为防止互相引用，以及LogicSystem能够成功访问HttpConnection，在LogicSystem.cpp中包含HttpConnection头文件 并且在HttpConnection中添加友元类LogicSystem, 且在HttpConnection.cpp中包含LogicSystem.h文件 12345678bool LogicSystem::HandleGet(std::string path, std::shared_ptr&lt;HttpConnection&gt; con) &#123; if (_get_handlers.find(path) == _get_handlers.end()) &#123; return false; &#125; _get_handlers[path](con); return true;&#125; 这样我们在HttpConnection里实现WriteResponse函数 123456789101112void HttpConnection::WriteResponse() &#123; auto self = shared_from_this(); _response.content_length(_response.body().size()); http::async_write( _socket, _response, [self](beast::error_code ec, std::size_t) &#123; self-&gt;_socket.shutdown(tcp::socket::shutdown_send, ec); self-&gt;deadline_.cancel(); &#125;);&#125; 因为http是短链接，所以发送完数据后不需要再监听对方链接，直接断开发送端即可。 另外，http处理请求需要有一个时间约束，发送的数据包不能超时。所以在发送时我们启动一个定时器，收到发送的回调后取消定时器。 我们实现检测超时的函数 12345678910111213void HttpConnection::CheckDeadline() &#123; auto self = shared_from_this(); deadline_.async_wait( [self](beast::error_code ec) &#123; if (!ec) &#123; // Close socket to cancel any outstanding operation. self-&gt;_socket.close(ec); &#125; &#125;);&#125; 我们在主函数中初始化上下文iocontext以及启动信号监听ctr-c退出事件， 并且启动iocontext服务 12345678910111213141516171819202122232425262728293031323334353637383940int main()&#123; try &#123; unsigned short port = static_cast&lt;unsigned short&gt;(8080); net::io_context ioc&#123; 1 &#125;; boost::asio::signal_set signals(ioc, SIGINT, SIGTERM); signals.async_wait([&amp;ioc](const boost::system::error_code&amp; error, int signal_number) &#123; if (error) &#123; return; &#125; ioc.stop(); &#125;); std::make_shared&lt;CServer&gt;(ioc, port)-&gt;Start(); ioc.run(); &#125; catch (std::exception const&amp; e) &#123; std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; &#125;&#125;``启动服务器，在浏览器输入`http://localhost:8080/get_test`会看到服务器回包`receive get_test req`如果我们输入带参数的url请求`http://localhost:8080/get_test?key1=value1&amp;key2=value2`会收到服务器反馈`url not found`所以对于get请求带参数的情况我们要实现参数解析，我们可以自己实现简单的url解析函数``` cpp//char 转为16进制unsigned char ToHex(unsigned char x)&#123; return x &gt; 9 ? x + 55 : x + 48;&#125; 将十进制的char转为16进制，如果是数字不超过9则加48转为对应的ASCII码的值 如果字符是大于9的，比如AZ, az等则加55，获取到对应字符的ASCII码值 详细的ASCII码表大家可以看这个https://c.biancheng.net/c/ascii/ 接下来实现从16进制转为十进制的char的方法 123456789unsigned char FromHex(unsigned char x)&#123; unsigned char y; if (x &gt;= &#x27;A&#x27; &amp;&amp; x &lt;= &#x27;Z&#x27;) y = x - &#x27;A&#x27; + 10; else if (x &gt;= &#x27;a&#x27; &amp;&amp; x &lt;= &#x27;z&#x27;) y = x - &#x27;a&#x27; + 10; else if (x &gt;= &#x27;0&#x27; &amp;&amp; x &lt;= &#x27;9&#x27;) y = x - &#x27;0&#x27;; else assert(0); return y;&#125; 接下来我们实现url编码工作 12345678910111213141516171819202122232425std::string UrlEncode(const std::string&amp; str)&#123; std::string strTemp = &quot;&quot;; size_t length = str.length(); for (size_t i = 0; i &lt; length; i++) &#123; //判断是否仅有数字和字母构成 if (isalnum((unsigned char)str[i]) || (str[i] == &#x27;-&#x27;) || (str[i] == &#x27;_&#x27;) || (str[i] == &#x27;.&#x27;) || (str[i] == &#x27;~&#x27;)) strTemp += str[i]; else if (str[i] == &#x27; &#x27;) //为空字符 strTemp += &quot;+&quot;; else &#123; //其他字符需要提前加%并且高四位和低四位分别转为16进制 strTemp += &#x27;%&#x27;; strTemp += ToHex((unsigned char)str[i] &gt;&gt; 4); strTemp += ToHex((unsigned char)str[i] &amp; 0x0F); &#125; &#125; return strTemp;&#125; 我们先判断str[i]是否为字母或者数字，或者一些简单的下划线，如果是泽直接拼接，否则判断是否为空字符，如果为空则换成’+’拼接。否则就是特殊字符，我们需要将特殊字符转化为’%’和两个十六进制字符拼接。现拼接’%’，再将字符的高四位拼接到strTemp上，最后将低四位拼接到strTemp上。 url解码的工作正好相反 1234567891011121314151617181920std::string UrlDecode(const std::string&amp; str)&#123; std::string strTemp = &quot;&quot;; size_t length = str.length(); for (size_t i = 0; i &lt; length; i++) &#123; //还原+为空 if (str[i] == &#x27;+&#x27;) strTemp += &#x27; &#x27;; //遇到%将后面的两个字符从16进制转为char再拼接 else if (str[i] == &#x27;%&#x27;) &#123; assert(i + 2 &lt; length); unsigned char high = FromHex((unsigned char)str[++i]); unsigned char low = FromHex((unsigned char)str[++i]); strTemp += high * 16 + low; &#125; else strTemp += str[i]; &#125; return strTemp;&#125; 接下来实现get请求的参数解析, 在HttpConnection里添加两个成员 12std::string _get_url;std::unordered_map&lt;std::string, std::string&gt; _get_params; 参数解析如下 1234567891011121314151617181920212223242526272829303132333435void HttpConnection::PreParseGetParam() &#123; // 提取 URI auto uri = _request.target(); // 查找查询字符串的开始位置（即 &#x27;?&#x27; 的位置） auto query_pos = uri.find(&#x27;?&#x27;); if (query_pos == std::string::npos) &#123; _get_url = uri; return; &#125; _get_url = uri.substr(0, query_pos); std::string query_string = uri.substr(query_pos + 1); std::string key; std::string value; size_t pos = 0; while ((pos = query_string.find(&#x27;&amp;&#x27;)) != std::string::npos) &#123; auto pair = query_string.substr(0, pos); size_t eq_pos = pair.find(&#x27;=&#x27;); if (eq_pos != std::string::npos) &#123; key = UrlDecode(pair.substr(0, eq_pos)); // 假设有 url_decode 函数来处理URL解码 value = UrlDecode(pair.substr(eq_pos + 1)); _get_params[key] = value; &#125; query_string.erase(0, pos + 1); &#125; // 处理最后一个参数对（如果没有 &amp; 分隔符） if (!query_string.empty()) &#123; size_t eq_pos = query_string.find(&#x27;=&#x27;); if (eq_pos != std::string::npos) &#123; key = UrlDecode(query_string.substr(0, eq_pos)); value = UrlDecode(query_string.substr(eq_pos + 1)); _get_params[key] = value; &#125; &#125;&#125; HttpConnection::HandleReq函数略作修改 12345678void HttpConnection::HandleReq() &#123; //...省略 if (_request.method() == http::verb::get) &#123; PreParseGetParam(); bool success = LogicSystem::GetInstance()-&gt;HandleGet(_get_url, shared_from_this()); &#125; //...省略&#125; 我们修改LogicSytem构造函数，在get_test的回调里返回参数给对端 1234567891011LogicSystem::LogicSystem() &#123; RegGet(&quot;/get_test&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;receive get_test req &quot; &lt;&lt; std::endl; int i = 0; for (auto&amp; elem : connection-&gt;_get_params) &#123; i++; beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;param&quot; &lt;&lt; i &lt;&lt; &quot; key is &quot; &lt;&lt; elem.first; beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;, &quot; &lt;&lt; &quot; value is &quot; &lt;&lt; elem.second &lt;&lt; std::endl; &#125; &#125;);&#125; 在浏览器输入http://localhost:8080/get_test?key1=value1&amp;key2=value2 看到浏览器收到如下图信息，说明我们的get请求逻辑处理完了","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(5) Beast实现http get请求处理","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro5/","text":"注册Post请求我们实现RegPost函数 123void LogicSystem::RegPost(std::string url, HttpHandler handler) &#123; _post_handlers.insert(make_pair(url, handler));&#125; 在const.h中添加ErrorCodes定义并且包含JsonCpp相关的头文件 123456789#include &lt;json/json.h&gt;#include &lt;json/value.h&gt;#include &lt;json/reader.h&gt;enum ErrorCodes &#123; Success = 0, Error_Json = 1001, //Json解析错误 RPCFailed = 1002, //RPC请求错误&#125;; 然后在LogicSystem的构造函数里添加获取验证码的处理逻辑， 123456789101112131415161718192021222324RegPost(&quot;/get_varifycode&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; auto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; connection-&gt;_response.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::Error_Json; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; auto email = src_root[&quot;email&quot;].asString(); cout &lt;&lt; &quot;email is &quot; &lt;&lt; email &lt;&lt; endl; root[&quot;error&quot;] = 0; root[&quot;email&quot;] = src_root[&quot;email&quot;]; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true;&#125;); 然后我们在LogicSystem中添加Post请求的处理 12345678bool LogicSystem::HandlePost(std::string path, std::shared_ptr&lt;HttpConnection&gt; con) &#123; if (_post_handlers.find(path) == _post_handlers.end()) &#123; return false; &#125; _post_handlers[path](con); return true;&#125; 在HttpConnection的HandleReq中添加post请求处理 12345678910111213141516171819void HttpConnection::HandleReq() &#123; //省略... if (_request.method() == http::verb::post) &#123; bool success = LogicSystem::GetInstance()-&gt;HandlePost(_request.target(), shared_from_this()); if (!success) &#123; _response.result(http::status::not_found); _response.set(http::field::content_type, &quot;text/plain&quot;); beast::ostream(_response.body()) &lt;&lt; &quot;url not found\\r\\n&quot;; WriteResponse(); return; &#125; _response.result(http::status::ok); _response.set(http::field::server, &quot;GateServer&quot;); WriteResponse(); return; &#125;&#125; 然后我们启动服务器，然后下载postman，大家可以去官网下载，如果速度慢可以去我的网盘下载https://pan.baidu.com/s/1DBIf7Y6G3v0XYfW5LyDKMg?pwd=kjxz 提取码：kjxz 打开postman，将请求修改为post 绿色的为post请求的json参数，红色的为服务器返回的json数据包。 我们看服务器打印的日志 客户端增加post逻辑我们之前在客户端实现了httpmgr的post请求，在点击获取验证码的槽函数里添加发送http的post请求即可 12345678910111213141516171819void RegisterDialog::on_get_code_clicked()&#123; //验证邮箱的地址正则表达式 auto email = ui-&gt;email_edit-&gt;text(); // 邮箱地址的正则表达式 QRegularExpression regex(R&quot;((\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+)&quot;); bool match = regex.match(email).hasMatch(); // 执行正则表达式匹配 if(match)&#123; //发送http请求获取验证码 QJsonObject json_obj; json_obj[&quot;email&quot;] = email; HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(&quot;http://localhost:8080/get_varifycode&quot;), json_obj, ReqId::ID_GET_VARIFY_CODE,Modules::REGISTERMOD); &#125;else&#123; //提示邮箱不正确 showTip(tr(&quot;邮箱地址不正确&quot;),false); &#125;&#125; 当服务器不启动，客户端输入邮箱，点击获取验证码，客户端会收到网络连接失败的提示 启动服务器后，再次获取验证码，就显示正确提示了，而且客户端输出了服务器回传的邮箱地址email is &quot;secondtonone1@163.com&quot;，界面也刷新为正确显示 客户端配置管理我们发现客户端代码中很多参数都是写死的，最好通过配置文件管理，我们在代码所在目录中新建一个config.ini文件, 内部添加配置 123[GateServer]host=localhostport=8080 接着右键项目添加现有文件config.ini即可加入项目中。 因为我们的程序最终会输出的bin目录，所以在pro中添加拷贝脚本将配置也拷贝到bin目录 12345678910111213win32:CONFIG(release, debug | release)&#123; #指定要拷贝的文件目录为工程目录下release目录下的所有dll、lib文件，例如工程目录在D:\\QT\\Test #PWD就为D:/QT/Test，DllFile = D:/QT/Test/release/*.dll TargetConfig = $$&#123;PWD&#125;/config.ini #将输入目录中的&quot;/&quot;替换为&quot;\\&quot; TargetConfig = $$replace(TargetConfig, /, \\\\) #将输出目录中的&quot;/&quot;替换为&quot;\\&quot; OutputDir = $$&#123;OUT_PWD&#125;/$$&#123;DESTDIR&#125; OutputDir = $$replace(OutputDir, /, \\\\) //执行copy命令 QMAKE_POST_LINK += copy /Y \\&quot;$$TargetConfig\\&quot; \\&quot;$$OutputDir\\&quot;&#125; global.h中添加声明 1extern QString gate_url_prefix; 在cpp中添加定义 1QString gate_url_prefix = &quot;&quot;; 在main函数中添加解析配置的逻辑 1234567891011// 获取当前应用程序的路径QString app_path = QCoreApplication::applicationDirPath();// 拼接文件名QString fileName = &quot;config.ini&quot;;QString config_path = QDir::toNativeSeparators(app_path + QDir::separator() + fileName);QSettings settings(config_path, QSettings::IniFormat);QString gate_host = settings.value(&quot;GateServer/host&quot;).toString();QString gate_port = settings.value(&quot;GateServer/port&quot;).toString();gate_url_prefix = &quot;http://&quot;+gate_host+&quot;:&quot;+gate_port; 将RegisterDialog发送post请求修改为 12HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(gate_url_prefix+&quot;/get_varifycode&quot;), json_obj, ReqId::ID_GET_VARIFY_CODE,Modules::REGISTERMOD); 再次测试仍旧可以收到服务器回馈的http包。 这么做的好处就是客户端增加了配置，而且以后修改参数也方便。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(7) 客户端实现Post验证码请求","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro7/","text":"属性管理器推荐一种可复制配置的方式，视图里选择其他窗口，再选择属性管理器 我们选择要配置的类型，我选择Debug 64位的配置，添加新项目属性表 选择创建属性的名字 接下来双击我们创建好的属性文件，将之前配置的boost和jsoncpp库属性移动到这里，把之前在项目中配置的删除。 包含目录 库目录 链接库 接下来配置grpc头文件包含目录，C++ 常规-&gt; 附加包含目录添加如下 12345D:\\cppsoft\\grpc\\third_party\\re2D:\\cppsoft\\grpc\\third_party\\address_sorting\\includeD:\\cppsoft\\grpc\\third_party\\abseil-cppD:\\cppsoft\\grpc\\third_party\\protobuf\\srcD:\\cppsoft\\grpc\\include 接下来配置库路径, 在链接器常规选项下，点击附加库目录，添加我们需要的库目录 123456789101112131415161718D:\\cppsoft\\grpc\\visualpro\\third_party\\re2\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\types\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\synchronization\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\status\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\random\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\flags\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\debugging\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\container\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\hash\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\boringssl-with-bazel\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\numeric\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\time\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\base\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\strings\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\zlib\\DebugD:\\cppsoft\\grpc\\visualpro\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\cares\\cares\\lib\\Debug 在链接器-&gt;输入-&gt;附加依赖项中添加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667libprotobufd.libgpr.libgrpc.libgrpc++.libgrpc++_reflection.libaddress_sorting.libws2_32.libcares.libzlibstaticd.libupb.libssl.libcrypto.libabsl_bad_any_cast_impl.libabsl_bad_optional_access.libabsl_bad_variant_access.libabsl_base.libabsl_city.libabsl_civil_time.libabsl_cord.libabsl_debugging_internal.libabsl_demangle_internal.libabsl_examine_stack.libabsl_exponential_biased.libabsl_failure_signal_handler.libabsl_flags.libabsl_flags_config.libabsl_flags_internal.libabsl_flags_marshalling.libabsl_flags_parse.libabsl_flags_program_name.libabsl_flags_usage.libabsl_flags_usage_internal.libabsl_graphcycles_internal.libabsl_hash.libabsl_hashtablez_sampler.libabsl_int128.libabsl_leak_check.libabsl_leak_check_disable.libabsl_log_severity.libabsl_malloc_internal.libabsl_periodic_sampler.libabsl_random_distributions.libabsl_random_internal_distribution_test_util.libabsl_random_internal_pool_urbg.libabsl_random_internal_randen.libabsl_random_internal_randen_hwaes.libabsl_random_internal_randen_hwaes_impl.libabsl_random_internal_randen_slow.libabsl_random_internal_seed_material.libabsl_random_seed_gen_exception.libabsl_random_seed_sequences.libabsl_raw_hash_set.libabsl_raw_logging_internal.libabsl_scoped_set_env.libabsl_spinlock_wait.libabsl_stacktrace.libabsl_status.libabsl_strings.libabsl_strings_internal.libabsl_str_format_internal.libabsl_symbolize.libabsl_synchronization.libabsl_throw_delegate.libabsl_time.libabsl_time_zone.libabsl_statusor.libre2.lib 之后点击保存会看到项目目录下生成了PropertySheet.props文件 proto文件编写在项目的根目录下创建一个proto名字为message.proto 1234567891011121314151617syntax = &quot;proto3&quot;;package message;service VarifyService &#123; rpc GetVarifyCode (GetVarifyReq) returns (GetVarifyRsp) &#123;&#125;&#125;message GetVarifyReq &#123; string email = 1;&#125;message GetVarifyRsp &#123; int32 error = 1; string email = 2; string code = 3;&#125; 接下来我们利用grpc编译后生成的proc.exe生成proto的grpc的头文件和源文件 1D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe -I=&quot;.&quot; --grpc_out=&quot;.&quot; --plugin=protoc-gen-grpc=&quot;D:\\cppsoft\\grpc\\visualpro\\Debug\\grpc_cpp_plugin.exe&quot; &quot;message.proto&quot; 上述命令会生成message.grpc.pb.h和message.grpc.pb.cc文件。 接下来我们生成用于序列化和反序列化的pb文件 1D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe --cpp_out=. &quot;message.proto&quot; 上述命令会生成message.pb.h和message.pb.cc文件 接下来我们将这些pb.h和pb.cc放入项目中 我们新建一个VarifyGrpcClient类，vs帮我们自动生成头文件和源文件，我们在头文件添加Grpc客户端类 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;grpcpp/grpcpp.h&gt;#include &quot;message.grpc.pb.h&quot;#include &quot;const.h&quot;#include &quot;Singleton.h&quot;using grpc::Channel;using grpc::Status;using grpc::ClientContext;using message::GetVarifyReq;using message::GetVarifyRsp;using message::VarifyService;class VerifyGrpcClient:public Singleton&lt;VerifyGrpcClient&gt;&#123; friend class Singleton&lt;VerifyGrpcClient&gt;;public: GetVarifyRsp GetVarifyCode(std::string email) &#123; ClientContext context; GetVarifyRsp reply; GetVarifyReq request; request.set_email(email); Status status = stub_-&gt;GetVarifyCode(&amp;context, request, &amp;reply); if (status.ok()) &#123; return reply; &#125; else &#123; reply.set_error(ErrorCodes::RPCFailed); return reply; &#125; &#125;private: VerifyGrpcClient() &#123; std::shared_ptr&lt;Channel&gt; channel = grpc::CreateChannel(&quot;127.0.0.1:50051&quot;, grpc::InsecureChannelCredentials()); stub_ = VarifyService::NewStub(channel); &#125; std::unique_ptr&lt;VarifyService::Stub&gt; stub_;&#125;; 我们在之前收到post请求获取验证码的逻辑里添加处理 12345678910111213141516171819202122232425RegPost(&quot;/get_varifycode&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; auto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; connection-&gt;_response.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::Error_Json; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; auto email = src_root[&quot;email&quot;].asString(); GetVarifyRsp rsp = VerifyGrpcClient::GetInstance()-&gt;GetVarifyCode(email); cout &lt;&lt; &quot;email is &quot; &lt;&lt; email &lt;&lt; endl; root[&quot;error&quot;] = rsp.error(); root[&quot;email&quot;] = src_root[&quot;email&quot;]; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true;&#125;); 服务器读取配置我们很多参数都是写死的，现通过配置文件读取以方便以后修改在项目中添加config.ini文件 1234[GateServer]Port = 8080[VarifyServer]Port = 50051 添加ConfigMgr类用来读取和管理配置, 定义一个SectionInfo类管理key和value 123456789101112131415161718192021222324252627struct SectionInfo &#123; SectionInfo()&#123;&#125; ~SectionInfo()&#123; _section_datas.clear(); &#125; SectionInfo(const SectionInfo&amp; src) &#123; _section_datas = src._section_datas; &#125; SectionInfo&amp; operator = (const SectionInfo&amp; src) &#123; if (&amp;src == this) &#123; return *this; &#125; this-&gt;_section_datas = src._section_datas; &#125; std::map&lt;std::string, std::string&gt; _section_datas; std::string operator[](const std::string &amp;key) &#123; if (_section_datas.find(key) == _section_datas.end()) &#123; return &quot;&quot;; &#125; // 这里可以添加一些边界检查 return _section_datas[key]; &#125;&#125;; 定义ComigMgr管理section和其包含的key与value 1234567891011121314151617181920212223242526272829303132class ConfigMgr&#123;public: ~ConfigMgr() &#123; _config_map.clear(); &#125; SectionInfo operator[](const std::string&amp; section) &#123; if (_config_map.find(section) == _config_map.end()) &#123; return SectionInfo(); &#125; return _config_map[section]; &#125; ConfigMgr&amp; operator=(const ConfigMgr&amp; src) &#123; if (&amp;src == this) &#123; return *this; &#125; this-&gt;_config_map = src._config_map; &#125;; ConfigMgr(const ConfigMgr&amp; src) &#123; this-&gt;_config_map = src._config_map; &#125; ConfigMgr();private: // 存储section和key-value对的map std::map&lt;std::string, SectionInfo&gt; _config_map;&#125;; 构造函数里实现config读取 1234567891011121314151617181920212223242526272829303132333435363738394041ConfigMgr::ConfigMgr()&#123; // 获取当前工作目录 boost::filesystem::path current_path = boost::filesystem::current_path(); // 构建config.ini文件的完整路径 boost::filesystem::path config_path = current_path / &quot;config.ini&quot;; std::cout &lt;&lt; &quot;Config path: &quot; &lt;&lt; config_path &lt;&lt; std::endl; // 使用Boost.PropertyTree来读取INI文件 boost::property_tree::ptree pt; boost::property_tree::read_ini(config_path.string(), pt); // 遍历INI文件中的所有section for (const auto&amp; section_pair : pt) &#123; const std::string&amp; section_name = section_pair.first; const boost::property_tree::ptree&amp; section_tree = section_pair.second; // 对于每个section，遍历其所有的key-value对 std::map&lt;std::string, std::string&gt; section_config; for (const auto&amp; key_value_pair : section_tree) &#123; const std::string&amp; key = key_value_pair.first; const std::string&amp; value = key_value_pair.second.get_value&lt;std::string&gt;(); section_config[key] = value; &#125; SectionInfo sectionInfo; sectionInfo._section_datas = section_config; // 将section的key-value对保存到config_map中 _config_map[section_name] = sectionInfo; &#125; // 输出所有的section和key-value对 for (const auto&amp; section_entry : _config_map) &#123; const std::string&amp; section_name = section_entry.first; SectionInfo section_config = section_entry.second; std::cout &lt;&lt; &quot;[&quot; &lt;&lt; section_name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; for (const auto&amp; key_value_pair : section_config._section_datas) &#123; std::cout &lt;&lt; key_value_pair.first &lt;&lt; &quot;=&quot; &lt;&lt; key_value_pair.second &lt;&lt; std::endl; &#125; &#125;&#125; 在const.h里声明一个全局变量 12class ConfigMgr;extern ConfigMgr gCfgMgr; 接下来在main函数中将8080端口改为从配置读取 123ConfigMgr gCfgMgr;std::string gate_port_str = gCfgMgr[&quot;GateServer&quot;][&quot;Port&quot;];unsigned short gate_port = atoi(gate_port_str.c_str()); 其他地方想要获取配置信息就不需要定义了，直接包含const.h并且使用gCfgMgr即可。 总结本节基于visual studio配置grpc，并实现了grpc客户端发送请求的逻辑。下一节实现 grpc server","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(8) windows配置和使用grpc","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro8/","text":"认证服务我们的认证服务要给邮箱发送验证码，所以用nodejs较为合适，nodejs是一门IO效率很高而且生态完善的语言，用到发送邮件的库也方便。 nodejs可以去官网下载https://nodejs.org/en，一路安装就可以了 我们新建VarifyServer文件夹，在文件夹内部初始化server要用到的nodejs库的配置文件 1npm init 根据提示同意会创建一个package.json文件 接下来安装grpc-js包，也可以安装grpc，grpc是C++版本，grpc-js是js版本，C++版本停止维护了。所以用grpc-js版本。 安装过程出现了错误，因为淘宝镜像地址过期了 清除之前npm镜像地址 1npm cache clean --force 重新设置新的淘宝镜像 1npm config set registry https://registry.npmmirror.com 接着下载grpc-js就成功了 接着安装proto-loader用来动态解析proto文件 1npm install @grpc/proto-loader 我们再安装email处理的库 1npm install nodemailer 我们将proto文件放入VarifyServer文件夹，并且新建一个proto.js用来解析proto文件 1234567891011const path = require(&#x27;path&#x27;)const grpc = require(&#x27;@grpc/grpc-js&#x27;)const protoLoader = require(&#x27;@grpc/proto-loader&#x27;)const PROTO_PATH = path.join(__dirname, &#x27;message.proto&#x27;)const packageDefinition = protoLoader.loadSync(PROTO_PATH, &#123; keepCase: true, longs: String, enums: String, defaults: true, oneofs: true &#125;)const protoDescriptor = grpc.loadPackageDefinition(packageDefinition)const message_proto = protoDescriptor.messagemodule.exports = message_proto keepCase: 如果为 true，则保留字段名的原始大小写。如果为 false，则将所有字段名转换为驼峰命名法。 longs: 控制如何表示 Protocol Buffers 中的 long 类型。如果设置为 String，则长整数会被转换为字符串，以避免 JavaScript 中的整数溢出问题。 enums: 控制如何表示 Protocol Buffers 中的枚举类型。如果设置为 String，则枚举值会被转换为字符串。 defaults: 如果为 true，则为未明确设置的字段提供默认值。 oneofs: 如果为 true，则支持 Protocol Buffers 中的 oneof 特性。 在写代码发送邮件之前，我们先去邮箱开启smtp服务。我用的163邮箱，在邮箱设置中查找smtp服务器地址，需要开启smtp服务。这个是固定的，不需要修改。 网易163邮箱的 SMTP 服务器地址为: smtp.163.com 发送邮件，建议使用授权码(有的邮箱叫 独立密码)，确保邮箱密码的安全性。授权码在邮箱设置中进行设置。如果开启了授权码，发送邮件的时候，必须使用授权码。 这里设置开启smtp服务和授权码。我这里已经是设置好的。 新增一个授权码用于发邮件 读取配置因为我们要实现参数可配置，所以要读取配置，先在文件夹内创建一个config.json文件 123456&#123; &quot;email&quot;: &#123; &quot;user&quot;: &quot;secondtonone1@163.com&quot;, &quot;pass&quot;: &quot;CRWTAZOSNCWDDQQTllfc&quot; &#125;,&#125; user是我们得邮箱地址，pass是邮箱得授权码，只有有了授权码才能用代码发邮件。大家记得把授权码改为你们自己的，否则用我的无法发送成功。 另外我们也要用到一些常量和全局得变量，所以我们定义一个const.js 12345678910let code_prefix = &quot;code_&quot;;const Errors = &#123; Success : 0, RedisErr : 1, Exception : 2,&#125;;module.exports = &#123;code_prefix,Errors&#125; 新建config.js用来读取配置 1234567891011121314const fs = require(&#x27;fs&#x27;);let config = JSON.parse(fs.readFileSync(&#x27;config.json&#x27;, &#x27;utf8&#x27;));let email_user = config.email.user;let email_pass = config.email.pass;let mysql_host = config.mysql.host;let mysql_port = config.mysql.port;let redis_host = config.redis.host;let redis_port = config.redis.port;let redis_passwd = config.redis.passwd;let code_prefix = &quot;code_&quot;;module.exports = &#123;email_pass, email_user, mysql_host, mysql_port,redis_host, redis_port, redis_passwd, code_prefix&#125; 接下来封装发邮件的模块，新建一个email.js文件 123456789101112131415const nodemailer = require(&#x27;nodemailer&#x27;);const config_module = require(&quot;./config&quot;)/** * 创建发送邮件的代理 */let transport = nodemailer.createTransport(&#123; host: &#x27;smtp.163.com&#x27;, port: 465, secure: true, auth: &#123; user: config_module.email_user, // 发送方邮箱地址 pass: config_module.email_pass // 邮箱授权码或者密码 &#125;&#125;); 接下来实现发邮件函数 123456789101112131415161718192021/** * 发送邮件的函数 * @param &#123;*&#125; mailOptions_ 发送邮件的参数 * @returns */function SendMail(mailOptions_)&#123; return new Promise(function(resolve, reject)&#123; transport.sendMail(mailOptions_, function(error, info)&#123; if (error) &#123; console.log(error); reject(error); &#125; else &#123; console.log(&#x27;邮件已成功发送：&#x27; + info.response); resolve(info.response) &#125; &#125;); &#125;) &#125;module.exports.SendMail = SendMail 因为transport.SendMail相当于一个异步函数，调用该函数后发送的结果是通过回调函数通知的，所以我们没办法同步使用，需要用Promise封装这个调用，抛出Promise给外部，那么外部就可以通过await或者then catch的方式处理了。 我们新建server.js，用来启动grpc server 123456789101112131415161718192021222324252627282930313233343536373839404142async function GetVarifyCode(call, callback) &#123; console.log(&quot;email is &quot;, call.request.email) try&#123; uniqueId = uuidv4(); console.log(&quot;uniqueId is &quot;, uniqueId) let text_str = &#x27;您的验证码为&#x27;+ uniqueId +&#x27;请三分钟内完成注册&#x27; //发送邮件 let mailOptions = &#123; from: &#x27;secondtonone1@163.com&#x27;, to: call.request.email, subject: &#x27;验证码&#x27;, text: text_str, &#125;; let send_res = await emailModule.SendMail(mailOptions); console.log(&quot;send res is &quot;, send_res) callback(null, &#123; email: call.request.email, error:const_module.Errors.Success &#125;); &#125;catch(error)&#123; console.log(&quot;catch error is &quot;, error) callback(null, &#123; email: call.request.email, error:const_module.Errors.Exception &#125;); &#125; &#125;function main() &#123; var server = new grpc.Server() server.addService(message_proto.VarifyService.service, &#123; GetVarifyCode: GetVarifyCode &#125;) server.bindAsync(&#x27;0.0.0.0:50051&#x27;, grpc.ServerCredentials.createInsecure(), () =&gt; &#123; server.start() console.log(&#x27;grpc server started&#x27;) &#125;)&#125;main() GetVarifyCode声明为async是为了能在内部调用await。 提升GateServer并发添加ASIO IOContext Pool 结构，让多个iocontext跑在不同的线程中 1234567891011121314151617181920212223#include &lt;vector&gt;#include &lt;boost/asio.hpp&gt;#include &quot;Singleton.h&quot;class AsioIOServicePool:public Singleton&lt;AsioIOServicePool&gt;&#123; friend Singleton&lt;AsioIOServicePool&gt;;public: using IOService = boost::asio::io_context; using Work = boost::asio::io_context::work; using WorkPtr = std::unique_ptr&lt;Work&gt;; ~AsioIOServicePool(); AsioIOServicePool(const AsioIOServicePool&amp;) = delete; AsioIOServicePool&amp; operator=(const AsioIOServicePool&amp;) = delete; // 使用 round-robin 的方式返回一个 io_service boost::asio::io_context&amp; GetIOService(); void Stop();private: AsioIOServicePool(std::size_t size = 2/*std::thread::hardware_concurrency()*/); std::vector&lt;IOService&gt; _ioServices; std::vector&lt;WorkPtr&gt; _works; std::vector&lt;std::thread&gt; _threads; std::size_t _nextIOService;&#125;; 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;AsioIOServicePool.h&quot;#include &lt;iostream&gt;using namespace std;AsioIOServicePool::AsioIOServicePool(std::size_t size):_ioServices(size),_works(size), _nextIOService(0)&#123; for (std::size_t i = 0; i &lt; size; ++i) &#123; _works[i] = std::unique_ptr&lt;Work&gt;(new Work(_ioServices[i])); &#125; //遍历多个ioservice，创建多个线程，每个线程内部启动ioservice for (std::size_t i = 0; i &lt; _ioServices.size(); ++i) &#123; _threads.emplace_back([this, i]() &#123; _ioServices[i].run(); &#125;); &#125;&#125;AsioIOServicePool::~AsioIOServicePool() &#123; Stop(); std::cout &lt;&lt; &quot;AsioIOServicePool destruct&quot; &lt;&lt; endl;&#125;boost::asio::io_context&amp; AsioIOServicePool::GetIOService() &#123; auto&amp; service = _ioServices[_nextIOService++]; if (_nextIOService == _ioServices.size()) &#123; _nextIOService = 0; &#125; return service;&#125;void AsioIOServicePool::Stop()&#123; //因为仅仅执行work.reset并不能让iocontext从run的状态中退出 //当iocontext已经绑定了读或写的监听事件后，还需要手动stop该服务。 for (auto&amp; work : _works) &#123; //把服务先停止 work-&gt;get_io_context().stop(); work.reset(); &#125; for (auto&amp; t : _threads) &#123; t.join(); &#125;&#125; 修改CServer处Start逻辑, 改为每次从IOServicePool连接池中获取连接 123456789101112131415161718192021222324void CServer::Start()&#123; auto self = shared_from_this(); auto&amp; io_context = AsioIOServicePool::GetInstance()-&gt;GetIOService(); std::shared_ptr&lt;HttpConnection&gt; new_con = std::make_shared&lt;HttpConnection&gt;(io_context); _acceptor.async_accept(new_con-&gt;GetSocket(), [self, new_con](beast::error_code ec) &#123; try &#123; //出错则放弃这个连接，继续监听新链接 if (ec) &#123; self-&gt;Start(); return; &#125; //处理新链接，创建HpptConnection类管理新连接 new_con-&gt;Start(); //继续监听 self-&gt;Start(); &#125; catch (std::exception&amp; exp) &#123; std::cout &lt;&lt; &quot;exception is &quot; &lt;&lt; exp.what() &lt;&lt; std::endl; self-&gt;Start(); &#125; &#125;);&#125; 为了方便读取配置文件，将ConfigMgr改为单例, 将构造函数变成私有，添加Inst函数 1234static ConfigMgr&amp; Inst() &#123; static ConfigMgr cfg_mgr; return cfg_mgr;&#125; VerifyGrpcClient.cpp中添加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class RPConPool &#123;public: RPConPool(size_t poolSize, std::string host, std::string port) : poolSize_(poolSize), host_(host), port_(port), b_stop_(false) &#123; for (size_t i = 0; i &lt; poolSize_; ++i) &#123; std::shared_ptr&lt;Channel&gt; channel = grpc::CreateChannel(host+&quot;:&quot;+port, grpc::InsecureChannelCredentials()); connections_.push(VarifyService::NewStub(channel)); &#125; &#125; ~RPConPool() &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); Close(); while (!connections_.empty()) &#123; connections_.pop(); &#125; &#125; std::unique_ptr&lt;VarifyService::Stub&gt; getConnection() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); cond_.wait(lock, [this] &#123; if (b_stop_) &#123; return true; &#125; return !connections_.empty(); &#125;); //如果停止则直接返回空指针 if (b_stop_) &#123; return nullptr; &#125; auto context = std::move(connections_.front()); connections_.pop(); return context; &#125; void returnConnection(std::unique_ptr&lt;VarifyService::Stub&gt; context) &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); if (b_stop_) &#123; return; &#125; connections_.push(std::move(context)); cond_.notify_one(); &#125; void Close() &#123; b_stop_ = true; cond_.notify_all(); &#125;private: atomic&lt;bool&gt; b_stop_; size_t poolSize_; std::string host_; std::string port_; std::queue&lt;std::unique_ptr&lt;VarifyService::Stub&gt;&gt; connections_; std::mutex mutex_; std::condition_variable cond_;&#125;; 我们在VerifyGrpcClient类中添加成员 1std::unique_ptr&lt;RPConPool&gt; pool_; 修改构造函数 123456VerifyGrpcClient::VerifyGrpcClient() &#123; auto&amp; gCfgMgr = ConfigMgr::Inst(); std::string host = gCfgMgr[&quot;VarifyServer&quot;][&quot;Host&quot;]; std::string port = gCfgMgr[&quot;VarifyServer&quot;][&quot;Port&quot;]; pool_.reset(new RPConPool(5, host, port));&#125; 当我们想连接grpc server端时，可以通过池子获取连接，用完之后再返回连接给池子 123456789101112131415161718GetVarifyRsp GetVarifyCode(std::string email) &#123; ClientContext context; GetVarifyRsp reply; GetVarifyReq request; request.set_email(email); auto stub = pool_-&gt;getConnection(); Status status = stub-&gt;GetVarifyCode(&amp;context, request, &amp;reply); if (status.ok()) &#123; pool_-&gt;returnConnection(std::move(stub)); return reply; &#125; else &#123; pool_-&gt;returnConnection(std::move(stub)); reply.set_error(ErrorCodes::RPCFailed); return reply; &#125;&#125; 总结到本节为止我们完成nodejs搭建的grpc server， 修改package.json中的脚本 123&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;node server.js&quot;&#125;, 接着命令行执行 npm run serve即可启动grpc 服务。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(11) redis环境配置和使用","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro11/","text":"注册功能实现注册功能，先实现客户端发送post请求, 将注册ui中确定按钮改为sure_btn，并为其添加click槽函数 12345678910111213141516171819202122232425262728293031323334353637383940414243//day11 添加确认槽函数void RegisterDialog::on_sure_btn_clicked()&#123; if(ui-&gt;user_edit-&gt;text() == &quot;&quot;)&#123; showTip(tr(&quot;用户名不能为空&quot;), false); return; &#125; if(ui-&gt;email_edit-&gt;text() == &quot;&quot;)&#123; showTip(tr(&quot;邮箱不能为空&quot;), false); return; &#125; if(ui-&gt;pass_edit-&gt;text() == &quot;&quot;)&#123; showTip(tr(&quot;密码不能为空&quot;), false); return; &#125; if(ui-&gt;confirm_edit-&gt;text() == &quot;&quot;)&#123; showTip(tr(&quot;确认密码不能为空&quot;), false); return; &#125; if(ui-&gt;confirm_edit-&gt;text() != ui-&gt;pass_edit-&gt;text())&#123; showTip(tr(&quot;密码和确认密码不匹配&quot;), false); return; &#125; if(ui-&gt;varify_edit-&gt;text() == &quot;&quot;)&#123; showTip(tr(&quot;验证码不能为空&quot;), false); return; &#125; //day11 发送http请求注册用户 QJsonObject json_obj; json_obj[&quot;user&quot;] = ui-&gt;user_edit-&gt;text(); json_obj[&quot;email&quot;] = ui-&gt;email_edit-&gt;text(); json_obj[&quot;passwd&quot;] = ui-&gt;pass_edit-&gt;text(); json_obj[&quot;confirm&quot;] = ui-&gt;confirm_edit-&gt;text(); json_obj[&quot;varifycode&quot;] = ui-&gt;varify_edit-&gt;text(); HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(gate_url_prefix+&quot;/user_register&quot;), json_obj, ReqId::ID_REG_USER,Modules::REGISTERMOD);&#125; 再添加http请求回复后收到处理流程 123456789101112131415void RegisterDialog::initHttpHandlers()&#123; //...省略 //注册注册用户回包逻辑 _handlers.insert(ReqId::ID_REG_USER, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); return; &#125; auto email = jsonObj[&quot;email&quot;].toString(); showTip(tr(&quot;用户注册成功&quot;), true); qDebug()&lt;&lt; &quot;email is &quot; &lt;&lt; email ; &#125;);&#125; Server端接受注册请求Server注册user_register逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556RegPost(&quot;/user_register&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; auto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; connection-&gt;_response.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::Error_Json; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //先查找redis中email对应的验证码是否合理 std::string varify_code; bool b_get_varify = RedisMgr::GetInstance()-&gt;Get(src_root[&quot;email&quot;].asString(), varify_code); if (!b_get_varify) &#123; std::cout &lt;&lt; &quot; get varify code expired&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::VarifyExpired; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; if (varify_code != src_root[&quot;varifycode&quot;].asString()) &#123; std::cout &lt;&lt; &quot; varify code error&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::VarifyCodeErr; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //访问redis查找 bool b_usr_exist = RedisMgr::GetInstance()-&gt;ExistsKey(src_root[&quot;user&quot;].asString()); if (b_usr_exist) &#123; std::cout &lt;&lt; &quot; user exist&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::UserExist; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //查找数据库判断用户是否存在 root[&quot;error&quot;] = 0; root[&quot;email&quot;] = src_root[&quot;email&quot;]; root [&quot;user&quot;]= src_root[&quot;user&quot;].asString(); root[&quot;passwd&quot;] = src_root[&quot;passwd&quot;].asString(); root[&quot;confirm&quot;] = src_root[&quot;confirm&quot;].asString(); root[&quot;varifycode&quot;] = src_root[&quot;varifycode&quot;].asString(); std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125;); 安装Mysql先介绍Windows环境下安装mysql 点击mysql安装包下载链接：https://dev.mysql.com/downloads/mysql 选择window版本，点击下载按钮，如下所示 不用登录直接下载 下载好mysql安装包后，将其解压到指定目录，并记下解压的目录，后续用于环境变量配置 在bin目录同级下创建一个文件，命名为my.ini编辑my.ini文件 12345678910111213141516171819202122232425[mysqld]# 设置3308端口port=3308# 设置mysql的安装目录 ---这里输入你安装的文件路径----basedir=D:\\cppsoft\\mysql# 设置mysql数据库的数据的存放目录datadir=D:\\mysql\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3308default-character-set=utf8 有两点需要注意修改的： A、basedir这里输入的是mysql解压存放的文件路径 B、datadir这里设置mysql数据库的数据存放目录 打开cmd进入mysql的bin文件下 依次执行命令 第一个命令为： 12//安装mysql 安装完成后Mysql会有一个随机密码.\\mysqld.exe --initialize --console 如下图，随机密码要记住，以后我们改密码会用到 接下来在cmd执行第二条命令 12//安装mysql服务并启动 .\\mysqld.exe --install mysql 如果出现以下情况，说明cmd不是以管理员形式执行的，改用为管理员权限执行即可。 成功如下 目前为止安装完毕，大家如果mysql官网下载缓慢，可以去我的网盘下载 https://pan.baidu.com/s/1BTMZB31FWFUq4mZZdzcA9g?pwd=6xlz 提取码：6xlz 修改mysql密码1 在本机启动mysql服务： 点击桌面我的电脑，右键选择管理进去： 点击后选择服务 点击服务后可查看当前计算机启动的所有服务，找到mysql，然后右键点击设为启动，同时也可设置其为自动启动和手动启动 继续在cmd上执行以下命令 1mysql -uroot -p 回车后输入上面安装时保存的初始密码，进入mysql里面： 在mysql里面继续执行以下命令： 12//修改密码为123mysqlALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;; 回车按照指引执行完后，代表密码修改成功，再输入exit;退出即可 配置环境变量为了方便使用mysql命令，可以将mysql目录配置在环境变量里 新建系统变量： 变量名：MYSQL_HOME 变量值：msql目录 修改系统的path变量 编辑path，进去后添加 %MYSQL_HOME%\\bin 测试连接为了方便测试，大家可以使用navicat等桌面工具测试连接。以后增删改查也方便。 可以去官网下载 https://www.navicat.com.cn/ 或者我得网盘下载 https://pan.baidu.com/s/10jApYUrwaI19j345dpPGNA?pwd=77m2 验证码： 77m2 效果如下： Docker环境配置mysql拉取mysql镜像 1docker pull mysql:8.0 先启动一个测试版本，然后把他的配置文件拷贝出来 123docker run --name mysqltest \\-p 3307:3306 -e MYSQL_ROOT_PASSWORD=root \\-d mysql 创建三个目录，我得目录是 123mkdir -p /home/zack/llfc/mysql/configmkdir -p /home/zack/llfc/mysql/datamkdir -p /home/zack/llfc/mysql/logs 进入docker中 1docker exec -it mysqltest bash 之后可以通过搜寻找到配置在/etc/mysql/my.cnf 所以接下来退出容器，执行拷贝命令 1docker cp mysqltest:/etc/mysql/my.cnf /home/zack/llfc/mysql/config 然后删除测试用的mysql docker 1docker rm -f mysqltest 然后启动我们的容器 12345docker run --restart=on-failure:3 -d \\-v /home/zack/llfc/mysql/config/my.cnf:/etc/mysql/my.cnf \\-v /home/zack/llfc/mysql/data/:/var/lib/mysql \\-v /home/zack/llfc/mysql/logs:/logs -p 3308:3306 \\--name llfcmysql -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0 设置远程访问进入docker 1docker exec -it llfcmysql bash 登录mysql 1mysql -u root -p 设置允许远程访问，我不设置也能访问的，这里介绍一下。 123use mysqlALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;flush privileges; 再次用navicat连接，是可以连接上了。 完善GateServer配置添加Redis和Mysql配置 12345678[Mysql]Host = 81.68.86.146Port = 3308Passwd = 123456[Redis]Host = 81.68.86.146Port = 6380Passwd = 123456 Mysql Connector C++尽管Mysql提供了访问数据库的接口，但是都是基于C风格的，为了便于面向对象设计，我们使用Mysql Connector C++ 这个库来访问mysql。 我们先安装这个库，因为我们windows环境代码是debug版本，所以下载connector的debug版本，如果你的开发编译用的release版本，那么就要下载releas版本，否则会报错terminate called after throwing an instance of &#39;std::bad_alloc&#39;. 因为我在windows只做debug调试后期会将项目移植到Linux端，所以这里只下载debug版 下载地址 https://dev.mysql.com/downloads/connector/cpp/ 如果下载缓慢可以去我的网盘下载https://pan.baidu.com/s/1XAVhPAAzZpZahsyITua2oQ?pwd=9c1w 提取码：9c1w 下载后将文件夹解压放在一个自己常用的目录，我放在D:\\cppsoft\\mysql_connector 接下来去visual studio中配置项目 VC++ 包含目录添加D:\\cppsoft\\mysql_connector\\include 库目录包含D:\\cppsoft\\mysql_connector\\lib64\\vs14 然后将D:\\cppsoft\\mysql_connector\\lib64\\debug下的mysqlcppconn8-2-vs14.dll和mysqlcppconn9-vs14.dll分别拷贝到项目中 为了让项目自动将dll拷贝到运行目录，可以在生成事件-&gt;生成后事件中添加xcopy命令 12xcopy $(ProjectDir)config.ini $(SolutionDir)$(Platform)\\$(Configuration)\\ /yxcopy $(ProjectDir)*.dll $(SolutionDir)$(Platform)\\$(Configuration)\\ /y 封装mysql连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MySqlPool &#123;public: MySqlPool(const std::string&amp; url, const std::string&amp; user, const std::string&amp; pass, const std::string&amp; schema, int poolSize) : url_(url), user_(user), pass_(pass), schema_(schema), poolSize_(poolSize), b_stop_(false)&#123; try &#123; for (int i = 0; i &lt; poolSize_; ++i) &#123; sql::mysql::MySQL_Driver* driver = sql::mysql::get_mysql_driver_instance(); std::unique_ptr&lt;sql::Connection&gt; con(driver-&gt;connect(url_, user_, pass_)); con-&gt;setSchema(schema_); pool_.push(std::move(con)); &#125; &#125; catch (sql::SQLException&amp; e) &#123; // 处理异常 std::cout &lt;&lt; &quot;mysql pool init failed&quot; &lt;&lt; std::endl; &#125; &#125; std::unique_ptr&lt;sql::Connection&gt; getConnection() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); cond_.wait(lock, [this] &#123; if (b_stop_) &#123; return true; &#125; return !pool_.empty(); &#125;); if (b_stop_) &#123; return nullptr; &#125; std::unique_ptr&lt;sql::Connection&gt; con(std::move(pool_.front())); pool_.pop(); return con; &#125; void returnConnection(std::unique_ptr&lt;sql::Connection&gt; con) &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); if (b_stop_) &#123; return; &#125; pool_.push(std::move(con)); cond_.notify_one(); &#125; void Close() &#123; b_stop_ = true; cond_.notify_all(); &#125; ~MySqlPool() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); while (!pool_.empty()) &#123; pool_.pop(); &#125; &#125;private: std::string url_; std::string user_; std::string pass_; std::string schema_; int poolSize_; std::queue&lt;std::unique_ptr&lt;sql::Connection&gt;&gt; pool_; std::mutex mutex_; std::condition_variable cond_; std::atomic&lt;bool&gt; b_stop_;&#125;; 封装DAO操作层类的声明 123456789class MysqlDao&#123;public: MysqlDao(); ~MysqlDao(); int RegUser(const std::string&amp; name, const std::string&amp; email, const std::string&amp; pwd);private: std::unique_ptr&lt;MySqlPool&gt; pool_;&#125;; 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455MysqlDao::MysqlDao()&#123; auto &amp; cfg = ConfigMgr::Inst(); const auto&amp; host = cfg[&quot;Mysql&quot;][&quot;Host&quot;]; const auto&amp; port = cfg[&quot;Mysql&quot;][&quot;Port&quot;]; const auto&amp; pwd = cfg[&quot;Mysql&quot;][&quot;Passwd&quot;]; const auto&amp; schema = cfg[&quot;Mysql&quot;][&quot;Schema&quot;]; const auto&amp; user = cfg[&quot;Mysql&quot;][&quot;User&quot;]; pool_.reset(new MySqlPool(host+&quot;:&quot;+port, user, pwd,schema, 5));&#125;MysqlDao::~MysqlDao()&#123; pool_-&gt;Close();&#125;int MysqlDao::RegUser(const std::string&amp; name, const std::string&amp; email, const std::string&amp; pwd)&#123; auto con = pool_-&gt;getConnection(); try &#123; if (con == nullptr) &#123; pool_-&gt;returnConnection(std::move(con)); return false; &#125; // 准备调用存储过程 unique_ptr &lt; sql::PreparedStatement &gt; stmt(con-&gt;prepareStatement(&quot;CALL reg_user(?,?,?,@result)&quot;)); // 设置输入参数 stmt-&gt;setString(1, name); stmt-&gt;setString(2, email); stmt-&gt;setString(3, pwd); // 由于PreparedStatement不直接支持注册输出参数，我们需要使用会话变量或其他方法来获取输出参数的值 // 执行存储过程 stmt-&gt;execute(); // 如果存储过程设置了会话变量或有其他方式获取输出参数的值，你可以在这里执行SELECT查询来获取它们 // 例如，如果存储过程设置了一个会话变量@result来存储输出结果，可以这样获取： unique_ptr&lt;sql::Statement&gt; stmtResult(con-&gt;createStatement()); unique_ptr&lt;sql::ResultSet&gt; res(stmtResult-&gt;executeQuery(&quot;SELECT @result AS result&quot;)); if (res-&gt;next()) &#123; int result = res-&gt;getInt(&quot;result&quot;); cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; endl; pool_-&gt;returnConnection(std::move(con)); return result; &#125; pool_-&gt;returnConnection(std::move(con)); return -1; &#125; catch (sql::SQLException&amp; e) &#123; pool_-&gt;returnConnection(std::move(con)); std::cerr &lt;&lt; &quot;SQLException: &quot; &lt;&lt; e.what(); std::cerr &lt;&lt; &quot; (MySQL error code: &quot; &lt;&lt; e.getErrorCode(); std::cerr &lt;&lt; &quot;, SQLState: &quot; &lt;&lt; e.getSQLState() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl; return -1; &#125;&#125; 新建数据库llfc， llfc数据库添加user表和user_id表 user表 user_id就一行数据，用来记录用户id 这里id用简单计数表示，不考虑以后合服务器和分表分库，如果考虑大家可以采取不同的策略，雪花算法等。 新建存储过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344CREATE DEFINER=`root`@`%` PROCEDURE `reg_user`( IN `new_name` VARCHAR(255), IN `new_email` VARCHAR(255), IN `new_pwd` VARCHAR(255), OUT `result` INT)BEGIN -- 如果在执行过程中遇到任何错误，则回滚事务 DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN -- 回滚事务 ROLLBACK; -- 设置返回值为-1，表示错误 SET result = -1; END; -- 开始事务 START TRANSACTION; -- 检查用户名是否已存在 IF EXISTS (SELECT 1 FROM `user` WHERE `name` = new_name) THEN SET result = 0; -- 用户名已存在 COMMIT; ELSE -- 用户名不存在，检查email是否已存在 IF EXISTS (SELECT 1 FROM `user` WHERE `email` = new_email) THEN SET result = 0; -- email已存在 COMMIT; ELSE -- email也不存在，更新user_id表 UPDATE `user_id` SET `id` = `id` + 1; -- 获取更新后的id SELECT `id` INTO @new_id FROM `user_id`; -- 在user表中插入新记录 INSERT INTO `user` (`uid`, `name`, `email`, `pwd`) VALUES (@new_id, new_name, new_email, new_pwd); -- 设置result为新插入的uid SET result = @new_id; -- 插入成功，返回新的uid COMMIT; END IF; END IF; END 数据库管理者我们需要建立一个数据库管理者用来实现服务层，对接逻辑层的调用 123456789101112#include &quot;const.h&quot;#include &quot;MysqlDao.h&quot;class MysqlMgr: public Singleton&lt;MysqlMgr&gt;&#123; friend class Singleton&lt;MysqlMgr&gt;;public: ~MysqlMgr(); int RegUser(const std::string&amp; name, const std::string&amp; email, const std::string&amp; pwd);private: MysqlMgr(); MysqlDao _dao;&#125;; 实现 1234567891011121314#include &quot;MysqlMgr.h&quot;MysqlMgr::~MysqlMgr() &#123;&#125;int MysqlMgr::RegUser(const std::string&amp; name, const std::string&amp; email, const std::string&amp; pwd)&#123; return _dao.RegUser(name, email, pwd);&#125;MysqlMgr::MysqlMgr() &#123;&#125; 逻辑层调用在逻辑层注册消息处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768RegPost(&quot;/user_register&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; auto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; connection-&gt;_response.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::Error_Json; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; auto email = src_root[&quot;email&quot;].asString(); auto name = src_root[&quot;user&quot;].asString(); auto pwd = src_root[&quot;passwd&quot;].asString(); auto confirm = src_root[&quot;confirm&quot;].asString(); if (pwd != confirm) &#123; std::cout &lt;&lt; &quot;password err &quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::PasswdErr; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //先查找redis中email对应的验证码是否合理 std::string varify_code; bool b_get_varify = RedisMgr::GetInstance()-&gt;Get(CODEPREFIX+src_root[&quot;email&quot;].asString(), varify_code); if (!b_get_varify) &#123; std::cout &lt;&lt; &quot; get varify code expired&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::VarifyExpired; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; if (varify_code != src_root[&quot;varifycode&quot;].asString()) &#123; std::cout &lt;&lt; &quot; varify code error&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::VarifyCodeErr; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //查找数据库判断用户是否存在 int uid = MysqlMgr::GetInstance()-&gt;RegUser(name, email, pwd); if (uid == 0 || uid == -1) &#123; std::cout &lt;&lt; &quot; user or email exist&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::UserExist; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; root[&quot;error&quot;] = 0; root[&quot;uid&quot;] = uid; root[&quot;email&quot;] = email; root [&quot;user&quot;]= name; root[&quot;passwd&quot;] = pwd; root[&quot;confirm&quot;] = confirm; root[&quot;varifycode&quot;] = src_root[&quot;varifycode&quot;].asString(); std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125;); 再次启动客户端测试，可以注册成功","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(14) 封装Mysql连接池","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro14/","text":"客户端登录功能登录界面新增err_tip，用来提示用户登陆结果。至于密码输入框大家可以根据注册界面的逻辑实现隐藏和显示的功能。这里留给大家自己实现。 点击登录需要发送http 请求到GateServer，GateServer先验证登录密码，再调用grpc请求给StatusServer，获取聊天服务器ip信息和token信息反馈给客户端。 结构图如下 我们先实现客户端登录,为登录按钮添加槽函数响应 1234567891011121314151617181920void LoginDialog::on_login_btn_clicked()&#123; qDebug()&lt;&lt;&quot;login btn clicked&quot;; if(checkUserValid() == false)&#123; return; &#125; if(checkPwdValid() == false)&#123; return ; &#125; auto user = ui-&gt;user_edit-&gt;text(); auto pwd = ui-&gt;pass_edit-&gt;text(); //发送http请求登录 QJsonObject json_obj; json_obj[&quot;user&quot;] = user; json_obj[&quot;passwd&quot;] = xorString(pwd); HttpMgr::GetInstance()-&gt;PostHttpReq(QUrl(gate_url_prefix+&quot;/user_login&quot;), json_obj, ReqId::ID_LOGIN_USER,Modules::LOGINMOD);&#125; 增加检测函数 1234567891011121314151617181920bool LoginDialog::checkUserValid()&#123; auto user = ui-&gt;user_edit-&gt;text(); if(user.isEmpty())&#123; qDebug() &lt;&lt; &quot;User empty &quot; ; return false; &#125; return true;&#125;bool LoginDialog::checkPwdValid()&#123; auto pwd = ui-&gt;pass_edit-&gt;text(); if(pwd.length() &lt; 6 || pwd.length() &gt; 15)&#123; qDebug() &lt;&lt; &quot;Pass length invalid&quot;; return false; &#125; return true;&#125; 在HttpMgr中添加sig_login_mod_finish信号，收到http请求完成回包的槽函数中添加登录模块的响应，将登录模块的消息发送到登录界面 12345678910111213141516void HttpMgr::slot_http_finish(ReqId id, QString res, ErrorCodes err, Modules mod)&#123; if(mod == Modules::REGISTERMOD)&#123; //发送信号通知指定模块http响应结束 emit sig_reg_mod_finish(id, res, err); &#125; if(mod == Modules::RESETMOD)&#123; //发送信号通知指定模块http响应结束 emit sig_reset_mod_finish(id, res, err); &#125; if(mod == Modules::LOGINMOD)&#123; emit sig_login_mod_finish(id, res, err); &#125;&#125; 在LoginDialog的构造函数中添加消息对应的槽函数连接 1234567891011121314LoginDialog::LoginDialog(QWidget *parent) : QDialog(parent), ui(new Ui::LoginDialog)&#123; ui-&gt;setupUi(this); connect(ui-&gt;reg_btn, &amp;QPushButton::clicked, this, &amp;LoginDialog::switchRegister); ui-&gt;forget_label-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;&quot;,&quot;selected&quot;,&quot;selected_hover&quot;,&quot;&quot;); ui-&gt;forget_label-&gt;setCursor(Qt::PointingHandCursor); connect(ui-&gt;forget_label, &amp;ClickedLabel::clicked, this, &amp;LoginDialog::slot_forget_pwd); initHttpHandlers(); //连接登录回包信号 connect(HttpMgr::GetInstance().get(), &amp;HttpMgr::sig_login_mod_finish, this, &amp;LoginDialog::slot_login_mod_finish);&#125; initHttpHandlers为初始化http回调逻辑, 并添加_handlers成员 1234567891011121314void LoginDialog::initHttpHandlers()&#123; //注册获取登录回包逻辑 _handlers.insert(ReqId::ID_LOGIN_USER, [this](QJsonObject jsonObj)&#123; int error = jsonObj[&quot;error&quot;].toInt(); if(error != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;参数错误&quot;),false); return; &#125; auto user = jsonObj[&quot;user&quot;].toString(); showTip(tr(&quot;登录成功&quot;), true); qDebug()&lt;&lt; &quot;user is &quot; &lt;&lt; user ; &#125;);&#125; 在LoginDialog中添加槽函数slot_login_mod_finish 123456789101112131415161718192021222324252627void LoginDialog::slot_login_mod_finish(ReqId id, QString res, ErrorCodes err)&#123; if(err != ErrorCodes::SUCCESS)&#123; showTip(tr(&quot;网络请求错误&quot;),false); return; &#125; // 解析 JSON 字符串,res需转化为QByteArray QJsonDocument jsonDoc = QJsonDocument::fromJson(res.toUtf8()); //json解析错误 if(jsonDoc.isNull())&#123; showTip(tr(&quot;json解析错误&quot;),false); return; &#125; //json解析错误 if(!jsonDoc.isObject())&#123; showTip(tr(&quot;json解析错误&quot;),false); return; &#125; //调用对应的逻辑,根据id回调。 _handlers[id](jsonDoc.object()); return;&#125; 到此客户端登陆请求发送的模块封装完了 GateServer完善登陆逻辑在LogicSystem的构造函数中添加登陆请求的注册。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//用户登录逻辑RegPost(&quot;/user_login&quot;, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123; auto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; connection-&gt;_response.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::Error_Json; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; auto name = src_root[&quot;user&quot;].asString(); auto pwd = src_root[&quot;passwd&quot;].asString(); UserInfo userInfo; //查询数据库判断用户名和密码是否匹配 bool pwd_valid = MysqlMgr::GetInstance()-&gt;CheckPwd(name, pwd, userInfo); if (!pwd_valid) &#123; std::cout &lt;&lt; &quot; user pwd not match&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::PasswdInvalid; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; //查询StatusServer找到合适的连接 auto reply = StatusGrpcClient::GetInstance()-&gt;GetChatServer(userInfo.uid); if (reply.error()) &#123; std::cout &lt;&lt; &quot; grpc get chat server failed, error is &quot; &lt;&lt; reply.error()&lt;&lt; std::endl; root[&quot;error&quot;] = ErrorCodes::RPCGetFailed; std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125; std::cout &lt;&lt; &quot;succeed to load userinfo uid is &quot; &lt;&lt; userInfo.uid &lt;&lt; std::endl; root[&quot;error&quot;] = 0; root[&quot;user&quot;] = name; root[&quot;uid&quot;] = userInfo.uid; root[&quot;token&quot;] = reply.token(); root[&quot;host&quot;] = reply.host(); std::string jsonstr = root.toStyledString(); beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr; return true; &#125;); 在MysqlMgr中添加CheckPwd函数 123bool MysqlMgr::CheckPwd(const std::string&amp; name, const std::string&amp; pwd, UserInfo&amp; userInfo) &#123; return _dao.CheckPwd(name, pwd, userInfo);&#125; 在DAO层添加根据用户名查询sql逻辑,并且判断pwd是否匹配。 123456789101112131415161718192021222324252627282930313233343536373839404142bool MysqlDao::CheckPwd(const std::string&amp; name, const std::string&amp; pwd, UserInfo&amp; userInfo) &#123; auto con = pool_-&gt;getConnection(); Defer defer([this, &amp;con]() &#123; pool_-&gt;returnConnection(std::move(con)); &#125;); try &#123; if (con == nullptr) &#123; return false; &#125; // 准备SQL语句 std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(con-&gt;prepareStatement(&quot;SELECT * FROM user WHERE name = ?&quot;)); pstmt-&gt;setString(1, name); // 将username替换为你要查询的用户名 // 执行查询 std::unique_ptr&lt;sql::ResultSet&gt; res(pstmt-&gt;executeQuery()); std::string origin_pwd = &quot;&quot;; // 遍历结果集 while (res-&gt;next()) &#123; origin_pwd = res-&gt;getString(&quot;pwd&quot;); // 输出查询到的密码 std::cout &lt;&lt; &quot;Password: &quot; &lt;&lt; origin_pwd &lt;&lt; std::endl; break; &#125; if (pwd != origin_pwd) &#123; return false; &#125; userInfo.name = name; userInfo.email = res-&gt;getString(&quot;email&quot;); userInfo.uid = res-&gt;getInt(&quot;uid&quot;); userInfo.pwd = origin_pwd; return true; &#125; catch (sql::SQLException&amp; e) &#123; std::cerr &lt;&lt; &quot;SQLException: &quot; &lt;&lt; e.what(); std::cerr &lt;&lt; &quot; (MySQL error code: &quot; &lt;&lt; e.getErrorCode(); std::cerr &lt;&lt; &quot;, SQLState: &quot; &lt;&lt; e.getSQLState() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl; return false; &#125;&#125; 因为要调用grpc访问StatusServer，所以我们这里先完善协议proto文件 1234567891011121314151617181920212223242526272829303132syntax = &quot;proto3&quot;;package message;service VarifyService &#123; rpc GetVarifyCode (GetVarifyReq) returns (GetVarifyRsp) &#123;&#125;&#125;message GetVarifyReq &#123; string email = 1;&#125;message GetVarifyRsp &#123; int32 error = 1; string email = 2; string code = 3;&#125;message GetChatServerReq &#123; int32 uid = 1;&#125;message GetChatServerRsp &#123; int32 error = 1; string host = 2; string port = 3; string token = 4;&#125;service StatusService &#123; rpc GetChatServer (GetChatServerReq) returns (GetChatServerRsp) &#123;&#125;&#125; 我们用下面两条命令重新生成pb.h和grpc.pb.h 1D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe --cpp_out=. &quot;message.proto&quot; 生成grpc.pb.h 1D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe -I=&quot;.&quot; --grpc_out=&quot;.&quot; --plugin=protoc-gen-grpc=&quot;D:\\cppsoft\\grpc\\visualpro\\Debug\\grpc_cpp_plugin.exe&quot; &quot;message.proto&quot; 这俩命令执行完成后总计生成四个文件 实现StatusGrpcClient 1234567891011121314151617181920212223242526#include &quot;const.h&quot;#include &quot;Singleton.h&quot;#include &quot;ConfigMgr.h&quot;using grpc::Channel;using grpc::Status;using grpc::ClientContext;using message::GetChatServerReq;using message::GetChatServerRsp;using message::StatusService;class StatusGrpcClient :public Singleton&lt;StatusGrpcClient&gt;&#123; friend class Singleton&lt;StatusGrpcClient&gt;;public: ~StatusGrpcClient() &#123; &#125; GetChatServerRsp GetChatServer(int uid);private: StatusGrpcClient(); std::unique_ptr&lt;StatusConPool&gt; pool_; &#125;; 具体实现 1234567891011121314151617181920212223242526272829#include &quot;StatusGrpcClient.h&quot;GetChatServerRsp StatusGrpcClient::GetChatServer(int uid)&#123; ClientContext context; GetChatServerRsp reply; GetChatServerReq request; request.set_uid(uid); auto stub = pool_-&gt;getConnection(); Status status = stub-&gt;GetChatServer(&amp;context, request, &amp;reply); Defer defer([&amp;stub, this]() &#123; pool_-&gt;returnConnection(std::move(stub)); &#125;); if (status.ok()) &#123; return reply; &#125; else &#123; reply.set_error(ErrorCodes::RPCFailed); return reply; &#125;&#125;StatusGrpcClient::StatusGrpcClient()&#123; auto&amp; gCfgMgr = ConfigMgr::Inst(); std::string host = gCfgMgr[&quot;StatusServer&quot;][&quot;Host&quot;]; std::string port = gCfgMgr[&quot;StatusServer&quot;][&quot;Port&quot;]; pool_.reset(new StatusConPool(5, host, port));&#125; 当然GateServer的config.ini文件也要做更新 123456789101112131415161718[GateServer]Port = 8080[VarifyServer]Host = 127.0.0.1Port = 50051[StatusServer]Host = 127.0.0.1Port = 50052[Mysql]Host = 81.68.86.146Port = 3308User = rootPasswd = 123456Schema = llfc[Redis]Host = 81.68.86.146Port = 6380Passwd = 123456 StatusGrpcClient用到了StatusConPool, 将其实现放在StatusGrpcClient类之上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class StatusConPool &#123;public: StatusConPool(size_t poolSize, std::string host, std::string port) : poolSize_(poolSize), host_(host), port_(port), b_stop_(false) &#123; for (size_t i = 0; i &lt; poolSize_; ++i) &#123; std::shared_ptr&lt;Channel&gt; channel = grpc::CreateChannel(host + &quot;:&quot; + port, grpc::InsecureChannelCredentials()); connections_.push(StatusService::NewStub(channel)); &#125; &#125; ~StatusConPool() &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); Close(); while (!connections_.empty()) &#123; connections_.pop(); &#125; &#125; std::unique_ptr&lt;StatusService::Stub&gt; getConnection() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); cond_.wait(lock, [this] &#123; if (b_stop_) &#123; return true; &#125; return !connections_.empty(); &#125;); //如果停止则直接返回空指针 if (b_stop_) &#123; return nullptr; &#125; auto context = std::move(connections_.front()); connections_.pop(); return context; &#125; void returnConnection(std::unique_ptr&lt;StatusService::Stub&gt; context) &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); if (b_stop_) &#123; return; &#125; connections_.push(std::move(context)); cond_.notify_one(); &#125; void Close() &#123; b_stop_ = true; cond_.notify_all(); &#125;private: atomic&lt;bool&gt; b_stop_; size_t poolSize_; std::string host_; std::string port_; std::queue&lt;std::unique_ptr&lt;StatusService::Stub&gt;&gt; connections_; std::mutex mutex_; std::condition_variable cond_;&#125;; StatusServer状态服务我们要实现状态服务，主要是用来监听其他服务器的查询请求, 用visual studio创建项目，名字为StatusServer. 在主函数所在文件StatusServer.cpp中实现如下逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;json/json.h&gt;#include &lt;json/value.h&gt;#include &lt;json/reader.h&gt;#include &quot;const.h&quot;#include &quot;ConfigMgr.h&quot;#include &quot;hiredis.h&quot;#include &quot;RedisMgr.h&quot;#include &quot;MysqlMgr.h&quot;#include &quot;AsioIOServicePool.h&quot;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;boost/asio.hpp&gt;#include &quot;StatusServiceImpl.h&quot;void RunServer() &#123; auto &amp; cfg = ConfigMgr::Inst(); std::string server_address(cfg[&quot;StatusServer&quot;][&quot;Host&quot;]+&quot;:&quot;+ cfg[&quot;StatusServer&quot;][&quot;Port&quot;]); StatusServiceImpl service; grpc::ServerBuilder builder; // 监听端口和添加服务 builder.AddListeningPort(server_address, grpc::InsecureServerCredentials()); builder.RegisterService(&amp;service); // 构建并启动gRPC服务器 std::unique_ptr&lt;grpc::Server&gt; server(builder.BuildAndStart()); std::cout &lt;&lt; &quot;Server listening on &quot; &lt;&lt; server_address &lt;&lt; std::endl; // 创建Boost.Asio的io_context boost::asio::io_context io_context; // 创建signal_set用于捕获SIGINT boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); // 设置异步等待SIGINT信号 signals.async_wait([&amp;server](const boost::system::error_code&amp; error, int signal_number) &#123; if (!error) &#123; std::cout &lt;&lt; &quot;Shutting down server...&quot; &lt;&lt; std::endl; server-&gt;Shutdown(); // 优雅地关闭服务器 &#125; &#125;); // 在单独的线程中运行io_context std::thread([&amp;io_context]() &#123; io_context.run(); &#125;).detach(); // 等待服务器关闭 server-&gt;Wait(); io_context.stop(); // 停止io_context&#125;int main(int argc, char** argv) &#123; try &#123; RunServer(); &#125; catch (std::exception const&amp; e) &#123; std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; &#125; return 0;&#125; 在开始逻辑之前，我们需要先更新下config.ini文件 12345678910111213141516171819[StatusServer]Port = 50052Host = 0.0.0.0[Mysql]Host = 81.68.86.146Port = 3308User = rootPasswd = 123456Schema = llfc[Redis]Host = 81.68.86.146Port = 6380Passwd = 123456[ChatServer1]Host = 127.0.0.1Port = 8090[ChatServer2]Host = 127.0.0.1Port = 8091 然后我们将GateServer之前生成的pb文件和proto文件拷贝到StatusServer中。并且加入到项目中。 我们在项目中添加一个新的类StatusServiceImpl，该类主要继承自StatusService::Service。 1234567891011121314151617181920212223242526#include &lt;grpcpp/grpcpp.h&gt;#include &quot;message.grpc.pb.h&quot;using grpc::Server;using grpc::ServerBuilder;using grpc::ServerContext;using grpc::Status;using message::GetChatServerReq;using message::GetChatServerRsp;using message::StatusService;struct ChatServer &#123; std::string host; std::string port;&#125;;class StatusServiceImpl final : public StatusService::Service&#123;public: StatusServiceImpl(); Status GetChatServer(ServerContext* context, const GetChatServerReq* request, GetChatServerRsp* reply) override; std::vector&lt;ChatServer&gt; _servers; int _server_index;&#125;; 具体实现 1234567891011121314151617181920212223242526272829303132333435363738#include &quot;StatusServiceImpl.h&quot;#include &quot;ConfigMgr.h&quot;#include &quot;const.h&quot;std::string generate_unique_string() &#123; // 创建UUID对象 boost::uuids::uuid uuid = boost::uuids::random_generator()(); // 将UUID转换为字符串 std::string unique_string = to_string(uuid); return unique_string;&#125;Status StatusServiceImpl::GetChatServer(ServerContext* context, const GetChatServerReq* request, GetChatServerRsp* reply)&#123; std::string prefix(&quot;llfc status server has received : &quot;); _server_index = (_server_index++) % (_servers.size()); auto &amp;server = _servers[_server_index]; reply-&gt;set_host(server.host); reply-&gt;set_port(server.port); reply-&gt;set_error(ErrorCodes::Success); reply-&gt;set_token(generate_unique_string()); return Status::OK;&#125;StatusServiceImpl::StatusServiceImpl():_server_index(0)&#123; auto&amp; cfg = ConfigMgr::Inst(); ChatServer server; server.port = cfg[&quot;ChatServer1&quot;][&quot;Port&quot;]; server.host = cfg[&quot;ChatServer1&quot;][&quot;Host&quot;]; _servers.push_back(server); server.port = cfg[&quot;ChatServer2&quot;][&quot;Port&quot;]; server.host = cfg[&quot;ChatServer2&quot;][&quot;Host&quot;]; _servers.push_back(server);&#125; 其余的文件为了保持复用，我们不重复开发，将GateServer中的RedisMgr,MysqlMgr,Singleton,IOSerivePool等统统拷贝过来并添加到项目中。 联调测试我们启动StatusServer，GateServer以及QT客户端，输入密码和用户名，点击登陆，会看到前端收到登陆成功的消息","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(25) 实现好友申请界面","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro25/","text":"简介本文介绍如何实现好友申请界面, 其效果如下图所示 在此之前我们需要先定义一个ClickedOnceLabel类，支持点击一次的label功能。 接着新增一个ClickedOnceLabel类 123456789class ClickedOnceLabel : public QLabel&#123; Q_OBJECTpublic: ClickedOnceLabel(QWidget *parent=nullptr); virtual void mouseReleaseEvent(QMouseEvent *ev) override;signals: void clicked(QString);&#125;; 实现 123456789101112131415ClickedOnceLabel::ClickedOnceLabel(QWidget *parent):QLabel(parent)&#123; setCursor(Qt::PointingHandCursor);&#125;void ClickedOnceLabel::mouseReleaseEvent(QMouseEvent *event)&#123; if (event-&gt;button() == Qt::LeftButton) &#123; emit clicked(this-&gt;text()); return; &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QLabel::mousePressEvent(event);&#125; 完善ClickedLabel我们之前实现了ClickedLabel类，接下来修改下clicked信号，使其携带参数 1void clicked(QString, ClickLbState); 然后在其实现的鼠标释放事件的逻辑中添加 123456789101112131415161718192021void ClickedLabel::mouseReleaseEvent(QMouseEvent *event)&#123; if (event-&gt;button() == Qt::LeftButton) &#123; if(_curstate == ClickLbState::Normal)&#123; // qDebug()&lt;&lt;&quot;ReleaseEvent , change to normal hover: &quot;&lt;&lt; _normal_hover; setProperty(&quot;state&quot;,_normal_hover); repolish(this); update(); &#125;else&#123; // qDebug()&lt;&lt;&quot;ReleaseEvent , change to select hover: &quot;&lt;&lt; _selected_hover; setProperty(&quot;state&quot;,_selected_hover); repolish(this); update(); &#125; emit clicked(this-&gt;text(), _curstate); return; &#125; // 调用基类的mousePressEvent以保证正常的事件处理 QLabel::mousePressEvent(event);&#125; 好友申请好友申请界面和逻辑，我们可以创建一个设计师界面类叫做ApplyFriend类，我们在类的声明中添加如下成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class ApplyFriend : public QDialog&#123; Q_OBJECTpublic: explicit ApplyFriend(QWidget *parent = nullptr); ~ApplyFriend(); void InitTipLbs(); void AddTipLbs(ClickedLabel*, QPoint cur_point, QPoint &amp;next_point, int text_width, int text_height); bool eventFilter(QObject *obj, QEvent *event); void SetSearchInfo(std::shared_ptr&lt;SearchInfo&gt; si);private: Ui::ApplyFriend *ui; void resetLabels(); //已经创建好的标签 QMap&lt;QString, ClickedLabel*&gt; _add_labels; std::vector&lt;QString&gt; _add_label_keys; QPoint _label_point; //用来在输入框显示添加新好友的标签 QMap&lt;QString, FriendLabel*&gt; _friend_labels; std::vector&lt;QString&gt; _friend_label_keys; void addLabel(QString name); std::vector&lt;QString&gt; _tip_data; QPoint _tip_cur_point; std::shared_ptr&lt;SearchInfo&gt; _si;public slots: //显示更多label标签 void ShowMoreLabel(); //输入label按下回车触发将标签加入展示栏 void SlotLabelEnter(); //点击关闭，移除展示栏好友便签 void SlotRemoveFriendLabel(QString); //通过点击tip实现增加和减少好友便签 void SlotChangeFriendLabelByTip(QString, ClickLbState); //输入框文本变化显示不同提示 void SlotLabelTextChange(const QString&amp; text); //输入框输入完成 void SlotLabelEditFinished(); //输入标签显示提示框，点击提示框内容后添加好友便签 void SlotAddFirendLabelByClickTip(QString text); //处理确认回调 void SlotApplySure(); //处理取消回调 void SlotApplyCancel();&#125;; 接下来我们修改ui使其变成如下布局 然后我们逐个实现功能,构造函数分别实现信号的链接和成员初始化，析构函数回收必要的资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ApplyFriend::ApplyFriend(QWidget *parent) : QDialog(parent), ui(new Ui::ApplyFriend),_label_point(2,6)&#123; ui-&gt;setupUi(this); // 隐藏对话框标题栏 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); this-&gt;setObjectName(&quot;ApplyFriend&quot;); this-&gt;setModal(true); ui-&gt;name_ed-&gt;setPlaceholderText(tr(&quot;恋恋风辰&quot;)); ui-&gt;lb_ed-&gt;setPlaceholderText(&quot;搜索、添加标签&quot;); ui-&gt;back_ed-&gt;setPlaceholderText(&quot;燃烧的胸毛&quot;); ui-&gt;lb_ed-&gt;SetMaxLength(21); ui-&gt;lb_ed-&gt;move(2, 2); ui-&gt;lb_ed-&gt;setFixedHeight(20); ui-&gt;lb_ed-&gt;setMaxLength(10); ui-&gt;input_tip_wid-&gt;hide(); _tip_cur_point = QPoint(5, 5); _tip_data = &#123; &quot;同学&quot;,&quot;家人&quot;,&quot;菜鸟教程&quot;,&quot;C++ Primer&quot;,&quot;Rust 程序设计&quot;, &quot;父与子学Python&quot;,&quot;nodejs开发指南&quot;,&quot;go 语言开发指南&quot;, &quot;游戏伙伴&quot;,&quot;金融投资&quot;,&quot;微信读书&quot;,&quot;拼多多拼友&quot; &#125;; connect(ui-&gt;more_lb, &amp;ClickedOnceLabel::clicked, this, &amp;ApplyFriend::ShowMoreLabel); InitTipLbs(); //链接输入标签回车事件 connect(ui-&gt;lb_ed, &amp;CustomizeEdit::returnPressed, this, &amp;ApplyFriend::SlotLabelEnter); connect(ui-&gt;lb_ed, &amp;CustomizeEdit::textChanged, this, &amp;ApplyFriend::SlotLabelTextChange); connect(ui-&gt;lb_ed, &amp;CustomizeEdit::editingFinished, this, &amp;ApplyFriend::SlotLabelEditFinished); connect(ui-&gt;tip_lb, &amp;ClickedOnceLabel::clicked, this, &amp;ApplyFriend::SlotAddFirendLabelByClickTip); ui-&gt;scrollArea-&gt;horizontalScrollBar()-&gt;setHidden(true); ui-&gt;scrollArea-&gt;verticalScrollBar()-&gt;setHidden(true); ui-&gt;scrollArea-&gt;installEventFilter(this); ui-&gt;sure_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); ui-&gt;cancel_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); //连接确认和取消按钮的槽函数 connect(ui-&gt;cancel_btn, &amp;QPushButton::clicked, this, &amp;ApplyFriend::SlotApplyCancel); connect(ui-&gt;sure_btn, &amp;QPushButton::clicked, this, &amp;ApplyFriend::SlotApplySure);&#125;ApplyFriend::~ApplyFriend()&#123; qDebug()&lt;&lt; &quot;ApplyFriend destruct&quot;; delete ui;&#125; 因为此时还未与服务器联调数据，此时我们写一个InitLabel的函数模拟创建多个标签展示 123456789101112131415161718192021222324252627282930313233343536void ApplyFriend::InitTipLbs()&#123; int lines = 1; for(int i = 0; i &lt; _tip_data.size(); i++)&#123; auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(_tip_data[i]); connect(lb, &amp;ClickedLabel::clicked, this, &amp;ApplyFriend::SlotChangeFriendLabelByTip); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 if (_tip_cur_point.x() + textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;width()) &#123; lines++; if (lines &gt; 2) &#123; delete lb; return; &#125; _tip_cur_point.setX(tip_offset); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; auto next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point,next_point, textWidth, textHeight); _tip_cur_point = next_point; &#125;&#125; 下面这个函数是将标签添加到展示区 123456789void ApplyFriend::AddTipLbs(ClickedLabel* lb, QPoint cur_point, QPoint&amp; next_point, int text_width, int text_height)&#123; lb-&gt;move(cur_point); lb-&gt;show(); _add_labels.insert(lb-&gt;text(), lb); _add_label_keys.push_back(lb-&gt;text()); next_point.setX(lb-&gt;pos().x() + text_width + 15); next_point.setY(lb-&gt;pos().y());&#125; 重写事件过滤器展示滑动条 123456789101112bool ApplyFriend::eventFilter(QObject *obj, QEvent *event)&#123; if (obj == ui-&gt;scrollArea &amp;&amp; event-&gt;type() == QEvent::Enter) &#123; ui-&gt;scrollArea-&gt;verticalScrollBar()-&gt;setHidden(false); &#125; else if (obj == ui-&gt;scrollArea &amp;&amp; event-&gt;type() == QEvent::Leave) &#123; ui-&gt;scrollArea-&gt;verticalScrollBar()-&gt;setHidden(true); &#125; return QObject::eventFilter(obj, event);&#125; 后期搜索用户功能用户数据会从服务器传回来，所以写了下面的接口 12345678void ApplyFriend::SetSearchInfo(std::shared_ptr&lt;SearchInfo&gt; si)&#123; _si = si; auto applyname = UserMgr::GetInstance()-&gt;GetName(); auto bakname = si-&gt;_name; ui-&gt;name_ed-&gt;setText(applyname); ui-&gt;back_ed-&gt;setText(bakname);&#125; 当点击按钮，可展示更多标签的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void ApplyFriend::ShowMoreLabel()&#123; qDebug()&lt;&lt; &quot;receive more label clicked&quot;; ui-&gt;more_lb_wid-&gt;hide(); ui-&gt;lb_list-&gt;setFixedWidth(325); _tip_cur_point = QPoint(5, 5); auto next_point = _tip_cur_point; int textWidth; int textHeight; //重拍现有的label for(auto &amp; added_key : _add_label_keys)&#123; auto added_lb = _add_labels[added_key]; QFontMetrics fontMetrics(added_lb-&gt;font()); // 获取QLabel控件的字体信息 textWidth = fontMetrics.width(added_lb-&gt;text()); // 获取文本的宽度 textHeight = fontMetrics.height(); // 获取文本的高度 if(_tip_cur_point.x() +textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;width())&#123; _tip_cur_point.setX(tip_offset); _tip_cur_point.setY(_tip_cur_point.y()+textHeight+15); &#125; added_lb-&gt;move(_tip_cur_point); next_point.setX(added_lb-&gt;pos().x() + textWidth + 15); next_point.setY(_tip_cur_point.y()); _tip_cur_point = next_point; &#125; //添加未添加的 for(int i = 0; i &lt; _tip_data.size(); i++)&#123; auto iter = _add_labels.find(_tip_data[i]); if(iter != _add_labels.end())&#123; continue; &#125; auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(_tip_data[i]); connect(lb, &amp;ClickedLabel::clicked, this, &amp;ApplyFriend::SlotChangeFriendLabelByTip); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 if (_tip_cur_point.x() + textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;width()) &#123; _tip_cur_point.setX(tip_offset); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point, next_point, textWidth, textHeight); _tip_cur_point = next_point; &#125; int diff_height = next_point.y() + textHeight + tip_offset - ui-&gt;lb_list-&gt;height(); ui-&gt;lb_list-&gt;setFixedHeight(next_point.y() + textHeight + tip_offset); //qDebug()&lt;&lt;&quot;after resize ui-&gt;lb_list size is &quot; &lt;&lt; ui-&gt;lb_list-&gt;size(); ui-&gt;scrollcontent-&gt;setFixedHeight(ui-&gt;scrollcontent-&gt;height()+diff_height);&#125; 重排好友标签编辑栏的标签 123456789101112131415161718192021222324252627282930void ApplyFriend::resetLabels()&#123; auto max_width = ui-&gt;gridWidget-&gt;width(); auto label_height = 0; for(auto iter = _friend_labels.begin(); iter != _friend_labels.end(); iter++)&#123; //todo... 添加宽度统计 if( _label_point.x() + iter.value()-&gt;width() &gt; max_width) &#123; _label_point.setY(_label_point.y()+iter.value()-&gt;height()+6); _label_point.setX(2); &#125; iter.value()-&gt;move(_label_point); iter.value()-&gt;show(); _label_point.setX(_label_point.x()+iter.value()-&gt;width()+2); _label_point.setY(_label_point.y()); label_height = iter.value()-&gt;height(); &#125; if(_friend_labels.isEmpty())&#123; ui-&gt;lb_ed-&gt;move(_label_point); return; &#125; if(_label_point.x() + MIN_APPLY_LABEL_ED_LEN &gt; ui-&gt;gridWidget-&gt;width())&#123; ui-&gt;lb_ed-&gt;move(2,_label_point.y()+label_height+6); &#125;else&#123; ui-&gt;lb_ed-&gt;move(_label_point); &#125;&#125; 添加好友标签编辑栏的标签 12345678910111213141516171819202122232425262728293031323334353637383940414243void ApplyFriend::addLabel(QString name)&#123; if (_friend_labels.find(name) != _friend_labels.end()) &#123; return; &#125; auto tmplabel = new FriendLabel(ui-&gt;gridWidget); tmplabel-&gt;SetText(name); tmplabel-&gt;setObjectName(&quot;FriendLabel&quot;); auto max_width = ui-&gt;gridWidget-&gt;width(); //todo... 添加宽度统计 if (_label_point.x() + tmplabel-&gt;width() &gt; max_width) &#123; _label_point.setY(_label_point.y() + tmplabel-&gt;height() + 6); _label_point.setX(2); &#125; else &#123; &#125; tmplabel-&gt;move(_label_point); tmplabel-&gt;show(); _friend_labels[tmplabel-&gt;Text()] = tmplabel; _friend_label_keys.push_back(tmplabel-&gt;Text()); connect(tmplabel, &amp;FriendLabel::sig_close, this, &amp;ApplyFriend::SlotRemoveFriendLabel); _label_point.setX(_label_point.x() + tmplabel-&gt;width() + 2); if (_label_point.x() + MIN_APPLY_LABEL_ED_LEN &gt; ui-&gt;gridWidget-&gt;width()) &#123; ui-&gt;lb_ed-&gt;move(2, _label_point.y() + tmplabel-&gt;height() + 2); &#125; else &#123; ui-&gt;lb_ed-&gt;move(_label_point); &#125; ui-&gt;lb_ed-&gt;clear(); if (ui-&gt;gridWidget-&gt;height() &lt; _label_point.y() + tmplabel-&gt;height() + 2) &#123; ui-&gt;gridWidget-&gt;setFixedHeight(_label_point.y() + tmplabel-&gt;height() * 2 + 2); &#125;&#125; 点击回车后，在好友标签编辑栏添加标签，在标签展示栏添加标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void ApplyFriend::SlotLabelEnter()&#123; if(ui-&gt;lb_ed-&gt;text().isEmpty())&#123; return; &#125; auto text = ui-&gt;lb_ed-&gt;text(); addLabel(ui-&gt;lb_ed-&gt;text()); ui-&gt;input_tip_wid-&gt;hide(); auto find_it = std::find(_tip_data.begin(), _tip_data.end(), text); //找到了就只需设置状态为选中即可 if (find_it == _tip_data.end()) &#123; _tip_data.push_back(text); &#125; //判断标签展示栏是否有该标签 auto find_add = _add_labels.find(text); if (find_add != _add_labels.end()) &#123; find_add.value()-&gt;SetCurState(ClickLbState::Selected); return; &#125; //标签展示栏也增加一个标签, 并设置绿色选中 auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(text); connect(lb, &amp;ClickedLabel::clicked, this, &amp;ApplyFriend::SlotChangeFriendLabelByTip); qDebug() &lt;&lt; &quot;ui-&gt;lb_list-&gt;width() is &quot; &lt;&lt; ui-&gt;lb_list-&gt;width(); qDebug() &lt;&lt; &quot;_tip_cur_point.x() is &quot; &lt;&lt; _tip_cur_point.x(); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 qDebug() &lt;&lt; &quot;textWidth is &quot; &lt;&lt; textWidth; if (_tip_cur_point.x() + textWidth + tip_offset + 3 &gt; ui-&gt;lb_list-&gt;width()) &#123; _tip_cur_point.setX(5); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; auto next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point, next_point, textWidth, textHeight); _tip_cur_point = next_point; int diff_height = next_point.y() + textHeight + tip_offset - ui-&gt;lb_list-&gt;height(); ui-&gt;lb_list-&gt;setFixedHeight(next_point.y() + textHeight + tip_offset); lb-&gt;SetCurState(ClickLbState::Selected); ui-&gt;scrollcontent-&gt;setFixedHeight(ui-&gt;scrollcontent-&gt;height() + diff_height);&#125; 当我们点击好友标签编辑栏的标签的关闭按钮时会调用下面的槽函数 12345678910111213141516171819202122232425262728293031323334353637383940void ApplyFriend::SlotRemoveFriendLabel(QString name)&#123; qDebug() &lt;&lt; &quot;receive close signal&quot;; _label_point.setX(2); _label_point.setY(6); auto find_iter = _friend_labels.find(name); if(find_iter == _friend_labels.end())&#123; return; &#125; auto find_key = _friend_label_keys.end(); for(auto iter = _friend_label_keys.begin(); iter != _friend_label_keys.end(); iter++)&#123; if(*iter == name)&#123; find_key = iter; break; &#125; &#125; if(find_key != _friend_label_keys.end())&#123; _friend_label_keys.erase(find_key); &#125; delete find_iter.value(); _friend_labels.erase(find_iter); resetLabels(); auto find_add = _add_labels.find(name); if(find_add == _add_labels.end())&#123; return; &#125; find_add.value()-&gt;ResetNormalState();&#125; 当我们点击标签展示栏的标签，可以实现标签添加和删除 123456789101112131415161718192021//点击标已有签添加或删除新联系人的标签void ApplyFriend::SlotChangeFriendLabelByTip(QString lbtext, ClickLbState state)&#123; auto find_iter = _add_labels.find(lbtext); if(find_iter == _add_labels.end())&#123; return; &#125; if(state == ClickLbState::Selected)&#123; //编写添加逻辑 addLabel(lbtext); return; &#125; if(state == ClickLbState::Normal)&#123; //编写删除逻辑 SlotRemoveFriendLabel(lbtext); return; &#125;&#125; 当标签文本变化时，下面提示框的文本跟随变化 123456789101112131415161718void ApplyFriend::SlotLabelTextChange(const QString&amp; text)&#123; if (text.isEmpty()) &#123; ui-&gt;tip_lb-&gt;setText(&quot;&quot;); ui-&gt;input_tip_wid-&gt;hide(); return; &#125; auto iter = std::find(_tip_data.begin(), _tip_data.end(), text); if (iter == _tip_data.end()) &#123; auto new_text = add_prefix + text; ui-&gt;tip_lb-&gt;setText(new_text); ui-&gt;input_tip_wid-&gt;show(); return; &#125; ui-&gt;tip_lb-&gt;setText(text); ui-&gt;input_tip_wid-&gt;show();&#125; 如果编辑完成，则隐藏编辑框 1234void ApplyFriend::SlotLabelEditFinished()&#123; ui-&gt;input_tip_wid-&gt;hide();&#125; 点击提示框，也会添加标签，功能如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void ApplyFriend::SlotAddFirendLabelByClickTip(QString text)&#123; int index = text.indexOf(add_prefix); if (index != -1) &#123; text = text.mid(index + add_prefix.length()); &#125; addLabel(text); auto find_it = std::find(_tip_data.begin(), _tip_data.end(), text); //找到了就只需设置状态为选中即可 if (find_it == _tip_data.end()) &#123; _tip_data.push_back(text); &#125; //判断标签展示栏是否有该标签 auto find_add = _add_labels.find(text); if (find_add != _add_labels.end()) &#123; find_add.value()-&gt;SetCurState(ClickLbState::Selected); return; &#125; //标签展示栏也增加一个标签, 并设置绿色选中 auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(text); connect(lb, &amp;ClickedLabel::clicked, this, &amp;ApplyFriend::SlotChangeFriendLabelByTip); qDebug() &lt;&lt; &quot;ui-&gt;lb_list-&gt;width() is &quot; &lt;&lt; ui-&gt;lb_list-&gt;width(); qDebug() &lt;&lt; &quot;_tip_cur_point.x() is &quot; &lt;&lt; _tip_cur_point.x(); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 qDebug() &lt;&lt; &quot;textWidth is &quot; &lt;&lt; textWidth; if (_tip_cur_point.x() + textWidth+ tip_offset+3 &gt; ui-&gt;lb_list-&gt;width()) &#123; _tip_cur_point.setX(5); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; auto next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point, next_point, textWidth,textHeight); _tip_cur_point = next_point; int diff_height = next_point.y() + textHeight + tip_offset - ui-&gt;lb_list-&gt;height(); ui-&gt;lb_list-&gt;setFixedHeight(next_point.y() + textHeight + tip_offset); lb-&gt;SetCurState(ClickLbState::Selected); ui-&gt;scrollcontent-&gt;setFixedHeight(ui-&gt;scrollcontent-&gt;height()+ diff_height );&#125; 确认申请和取消申请只是打印了对应信息，并且回收界面 12345678910111213void ApplyFriend::SlotApplyCancel()&#123; qDebug() &lt;&lt; &quot;Slot Apply Cancel&quot;; this-&gt;hide(); deleteLater();&#125;void ApplyFriend::SlotApplySure()&#123; qDebug()&lt;&lt;&quot;Slot Apply Sure called&quot; ; this-&gt;hide(); deleteLater();&#125; 美化界面添加如下qss文件美化界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#ApplyFriend&#123; border: 2px solid #f1f1f1; font-size: 14px; background: #f7f7f8;&#125;#scrollArea&#123; background: #f7f7f8; border: none;&#125;#scrollcontent&#123; background: #f7f7f8;&#125;#scrollcontent #apply_lb&#123; font-family: &quot;Microsoft YaHei&quot;; font-size: 16px; font-weight: normal;&#125;#apply_wid QLabel&#123; color:rgb(140,140,140); font-size: 14px; font-family: &quot;Microsoft YaHei&quot;; height: 25px;&#125;#apply_wid #name_ed, #apply_wid #back_ed&#123; border: 1px solid #f7f7f8; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;;&#125;#apply_wid #lb_ed &#123; border: none; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;;&#125;#apply_wid #more_lb&#123; border-image: url(:/res/arowdown.png);&#125;#apply_wid #tipslb[state=&#x27;normal&#x27;] &#123; padding: 2px; background: #e1e1e1; color: #1e1e1e; border-radius: 10px;&#125;#apply_wid #tipslb[state=&#x27;hover&#x27;] &#123; padding: 2px; background: #e1e1e1; color: #1e1e1e; border-radius: 10px;&#125;#apply_wid #tipslb[state=&#x27;pressed&#x27;] &#123; padding: 2px; background: #e1e1e1; color: #48bf56; border-radius: 10px;&#125;#apply_wid #tipslb[state=&#x27;selected_normal&#x27;] &#123; padding: 2px; background: #e1e1e1; color: #48bf56; border-radius: 10px;&#125;#apply_wid #tipslb[state=&#x27;selected_hover&#x27;] &#123; padding: 2px; background: #e1e1e1; color: #48bf56; border-radius: 10px;&#125;#apply_wid #tipslb[state=&#x27;selected_pressed&#x27;] &#123; padding: 2px; background: #e1e1e1; color: #1e1e1e; border-radius: 10px;&#125;#input_tip_wid &#123; background: #d3eaf8;&#125;#apply_wid #FriendLabel &#123; background: #daf6e7; color: #48bf56; border-radius: 10px;&#125;#apply_wid #tip_lb &#123; padding-left: 2px; color:rgb(153,153,153); font-size: 14px; font-family: &quot;Microsoft YaHei&quot;;&#125;#gridWidget &#123; background: #fdfdfd;&#125;#close_lb[state=&#x27;normal&#x27;] &#123; border-image: url(:/res/tipclose.png);&#125;#close_lb[state=&#x27;hover&#x27;] &#123; border-image: url(:/res/tipclose.png);&#125;#close_lb[state=&#x27;pressed&#x27;] &#123; border-image: url(:/res/tipclose.png);&#125;#close_lb[state=&#x27;select_normal&#x27;] &#123; border-image: url(:/res/tipclose.png);&#125;#close_lb[state=&#x27;select_hover&#x27;] &#123; border-image: url(:/res/tipclose.png);&#125;#close_lb[state=&#x27;select_pressed&#x27;] &#123; border-image: url(:/res/tipclose.png);&#125;#apply_sure_wid #sure_btn[state=&#x27;normal&#x27;] &#123; background: #f0f0f0; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#apply_sure_wid #sure_btn[state=&#x27;hover&#x27;] &#123; background: #d2d2d2; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#apply_sure_wid #sure_btn[state=&#x27;press&#x27;] &#123; background: #c6c6c6; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#apply_sure_wid #cancel_btn[state=&#x27;normal&#x27;] &#123; background: #f0f0f0; color: #2e2f30; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#apply_sure_wid #cancel_btn[state=&#x27;hover&#x27;] &#123; background: #d2d2d2; color: #2e2f30; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#apply_sure_wid #cancel_btn[state=&#x27;press&#x27;] &#123; background: #c6c6c6; color: #2e2f30; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125; 视频https://www.bilibili.com/video/BV1ZM4m127z8/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接https://gitee.com/secondtonone1/llfcchat","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(26) 实现联系人和好友申请列表","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro26/","text":"简介今日实现界面效果 联系人列表我们自定义一个ChatUserList类，用来管理聊天列表。其声明如下： 12345678910111213141516171819202122232425class ContactUserList : public QListWidget&#123; Q_OBJECTpublic: ContactUserList(QWidget *parent = nullptr); void ShowRedPoint(bool bshow = true);protected: bool eventFilter(QObject *watched, QEvent *event) override ;private: void addContactUserList();public slots: void slot_item_clicked(QListWidgetItem *item);// void slot_add_auth_firend(std::shared_ptr&lt;AuthInfo&gt;);// void slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt;);signals: void sig_loading_contact_user(); void sig_switch_apply_friend_page(); void sig_switch_friend_info_page();private: ConUserItem* _add_friend_item; QListWidgetItem * _groupitem;&#125;; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157ContactUserList::ContactUserList(QWidget *parent)&#123; Q_UNUSED(parent); this-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); // 安装事件过滤器 this-&gt;viewport()-&gt;installEventFilter(this); //模拟从数据库或者后端传输过来的数据,进行列表加载 addContactUserList(); //连接点击的信号和槽 connect(this, &amp;QListWidget::itemClicked, this, &amp;ContactUserList::slot_item_clicked);// //链接对端同意认证后通知的信号// connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_add_auth_friend,this,// &amp;ContactUserList::slot_add_auth_firend);// //链接自己点击同意认证后界面刷新// connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_auth_rsp,this,// &amp;ContactUserList::slot_auth_rsp);&#125;void ContactUserList::ShowRedPoint(bool bshow /*= true*/)&#123; _add_friend_item-&gt;ShowRedPoint(bshow);&#125;void ContactUserList::addContactUserList()&#123; auto * groupTip = new GroupTipItem(); QListWidgetItem *item = new QListWidgetItem; item-&gt;setSizeHint(groupTip-&gt;sizeHint()); this-&gt;addItem(item); this-&gt;setItemWidget(item, groupTip); item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsSelectable); _add_friend_item = new ConUserItem(); _add_friend_item-&gt;setObjectName(&quot;new_friend_item&quot;); _add_friend_item-&gt;SetInfo(0,tr(&quot;新的朋友&quot;),&quot;:/res/add_friend.png&quot;); _add_friend_item-&gt;SetItemType(ListItemType::APPLY_FRIEND_ITEM); QListWidgetItem *add_item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); add_item-&gt;setSizeHint(_add_friend_item-&gt;sizeHint()); this-&gt;addItem(add_item); this-&gt;setItemWidget(add_item, _add_friend_item); //默认设置新的朋友申请条目被选中 this-&gt;setCurrentItem(add_item); auto * groupCon = new GroupTipItem(); groupCon-&gt;SetGroupTip(tr(&quot;联系人&quot;)); _groupitem = new QListWidgetItem; _groupitem-&gt;setSizeHint(groupCon-&gt;sizeHint()); this-&gt;addItem(_groupitem); this-&gt;setItemWidget(_groupitem, groupCon); _groupitem-&gt;setFlags(_groupitem-&gt;flags() &amp; ~Qt::ItemIsSelectable); // 创建QListWidgetItem，并设置自定义的widget for(int i = 0; i &lt; 13; i++)&#123; int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int str_i = randomValue%strs.size(); int head_i = randomValue%heads.size(); int name_i = randomValue%names.size(); auto *con_user_wid = new ConUserItem(); con_user_wid-&gt;SetInfo(0,names[name_i], heads[head_i]); QListWidgetItem *item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(con_user_wid-&gt;sizeHint()); this-&gt;addItem(item); this-&gt;setItemWidget(item, con_user_wid); &#125;&#125;bool ContactUserList::eventFilter(QObject *watched, QEvent *event)&#123; // 检查事件是否是鼠标悬浮进入或离开 if (watched == this-&gt;viewport()) &#123; if (event-&gt;type() == QEvent::Enter) &#123; // 鼠标悬浮，显示滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); &#125; else if (event-&gt;type() == QEvent::Leave) &#123; // 鼠标离开，隐藏滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); &#125; &#125; // 检查事件是否是鼠标滚轮事件 if (watched == this-&gt;viewport() &amp;&amp; event-&gt;type() == QEvent::Wheel) &#123; QWheelEvent *wheelEvent = static_cast&lt;QWheelEvent*&gt;(event); int numDegrees = wheelEvent-&gt;angleDelta().y() / 8; int numSteps = numDegrees / 15; // 计算滚动步数 // 设置滚动幅度 this-&gt;verticalScrollBar()-&gt;setValue(this-&gt;verticalScrollBar()-&gt;value() - numSteps); // 检查是否滚动到底部 QScrollBar *scrollBar = this-&gt;verticalScrollBar(); int maxScrollValue = scrollBar-&gt;maximum(); int currentValue = scrollBar-&gt;value(); //int pageSize = 10; // 每页加载的联系人数量 if (maxScrollValue - currentValue &lt;= 0) &#123; // 滚动到底部，加载新的联系人 qDebug()&lt;&lt;&quot;load more contact user&quot;; //发送信号通知聊天界面加载更多聊天内容 emit sig_loading_contact_user(); &#125; return true; // 停止事件传递 &#125; return QListWidget::eventFilter(watched, event);&#125;void ContactUserList::slot_item_clicked(QListWidgetItem *item)&#123; QWidget *widget = this-&gt;itemWidget(item); // 获取自定义widget对象 if(!widget)&#123; qDebug()&lt;&lt; &quot;slot item clicked widget is nullptr&quot;; return; &#125; // 对自定义widget进行操作， 将item 转化为基类ListItemBase ListItemBase *customItem = qobject_cast&lt;ListItemBase*&gt;(widget); if(!customItem)&#123; qDebug()&lt;&lt; &quot;slot item clicked widget is nullptr&quot;; return; &#125; auto itemType = customItem-&gt;GetItemType(); if(itemType == ListItemType::INVALID_ITEM || itemType == ListItemType::GROUP_TIP_ITEM)&#123; qDebug()&lt;&lt; &quot;slot invalid item clicked &quot;; return; &#125; if(itemType == ListItemType::APPLY_FRIEND_ITEM)&#123; // 创建对话框，提示用户 qDebug()&lt;&lt; &quot;apply friend item clicked &quot;; //跳转到好友申请界面 emit sig_switch_apply_friend_page(); return; &#125; if(itemType == ListItemType::CONTACT_USER_ITEM)&#123; // 创建对话框，提示用户 qDebug()&lt;&lt; &quot;contact user item clicked &quot;; //跳转到好友申请界面 emit sig_switch_friend_info_page(); return; &#125;&#125; 构造函数中关闭了滚动条的显示，重写了事件过滤器，实现了根据鼠标区域判断是否显示滚动条的功能。 并且实现了点击其中某个item响应对应的功能。并根据不同的item类型跳转不同的页面。 联系人item因为每一个item都是我们自己定义的，所以我们添加设计师界面类，界面布局如下所示 类的声明如下 12345678910111213141516class ConUserItem : public ListItemBase&#123; Q_OBJECTpublic: explicit ConUserItem(QWidget *parent = nullptr); ~ConUserItem(); QSize sizeHint() const override; void SetInfo(std::shared_ptr&lt;AuthInfo&gt; auth_info); void SetInfo(std::shared_ptr&lt;AuthRsp&gt; auth_rsp); void SetInfo(int uid, QString name, QString icon); void ShowRedPoint(bool show = false);private: Ui::ConUserItem *ui; std::shared_ptr&lt;UserInfo&gt; _info;&#125;; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ConUserItem::ConUserItem(QWidget *parent) : ListItemBase(parent), ui(new Ui::ConUserItem)&#123; ui-&gt;setupUi(this); SetItemType(ListItemType::CONTACT_USER_ITEM); ui-&gt;red_point-&gt;raise(); ShowRedPoint(true);&#125;ConUserItem::~ConUserItem()&#123; delete ui;&#125;QSize ConUserItem::sizeHint() const&#123; return QSize(250, 70); // 返回自定义的尺寸&#125;void ConUserItem::SetInfo(std::shared_ptr&lt;AuthInfo&gt; auth_info)&#123; _info = std::make_shared&lt;UserInfo&gt;(auth_info); // 加载图片 QPixmap pixmap(_info-&gt;_icon); // 设置图片自动缩放 ui-&gt;icon_lb-&gt;setPixmap(pixmap.scaled(ui-&gt;icon_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation)); ui-&gt;icon_lb-&gt;setScaledContents(true); ui-&gt;user_name_lb-&gt;setText(_info-&gt;_name);&#125;void ConUserItem::SetInfo(int uid, QString name, QString icon)&#123; _info = std::make_shared&lt;UserInfo&gt;(uid,name, icon); // 加载图片 QPixmap pixmap(_info-&gt;_icon); // 设置图片自动缩放 ui-&gt;icon_lb-&gt;setPixmap(pixmap.scaled(ui-&gt;icon_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation)); ui-&gt;icon_lb-&gt;setScaledContents(true); ui-&gt;user_name_lb-&gt;setText(_info-&gt;_name);&#125;void ConUserItem::SetInfo(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)&#123; _info = std::make_shared&lt;UserInfo&gt;(auth_rsp); // 加载图片 QPixmap pixmap(_info-&gt;_icon); // 设置图片自动缩放 ui-&gt;icon_lb-&gt;setPixmap(pixmap.scaled(ui-&gt;icon_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation)); ui-&gt;icon_lb-&gt;setScaledContents(true); ui-&gt;user_name_lb-&gt;setText(_info-&gt;_name);&#125;void ConUserItem::ShowRedPoint(bool show)&#123; if(show)&#123; ui-&gt;red_point-&gt;show(); &#125;else&#123; ui-&gt;red_point-&gt;hide(); &#125;&#125; 这样我们启动程序就能看到模拟的联系人列表被加载进来了。 申请列表申请页面ui布局如下 我们新增ApplyFriendPage类，用来显示申请列表 12345678910111213141516171819class ApplyFriendPage : public QWidget&#123; Q_OBJECTpublic: explicit ApplyFriendPage(QWidget *parent = nullptr); ~ApplyFriendPage(); void AddNewApply(std::shared_ptr&lt;AddFriendApply&gt; apply);protected: void paintEvent(QPaintEvent *event);private: void loadApplyList(); Ui::ApplyFriendPage *ui; std::unordered_map&lt;int, ApplyFriendItem*&gt; _unauth_items;public slots: void slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt; );signals: void sig_show_search(bool);&#125;; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119ApplyFriendPage::ApplyFriendPage(QWidget *parent) : QWidget(parent), ui(new Ui::ApplyFriendPage)&#123; ui-&gt;setupUi(this); connect(ui-&gt;apply_friend_list, &amp;ApplyFriendList::sig_show_search, this, &amp;ApplyFriendPage::sig_show_search); loadApplyList(); //接受tcp传递的authrsp信号处理 connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_auth_rsp, this, &amp;ApplyFriendPage::slot_auth_rsp);&#125;ApplyFriendPage::~ApplyFriendPage()&#123; delete ui;&#125;void ApplyFriendPage::AddNewApply(std::shared_ptr&lt;AddFriendApply&gt; apply)&#123; //先模拟头像随机，以后头像资源增加资源服务器后再显示 int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int head_i = randomValue % heads.size(); auto* apply_item = new ApplyFriendItem(); auto apply_info = std::make_shared&lt;ApplyInfo&gt;(apply-&gt;_from_uid, apply-&gt;_name, apply-&gt;_desc,heads[head_i], apply-&gt;_name, 0, 0); apply_item-&gt;SetInfo( apply_info); QListWidgetItem* item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(apply_item-&gt;sizeHint()); item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable); ui-&gt;apply_friend_list-&gt;insertItem(0,item); ui-&gt;apply_friend_list-&gt;setItemWidget(item, apply_item); apply_item-&gt;ShowAddBtn(true); //收到审核好友信号 connect(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [this](std::shared_ptr&lt;ApplyInfo&gt; apply_info) &#123;// auto* authFriend = new AuthenFriend(this);// authFriend-&gt;setModal(true);// authFriend-&gt;SetApplyInfo(apply_info);// authFriend-&gt;show(); &#125;);&#125;void ApplyFriendPage::paintEvent(QPaintEvent *event)&#123; QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);&#125;void ApplyFriendPage::loadApplyList()&#123; //添加好友申请 auto apply_list = UserMgr::GetInstance()-&gt;GetApplyList(); for(auto &amp;apply: apply_list)&#123; int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int head_i = randomValue % heads.size(); auto* apply_item = new ApplyFriendItem(); apply-&gt;SetIcon(heads[head_i]); apply_item-&gt;SetInfo(apply); QListWidgetItem* item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(apply_item-&gt;sizeHint()); item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable); ui-&gt;apply_friend_list-&gt;insertItem(0,item); ui-&gt;apply_friend_list-&gt;setItemWidget(item, apply_item); if(apply-&gt;_status)&#123; apply_item-&gt;ShowAddBtn(false); &#125;else&#123; apply_item-&gt;ShowAddBtn(true); auto uid = apply_item-&gt;GetUid(); _unauth_items[uid] = apply_item; &#125; //收到审核好友信号 connect(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [this](std::shared_ptr&lt;ApplyInfo&gt; apply_info) &#123;// auto* authFriend = new AuthenFriend(this);// authFriend-&gt;setModal(true);// authFriend-&gt;SetApplyInfo(apply_info);// authFriend-&gt;show(); &#125;); &#125; // 模拟假数据，创建QListWidgetItem，并设置自定义的widget for(int i = 0; i &lt; 13; i++)&#123; int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int str_i = randomValue%strs.size(); int head_i = randomValue%heads.size(); int name_i = randomValue%names.size(); auto *apply_item = new ApplyFriendItem(); auto apply = std::make_shared&lt;ApplyInfo&gt;(0, names[name_i], strs[str_i], heads[head_i], names[name_i], 0, 1); apply_item-&gt;SetInfo(apply); QListWidgetItem *item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(apply_item-&gt;sizeHint()); item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable); ui-&gt;apply_friend_list-&gt;addItem(item); ui-&gt;apply_friend_list-&gt;setItemWidget(item, apply_item); //收到审核好友信号 connect(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [this](std::shared_ptr&lt;ApplyInfo&gt; apply_info)&#123;// auto *authFriend = new AuthenFriend(this);// authFriend-&gt;setModal(true);// authFriend-&gt;SetApplyInfo(apply_info);// authFriend-&gt;show(); &#125;); &#125;&#125;void ApplyFriendPage::slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)&#123; auto uid = auth_rsp-&gt;_uid; auto find_iter = _unauth_items.find(uid); if (find_iter == _unauth_items.end()) &#123; return; &#125; find_iter-&gt;second-&gt;ShowAddBtn(false);&#125; 因为每个item自定义，所以我们新增设计师界面类ApplyFriendItem 界面布局 类的声明如下： 1234567891011121314151617181920class ApplyFriendItem : public ListItemBase&#123; Q_OBJECTpublic: explicit ApplyFriendItem(QWidget *parent = nullptr); ~ApplyFriendItem(); void SetInfo(std::shared_ptr&lt;ApplyInfo&gt; apply_info); void ShowAddBtn(bool bshow); QSize sizeHint() const override &#123; return QSize(250, 80); // 返回自定义的尺寸 &#125; int GetUid();private: Ui::ApplyFriendItem *ui; std::shared_ptr&lt;ApplyInfo&gt; _apply_info; bool _added;signals: void sig_auth_friend(std::shared_ptr&lt;ApplyInfo&gt; apply_info);&#125;; 以下为具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ApplyFriendItem::ApplyFriendItem(QWidget *parent) : ListItemBase(parent), _added(false), ui(new Ui::ApplyFriendItem)&#123; ui-&gt;setupUi(this); SetItemType(ListItemType::APPLY_FRIEND_ITEM); ui-&gt;addBtn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;, &quot;press&quot;); ui-&gt;addBtn-&gt;hide(); connect(ui-&gt;addBtn, &amp;ClickedBtn::clicked, [this]()&#123; emit this-&gt;sig_auth_friend(_apply_info); &#125;);&#125;ApplyFriendItem::~ApplyFriendItem()&#123; delete ui;&#125;void ApplyFriendItem::SetInfo(std::shared_ptr&lt;ApplyInfo&gt; apply_info)&#123; _apply_info = apply_info; // 加载图片 QPixmap pixmap(_apply_info-&gt;_icon); // 设置图片自动缩放 ui-&gt;icon_lb-&gt;setPixmap(pixmap.scaled(ui-&gt;icon_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation)); ui-&gt;icon_lb-&gt;setScaledContents(true); ui-&gt;user_name_lb-&gt;setText(_apply_info-&gt;_name); ui-&gt;user_chat_lb-&gt;setText(_apply_info-&gt;_desc);&#125;void ApplyFriendItem::ShowAddBtn(bool bshow)&#123; if (bshow) &#123; ui-&gt;addBtn-&gt;show(); ui-&gt;already_add_lb-&gt;hide(); _added = false; &#125; else &#123; ui-&gt;addBtn-&gt;hide(); ui-&gt;already_add_lb-&gt;show(); _added = true; &#125;&#125;int ApplyFriendItem::GetUid() &#123; return _apply_info-&gt;_uid;&#125; 申请列表类ApplyFriendList的声明如下 12345678910111213class ApplyFriendList: public QListWidget&#123; Q_OBJECTpublic: ApplyFriendList(QWidget *parent = nullptr);protected: bool eventFilter(QObject *watched, QEvent *event) override;private slots:signals: void sig_show_search(bool);&#125;; 具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344ApplyFriendList::ApplyFriendList(QWidget *parent)&#123; Q_UNUSED(parent); this-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); // 安装事件过滤器 this-&gt;viewport()-&gt;installEventFilter(this);&#125;bool ApplyFriendList::eventFilter(QObject *watched, QEvent *event)&#123; // 检查事件是否是鼠标悬浮进入或离开 if (watched == this-&gt;viewport()) &#123; if (event-&gt;type() == QEvent::Enter) &#123; // 鼠标悬浮，显示滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); &#125; else if (event-&gt;type() == QEvent::Leave) &#123; // 鼠标离开，隐藏滚动条 this-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff); &#125; &#125; if (watched == this-&gt;viewport()) &#123; if (event-&gt;type() == QEvent::MouseButtonPress) &#123; emit sig_show_search(false); &#125; &#125; // 检查事件是否是鼠标滚轮事件 if (watched == this-&gt;viewport() &amp;&amp; event-&gt;type() == QEvent::Wheel) &#123; QWheelEvent *wheelEvent = static_cast&lt;QWheelEvent*&gt;(event); int numDegrees = wheelEvent-&gt;angleDelta().y() / 8; int numSteps = numDegrees / 15; // 计算滚动步数 // 设置滚动幅度 this-&gt;verticalScrollBar()-&gt;setValue(this-&gt;verticalScrollBar()-&gt;value() - numSteps); return true; // 停止事件传递 &#125; return QListWidget::eventFilter(watched, event);&#125; 然后在ChatDialog的stackedWidget中将friend_apply_page升级为ApplyFriendPage. 这样我们启动程序就能看到联系人列表和申请列表了。 下一步还需要写QSS美化以下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#con_user_list &#123; background-color: rgb(247,247,248); border: none;&#125;#con_user_list::item:selected &#123; background-color: #d3d7d4; border: none; outline: none;&#125;#con_user_list::item:hover &#123; background-color: rgb(206,207,208); border: none; outline: none;&#125;#con_user_list::focus &#123; border: none; outline: none;&#125;#GroupTipItem &#123; background-color: #eaeaea; border: none;&#125;#GroupTipItem QLabel&#123; color: #2e2f30; font-size: 12px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border: none;&#125;#new_friend_item &#123; border-bottom: 1px solid #eaeaea;&#125;#LineItem &#123; background-color:rgb(247,247,247); border: none;&#125;#friend_apply_lb &#123; font-family: &quot;Microsoft YaHei&quot;; font-size: 18px; font-weight: normal;&#125;#friend_apply_wid &#123; background-color: #f1f2f3; border-bottom: 1px solid #ede9e7;&#125;#apply_friend_list &#123; background-color: #f1f2f3; border-left: 1px solid #ede9e7; border-top: none; border-right: none; border-bottom: none;&#125;ApplyFriendItem &#123; background-color: #f1f2f3; border-bottom: 2px solid #dbd9d9;&#125;ApplyFriendItem #user_chat_lb&#123; color: #a2a2a2; font-size: 14px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */&#125;ApplyFriendItem #addBtn[state=&#x27;normal&#x27;] &#123; background-color: #d3d7d4; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;ApplyFriendItem #addBtn[state=&#x27;hover&#x27;] &#123; background-color: #D3D3D3; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;ApplyFriendItem #addBtn[state=&#x27;press&#x27;] &#123; background-color: #BEBEBE; color: #2cb46e; font-size: 16px; /* 设置字体大小 */ font-family: &quot;Microsoft YaHei&quot;; /* 设置字体 */ border-radius: 20px; /* 设置圆角 */&#125;#already_add_lb&#123; color:rgb(153,153,153); font-size: 12px; font-family: &quot;Microsoft YaHei&quot;;&#125;#user_name_lb&#123; color:rgb(0,0,0); font-size: 16px; font-weight: normal; font-family: &quot;Microsoft YaHei&quot;;&#125; 源码连接https://gitee.com/secondtonone1/llfcchat 视频连接https://www.bilibili.com/video/BV1SS42197Yo/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"C++ 全栈聊天项目(9) nodejs实现邮箱验证服务","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro9/","text":"邮箱验证服务联调我们启动GateServer和VarifyServer 我们启动客户端，点击注册按钮进入注册界面，输入邮箱并且点击获取验证码 GateServer收到Client发送的请求后，会调用grpc 服务 访问VarifyServer，VarifyServer会随机生成验证码，并且调用邮箱模块发送邮件给指定邮箱。而且把发送的结果给GateServer，GateServer再将消息回传给客户端。 设置验证码过期我们的验证码是要设置过期的，可以用redis管理过期的验证码自动删除，key为邮箱，value为验证码，过期时间为3min。 windows 安装redis服务windows 版本下载地址: https://github.com/tporadowski/redis/releases 下载速度慢可以去我的网盘 链接: https://pan.baidu.com/s/1v_foHZLvBeJQMePSGnp4Ow?pwd=yid3 提取码: yid3 下载完成后解压 修改redis.windows.conf, 并且修改端口 1port 6380 找到requirepass foobared，下面添加requirepass 12# requirepass foobaredrequirepass 123456 启动redis 服务器 .\\redis-server.exe .\\redis.windows.conf 启动客户端 .\\redis-cli.exe -p 6380, 输入密码登录成功 Linux 安装redis服务Linux安装容器后，直接用容器启动redis 1docker run -d --name llfc-redis -p 6380:6379 redis --requirepass &quot;123456&quot; 为了方便测试能否链接以及以后查看数据,大家可以下载redis desktop manager 官网链接redisdesktop.com/ 下载速度慢可以去我的网盘 链接: https://pan.baidu.com/s/1v_foHZLvBeJQMePSGnp4Ow?pwd=yid3 提取码: yid3 下载后安装 设置好ip和密码，点击测试连接连通就成功了 widows编译和配置redisLinux的redis库直接编译安装即可，windows反而麻烦一些，我们先阐述windows环境如何配置redis库， C++ 的redis库有很多种，最常用的有hredis和redis-plus-plus. 我们用redis-plus-plus. 这里介绍一种简单的安装方式—vcpkg 先安装vcpkg, 源码地址 https://github.com/microsoft/vcpkg/releases 下载源码后 windows版本redis下载地址 https://github.com/microsoftarchive/redis 因为是源码，所以进入msvc目录 用visual studio打开sln文件，弹出升级窗口, 我的是vs2019所以升级到142 只需要生成hiredis工程和Win32_Interop工程即可，分别点击生成,生成hiredis.lib和Win32_Interop.lib即可 右键两个工程的属性，代码生成里选择运行时库加载模式为MDD(Debug模式动态运行加载)，为了兼容我们其他的库，其他的库也是MDD模式 编译Win32_Interop.lib时报错， system_error不是std成员， 解决办法为在Win32_variadicFunctor.cpp和Win32_FDAPI.cpp添加#include &lt;system_error&gt;,再右键生成成功 将hiredis.lib和Win32_Interop.lib拷贝到D:\\cppsoft\\reids\\lib 将redis-3.0\\deps和redis-3.0\\src文件夹拷贝到D:\\cppsoft\\reids 然后我们在visual studio中配置VC++ 包含目录 配置VC++库目录 然后在链接器-&gt;输入-&gt;附加依赖项中添加 代码测试我们需要写代码测试库配置的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void TestRedis() &#123; //连接redis 需要启动才可以进行连接//redis默认监听端口为6387 可以再配置文件中修改 redisContext* c = redisConnect(&quot;127.0.0.1&quot;, 6380); if (c-&gt;err) &#123; printf(&quot;Connect to redisServer faile:%s\\n&quot;, c-&gt;errstr); redisFree(c); return; &#125; printf(&quot;Connect to redisServer Success\\n&quot;); std::string redis_password = &quot;123456&quot;; redisReply* r = (redisReply*)redisCommand(c, &quot;AUTH %s&quot;, redis_password); if (r-&gt;type == REDIS_REPLY_ERROR) &#123; printf(&quot;Redis认证失败！\\n&quot;); &#125;else &#123; printf(&quot;Redis认证成功！\\n&quot;); &#125; //为redis设置key const char* command1 = &quot;set stest1 value1&quot;; //执行redis命令行 r = (redisReply*)redisCommand(c, command1); //如果返回NULL则说明执行失败 if (NULL == r) &#123; printf(&quot;Execut command1 failure\\n&quot;); redisFree(c); return; &#125; //如果执行失败则释放连接 if (!(r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; (strcmp(r-&gt;str, &quot;OK&quot;) == 0 || strcmp(r-&gt;str, &quot;ok&quot;) == 0))) &#123; printf(&quot;Failed to execute command[%s]\\n&quot;, command1); freeReplyObject(r); redisFree(c); return; &#125; //执行成功 释放redisCommand执行后返回的redisReply所占用的内存 freeReplyObject(r); printf(&quot;Succeed to execute command[%s]\\n&quot;, command1); const char* command2 = &quot;strlen stest1&quot;; r = (redisReply*)redisCommand(c, command2); //如果返回类型不是整形 则释放连接 if (r-&gt;type != REDIS_REPLY_INTEGER) &#123; printf(&quot;Failed to execute command[%s]\\n&quot;, command2); freeReplyObject(r); redisFree(c); return; &#125; //获取字符串长度 int length = r-&gt;integer; freeReplyObject(r); printf(&quot;The length of &#x27;stest1&#x27; is %d.\\n&quot;, length); printf(&quot;Succeed to execute command[%s]\\n&quot;, command2); //获取redis键值对信息 const char* command3 = &quot;get stest1&quot;; r = (redisReply*)redisCommand(c, command3); if (r-&gt;type != REDIS_REPLY_STRING) &#123; printf(&quot;Failed to execute command[%s]\\n&quot;, command3); freeReplyObject(r); redisFree(c); return; &#125; printf(&quot;The value of &#x27;stest1&#x27; is %s\\n&quot;, r-&gt;str); freeReplyObject(r); printf(&quot;Succeed to execute command[%s]\\n&quot;, command3); const char* command4 = &quot;get stest2&quot;; r = (redisReply*)redisCommand(c, command4); if (r-&gt;type != REDIS_REPLY_NIL) &#123; printf(&quot;Failed to execute command[%s]\\n&quot;, command4); freeReplyObject(r); redisFree(c); return; &#125; freeReplyObject(r); printf(&quot;Succeed to execute command[%s]\\n&quot;, command4); //释放连接资源 redisFree(c);&#125; 在主函数中调用TestRedis，编译项目时发现编译失败，提示 在同时使用Redis连接和socket连接时，遇到了Win32_Interop.lib和WS2_32.lib冲突的问题, 因为我们底层用了socket作为网络通信，也用redis，导致两个库冲突。 引起原因主要是Redis库Win32_FDAPI.cpp有重新定义了socket的一些方法引起来冲突 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566extern &quot;C&quot; &#123;// Unix compatible FD based routinesfdapi_accept accept = NULL;fdapi_access access = NULL;fdapi_bind bind = NULL;fdapi_connect connect = NULL;fdapi_fcntl fcntl = NULL;fdapi_fstat fdapi_fstat64 = NULL;fdapi_fsync fsync = NULL;fdapi_ftruncate ftruncate = NULL;fdapi_freeaddrinfo freeaddrinfo = NULL;fdapi_getaddrinfo getaddrinfo = NULL;fdapi_getpeername getpeername = NULL;fdapi_getsockname getsockname = NULL;fdapi_getsockopt getsockopt = NULL;fdapi_htonl htonl = NULL;fdapi_htons htons = NULL;fdapi_isatty isatty = NULL;fdapi_inet_ntop inet_ntop = NULL;fdapi_inet_pton inet_pton = NULL;fdapi_listen listen = NULL;fdapi_lseek64 lseek64 = NULL;fdapi_ntohl ntohl = NULL;fdapi_ntohs ntohs = NULL;fdapi_open open = NULL;fdapi_pipe pipe = NULL;fdapi_poll poll = NULL;fdapi_read read = NULL;fdapi_select select = NULL;fdapi_setsockopt setsockopt = NULL;fdapi_socket socket = NULL;fdapi_write write = NULL;&#125;auto f_WSACleanup = dllfunctor_stdcall&lt;int&gt;(&quot;ws2_32.dll&quot;, &quot;WSACleanup&quot;);auto f_WSAFDIsSet = dllfunctor_stdcall&lt;int, SOCKET, fd_set*&gt;(&quot;ws2_32.dll&quot;, &quot;__WSAFDIsSet&quot;);auto f_WSAGetLastError = dllfunctor_stdcall&lt;int&gt;(&quot;ws2_32.dll&quot;, &quot;WSAGetLastError&quot;);auto f_WSAGetOverlappedResult = dllfunctor_stdcall&lt;BOOL, SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD&gt;(&quot;ws2_32.dll&quot;, &quot;WSAGetOverlappedResult&quot;);auto f_WSADuplicateSocket = dllfunctor_stdcall&lt;int, SOCKET, DWORD, LPWSAPROTOCOL_INFO&gt;(&quot;ws2_32.dll&quot;, &quot;WSADuplicateSocketW&quot;);auto f_WSAIoctl = dllfunctor_stdcall&lt;int, SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPVOID, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE&gt;(&quot;ws2_32.dll&quot;, &quot;WSAIoctl&quot;);auto f_WSARecv = dllfunctor_stdcall&lt;int, SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE&gt;(&quot;ws2_32.dll&quot;, &quot;WSARecv&quot;);auto f_WSASocket = dllfunctor_stdcall&lt;SOCKET, int, int, int, LPWSAPROTOCOL_INFO, GROUP, DWORD&gt;(&quot;ws2_32.dll&quot;, &quot;WSASocketW&quot;);auto f_WSASend = dllfunctor_stdcall&lt;int, SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE&gt;(&quot;ws2_32.dll&quot;, &quot;WSASend&quot;);auto f_WSAStartup = dllfunctor_stdcall&lt;int, WORD, LPWSADATA&gt;(&quot;ws2_32.dll&quot;, &quot;WSAStartup&quot;);auto f_ioctlsocket = dllfunctor_stdcall&lt;int, SOCKET, long, u_long*&gt;(&quot;ws2_32.dll&quot;, &quot;ioctlsocket&quot;);auto f_accept = dllfunctor_stdcall&lt;SOCKET, SOCKET, struct sockaddr*, int*&gt;(&quot;ws2_32.dll&quot;, &quot;accept&quot;);auto f_bind = dllfunctor_stdcall&lt;int, SOCKET, const struct sockaddr*, int&gt;(&quot;ws2_32.dll&quot;, &quot;bind&quot;);auto f_closesocket = dllfunctor_stdcall&lt;int, SOCKET&gt;(&quot;ws2_32.dll&quot;, &quot;closesocket&quot;);auto f_connect = dllfunctor_stdcall&lt;int, SOCKET, const struct sockaddr*, int&gt;(&quot;ws2_32.dll&quot;, &quot;connect&quot;);auto f_freeaddrinfo = dllfunctor_stdcall&lt;void, addrinfo*&gt;(&quot;ws2_32.dll&quot;, &quot;freeaddrinfo&quot;);auto f_getaddrinfo = dllfunctor_stdcall&lt;int, PCSTR, PCSTR, const ADDRINFOA*, ADDRINFOA**&gt;(&quot;ws2_32.dll&quot;, &quot;getaddrinfo&quot;);auto f_gethostbyname = dllfunctor_stdcall&lt;struct hostent*, const char*&gt;(&quot;ws2_32.dll&quot;, &quot;gethostbyname&quot;);auto f_getpeername = dllfunctor_stdcall&lt;int, SOCKET, struct sockaddr*, int*&gt;(&quot;ws2_32.dll&quot;, &quot;getpeername&quot;);auto f_getsockname = dllfunctor_stdcall&lt;int, SOCKET, struct sockaddr*, int*&gt;(&quot;ws2_32.dll&quot;, &quot;getsockname&quot;);auto f_getsockopt = dllfunctor_stdcall&lt;int, SOCKET, int, int, char*, int*&gt;(&quot;ws2_32.dll&quot;, &quot;getsockopt&quot;);auto f_htonl = dllfunctor_stdcall&lt;u_long, u_long&gt;(&quot;ws2_32.dll&quot;, &quot;htonl&quot;);auto f_htons = dllfunctor_stdcall&lt;u_short, u_short&gt;(&quot;ws2_32.dll&quot;, &quot;htons&quot;);auto f_listen = dllfunctor_stdcall&lt;int, SOCKET, int&gt;(&quot;ws2_32.dll&quot;, &quot;listen&quot;);auto f_ntohs = dllfunctor_stdcall&lt;u_short, u_short&gt;(&quot;ws2_32.dll&quot;, &quot;ntohs&quot;);auto f_ntohl = dllfunctor_stdcall&lt;u_long, u_long&gt;(&quot;ws2_32.dll&quot;, &quot;ntohl&quot;);auto f_recv = dllfunctor_stdcall&lt;int, SOCKET, char*, int, int&gt;(&quot;ws2_32.dll&quot;, &quot;recv&quot;);auto f_select = dllfunctor_stdcall&lt;int, int, fd_set*, fd_set*, fd_set*, const struct timeval*&gt;(&quot;ws2_32.dll&quot;, &quot;select&quot;);auto f_send = dllfunctor_stdcall&lt;int, SOCKET, const char*, int, int&gt;(&quot;ws2_32.dll&quot;, &quot;send&quot;);auto f_setsockopt = dllfunctor_stdcall&lt;int, SOCKET, int, int, const char*, int&gt;(&quot;ws2_32.dll&quot;, &quot;setsockopt&quot;);auto f_socket = dllfunctor_stdcall&lt;SOCKET, int, int, int&gt;(&quot;ws2_32.dll&quot;, &quot;socket&quot;); 去掉Redis库里面的socket的函数的重定义，把所有使用这些方法的地方都改为下面对应的函数 1234567891011121314151617181920212223242526int FDAPI_accept(int rfd, struct sockaddr *addr, socklen_t *addrlen);int FDAPI_access(const char *pathname, int mode);int FDAPI_bind(int rfd, const struct sockaddr *addr, socklen_t addrlen);int FDAPI_connect(int rfd, const struct sockaddr *addr, size_t addrlen);int FDAPI_fcntl(int rfd, int cmd, int flags);int FDAPI_fstat64(int rfd, struct __stat64 *buffer);void FDAPI_freeaddrinfo(struct addrinfo *ai);int FDAPI_fsync(int rfd);int FDAPI_ftruncate(int rfd, PORT_LONGLONG length);int FDAPI_getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);int FDAPI_getsockopt(int rfd, int level, int optname, void *optval, socklen_t *optlen);int FDAPI_getpeername(int rfd, struct sockaddr *addr, socklen_t * addrlen);int FDAPI_getsockname(int rfd, struct sockaddr* addrsock, int* addrlen);u_long FDAPI_htonl(u_long hostlong);u_short FDAPI_htons(u_short hostshort);u_int FDAPI_ntohl(u_int netlong);u_short FDAPI_ntohs(u_short netshort);int FDAPI_open(const char * _Filename, int _OpenFlag, int flags);int FDAPI_pipe(int *pfds);int FDAPI_poll(struct pollfd *fds, nfds_t nfds, int timeout);int FDAPI_listen(int rfd, int backlog);int FDAPI_socket(int af, int type, int protocol);int FDAPI_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);int FDAPI_setsockopt(int rfd, int level, int optname, const void *optval, socklen_t optlen);ssize_t FDAPI_read(int rfd, void *buf, size_t count);ssize_t FDAPI_write(int rfd, const void *buf, size_t count); 考虑大家修改起来很麻烦，可以下载我的代码 https://gitee.com/secondtonone1/windows-redis 再次编译生成hredis和Win32_Interop的lib库，重新配置下，项目再次编译就通过了。 封装redis操作类因为hredis提供的操作太别扭了，我们手动封装redis操作类，简化调用流程。 封装的类叫RedisMgr，它是个单例类并且可接受回调，按照我们之前的风格 1234567891011121314151617181920212223242526class RedisMgr: public Singleton&lt;RedisMgr&gt;, public std::enable_shared_from_this&lt;RedisMgr&gt;&#123; friend class Singleton&lt;RedisMgr&gt;;public: ~RedisMgr(); bool Connect(const std::string&amp; host, int port); bool Get(const std::string &amp;key, std::string&amp; value); bool Set(const std::string &amp;key, const std::string &amp;value); bool Auth(const std::string &amp;password); bool LPush(const std::string &amp;key, const std::string &amp;value); bool LPop(const std::string &amp;key, std::string&amp; value); bool RPush(const std::string&amp; key, const std::string&amp; value); bool RPop(const std::string&amp; key, std::string&amp; value); bool HSet(const std::string &amp;key, const std::string &amp;hkey, const std::string &amp;value); bool HSet(const char* key, const char* hkey, const char* hvalue, size_t hvaluelen); std::string HGet(const std::string &amp;key, const std::string &amp;hkey); bool Del(const std::string &amp;key); bool ExistsKey(const std::string &amp;key); void Close();private: RedisMgr(); redisContext* _connect; redisReply* _reply;&#125;; 连接操作 12345678910bool RedisMgr::Connect(const std::string &amp;host, int port)&#123; this-&gt;_connect = redisConnect(host.c_str(), port); if (this-&gt;_connect != NULL &amp;&amp; this-&gt;_connect-&gt;err) &#123; std::cout &lt;&lt; &quot;connect error &quot; &lt;&lt; this-&gt;_connect-&gt;errstr &lt;&lt; std::endl; return false; &#125; return true;&#125; 获取key对应的value 123456789101112131415161718192021bool RedisMgr::Get(const std::string &amp;key, std::string&amp; value)&#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;GET %s&quot;, key.c_str()); if (this-&gt;_reply == NULL) &#123; std::cout &lt;&lt; &quot;[ GET &quot; &lt;&lt; key &lt;&lt; &quot; ] failed&quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; if (this-&gt;_reply-&gt;type != REDIS_REPLY_STRING) &#123; std::cout &lt;&lt; &quot;[ GET &quot; &lt;&lt; key &lt;&lt; &quot; ] failed&quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; value = this-&gt;_reply-&gt;str; freeReplyObject(this-&gt;_reply); std::cout &lt;&lt; &quot;Succeed to execute command [ GET &quot; &lt;&lt; key &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl; return true;&#125; 设置key和value 1234567891011121314151617181920212223242526bool RedisMgr::Set(const std::string &amp;key, const std::string &amp;value)&#123; //执行redis命令行 this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;SET %s %s&quot;, key.c_str(), value.c_str()); //如果返回NULL则说明执行失败 if (NULL == this-&gt;_reply) &#123; std::cout &lt;&lt; &quot;Execut command [ SET &quot; &lt;&lt; key &lt;&lt; &quot; &quot;&lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; //如果执行失败则释放连接 if (!(this-&gt;_reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; (strcmp(this-&gt;_reply-&gt;str, &quot;OK&quot;) == 0 || strcmp(this-&gt;_reply-&gt;str, &quot;ok&quot;) == 0))) &#123; std::cout &lt;&lt; &quot;Execut command [ SET &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; //执行成功 释放redisCommand执行后返回的redisReply所占用的内存 freeReplyObject(this-&gt;_reply); std::cout &lt;&lt; &quot;Execut command [ SET &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; return true;&#125; 密码认证 12345678910111213141516bool RedisMgr::Auth(const std::string &amp;password)&#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;AUTH %s&quot;, password.c_str()); if (this-&gt;_reply-&gt;type == REDIS_REPLY_ERROR) &#123; std::cout &lt;&lt; &quot;认证失败&quot; &lt;&lt; std::endl; //执行成功 释放redisCommand执行后返回的redisReply所占用的内存 freeReplyObject(this-&gt;_reply); return false; &#125; else &#123; //执行成功 释放redisCommand执行后返回的redisReply所占用的内存 freeReplyObject(this-&gt;_reply); std::cout &lt;&lt; &quot;认证成功&quot; &lt;&lt; std::endl; return true; &#125;&#125; 左侧push 1234567891011121314151617181920bool RedisMgr::LPush(const std::string &amp;key, const std::string &amp;value)&#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;LPUSH %s %s&quot;, key.c_str(), value.c_str()); if (NULL == this-&gt;_reply) &#123; std::cout &lt;&lt; &quot;Execut command [ LPUSH &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; if (this-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER || this-&gt;_reply-&gt;integer &lt;= 0) &#123; std::cout &lt;&lt; &quot;Execut command [ LPUSH &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; std::cout &lt;&lt; &quot;Execut command [ LPUSH &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; 左侧pop 123456789101112bool RedisMgr::LPop(const std::string &amp;key, std::string&amp; value)&#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;LPOP %s &quot;, key.c_str()); if (_reply == nullptr || _reply-&gt;type == REDIS_REPLY_NIL) &#123; std::cout &lt;&lt; &quot;Execut command [ LPOP &quot; &lt;&lt; key&lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; value = _reply-&gt;str; std::cout &lt;&lt; &quot;Execut command [ LPOP &quot; &lt;&lt; key &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; 右侧push 12345678910111213141516171819bool RedisMgr::RPush(const std::string&amp; key, const std::string&amp; value) &#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;RPUSH %s %s&quot;, key.c_str(), value.c_str()); if (NULL == this-&gt;_reply) &#123; std::cout &lt;&lt; &quot;Execut command [ RPUSH &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; if (this-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER || this-&gt;_reply-&gt;integer &lt;= 0) &#123; std::cout &lt;&lt; &quot;Execut command [ RPUSH &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; std::cout &lt;&lt; &quot;Execut command [ RPUSH &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; 右侧pop 123456789101112bool RedisMgr::RPop(const std::string&amp; key, std::string&amp; value) &#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;RPOP %s &quot;, key.c_str()); if (_reply == nullptr || _reply-&gt;type == REDIS_REPLY_NIL) &#123; std::cout &lt;&lt; &quot;Execut command [ RPOP &quot; &lt;&lt; key &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; value = _reply-&gt;str; std::cout &lt;&lt; &quot;Execut command [ RPOP &quot; &lt;&lt; key &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; HSet操作 1234567891011121314151617181920212223242526272829303132333435bool RedisMgr::HSet(const std::string &amp;key, const std::string &amp;hkey, const std::string &amp;value) &#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;HSET %s %s %s&quot;, key.c_str(), hkey.c_str(), value.c_str()); if (_reply == nullptr || _reply-&gt;type != REDIS_REPLY_INTEGER ) &#123; std::cout &lt;&lt; &quot;Execut command [ HSet &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; hkey &lt;&lt;&quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; std::cout &lt;&lt; &quot;Execut command [ HSet &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; hkey &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125;bool RedisMgr::HSet(const char* key, const char* hkey, const char* hvalue, size_t hvaluelen)&#123; const char* argv[4]; size_t argvlen[4]; argv[0] = &quot;HSET&quot;; argvlen[0] = 4; argv[1] = key; argvlen[1] = strlen(key); argv[2] = hkey; argvlen[2] = strlen(hkey); argv[3] = hvalue; argvlen[3] = hvaluelen; this-&gt;_reply = (redisReply*)redisCommandArgv(this-&gt;_connect, 4, argv, argvlen); if (_reply == nullptr || _reply-&gt;type != REDIS_REPLY_INTEGER) &#123; std::cout &lt;&lt; &quot;Execut command [ HSet &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; hkey &lt;&lt; &quot; &quot; &lt;&lt; hvalue &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; std::cout &lt;&lt; &quot;Execut command [ HSet &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; hkey &lt;&lt; &quot; &quot; &lt;&lt; hvalue &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; HGet操作 12345678910111213141516171819202122std::string RedisMgr::HGet(const std::string &amp;key, const std::string &amp;hkey)&#123; const char* argv[3]; size_t argvlen[3]; argv[0] = &quot;HGET&quot;; argvlen[0] = 4; argv[1] = key.c_str(); argvlen[1] = key.length(); argv[2] = hkey.c_str(); argvlen[2] = hkey.length(); this-&gt;_reply = (redisReply*)redisCommandArgv(this-&gt;_connect, 3, argv, argvlen); if (this-&gt;_reply == nullptr || this-&gt;_reply-&gt;type == REDIS_REPLY_NIL) &#123; freeReplyObject(this-&gt;_reply); std::cout &lt;&lt; &quot;Execut command [ HGet &quot; &lt;&lt; key &lt;&lt; &quot; &quot;&lt;&lt; hkey &lt;&lt;&quot; ] failure ! &quot; &lt;&lt; std::endl; return &quot;&quot;; &#125; std::string value = this-&gt;_reply-&gt;str; freeReplyObject(this-&gt;_reply); std::cout &lt;&lt; &quot;Execut command [ HGet &quot; &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; hkey &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; return value;&#125; Del 操作 123456789101112bool RedisMgr::Del(const std::string &amp;key)&#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;DEL %s&quot;, key.c_str()); if (this-&gt;_reply == nullptr || this-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER) &#123; std::cout &lt;&lt; &quot;Execut command [ Del &quot; &lt;&lt; key &lt;&lt; &quot; ] failure ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; std::cout &lt;&lt; &quot;Execut command [ Del &quot; &lt;&lt; key &lt;&lt; &quot; ] success ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; 判断键值是否存在 123456789101112bool RedisMgr::ExistsKey(const std::string &amp;key)&#123; this-&gt;_reply = (redisReply*)redisCommand(this-&gt;_connect, &quot;exists %s&quot;, key.c_str()); if (this-&gt;_reply == nullptr || this-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER || this-&gt;_reply-&gt;integer == 0) &#123; std::cout &lt;&lt; &quot;Not Found [ Key &quot; &lt;&lt; key &lt;&lt; &quot; ] ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return false; &#125; std::cout &lt;&lt; &quot; Found [ Key &quot; &lt;&lt; key &lt;&lt; &quot; ] exists ! &quot; &lt;&lt; std::endl; freeReplyObject(this-&gt;_reply); return true;&#125; 关闭 1234void RedisMgr::Close()&#123; redisFree(_connect);&#125; 测试用例 12345678910111213141516171819202122void TestRedisMgr() &#123; assert(RedisMgr::GetInstance()-&gt;Connect(&quot;127.0.0.1&quot;, 6380)); assert(RedisMgr::GetInstance()-&gt;Auth(&quot;123456&quot;)); assert(RedisMgr::GetInstance()-&gt;Set(&quot;blogwebsite&quot;,&quot;llfc.club&quot;)); std::string value=&quot;&quot;; assert(RedisMgr::GetInstance()-&gt;Get(&quot;blogwebsite&quot;, value) ); assert(RedisMgr::GetInstance()-&gt;Get(&quot;nonekey&quot;, value) == false); assert(RedisMgr::GetInstance()-&gt;HSet(&quot;bloginfo&quot;,&quot;blogwebsite&quot;, &quot;llfc.club&quot;)); assert(RedisMgr::GetInstance()-&gt;HGet(&quot;bloginfo&quot;,&quot;blogwebsite&quot;) != &quot;&quot;); assert(RedisMgr::GetInstance()-&gt;ExistsKey(&quot;bloginfo&quot;)); assert(RedisMgr::GetInstance()-&gt;Del(&quot;bloginfo&quot;)); assert(RedisMgr::GetInstance()-&gt;Del(&quot;bloginfo&quot;)); assert(RedisMgr::GetInstance()-&gt;ExistsKey(&quot;bloginfo&quot;) == false); assert(RedisMgr::GetInstance()-&gt;LPush(&quot;lpushkey1&quot;, &quot;lpushvalue1&quot;)); assert(RedisMgr::GetInstance()-&gt;LPush(&quot;lpushkey1&quot;, &quot;lpushvalue2&quot;)); assert(RedisMgr::GetInstance()-&gt;LPush(&quot;lpushkey1&quot;, &quot;lpushvalue3&quot;)); assert(RedisMgr::GetInstance()-&gt;RPop(&quot;lpushkey1&quot;, value)); assert(RedisMgr::GetInstance()-&gt;RPop(&quot;lpushkey1&quot;, value)); assert(RedisMgr::GetInstance()-&gt;LPop(&quot;lpushkey1&quot;, value)); assert(RedisMgr::GetInstance()-&gt;LPop(&quot;lpushkey2&quot;, value)==false); RedisMgr::GetInstance()-&gt;Close();&#125; 封装redis连接池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class RedisConPool &#123;public: RedisConPool(size_t poolSize, const char* host, int port, const char* pwd) : poolSize_(poolSize), host_(host), port_(port), b_stop_(false)&#123; for (size_t i = 0; i &lt; poolSize_; ++i) &#123; auto* context = redisConnect(host, port); if (context == nullptr || context-&gt;err != 0) &#123; if (context != nullptr) &#123; redisFree(context); &#125; continue; &#125; auto reply = (redisReply*)redisCommand(context, &quot;AUTH %s&quot;, pwd); if (reply-&gt;type == REDIS_REPLY_ERROR) &#123; std::cout &lt;&lt; &quot;认证失败&quot; &lt;&lt; std::endl; //执行成功 释放redisCommand执行后返回的redisReply所占用的内存 freeReplyObject(reply); continue; &#125; //执行成功 释放redisCommand执行后返回的redisReply所占用的内存 freeReplyObject(reply); std::cout &lt;&lt; &quot;认证成功&quot; &lt;&lt; std::endl; connections_.push(context); &#125; &#125; ~RedisConPool() &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); while (!connections_.empty()) &#123; connections_.pop(); &#125; &#125; redisContext* getConnection() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); cond_.wait(lock, [this] &#123; if (b_stop_) &#123; return true; &#125; return !connections_.empty(); &#125;); //如果停止则直接返回空指针 if (b_stop_) &#123; return nullptr; &#125; auto* context = connections_.front(); connections_.pop(); return context; &#125; void returnConnection(redisContext* context) &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); if (b_stop_) &#123; return; &#125; connections_.push(context); cond_.notify_one(); &#125; void Close() &#123; b_stop_ = true; cond_.notify_all(); &#125;private: atomic&lt;bool&gt; b_stop_; size_t poolSize_; const char* host_; int port_; std::queue&lt;redisContext*&gt; connections_; std::mutex mutex_; std::condition_variable cond_;&#125;; RedisMgr构造函数中初始化pool连接池 1234567RedisMgr::RedisMgr() &#123; auto&amp; gCfgMgr = ConfigMgr::Inst(); auto host = gCfgMgr[&quot;Redis&quot;][&quot;Host&quot;]; auto port = gCfgMgr[&quot;Redis&quot;][&quot;Port&quot;]; auto pwd = gCfgMgr[&quot;Redis&quot;][&quot;Passwd&quot;]; _con_pool.reset(new RedisConPool(5, host.c_str(), atoi(port.c_str()), pwd.c_str()));&#125; 在析构函数中回收资源 1234567RedisMgr::~RedisMgr() &#123; Close();&#125;void RedisMgr::Close() &#123; _con_pool-&gt;Close();&#125; 在使用的时候改为从Pool中获取链接 12345678910111213141516171819202122232425262728bool RedisMgr::Get(const std::string&amp; key, std::string&amp; value)&#123; auto connect = _con_pool-&gt;getConnection(); if (connect == nullptr) &#123; return false; &#125; auto reply = (redisReply*)redisCommand(connect, &quot;GET %s&quot;, key.c_str()); if (reply == NULL) &#123; std::cout &lt;&lt; &quot;[ GET &quot; &lt;&lt; key &lt;&lt; &quot; ] failed&quot; &lt;&lt; std::endl; freeReplyObject(reply); _con_pool-&gt;returnConnection(connect); return false; &#125; if (reply-&gt;type != REDIS_REPLY_STRING) &#123; std::cout &lt;&lt; &quot;[ GET &quot; &lt;&lt; key &lt;&lt; &quot; ] failed&quot; &lt;&lt; std::endl; freeReplyObject(reply); _con_pool-&gt;returnConnection(connect); return false; &#125; value = reply-&gt;str; freeReplyObject(reply); std::cout &lt;&lt; &quot;Succeed to execute command [ GET &quot; &lt;&lt; key &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl; _con_pool-&gt;returnConnection(connect); return true;&#125; 总结本节告诉大家如何搭建redis服务，linux和windows环境的，并且编译了windows版本的hredis库，解决了链接错误，而且封装了RedisMgr管理类。并实现了测试用例，大家感兴趣可以测试一下。下一节实现VarifyServer访问的redis功能。","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(28) 分布式服务通知好友申请","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro28/","text":"简介本文介绍如何实现用户查找和好友申请功能。查找和申请好友会涉及前后端通信和rpc服务间调用。所以目前先从客户端入手，搜索用户后发送查找好友申请请求给服务器，服务器收到后判断是否存在，如果不存在则显示未找到，如果存在则显示查找到的结果 点击查询客户端点击搜索列表的添加好友item后，先弹出一个模态对话框，上面有loading动作表示加载，直到服务器返回结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void SearchList::slot_item_clicked(QListWidgetItem *item)&#123; QWidget *widget = this-&gt;itemWidget(item); //获取自定义widget对象 if(!widget)&#123; qDebug()&lt;&lt; &quot;slot item clicked widget is nullptr&quot;; return; &#125; // 对自定义widget进行操作， 将item 转化为基类ListItemBase ListItemBase *customItem = qobject_cast&lt;ListItemBase*&gt;(widget); if(!customItem)&#123; qDebug()&lt;&lt; &quot;slot item clicked widget is nullptr&quot;; return; &#125; auto itemType = customItem-&gt;GetItemType(); if(itemType == ListItemType::INVALID_ITEM)&#123; qDebug()&lt;&lt; &quot;slot invalid item clicked &quot;; return; &#125; if(itemType == ListItemType::ADD_USER_TIP_ITEM)&#123; if(_send_pending)&#123; return; &#125; if (!_search_edit) &#123; return; &#125; waitPending(true); auto search_edit = dynamic_cast&lt;CustomizeEdit*&gt;(_search_edit); auto uid_str = search_edit-&gt;text(); QJsonObject jsonObj; jsonObj[&quot;uid&quot;] = uid_str; QJsonDocument doc(jsonObj); QByteArray jsonData = doc.toJson(QJsonDocument::Compact); emit TcpMgr::GetInstance()-&gt;sig_send_data(ReqId::ID_SEARCH_USER_REQ, jsonData); return; &#125; //清楚弹出框 CloseFindDlg();&#125; _send_pending为新增的成员变量，如果为true则表示发送阻塞.构造函数中将其设置为false。 waitPending函数为根据pending状态展示加载框 12345678910111213void SearchList::waitPending(bool pending)&#123; if(pending)&#123; _loadingDialog = new LoadingDlg(this); _loadingDialog-&gt;setModal(true); _loadingDialog-&gt;show(); _send_pending = pending; &#125;else&#123; _loadingDialog-&gt;hide(); _loadingDialog-&gt;deleteLater(); _send_pending = pending; &#125;&#125; 当我们发送数据后服务器会处理，返回ID_SEARCH_USER_RSP包，所以客户端要实现对ID_SEARCH_USER_RSP包的处理 1234567891011121314151617181920212223242526272829303132333435_handlers.insert(ID_SEARCH_USER_RSP, [this](ReqId id, int len, QByteArray data)&#123; Q_UNUSED(len); qDebug()&lt;&lt; &quot;handle id is &quot;&lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if(jsonDoc.isNull())&#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if(!jsonObj.contains(&quot;error&quot;))&#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Login Failed, err is Json Parse Err&quot; &lt;&lt; err ; emit sig_login_failed(err); return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if(err != ErrorCodes::SUCCESS)&#123; qDebug() &lt;&lt; &quot;Login Failed, err is &quot; &lt;&lt; err ; emit sig_login_failed(err); return; &#125; auto search_info = std::make_shared&lt;SearchInfo&gt;(jsonObj[&quot;uid&quot;].toInt(), jsonObj[&quot;name&quot;].toString(), jsonObj[&quot;nick&quot;].toString(), jsonObj[&quot;desc&quot;].toString(), jsonObj[&quot;sex&quot;].toInt(), jsonObj[&quot;icon&quot;].toString()); emit sig_user_search(search_info);&#125;); 将搜索到的结果封装为search_info发送给SearchList类做展示, search_list中连接信号和槽 12//连接搜索条目connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_user_search, this, &amp;SearchList::slot_user_search); slot_user_search槽函数弹出搜索结果 1234567891011121314void SearchList::slot_user_search(std::shared_ptr&lt;SearchInfo&gt; si)&#123; waitPending(false); if(si == nullptr)&#123; _find_dlg = std::make_shared&lt;FindFailDlg&gt;(this); &#125;else&#123; //此处分两种情况，一种是搜多到已经是自己的朋友了，一种是未添加好友 //查找是否已经是好友 todo... _find_dlg = std::make_shared&lt;FindSuccessDlg&gt;(this); std::dynamic_pointer_cast&lt;FindSuccessDlg&gt;(_find_dlg)-&gt;SetSearchInfo(si); &#125; _find_dlg-&gt;show();&#125; FindSuccessDlg是找到的结果展示，FindFailDlg是未找到结果展示。以下为FindSuccessDlg的ui布局 具体声明如下 123456789101112131415161718class FindSuccessDlg : public QDialog&#123; Q_OBJECTpublic: explicit FindSuccessDlg(QWidget *parent = nullptr); ~FindSuccessDlg(); void SetSearchInfo(std::shared_ptr&lt;SearchInfo&gt; si);private: Ui::FindSuccessDlg *ui; std::shared_ptr&lt;SearchInfo&gt; _si; QWidget * _parent;private slots: void on_add_friend_btn_clicked();&#125;; 具体实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243FindSuccessDlg::FindSuccessDlg(QWidget *parent) : QDialog(parent), _parent(parent), ui(new Ui::FindSuccessDlg)&#123; ui-&gt;setupUi(this); // 设置对话框标题 setWindowTitle(&quot;添加&quot;); // 隐藏对话框标题栏 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); // 获取当前应用程序的路径 QString app_path = QCoreApplication::applicationDirPath(); QString pix_path = QDir::toNativeSeparators(app_path + QDir::separator() + &quot;static&quot;+QDir::separator()+&quot;head_1.jpg&quot;); QPixmap head_pix(pix_path); head_pix = head_pix.scaled(ui-&gt;head_lb-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation); ui-&gt;head_lb-&gt;setPixmap(head_pix); ui-&gt;add_friend_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); this-&gt;setModal(true);&#125;FindSuccessDlg::~FindSuccessDlg()&#123; qDebug()&lt;&lt;&quot;FindSuccessDlg destruct&quot;; delete ui;&#125;void FindSuccessDlg::SetSearchInfo(std::shared_ptr&lt;SearchInfo&gt; si)&#123; ui-&gt;name_lb-&gt;setText(si-&gt;_name); _si = si;&#125;void FindSuccessDlg::on_add_friend_btn_clicked()&#123; //todo... 添加好友界面弹出 this-&gt;hide(); //弹出加好友界面 auto applyFriend = new ApplyFriend(_parent); applyFriend-&gt;SetSearchInfo(_si); applyFriend-&gt;setModal(true); applyFriend-&gt;show();&#125; 类似的FindFailDlg也是这种思路，大家自己实现即可。 服务器查询逻辑chatserver服务器要根据客户端发送过来的用户id进行查找,chatserver服务器需先注册ID_SEARCH_USER_REQ和回调函数 1234567void LogicSystem::RegisterCallBacks() &#123; _fun_callbacks[MSG_CHAT_LOGIN] = std::bind(&amp;LogicSystem::LoginHandler, this, placeholders::_1, placeholders::_2, placeholders::_3); _fun_callbacks[ID_SEARCH_USER_REQ] = std::bind(&amp;LogicSystem::SearchInfo, this, placeholders::_1, placeholders::_2, placeholders::_3);&#125; SearchInfo根据用户uid查询具体信息 12345678910111213141516171819202122void LogicSystem::SearchInfo(std::shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid_str = root[&quot;uid&quot;].asString(); std::cout &lt;&lt; &quot;user SearchInfo uid is &quot; &lt;&lt; uid_str &lt;&lt; endl; Json::Value rtvalue; Defer deder([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_SEARCH_USER_RSP); &#125;); bool b_digit = isPureDigit(uid_str); if (b_digit) &#123; GetUserByUid(uid_str, rtvalue); &#125; else &#123; GetUserByName(uid_str, rtvalue); &#125;&#125; 到此客户端和服务器搜索查询的联调功能已经解决了。 客户端添加好友当Client1搜索到好友后，点击添加弹出信息界面，然后点击确定即可向对方Client2申请添加好友，这个请求要先发送到Client1所在的服务器Server1，服务器收到后判断Client2所在服务器，如果Client2在Server1则直接在Server1中查找Client2的连接信息，没找到说明Client2未在内存中，找到了则通过Session发送tcp给对方。如果Client2不在Server1而在Server2上，则需要让Server1通过grpc接口通知Server2,Server2收到后继续判断Client2是否在线，如果在线则通知。 如下图，Client1想和Client2以及Client3分别通信，需要先将请求发给Client1所在的Server1，再考虑是否rpc调用。 客户端在ApplySure槽函数中添加好友请求 12345678910111213141516171819202122232425262728void ApplyFriend::SlotApplySure()&#123; qDebug() &lt;&lt; &quot;Slot Apply Sure called&quot; ; QJsonObject jsonObj; auto uid = UserMgr::GetInstance()-&gt;GetUid(); jsonObj[&quot;uid&quot;] = uid; auto name = ui-&gt;name_ed-&gt;text(); if(name.isEmpty())&#123; name = ui-&gt;name_ed-&gt;placeholderText(); &#125; jsonObj[&quot;applyname&quot;] = name; auto bakname = ui-&gt;back_ed-&gt;text(); if(bakname.isEmpty())&#123; bakname = ui-&gt;back_ed-&gt;placeholderText(); &#125; jsonObj[&quot;bakname&quot;] = bakname; jsonObj[&quot;touid&quot;] = _si-&gt;_uid; QJsonDocument doc(jsonObj); QByteArray jsonData = doc.toJson(QJsonDocument::Compact); //发送tcp请求给chat server emit TcpMgr::GetInstance()-&gt;sig_send_data(ReqId::ID_ADD_FRIEND_REQ, jsonData); this-&gt;hide(); deleteLater();&#125; 另一个客户端会收到服务器通知添加好友的请求,所以在TcpMgr里监听这个请求 123456789101112131415161718192021222324252627282930313233343536373839404142_handlers.insert(ID_NOTIFY_ADD_FRIEND_REQ, [this](ReqId id, int len, QByteArray data) &#123; Q_UNUSED(len); qDebug() &lt;&lt; &quot;handle id is &quot; &lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if (jsonDoc.isNull()) &#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if (!jsonObj.contains(&quot;error&quot;)) &#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Login Failed, err is Json Parse Err&quot; &lt;&lt; err; emit sig_user_search(nullptr); return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if (err != ErrorCodes::SUCCESS) &#123; qDebug() &lt;&lt; &quot;Login Failed, err is &quot; &lt;&lt; err; emit sig_user_search(nullptr); return; &#125; int from_uid = jsonObj[&quot;applyuid&quot;].toInt(); QString name = jsonObj[&quot;name&quot;].toString(); QString desc = jsonObj[&quot;desc&quot;].toString(); QString icon = jsonObj[&quot;icon&quot;].toString(); QString nick = jsonObj[&quot;nick&quot;].toString(); int sex = jsonObj[&quot;sex&quot;].toInt(); auto apply_info = std::make_shared&lt;AddFriendApply&gt;( from_uid, name, desc, icon, nick, sex); emit sig_friend_apply(apply_info); &#125;); 服务调用服务器要处理客户端发过来的添加好友的请求，并决定是否调用rpc通知其他服务。 先将AddFriendApply函数注册到回调map里 12345678910void LogicSystem::RegisterCallBacks() &#123; _fun_callbacks[MSG_CHAT_LOGIN] = std::bind(&amp;LogicSystem::LoginHandler, this, placeholders::_1, placeholders::_2, placeholders::_3); _fun_callbacks[ID_SEARCH_USER_REQ] = std::bind(&amp;LogicSystem::SearchInfo, this, placeholders::_1, placeholders::_2, placeholders::_3); _fun_callbacks[ID_ADD_FRIEND_REQ] = std::bind(&amp;LogicSystem::AddFriendApply, this, placeholders::_1, placeholders::_2, placeholders::_3);&#125; 接下来实现AddFriendApply 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void LogicSystem::AddFriendApply(std::shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid = root[&quot;uid&quot;].asInt(); auto applyname = root[&quot;applyname&quot;].asString(); auto bakname = root[&quot;bakname&quot;].asString(); auto touid = root[&quot;touid&quot;].asInt(); std::cout &lt;&lt; &quot;user login uid is &quot; &lt;&lt; uid &lt;&lt; &quot; applyname is &quot; &lt;&lt; applyname &lt;&lt; &quot; bakname is &quot; &lt;&lt; bakname &lt;&lt; &quot; touid is &quot; &lt;&lt; touid &lt;&lt; endl; Json::Value rtvalue; rtvalue[&quot;error&quot;] = ErrorCodes::Success; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_ADD_FRIEND_RSP); &#125;); //先更新数据库 MysqlMgr::GetInstance()-&gt;AddFriendApply(uid, touid); //查询redis 查找touid对应的server ip auto to_str = std::to_string(touid); auto to_ip_key = USERIPPREFIX + to_str; std::string to_ip_value = &quot;&quot;; bool b_ip = RedisMgr::GetInstance()-&gt;Get(to_ip_key, to_ip_value); if (!b_ip) &#123; return; &#125; auto&amp; cfg = ConfigMgr::Inst(); auto self_name = cfg[&quot;SelfServer&quot;][&quot;Name&quot;]; //直接通知对方有申请消息 if (to_ip_value == self_name) &#123; auto session = UserMgr::GetInstance()-&gt;GetSession(touid); if (session) &#123; //在内存中则直接发送通知对方 Json::Value notify; notify[&quot;error&quot;] = ErrorCodes::Success; notify[&quot;applyuid&quot;] = uid; notify[&quot;name&quot;] = applyname; notify[&quot;desc&quot;] = &quot;&quot;; std::string return_str = notify.toStyledString(); session-&gt;Send(return_str, ID_NOTIFY_ADD_FRIEND_REQ); &#125; return; &#125; std::string base_key = USER_BASE_INFO + std::to_string(uid); auto apply_info = std::make_shared&lt;UserInfo&gt;(); bool b_info = GetBaseInfo(base_key, uid, apply_info); AddFriendReq add_req; add_req.set_applyuid(uid); add_req.set_touid(touid); add_req.set_name(applyname); add_req.set_desc(&quot;&quot;); if (b_info) &#123; add_req.set_icon(apply_info-&gt;icon); add_req.set_sex(apply_info-&gt;sex); add_req.set_nick(apply_info-&gt;nick); &#125; //发送通知 ChatGrpcClient::GetInstance()-&gt;NotifyAddFriend(to_ip_value, add_req);&#125; 上面的函数中先更新数据库将申请写入数据库中 123bool MysqlMgr::AddFriendApply(const int&amp; from, const int&amp; to) &#123; return _dao.AddFriendApply(from, to);&#125; 内部调用dao层面的添加好友请求 1234567891011121314151617181920212223242526272829303132bool MysqlDao::AddFriendApply(const int&amp; from, const int&amp; to) &#123; auto con = pool_-&gt;getConnection(); if (con == nullptr) &#123; return false; &#125; Defer defer([this, &amp;con]() &#123; pool_-&gt;returnConnection(std::move(con)); &#125;); try &#123; std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(con-&gt;_con-&gt;prepareStatement(&quot;INSERT INTO friend_apply (from_uid, to_uid) values (?,?) &quot; &quot;ON DUPLICATE KEY UPDATE from_uid = from_uid, to_uid = to_uid &quot;)); pstmt-&gt;setInt(1, from); pstmt-&gt;setInt(2, to); //执行更新 int rowAffected = pstmt-&gt;executeUpdate(); if (rowAffected &lt; 0) &#123; return false; &#125; return true; &#125; catch (sql::SQLException&amp; e) &#123; std::cerr &lt;&lt; &quot;SQLException: &quot; &lt;&lt; e.what(); std::cerr &lt;&lt; &quot; (MySQL error code: &quot; &lt;&lt; e.getErrorCode(); std::cerr &lt;&lt; &quot;, SQLState: &quot; &lt;&lt; e.getSQLState() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl; return false; &#125; return true;&#125; 添加完成后判断要通知的对端是否在本服务器，如果在本服务器则直接通过uid查找session，判断用户是否在线，如果在线则直接通知对端。 如果不在本服务器，则需要通过rpc通知对端服务器。rpc的客户端这么写即可。 12345678910111213141516171819202122232425262728AddFriendRsp ChatGrpcClient::NotifyAddFriend(std::string server_ip, const AddFriendReq&amp; req) &#123; AddFriendRsp rsp; Defer defer([&amp;rsp, &amp;req]() &#123; rsp.set_error(ErrorCodes::Success); rsp.set_applyuid(req.applyuid()); rsp.set_touid(req.touid()); &#125;); auto find_iter = _pools.find(server_ip); if (find_iter == _pools.end()) &#123; return rsp; &#125; auto&amp; pool = find_iter-&gt;second; ClientContext context; auto stub = pool-&gt;getConnection(); Status status = stub-&gt;NotifyAddFriend(&amp;context, req, &amp;rsp); Defer defercon([&amp;stub, this, &amp;pool]() &#123; pool-&gt;returnConnection(std::move(stub)); &#125;); if (!status.ok()) &#123; rsp.set_error(ErrorCodes::RPCFailed); return rsp; &#125; return rsp;&#125; 同样rpc的服务端也要实现，我们先将rpc客户端和服务端的逻辑都在ChatServer1写好，然后复制给ChatServer2即可。 rpc的服务实现如下 123456789101112131415161718192021222324252627282930313233Status ChatServiceImpl::NotifyAddFriend(ServerContext* context, const AddFriendReq* request, AddFriendRsp* reply) &#123; //查找用户是否在本服务器 auto touid = request-&gt;touid(); auto session = UserMgr::GetInstance()-&gt;GetSession(touid); Defer defer([request, reply]() &#123; reply-&gt;set_error(ErrorCodes::Success); reply-&gt;set_applyuid(request-&gt;applyuid()); reply-&gt;set_touid(request-&gt;touid()); &#125;); //用户不在内存中则直接返回 if (session == nullptr) &#123; return Status::OK; &#125; //在内存中则直接发送通知对方 Json::Value rtvalue; rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;applyuid&quot;] = request-&gt;applyuid(); rtvalue[&quot;name&quot;] = request-&gt;name(); rtvalue[&quot;desc&quot;] = request-&gt;desc(); rtvalue[&quot;icon&quot;] = request-&gt;icon(); rtvalue[&quot;sex&quot;] = request-&gt;sex(); rtvalue[&quot;nick&quot;] = request-&gt;nick(); std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_NOTIFY_ADD_FRIEND_REQ); return Status::OK;&#125; 上面的代码也是判断要通知的客户端是否在内存中，如果在就通过session发送tcp请求。 将ChatServer1的代码拷贝给ChatServer2,重启两个服务，再启动两个客户端，一个客户端申请另一个客户端，通过查看客户端日志是能看到申请信息的。 申请显示接下来被通知申请的客户端要做界面显示，我们实现被通知的客户端收到sig_friend_apply信号的处理逻辑。在ChatDialog的构造函数中连接信号和槽 12//连接申请添加好友信号 connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_friend_apply, this, &amp;ChatDialog::slot_apply_friend); 实现申请好友的槽函数 123456789101112131415void ChatDialog::slot_apply_friend(std::shared_ptr&lt;AddFriendApply&gt; apply)&#123; qDebug() &lt;&lt; &quot;receive apply friend slot, applyuid is &quot; &lt;&lt; apply-&gt;_from_uid &lt;&lt; &quot; name is &quot; &lt;&lt; apply-&gt;_name &lt;&lt; &quot; desc is &quot; &lt;&lt; apply-&gt;_desc; bool b_already = UserMgr::GetInstance()-&gt;AlreadyApply(apply-&gt;_from_uid); if(b_already)&#123; return; &#125; UserMgr::GetInstance()-&gt;AddApplyList(std::make_shared&lt;ApplyInfo&gt;(apply)); ui-&gt;side_contact_lb-&gt;ShowRedPoint(true); ui-&gt;con_user_list-&gt;ShowRedPoint(true); ui-&gt;friend_apply_page-&gt;AddNewApply(apply);&#125; 这样就能显示新的申请消息和红点了。具体添加一个新的申请条目到申请好友页面的逻辑如下： 123456789101112131415161718192021222324void ApplyFriendPage::AddNewApply(std::shared_ptr&lt;AddFriendApply&gt; apply)&#123; //先模拟头像随机，以后头像资源增加资源服务器后再显示 int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int head_i = randomValue % heads.size(); auto* apply_item = new ApplyFriendItem(); auto apply_info = std::make_shared&lt;ApplyInfo&gt;(apply-&gt;_from_uid, apply-&gt;_name, apply-&gt;_desc,heads[head_i], apply-&gt;_name, 0, 0); apply_item-&gt;SetInfo( apply_info); QListWidgetItem* item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(apply_item-&gt;sizeHint()); item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable); ui-&gt;apply_friend_list-&gt;insertItem(0,item); ui-&gt;apply_friend_list-&gt;setItemWidget(item, apply_item); apply_item-&gt;ShowAddBtn(true); //收到审核好友信号 connect(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [this](std::shared_ptr&lt;ApplyInfo&gt; apply_info) &#123; auto* authFriend = new AuthenFriend(this); authFriend-&gt;setModal(true); authFriend-&gt;SetApplyInfo(apply_info); authFriend-&gt;show(); &#125;);&#125; 测试效果, 收到对方请求后如下图 登录加载申请当用户登录后，服务器需要将申请列表同步给客户端, 写在登录逻辑里。 12345678910111213141516 //从数据库获取申请列表std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt; apply_list;auto b_apply = GetFriendApplyInfo(uid,apply_list);if (b_apply) &#123; for (auto &amp; apply : apply_list) &#123; Json::Value obj; obj[&quot;name&quot;] = apply-&gt;_name; obj[&quot;uid&quot;] = apply-&gt;_uid; obj[&quot;icon&quot;] = apply-&gt;_icon; obj[&quot;nick&quot;] = apply-&gt;_nick; obj[&quot;sex&quot;] = apply-&gt;_sex; obj[&quot;desc&quot;] = apply-&gt;_desc; obj[&quot;status&quot;] = apply-&gt;_status; rtvalue[&quot;apply_list&quot;].append(obj); &#125;&#125; 获取好友申请信息函数 1234bool LogicSystem::GetFriendApplyInfo(int to_uid, std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt; &amp;list) &#123; //从mysql获取好友申请列表 return MysqlMgr::GetInstance()-&gt;GetApplyList(to_uid, list, 0, 10);&#125; dao层面实现获取申请列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool MysqlMgr::GetApplyList(int touid, std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt;&amp; applyList, int begin, int limit) &#123; return _dao.GetApplyList(touid, applyList, begin, limit);&#125;bool MysqlDao::GetApplyList(int touid, std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt;&amp; applyList, int begin, int limit) &#123; auto con = pool_-&gt;getConnection(); if (con == nullptr) &#123; return false; &#125; Defer defer([this, &amp;con]() &#123; pool_-&gt;returnConnection(std::move(con)); &#125;); try &#123; // 准备SQL语句, 根据起始id和限制条数返回列表 std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(con-&gt;_con-&gt;prepareStatement(&quot;select apply.from_uid, apply.status, user.name, &quot; &quot;user.nick, user.sex from friend_apply as apply join user on apply.from_uid = user.uid where apply.to_uid = ? &quot; &quot;and apply.id &gt; ? order by apply.id ASC LIMIT ? &quot;)); pstmt-&gt;setInt(1, touid); // 将uid替换为你要查询的uid pstmt-&gt;setInt(2, begin); // 起始id pstmt-&gt;setInt(3, limit); //偏移量 // 执行查询 std::unique_ptr&lt;sql::ResultSet&gt; res(pstmt-&gt;executeQuery()); // 遍历结果集 while (res-&gt;next()) &#123; auto name = res-&gt;getString(&quot;name&quot;); auto uid = res-&gt;getInt(&quot;from_uid&quot;); auto status = res-&gt;getInt(&quot;status&quot;); auto nick = res-&gt;getString(&quot;nick&quot;); auto sex = res-&gt;getInt(&quot;sex&quot;); auto apply_ptr = std::make_shared&lt;ApplyInfo&gt;(uid, name, &quot;&quot;, &quot;&quot;, nick, sex, status); applyList.push_back(apply_ptr); &#125; return true; &#125; catch (sql::SQLException&amp; e) &#123; std::cerr &lt;&lt; &quot;SQLException: &quot; &lt;&lt; e.what(); std::cerr &lt;&lt; &quot; (MySQL error code: &quot; &lt;&lt; e.getErrorCode(); std::cerr &lt;&lt; &quot;, SQLState: &quot; &lt;&lt; e.getSQLState() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl; return false; &#125;&#125; 好友认证界面客户端需要实现好友认证界面，当点击同意对方好友申请后，弹出认证信息，点击确定后将认证同意的请求发给服务器，服务器再通知申请方，告知对方被申请人已经同意加好友了。认证界面和申请界面类似, 这个大家自己实现即可。 认证界面的函数和逻辑可以照抄申请好友的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435AuthenFriend::AuthenFriend(QWidget *parent) : QDialog(parent), ui(new Ui::AuthenFriend),_label_point(2,6)&#123; ui-&gt;setupUi(this); // 隐藏对话框标题栏 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); this-&gt;setObjectName(&quot;AuthenFriend&quot;); this-&gt;setModal(true); ui-&gt;lb_ed-&gt;setPlaceholderText(&quot;搜索、添加标签&quot;); ui-&gt;back_ed-&gt;setPlaceholderText(&quot;燃烧的胸毛&quot;); ui-&gt;lb_ed-&gt;SetMaxLength(21); ui-&gt;lb_ed-&gt;move(2, 2); ui-&gt;lb_ed-&gt;setFixedHeight(20); ui-&gt;lb_ed-&gt;setMaxLength(10); ui-&gt;input_tip_wid-&gt;hide(); _tip_cur_point = QPoint(5, 5); _tip_data = &#123; &quot;同学&quot;,&quot;家人&quot;,&quot;菜鸟教程&quot;,&quot;C++ Primer&quot;,&quot;Rust 程序设计&quot;, &quot;父与子学Python&quot;,&quot;nodejs开发指南&quot;,&quot;go 语言开发指南&quot;, &quot;游戏伙伴&quot;,&quot;金融投资&quot;,&quot;微信读书&quot;,&quot;拼多多拼友&quot; &#125;; connect(ui-&gt;more_lb, &amp;ClickedOnceLabel::clicked, this, &amp;AuthenFriend::ShowMoreLabel); InitTipLbs(); //链接输入标签回车事件 connect(ui-&gt;lb_ed, &amp;CustomizeEdit::returnPressed, this, &amp;AuthenFriend::SlotLabelEnter); connect(ui-&gt;lb_ed, &amp;CustomizeEdit::textChanged, this, &amp;AuthenFriend::SlotLabelTextChange); connect(ui-&gt;lb_ed, &amp;CustomizeEdit::editingFinished, this, &amp;AuthenFriend::SlotLabelEditFinished); connect(ui-&gt;tip_lb, &amp;ClickedOnceLabel::clicked, this, &amp;AuthenFriend::SlotAddFirendLabelByClickTip); ui-&gt;scrollArea-&gt;horizontalScrollBar()-&gt;setHidden(true); ui-&gt;scrollArea-&gt;verticalScrollBar()-&gt;setHidden(true); ui-&gt;scrollArea-&gt;installEventFilter(this); ui-&gt;sure_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); ui-&gt;cancel_btn-&gt;SetState(&quot;normal&quot;,&quot;hover&quot;,&quot;press&quot;); //连接确认和取消按钮的槽函数 connect(ui-&gt;cancel_btn, &amp;QPushButton::clicked, this, &amp;AuthenFriend::SlotApplyCancel); connect(ui-&gt;sure_btn, &amp;QPushButton::clicked, this, &amp;AuthenFriend::SlotApplySure);&#125;AuthenFriend::~AuthenFriend()&#123; qDebug()&lt;&lt; &quot;AuthenFriend destruct&quot;; delete ui;&#125;void AuthenFriend::InitTipLbs()&#123; int lines = 1; for(int i = 0; i &lt; _tip_data.size(); i++)&#123; auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(_tip_data[i]); connect(lb, &amp;ClickedLabel::clicked, this, &amp;AuthenFriend::SlotChangeFriendLabelByTip); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 if (_tip_cur_point.x() + textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;width()) &#123; lines++; if (lines &gt; 2) &#123; delete lb; return; &#125; _tip_cur_point.setX(tip_offset); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; auto next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point,next_point, textWidth, textHeight); _tip_cur_point = next_point; &#125;&#125;void AuthenFriend::AddTipLbs(ClickedLabel* lb, QPoint cur_point, QPoint&amp; next_point, int text_width, int text_height)&#123; lb-&gt;move(cur_point); lb-&gt;show(); _add_labels.insert(lb-&gt;text(), lb); _add_label_keys.push_back(lb-&gt;text()); next_point.setX(lb-&gt;pos().x() + text_width + 15); next_point.setY(lb-&gt;pos().y());&#125;bool AuthenFriend::eventFilter(QObject *obj, QEvent *event)&#123; if (obj == ui-&gt;scrollArea &amp;&amp; event-&gt;type() == QEvent::Enter) &#123; ui-&gt;scrollArea-&gt;verticalScrollBar()-&gt;setHidden(false); &#125; else if (obj == ui-&gt;scrollArea &amp;&amp; event-&gt;type() == QEvent::Leave) &#123; ui-&gt;scrollArea-&gt;verticalScrollBar()-&gt;setHidden(true); &#125; return QObject::eventFilter(obj, event);&#125;void AuthenFriend::SetApplyInfo(std::shared_ptr&lt;ApplyInfo&gt; apply_info)&#123; _apply_info = apply_info; ui-&gt;back_ed-&gt;setPlaceholderText(apply_info-&gt;_name);&#125;void AuthenFriend::ShowMoreLabel()&#123; qDebug()&lt;&lt; &quot;receive more label clicked&quot;; ui-&gt;more_lb_wid-&gt;hide(); ui-&gt;lb_list-&gt;setFixedWidth(325); _tip_cur_point = QPoint(5, 5); auto next_point = _tip_cur_point; int textWidth; int textHeight; //重拍现有的label for(auto &amp; added_key : _add_label_keys)&#123; auto added_lb = _add_labels[added_key]; QFontMetrics fontMetrics(added_lb-&gt;font()); // 获取QLabel控件的字体信息 textWidth = fontMetrics.width(added_lb-&gt;text()); // 获取文本的宽度 textHeight = fontMetrics.height(); // 获取文本的高度 if(_tip_cur_point.x() +textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;width())&#123; _tip_cur_point.setX(tip_offset); _tip_cur_point.setY(_tip_cur_point.y()+textHeight+15); &#125; added_lb-&gt;move(_tip_cur_point); next_point.setX(added_lb-&gt;pos().x() + textWidth + 15); next_point.setY(_tip_cur_point.y()); _tip_cur_point = next_point; &#125; //添加未添加的 for(int i = 0; i &lt; _tip_data.size(); i++)&#123; auto iter = _add_labels.find(_tip_data[i]); if(iter != _add_labels.end())&#123; continue; &#125; auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(_tip_data[i]); connect(lb, &amp;ClickedLabel::clicked, this, &amp;AuthenFriend::SlotChangeFriendLabelByTip); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 if (_tip_cur_point.x() + textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;width()) &#123; _tip_cur_point.setX(tip_offset); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point, next_point, textWidth, textHeight); _tip_cur_point = next_point; &#125; int diff_height = next_point.y() + textHeight + tip_offset - ui-&gt;lb_list-&gt;height(); ui-&gt;lb_list-&gt;setFixedHeight(next_point.y() + textHeight + tip_offset); //qDebug()&lt;&lt;&quot;after resize ui-&gt;lb_list size is &quot; &lt;&lt; ui-&gt;lb_list-&gt;size(); ui-&gt;scrollcontent-&gt;setFixedHeight(ui-&gt;scrollcontent-&gt;height()+diff_height);&#125;void AuthenFriend::resetLabels()&#123; auto max_width = ui-&gt;gridWidget-&gt;width(); auto label_height = 0; for(auto iter = _friend_labels.begin(); iter != _friend_labels.end(); iter++)&#123; //todo... 添加宽度统计 if( _label_point.x() + iter.value()-&gt;width() &gt; max_width) &#123; _label_point.setY(_label_point.y()+iter.value()-&gt;height()+6); _label_point.setX(2); &#125; iter.value()-&gt;move(_label_point); iter.value()-&gt;show(); _label_point.setX(_label_point.x()+iter.value()-&gt;width()+2); _label_point.setY(_label_point.y()); label_height = iter.value()-&gt;height(); &#125; if(_friend_labels.isEmpty())&#123; ui-&gt;lb_ed-&gt;move(_label_point); return; &#125; if(_label_point.x() + MIN_APPLY_LABEL_ED_LEN &gt; ui-&gt;gridWidget-&gt;width())&#123; ui-&gt;lb_ed-&gt;move(2,_label_point.y()+label_height+6); &#125;else&#123; ui-&gt;lb_ed-&gt;move(_label_point); &#125;&#125;void AuthenFriend::addLabel(QString name)&#123; if (_friend_labels.find(name) != _friend_labels.end()) &#123; return; &#125; auto tmplabel = new FriendLabel(ui-&gt;gridWidget); tmplabel-&gt;SetText(name); tmplabel-&gt;setObjectName(&quot;FriendLabel&quot;); auto max_width = ui-&gt;gridWidget-&gt;width(); //todo... 添加宽度统计 if (_label_point.x() + tmplabel-&gt;width() &gt; max_width) &#123; _label_point.setY(_label_point.y() + tmplabel-&gt;height() + 6); _label_point.setX(2); &#125; else &#123; &#125; tmplabel-&gt;move(_label_point); tmplabel-&gt;show(); _friend_labels[tmplabel-&gt;Text()] = tmplabel; _friend_label_keys.push_back(tmplabel-&gt;Text()); connect(tmplabel, &amp;FriendLabel::sig_close, this, &amp;AuthenFriend::SlotRemoveFriendLabel); _label_point.setX(_label_point.x() + tmplabel-&gt;width() + 2); if (_label_point.x() + MIN_APPLY_LABEL_ED_LEN &gt; ui-&gt;gridWidget-&gt;width()) &#123; ui-&gt;lb_ed-&gt;move(2, _label_point.y() + tmplabel-&gt;height() + 2); &#125; else &#123; ui-&gt;lb_ed-&gt;move(_label_point); &#125; ui-&gt;lb_ed-&gt;clear(); if (ui-&gt;gridWidget-&gt;height() &lt; _label_point.y() + tmplabel-&gt;height() + 2) &#123; ui-&gt;gridWidget-&gt;setFixedHeight(_label_point.y() + tmplabel-&gt;height() * 2 + 2); &#125;&#125;void AuthenFriend::SlotLabelEnter()&#123; if(ui-&gt;lb_ed-&gt;text().isEmpty())&#123; return; &#125; addLabel(ui-&gt;lb_ed-&gt;text()); ui-&gt;input_tip_wid-&gt;hide();&#125;void AuthenFriend::SlotRemoveFriendLabel(QString name)&#123; qDebug() &lt;&lt; &quot;receive close signal&quot;; _label_point.setX(2); _label_point.setY(6); auto find_iter = _friend_labels.find(name); if(find_iter == _friend_labels.end())&#123; return; &#125; auto find_key = _friend_label_keys.end(); for(auto iter = _friend_label_keys.begin(); iter != _friend_label_keys.end(); iter++)&#123; if(*iter == name)&#123; find_key = iter; break; &#125; &#125; if(find_key != _friend_label_keys.end())&#123; _friend_label_keys.erase(find_key); &#125; delete find_iter.value(); _friend_labels.erase(find_iter); resetLabels(); auto find_add = _add_labels.find(name); if(find_add == _add_labels.end())&#123; return; &#125; find_add.value()-&gt;ResetNormalState();&#125;//点击标已有签添加或删除新联系人的标签void AuthenFriend::SlotChangeFriendLabelByTip(QString lbtext, ClickLbState state)&#123; auto find_iter = _add_labels.find(lbtext); if(find_iter == _add_labels.end())&#123; return; &#125; if(state == ClickLbState::Selected)&#123; //编写添加逻辑 addLabel(lbtext); return; &#125; if(state == ClickLbState::Normal)&#123; //编写删除逻辑 SlotRemoveFriendLabel(lbtext); return; &#125;&#125;void AuthenFriend::SlotLabelTextChange(const QString&amp; text)&#123; if (text.isEmpty()) &#123; ui-&gt;tip_lb-&gt;setText(&quot;&quot;); ui-&gt;input_tip_wid-&gt;hide(); return; &#125; auto iter = std::find(_tip_data.begin(), _tip_data.end(), text); if (iter == _tip_data.end()) &#123; auto new_text = add_prefix + text; ui-&gt;tip_lb-&gt;setText(new_text); ui-&gt;input_tip_wid-&gt;show(); return; &#125; ui-&gt;tip_lb-&gt;setText(text); ui-&gt;input_tip_wid-&gt;show();&#125;void AuthenFriend::SlotLabelEditFinished()&#123; ui-&gt;input_tip_wid-&gt;hide();&#125;void AuthenFriend::SlotAddFirendLabelByClickTip(QString text)&#123; int index = text.indexOf(add_prefix); if (index != -1) &#123; text = text.mid(index + add_prefix.length()); &#125; addLabel(text); //标签展示栏也增加一个标签, 并设置绿色选中 if (index != -1) &#123; _tip_data.push_back(text); &#125; auto* lb = new ClickedLabel(ui-&gt;lb_list); lb-&gt;SetState(&quot;normal&quot;, &quot;hover&quot;, &quot;pressed&quot;, &quot;selected_normal&quot;, &quot;selected_hover&quot;, &quot;selected_pressed&quot;); lb-&gt;setObjectName(&quot;tipslb&quot;); lb-&gt;setText(text); connect(lb, &amp;ClickedLabel::clicked, this, &amp;AuthenFriend::SlotChangeFriendLabelByTip); qDebug() &lt;&lt; &quot;ui-&gt;lb_list-&gt;width() is &quot; &lt;&lt; ui-&gt;lb_list-&gt;width(); qDebug() &lt;&lt; &quot;_tip_cur_point.x() is &quot; &lt;&lt; _tip_cur_point.x(); QFontMetrics fontMetrics(lb-&gt;font()); // 获取QLabel控件的字体信息 int textWidth = fontMetrics.width(lb-&gt;text()); // 获取文本的宽度 int textHeight = fontMetrics.height(); // 获取文本的高度 qDebug() &lt;&lt; &quot;textWidth is &quot; &lt;&lt; textWidth; if (_tip_cur_point.x() + textWidth+ tip_offset+3 &gt; ui-&gt;lb_list-&gt;width()) &#123; _tip_cur_point.setX(5); _tip_cur_point.setY(_tip_cur_point.y() + textHeight + 15); &#125; auto next_point = _tip_cur_point; AddTipLbs(lb, _tip_cur_point, next_point, textWidth,textHeight); _tip_cur_point = next_point; int diff_height = next_point.y() + textHeight + tip_offset - ui-&gt;lb_list-&gt;height(); ui-&gt;lb_list-&gt;setFixedHeight(next_point.y() + textHeight + tip_offset); lb-&gt;SetCurState(ClickLbState::Selected); ui-&gt;scrollcontent-&gt;setFixedHeight(ui-&gt;scrollcontent-&gt;height()+ diff_height );&#125;void AuthenFriend::SlotApplySure()&#123; qDebug() &lt;&lt; &quot;Slot Apply Sure &quot;; //添加发送逻辑 QJsonObject jsonObj; auto uid = UserMgr::GetInstance()-&gt;GetUid(); jsonObj[&quot;fromuid&quot;] = uid; jsonObj[&quot;touid&quot;] = _apply_info-&gt;_uid; QString back_name = &quot;&quot;; if(ui-&gt;back_ed-&gt;text().isEmpty())&#123; back_name = ui-&gt;back_ed-&gt;placeholderText(); &#125;else&#123; back_name = ui-&gt;back_ed-&gt;text(); &#125; jsonObj[&quot;back&quot;] = back_name; QJsonDocument doc(jsonObj); QByteArray jsonData = doc.toJson(QJsonDocument::Compact); //发送tcp请求给chat server emit TcpMgr::GetInstance()-&gt;sig_send_data(ReqId::ID_AUTH_FRIEND_REQ, jsonData); this-&gt;hide(); deleteLater();&#125;void AuthenFriend::SlotApplyCancel()&#123; this-&gt;hide(); deleteLater();&#125; 源码连接https://gitee.com/secondtonone1/llfcchat 视频连接https://www.bilibili.com/video/BV1Ex4y1s7cq/","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"聊天项目(29) 好友认证和聊天通信","date":"2024-08-31T01:30:35.000Z","path":"2024/08/31/cpppro29/","text":"好友认证服务器响应服务器接受客户端发送过来的好友认证请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void LogicSystem::AuthFriendApply(std::shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid = root[&quot;fromuid&quot;].asInt(); auto touid = root[&quot;touid&quot;].asInt(); auto back_name = root[&quot;back&quot;].asString(); std::cout &lt;&lt; &quot;from &quot; &lt;&lt; uid &lt;&lt; &quot; auth friend to &quot; &lt;&lt; touid &lt;&lt; std::endl; Json::Value rtvalue; rtvalue[&quot;error&quot;] = ErrorCodes::Success; auto user_info = std::make_shared&lt;UserInfo&gt;(); std::string base_key = USER_BASE_INFO + std::to_string(touid); bool b_info = GetBaseInfo(base_key, touid, user_info); if (b_info) &#123; rtvalue[&quot;name&quot;] = user_info-&gt;name; rtvalue[&quot;nick&quot;] = user_info-&gt;nick; rtvalue[&quot;icon&quot;] = user_info-&gt;icon; rtvalue[&quot;sex&quot;] = user_info-&gt;sex; rtvalue[&quot;uid&quot;] = touid; &#125; else &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; &#125; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_AUTH_FRIEND_RSP); &#125;); //先更新数据库 MysqlMgr::GetInstance()-&gt;AuthFriendApply(uid, touid); //更新数据库添加好友 MysqlMgr::GetInstance()-&gt;AddFriend(uid, touid,back_name); //查询redis 查找touid对应的server ip auto to_str = std::to_string(touid); auto to_ip_key = USERIPPREFIX + to_str; std::string to_ip_value = &quot;&quot;; bool b_ip = RedisMgr::GetInstance()-&gt;Get(to_ip_key, to_ip_value); if (!b_ip) &#123; return; &#125; auto&amp; cfg = ConfigMgr::Inst(); auto self_name = cfg[&quot;SelfServer&quot;][&quot;Name&quot;]; //直接通知对方有认证通过消息 if (to_ip_value == self_name) &#123; auto session = UserMgr::GetInstance()-&gt;GetSession(touid); if (session) &#123; //在内存中则直接发送通知对方 Json::Value notify; notify[&quot;error&quot;] = ErrorCodes::Success; notify[&quot;fromuid&quot;] = uid; notify[&quot;touid&quot;] = touid; std::string base_key = USER_BASE_INFO + std::to_string(uid); auto user_info = std::make_shared&lt;UserInfo&gt;(); bool b_info = GetBaseInfo(base_key, uid, user_info); if (b_info) &#123; notify[&quot;name&quot;] = user_info-&gt;name; notify[&quot;nick&quot;] = user_info-&gt;nick; notify[&quot;icon&quot;] = user_info-&gt;icon; notify[&quot;sex&quot;] = user_info-&gt;sex; &#125; else &#123; notify[&quot;error&quot;] = ErrorCodes::UidInvalid; &#125; std::string return_str = notify.toStyledString(); session-&gt;Send(return_str, ID_NOTIFY_AUTH_FRIEND_REQ); &#125; return ; &#125; AuthFriendReq auth_req; auth_req.set_fromuid(uid); auth_req.set_touid(touid); //发送通知 ChatGrpcClient::GetInstance()-&gt;NotifyAuthFriend(to_ip_value, auth_req);&#125; 将请求注册到map里，在LogicSystem::RegisterCallBacks中添加 12_fun_callbacks[ID_AUTH_FRIEND_REQ] = std::bind(&amp;LogicSystem::AuthFriendApply, this, placeholders::_1, placeholders::_2, placeholders::_3); 因为上面的逻辑调用了grpc发送通知，所以实现grpc发送认证通知的逻辑 1234567891011121314151617181920212223242526272829AuthFriendRsp ChatGrpcClient::NotifyAuthFriend(std::string server_ip, const AuthFriendReq&amp; req) &#123; AuthFriendRsp rsp; rsp.set_error(ErrorCodes::Success); Defer defer([&amp;rsp, &amp;req]() &#123; rsp.set_fromuid(req.fromuid()); rsp.set_touid(req.touid()); &#125;); auto find_iter = _pools.find(server_ip); if (find_iter == _pools.end()) &#123; return rsp; &#125; auto&amp; pool = find_iter-&gt;second; ClientContext context; auto stub = pool-&gt;getConnection(); Status status = stub-&gt;NotifyAuthFriend(&amp;context, req, &amp;rsp); Defer defercon([&amp;stub, this, &amp;pool]() &#123; pool-&gt;returnConnection(std::move(stub)); &#125;); if (!status.ok()) &#123; rsp.set_error(ErrorCodes::RPCFailed); return rsp; &#125; return rsp;&#125; 这里注意，stub之所以能发送通知，是因为proto里定义了认证通知等服务，大家记得更新proto和我的一样，这事完整的proto 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122syntax = &quot;proto3&quot;;package message;service VarifyService &#123; rpc GetVarifyCode (GetVarifyReq) returns (GetVarifyRsp) &#123;&#125;&#125;message GetVarifyReq &#123; string email = 1;&#125;message GetVarifyRsp &#123; int32 error = 1; string email = 2; string code = 3;&#125;message GetChatServerReq &#123; int32 uid = 1;&#125;message GetChatServerRsp &#123; int32 error = 1; string host = 2; string port = 3; string token = 4;&#125;message LoginReq&#123; int32 uid = 1; string token= 2;&#125;message LoginRsp &#123; int32 error = 1; int32 uid = 2; string token = 3;&#125;service StatusService &#123; rpc GetChatServer (GetChatServerReq) returns (GetChatServerRsp) &#123;&#125; rpc Login(LoginReq) returns(LoginRsp);&#125;message AddFriendReq &#123; int32 applyuid = 1; string name = 2; string desc = 3; string icon = 4; string nick = 5; int32 sex = 6; int32 touid = 7;&#125;message AddFriendRsp &#123; int32 error = 1; int32 applyuid = 2; int32 touid = 3;&#125;message RplyFriendReq &#123; int32 rplyuid = 1; bool agree = 2; int32 touid = 3;&#125;message RplyFriendRsp &#123; int32 error = 1; int32 rplyuid = 2; int32 touid = 3;&#125;message SendChatMsgReq&#123; int32 fromuid = 1; int32 touid = 2; string message = 3;&#125;message SendChatMsgRsp&#123; int32 error = 1; int32 fromuid = 2; int32 touid = 3;&#125;message AuthFriendReq&#123; int32 fromuid = 1; int32 touid = 2;&#125;message AuthFriendRsp&#123; int32 error = 1; int32 fromuid = 2; int32 touid = 3;&#125;message TextChatMsgReq &#123; int32 fromuid = 1; int32 touid = 2; repeated TextChatData textmsgs = 3;&#125;message TextChatData&#123; string msgid = 1; string msgcontent = 2;&#125;message TextChatMsgRsp &#123; int32 error = 1; int32 fromuid = 2; int32 touid = 3; repeated TextChatData textmsgs = 4;&#125;service ChatService &#123; rpc NotifyAddFriend(AddFriendReq) returns (AddFriendRsp) &#123;&#125; rpc RplyAddFriend(RplyFriendReq) returns (RplyFriendRsp) &#123;&#125; rpc SendChatMsg(SendChatMsgReq) returns (SendChatMsgRsp) &#123;&#125; rpc NotifyAuthFriend(AuthFriendReq) returns (AuthFriendRsp) &#123;&#125; rpc NotifyTextChatMsg(TextChatMsgReq) returns (TextChatMsgRsp)&#123;&#125;&#125; 为了方便生成grpcpb文件，我写了一个start.bat批处理文件 123456789101112@echo offset PROTOC_PATH=D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exeset GRPC_PLUGIN_PATH=D:\\cppsoft\\grpc\\visualpro\\Debug\\grpc_cpp_plugin.exeset PROTO_FILE=message.protoecho Generating gRPC code...%PROTOC_PATH% -I=&quot;.&quot; --grpc_out=&quot;.&quot; --plugin=protoc-gen-grpc=&quot;%GRPC_PLUGIN_PATH%&quot; &quot;%PROTO_FILE%&quot;echo Generating C++ code...%PROTOC_PATH% --cpp_out=. &quot;%PROTO_FILE%&quot;echo Done. 执行这个批处理文件就能生成最新的pb文件了。 接下来实现grpc服务对认证的处理 123456789101112131415161718192021222324252627282930313233343536373839404142Status ChatServiceImpl::NotifyAuthFriend(ServerContext* context, const AuthFriendReq* request, AuthFriendRsp* reply) &#123; //查找用户是否在本服务器 auto touid = request-&gt;touid(); auto fromuid = request-&gt;fromuid(); auto session = UserMgr::GetInstance()-&gt;GetSession(touid); Defer defer([request, reply]() &#123; reply-&gt;set_error(ErrorCodes::Success); reply-&gt;set_fromuid(request-&gt;fromuid()); reply-&gt;set_touid(request-&gt;touid()); &#125;); //用户不在内存中则直接返回 if (session == nullptr) &#123; return Status::OK; &#125; //在内存中则直接发送通知对方 Json::Value rtvalue; rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;fromuid&quot;] = request-&gt;fromuid(); rtvalue[&quot;touid&quot;] = request-&gt;touid(); std::string base_key = USER_BASE_INFO + std::to_string(fromuid); auto user_info = std::make_shared&lt;UserInfo&gt;(); bool b_info = GetBaseInfo(base_key, fromuid, user_info); if (b_info) &#123; rtvalue[&quot;name&quot;] = user_info-&gt;name; rtvalue[&quot;nick&quot;] = user_info-&gt;nick; rtvalue[&quot;icon&quot;] = user_info-&gt;icon; rtvalue[&quot;sex&quot;] = user_info-&gt;sex; &#125; else &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; &#125; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_NOTIFY_AUTH_FRIEND_REQ); return Status::OK;&#125; 所以A认证B为好友，A所在的服务器会给A回复一个ID_AUTH_FRIEND_RSP的消息，B所在的服务器会给B回复一个ID_NOTIFY_AUTH_FRIEND_REQ消息。 客户端响应客户端需要响应服务器发过来的ID_AUTH_FRIEND_RSP和ID_NOTIFY_AUTH_FRIEND_REQ消息 客户端响应ID_AUTH_FRIEND_RSP，在initHandlers中添加 123456789101112131415161718192021222324252627282930313233343536_handlers.insert(ID_AUTH_FRIEND_RSP, [this](ReqId id, int len, QByteArray data) &#123; Q_UNUSED(len); qDebug() &lt;&lt; &quot;handle id is &quot; &lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if (jsonDoc.isNull()) &#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if (!jsonObj.contains(&quot;error&quot;)) &#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Auth Friend Failed, err is Json Parse Err&quot; &lt;&lt; err; return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if (err != ErrorCodes::SUCCESS) &#123; qDebug() &lt;&lt; &quot;Auth Friend Failed, err is &quot; &lt;&lt; err; return; &#125; auto name = jsonObj[&quot;name&quot;].toString(); auto nick = jsonObj[&quot;nick&quot;].toString(); auto icon = jsonObj[&quot;icon&quot;].toString(); auto sex = jsonObj[&quot;sex&quot;].toInt(); auto uid = jsonObj[&quot;uid&quot;].toInt(); auto rsp = std::make_shared&lt;AuthRsp&gt;(uid, name, nick, icon, sex); emit sig_auth_rsp(rsp); qDebug() &lt;&lt; &quot;Auth Friend Success &quot; ; &#125;); 在initHandlers中添加ID_NOTIFY_AUTH_FRIEND_REQ 123456789101112131415161718192021222324252627282930313233343536_handlers.insert(ID_NOTIFY_AUTH_FRIEND_REQ, [this](ReqId id, int len, QByteArray data) &#123; Q_UNUSED(len); qDebug() &lt;&lt; &quot;handle id is &quot; &lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if (jsonDoc.isNull()) &#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if (!jsonObj.contains(&quot;error&quot;)) &#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Auth Friend Failed, err is &quot; &lt;&lt; err; return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if (err != ErrorCodes::SUCCESS) &#123; qDebug() &lt;&lt; &quot;Auth Friend Failed, err is &quot; &lt;&lt; err; return; &#125; int from_uid = jsonObj[&quot;fromuid&quot;].toInt(); QString name = jsonObj[&quot;name&quot;].toString(); QString nick = jsonObj[&quot;nick&quot;].toString(); QString icon = jsonObj[&quot;icon&quot;].toString(); int sex = jsonObj[&quot;sex&quot;].toInt(); auto auth_info = std::make_shared&lt;AuthInfo&gt;(from_uid,name, nick, icon, sex); emit sig_add_auth_friend(auth_info); &#125;); 客户端ChatDialog中添加对sig_add_auth_friend响应，实现添加好友到聊天列表中 123456789101112131415161718192021222324252627void ChatDialog::slot_add_auth_friend(std::shared_ptr&lt;AuthInfo&gt; auth_info) &#123; qDebug() &lt;&lt; &quot;receive slot_add_auth__friend uid is &quot; &lt;&lt; auth_info-&gt;_uid &lt;&lt; &quot; name is &quot; &lt;&lt; auth_info-&gt;_name &lt;&lt; &quot; nick is &quot; &lt;&lt; auth_info-&gt;_nick; //判断如果已经是好友则跳过 auto bfriend = UserMgr::GetInstance()-&gt;CheckFriendById(auth_info-&gt;_uid); if(bfriend)&#123; return; &#125; UserMgr::GetInstance()-&gt;AddFriend(auth_info); int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int str_i = randomValue % strs.size(); int head_i = randomValue % heads.size(); int name_i = randomValue % names.size(); auto* chat_user_wid = new ChatUserWid(); auto user_info = std::make_shared&lt;UserInfo&gt;(auth_info); chat_user_wid-&gt;SetInfo(user_info); QListWidgetItem* item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(chat_user_wid-&gt;sizeHint()); ui-&gt;chat_user_list-&gt;insertItem(0, item); ui-&gt;chat_user_list-&gt;setItemWidget(item, chat_user_wid); _chat_items_added.insert(auth_info-&gt;_uid, item);&#125; 客户端ChatDialog中添加对sig_auth_rsp响应, 实现添加好友到聊天列表中 123456789101112131415161718192021222324252627void ChatDialog::slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)&#123; qDebug() &lt;&lt; &quot;receive slot_auth_rsp uid is &quot; &lt;&lt; auth_rsp-&gt;_uid &lt;&lt; &quot; name is &quot; &lt;&lt; auth_rsp-&gt;_name &lt;&lt; &quot; nick is &quot; &lt;&lt; auth_rsp-&gt;_nick; //判断如果已经是好友则跳过 auto bfriend = UserMgr::GetInstance()-&gt;CheckFriendById(auth_rsp-&gt;_uid); if(bfriend)&#123; return; &#125; UserMgr::GetInstance()-&gt;AddFriend(auth_rsp); int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int str_i = randomValue % strs.size(); int head_i = randomValue % heads.size(); int name_i = randomValue % names.size(); auto* chat_user_wid = new ChatUserWid(); auto user_info = std::make_shared&lt;UserInfo&gt;(auth_rsp); chat_user_wid-&gt;SetInfo(user_info); QListWidgetItem* item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(chat_user_wid-&gt;sizeHint()); ui-&gt;chat_user_list-&gt;insertItem(0, item); ui-&gt;chat_user_list-&gt;setItemWidget(item, chat_user_wid); _chat_items_added.insert(auth_rsp-&gt;_uid, item);&#125; 因为认证对方为好友后，需要将申请页面的添加按钮变成已添加，所以ApplyFriendPage响应sig_auth_rsp信号 123456789void ApplyFriendPage::slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt; auth_rsp) &#123; auto uid = auth_rsp-&gt;_uid; auto find_iter = _unauth_items.find(uid); if (find_iter == _unauth_items.end()) &#123; return; &#125; find_iter-&gt;second-&gt;ShowAddBtn(false);&#125; 同意并认证对方为好友后，也需要将对方添加到联系人列表，ContactUserList响应sig_auth_rsp信号 1234567891011121314151617181920212223242526void ContactUserList::slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)&#123; qDebug() &lt;&lt; &quot;slot auth rsp called&quot;; bool isFriend = UserMgr::GetInstance()-&gt;CheckFriendById(auth_rsp-&gt;_uid); if(isFriend)&#123; return; &#125; // 在 groupitem 之后插入新项 int randomValue = QRandomGenerator::global()-&gt;bounded(100); // 生成0到99之间的随机整数 int str_i = randomValue%strs.size(); int head_i = randomValue%heads.size(); auto *con_user_wid = new ConUserItem(); con_user_wid-&gt;SetInfo(auth_rsp-&gt;_uid ,auth_rsp-&gt;_name, heads[head_i]); QListWidgetItem *item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(con_user_wid-&gt;sizeHint()); // 获取 groupitem 的索引 int index = this-&gt;row(_groupitem); // 在 groupitem 之后插入新项 this-&gt;insertItem(index + 1, item); this-&gt;setItemWidget(item, con_user_wid);&#125; 登录加载好友因为添加好友后，如果客户端重新登录，服务器LoginHandler需要加载好友列表，所以服务器要返回好友列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101void LogicSystem::LoginHandler(shared_ptr&lt;CSession&gt; session, const short &amp;msg_id, const string &amp;msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid = root[&quot;uid&quot;].asInt(); auto token = root[&quot;token&quot;].asString(); std::cout &lt;&lt; &quot;user login uid is &quot; &lt;&lt; uid &lt;&lt; &quot; user token is &quot; &lt;&lt; token &lt;&lt; endl; Json::Value rtvalue; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, MSG_CHAT_LOGIN_RSP); &#125;); //从redis获取用户token是否正确 std::string uid_str = std::to_string(uid); std::string token_key = USERTOKENPREFIX + uid_str; std::string token_value = &quot;&quot;; bool success = RedisMgr::GetInstance()-&gt;Get(token_key, token_value); if (!success) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; return ; &#125; if (token_value != token) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::TokenInvalid; return ; &#125; rtvalue[&quot;error&quot;] = ErrorCodes::Success; std::string base_key = USER_BASE_INFO + uid_str; auto user_info = std::make_shared&lt;UserInfo&gt;(); bool b_base = GetBaseInfo(base_key, uid, user_info); if (!b_base) &#123; rtvalue[&quot;error&quot;] = ErrorCodes::UidInvalid; return; &#125; rtvalue[&quot;uid&quot;] = uid; rtvalue[&quot;pwd&quot;] = user_info-&gt;pwd; rtvalue[&quot;name&quot;] = user_info-&gt;name; rtvalue[&quot;email&quot;] = user_info-&gt;email; rtvalue[&quot;nick&quot;] = user_info-&gt;nick; rtvalue[&quot;desc&quot;] = user_info-&gt;desc; rtvalue[&quot;sex&quot;] = user_info-&gt;sex; rtvalue[&quot;icon&quot;] = user_info-&gt;icon; //从数据库获取申请列表 std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt; apply_list; auto b_apply = GetFriendApplyInfo(uid,apply_list); if (b_apply) &#123; for (auto &amp; apply : apply_list) &#123; Json::Value obj; obj[&quot;name&quot;] = apply-&gt;_name; obj[&quot;uid&quot;] = apply-&gt;_uid; obj[&quot;icon&quot;] = apply-&gt;_icon; obj[&quot;nick&quot;] = apply-&gt;_nick; obj[&quot;sex&quot;] = apply-&gt;_sex; obj[&quot;desc&quot;] = apply-&gt;_desc; obj[&quot;status&quot;] = apply-&gt;_status; rtvalue[&quot;apply_list&quot;].append(obj); &#125; &#125; //获取好友列表 std::vector&lt;std::shared_ptr&lt;UserInfo&gt;&gt; friend_list; bool b_friend_list = GetFriendList(uid, friend_list); for (auto&amp; friend_ele : friend_list) &#123; Json::Value obj; obj[&quot;name&quot;] = friend_ele-&gt;name; obj[&quot;uid&quot;] = friend_ele-&gt;uid; obj[&quot;icon&quot;] = friend_ele-&gt;icon; obj[&quot;nick&quot;] = friend_ele-&gt;nick; obj[&quot;sex&quot;] = friend_ele-&gt;sex; obj[&quot;desc&quot;] = friend_ele-&gt;desc; obj[&quot;back&quot;] = friend_ele-&gt;back; rtvalue[&quot;friend_list&quot;].append(obj); &#125; auto server_name = ConfigMgr::Inst().GetValue(&quot;SelfServer&quot;, &quot;Name&quot;); //将登录数量增加 auto rd_res = RedisMgr::GetInstance()-&gt;HGet(LOGIN_COUNT, server_name); int count = 0; if (!rd_res.empty()) &#123; count = std::stoi(rd_res); &#125; count++; auto count_str = std::to_string(count); RedisMgr::GetInstance()-&gt;HSet(LOGIN_COUNT, server_name, count_str); //session绑定用户uid session-&gt;SetUserId(uid); //为用户设置登录ip server的名字 std::string ipkey = USERIPPREFIX + uid_str; RedisMgr::GetInstance()-&gt;Set(ipkey, server_name); //uid和session绑定管理,方便以后踢人操作 UserMgr::GetInstance()-&gt;SetUserSession(uid, session); return;&#125; 客户端在initHandlers中加载聊天列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849_handlers.insert(ID_CHAT_LOGIN_RSP, [this](ReqId id, int len, QByteArray data)&#123; Q_UNUSED(len); qDebug()&lt;&lt; &quot;handle id is &quot;&lt;&lt; id ; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if(jsonDoc.isNull())&#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); qDebug()&lt;&lt; &quot;data jsonobj is &quot; &lt;&lt; jsonObj ; if(!jsonObj.contains(&quot;error&quot;))&#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Login Failed, err is Json Parse Err&quot; &lt;&lt; err ; emit sig_login_failed(err); return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if(err != ErrorCodes::SUCCESS)&#123; qDebug() &lt;&lt; &quot;Login Failed, err is &quot; &lt;&lt; err ; emit sig_login_failed(err); return; &#125; auto uid = jsonObj[&quot;uid&quot;].toInt(); auto name = jsonObj[&quot;name&quot;].toString(); auto nick = jsonObj[&quot;nick&quot;].toString(); auto icon = jsonObj[&quot;icon&quot;].toString(); auto sex = jsonObj[&quot;sex&quot;].toInt(); auto user_info = std::make_shared&lt;UserInfo&gt;(uid, name, nick, icon, sex); UserMgr::GetInstance()-&gt;SetUserInfo(user_info); UserMgr::GetInstance()-&gt;SetToken(jsonObj[&quot;token&quot;].toString()); if(jsonObj.contains(&quot;apply_list&quot;))&#123; UserMgr::GetInstance()-&gt;AppendApplyList(jsonObj[&quot;apply_list&quot;].toArray()); &#125; //添加好友列表 if (jsonObj.contains(&quot;friend_list&quot;)) &#123; UserMgr::GetInstance()-&gt;AppendFriendList(jsonObj[&quot;friend_list&quot;].toArray()); &#125; emit sig_swich_chatdlg();&#125;); 好友聊天客户端发送聊天消息客户端发送聊天消息，在输入框输入消息后，点击发送回执行下面的槽函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void ChatPage::on_send_btn_clicked()&#123; if (_user_info == nullptr) &#123; qDebug() &lt;&lt; &quot;friend_info is empty&quot;; return; &#125; auto user_info = UserMgr::GetInstance()-&gt;GetUserInfo(); auto pTextEdit = ui-&gt;chatEdit; ChatRole role = ChatRole::Self; QString userName = user_info-&gt;_name; QString userIcon = user_info-&gt;_icon; const QVector&lt;MsgInfo&gt;&amp; msgList = pTextEdit-&gt;getMsgList(); QJsonObject textObj; QJsonArray textArray; int txt_size = 0; for(int i=0; i&lt;msgList.size(); ++i) &#123; //消息内容长度不合规就跳过 if(msgList[i].content.length() &gt; 1024)&#123; continue; &#125; QString type = msgList[i].msgFlag; ChatItemBase *pChatItem = new ChatItemBase(role); pChatItem-&gt;setUserName(userName); pChatItem-&gt;setUserIcon(QPixmap(userIcon)); QWidget *pBubble = nullptr; if(type == &quot;text&quot;) &#123; //生成唯一id QUuid uuid = QUuid::createUuid(); //转为字符串 QString uuidString = uuid.toString(); pBubble = new TextBubble(role, msgList[i].content); if(txt_size + msgList[i].content.length()&gt; 1024)&#123; textObj[&quot;fromuid&quot;] = user_info-&gt;_uid; textObj[&quot;touid&quot;] = _user_info-&gt;_uid; textObj[&quot;text_array&quot;] = textArray; QJsonDocument doc(textObj); QByteArray jsonData = doc.toJson(QJsonDocument::Compact); //发送并清空之前累计的文本列表 txt_size = 0; textArray = QJsonArray(); textObj = QJsonObject(); //发送tcp请求给chat server emit TcpMgr::GetInstance()-&gt;sig_send_data(ReqId::ID_TEXT_CHAT_MSG_REQ, jsonData); &#125; //将bubble和uid绑定，以后可以等网络返回消息后设置是否送达 //_bubble_map[uuidString] = pBubble; txt_size += msgList[i].content.length(); QJsonObject obj; QByteArray utf8Message = msgList[i].content.toUtf8(); obj[&quot;content&quot;] = QString::fromUtf8(utf8Message); obj[&quot;msgid&quot;] = uuidString; textArray.append(obj); auto txt_msg = std::make_shared&lt;TextChatData&gt;(uuidString, obj[&quot;content&quot;].toString(), user_info-&gt;_uid, _user_info-&gt;_uid); emit sig_append_send_chat_msg(txt_msg); &#125; else if(type == &quot;image&quot;) &#123; pBubble = new PictureBubble(QPixmap(msgList[i].content) , role); &#125; else if(type == &quot;file&quot;) &#123; &#125; //发送消息 if(pBubble != nullptr) &#123; pChatItem-&gt;setWidget(pBubble); ui-&gt;chat_data_list-&gt;appendChatItem(pChatItem); &#125; &#125; qDebug() &lt;&lt; &quot;textArray is &quot; &lt;&lt; textArray ; //发送给服务器 textObj[&quot;text_array&quot;] = textArray; textObj[&quot;fromuid&quot;] = user_info-&gt;_uid; textObj[&quot;touid&quot;] = _user_info-&gt;_uid; QJsonDocument doc(textObj); QByteArray jsonData = doc.toJson(QJsonDocument::Compact); //发送并清空之前累计的文本列表 txt_size = 0; textArray = QJsonArray(); textObj = QJsonObject(); //发送tcp请求给chat server emit TcpMgr::GetInstance()-&gt;sig_send_data(ReqId::ID_TEXT_CHAT_MSG_REQ, jsonData);&#125; TcpMgr响应发送信号 123456789101112131415161718192021222324void TcpMgr::slot_send_data(ReqId reqId, QByteArray dataBytes)&#123; uint16_t id = reqId; // 计算长度（使用网络字节序转换） quint16 len = static_cast&lt;quint16&gt;(dataBytes.length()); // 创建一个QByteArray用于存储要发送的所有数据 QByteArray block; QDataStream out(&amp;block, QIODevice::WriteOnly); // 设置数据流使用网络字节序 out.setByteOrder(QDataStream::BigEndian); // 写入ID和长度 out &lt;&lt; id &lt;&lt; len; // 添加字符串数据 block.append(dataBytes); // 发送数据 _socket.write(block); qDebug() &lt;&lt; &quot;tcp mgr send byte data is &quot; &lt;&lt; block ;&#125; 服务器响应服务器响应客户端发送过来文本消息，在initHandlers中添加处理文本消息的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void LogicSystem::DealChatTextMsg(std::shared_ptr&lt;CSession&gt; session, const short&amp; msg_id, const string&amp; msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); auto uid = root[&quot;fromuid&quot;].asInt(); auto touid = root[&quot;touid&quot;].asInt(); const Json::Value arrays = root[&quot;text_array&quot;]; Json::Value rtvalue; rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;text_array&quot;] = arrays; rtvalue[&quot;fromuid&quot;] = uid; rtvalue[&quot;touid&quot;] = touid; Defer defer([this, &amp;rtvalue, session]() &#123; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_TEXT_CHAT_MSG_RSP); &#125;); //查询redis 查找touid对应的server ip auto to_str = std::to_string(touid); auto to_ip_key = USERIPPREFIX + to_str; std::string to_ip_value = &quot;&quot;; bool b_ip = RedisMgr::GetInstance()-&gt;Get(to_ip_key, to_ip_value); if (!b_ip) &#123; return; &#125; auto&amp; cfg = ConfigMgr::Inst(); auto self_name = cfg[&quot;SelfServer&quot;][&quot;Name&quot;]; //直接通知对方有认证通过消息 if (to_ip_value == self_name) &#123; auto session = UserMgr::GetInstance()-&gt;GetSession(touid); if (session) &#123; //在内存中则直接发送通知对方 std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_NOTIFY_TEXT_CHAT_MSG_REQ); &#125; return ; &#125; TextChatMsgReq text_msg_req; text_msg_req.set_fromuid(uid); text_msg_req.set_touid(touid); for (const auto&amp; txt_obj : arrays) &#123; auto content = txt_obj[&quot;content&quot;].asString(); auto msgid = txt_obj[&quot;msgid&quot;].asString(); std::cout &lt;&lt; &quot;content is &quot; &lt;&lt; content &lt;&lt; std::endl; std::cout &lt;&lt; &quot;msgid is &quot; &lt;&lt; msgid &lt;&lt; std::endl; auto *text_msg = text_msg_req.add_textmsgs(); text_msg-&gt;set_msgid(msgid); text_msg-&gt;set_msgcontent(content); &#125; //发送通知 todo... ChatGrpcClient::GetInstance()-&gt;NotifyTextChatMsg(to_ip_value, text_msg_req, rtvalue);&#125; 服务器实现发送消息的rpc客户端 12345678910111213141516171819202122232425262728293031323334353637TextChatMsgRsp ChatGrpcClient::NotifyTextChatMsg(std::string server_ip, const TextChatMsgReq&amp; req, const Json::Value&amp; rtvalue) &#123; TextChatMsgRsp rsp; rsp.set_error(ErrorCodes::Success); Defer defer([&amp;rsp, &amp;req]() &#123; rsp.set_fromuid(req.fromuid()); rsp.set_touid(req.touid()); for (const auto&amp; text_data : req.textmsgs()) &#123; TextChatData* new_msg = rsp.add_textmsgs(); new_msg-&gt;set_msgid(text_data.msgid()); new_msg-&gt;set_msgcontent(text_data.msgcontent()); &#125; &#125;); auto find_iter = _pools.find(server_ip); if (find_iter == _pools.end()) &#123; return rsp; &#125; auto&amp; pool = find_iter-&gt;second; ClientContext context; auto stub = pool-&gt;getConnection(); Status status = stub-&gt;NotifyTextChatMsg(&amp;context, req, &amp;rsp); Defer defercon([&amp;stub, this, &amp;pool]() &#123; pool-&gt;returnConnection(std::move(stub)); &#125;); if (!status.ok()) &#123; rsp.set_error(ErrorCodes::RPCFailed); return rsp; &#125; return rsp;&#125; 服务器实现rpc服务端处理消息通知 123456789101112131415161718192021222324252627282930313233Status ChatServiceImpl::NotifyTextChatMsg(::grpc::ServerContext* context, const TextChatMsgReq* request, TextChatMsgRsp* reply) &#123; //查找用户是否在本服务器 auto touid = request-&gt;touid(); auto session = UserMgr::GetInstance()-&gt;GetSession(touid); reply-&gt;set_error(ErrorCodes::Success); //用户不在内存中则直接返回 if (session == nullptr) &#123; return Status::OK; &#125; //在内存中则直接发送通知对方 Json::Value rtvalue; rtvalue[&quot;error&quot;] = ErrorCodes::Success; rtvalue[&quot;fromuid&quot;] = request-&gt;fromuid(); rtvalue[&quot;touid&quot;] = request-&gt;touid(); //将聊天数据组织为数组 Json::Value text_array; for (auto&amp; msg : request-&gt;textmsgs()) &#123; Json::Value element; element[&quot;content&quot;] = msg.msgcontent(); element[&quot;msgid&quot;] = msg.msgid(); text_array.append(element); &#125; rtvalue[&quot;text_array&quot;] = text_array; std::string return_str = rtvalue.toStyledString(); session-&gt;Send(return_str, ID_NOTIFY_TEXT_CHAT_MSG_REQ); return Status::OK;&#125; 客户端响应通知客户端响应服务器返回的消息，包括两种： A给B发送文本消息，A所在的服务器会给A发送ID_TEXT_CHAT_MSG_RSP消息。 B所在的服务器会通知B，告诉B有来自A的消息，通知消息为ID_NOTIFY_TEXT_CHAT_MSG_REQ 所以在tcpmgr的initHandlers中添加响应ID_TEXT_CHAT_MSG_RSP消息 1234567891011121314151617181920212223242526272829_handlers.insert(ID_TEXT_CHAT_MSG_RSP, [this](ReqId id, int len, QByteArray data) &#123; Q_UNUSED(len); qDebug() &lt;&lt; &quot;handle id is &quot; &lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if (jsonDoc.isNull()) &#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if (!jsonObj.contains(&quot;error&quot;)) &#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Chat Msg Rsp Failed, err is Json Parse Err&quot; &lt;&lt; err; return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if (err != ErrorCodes::SUCCESS) &#123; qDebug() &lt;&lt; &quot;Chat Msg Rsp Failed, err is &quot; &lt;&lt; err; return; &#125; qDebug() &lt;&lt; &quot;Receive Text Chat Rsp Success &quot; ; //ui设置送达等标记 todo... &#125;); 在TcpMgr的initHandlers中添加ID_NOTIFY_TEXT_CHAT_MSG_REQ 12345678910111213141516171819202122232425262728293031_handlers.insert(ID_NOTIFY_TEXT_CHAT_MSG_REQ, [this](ReqId id, int len, QByteArray data) &#123; Q_UNUSED(len); qDebug() &lt;&lt; &quot;handle id is &quot; &lt;&lt; id &lt;&lt; &quot; data is &quot; &lt;&lt; data; // 将QByteArray转换为QJsonDocument QJsonDocument jsonDoc = QJsonDocument::fromJson(data); // 检查转换是否成功 if (jsonDoc.isNull()) &#123; qDebug() &lt;&lt; &quot;Failed to create QJsonDocument.&quot;; return; &#125; QJsonObject jsonObj = jsonDoc.object(); if (!jsonObj.contains(&quot;error&quot;)) &#123; int err = ErrorCodes::ERR_JSON; qDebug() &lt;&lt; &quot;Notify Chat Msg Failed, err is Json Parse Err&quot; &lt;&lt; err; return; &#125; int err = jsonObj[&quot;error&quot;].toInt(); if (err != ErrorCodes::SUCCESS) &#123; qDebug() &lt;&lt; &quot;Notify Chat Msg Failed, err is &quot; &lt;&lt; err; return; &#125; qDebug() &lt;&lt; &quot;Receive Text Chat Notify Success &quot; ; auto msg_ptr = std::make_shared&lt;TextChatMsg&gt;(jsonObj[&quot;fromuid&quot;].toInt(), jsonObj[&quot;touid&quot;].toInt(),jsonObj[&quot;text_array&quot;].toArray()); emit sig_text_chat_msg(msg_ptr); &#125;); 客户端ChatDialog添加对sig_text_chat_msg的响应 123456789101112131415161718192021222324252627282930313233void ChatDialog::slot_text_chat_msg(std::shared_ptr&lt;TextChatMsg&gt; msg)&#123; auto find_iter = _chat_items_added.find(msg-&gt;_from_uid); if(find_iter != _chat_items_added.end())&#123; qDebug() &lt;&lt; &quot;set chat item msg, uid is &quot; &lt;&lt; msg-&gt;_from_uid; QWidget *widget = ui-&gt;chat_user_list-&gt;itemWidget(find_iter.value()); auto chat_wid = qobject_cast&lt;ChatUserWid*&gt;(widget); if(!chat_wid)&#123; return; &#125; chat_wid-&gt;updateLastMsg(msg-&gt;_chat_msgs); //更新当前聊天页面记录 UpdateChatMsg(msg-&gt;_chat_msgs); UserMgr::GetInstance()-&gt;AppendFriendChatMsg(msg-&gt;_from_uid,msg-&gt;_chat_msgs); return; &#125; //如果没找到，则创建新的插入listwidget auto* chat_user_wid = new ChatUserWid(); //查询好友信息 auto fi_ptr = UserMgr::GetInstance()-&gt;GetFriendById(msg-&gt;_from_uid); chat_user_wid-&gt;SetInfo(fi_ptr); QListWidgetItem* item = new QListWidgetItem; //qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint(); item-&gt;setSizeHint(chat_user_wid-&gt;sizeHint()); chat_user_wid-&gt;updateLastMsg(msg-&gt;_chat_msgs); UserMgr::GetInstance()-&gt;AppendFriendChatMsg(msg-&gt;_from_uid,msg-&gt;_chat_msgs); ui-&gt;chat_user_list-&gt;insertItem(0, item); ui-&gt;chat_user_list-&gt;setItemWidget(item, chat_user_wid); _chat_items_added.insert(msg-&gt;_from_uid, item);&#125; 效果展示 源码连接https://gitee.com/secondtonone1/llfcchat 视频连接https://www.bilibili.com/video/BV1ib421J745/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9","categories":[{"name":"C++聊天项目","slug":"cpppro","permalink":"http://www.limerence2017.com/categories/cpppro/"}],"tags":[{"name":"C++聊天项目","slug":"C-聊天项目","permalink":"http://www.limerence2017.com/tags/C-%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"}]},{"title":"并发编程排错思路和方法","date":"2024-02-24T06:15:17.000Z","path":"2024/02/24/concpp29/","text":"简介到目前为止，前面一系列的文章已经将多线程编程技术介绍完了，很多人问我如何排查多线程程序的问题，本节是最后一节，给大家提供一些在多线程编程过程中排查问题的思路。因为本节代码演示和实际操作内容较多，该文档仅做基本的说明，详细操作可看视频， 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 常见问题在介绍如何排查前我们先将问题做几个归类： 内存问题，包括内存泄露(未回收内存)，空指针，悬垂指针(野指针)，double free问题等。 资源竞争，多个线程竞争同一块临界区的资源，未保证互斥 死锁(互相引用阻塞卡死)和活锁(乐观锁尝试) 引用已释放的变量，生命周期管理失效导致 浅拷贝造成内存异常 线程管控失败，修改或者回收一个已经绑定正在运行线程的变量，或者线程本该回收却被卡死，皆因线程管控失败导致 智能指针和裸指针混用导致二次析构，也属于double free。 接下来根据上面列出的问题，我们根据实际案例排查出现问题的原因以及规避的方法。 接下来的案例均取自我的源码，源码链接如下： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot 空指针空指针的问题比较好排查，我们在封装无锁队列的时候照抄《C++并发编程实战》一书引发了崩溃，详见源码链接中crushque.h以及lockfreequetest.cpp。 测试用例如下： 1234567891011121314151617181920212223242526void TestCrushQue() &#123; crush_que&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT * 10000; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT * 10000;) &#123; auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); t1.join(); t2.join();&#125; 最后显示的崩溃点在 很明显这是引发崩溃的底层代码，并不是上层代码，通过调用堆栈找到和崩溃最相近的逻辑 我们点击第二行的栈调用跳转到队列的push操作。 在代码166行处是崩溃的上层调用，我们通过分析old_tail.ptr此时为空指针，该问题的根因在于构造无锁队列时未进行头节点和尾部节点的初始化所致。 无论linux还是windows，排查崩溃问题最首要的解决方式为观察栈调用，gdb或者windows的栈信息直观的反应了崩溃的触发顺序。 内存泄漏一般来说内存泄漏检测有专门的工具库，linux环境下可使用valgrind，windows的visual studio环境下Visual Leak Detector， 这些工具只能被动的检测内存泄漏，很多情况我们需要针对已经开发的类或者逻辑编写测试用例，检测内存泄漏。 比如我们对于无锁队列中提供了一个内存泄漏的版本，详见memoryleakque.h以及测试用例lockfreequetest.cpp，以下为测试代码 12345678910111213141516171819202122232425262728void TestLeakQue() &#123; memoryleak_que&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT;) &#123; auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); t1.join(); t2.join(); assert(que.destruct_count == TESTCOUNT);&#125; 针对这个队列, 我们统计释放节点的个数和开辟节点的个数是否相等，通过assert(que.destruct_count == TESTCOUNT);断言检测，实际测试过程中发现存在内存泄漏。 针对无锁队列的内存泄漏无外乎就是push和pop操作造成的，我们把测试用例改为单线程，先将多线程这个可变因素去掉 123456789101112131415161718192021void TestLeakQueSingleThread() &#123; memoryleak_que&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); t1.join(); assert(que.destruct_count == TESTCOUNT);&#125; 上面的代码测试未发现内存泄漏，但这还不能将问题归因于多线程，我们构造一种情况触发空队列的pop 12345678910111213141516171819202122232425262728void TestLeakQueMultiPop() &#123; memoryleak_que&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; auto p2 = que.pop(); if (p2 == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p2 &lt;&lt; std::endl; &#125; &#125;); t1.join(); assert(que.destruct_count == TESTCOUNT);&#125; 上面的代码再一次触发断言，说明存在内存泄漏，那我们可以将问题归因于pop操作，而且是队列为空的pop操作。 接下来配合断点调试，windows断点调试较为方便，或者linux环境gdb调试麻烦，可以在关键点打印信息排查问题。 我们使用visual studio断点排查这个问题，先让队列push一个数据，再pop两次，第二次pop肯定无效因为是空队列，但也是引发泄漏的关键原因。 接下来再push一个数据，再pop节点，我们需观察这次pop是否会触发节点回收的逻辑。 回收节点的逻辑只有两处，在release_ref和free_external_counter内部判断internal_count和external_counters为0时才会调用delete回收内存，所以我们只需要在release_ref和free_external_counter中打断点，观察这两个引用计数是否为0，如果不为0说明引用计数的计算出了问题。 为了便于观察数据，我们采取单步调试的方式，经过断点调试，发现第二次循环pop时，free_external_count内部old_node_ptr.external_count为3，而第一次循环pop时old_node_ptr.external_count为2. 那么第二次计算internal_count就不会为0，导致节点不会回收。 问题的根因也找到了在pop判断队列为空的时候直接返回了，之前进行了increase_external_count将外部引用计数增加了，在判断队列为空未进行修改就返回了，我们知道外部引用计数只是一个副本，可能同时有多个线程修改外部引用计数，所以只需要让内部引用计数释放一次即可 12345if (ptr == tail.load().ptr)&#123; ptr-&gt;release_ref(); return std::unique_ptr&lt;T&gt;();&#125; 再次测试未发现内存泄漏。 自己设计测试用例时要注意覆盖多种情况，比如无锁队列，我后来又测试了单线程，多线程一进一出，多线程一进多出，多线程一出多进，多线程多出多进等，以及加大线程数测试。详细案例可以看看源码， lockfreequetest.cpp。 double free对于悬垂指针也叫做野指针，指的是释放内存后，再次使用这个指针访问数据造成崩溃。double free也属于指针管理失效导致，我们看看网络编程中对官方案例存在隐患的剖析。案例在网络编程network文件夹，day05-AsyncServer中，我们实现了一个异步的echo应答server。正常情况下应答server没有任何问题，但是对于全双工情况(实际情况都是收发解耦合)，比如我们在收到消息后监听读事件，并发送，而不是在发送消息后监听读事件。我们将handle_read处理改为如下 123456789101112131415void Session::handle_read(const boost::system::error_code&amp; error, size_t bytes_transfered) &#123; if (!error) &#123; cout &lt;&lt; &quot;server receive data is &quot; &lt;&lt; _data &lt;&lt; endl; std::string send_data(_data); //在发送 _socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&amp;Session::handle_read, this, placeholders::_1, placeholders::_2)); boost::asio::async_write(_socket, boost::asio::buffer(send_data, bytes_transfered), std::bind(&amp;Session::handle_write, this, placeholders::_1)); &#125; else &#123; delete this; &#125;&#125; 我们启动day04-SyncClient和day05-AsyncServer分别测试，在Server handle_read里async_read_some处打断点，然后启动客户端，客户端发送数据后服务器触发async_read_some断点，此时关闭客户端，然后服务器继续执行后面的逻辑会引发崩溃。 遇到崩溃第一反应是看看崩溃的栈信息，崩溃在最底层代码 栈信息也看不懂 看栈调用应该是崩溃在asio底层iocp模型写回调里了。 那我们可以用注释的方式排查问题。我们把handle_write回调里面的逻辑注释掉 12345678910void Session::handle_write(const boost::system::error_code&amp; error) &#123; // if (!error) &#123; // memset(_data, 0, max_length); // _socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&amp;Session::handle_read, // this, placeholders::_1, placeholders::_2)); // &#125; // else &#123; // delete this; // &#125;&#125; 再次启动客户端和服务器，在服务器收到读回调后断点并关闭客户端，服务器放开断点继续执行，未发现崩溃。 观察注释掉的逻辑，最有嫌疑的是delete this, 我们仅仅将delete this注释掉后就不会崩溃了，那我们找到问题根因了 第一次回调触发handle_read没问题，此时在回调里关闭客户端，因为第一次回调再次调用async_read_some将读事件注册给asio底层的事件循环，调用async_write将写事件注册给asio底层循环，当客户端关闭后会第二次触发读回调，这次读回调会执行delete操作，delete this之后，Session所有的数据都被回收，而写回调也会触发，因为那么就行了二次delete操作，这就是double free问题。 解决这个问题我们提出了利用智能指针构造一个伪闭包的方式延长Session周期，保证回调之前不会delete Session。具体可以看看这篇文章https://llfc.club/articlepage?id=2OEQEc6p4k79cXsTr6dOVfZbo79 视频链接 https://www.bilibili.com/video/BV15P411S7fp/?spm_id_from=333.788&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 本文仅作排查故障方法整理，其他不做赘述，相关处理方案可以看我博客其他文章和视频。 资源竞争资源竞争大部分情况是逻辑错误，比如两个线程A和B同时修改互斥区域，互斥区域未加锁，这期间也可能造成崩溃，比如线程A删除了数据C，而线程B正在访问数据C，引发崩溃后大家不要慌，先看崩溃的堆栈信息，如果是指针显示为0xdddd之类的说明是访问了被删除的数据，那么我们排查删除的逻辑，或者屏蔽删除的逻辑看看会不会出问题，基本思路是 崩溃看堆栈信息，排查是不是野指针或者double free问题。 如果不是崩溃信息，数据混乱就查找修改数据的逻辑，或者屏蔽这个逻辑，看看是不是多线程造成的。 崩溃问题也可以通过屏蔽部分逻辑排查是不是多线程导致的。 在必要的逻辑区间增加日志，排查逻辑异常的上层原因。 这部分问题要结合实际工作去排查，慢慢熟悉这种思路以后就不陌生了。 死锁问题多线程出现死锁问题是很头疼，现象不如内存崩溃或者资源竞争那么明显，表现给开发者的是一种卡死的现象。造成死锁的根本原因在于锁资源互相竞争，遇到这种问题要先梳理逻辑，找到互相引用的关键点。我们通过代码仓库中concurrent文件夹day24-TroubleShoot 中deadlock.h演示 12345678910111213141516void deadlockdemo() &#123; std::mutex mtx; int global_data = 0; std::thread t1([&amp;mtx, &amp;global_data]() &#123; std::lock_guard&lt;std::mutex&gt; outer_lock(mtx); global_data++; std::async([&amp;mtx, &amp;global_data]() &#123; std::lock_guard&lt;std::mutex&gt; inner_lock(mtx); global_data++; std::cout &lt;&lt; global_data &lt;&lt; std::endl; &#125;); &#125;); t1.join();&#125; 主函数调用这个函数，主进程无法退出。因为不是崩溃问题所以无法查看调用栈，对于这个问题，我们在关键位置打印日志，看看具体走到哪里出了问题。 123456789101112131415161718192021void deadlockdemo() &#123; std::mutex mtx; int global_data = 0; std::thread t1([&amp;mtx, &amp;global_data]() &#123; std::cout &lt;&lt; &quot;begin lock outer_lock...&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; outer_lock(mtx); std::cout &lt;&lt; &quot;after lock outer_lock...&quot; &lt;&lt; std::endl; global_data++; std::async([&amp;mtx, &amp;global_data]() &#123; std::cout &lt;&lt; &quot;begin lock inner_lock...&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; inner_lock(mtx); std::cout &lt;&lt; &quot;after lock inner_lock...&quot; &lt;&lt; std::endl; global_data++; std::cout &lt;&lt; global_data &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unlock inner_lock...&quot; &lt;&lt; std::endl; &#125;); std::cout &lt;&lt; &quot;unlock outer_lock...&quot; &lt;&lt; std::endl; &#125;); t1.join();&#125; 日志输出 123begin lock outer_lock...after lock outer_lock...begin lock inner_lock... 可以看到内部锁没有加成功。这种情况就是死锁了，再来分析原因，因为async会返回一个future，作为右值这个future会立即调用析构函数，析构函数内部会等待任务完成(并发编程已经从源码剖析了，这里不再赘述)。内部任务要加锁加不上，外部解不开锁因为async返回的future析构无法调用成功。这就是死锁的原因了。修正，只要让future不立即调用析构即可，我们可以用变量接受future,这样析构就会延缓到解锁之后，变量可以放在最外层，这样变量不会触发析构。 12345678910111213141516171819202122void lockdemo() &#123; std::mutex mtx; int global_data = 0; std::future&lt;void&gt; future_res; std::thread t1([&amp;mtx, &amp;global_data,&amp;future_res]() &#123; std::cout &lt;&lt; &quot;begin lock outer_lock...&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; outer_lock(mtx); std::cout &lt;&lt; &quot;after lock outer_lock...&quot; &lt;&lt; std::endl; global_data++; future_res = std::async([&amp;mtx, &amp;global_data]() &#123; std::cout &lt;&lt; &quot;begin lock inner_lock...&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; inner_lock(mtx); std::cout &lt;&lt; &quot;after lock inner_lock...&quot; &lt;&lt; std::endl; global_data++; std::cout &lt;&lt; global_data &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unlock inner_lock...&quot; &lt;&lt; std::endl; &#125;); std::cout &lt;&lt; &quot;unlock outer_lock...&quot; &lt;&lt; std::endl; &#125;); t1.join();&#125; 程序输出 1234567begin lock outer_lock...after lock outer_lock...unlock outer_lock...begin lock inner_lock...after lock inner_lock...2unlock inner_lock... 关于活锁，解决方式类似，在关键位置添加注释排查具体原因。 引用释放的变量随着C++ 11 lambda表达式推出后，编程更方便了，但是引用释放的变量这个问题也随之而来。案例在day24-TroubleShoot文件夹deadlock.cpp中reference_invalid函数。 123456789101112131415161718192021222324252627282930void reference_invalid()&#123; class task_data &#123; public: task_data(int i):_data(new int(i))&#123;&#125; ~task_data() &#123; delete _data; &#125; int* _data; &#125;; std::queue&lt;std::function&lt;void()&gt;&gt; task_que; for (int i = 0; i &lt; 10; i++) &#123; task_data data(i); task_que.push([&amp;data]() &#123; (*data._data)++; std::cout &lt;&lt; &quot;data is &quot; &lt;&lt; *data._data &lt;&lt; std::endl; &#125;); &#125; auto res_future = std::async([&amp;task_que]() &#123; for (;;) &#123; if (task_que.empty()) &#123; break; &#125; auto&amp; task = task_que.front(); task(); task_que.pop(); &#125; &#125;); res_future.wait();&#125; 上述函数调用后输出的数值为 12345678910data is -572662307data is 1349705340data is -2147481856data is -572662307data is -572662307data is -572662307data is -572662307data is -572662307data is -572662307data is -572662307 为什么数据变乱了呢？我们分析一下，这种多线程的逻辑问题就要通过加日志或者梳理逻辑排查了。异步任务里从任务队列弹出任务并执行，我们观察任务是一个lambda表达式，捕获的是task_data类型的引用，既然是引用就有生命周期，我们在将task放入队列时，task_data类型变量data为局部变量，此时还未失效，等离开循环的作用域调用data会调用析构函数，那么内部的数据就被释放了，所以之后线程异步访问时会出现乱码。 怎么改呢？我们在网络编程中介绍了一种思路，利用智能指针构造一个伪闭包逻辑，C++不像js，python，go等有闭包机制，但是我们可以通过智能指针增加引用计数，达到闭包效果。 123456789101112131415161718192021222324252627282930void reference_sharedptr() &#123; class task_data &#123; public: task_data(int i) :_data(new int(i)) &#123;&#125; ~task_data() &#123; delete _data; &#125; int* _data; &#125;; std::queue&lt;std::function&lt;void()&gt;&gt; task_que; for (int i = 0; i &lt; 10; i++) &#123; std::shared_ptr&lt;task_data&gt; taskptr = std::make_shared&lt;task_data&gt;(i); task_que.push([taskptr]() &#123; (*( taskptr-&gt;_data))++; std::cout &lt;&lt; &quot;data is &quot; &lt;&lt; *(taskptr-&gt;_data) &lt;&lt; std::endl; &#125;); &#125; auto res_future = std::async([&amp;task_que]() &#123; for (;;) &#123; if (task_que.empty()) &#123; break; &#125; auto&amp; task = task_que.front(); task(); task_que.pop(); &#125; &#125;); res_future.wait(); &#125; 再次运行输出正确。 浅拷贝浅拷贝这个词对于C++开发者并不陌生，如果没有合理的内存管理机制，浅拷贝会造成很严重的内存崩溃问题。看下面这个例子,同样在day24-TroubleShoot文件夹deadlock.cpp中 1234567891011121314void shallow_copy()&#123; class task_data &#123; public: task_data(int i) :_data(new int(i)) &#123;&#125; ~task_data() &#123; std::cout &lt;&lt; &quot;call task_data destruct&quot; &lt;&lt; std::endl; delete _data; &#125; int* _data; &#125;; task_data data1(1); task_data data2 = std::move(data1);&#125; 上面这个例子运行会导致崩溃，我们看data1移动给data2后，二者在作用域结束时都进行析构。 因为我们没实现移动构造和拷贝构造，系统默认的移动构造执行拷贝构造，默认的拷贝构造是浅拷贝，所以data1和data2内部的_data引用同一块内存，他们析构的时候会造成二次析构。 读者可能觉得这个例子太简单，不会犯错，那我们看第二个例子 123456789101112131415161718void shallow_copy2()&#123; class task_data &#123; public: task_data(int i) :_data(new int(i)) &#123;&#125; ~task_data() &#123; std::cout &lt;&lt; &quot;call task_data destruct&quot; &lt;&lt; std::endl; delete _data; &#125; int* _data; &#125;; auto task_call = []() -&gt; task_data &#123; task_data data(100); return data; &#125;; task_call();&#125; 第二个例子中我们定义了一个lambda表达式task_call，返回task_data类型的对象。 关于返回局部对象，编译器有两种情况： 如果编译器支持返回值优化（Return Value Optimization, RVO），那么在返回局部对象时，编译器可能会通过返回值优化来避免执行移动构造函数。RVO 是一种编译器优化技术，可以避免对返回值进行拷贝或移动操作，直接将局部对象的值放置到调用者提供的空间中，从而减少了不必要的资源开销和性能消耗。 在 C++11 引入移动语义后，编译器有权将返回的局部对象视为右值，从而执行移动构造而非拷贝构造。 无论上述哪一种，都是将值返回，那么都会执行浅拷贝，局部变量随着作用域结束被释放，内部的内存_data被回收，而外部接收的返回值仍在引用_data，此时_data就是野指针。外部对象释放会造成二次析构，或者外部对象使用_data时也会引发野指针崩溃问题。 解决的方式就是实现拷贝构造和移动构造。 1234567891011121314151617181920212223242526void normal_copy() &#123; class task_data &#123; public: task_data(int i) :_data(new int(i)) &#123;&#125; ~task_data() &#123; std::cout &lt;&lt; &quot;call task_data destruct&quot; &lt;&lt; std::endl; delete _data; &#125; task_data(const task_data&amp; src) &#123; _data = new int(*(src._data)); &#125; task_data(task_data&amp;&amp; src) &#123; _data = new int(*(src._data)); &#125; int* _data; &#125;; auto task_call = []() -&gt; task_data &#123; task_data data(100); return data; &#125;; task_call(); &#125; 再次运行，看到调用两个析构函数，并且未崩溃 123call task_data destructcall task_data destructmain exit 线程管控多线程编程常遇到的一个问题就是线程管控。案例在day24-TroubleShoot文件夹deadlock.cpp中。 我们实现了一个生产者和消费者的管理类和一个用来控制退出的原子变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 std::atomic&lt;bool&gt; b_stop = false;class ProductConsumerMgr &#123;public: ProductConsumerMgr()&#123; _consumer = std::thread([this]() &#123; while (!b_stop) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _consume_cv.wait(lock, [this]() &#123; if (_data_que.empty()) &#123; return false; &#125; return true; &#125;); int data = _data_que.front(); _data_que.pop(); std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; data &lt;&lt; std::endl; lock.unlock(); _producer_cv.notify_one(); &#125; &#125;); _producer = std::thread([this]() &#123; int data = 0; while (!b_stop) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _producer_cv.wait(lock, [this]() &#123; if (_data_que.size() &gt; 100) &#123; return false; &#125; return true; &#125;); _data_que.push(++data); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; data &lt;&lt; std::endl; lock.unlock(); _consume_cv.notify_one(); &#125; &#125;); &#125; ~ProductConsumerMgr()&#123; _producer.join(); _consumer.join(); &#125;private: std::mutex _mtx; std::condition_variable _consume_cv; std::condition_variable _producer_cv; std::queue&lt;int&gt; _data_que; std::thread _consumer; std::thread _producer;&#125;; 生产者不断生产数据放入队列，消费者不断从队列消费数据。 ProductConsumerMgr析构时等待生产者和消费者两个线程退出。 b_stop用来控制线程退出。 我们实现捕获ctl+c以及关闭窗口信号的函数，然后将b_stop设置为true. 12345678910111213141516171819202122232425262728293031323334BOOL CtrlHandler(DWORD fdwCtrlType)&#123; switch (fdwCtrlType) &#123; // Handle the CTRL-C signal. case CTRL_C_EVENT: printf(&quot;Ctrl-C event\\n\\n&quot;); b_stop = true; return(TRUE); // CTRL-CLOSE: confirm that the user wants to exit. case CTRL_CLOSE_EVENT: b_stop = true; printf(&quot;Ctrl-Close event\\n\\n&quot;); return(TRUE); case CTRL_SHUTDOWN_EVENT: b_stop = true; printf(&quot;Ctrl-Shutdown event\\n\\n&quot;); return FALSE; default: return FALSE; &#125;&#125;void TestProducerConsumer()&#123; SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE); ProductConsumerMgr mgr; while (!b_stop) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125;&#125; 在主函数中启动TestProducerConsumer，生产者和消费者会不断工作，我们按下ctrl+c会中断程序，程序可以安全退出。在一般情况下没有问题，是不是意味着我们的程序足够健壮呢？ 我们延缓生产者生产的效率，假设一个小时生产一个数据放入队列，此时Ctrl+c看看是否会中断程序 1234567891011121314151617_producer = std::thread([this]() &#123; int data = 0; while (!b_stop) &#123; std::this_thread::sleep_for(std::chrono::seconds(5)); std::unique_lock&lt;std::mutex&gt; lock(_mtx); _producer_cv.wait(lock, [this]() &#123; if (_data_que.size() &gt; 100) &#123; return false; &#125; return true; &#125;); _data_que.push(++data); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; data &lt;&lt; std::endl; lock.unlock(); _consume_cv.notify_one(); &#125;&#125;); 生产者改为上述每5s产生一个数据，此时ctrl+c并不会中断程序，程序不会退出。 问题的根本在于条件竞争，当我们的生产者生产效率低时，队列为空，测试消费者线程处于挂起状态，ctrl+c虽然将停止信号设置为true，但是ProductConsumerMgr析构并不能执行完成，析构函数会等待两个线程退出，消费者线程不会退出，因为处于挂起状态了。 怎么办呢？我们可以在析构里通知两个线程退出即可。而且两个线程要增加唤醒后判断停止标记的逻辑。 123456~ProductConsumerMgr()&#123; _consume_cv.notify_one(); _producer_cv.notify_one(); _producer.join(); _consumer.join();&#125; 两个线程增加条件判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ProductConsumerMgr()&#123; _consumer = std::thread([this]() &#123; while (!b_stop) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _consume_cv.wait(lock, [this]() &#123; if (b_stop) &#123; return true; &#125; if (_data_que.empty()) &#123; return false; &#125; return true; &#125;); if (b_stop) &#123; return ; &#125; int data = _data_que.front(); _data_que.pop(); std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; data &lt;&lt; std::endl; lock.unlock(); _producer_cv.notify_one(); &#125; &#125;); _producer = std::thread([this]() &#123; int data = 0; while (!b_stop) &#123; std::this_thread::sleep_for(std::chrono::seconds(5)); std::unique_lock&lt;std::mutex&gt; lock(_mtx); _producer_cv.wait(lock, [this]() &#123; if (b_stop) &#123; return true; &#125; if (_data_que.size() &gt; 100) &#123; return false; &#125; return true; &#125;); if (b_stop) &#123; return ; &#125; _data_que.push(++data); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; data &lt;&lt; std::endl; lock.unlock(); _consume_cv.notify_one(); &#125; &#125;);&#125; 按下ctrl+c后，程序输出如下，并且正常退出 1234push data is 1pop data is 1Ctrl-C eventmain exit 多线程之间协同工作以及安全退出是设计要考虑的事情。 混用智能指针和裸指针有时候混用智能指针和裸指针，我们也会不小心delete一个交给只能指针管理的裸指针。单例在day24-TroubleShoot文件夹中ThreadSafeQue.h以及deadlock.cpp中。 之前我们为了让线程池从其他队列的尾部窃取任务，所以用双向链表实现了线程安全队列，并且实现了从尾部pop数据的方法。 12345678910111213141516bool try_steal(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; tail_lock(tail_mutex,std::defer_lock); std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex, std::defer_lock); std::lock(tail_lock, head_lock); if (head.get() == tail) &#123; return false; &#125; node* prev_node = tail-&gt;prev; value = std::move(*(prev_node-&gt;data)); delete tail; tail = prev_node; tail-&gt;next = nullptr; return true;&#125; 我们实现测试用例，一个线程push数据，一个线程从尾部pop数据，一个线程 12345678910111213141516171819202122232425262728293031323334353637383940void TestSteal() &#123; threadsafe_queue&lt;int&gt; que; std::thread t1([&amp;que]() &#123; int index = 0; for (; ; ) &#123; index++; que.push(index); std::this_thread::sleep_for(std::chrono::milliseconds(200)); &#125; &#125;); std::thread t3([&amp;que]() &#123; for (; ; ) &#123; int value; bool res = que.try_pop(value); if (!res) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); continue; &#125; std::cout &lt;&lt; &quot;pop out value is &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; &#125;); std::thread t2([&amp;que]() &#123; for (; ; ) &#123; int value; bool res = que.try_steal(value); if (!res) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); continue; &#125; std::cout &lt;&lt; &quot;steal out value is &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; &#125;); t1.join(); t2.join(); t3.join();&#125; 执行TestSteal时，程序崩溃。 查看堆栈上层信息，崩溃在try_steal这个函数里了。 多线程排查问题时，先把最有嫌疑的线程屏蔽，我们把try_steal的线程屏蔽，发现没有引发崩溃。可以确定是try_steal导致。 我们看try_steal函数内部，涉及内存的有个delete tail, 我们将这个delete tail 注释，发现没问题了。可见是delete tail 出了问题，结合底层崩溃的信息是unique_ptr的析构函数，可以推断我们混用了裸指针和智能指针，很可能是delete了智能指针管理的内存，导致智能指针析构的时候又一次delete内存引发崩溃。我们看下队列里节点的设计 1234567891011struct node&#123; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; node* prev;&#125;;std::mutex head_mutex;std::unique_ptr&lt;node&gt; head;std::mutex tail_mutex;node* tail; 队列是通过node构造的链表，每个节点的next指针为智能指针指向下一个节点，head为std::unique_ptr&lt;node&gt;，tail虽然为node*类型的指针，但是是从智能指针get获取的，那么tail是不应该删除的。 解决的办法就是不用delete即可，pop 尾部节点后将新的尾部节点next指针设置为nullptr，这样就相当于对原tail所属的unique_ptr减少引用计数了。 总结本文介绍了C++ 多线程以及内存等问题的排错思路和方法，感兴趣的可以看看源码。 源码链接https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"中断线程","date":"2024-02-15T01:22:43.000Z","path":"2024/02/15/concpp28/","text":"简介前几篇文章陆续介绍了线程池(ThreadPool)，可汇合线程(join_thread)等技术，其中也用到了当管理类要退出时会通过条件变量唤醒挂起的线程，然后等待其执行完退出。本文按照作者的思路补充设计可中断的线程。 可中断线程一个可中断的线程大体的实现是这个样子的 1234567891011121314151617181920212223242526272829303132class interruptible_thread&#123; std::thread internal_thread; interrupt_flag* flag;public: template&lt;typename FunctionType&gt; interruptible_thread(FunctionType f) &#123; //⇽-- - 2 std::promise&lt;interrupt_flag*&gt; p; //⇽-- - 3 internal_thread = std::thread([f, &amp;p] &#123; p.set_value(&amp;this_thread_interrupt_flag); //⇽-- - 4 f(); &#125;); //⇽-- - 5 flag = p.get_future().get(); &#125; void join() &#123; internal_thread.join(); &#125; void interrupt() &#123; if (flag) &#123; //⇽-- - 6 flag-&gt;set(); &#125; &#125;&#125;; interrupt_flag 为中断标记，其set操作用来标记中断 internal_thread为内部线程，其回调函数内部先设置interrupt_flag*类型的promise值，再执行回调函数。 在interruptible_thread构造函数中等待internal_thread回调函数内部设置好flag的promise值后再退出。 this_thread_interrupt_flag是我们定义的线程变量thread_local interrupt_flag this_thread_interrupt_flag; 中断标记中断标记interrupt_flag类，主要是用来设置中断标记和判断是否已经中断，有可能挂起在条件变量的wait操作上，此时中断就需要唤醒挂起的线程。 为了扩充功能，我们希望设计接口支持在任何锁上等待，那我们使用condition_variable_any支持任意类型的条件变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class interrupt_flag&#123; std::atomic&lt;bool&gt; flag; std::condition_variable* thread_cond; std::condition_variable_any* thread_cond_any; std::mutex set_clear_mutex;public: interrupt_flag() : thread_cond(0), thread_cond_any(0) &#123;&#125; void set() &#123; flag.store(true, std::memory_order_relaxed); std::lock_guard&lt;std::mutex&gt; lk(set_clear_mutex); if (thread_cond) &#123; thread_cond-&gt;notify_all(); &#125; else if (thread_cond_any) &#123; thread_cond_any-&gt;notify_all(); &#125; &#125; bool is_set() const &#123; return flag.load(std::memory_order_relaxed); &#125; void set_condition_variable(std::condition_variable&amp; cv) &#123; std::lock_guard&lt;std::mutex&gt; lk(set_clear_mutex); thread_cond = &amp;cv; &#125; void clear_condition_variable() &#123; std::lock_guard&lt;std::mutex&gt; lk(set_clear_mutex); thread_cond = 0; &#125; template&lt;typename Lockable&gt; void wait(std::condition_variable_any&amp; cv, Lockable&amp; lk) &#123; struct custom_lock &#123; interrupt_flag* self; Lockable&amp; lk; custom_lock(interrupt_flag* self_, std::condition_variable_any&amp; cond, Lockable&amp; lk_) : self(self_), lk(lk_) &#123; self-&gt;set_clear_mutex.lock(); self-&gt;thread_cond_any = &amp;cond; &#125; void unlock() &#123; lk.unlock(); self-&gt;set_clear_mutex.unlock(); &#125; void lock() &#123; std::lock(self-&gt;set_clear_mutex, lk); &#125; ~custom_lock() &#123; self-&gt;thread_cond_any = 0; self-&gt;set_clear_mutex.unlock(); &#125; &#125;; custom_lock cl(this, cv, lk); interruption_point(); cv.wait(cl); interruption_point(); &#125;&#125;; set函数将停止标记设置为true，然后用条件变量通知挂起的线程。 set_condition_variable 设置flag关联的条件变量，因为需要用指定的条件变量通知挂起的线程。 clear_condition_variable清除关联的条件变量 wait操作封装了接受任意锁的等待操作，wait函数内部定义了custom_lock，封装了加锁，解锁等操作。 wait操作内部构造了custom_lock对象cl主要是对set_clear_mutex加锁，然后在调用cv.wait，这样能和set函数中的通知条件变量构成互斥，这么做的好处就是要么先将flag设置为true并发送通知，要么先wait，然后再发送通知。这样避免了线程在wait处卡死(线程不会错过发送的通知) interruption_point函数内部判断flag是否为true，如果为true则抛出异常，这里作者处理的突兀了一些。读者可将这个函数改为bool返回值，调用者根据返回值判断是否继续等都可以。 1234567void interruption_point()&#123; if (this_thread_interrupt_flag.is_set()) &#123; throw thread_interrupted(); &#125;&#125; thread_interrupted为我们自定义的异常 1234567891011121314class thread_interrupted : public std::exception&#123;public: thread_interrupted() : message(&quot;thread interrupted.&quot;) &#123;&#125; ~thread_interrupted() throw () &#123; &#125; virtual const char* what() const throw () &#123; return message.c_str(); &#125;private: std::string message;&#125;; 接下来定义一个类clear_cv_on_destruct 12345struct clear_cv_on_destruct &#123; ~clear_cv_on_destruct()&#123; this_thread_interrupt_flag.clear_condition_variable(); &#125;&#125;; clear_cv_on_destruct 这个类主要是用来在析构时释放和flag关联的条件变量。 除此之外，我们还可以封装几个不同版本的等待支持普通条件变量的等待 12345678910void interruptible_wait(std::condition_variable&amp; cv, std::unique_lock&lt;std::mutex&gt;&amp; lk)&#123; interruption_point(); this_thread_interrupt_flag.set_condition_variable(cv); clear_cv_on_destruct guard; interruption_point(); cv.wait_for(lk, std::chrono::milliseconds(1)); interruption_point();&#125; 支持谓词的等待 1234567891011121314template&lt;typename Predicate&gt;void interruptible_wait(std::condition_variable&amp; cv, std::unique_lock&lt;std::mutex&gt;&amp; lk, Predicate pred)&#123; interruption_point(); this_thread_interrupt_flag.set_condition_variable(cv); clear_cv_on_destruct guard; while (!this_thread_interrupt_flag.is_set() &amp;&amp; !pred()) &#123; cv.wait_for(lk, std::chrono::milliseconds(1)); &#125; interruption_point();&#125; 上面两个版本采用wait_for而不用wait是因为如果等待之前条件变量的通知已经发送，线程之后才调用wait就会发生死等，所以这里采用的wait_for 支持future的等待 1234567891011template&lt;typename T&gt;void interruptible_wait(std::future&lt;T&gt;&amp; uf)&#123; while (!this_thread_interrupt_flag.is_set()) &#123; if (uf.wait_for(std::chrono::milliseconds(1)) == std::future_status::ready) break; &#125; interruption_point();&#125; 接下来我们用案例测试上面的案例 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &quot;interupthread.h&quot;std::vector&lt;interruptible_thread&gt; background_threads;std::mutex mtx1;std::mutex mtx2;std::condition_variable cv1;std::condition_variable_any cv2;void start_background_processing() &#123; background_threads.push_back([]() &#123; try &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx1); interruptible_wait(cv1, lock); &#125; catch (std::exception&amp; ex) &#123; std::cout &lt;&lt; &quot;catch exception is &quot; &lt;&lt; ex.what() &lt;&lt; std::endl; &#125; &#125;); background_threads.push_back([]() &#123; try &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx2); this_thread_interrupt_flag.wait(cv2, mtx2); &#125; catch (std::exception&amp; ex) &#123; std::cout &lt;&lt; &quot;catch exception is &quot; &lt;&lt; ex.what() &lt;&lt; std::endl; &#125; &#125;);&#125;int main()&#123; start_background_processing(); for (unsigned i = 0; i &lt; background_threads.size(); i++) &#123; background_threads[i].interrupt(); &#125; for (unsigned i = 0; i &lt; background_threads.size(); i++) &#123; background_threads[i].join(); &#125;&#125; 上面的案例中启动了两个线程，每个线程回调函数中调用我们封装的可中断的等待。在主函数中断两个线程，并测试两个线程能否在等待中中断。 程序输出 12catch exception is thread interrupted.catch exception is thread interrupted. 总结本文介绍了中断线程的设计，说简单点还是设置终止标记为true，利用条件变量通知挂起的线程唤醒。 源码链接： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day23-interupthread 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"线程池技术补充(轮询，等待完成结果，避免争夺，任务窃取)","date":"2024-02-12T00:38:09.000Z","path":"2024/02/12/concpp27/","text":"简介前文我们介绍了线程池，已经给大家提供了一个完整的线程池封装了，本节跟着《C++ 并发编程实战》一书中作者的思路，看看他的线程池的实现，以此作为补充 轮询方式的线程池配合我们之前封装的线程安全队列threadsafe_queue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;mutex&gt;#include &lt;queue&gt;template&lt;typename T&gt;class threadsafe_queue&#123;private: struct node &#123; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; node* prev; &#125;; std::mutex head_mutex; std::unique_ptr&lt;node&gt; head; std::mutex tail_mutex; node* tail; std::condition_variable data_cond; std::atomic_bool bstop; node* get_tail() &#123; std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); return tail; &#125; std::unique_ptr&lt;node&gt; pop_head() &#123; std::unique_ptr&lt;node&gt; old_head = std::move(head); head = std::move(old_head-&gt;next); return old_head; &#125; std::unique_lock&lt;std::mutex&gt; wait_for_data() &#123; std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex); data_cond.wait(head_lock,[&amp;] &#123;return head.get() != get_tail() || bstop.load() == true; &#125;); return std::move(head_lock); &#125; std::unique_ptr&lt;node&gt; wait_pop_head() &#123; std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data()); if (bstop.load()) &#123; return nullptr; &#125; return pop_head(); &#125; std::unique_ptr&lt;node&gt; wait_pop_head(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data()); if (bstop.load()) &#123; return nullptr; &#125; value = std::move(*head-&gt;data); return pop_head(); &#125; std::unique_ptr&lt;node&gt; try_pop_head() &#123; std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); if (head.get() == get_tail()) &#123; return std::unique_ptr&lt;node&gt;(); &#125; return pop_head(); &#125; std::unique_ptr&lt;node&gt; try_pop_head(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); if (head.get() == get_tail()) &#123; return std::unique_ptr&lt;node&gt;(); &#125; value = std::move(*head-&gt;data); return pop_head(); &#125;public: threadsafe_queue() : // ⇽-- - 1 head(new node), tail(head.get()) &#123;&#125; ~threadsafe_queue() &#123; bstop.store(true); data_cond.notify_all(); &#125; threadsafe_queue(const threadsafe_queue&amp; other) = delete; threadsafe_queue&amp; operator=(const threadsafe_queue&amp; other) = delete; void Exit() &#123; bstop.store(true); data_cond.notify_all(); &#125; bool wait_and_pop_timeout(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex); auto res = data_cond.wait_for(head_lock, std::chrono::milliseconds(100), [&amp;] &#123;return head.get() != get_tail() || bstop.load() == true; &#125;); if (res == false) &#123; return false; &#125; if (bstop.load()) &#123; return false; &#125; value = std::move(*head-&gt;data); head = std::move(head-&gt;next); return true; &#125; std::shared_ptr&lt;T&gt; wait_and_pop() // &lt;------3 &#123; std::unique_ptr&lt;node&gt; const old_head = wait_pop_head(); if (old_head == nullptr) &#123; return nullptr; &#125; return old_head-&gt;data; &#125; bool wait_and_pop(T&amp; value) // &lt;------4 &#123; std::unique_ptr&lt;node&gt; const old_head = wait_pop_head(value); if (old_head == nullptr) &#123; return false; &#125; return true; &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::unique_ptr&lt;node&gt; old_head = try_pop_head(); return old_head ? old_head-&gt;data : std::shared_ptr&lt;T&gt;(); &#125; bool try_pop(T&amp; value) &#123; std::unique_ptr&lt;node&gt; const old_head = try_pop_head(value); if (old_head) &#123; return true; &#125; return false; &#125; bool empty() &#123; std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); return (head.get() == get_tail()); &#125; void push(T new_value) //&lt;------2 &#123; std::shared_ptr&lt;T&gt; new_data( std::make_shared&lt;T&gt;(std::move(new_value))); std::unique_ptr&lt;node&gt; p(new node); &#123; std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); tail-&gt;data = new_data; node* const new_tail = p.get(); new_tail-&gt;prev = tail; tail-&gt;next = std::move(p); tail = new_tail; &#125; data_cond.notify_one(); &#125; bool try_steal(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; tail_lock(tail_mutex,std::defer_lock); std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex, std::defer_lock); std::lock(tail_lock, head_lock); if (head.get() == tail) &#123; return false; &#125; node* prev_node = tail-&gt;prev; value = std::move(*(prev_node-&gt;data)); tail = prev_node; tail-&gt;next = nullptr; return true; &#125;&#125;; 我们封装了一个简单轮询的线程池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;atomic&gt;#include &quot;ThreadSafeQue.h&quot;#include &quot;join_thread.h&quot;class simple_thread_pool&#123; std::atomic_bool done; //⇽-- - 1 threadsafe_queue&lt;std::function&lt;void()&gt; &gt; work_queue; //⇽-- - 2 std::vector&lt;std::thread&gt; threads; //⇽-- - 3 join_threads joiner; void worker_thread() &#123; //⇽-- - 4 while (!done) &#123; std::function&lt;void()&gt; task; //⇽-- - 5 if (work_queue.try_pop(task)) &#123; //⇽-- - 6 task(); &#125; else &#123; //⇽-- - 7 std::this_thread::yield(); &#125; &#125; &#125; simple_thread_pool() : done(false), joiner(threads) &#123; //⇽--- 8 unsigned const thread_count = std::thread::hardware_concurrency(); try &#123; for (unsigned i = 0; i &lt; thread_count; ++i) &#123; //⇽-- - 9 threads.push_back(std::thread(&amp;simple_thread_pool::worker_thread, this)); &#125; &#125; catch (...) &#123; //⇽-- - 10 done = true; throw; &#125; &#125;public: static simple_thread_pool&amp; instance() &#123; static simple_thread_pool pool; return pool; &#125; ~simple_thread_pool() &#123; //⇽-- - 11 done = true; for (unsigned i = 0; i &lt; threads.size(); ++i) &#123; //⇽-- - 9 threads[i].join(); &#125; &#125; template&lt;typename FunctionType&gt; void submit(FunctionType f) &#123; //⇽-- - 12 work_queue.push(std::function&lt;void()&gt;(f)); &#125;&#125;; worker_thread 即为线程的回调函数，回调函数内从队列中取出任务并处理，如果没有任务则调用yield释放cpu资源。 submit函数比较简单，投递了一个返回值为void，参数为void的任务。这和我们之前自己设计的线程池(可执行任意参数类型，返回值不限的函数)相比功能稍差了一些。 获取任务完成结果因为外部投递任务给线程池后要获取线程池执行任务的结果，我们之前自己设计的线程池采用的是future和decltype推断函数返回值的方式构造一个返回类型的future。 这里作者先封装一个可调用对象的类 123456789101112131415161718192021222324252627282930313233class function_wrapper&#123; struct impl_base &#123; virtual void call() = 0; virtual ~impl_base() &#123;&#125; &#125;; std::unique_ptr&lt;impl_base&gt; impl; template&lt;typename F&gt; struct impl_type : impl_base &#123; F f; impl_type(F&amp;&amp; f_) : f(std::move(f_)) &#123;&#125; void call() &#123; f(); &#125; &#125;;public: template&lt;typename F&gt; function_wrapper(F&amp;&amp; f) : impl(new impl_type&lt;F&gt;(std::move(f))) &#123;&#125; void operator()() &#123; impl-&gt;call(); &#125; function_wrapper() = default; function_wrapper(function_wrapper&amp;&amp; other) : impl(std::move(other.impl)) &#123;&#125; function_wrapper&amp; operator=(function_wrapper&amp;&amp; other) &#123; impl = std::move(other.impl); return *this; &#125; function_wrapper(const function_wrapper&amp;) = delete; function_wrapper(function_wrapper&amp;) = delete; function_wrapper&amp; operator=(const function_wrapper&amp;) = delete;&#125;; impl_base 是一个基类，内部有一个纯虚函数call，以及一个虚析构，这样可以通过delete 基类指针动态析构子类对象。 impl_type 继承了impl_base类，内部包含了一个可调用对象f，并且实现了构造函数和call函数，call内部调用可调用对象f。 function_wrapper 内部有智能指针impl_base类型的unique_ptr变量impl, function_wrapper构造函数根据可调用对象f构造impl function_wrapper支持移动构造不支持拷贝和赋值。function_wrapper本质上就是当作task给线程池执行的。 可获取任务执行状态的线程池如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class future_thread_pool&#123;private: void worker_thread() &#123; while (!done) &#123; function_wrapper task; if (work_queue.try_pop(task)) &#123; task(); &#125; else &#123; std::this_thread::yield(); &#125; &#125; &#125;public: static future_thread_pool&amp; instance() &#123; static future_thread_pool pool; return pool; &#125; ~future_thread_pool() &#123; //⇽-- - 11 done = true; for (unsigned i = 0; i &lt; threads.size(); ++i) &#123; //⇽-- - 9 threads[i].join(); &#125; &#125; template&lt;typename FunctionType&gt; std::future&lt;typename std::result_of&lt;FunctionType()&gt;::type&gt; submit(FunctionType f) &#123; typedef typename std::result_of&lt;FunctionType()&gt;::type result_type; std::packaged_task&lt;result_type()&gt; task(std::move(f)); std::future&lt;result_type&gt; res(task.get_future()); work_queue.push(std::move(task)); return res; &#125;private: future_thread_pool() : done(false), joiner(threads) &#123; //⇽--- 8 unsigned const thread_count = std::thread::hardware_concurrency(); try &#123; for (unsigned i = 0; i &lt; thread_count; ++i) &#123; //⇽-- - 9 threads.push_back(std::thread(&amp;future_thread_pool::worker_thread, this)); &#125; &#125; catch (...) &#123; //⇽-- - 10 done = true; throw; &#125; &#125; std::atomic_bool done; //⇽-- - 1 threadsafe_queue&lt;function_wrapper&gt; work_queue; //⇽-- - 2 std::vector&lt;std::thread&gt; threads; //⇽-- - 3 join_threads joiner;&#125;; worker_thread内部从队列中pop任务并执行，如果没有任务则交出cpu资源。 submit函数返回值为std::future&lt;typename std::result_of&lt;FunctionType()&gt;::type&gt;类型，通过std::result_of&lt;FunctionType()&gt;推断出函数执行的结果，然后通过::type推断出结果的类型，并且根据这个类型构造future，这样调用者就可以在投递完任务获取任务的执行结果了。 submit函数内部我们将函数执行的结果类型定义为result_type类型，并且利用f构造一个packaged_task任务。通过task返回一个future给外部调用者，然后我们调用队列的push将task放入队列，注意队列存储的是function_wrapper，这里是利用task隐式构造了function_wrapper类型的对象。 利用条件变量等待当我们的任务队列中没有任务的时候，可以让线程挂起，然后等待有任务投递到队列后在激活线程处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class notify_thread_pool&#123;private: void worker_thread() &#123; while (!done) &#123; auto task_ptr = work_queue.wait_and_pop(); if (task_ptr == nullptr) &#123; continue; &#125; (*task_ptr)(); &#125; &#125;public: static notify_thread_pool&amp; instance() &#123; static notify_thread_pool pool; return pool; &#125; ~notify_thread_pool() &#123; //⇽-- - 11 done = true; work_queue.Exit(); for (unsigned i = 0; i &lt; threads.size(); ++i) &#123; //⇽-- - 9 threads[i].join(); &#125; &#125; template&lt;typename FunctionType&gt; std::future&lt;typename std::result_of&lt;FunctionType()&gt;::type&gt; submit(FunctionType f) &#123; typedef typename std::result_of&lt;FunctionType()&gt;::type result_type; std::packaged_task&lt;result_type()&gt; task(std::move(f)); std::future&lt;result_type&gt; res(task.get_future()); work_queue.push(std::move(task)); return res; &#125;private: notify_thread_pool() : done(false), joiner(threads) &#123; //⇽--- 8 unsigned const thread_count = std::thread::hardware_concurrency(); try &#123; for (unsigned i = 0; i &lt; thread_count; ++i) &#123; //⇽-- - 9 threads.push_back(std::thread(&amp;notify_thread_pool::worker_thread, this)); &#125; &#125; catch (...) &#123; //⇽-- - 10 done = true; work_queue.Exit(); throw; &#125; &#125; std::atomic_bool done; //⇽-- - 1 threadsafe_queue&lt;function_wrapper&gt; work_queue; //⇽-- - 2 std::vector&lt;std::thread&gt; threads; //⇽-- - 3 join_threads joiner;&#125;; worker_thread内部调用了work_queue的wait_and_pop函数，如果队列中有任务直接返回，如果没任务则挂起。 另外我们在线程池的析构函数和异常处理时都增加了work_queue.Exit(); 这需要在我们的线程安全队列中增加Exit函数通知线程唤醒，因为线程发现队列为空会阻塞住。 1234void Exit() &#123; bstop.store(true); data_cond.notify_all();&#125; 避免争夺我们的任务队列只有一个，当向任务队列频繁投递任务，线程池中其他线程从队列中获取任务，队列就会频繁加锁和解锁，一般情况下性能不会有什么损耗，但是如果投递的任务较多，我们可以采取分流的方式，创建多个任务队列(可以和线程池中线程数相等)，将任务投递给不同的任务队列，每个线程消费自己的队列即可，这样减少了线程间取任务的冲突。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &quot;ThreadSafeQue.h&quot;#include &lt;future&gt;#include &quot;ThreadSafeQue.h&quot;#include &quot;join_thread.h&quot;#include &quot;FutureThreadPool.h&quot;class parrallen_thread_pool&#123;private: void worker_thread(int index) &#123; while (!done) &#123; auto task_ptr = thread_work_ques[index].wait_and_pop(); if (task_ptr == nullptr) &#123; continue; &#125; (*task_ptr)(); &#125; &#125;public: static parrallen_thread_pool&amp; instance() &#123; static parrallen_thread_pool pool; return pool; &#125; ~parrallen_thread_pool() &#123; //⇽-- - 11 done = true; for (unsigned i = 0; i &lt; thread_work_ques.size(); i++) &#123; thread_work_ques[i].Exit(); &#125; for (unsigned i = 0; i &lt; threads.size(); ++i) &#123; //⇽-- - 9 threads[i].join(); &#125; &#125; template&lt;typename FunctionType&gt; std::future&lt;typename std::result_of&lt;FunctionType()&gt;::type&gt; submit(FunctionType f) &#123; int index = (atm_index.load() + 1) % thread_work_ques.size(); atm_index.store(index); typedef typename std::result_of&lt;FunctionType()&gt;::type result_type; std::packaged_task&lt;result_type()&gt; task(std::move(f)); std::future&lt;result_type&gt; res(task.get_future()); thread_work_ques[index].push(std::move(task)); return res; &#125;private: parrallen_thread_pool() : done(false), joiner(threads), atm_index(0) &#123; //⇽--- 8 unsigned const thread_count = std::thread::hardware_concurrency(); try &#123; thread_work_ques = std::vector &lt; threadsafe_queue&lt;function_wrapper&gt;&gt;(thread_count); for (unsigned i = 0; i &lt; thread_count; ++i) &#123; //⇽-- - 9 threads.push_back(std::thread(&amp;parrallen_thread_pool::worker_thread, this, i)); &#125; &#125; catch (...) &#123; //⇽-- - 10 done = true; for (int i = 0; i &lt; thread_work_ques.size(); i++) &#123; thread_work_ques[i].Exit(); &#125; throw; &#125; &#125; std::atomic_bool done; //全局队列 std::vector&lt;threadsafe_queue&lt;function_wrapper&gt;&gt; thread_work_ques; //⇽-- - 2 std::vector&lt;std::thread&gt; threads; //⇽-- - 3 join_threads joiner; std::atomic&lt;int&gt; atm_index;&#125;; 我们将任务队列变为多个 //全局队列 std::vector&lt;threadsafe_queue&lt;function_wrapper&gt;&gt; thread_work_ques;. commit的时候根据atm_index索引自增后对总大小取余将任务投递给不同的队列。 worker_thread增加了索引参数，每个线程的在回调的时候会根据自己的索引取出对应队列中的任务进行执行。 任务窃取当本线程队列中的任务处理完了，它可以去别的线程的任务队列中看看是否有没处理的任务，帮助其他线程处理任务，简称任务窃取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &quot;ThreadSafeQue.h&quot;#include &lt;future&gt;#include &quot;ThreadSafeQue.h&quot;#include &quot;join_thread.h&quot;#include &quot;FutureThreadPool.h&quot;class steal_thread_pool&#123;private: void worker_thread(int index) &#123; while (!done) &#123; function_wrapper wrapper; bool pop_res = thread_work_ques[index].try_pop(wrapper); if (pop_res) &#123; wrapper(); continue; &#125; bool steal_res = false; for (int i = 0; i &lt; thread_work_ques.size(); i++) &#123; if (i == index) &#123; continue; &#125; steal_res = thread_work_ques[i].try_pop(wrapper); if (steal_res) &#123; wrapper(); break; &#125; &#125; if (steal_res) &#123; continue; &#125; std::this_thread::yield(); &#125; &#125;public: static steal_thread_pool&amp; instance() &#123; static steal_thread_pool pool; return pool; &#125; ~steal_thread_pool() &#123; //⇽-- - 11 done = true; for (unsigned i = 0; i &lt; thread_work_ques.size(); i++) &#123; thread_work_ques[i].Exit(); &#125; for (unsigned i = 0; i &lt; threads.size(); ++i) &#123; //⇽-- - 9 threads[i].join(); &#125; &#125; template&lt;typename FunctionType&gt; std::future&lt;typename std::result_of&lt;FunctionType()&gt;::type&gt; submit(FunctionType f) &#123; int index = (atm_index.load() + 1) % thread_work_ques.size(); atm_index.store(index); typedef typename std::result_of&lt;FunctionType()&gt;::type result_type; std::packaged_task&lt;result_type()&gt; task(std::move(f)); std::future&lt;result_type&gt; res(task.get_future()); thread_work_ques[index].push(std::move(task)); return res; &#125;private: steal_thread_pool() : done(false), joiner(threads), atm_index(0) &#123; //⇽--- 8 unsigned const thread_count = std::thread::hardware_concurrency(); try &#123; thread_work_ques = std::vector &lt; threadsafe_queue&lt;function_wrapper&gt;&gt;(thread_count); for (unsigned i = 0; i &lt; thread_count; ++i) &#123; //⇽-- - 9 threads.push_back(std::thread(&amp;steal_thread_pool::worker_thread, this, i)); &#125; &#125; catch (...) &#123; //⇽-- - 10 done = true; for (int i = 0; i &lt; thread_work_ques.size(); i++) &#123; thread_work_ques[i].Exit(); &#125; throw; &#125; &#125; std::atomic_bool done; //全局队列 std::vector&lt;threadsafe_queue&lt;function_wrapper&gt;&gt; thread_work_ques; //⇽-- - 2 std::vector&lt;std::thread&gt; threads; //⇽-- - 3 join_threads joiner; std::atomic&lt;int&gt; atm_index;&#125;; worker_thread中本线程会先处理自己队列中的任务，如果自己队列中没有任务则从其它线程的任务队列中获取任务。如果都没有则交出cpu资源。 为了实现try_steal的功能，我们需要修改线程安全队列threadsafe_queue，增加try_steal函数 123456789101112131415bool try_steal(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; tail_lock(tail_mutex,std::defer_lock); std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex, std::defer_lock); std::lock(tail_lock, head_lock); if (head.get() == tail) &#123; return false; &#125; node* prev_node = tail-&gt;prev; value = std::move(*(prev_node-&gt;data)); tail = prev_node; tail-&gt;next = nullptr; return true;&#125; 因为try_steal是从队列的尾部弹出数据，为了防止此时有其他线程从头部弹出数据造成操作同一个节点，或者其他线程弹出头部数据后接着修改头部节点为下一个节点，此时本线程正在弹出尾部节点，而尾部节点正好是头部的下一个节点造成数据混乱，此时加了两把锁，对头部和尾部都加锁。 我们这里所说的弹出尾部节点不是弹出tail，而是tail的前一个节点，因为tail是尾部表示一个空节点，tail前边的节点才是尾部数据的节点，为了实现反向查找，我们为node增加了prev指针 123456struct node&#123; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; node* prev;&#125;; 所以在push节点的时候也要把这个节点的prev指针指向前一个节点 123456789101112131415void push(T new_value) //&lt;------2&#123; std::shared_ptr&lt;T&gt; new_data( std::make_shared&lt;T&gt;(std::move(new_value))); std::unique_ptr&lt;node&gt; p(new node); &#123; std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); tail-&gt;data = new_data; node* const new_tail = p.get(); new_tail-&gt;prev = tail; tail-&gt;next = std::move(p); tail = new_tail; &#125; data_cond.notify_one();&#125; 整体来说steal版本的线程池就这些内容和前边变化不大。 测试测试用例已经在源代码中写好，感兴趣可以看下 源码链接： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day22-ThreadPool 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"线程池原理和实现","date":"2024-02-07T08:41:09.000Z","path":"2024/02/07/concpp26/","text":"简介线程池是一种并发编程的技术，用于有效地管理和复用线程资源。它由一组预先创建的线程组成，这些线程可以在需要时执行任务，并在任务完成后返回线程池中等待下一个任务。 线程池的主要目的是避免反复创建和销毁线程的开销，以及有效地控制并发线程的数量。通过使用线程池，可以降低系统的负载，并提高任务执行的效率。 以下是线程池的一些关键特点： 线程池包含一个线程队列和任务队列，任务队列用于存储待执行的任务。 线程池在启动时会创建一定数量的线程，并将它们放入线程队列中。 当有任务需要执行时，线程池从任务队列中获取任务，并将其分配给空闲的线程执行。 执行完任务的线程会继续等待下一个任务的到来，而不是被销毁。 如果任务队列为空，线程池中的线程可以进入睡眠状态，减少资源占用。 线程池可以限制同时执行的线程数量，避免过多的并发线程导致系统负载过高。 使用线程池有以下几个优点： 提高性能：通过复用线程，避免了线程创建和销毁的开销，提高了任务执行的效率。 资源控制：线程池可以限制并发线程的数量，避免系统负载过高，保护系统资源。 提高响应性：线程池可以在任务到来时立即进行处理，减少了任务等待的时间，提高了系统的响应速度。 简化编程：使用线程池可以将任务的提交和执行分离，简化了并发编程的复杂性。 需要注意的是，在使用线程池时，需要合理设置线程池的大小，避免线程过多导致资源浪费，或线程过少导致任务等待的时间过长。 线程池的实现首先我不希望线程池被拷贝，我希望它能以单例的形式在需要的地方调用, 那么单例模式就需要删除拷贝构造和拷贝赋值，所以我设计一个基类 12345678910class NoneCopy &#123;public: ~NoneCopy()&#123;&#125;protected: NoneCopy()&#123;&#125;private: NoneCopy(const NoneCopy&amp;) = delete; NoneCopy&amp; operator=(const NoneCopy&amp;) = delete;&#125;; 然后让线程池ThreadPool类继承NoneCopy, 这样ThreadPool也就不支持拷贝构造和拷贝赋值了，拷贝构造和拷贝赋值的前提是其基类可以拷贝构造和赋值。 1234567891011class ThreadPool : public NoneCopy &#123;public: ~ThreadPool(); static ThreadPool&amp; instance() &#123; static ThreadPool ins; return ins; &#125;private: ThreadPool();&#125;; 我们先实现了instance函数，该函数是一个静态成员函数，返回局部的静态实例ins. 我们之前在单例模式中讲过，函数内局部的静态变量，其生命周期和进程同步，但是可见度仅在函数内部。 局部静态变量只会在第一次调用这个函数时初始化一次。故可以作为单例模式。这种模式在C++ 11之前是不安全的，因为各平台编译器实现规则可能不统一导致多线程会生成多个实例。 但是C++ 11过后，语言层面对其优化保证了多个线程调用同一个函数只会生成一个实例，所以C++ 11过后我们可以放心使用。 接下来考虑构造函数，我们说过线程池需要线程队列和任务队列，所以这两个队列要在构造函数中完成构造，线程队列我们可以用一个vector存储，任务队列因为要保证先进先出，所以用queue结构即可。 因为任务队列要有通用性，所以我们规定任务队列中存储的类型为 1using Task = std::packaged_task&lt;void()&gt;; 我们在ThreadPool中添加如下成员 1234std::atomic_int thread_num_;std::queue&lt;Task&gt; tasks_;std::vector&lt;std::thread&gt; pool_;std::atomic_bool stop_; 其中 tasks_ 表示任务队列， pool_表示线程队列， thread_num_表示空闲的线程数, stop_表示线程池是否退出。 那我们可以实现线程池的构造函数了 12345678910ThreadPool(unsigned int num = std::thread::hardware_concurrency()) : stop_(false) &#123; if (num &lt;= 1) thread_num_ = 2; else thread_num_ = num; start();&#125; 我们在构造函数中初始化停止标记为false，初始化线程数默认为硬件允许的物理并行核数。然后调用了start函数。 start函数主要的功能为启动线程并且将线程放入vector中管理，线程的回调函数基本功能就是从任务队列中消费数据，如果队列中有任务则pop出任务并执行，否则线程需要挂起。在部分初学者实现的线程池当中会采用循环等待的方式(如果队列为空则继续循环)，这种方式会造成线程忙等，进而引发资源的浪费。 所以我们现在还需要给ThreadPool添加两个成员 12std::mutex cv_mt_;std::condition_variable cv_lock_; 分别表示互斥量和条件变量，用来控制线程的休眠和唤醒。 那我们实现start函数 1234567891011121314151617181920212223void start() &#123; for (int i = 0; i &lt; thread_num_; ++i) &#123; pool_.emplace_back([this]() &#123; while (!this-&gt;stop_.load()) &#123; Task task; &#123; std::unique_lock&lt;std::mutex&gt; cv_mt(cv_mt_); this-&gt;cv_lock_.wait(cv_mt, [this] &#123; return this-&gt;stop_.load() || !this-&gt;tasks_.empty(); &#125;); if (this-&gt;tasks_.empty()) return; task = std::move(this-&gt;tasks_.front()); this-&gt;tasks_.pop(); &#125; this-&gt;thread_num_--; task(); this-&gt;thread_num_++; &#125; &#125;); &#125;&#125; pool_为线程队列，在线程队列中我们采用emplace_back直接调用线程的构造函数，将线程要处理的逻辑写成lambda表达式，从而构造线程并且将线程插入线程队列中。 lambda表达式内的逻辑先判断是否停止，如果停止则退出循环, 否则继续循环。 循环的逻辑就是每次从队列中取任务，先调用条件变量等待队列不为空，或者收到退出信号，二者只要满足其一，条件变量的wait就返回，并且继续向下走。否则条件变量wait不会返回，线程将挂起。 如果条件变量判断条件满足(队列不为空或者发现停止信号)，线程继续向下执行，判断如果任务队列为空则说明是因为收到停止信号所以直接返回退出，否则就说明任务队列有数据，我们取出任务队列头部的task，将空闲线程数减少1，执行task，再将空闲线程数+1. 接下来我们实现析构函数 123~ThreadPool() &#123; stop();&#125; 析构函数中的stop就是要向线程发送停止信号，避免线程一直处于挂起状态(因为任务队列为空会导致线程挂起) 12345678910void stop() &#123; stop_.store(true); cv_lock_.notify_all(); for (auto&amp; td : pool_) &#123; if (td.joinable()) &#123; std::cout &lt;&lt; &quot;join thread &quot; &lt;&lt; td.get_id() &lt;&lt; std::endl; td.join(); &#125; &#125;&#125; stop函数中我们将停止标记设置为true，并且调用条件变量的notify_all唤醒所有线程，并且等待所有线程退出后线程池才析构完成。 我们再实现一个函数提供给外部查询当前空闲的线程数，这个功能可有可无，主要是方便外部根据空闲线程数是否达到阈值派发任务。 123int idleThreadCount() &#123; return thread_num_;&#125; 我们实现了线程池处理任务的逻辑，接下来我们要封装一个接口提供给外部，支持其投递任务给线程池。 因为我们要投递任务给线程池，任务的功能和参数都不同，而之前我们设置的线程池执行的task类型为void(void)，返回值为void，参数为void的任务。那我们可用用参数绑定的方式将一个函数绑定为void(void)类型, 比如我们用如下操作 123456789int functionint(int param) &#123; std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; param &lt;&lt; std::endl; return 0;&#125;void bindfunction() &#123; std::function&lt;int(void)&gt; functionv = std::bind(functionint, 3); functionv();&#125; 假设我们希望任务队列里的任务要调用functionint，以及参数为3，因为在投递任务时我们就知道任务要执行的函数和参数，所以我们可以将执行的函数和参数绑定生成参数为void的函数。 我们通过bindfunction将functionint绑定为一个返回值为int，参数为void的新函数functionv。而我们的任务队列要放入返回值为void，参数也为void的函数，该怎么办呢？ 其实很简单，我们可以利用lambda表达式生成一个返回值和参数都为void的函数，函数内部调用functionv即可，有点类似于go，python等语言的闭包，但是C++的闭包是一种伪闭包，需要用值的方式捕获用到的变量。 比如我们将上面的函数functionint和调用的参数3打包放入队列，可以这么写 12345678void pushtasktoque() &#123; std::function&lt;int(void)&gt; functionv = std::bind(functionint, 3); using Task = std::packaged_task&lt;void()&gt;; std::queue&lt;Task&gt; taskque; taskque.emplace([functionv]() &#123; functionv(); &#125;);&#125; 我们先将functionint绑定为functionv，然后定义一个队列存储的类型为std::packaged_task&lt;void()&gt;, 为了防止拷贝构造的开销，我们调用队列的emplace函数，该函数接受lambda表达式直接构造任务放入了队列里。因为lambda表达式捕获了functionv的值，所以可以在内部调用functionv。 lambda表达式返回值为void参数也为void，所以可以直接放入任务队列。 接下来要一个问题，一个问题是我们投递任务，有时候投递方需要获取任务是否完成, 那我们可以利用packaged_task返回一个future给调用方，调用方在外部就可以通过future判断任务是否返回了。我们修改上面的函数，实现commit任务的函数 123456789101112std::future&lt;int&gt; committask() &#123; std::function&lt;int(void)&gt; functionv = std::bind(functionint, 3); auto taskf = std::make_shared&lt;std::packaged_task&lt;int(void)&gt;&gt;(functionv); auto res = taskf-&gt;get_future(); using Task = std::packaged_task&lt;void()&gt;; std::queue&lt;Task&gt; taskque; taskque.emplace([taskf]() &#123; (*taskf)(); &#125;); return res;&#125; 我们将functionv传递给packaged_task构造函数，构造了一个packaged_task类型的智能指针，每个人的编程风格不同，大家也可以不用智能指针，直接使用packaged_task对象，比如下面的 1std::packaged_task&lt;int(void)&gt; taskf(functionv); 我构造的是packaged_task类型的智能指针，所以通过taskf-&gt;get_future()获取future对象res，这个res作为参数返回给外部，外部就可以通过res判断任务是否完成。 接下来我们定义了一个任务队列，任务队列调用emplace直接构造任务插入队列中，避免拷贝开销。参数为lambda表达式，lamba捕获taskf对象的值，在内部调用(*taskf)()完成任务调用。 上面只是通过具体的函数和参数实现了投递任务的功能，而实际情况是我们要投递各种类型的任务，以及多种类型和多个参数，该怎么实现committask函数更通用呢？ 对于更通用的设计我们通常采用模板 12345template &lt;class F, class... Args&gt;std::future&lt;int&gt; commit(F&amp;&amp; f, Args&amp;&amp;... args)&#123; //.... return std::future&lt;int&gt;();&#125; 上面的模板定义了两个类型，F表示可调用对象类型，可以是lambda表达式，函数，function类等， Args为可变参数模板，可以是任意种类的类型，任意数量。commit函数参数采用F和Args的右值引用，这种模板类型的右值引用也被称作万能引用类型，可以接受左值引用，也可接受右值引用，利用引用折叠技术，可以推断出f和args的最终类型。我在基础课程里讲过，这里再给大家复习一下折叠规则，假设T为模板类型，推到规则如下： T&amp; &amp; =&gt; T&amp; T&amp; &amp;&amp; =&gt; T&amp; T&amp;&amp; &amp; =&gt; T&amp; T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp; 总结一下，就是只要出现了左值引用最后折叠的结果都是左值引用，只有右值应用和右值引用折叠才能变成右值引用。 1234567891011template&lt;typename T&gt;void Function(T&amp;&amp; t)&#123; //...&#125;int main()&#123; int a = 3; Function(a); Function(3); return 0;&#125; 当我们把一个int类型的左值a传递给 Function的 T&amp;&amp; 参数t时(T为模板类型)， T被推导为int &amp; , 那么参数t整体的类型就变为int &amp; &amp;&amp; =&gt; int &amp;类型，也就是左值引用类型。 当我们把一个右值3传递给Function的T&amp;&amp; 参数t时，T被推导为int类型。t被推导为int &amp;&amp; 类型，也就是右值引用类型。 如果大家熟悉boost库，可以用boost库的type_id_with_cvr打印具体类型，比如我们下面的代码 12345678910111213141516171819202122232425262728#include &lt;boost/type_index.hpp&gt;using boost::typeindex::type_id_with_cvr;int functionint(int param) &#123; std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; param &lt;&lt; std::endl; return 0;&#125;template &lt;class F, class... Args&gt;std::future&lt;int&gt; commit(F&amp;&amp; f, Args&amp;&amp;... args) &#123; //.... // 利用Boost库打印模板推导出来的 T 类型 std::cout &lt;&lt; &quot;F type：&quot; &lt;&lt; type_id_with_cvr&lt;F&gt;().pretty_name() &lt;&lt; std::endl; // 利用Boost库打印形参的类型 std::cout &lt;&lt; &quot;f type:&quot; &lt;&lt; type_id_with_cvr&lt;decltype(f)&gt;().pretty_name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Args type：&quot; &lt;&lt; type_id_with_cvr&lt;Args...&gt;().pretty_name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;args type：&quot; &lt;&lt; type_id_with_cvr&lt;decltype(args)...&gt;().pretty_name() &lt;&lt; std::endl; return std::future&lt;int&gt;();&#125;void reference_collapsing()&#123; int a = 3; commit(functionint, a);&#125; 调用reference_collapsing函数输出如下 1234F type：int (__cdecl&amp;)(int)f type:int (__cdecl&amp;)(int)Args type：int &amp; __ptr64args type：int &amp; __ptr64 可以看出F和f的类型都为函数对象的左值引用类型int (__cdecl&amp;)(int)，因为可变参数列表只有一个int左值类型，所以Args被推导为int &amp;类型， 同样的道理args也是int &amp;类型。 那如果我们换一种方式调用 123void reference_collapsing2()&#123; commit(std::move(functionint), 3);&#125; 调用reference_collapsing2输出如下 1234F type：int __cdecl(int)f type:int (__cdecl&amp;&amp;)(int)Args type：intargs type：int &amp;&amp; __ptr64 F为函数对象类型int __cdecl(int), f被对段位函数对象的右值引用类型int (__cdecl&amp;&amp;)(int) Args 被推断为int类型， args被推断为int &amp;&amp; 类型。 所以我们就可以得出之前给大家的结论，对于模板类型参数T &amp;&amp; , 编译器会根据传入的类型为左值还是右值，将T 推断为不同的类型， 如果传入的类型为int类型的左值，则T为int&amp;类型，如果传入的类型为int类型的右值，则T为int类型。 模板参数介绍完了，还要介绍一下原样转发, 熟悉我视频风格的读者都知道在介绍正确做法前我会先介绍错误示范，我们先看下面的例子 123456789101112void use_rightref(int &amp;&amp; rparam) &#123; //....&#125;template&lt;typename T&gt;void use_tempref(T&amp;&amp; tparam) &#123; use_rightref(tparam);&#125;void test_tempref() &#123; use_tempref(3);&#125; 我先给大家介绍下上面代码的调用流程，我们在test_tempref里调用use_tempref, 参数3是一个右值，所以use_tempref中T被推断为int类型， tparam为int &amp;&amp; 类型。我们接着将tparam传递给use_rightref,tparam是int &amp;&amp; 类型，刚好可以传递给use_rightref，然而上面的代码会报错。 1“void use_rightref(int &amp;&amp;)”: 无法将参数 1 从“T”转换为“int &amp;&amp;” 报错的原因是我们将tparam传递给use_rightref的时候参数类型不匹配。在use_tempref中，tparam为int &amp;&amp; 类型，即int 的右值引用类型。但是将tparam传递给use_rightref时，tparam是作为左值传递的， 他的类型是int &amp;&amp; 类型，但是在函数use_tempref中tparam可以作为左值使用。这么说大家有点难理解 我们分开理解，左值和右值的区别 左值（lvalue） 是指表达式结束后依然存在的、可被取地址的数据。通俗地说，左值就是可以放在赋值符号左边的值。 右值（rvalue） 是指表达式结束后就不再存在的临时数据。通常是不可被取地址的临时值，例如常量、函数返回值、表达式计算结果等。在 C++11 之后，右值引用的引入使得我们可以直接操作右值。 我们看下面的代码 12345678910template&lt;typename T&gt;void use_tempref(T&amp;&amp; tparam) &#123; int a = 4; tparam = a; tparam = std::move(a);&#125;void test_tempref() &#123; use_tempref(3);&#125; 上述代码编译没有问题可以运行，tparam可以作为左值被赋值。所以当它作为参数传递给其他函数的时候，它也是作为左值使用的，那么传递给use_rightref时，就会出现int&amp;&amp; 绑定左值的情况，这在编译阶段是不允许的。 下面这种tparam也是被作为左值使用 123456789void use_tempref(int &amp;&amp; tparam) &#123; int a = 4; tparam = a; tparam = std::move(a);&#125;void test_tempref() &#123; use_tempref(3);&#125; 上面代码编译也会通过的。 那么我们接下来要解决tparam作为左值传递给use_rightref报错的问题，C++ 给我们提供了原样转发功能，这个在基础中也给大家介绍过, C++ 源码对于forward的实现有两个版本，分别是将一个左值转化为一个左值或者右值，以及将一个右值转化为一个右值。 1234567891011template &lt;class _Ty&gt;_NODISCARD constexpr _Ty&amp;&amp; forward( remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept &#123; // forward an lvalue as either an lvalue or an rvalue return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);&#125;template &lt;class _Ty&gt;_NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept &#123; // forward an rvalue as an rvalue static_assert(!is_lvalue_reference_v&lt;_Ty&gt;, &quot;bad forward call&quot;); return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);&#125; 因为实现了两个版本，所以forward会根据传递的是左值调用第一个版本，传递的是右值调用第二个版本。 我们看看remove_reference_t&lt;_Ty&gt;的源码 1234567891011121314template &lt;class _Ty&gt;struct remove_reference&lt;_Ty&amp;&gt; &#123; using type = _Ty; using _Const_thru_ref_type = const _Ty&amp;;&#125;;template &lt;class _Ty&gt;struct remove_reference&lt;_Ty&amp;&amp;&gt; &#123; using type = _Ty; using _Const_thru_ref_type = const _Ty&amp;&amp;;&#125;;template &lt;class _Ty&gt;using remove_reference_t = typename remove_reference&lt;_Ty&gt;::type; 我们通过观察就会发现remove_reference_t&lt;_Ty&gt;其实是去除了_Ty中的引用返回内部的type. 所以我们forward(3)时，执行forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg), _Ty为int &amp;&amp; 类型，remove_reference_t&lt;_Ty&gt;为int类型. 返回的为static_cast&lt;_Ty&amp;&amp;&gt;(_Arg)类型，即int &amp;&amp; &amp;&amp;类型,折叠一下变为int &amp;&amp;类型。 同样当我们forward(a)，比如a是一个int类型的左值，则执行_Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp; _Arg), _Ty为int &amp;类型， remove_reference_t&lt;_Ty&gt;为int类型， 返回值为static_cast&lt;_Ty&amp;&amp;&gt;(_Arg) ,即int &amp; &amp;&amp; 类型折叠为int &amp;类型。 所以有了这些知识，我们解决上面的编译错误可以这么干 123456789101112void use_rightref(int &amp;&amp; rparam) &#123; //....&#125;template&lt;typename T&gt;void use_tempref(T&amp;&amp; tparam) &#123; use_rightref(std::forward&lt;T&gt;(tparam));&#125;void test_tempref() &#123; use_tempref(3);&#125; 接下来我们回到线程池的话题，commit函数需要返回future对象，但是我们又无法在函数定义的时候提前写好返回值future的类型，那怎么办呢？ 可以用到C++ 11的一个技术就是尾置推导 1234567template &lt;class F, class... Args&gt;auto commit(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))&gt; &#123; using RetType = decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...)); return std::future&lt;RetType&gt;&#123;&#125;;&#125; 我们在commit函数返回值写成了auto,告诉编译器具体的返回类型在其后，这样编译器在加载完函数的参数f和args之后，可以推导返回值类型. 推导也很简单，我们通过decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...)), decltype会根据根据表达式推断表达式的结果类型，我们用future存储这个类型，这个future就是返回值类型。 decltype中我们用了forward原样转发f和args，其实f不用转发，因为我们调用f是按照左值调用的，至于args原样转发是考虑f接受的参数可能是一个右值，但是这种情况其实不多，所以对于普通情形，我们写成decltype(f(args...))没问题的。 因为推导的类型我们以后还会用到，所以用了RetType来记录这个类型。 接下来我们给出commit的完整代码 123456789101112131415161718template &lt;class F, class... Args&gt;auto commit(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))&gt; &#123; using RetType = decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...)); if (stop_.load()) return std::future&lt;RetType&gt;&#123;&#125;; auto task = std::make_shared&lt;std::packaged_task&lt;RetType()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)); std::future&lt;RetType&gt; ret = task-&gt;get_future(); &#123; std::lock_guard&lt;std::mutex&gt; cv_mt(cv_mt_); tasks_.emplace([task] &#123; (*task)(); &#125;); &#125; cv_lock_.notify_one(); return ret;&#125; 在commit中我们生成一个packaged_task&lt;RetType()&gt;类型的智能指针task，通过task获取future. 接下来我们加锁并且将task放入队列，但是因为task的返回类型为RetType，所以我们采用了lambda表达式捕获task，内部调用task，将这个lambda表达式放入任务队列。 然后通知其他线程唤醒，并且返回future。 测试为了测试线程池，我们可以用前文实现的快速排序的方法，将任务分段递归投递给线程池，让线程池排序 123456789101112131415161718192021222324template&lt;typename T&gt;std::list&lt;T&gt;pool_thread_quick_sort(std::list&lt;T&gt; input) &#123; if (input.empty()) &#123; return input; &#125; std::list&lt;T&gt; result; result.splice(result.begin(), input, input.begin()); T const&amp; partition_val = *result.begin(); typename std::list&lt;T&gt;::iterator divide_point = std::partition(input.begin(), input.end(), [&amp;](T const&amp; val) &#123;return val &lt; partition_val; &#125;); std::list&lt;T&gt; new_lower_chunk; new_lower_chunk.splice(new_lower_chunk.end(), input, input.begin(), divide_point); std::future&lt;std::list&lt;T&gt; &gt; new_lower = ThreadPool::instance().commit(pool_thread_quick_sort&lt;T&gt;, new_lower_chunk); std::list&lt;T&gt; new_higher(pool_thread_quick_sort(input)); result.splice(result.end(), new_higher); result.splice(result.begin(), new_lower.get()); return result;&#125; 我们再写一个测试用例 1234567891011void TestThreadPoolSort() &#123; std::list&lt;int&gt; nlist = &#123; 6,1,0,5,2,9,11 &#125;; auto sortlist = pool_thread_quick_sort&lt;int&gt;(nlist); for (auto&amp; value : sortlist) &#123; std::cout &lt;&lt; value &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125; 结果输出 10 1 2 5 6 9 11 总结本文介绍线程池的原理，并实现了线程池 源码链接： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day22-ThreadPool 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"","date":"2024-01-29T11:56:02.582Z","path":"2024/01/29/concpp25/","text":"title: 几种简单并行算法的实现(for_each,find以及partial_sum)date: 2024-01-29 19:56:02tags: C++categories: C++ 简介前文介绍了几种数据划分的方式，包括按照线程数量划分，按照递归方式划分，以及按照任务类型划分等。 本文结合之前的划分方式，基于stl的find, for_each以及partial_sum等算法实现并行版本。 并行版本for_each实现并行的for_each，最简单的方式就是将数据划分，每个线程分别处理一段连续的数据即可。 在介绍并行版本之前，我们先实现一个管理线程 的类join_threads，用来管控线程防止线程过早退出 12345678910111213141516class join_threads&#123; std::vector&lt;std::thread&gt;&amp; threads;public: explicit join_threads(std::vector&lt;std::thread&gt;&amp; threads_) : threads(threads_) &#123;&#125; ~join_threads() &#123; for (unsigned long i = 0; i &lt; threads.size(); ++i) &#123; if (threads[i].joinable()) threads[i].join(); &#125; &#125;&#125;; 接下来我们实现第一种方式 12345678910111213141516171819202122232425262728293031323334353637template&lt;typename Iterator, typename Func&gt;void parallel_for_each(Iterator first, Iterator last, Func f)&#123; unsigned long const length = std::distance(first, last); if (!length) return; unsigned long const min_per_thread = 25; unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread; unsigned long const hardware_threads = std::thread::hardware_concurrency(); unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); unsigned long const block_size = length / num_threads; std::vector&lt;std::future&lt;void&gt;&gt; futures(num_threads - 1); //⇽-- - 1 std::vector&lt;std::thread&gt; threads(num_threads - 1); join_threads joiner(threads); Iterator block_start = first; for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123; Iterator block_end = block_start; std::advance(block_end, block_size); std::packaged_task&lt;void(void)&gt; task( // ⇽-- - 2 [=]() &#123; std::for_each(block_start, block_end, f); &#125;); futures[i] = task.get_future(); threads[i] = std::thread(std::move(task)); //⇽-- - 3 block_start = block_end; &#125; std::for_each(block_start, last, f); for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123; futures[i].get(); // ⇽-- - 4 &#125;&#125; 1 我们规定如果处理的数量不超过25个则用单线程。否则根据处理的数量划分任务，计算开辟的线程数，如果要开辟的线程数大于内核线程的数量，则以内核线程数为准。 2 根据实际开辟的线程数num_threads计算每个线程处理的块大小。并且初始化两个vector，分别用来存储处理结果的future和处理任务的线程。 3 我们在(2处)代码生成了一个任务task，然后获取future赋值给vector对应下标为i的future元素，并且把任务绑定给对应下标为i的thread。 4 numthreads-1个线程并行处理for_each，剩下的主线程处理余下的for_each，最后通过futures.get汇总 第二种划分方式是我们采取递归的方式，我们知道采用递归的方式无法提前开辟准确数量的线程，我们采用async帮我们完成这个任务 1234567891011121314151617181920212223template&lt;typename Iterator, typename Func&gt;void async_for_each(Iterator first, Iterator last, Func f)&#123; unsigned long const length = std::distance(first, last); if (!length) return; unsigned long const min_per_thread = 25; if (length &lt; (2 * min_per_thread)) &#123; std::for_each(first, last, f); //⇽-- - 1 &#125; else &#123; Iterator const mid_point = first + length / 2; //⇽-- - 2 std::future&lt;void&gt; first_half = std::async(&amp;async_for_each&lt;Iterator, Func&gt;, first, mid_point, f); //⇽-- - 3 async_for_each(mid_point, last, f); // ⇽-- - 4 first_half.get(); &#125;&#125; async可以帮助我们判断是否需要开启线程还是自动串行执行。每次我们将要处理的数据一分为2，前半部分交给一个async开辟线程处理，后半部分在本线程处理。而所谓的本线程不一定是主线程，因为我们通过async递归执行parallel_for_each，也就相当于在一个线程里独立执行了。 find的并行实现find 的并行查找方式还是分两种，一种是将要查找的区间划分为几个段，每段交给一个线程查找。 另一种是采用递归的方式每次折半，前半部分交给一个线程查找，后半部分留在本线程查找。 我们先说第一种 find比较特殊，我们要防止线程忙等待，也要防止线程在其他线程已经查找到值后做无谓的浪费。可以用一个共享的全局atomic变量表示是否找到目标。 因为主线程要获取某个线程查找到的迭代器位置，所以我们用promise 设置 value为迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768template&lt;typename Iterator, typename MatchType&gt;Iterator parallel_find(Iterator first, Iterator last, MatchType match)&#123; struct find_element //⇽-- - 1 &#123; void operator()(Iterator begin,Iterator end, MatchType match, std::promise&lt;Iterator&gt;*result, std::atomic&lt;bool&gt;*done_flag) &#123; try &#123; for (; (begin != end) &amp;&amp; !done_flag-&gt;load(); ++begin) //⇽-- - 2 &#123; if (*begin == match) &#123; result-&gt;set_value(begin); //⇽-- - 3 done_flag-&gt;store(true); //⇽-- - 4 return; &#125; &#125; &#125; catch (...) //⇽-- - 5 &#123; try &#123; result-&gt;set_exception(std::current_exception()); //⇽-- - 6 done_flag-&gt;store(true); &#125; catch (...) //⇽-- - 7 &#123;&#125; &#125; &#125; &#125;; unsigned long const length = std::distance(first, last); if (!length) return last; unsigned long const min_per_thread = 25; unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread; unsigned long const hardware_threads = std::thread::hardware_concurrency(); unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); unsigned long const block_size = length / num_threads; std::promise&lt;Iterator&gt; result; //⇽-- - 8 std::atomic&lt;bool&gt; done_flag(false); //⇽-- - 9 std::vector&lt;std::thread&gt; threads(num_threads - 1); //⇽-- - 10 &#123; join_threads joiner(threads); Iterator block_start = first; for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123; Iterator block_end = block_start; std::advance(block_end, block_size); // ⇽-- - 11 threads[i] = std::thread(find_element(), block_start, block_end, match, &amp;result, &amp;done_flag); block_start = block_end; &#125; // ⇽-- - 12 find_element()(block_start, last, match, &amp;result, &amp;done_flag); &#125; // ⇽-- - 13 if (!done_flag.load()) &#123; return last; &#125; //⇽-- - 14 return result.get_future().get(); &#125; 1 find_element重载了()运算符，接受四个参数，分别是迭代器的开始，迭代起的结束，要查找的数值，以及用来通知外部的promise，还有线程之间用来检测是否有某个线程完成查找的原子变量。 2 find_element重载()的逻辑就是查找这个区间内满足某个值的位置，并将这个位置的迭代起设置到promise中，然后将完成的原子变量标记为true。 说第二种方式，利用递归折半查找，我们可以用async帮助我们完成并行任务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template&lt;typename Iterator, typename MatchType&gt;Iterator parallel_find_impl(Iterator first, Iterator last, MatchType match, std::atomic&lt;bool&gt;&amp; done) // ⇽-- - 1&#123; try &#123; unsigned long const length = std::distance(first,last); unsigned long const min_per_thread = 25; // ⇽-- - 2 if (length &lt; (2 * min_per_thread)) //⇽-- - 3 &#123; for (; (first != last) &amp;&amp; !done.load(); ++first) //⇽-- - 4 &#123; if (*first == match) &#123; done = true; //⇽-- - 5 return first; &#125; &#125; return last; //⇽-- - 6 &#125; else &#123; //⇽-- - 7 Iterator const mid_point = first + (length / 2); //⇽-- - 8 std::future&lt;Iterator&gt; async_result = std::async(&amp;parallel_find_impl&lt;Iterator,MatchType&gt;, mid_point,last,match,std::ref(done)); //⇽-- - 9 Iterator const direct_result = parallel_find_impl(first,mid_point,match,done); //⇽-- - 10 return (direct_result == mid_point) ?async_result.get() : direct_result; &#125; &#125; catch (...) &#123; // ⇽-- - 11 done = true; throw; &#125;&#125;template&lt;typename Iterator, typename MatchType&gt;Iterator parallel_find_async(Iterator first, Iterator last, MatchType match)&#123; std::atomic&lt;bool&gt; done(false); //⇽-- - 12 return parallel_find_impl(first, last, match, done); &#125; 1 并行查找的方式种我们先根据长度是否小于50决定是否开启并行任务，如果小于50则采取单线程方式。 2 如果采用并行的方式，我们将长度折半，前半部分交给async，后半部分交给本线程。 3 最后我们在主线程中汇合，获取结果。 partial_sum并行版本C++ 提供了累计计算求和的功能，比如一个vector中存储的数据为{1,2,3},那么经过计算，第一个元素仍然为1，第二个元素为1+2， 第三个元素为1+2+3，结果为{1,3,6}. 关于并行版本我们可以这么思考，假设元数组为{1,2,3,4,5,6,7},那我们可以划分为三个部分，第一部分为{1,2,3}交给第一个线程处理, 第二部分{4,5,6}交给第二个线程处理，7交给本线程处理。 但是我们要考虑的一个问题是线程2要用到线程1最后计算的结果，线程1计算后{1,3,6}，线程2需要用到6做累加，我们可以先让线程1计算出第3个元素值6，再将这个6传递给线程2，剩下的就可以并行计算了。同样的道理本线程要处理最后一个元素的累加结果，他需要等到线程2处理完第6个元素的值。 所以基本思路是每个线程优先处理分区的最后一个元素，通过promise设置给其他线程，在这个阶段线程之间是串行的，等到所有线程都开始计算其他位置后就是并行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889template&lt;typename Iterator&gt;void parallel_partial_sum(Iterator first, Iterator last)&#123; typedef typename Iterator::value_type value_type; struct process_chunk //⇽-- - 1 &#123; void operator()(Iterator begin, Iterator last, std::future&lt;value_type&gt;* previous_end_value, std::promise&lt;value_type&gt;* end_value) &#123; try &#123; Iterator end = last; ++end; std::partial_sum(begin, end, begin); //⇽-- - 2 if (previous_end_value) //⇽-- - 3 &#123; value_type addend = previous_end_value-&gt;get(); // ⇽-- - 4 *last += addend; // ⇽-- - 5 if (end_value) &#123; end_value-&gt;set_value(*last); //⇽-- - 6 &#125; // ⇽-- - 7 std::for_each(begin, last, [addend](value_type&amp; item) &#123; item += addend; &#125;); &#125; else if (end_value) &#123; // ⇽-- - 8 end_value-&gt;set_value(*last); &#125; &#125; catch (...) // ⇽-- - 9 &#123; if (end_value) &#123; end_value-&gt;set_exception(std::current_exception()); // ⇽-- - 10 &#125; else &#123; throw; // ⇽-- - 11 &#125; &#125; &#125; &#125;; unsigned long const length = std::distance(first, last); if (!length) &#123; return; &#125; unsigned long const min_per_thread = 25; //⇽-- - 12 unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread; unsigned long const hardware_threads = std::thread::hardware_concurrency(); unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); unsigned long const block_size = length / num_threads; typedef typename Iterator::value_type value_type; std::vector&lt;std::thread&gt; threads(num_threads - 1); // ⇽-- - 13 std::vector&lt;std::promise&lt;value_type&gt; &gt; end_values(num_threads - 1); // ⇽-- - 14 std::vector&lt;std::future&lt;value_type&gt; &gt; previous_end_values; // ⇽-- - 15 previous_end_values.reserve(num_threads - 1); // ⇽-- - 16 join_threads joiner(threads); Iterator block_start = first; for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123; Iterator block_last = block_start; std::advance(block_last, block_size - 1); // ⇽-- - 17 // ⇽-- - 18 threads[i] = std::thread(process_chunk(), block_start, block_last, (i != 0) ? &amp;previous_end_values[i - 1] : 0, &amp;end_values[i]); block_start = block_last; ++block_start; // ⇽-- - 19 previous_end_values.push_back(end_values[i].get_future()); // ⇽-- - 20 &#125; Iterator final_element = block_start; std::advance(final_element, std::distance(block_start, last) - 1); // ⇽-- - 21 // ⇽-- - 22 process_chunk()(block_start, final_element, (num_threads &gt; 1) ? &amp;previous_end_values.back() : 0, 0); &#125; 1 定义了process_chunk类，重载了()运算符，在重载的逻辑里我们先计算区间内的partial_sum累计求和(2处) 2 因为我们处理的区间不一定是首个区间，也就是他还需要加上前面区间处理得出的最后一个元素的值，所以我们通过previouse_end_value判断本区间不是首个区间，并且加上前面处理的结果。优先将最后一个值计算出来设置给promise。然后在利用for_each遍历计算其他位置的值。 总结本文介绍了如何并行设计stl的相关算法，读者有好的思路可以互相交流一下。 测试代码和项目代码链接： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day21-ParallenAlgorithm 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[],"tags":[]},{"title":"线程间切分任务的方法","date":"2024-01-13T14:45:16.000Z","path":"2024/01/13/concpp24/","text":"按数量切分对于大量处理的数据，可以按照任务数量区分，简单来说如果我们要处理n个任务，总计有m个线程，那么我们可以简单的规划每个线程处理n/m个任务。 如下图 这种方式用来划分大量相同任务时可以采用，但是有些逻辑并不是完全可以靠数量划分的，比如递归逻辑。 递归划分前文我们提及了快速排序的并行实现，包括利用async和线程池的方式。 快速排序算法含有两大基本步骤： 选定一个元素为比较的基准元素； 将数据集按大小划分为前后两部分，重新构成新序列，再针对这两个部分递归排序。 数据划分无法从一开始就并行化，因为数据只有经过处理后，我们才清楚它会归入哪个部分。 若我们要并行化这个算法，就需要利用递归操作的固有性质。 每层递归均会涉及更多的quick_sort()函数调用，因为我们需对基准元素前后两部分都进行排序。 由于这些递归调用所访问的数据集互不相关，因此它们完全独立，正好吻合并发程序的首选执行方式。 下图展示了以递归方式划分数据。 在早期我们实现并行递归的快速排序，那段代码每深入一层递归，都借std::async()生成新的异步任务处理前半部分数据，而后部分则继续用本线程计算后半部分数据。 我们通过std::async()让C++线程库自主决定，是另起新线程执行新任务，还是在原线程上同步运行。 这点相当重要：假设排序操作的数据集非常庞大，若每次递归都生成新线程，则势必令线程数目激增。 我们将通过后文的性能分析了解到，太多线程反而可能令应用程序变慢。 如果数据集着实庞大，还有可能消耗殆尽全部线程。按上述递归方式来切分数据是不错的思路，但需约束线程数目的增长，不可任其数目无限膨胀。 此例比较简单，std::async()足以应付，但它不是唯一选择。 后来我们觉得开辟过多的线程并不合适，采用了线程池。 并发编程的作者提出的另一种做法是，根据std::hardware_concurrency()函数的返回值设定线程的数目，实现了accumulate()的并行版本。 接着，我们采用之前实现的线程安全的栈容器，将尚未排序的数据段压入其中，而不是启动新线程以执行递归调用。 若某线程无所事事，或因全部数据段均已处理妥当，或因它正等着另一数据段完成排序，若是后者，该线程即从栈容器取出所等的数据段自行排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;thread&gt;#include &lt;list&gt;#include &quot;thread_safe_stack.h&quot;#include &lt;future&gt;#include &lt;memory&gt;template&lt;typename T&gt;struct sorter //1 &#123; struct chunk_to_sort &#123; std::list&lt;T&gt; data; std::promise&lt;std::list&lt;T&gt; &gt; promise; &#125;; thread_safe_stack&lt;chunk_to_sort&gt; chunks; //⇽-- - 2 std::vector&lt;std::thread&gt; threads; // ⇽-- - 3 unsigned const max_thread_count; std::atomic&lt;bool&gt; end_of_data; sorter() : max_thread_count(std::thread::hardware_concurrency() - 1), end_of_data(false) &#123;&#125; ~sorter() //⇽-- - 4 &#123; end_of_data = true; //⇽-- - 5 for (unsigned i = 0; i &lt; threads.size(); ++i) &#123; threads[i].join(); //⇽-- - 6 &#125; &#125; void try_sort_chunk() &#123; std::shared_ptr&lt;chunk_to_sort&gt; chunk = chunks.try_pop(); //⇽-- - 7 if (chunk) &#123; sort_chunk(chunk); //⇽-- - 8 &#125; &#125; std::list&lt;T&gt; do_sort(std::list&lt;T&gt;&amp; chunk_data) //⇽-- - 9 &#123; if (chunk_data.empty()) &#123; return chunk_data; &#125; std::list&lt;T&gt; result; result.splice(result.begin(),chunk_data,chunk_data.begin()); T const&amp; partition_val = *result.begin(); typename std::list&lt;T&gt;::iterator divide_point = //⇽-- - 10 std::partition(chunk_data.begin(),chunk_data.end(), [&amp;](T const&amp; val) &#123;return val &lt; partition_val; &#125;); chunk_to_sort new_lower_chunk; new_lower_chunk.data.splice(new_lower_chunk.data.end(), chunk_data,chunk_data.begin(), divide_point); std::future&lt;std::list&lt;T&gt; &gt; new_lower = new_lower_chunk.promise.get_future(); chunks.push(std::move(new_lower_chunk)); // ⇽-- - 11 if (threads.size() &lt; max_thread_count) // ⇽-- - 12 &#123; threads.push_back(std::thread(&amp;sorter&lt;T&gt;::sort_thread,this)); &#125; std::list&lt;T&gt; new_higher(do_sort(chunk_data)); result.splice(result.end(),new_higher); while (new_lower.wait_for(std::chrono::seconds(0)) != std::future_status::ready) //⇽-- - 13 &#123; try_sort_chunk(); // ⇽-- - 14 &#125; result.splice(result.begin(),new_lower.get()); return result; &#125; void sort_chunk(std::shared_ptr&lt;chunk_to_sort &gt; const&amp; chunk) &#123; chunk-&gt;promise.set_value(do_sort(chunk-&gt;data)); //⇽-- - 15 &#125; void sort_thread() &#123; while (!end_of_data) //⇽-- - 16 &#123; try_sort_chunk(); // ⇽-- - 17 //交出时间片 std::this_thread::yield(); //⇽-- - 18 &#125; &#125;&#125;; 我们实现一个函数调用上面的封装快速排序 12345678910template&lt;typename T&gt;std::list&lt;T&gt; parallel_quick_sort(std::list&lt;T&gt; input) //⇽-- - 19&#123; if (input.empty()) &#123; return input; &#125; sorter&lt;T&gt; s; return s.do_sort(input); //⇽-- - 20&#125; 本例中，parallel_quick_sort()函数(19处)把绝大部分功能委托给sorter类(1处)，后者通过栈容器管理待排序的数据段(2处)，并集中管控多个线程以并发执行任务(3处)，从而以便捷的操作方式给出了代码实现。 本例中，主要工作由成员函数do_sort()负责(9处)，它借标准库的std::partition()函数完成数据分段(10处)。 do_sort()将新划分出来的数据段压入栈容器(11处)，但没有为每个数据段都专门生成新线程，而仅当仍存在空闲的处理器时(12处)才生成新线程。 因为划分出的前半部分数据可能会由别的线程处理，所以我们需要等待它完成排序而进入就绪状态(13处)。 如果当前线程是整个程序中仅有的线程，或者其他线程都正忙于别的任务，那么这一等待行为则需妥善处理，在当前线程的等待期间，我们让它试着从栈容器取出数据进行处理(14处)。 try_sort_chunk()先从栈容器弹出一段数据(7处)并对其进行排序(8处)，再把结果存入附属该段的promise中(15处)，使之准备就绪，以待提取。 向栈容器压入数据段与取出相关结果相互对应，两项操作均由同一个线程先后执行(11和12处)。 只要标志end_of_data没有成立（16处），各线程便反复循环，尝试对栈内数据段进行排序17。 每个线程在两次检测标志之间进行让步（18处），好让别的线程有机会向栈容器添加数据段。这段代码由sorter类的析构函数汇合各个线程（4处）。 do_sort()将在全部数据段都完成排序后返回（即便许多工作线程仍在运行），主线程进而从parallel_quick_sort()的调用返回20，并销毁sorter对象。其析构函数将设置标志end_of_data成立（5处），然后等待全部线程结束（6处）。标志的成立使得线程函数内的循环终止（16处）。 按照工作类别划分任务单线程应用程序照样需要同时运行多个任务，而某些程序即便正忙于手头的任务，也需随时处理外部输入的事件（譬如用户按键或网络数据包传入）。这些情形都与单一功能的设计原则矛盾，必须妥善处理。若我们按照单线程思维手动编写代码，那最后很可能混成“大杂烩”：先执行一下任务甲，再执行一下任务乙，接着检测按键事件，然后检查传入的网络数据包，又回头继续执行任务甲，如此反复循环。这就要求任务甲保存状态，好让控制流程按周期返回主循环，结果令相关的代码复杂化。如果向循环加入太多任务，处理速度便可能严重放缓，让用户感觉按键的响应时间过长。相信读者肯定见过这种操作方式的极端表现：我们让某个应用程序处理一些任务，其用户界面却陷入僵滞，到任务完成后才恢复。 只要把每个任务都放在独立的线程上运行，操作系统便会替我们“包办”切换动作。因此，任务甲的代码可专注于执行任务，我们无须再考虑保存状态和返回主循环，也不必纠结间隔多久就得这样操作。 假定每项任务都相互独立，且各线程无须彼此通信，那么该构想即可轻而易举地实现。可惜往往事与愿违。即便经过良好的设计，后台任务也常常按用户要求执行操作，它们需在完成时通过某种方式更新界面，好让用户知晓。反之，若用户想取消任务，就要通过界面线程向后台任务发送消息，告知它停止。 所以各个任务线程中要提供互相通知的接口，这种思想和Actor模式不谋而合。 当然我们划分任务给不同的线程也要注意精细程度，比如两个线程要做的功能中某个环节是一个共有的功能，那么我们需要将这个功能整合到一个单线程上。我们可以理解在一些高并发的设计中，即便某些模块是高并发，但是耦合度很高的逻辑处理还是采用单线程方式，我们之前设计网络i服务器是逻辑处理也是单线程，但是我们可以根据功能做区分再分化为不同的线程，这就类似于Actor设计模式了。 假设有这样一个情形，我们实现一个系统控制机器中各部件的运动，A部件运动结束后通知B部件运动，B部件结束后通知C部件继续运动等，C运动结束后再通知A部件继续运动。 按照任务划分的模式，A，B，C分别运行在不同的线程中处理不同的任务，而任务又要以流水线A-&gt;B-&gt;C的方式运作。 我们可以这样抽象出一个Actor类，它包含消息的投递，消息的处理，以及消息队列的管理，并且它是一个单例类，全局唯一。 先实现这个基本的模板单例类, 这期间会用到CRTP技术，CRTP：一个继承 以自己为模板参数的模板类 的类。 CRTP 奇特递归模板技术， Curiously recurring template pattern。 模板单例类实现如下 12345678910111213141516171819202122232425262728293031323334#include &lt;thread&gt;#include &quot;ThreadSafeQue.h&quot;#include &lt;atomic&gt;#include &lt;iostream&gt;template&lt;typename ClassType, typename QueType&gt;class ActorSingle &#123;public: static ClassType&amp; Inst() &#123; static ClassType as; return as; &#125; ~ ActorSingle()&#123; &#125; void PostMsg(const QueType&amp; data) &#123; _que.push(data); &#125;protected: ActorSingle():_bstop(false)&#123; &#125; ActorSingle(const ActorSingle&amp;) = delete; ActorSingle(ActorSingle&amp;&amp;) = delete; ActorSingle&amp; operator = (const ActorSingle&amp;) = delete; std::atomic&lt;bool&gt; _bstop; ThreadSafeQue&lt;QueType&gt; _que; std::thread _thread;&#125;; 模板单例类包含了原子变量_bstop控制线程是否停止 包含了_que用来存储要处理的信息，这是一个线程安全的队列。 _thread是要处理任务的线程。 线程安全队列我们之前有实现过，但是还需要稍微改进下以满足接受外部停止的通知。 我们给ThreadSafeQue添加一个原子变量_bstop表示线程停止的标记 在需要停止等待的时候我们调用如下通知函数 1234void NotifyStop() &#123; _bstop.store(true); data_cond.notify_one();&#125; 等待消息的函数需要补充根据停止条件去返回的逻辑,目的为防止线程被一直挂起 123456std::unique_lock&lt;std::mutex&gt; wait_for_data() &#123; std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex); data_cond.wait(head_lock,[&amp;] &#123;return (_bstop.load() == true) || (head.get() != get_tail()); &#125;); return std::move(head_lock); &#125; 修改wait_pop_head，根据停止条件返回空指针 12345678910std::unique_ptr&lt;node&gt; wait_pop_head()&#123; std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data()); if (_bstop.load()) &#123; return nullptr; &#125; return pop_head();&#125; 等待返回数据的逻辑也稍作修改，因为有可能是接收到停止信号后等待返回，所以此时返回空指针即可 12345678std::shared_ptr&lt;T&gt; WaitAndPop() // &lt;------3&#123; std::unique_ptr&lt;node&gt; const old_head = wait_pop_head(); if (old_head == nullptr) &#123; return nullptr; &#125; return old_head-&gt;data;&#125; 比如我们要实现一个ClassA 处理A类任务，可以这么做 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;ActorSingle.h&quot;#include &quot;ClassB.h&quot;struct MsgClassA &#123; std::string name; friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const MsgClassA&amp; ca) &#123; os &lt;&lt; ca.name; return os; &#125;&#125;;class ClassA : public ActorSingle&lt;ClassA, MsgClassA&gt; &#123; friend class ActorSingle&lt;ClassA, MsgClassA&gt;;public: ~ClassA() &#123; _bstop = true; _que.NotifyStop(); _thread.join(); std::cout &lt;&lt; &quot;ClassA destruct &quot; &lt;&lt; std::endl; &#125; void DealMsg(std::shared_ptr&lt;MsgClassA&gt; data) &#123; std::cout &lt;&lt; &quot;class A deal msg is &quot; &lt;&lt; *data &lt;&lt; std::endl; MsgClassB msga; msga.name = &quot;llfc&quot;; ClassB::Inst().PostMsg(msga); &#125;private: ClassA()&#123; _thread = std::thread([this]() &#123; for (; (_bstop.load() == false);) &#123; std::shared_ptr&lt;MsgClassA&gt; data = _que.WaitAndPop(); if (data == nullptr) &#123; continue; &#125; DealMsg(data); &#125; std::cout &lt;&lt; &quot;ClassA thread exit &quot; &lt;&lt; std::endl; &#125;); &#125;&#125;; 我们利用CRTP模式让ClassA继承了以ClassA为类型的模板，然后在DealMsg函数内部调用了 ClassB的投递消息，将任务B交给另一个线程处理。 关于ClassB的实现方式和ClassA类似，然后我们在ClassB的DealMsg中调用ClassC的PostMsg将消息投递给C的线程处理。 达到的效果就是 A-&gt;B-&gt;C 我们在主函数调用 1234567891011#include &lt;iostream&gt;#include &quot;ClassA.h&quot;int main()&#123; MsgClassA msga; msga.name = &quot;llfc&quot;; ClassA::Inst().PostMsg(msga); std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout &lt;&lt; &quot;main process exited!\\n&quot;;&#125; 程序输出如下 12345678910class A deal msg is llfcclass B deal msg is llfcclass C deal msg is llfcmain process exited!ClassC thread exitClassC destructClassB thread exitClassB destructClassA thread exitClassA destruct 可以看到处理的顺序是A-&gt;B-&gt;C，并且每个类都有析构和函数回收，说明我们的程序不存在内存泄漏。 这里要提示读者一个问题，如果A给B投递消息，而B又要给A投递消息，那么如果在A的头文件包含B的头文件，而B的头文件包含A的头文件势必会造成互引用问题，那么最好的解决方式就是在A和B的头文件中分别声明对方，在cpp文件中再包含即可。 上面的例子通过模板和继承的方式实现了类似Actor的收发消息的功能。 总结本文介绍了线程划分任务的三种方式 1 按照任务的数量划分 2 递归划分 3 按照任务的种类划分 源码链接： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day20-Actor 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"无锁设计的四条原则","date":"2024-01-13T02:45:16.000Z","path":"2024/01/13/concpp23/","text":"简介前面的文章介绍了无锁并发的相关知识，涵盖了无锁队列，无锁栈，环状无锁队列的设计，本文总结下无锁并发设计的几个设计规则，以供读者自己编写无锁代码时可以起到抛砖引玉的效果。 模型设计原则1： 在原型设计中使用std::memory_order_seq_cst次序若代码服从std::memory_order_seq_cst次序，则对其进行分析和推理要比其他内存次序容易得多，因为它令全部操作形成一个确定的总序列。 回顾之前我们实现的无锁栈和无锁队列，它们的原始版本全都采用std::memory_order_seq_cst次序，当基本操作均正常工作后，我们才放宽内存次序约束。 在这种意义上，采用其他内存次序其实是一项优化，需要避免过早实施。我们通常只有先完全了解代码全貌，认清哪些代码操作核心数据结构，才可以确定放宽哪些操作的内存次序约束。否则，事情就会很棘手。即便代码在测试过程中正常工作，也无法保证在生产环境下代码依然如此，这令内存次序的放宽调整变得复杂。所以，仅仅测试代码的运行并不足够，除非我们能够采用测试工具（假如真的存在），系统化地核查线程访问内存次序的全部可能的组合，验证它们是否与指定的内存次序约束保持一致。 内存回收方案原则2： 使用无锁的内存回收方案无锁代码中的一大难题是内存管理。最基本的要求是，只要目标对象仍然有可能正被其他线程指涉，就不得删除。然而，为了避免过度消耗内存，我们还是想及时删除无用的对象。 我们在这一章学习了3种方法，以确保内存回收满足安全要求： 1 暂缓全部删除对象的动作，等到没有线程访问数据结构的时候，才删除待销毁的对象； 2 采用风险指针，以辨识特定对象是否正在被某线程访问； 3 就对象进行引用计数，只要外部环境仍正在指涉目标对象，它就不会被删除。 3种方法的关键思想都是以某种方式掌握正在访问目标对象的线程数目，仅当该对象完全不被指涉的时候，才会被删除。针对无锁数据结构，还有很多别的方法可以回收内存。 譬如，无锁数据是使用垃圾回收器的理想场景。若我们得以采用垃圾回收器，即事先知晓它具备适时删除无用节点的能力，则算法的实现代码写起来就会轻松一些。 另一种处理方法是重复使用节点，等到数据结构销毁时才完全释放它们。我们之前实现的环状无锁队列就是重复使用固定个数的队列，头尾成环。由于重用了节点，因此所分配的内存便一直有效，代码从而避开了一些涉及未定义行为的麻烦细节。然而，这种方法有一个缺点，它导致程序频频出现被称为“ABA问题”的情形。 防范ABA问题原则3：防范ABA问题在所有涉及比较-交换的算法中，我们都要注意防范ABA问题。 该问题产生过程如下： 步骤1：线程甲读取原子变量x，得知其值为A。 步骤2：线程甲根据A执行某项操作，比如查找，或如果x是指针，则依据它提取出相关值（称为ov）。 步骤3：线程甲因操作系统调度而发生阻塞。 步骤4：另一线程对原子变量x执行别的操作，将其值改成B。 步骤5：又有线程改变了与A相关的数据，使得线程甲原本持有的值失效（步骤2中的ov）。这种情形也许是A表示某内存地址，而改动操作则是释放指针的目标内存，或变更目标数据，最后将产生严重后果。 步骤6：原子变量x再次被某线程改动，重新变回A。 若x属于指针型别，其指向目标可能在步骤5被改换成一个新对象。 步骤7：线程甲继续运行，在原子变量x上执行比较-交换操作，与A进行对比。因此比较-交换操作成功执行（因x的值依然为A），但A的关联数据却不再有效，即原本在步骤2中取得的ov已失效，而线程甲却无从分辨，这将破坏数据结构。 画出示意图 之前我们实现的无锁结构均不存在ABA问题，但它很容易由无锁算法的代码引发。该问题最常见的解决方法之一是，在原子变量x中引入一个ABA计数器。将变量x和计数器组成单一结构，作为一个整体执行比较-交换操作。每当它的值被改换，计数器就自增。照此处理，如果别的线程改动了变量x，即便其值看起来与最初一样，比较-交换操作仍会失败。 如果某数据结构的操作算法涉及空闲内存列表，或者涉及循环使用节点(比如我们之前实现的循环队列)，而不是通过内存分配器回收管理，那么ABA问题就格外常见。 举一个例子 原有的栈结构为 A –&gt; B –&gt; C 假设一个线程1执行pop将A头部节点的数据加载出来，还未做读改写更新head为B，此时时间片被其他线程2抢占执行pop将A,B分别出栈，然后线程3抢占时间片又将A入栈，那么我们看到此时栈的情况为 A –&gt; C , 如果时间片切换回线程1，此时线程1执行读改写操作发现head还是为A，他会误认为这期间没有其他线程改变栈，所以线程1的读改写将head更新为B。其实B已经被弹出了，那么这就是ABA问题。 上面的仅仅是一个ABA案例的描述，那我们实现的无锁栈或者无锁队列为什么不存在这个ABA问题呢？原因是我们每次push加入的node节点都不同。node的结构包含数据域和下一个节点的指针 12345678struct node&#123; std::shared_ptr&lt;T&gt; data; node* next; node(T const&amp; data_) : //⇽-- - 1 data(std::make_shared&lt;T&gt;(data_)) &#123;&#125;&#125;; 我们每次调用push虽然传递的data可以理解为A，但是构造的智能指针地址不同，也就是node中存储的data不同。所以即使线程1做读改写比较的时候发现数值都为A，但是地址不同，也可区分出栈被改变。 123456789101112131415161718void push(T const&amp; data)&#123; node* const new_node = new node(data); //⇽-- - 2 new_node-&gt;next = head.load(); //⇽-- - 3 while (!head.compare_exchange_weak(new_node-&gt;next, new_node)); //⇽-- - 4&#125;std::shared_ptr&lt;T&gt; pop() &#123; node* old_head = nullptr; //1 do &#123; old_head = head.load(); //2 if (old_head == nullptr) &#123; return nullptr; &#125; &#125; while (!head.compare_exchange_weak(old_head, old_head-&gt;next)); //3 return old_head-&gt;data; //4 &#125; 解决忙等原则4：找出忙等循环，协助其他线程。 如我们在无锁队列第一版的push代码中，若两个线程同时执行压入操作，其中一个就须等待另一个结束，才可以继续运行。这实质上是一个忙等循环，如果放任不管，受到阻塞的线程就唯有浪费CPU时间却无计可施。阻塞型操作与使用互斥和锁一样，三者均有可能以忙等循环的方式实现。 假设按照调度安排，某线程先开始执行，却因另一线程的操作而暂停等待，那么只要我们修改操作的算法，就能让前者先完成全部步骤，从而避免忙等，操作也不会被阻塞。 之后我们让比较失败的线程辅助完成节点的创建和tail的更新。这要求将非原子变量的数据成员改为原子变量，并采用比较-交换操作设置其值。不过，更复杂的数据结构需要进行更多修改。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"无锁并发队列的设计","date":"2024-01-06T23:47:13.000Z","path":"2024/01/07/concpp22/","text":"简介前文介绍了无锁并发栈的设计，本文继续介绍无锁队列的设计。队列和栈容器的难点稍微不同，因为对于队列结构，push()和pop()分别访问其不同部分，而在栈容器上，这两项操作都访问头节点，所以两种数据结构所需的同步操作相异。如果某线程在队列一端做出改动，而另一线程同时访问队列另一端，代码就要保证前者的改动过程能正确地为后者所见 单一消费者和生产者队列我们实现一个简单的无锁队列，只应对一个生产者一个消费者的情况，便于我们理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;atomic&gt;#include&lt;memory&gt;template&lt;typename T&gt;class SinglePopPush&#123;private: struct node &#123; std::shared_ptr&lt;T&gt; data; node* next; node() : next(nullptr) &#123;&#125; &#125;; std::atomic&lt;node*&gt; head; std::atomic&lt;node*&gt; tail; node* pop_head() &#123; node* const old_head = head.load(); // ⇽-- - 1 if (old_head == tail.load()) &#123; return nullptr; &#125; head.store(old_head-&gt;next); return old_head; &#125;public: SinglePopPush() : head(new node), tail(head.load()) &#123;&#125; SinglePopPush(const SinglePopPush&amp; other) = delete; SinglePopPush&amp; operator=(const SinglePopPush&amp; other) = delete; ~SinglePopPush() &#123; while (node* const old_head = head.load()) &#123; head.store(old_head-&gt;next); delete old_head; &#125; &#125; std::shared_ptr&lt;T&gt; pop() &#123; node* old_head = pop_head(); if (!old_head) &#123; return std::shared_ptr&lt;T&gt;(); &#125; // ⇽-- -2 std::shared_ptr&lt;T&gt; const res(old_head-&gt;data); delete old_head; return res; &#125; void push(T new_value) &#123; std::shared_ptr&lt;T&gt; new_data(std::make_shared&lt;T&gt;(new_value)); // ⇽-- - 3 node* p = new node; //⇽-- - 4 node* const old_tail = tail.load(); //⇽-- - 5 old_tail-&gt;data.swap(new_data); //⇽-- - 6 old_tail-&gt;next = p; //⇽-- - 7 tail.store(p); &#125;&#125;; 上面的实现初看上去还不错。在同一时刻，如果只有一个线程调用push()，且仅有一个线程调用pop()，这份代码便可以相对完美地工作。 本例中的push()和pop()之间存在先行关系，这点很重要，它使队列的使用者可安全地获取数据。 tail指针的存储操作7与其载入操作1同步：按控制流程，在运行push()的线程上，原有的尾节点中的data指针先完成存储操作5，然后tail才作为指针存入新值7； 并且，在运行pop()的线程上，tail指针先完成载入操作1，原来的data指针才执行加载操作2，故data的存储操作5在载入操作1之前发生 （全部环节正确无误。因此这个单一生产者、单一消费者（Single-Producer Single-Consumer，SPSC）队列可以完美地工作。 不过，若多个线程并发调用push()或并发调用pop()，便会出问题。我们先来分析push()。如果有两个线程同时调用push()，就会分别构造一个新的空节点并分配内存3，而且都从tail指针读取相同的值4，结果它们都针对同一个尾节点更新其数据成员，却各自把data指针和next指针设置为不同的值5和6。这形成了数据竞争！ pop_head()也有类似问题，若两个线程同时调用这个函数，它们就会读取同一个头节点而获得相同的next指针，而且都把它赋予head指针以覆盖head指针原有的值。最终两个线程均认为自己获取了正确的头节点，这是错误的根源。给定一项数据，我们不仅要确保仅有一个线程可对它调用pop()，如果有别的线程同时读取头节点，则还需保证它们可以安全地访问头节点中的next指针。我们曾在前文的无锁栈容器中遇见过类似问题，其pop()函数也有完全相同的问题。 多线程push解决多线程push的竞争问题。 一种方法是将data指针原子化，通过比较-交换操作来设置它的值。如果比较-交换操作成功，所操作的节点即为真正的尾节点，我们便可安全地设定next指针，使之指向新节点。若比较-交换操作失败，就表明有另一线程同时存入了数据，我们应该进行循环，重新读取tail指针并从头开始操作。 如果std::shared_ptr&lt;&gt;上的原子操作是无锁实现，那便万事大吉，否则我们仍需采取别的方法。一种可行的方法是令pop()返回std::unique_ptr&lt;&gt;指针（凭此使之成为指涉目标对象的唯一指针），并在队列中存储指向数据的普通指针。这样让代码得以按std::atomic&lt;T*&gt;的形式存储指针，支持必要的compare_exchange_strong()调用。 1234567891011121314151617181920212223void push(T new_value)&#123; std::unique_ptr&lt;T&gt; new_data(new T(new_value)); counted_node_ptr new_next; new_next.ptr=new node; new_next.external_count=1; for(;;) &#123; //⇽--- 1 node* const old_tail=tail.load(); T* old_data=nullptr; //⇽--- 2 if(old_tail-&gt;data.compare_exchange_strong( old_data,new_data.get())) &#123; old_tail-&gt;next=new_next; // 3 tail.store(new_next.ptr); new_data.release(); break; &#125; &#125;&#125; 引用计数避免了上述的数据竞争，但那不是push()中仅有的数据竞争。只要我们仔细观察，便会发现其代码模式与栈容器相同：先载入原子指针1，然后依据该指针读取目标值2。 另一线程有可能同时更新tail指针3，如果该更新在pop()内部发生，最终将导致删除尾节点。若尾节点先被删除，代码却依然根据指针读取目标值，就会产生未定义行为。 有一种方法能解决上面的问题，且该方法颇具吸引力：在尾节点中添加一外部计数器，与处理头节点的方法相同。不过队列中的每个节点已配备一个外部计数器，分别存储在对应前驱节点内的next指针中。 若要让同一个节点具有两个外部计数器，便需要改动引用计数的实现方式，以免过早删除节点。我们为了满足上述要求，可在节点的结构体中记录外部计数器的数目，外部计数器一旦发生销毁，该数目则自减，并且将该外部计数器的值加到内部计数器的值之上。对于任意特定节点，如果内部计数器的值变为零，且再也没有外部计数器存在，我们就知道该节点能被安全地删除. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465template&lt;typename T&gt;class lock_free_queue&#123;private: struct node; struct counted_node_ptr &#123; int external_count; node* ptr; &#125;; std::atomic&lt;counted_node_ptr&gt; head; //⇽--- 1 std::atomic&lt;counted_node_ptr&gt; tail; struct node_counter &#123; unsigned internal_count:30; //⇽--- 2 unsigned external_counters:2; &#125;; struct node &#123; std::atomic&lt;T*&gt; data; //⇽--- 3 std::atomic&lt;node_counter&gt; count; counted_node_ptr next; node() &#123; node_counter new_count; new_count.internal_count=0; //⇽--- 4 new_count.external_counters=2; count.store(new_count); next.ptr=nullptr; next.external_count=0; &#125; &#125;;public: void push(T new_value) &#123; std::unique_ptr&lt;T&gt; new_data(new T(new_value)); counted_node_ptr new_next; new_next.ptr=new node; new_next.external_count=1; counted_node_ptr old_tail=tail.load(); for(;;) &#123; // 5 increase_external_count(tail,old_tail); T* old_data=nullptr; // 6 if(old_tail.ptr-&gt;data.compare_exchange_strong( old_data,new_data.get())) &#123; old_tail.ptr-&gt;next=new_next; old_tail=tail.exchange(new_next); // 7 free_external_counter(old_tail); new_data.release(); break; &#125; old_tail.ptr-&gt;release_ref(); &#125; &#125;&#125;; tail指针(1处) 和head指针的型别均为atomic，而node结构体则以成员count (3处)取代原有的internal_count。 该count成员也是一个结构体，内含internal_count变量和新引入的external_counters变量(2处) 。请注意，external_counters仅需使用两位，因为同一个节点最多只可能有两个外部计数器。因此，结构体count为它分配了一个两位的位域，而把internal_count设定为30位的整型值，从而维持了计数器32位的整体尺寸。 按此处理，内部计数器的取值范围仍然非常大，还保证了在32位或64位计算机上，一个机器字（machine word）便能容纳整个结构体。后文很快会解释，为了杜绝条件竞争，上述两种计数器必须合并，视作单一数据项，共同进行更新。只要把结构体的大小限制在单个机器字内，那么在许多硬件平台上，其原子操作就更加有机会以无锁方式实现。 节点经过初始化，其internal_count成员被置零，而external_counters成员则设置成2(4处)，因为我们向队列加入的每个新节点，它最初既被tail指针指涉，也被前一个节点的next指针指涉。 我们先调用一个新函数increase_external_count()令外部计数器的值增加（5处），再载入tail指针，进而读取尾节点的data成员并对它调用compare_exchange_strong()（6处），然后对原有的tail指针执行free_external_counter()（7处）。 我们画一下这个图 多线程pop多线程pop实现和之前无锁栈类似，我们只要做外部引用计数的增加和内部引用计数的减少即可 1234567891011121314151617181920212223242526272829303132333435363738template&lt;typename T&gt;class lock_free_queue&#123;private: struct node &#123; void release_ref(); //node的余下代码与代码清单7.16相同 &#125;;public: std::unique_ptr&lt;T&gt; pop() &#123; // 1 counted_node_ptr old_head=head.load(std::memory_order_relaxed); for(;;) &#123; //2 increase_external_count(head,old_head); node* const ptr=old_head.ptr; if(ptr==tail.load().ptr) &#123; //3 ptr-&gt;release_ref(); return std::unique_ptr&lt;T&gt;(); &#125; // 4 if(head.compare_exchange_strong(old_head,ptr-&gt;next)) &#123; T* const res=ptr-&gt;data.exchange(nullptr); // 5 free_external_counter(old_head); return std::unique_ptr&lt;T&gt;(res); &#125; // 6 ptr-&gt;release_ref(); &#125; &#125;&#125;; 节点的弹出操作从加载old_head指针开始（1处），接着进入一个无限循环，并且令已加载好的指针上的外部计数器的值自增（2处）。若头节点正巧就是尾节点，即表明队列内没有数据，我们便释放引用（3处），并返回空指针。 否则表明队列中存在数据，因此当前线程试图调用compare_exchange_strong()将其收归己有（4处）。以上调用会对比结构体head和old_head，其成员都包括外部计数器和指针，但均被视作一个整体。无论哪个成员发生了变化而导致不匹配，代码即释放引用（6处）并重新循环。 如果比较-交换操作成功，当前线程就顺利地将节点所属的数据收归己有，故我们随即释放弹出节点的外部计数器（5处），再将数据返回给pop()的调用者。若两个外部计数器都被释放，且内部计数器值变为0，则节点本身可被删除。有几个函数负责处理引用计数 下面是减少引用计数的函数 123456789101112131415161718192021222324252627282930template&lt;typename T&gt;class lock_free_queue&#123;private: struct node &#123; void release_ref() &#123; node_counter old_counter= count.load(std::memory_order_relaxed); node_counter new_counter; do &#123; new_counter=old_counter; //1 --new_counter.internal_count; &#125; //2 while(!count.compare_exchange_strong( old_counter,new_counter, std::memory_order_acquire,std::memory_order_relaxed)); if(!new_counter.internal_count &amp;&amp; !new_counter.external_counters) &#123; //3 delete this; &#125; &#125; &#125;;&#125;; 尽管我们在这里只改动位域成员internal_count(1处)，也必须按原子化方式更新整个计数器结构体。所以更新操作要用比较-交换函数配合循环实现（2处）。 当计数器internal_count完成自减后，如果内外两个计数器的值均为0，就表明调用release_ref()的是最后一个指涉目标节点的指针（代码清单pop （5 6两处）的ptr），我们应当删除节点（3处）。 接下来我们实现增加引用计数的操作 1234567891011121314151617181920template&lt;typename T&gt;class lock_free_queue&#123;private: static void increase_external_count( std::atomic&lt;counted_node_ptr&gt;&amp; counter, counted_node_ptr&amp; old_counter) &#123; counted_node_ptr new_counter; do &#123; new_counter=old_counter; ++new_counter.external_count; &#125; while(!counter.compare_exchange_strong( old_counter,new_counter, std::memory_order_acquire,std::memory_order_relaxed)); old_counter.external_count=new_counter.external_count; &#125;&#125;; increase_external_count()已改成了静态成员函数，需要更新的目标不再是自身固有的成员计数器，而是一个外部计数器，它通过第一个参数传入函数以进行更新。 针对无锁队列的节点释放其外部计数器 12345678910111213141516171819202122232425262728293031template&lt;typename T&gt;class lock_free_queue&#123;private: static void free_external_counter(counted_node_ptr &amp;old_node_ptr) &#123; node* const ptr=old_node_ptr.ptr; int const count_increase=old_node_ptr.external_count-2; node_counter old_counter= ptr-&gt;count.load(std::memory_order_relaxed); node_counter new_counter; do &#123; new_counter=old_counter; //⇽--- 1 --new_counter.external_counters; //⇽--- 2 new_counter.internal_count+=count_increase; &#125; //⇽--- 3 while(!ptr-&gt;count.compare_exchange_strong( old_counter,new_counter, std::memory_order_acquire,std::memory_order_relaxed)); if(!new_counter.internal_count &amp;&amp; !new_counter.external_counters) &#123; //⇽--- 4 delete ptr; &#125; &#125;&#125;; 与free_external_counter()对应的是increase_external_count()函数，该函数对整个计数器结构体仅执行一次compare_exchange_strong()，便合并更新了其中的两个计数器(3处)，这与release_ref()中更新internal_count的自减操作类似。 计数器external_counters则同时自减(1处)。如果这两个值均变为0，就表明目标节点再也没有被指涉，遂可以安全删除（4处）。 为了避免条件竞争，上述更新行为需要整合成单一操作完成，因此需要用比较-交换函数配合循环运行。若两项更新分别独立进行，万一有两个线程同时调用该函数，则它们可能都会认为自己是最后的执行者，所以都删除节点，结果产生未定义行为。 优化虽然上述代码尚可工作，也无条件竞争，但依然存在性能问题。一旦某线程开始执行 push()操作，针对 old_tail.ptr-&gt;data成功完成了compare_exchange_strong()调用(push代码6处)，就没有其他线程可以同时运行push()。若有其他任何线程试图同时压入数据，便始终看不到nullptr，而仅能看到上述线程执行push()传入的新值，导致compare_exchange_strong()调用失败，最后只能重新循环。这实际上是忙等，消耗CPU周期却一事无成，结果形成了实质的锁。第一个push()调用令其他线程发生阻塞，直到执行完毕才解除，所以这段代码不是无锁实现。问题不止这一个。若别的线程被阻塞，则操作系统会提高对互斥持锁的线程的优先级，好让它尽快完成，但本例却无法依此处理，被阻塞的线程将一直消耗CPU周期，等到最初调用push()的线程执行完毕才停止。这个问题带出了下一条妙计：让等待的线程协助正在执行push()的线程，以实现无锁队列。 我们很清楚应该在这种方法中具体做什么：先设定尾节点上的next指针，使之指向一个新的空节点，且必须随即更新tail指针。由于空节点全都等价，因此这里所用空节点的起源并不重要，其创建者既可以是成功压入数据的线程，也可以是等待压入数据的线程。如果将节点内的next指针原子化，代码就能借compare_exchange_strong()设置其值。只要设置好了next指针，便可使用compare_exchange_weak()配合循环设定tail指针，借此令它依然指向原来的尾节点。若tail指针有变，则说明它已同时被别的线程更新过，因此我们停止循环，不再重试。 pop()需要稍微改动才可以载入原子化的next指针 1234567891011121314151617181920212223242526272829303132333435template&lt;typename T&gt;class lock_free_queue&#123;private: struct node &#123; std::atomic&lt;T*&gt; data; std::atomic&lt;node_counter&gt; count; //⇽--- 1 std::atomic&lt;counted_node_ptr&gt; next; &#125;;public: std::unique_ptr&lt;T&gt; pop() &#123; counted_node_ptr old_head=head.load(std::memory_order_relaxed)； for(;;) &#123; increase_external_count(head,old_head); node* const ptr=old_head.ptr; if(ptr==tail.load().ptr) &#123; return std::unique_ptr&lt;T&gt;(); &#125; // ⇽--- 2 counted_node_ptr next=ptr-&gt;next.load(); if(head.compare_exchange_strong(old_head,next)) &#123; T* const res=ptr-&gt;data.exchange(nullptr); free_external_counter(old_head); return std::unique_ptr&lt;T&gt;(res); &#125; ptr-&gt;release_ref(); &#125; &#125;&#125;; 上面的代码进行了简单改动：next指针现在采用了原子变量（1处），并且（2处）的载入操作也成了原子操作。本例使用了默认的memory_order_seq_cst次序，而ptr-&gt;next指针原本属于std::atomic型别，在（2 处）隐式转化成counted_node_ptr型别，这将触发原子化的载入操作，故无须显式调用load()。不过我们还是进行了显式调用，目的是提醒自己，在以后优化时此处应该显式设定内存次序。 新版本的push()相对更复杂，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667template&lt;typename T&gt;class lock_free_queue&#123;private: // ⇽--- 1 void set_new_tail(counted_node_ptr &amp;old_tail, counted_node_ptr const &amp;new_tail) &#123; node* const current_tail_ptr=old_tail.ptr; // ⇽--- 2 while(!tail.compare_exchange_weak(old_tail,new_tail) &amp;&amp; old_tail.ptr==current_tail_ptr); // ⇽--- 3 if(old_tail.ptr==current_tail_ptr) //⇽--- 4 free_external_counter(old_tail); else //⇽--- 5 current_tail_ptr-&gt;release_ref(); &#125;public: void push(T new_value) &#123; std::unique_ptr&lt;T&gt; new_data(new T(new_value)); counted_node_ptr new_next; new_next.ptr=new node; new_next.external_count=1; counted_node_ptr old_tail=tail.load(); for(;;) &#123; increase_external_count(tail,old_tail); T* old_data=nullptr; //⇽--- 6 if(old_tail.ptr-&gt;data.compare_exchange_strong( old_data,new_data.get())) &#123; counted_node_ptr old_next=&#123;0&#125;; //⇽--- 7 if(!old_tail.ptr-&gt;next.compare_exchange_strong( old_next,new_next)) &#123; //⇽--- 8 delete new_next.ptr; new_next=old_next; // ⇽--- 9 &#125; set_new_tail(old_tail, new_next); new_data.release(); break; &#125; else // ⇽--- 10 &#123; counted_node_ptr old_next=&#123;0&#125;; // ⇽--- 11 if(old_tail.ptr-&gt;next.compare_exchange_strong( old_next,new_next)) &#123; // ⇽--- 12 old_next=new_next; // ⇽--- 13 new_next.ptr=new node; &#125; // ⇽--- 14 set_new_tail(old_tail, old_next); &#125; &#125; &#125;&#125;; 由于我们确实想在(6处)设置data指针，而且还需接受另一线程的协助，因此引入了else分支以处理该情形(10处)。上述push()的新版本先在(6处)处设置好节点内的data指针，然后通过compare_exchange_strong()更新next指针(7处)，从而避免了循环。 若交换操作失败，我们便知道另一线程同时抢先设定了next指针，遂无须保留函数中最初分配的新节点，可以将它删除（8处）。 虽然next指针是由别的线程设定的，但代码依然持有其值，留待后面更新tail指针（9处）。更新tail指针的代码被提取出来，写成set_new_tail()函数（1处）。它通过compare_exchange_weak()配合循环来更新tail指针（2处）。 如果其他线程试图通过push()压入新节点，计数器external_count就会发生变化，而上述新函数正是为了防止错失这一变化。但我们也要注意，若另一线程成功更新了tail指针，其值便不得再次改变。若当前线程重复更新tail指针，便会导致控制流程在队列内部不断循环，这种做法完全错误。 相应地，如果比较-交换操作失败，所载入的ptr指针也需要保持不变。在脱离循环时，假如ptr指针的原值和新值保持一致（3处）就说明tail指针的值肯定已经设置好，原有的外部计数器则需要释放（4处）。若ptr指针前后有所变化，则另一线程将释放计数器，而当前线程要释放它持有的唯一一个tail指针（5处）。 这里，若多个线程同时调用push()，那么只有一个线程能成功地在循环中设置data指针，失败的线程则转去协助成功的线程完成更新。当前线程一进入push()就分配了一个新节点，我们先更新next指针，使之指向该节点（11处）。假定操作成功，该节点就充当新的尾节点⑫，而我们还需另行分配一个新节点，为下一个压入队列的数据预先做好准备⑬。接着，代码尝试调用set_new_tail()以设置尾节点（14处），再重新循环。 官方案例的隐患我们基于上面的案例执行下面的测试代码，发现程序崩溃 12345678910111213141516171819202122232425262728void TestCrushQue() &#123; crush_que&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT*10000; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT*10000;) &#123; auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); t1.join(); t2.join();&#125; 我们看到崩溃在底层代码的原子变量交换这里 我们按照调用堆栈往上查找，发现是head和tail的ptr为空导致 解决这个问题比较简单，我们在队列的构造函数中添加head和tail的初始化即可。 12345678memoryleak_que() &#123; counted_node_ptr new_next; new_next.ptr = new node(); new_next.external_count = 1; tail.store(new_next); head.store(new_next); std::cout &lt;&lt; &quot;new_next.ptr is &quot; &lt;&lt; new_next.ptr &lt;&lt; std::endl;&#125; 我们也需要在析构函数里回收头尾节点，基本思路是依次出队，但是因为最后一个节点为tail，当head和tail相等时则停止回收，所以我们要额外回收头部节点(此时头部和尾部节点重合) 12345~memoryleak_que() &#123; while (pop()); auto head_counted_node = head.load(); delete head_counted_node.ptr;&#125; 为了测试内存泄漏，我们在栈中添加一个静态成员变量 1234567class memoryleak_que&#123;public:static std::atomic&lt;int&gt; destruct_count;&#125;;template&lt;typename T&gt;std::atomic&lt;int&gt; lock_free_queue&lt;T&gt;::destruct_count = 0; 我们在release_ref和free_external_counter中删除指针时增加这个静态成员变量的数量，最后统计删除的数量和我们开辟的数量是否相等 12345678910111213141516171819202122232425void release_ref()&#123; std::cout &lt;&lt; &quot;call release ref &quot; &lt;&lt; std::endl; node_counter old_counter = count.load(std::memory_order_relaxed); node_counter new_counter; do &#123; new_counter = old_counter; //1 --new_counter.internal_count; &#125; //2 while (!count.compare_exchange_strong( old_counter, new_counter, std::memory_order_acquire, std::memory_order_relaxed)); if (!new_counter.internal_count &amp;&amp; !new_counter.external_counters) &#123; //3 delete this; std::cout &lt;&lt; &quot;release_ref delete success&quot; &lt;&lt; std::endl; destruct_count.fetch_add(1); &#125;&#125; 123456789101112131415161718192021222324252627282930static void free_external_counter(counted_node_ptr&amp; old_node_ptr)&#123; std::cout &lt;&lt; &quot;call free_external_counter &quot; &lt;&lt; std::endl; node* const ptr = old_node_ptr.ptr; int const count_increase = old_node_ptr.external_count - 2; node_counter old_counter = ptr-&gt;count.load(std::memory_order_relaxed); node_counter new_counter; do &#123; new_counter = old_counter; //⇽--- 1 --new_counter.external_counters; //⇽--- 2 new_counter.internal_count += count_increase; &#125; //⇽--- 3 while (!ptr-&gt;count.compare_exchange_strong( old_counter, new_counter, std::memory_order_acquire, std::memory_order_relaxed)); if (!new_counter.internal_count &amp;&amp; !new_counter.external_counters) &#123; //⇽--- 4 destruct_count.fetch_add(1); std::cout &lt;&lt; &quot;free_external_counter delete success&quot; &lt;&lt; std::endl; delete ptr; &#125;&#125; 测试并发执行两个线程，最后assert断言删除节点数和开辟的节点数相等 123456789101112131415161718192021222324252627282930void TestLeakQue() &#123; memoryleak_que&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT ; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT ;) &#123; auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); t1.join(); t2.join(); assert(que.destruct_count == TESTCOUNT );&#125; 测试触发断言，说明存在内存泄漏。 经过调试我们发现其实是在pop头部节点时判断head和tail相等，直接返回空指针，但是引用计数没有做减少。这和栈的方式不同，栈的pop判断条件如果head节点的ptr指向空地址，说明这个节点为无效节点无需pop直接返回空指针，当有新数据插入时在头部插入新节点并更新head为新节点。这么做保证了即使最后那个无效节点引用计数怎么增加都无所谓。 但是队列不行，队列的操作方式是先开辟了head和tail节点，这两个节点最开始是无效的，但是当插入数据时，就将head的ptr指向的数据data更新为新的数据即可。这样head之前和tail相等时pop增加的引用计数如果不合理减少就会造成问题。 解决的思路也比较简单，如果head和tail相等说明为空队列，空队列减少该节点内部引用计数即可。 123456789101112131415161718192021222324 std::unique_ptr&lt;T&gt; pop()&#123; counted_node_ptr old_head = head.load(std::memory_order_relaxed); for (;;) &#123; increase_external_count(head, old_head); node* const ptr = old_head.ptr; if (ptr == tail.load().ptr) &#123; //头尾相等说明队列为空，要减少内部引用计数 ptr-&gt;release_ref(); return std::unique_ptr&lt;T&gt;(); &#125; // ⇽--- 2 counted_node_ptr next = ptr-&gt;next.load(); if (head.compare_exchange_strong(old_head, next)) &#123; T* const res = ptr-&gt;data.exchange(nullptr); free_external_counter(old_head); return std::unique_ptr&lt;T&gt;(res); &#125; ptr-&gt;release_ref(); &#125;&#125; 最后我们测试多线程pop和push的情况，目前稳定回收节点并且并发安全 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void TestLockFreeQueMultiPushPop() &#123; lock_free_queue&lt;int&gt; que; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT * 100; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t4([&amp;]() &#123; for (int i = TESTCOUNT*100; i &lt; TESTCOUNT * 200; i++) &#123; que.push(i); std::cout &lt;&lt; &quot;push data is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT * 100;) &#123; auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); std::thread t3([&amp;]() &#123; for (int i = 0; i &lt; TESTCOUNT * 100;) &#123; auto p = que.pop(); if (p == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; std::cout &lt;&lt; &quot;pop data is &quot; &lt;&lt; *p &lt;&lt; std::endl; &#125; &#125;); t1.join(); t2.join(); t3.join(); t4.join(); assert(que.destruct_count == TESTCOUNT * 200);&#125; 总结本文介绍了无锁队列的实现，利用了引用计数的思想，实现了并发安全的无锁队列。 源码链接： https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day18-LockFreeQue 视频链接： https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用内存模型优化无锁栈","date":"2024-01-01T05:36:24.000Z","path":"2024/01/01/concpp21/","text":"简介前文我们通过引用计数实现了无锁并发的栈结构，但是对于原子变量的读，写以及读改写操作默认采用的是memory_order_seq_cst,memory_order_seq_cst为全局顺序模型，也就是所有线程看到的执行顺序一致，但是这种模型对性能消耗较大，本文在之前实现的无锁栈的基础上介绍如何通过更为宽松的模型提升性能。先带着大家复习一下内存模型相关知识 release-acquire同步我们在之前的文章介绍了6中内存顺序，其中我们可以通过release和acquire的方式实现同步的效果，现在带着大家复习一下： 线程A执行store操作，采用memory_order_release顺序模型。线程B执行load操作采用memory_order_acquire顺序模型。如果线程B的load操作读取到A操作的store操作的数值，我们称线程a的store操作 synchronizes-with(同步) 线程b的load操作 happens-before先行因为a-&gt;store 同步于 b-&gt;load， 则 a-&gt;store 先行于 b-&gt;load。 只要同步就能推出先行，所谓先行就是逻辑执行的顺序，一定是a-&gt;store 先于 b-&gt;load 先行还包括一种情况，sequenced-before(顺序执行)， 所谓顺序执行就是单线程中执行的顺序为从上到下的顺序, 比如 1234int func()&#123; int a = 1008; //1 int b = 1024; //2&#125; 单线程角度1先于2执行(1 sequenced before 2)，也可推导出1先行于2. 先行具有传递性 1 happens-before 2， 2 happens-before 3, 则1 happens-before 3 注意先行是C++ 语意层面的概念， 指令实际的执行顺序可能是先2后1，取决于编译器。 但是我们可以通过内存顺序进行约束达到指令编排让1先于2的目的。如release内存序能保证其写操作之前的指令不会排在其后。acquire内存序能保证其读操作之前写入的指令不会排在其之后，也能保证其之后的指令不会排在读之前。所以release和acquire形成同步后类似于屏障，当然C++ 也有类似于的原语std::atomic_thread_fence(栅栏)。 写个代码复习一下 123456789101112131415161718void TestReleaseSeq() &#123; int data = 0; std::atomic&lt;int&gt; flag = 0; std::thread t1([&amp;]() &#123; data = 42; //1 flag.store(1, std::memory_order_release); //2 &#125;); std::thread t2([&amp;]() &#123; //3 while (!flag.load(std::memory_order_acquire)); //4 assert(data == 42); &#125;); t1.join(); t2.join();&#125; 我们从两方面解读代码： 1 指令编排角度， 2处使用了release内存序，保证1 会排在 2 之前。 3采用了acquire内存序，保证4排在3之后，且如果3能读到2的写入值，则保证指令1已经先于3执行完。因为while重试的机制，保证2同步于3，即2先于3执行，有因为1先于2执行，而3先于4执行，所以得出1先于4执行，那么4处断言正确不会崩溃。 2 从C++先行语义的角度，单线程t1内，1先行于2, 单线程t2内3先行于4, 而t1第2处代码采用release内存序，t2第3处代码采用acquire内存序列，2同步于3, 则2 先行于 3. 因为先行的传递性，1 sequenced-before 2, 2 happens-before 3, 3 sequenced-before 4, 则1 happens-before 4. 释放序列的扩展这段文字摘录于C++并发编程一书 如果存储操作的标记是memory_order_release、memory_order_acq_rel或memory_order_seq_cst，而载入操作则以memory_order_consume、memory_order_acquire或memory_order_seq_cst标记，这些操作前后相扣成链，每次载入的值都源自前面的存储操作，那么该操作链由一个释放序列组成。若最后的载入操作服从内存次序memory_order_acquire或memory_order_seq_cst，则最初的存储操作与它构成同步关系。但如果该载入操作服从的内存次序是memory_order_consume，那么两者构成前序依赖关系。操作链中，每个“读-改-写”操作都可选用任意内存次序，甚至也能选用memory_order_relaxed次序。 我们对上述阐述总结为下面的理解 release-sequnece的概念如下： 针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. 如果这一连串操作是由 1 同一线程上的写操作 2 或者任意线程上的 read-modify-write(可以是任意内存顺序) 操作 这两种构成的, 则称这一连串的操作为以 release 操作 A 为首的 release sequence. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序. 而同步的概念是： 一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作 所以release-sequence不一定构成同步，只有acquire到release的值才算作同步。 我们看下面的例子,该例子选取自C++ 并发编程中，我对其稍作修改以保证可以正常运行。 我们先定义了三个全局变量，分别是queue_data表示入队的数据，count表示入队的数量。store_finish表示存储完成。 123std::vector&lt;int&gt; queue_data;std::atomic&lt;int&gt; count;std::atomic&lt;bool&gt; store_finish = false; 我们实现入队逻辑，这个逻辑以后会有一个线程独立执行 123456789101112void populate_queue()&#123; unsigned const number_of_items = 20; queue_data.clear(); for (unsigned i = 0; i &lt; number_of_items; ++i) &#123; queue_data.push_back(i); &#125; // 1 最初的存储操作 count.store(number_of_items, std::memory_order_release); store_finish.store(true, std::memory_order_relaxed);&#125; 上述函数将20个元素从0到19依次入队，然后修改count值为20，使用release内存顺序，并且将完成标记设置为true. 然后我们实现消费函数 1234567891011121314151617void consume_queue_items()&#123; while (true) &#123; //2等待存储完成 while (!store_finish.load(std::memory_order_relaxed)); int item_index; //3 读—改—写”操作 if ((item_index = count.fetch_sub(1, std::memory_order_acquire)) &lt;= 0) &#123; return; &#125; //4 从内部容器queue_data 读取数据项是安全行为 std::cout &lt;&lt; &quot;queue_data is &quot; &lt;&lt; queue_data[item_index-1] &lt;&lt; std::endl; &#125;&#125; 上述函数，我们在2处等待存储完成，在3处读改写修改count的值，采用的是acquire内存顺序，然后我们从队列中根据item_index读取数据。 假设一个线程t1用来执行populate_queue，一个线程t2用来执行consume_queue_items。 那么因为release-acquire的关系，我们可以推断出 t1 synchronizes-with t2. 那我们用三个线程并行操作会怎样呢？ 12345678void TestReleaseSeq2() &#123; std::thread a(populate_queue); std::thread b(consume_queue_items); std::thread c(consume_queue_items); a.join(); b.join(); c.join();&#125; 可以看到输出如下 虽然控制台打印混乱，但是我们可以看到消费者线程t2和t3并没有打印重复的数据，说明他们互斥访问count,每个线程取到的count不一样进而访问queue_data中的不同数据。 假设只有一个线程a和线程b,我们知道一个生产者a和一个消费者b构成了同步关系，没有问题，如果增加了消费者线程c，b和c中都有fetch_sub这种读-改-写操作，采用的都是acquire内存顺序，但从线程b和c的角度并不能构成同步，那是不是就意味着b和c可能获取到count的值相同？ 答案是否定的，单从线程角度b和c并不能构成同步，但是b和c必然有一个线程先执行一个线程后执行fetch_sub(原子变量的操作任何顺序模型都能保证操作的原子性)。假设b先执行，和a构成release-sequence关系，b读取到a执行的count strore的结果， b处于以a线程的release为首的释放序列中，则b的store操作会和c的读-改-写(fetch操作)构成同步(c 采用的是acquire). C++并发编程一书中对类似的代码也做了同样的解释。 如下图是书中给出的图示，实线表示先行关系，虚线标识释放序列 那我们可以这么简化上面的分析结论 1 a线程和b线程构成release-sequence的释放序列 2 即使b线程和c线程不构成同步，但是b线程的读改写操作处于release-sequence中，且c线程采用acquire方式读改写，则b的读改写和c线程的读改写构成同步， 以a线程的release为首的sequence序列和c线程的读改写构成同步。 3 这里要强调一点， 如果a relese-sequence b， a和b不一定构成同步，但是b sychronizes with c， 则a synchronizes with c. 简单来说处于relase序列中的任意读改写操作和其他的线程构成同步，那么我们就能得出relese-sequence为首的操作和其他线程同步。 优化无锁栈我们优化无锁栈先从push操作下手，我们要考虑的是如果有数据入栈，那么pop时要读取最新入栈的数据。所以我们要让push操作同步给pop操作，想到的办法很简单，push对head的修改采用release内存序列，pop对head的读改写采用acquire内存序列。 如果未有元素入栈，多个线程pop并不会产生问题，根据head内部的ptr指向为空判断空栈直接返回空指针。 如果此时已经有一个元素在栈中，多个线程并发pop，执行读改写操作，这些线程本来是无法同步的，但是最先pop的线程会和push线程构成同步关系，且形成release-sequence。那之后的线程pop就会和第一个pop的线程的写操作形成同步。 简单总结上面的含义： 1 因为要保证pop操作时节点的数据是有效的。push和pop要构成同步关系，push 采用release内存序修改head，pop 采用acquire内存序修改head 2 第一个pop的线程的写操作和之后的pop线程读操作要构成同步关系 实现push函数 12345678void push(T const&amp; data) &#123; counted_node_ptr new_node; new_node.ptr = new count_node(data); new_node.external_count = 1; new_node.ptr-&gt;next = head.load(); while (!head.compare_exchange_weak(new_node.ptr-&gt;next, new_node, memory_order::memory_order_release, memory_order::memory_order_relaxed));&#125; 对于head的修改，我们采用compare_exchange_weak操作。如果修改成功则使用memory_order_release内存顺序，否则就用memory_order_relaxed内存顺序。因为失败会进行重试，所以什么内存序都可以。 接下来实现pop 12345678910111213std::shared_ptr&lt;T&gt; pop() &#123; counted_node_ptr old_head = head.load(); for (;;) &#123; increase_head_count(old_head); count_node* const ptr = old_head.ptr; //1 判断为空责直接返回 if (!ptr) &#123; return std::shared_ptr&lt;T&gt;(); &#125; //省略数据出栈和头部更新操作.... //.... &#125;&#125; 在pop中我们先将head加载出来，然后利用increase_head_count对old_head外部引用技术+1. 我们先讨论increase_head_count的实现,因为我们在increase_head_count的时候很可能其他的线程执行push操作。 因为increae_head_count和push操作都是对head的读改写操作，我们知道无论采用何种内存模型，原子变量的读改写都能保证原子数据的完整性。 因为pop操作比如第1处代码，以至于后面的操作会用到ptr-&gt;data数据，所以必须要让push操作和pop操作达到同步关系，才能保证push的data数据对pop操作可见，increase_count用的是acquire模型，而push用的是release模型，保证push先行于pop，这样pop逻辑中的data就是有效的。 12345678910111213//增加头部节点引用数量void increase_head_count(counted_node_ptr&amp; old_counter) &#123; counted_node_ptr new_counter; do &#123; new_counter = old_counter; ++new_counter.external_count; &#125;//7 循环判断保证head和old_counter想等时做更新,多线程情况保证引用计数原子递增。 while (!head.compare_exchange_strong(old_counter, new_counter, std::memory_order_acquire, std::memory_order_relaxed)); //8 走到此处说明head的external_count已经被更新了 old_counter.external_count = new_counter.external_count;&#125; 接下来我们实现省略的部分，省略的部分要根据head和old_head的值是否想等做出不同的逻辑，上一篇的逻辑是： 1 如果head和old_head相等则说明本线程抢占了head并且需要对外部引用计数-2，得出其他线程增加的引用计数，如果这个引用计数为内部的引用计数(可为负数)的负数则说明其他线程已经不再占有head，已经做了内部引用计数的更新，本线程回收资源即可。 2 如果head和old_head不相等则说明head已经被更改，或者自己获取的old_head是旧的(两个线程并发执行pop, 该线程是引用计数不准确的那个或者该线程读取的head已经被弹出)，所以只需减少内部引用计数即可。 所以之后的逻辑是这样的 123456789101112131415161718192021//2 本线程如果抢先完成head的更新if (head.compare_exchange_strong(old_head, ptr-&gt;next)) &#123; //返回头部数据 std::shared_ptr&lt;T&gt; res; //交换数据 res.swap(ptr-&gt;data); //3 减少外部引用计数，先统计到目前为止增加了多少外部引用 int const count_increase = old_head.external_count - 2; //4 将内部引用计数添加 if (ptr-&gt;internal_count.fetch_add(count_increase) == -count_increase) &#123; delete ptr; &#125; return res;&#125; else if (ptr-&gt;internal_count.fetch_sub(1) == 1) &#123;//5 //如果当前线程操作的head节点已经被别的线程更新，则减少内部引用计数 //当前线程减少内部引用计数，返回之前值为1说明指针仅被当前线程引用 delete ptr;&#125; 对于无锁编程，我的心得有两点 1 对于一个原子变量M，其释放序列中的读改写操作无论采用何种模型都能读取M的最新值。2 内存顺序模型用来保证数据在多个线程的可见顺序。 例如因为本线程在2处的比较交换要获取到其他线程修改的head的最新情况，其他线程要么是push操作，要么是pop操作。 1 经过前面的分析，线程a push 操作同步于b线程和c线程的pop中的increase_count操作，那么b线程2处的compare_exchange_strong和c线程2处的compare_exchange_strong都能读取到push操作写入data值。 2 那么b线程2处的compare_exchange_strong和c线程2处的compare_exchange_strong并不构成同步，但他们一定处于释放序列中，因为原子操作读改写保证了原子性。 绘制运行图，实线表示先行，虚线表示释放序列。 所以综上所述2处比较交换采用relaxed即可，大家不放心可以采用acquire方式。 接下来考虑compare_exchange_strong比较成功和失败之后各自内部的逻辑，因为我们要保证ptr的data在被删除之前swap到res里。 1 如果是走入2处的逻辑进入4处代码删除ptr，那么需要保证swap操作先于fetch_add之后的delete操作，所以fetch_add采用release模型。 2 对于5处的fetch_sub操作，内部如果满足删除delete则删除ptr指针，要保证2处逻辑内的swap操作先于delete操作。所以5处的fetch_sub要采用acquire操作。 整理后的pop操作如下 1234567891011121314151617181920212223242526272829std::shared_ptr&lt;T&gt; pop() &#123; counted_node_ptr old_head = head.load(); for (;;) &#123; increase_head_count(old_head); count_node* const ptr = old_head.ptr; //1 判断为空责直接返回 if (!ptr) &#123; return std::shared_ptr&lt;T&gt;(); &#125; //2 本线程如果抢先完成head的更新 if (head.compare_exchange_strong(old_head, ptr-&gt;next, std::memory_order_relaxed)) &#123; //返回头部数据 std::shared_ptr&lt;T&gt; res; //交换数据 res.swap(ptr-&gt;data); //3 减少外部引用计数，先统计到目前为止增加了多少外部引用 int const count_increase = old_head.external_count - 2; //4 将内部引用计数添加 if (ptr-&gt;internal_count.fetch_add(count_increase, std::memory_order_release) == -count_increase) &#123; delete ptr; &#125; return res; &#125; else if (ptr-&gt;internal_count.fetch_sub(1, std::memory_order_acquire) == 1) &#123; //5 //如果当前线程操作的head节点已经被别的线程更新，则减少内部引用计数 delete ptr; &#125; &#125;&#125; 但是并发编程的作者认为5处采用acquire内存序过于严格，可以采用relaxed方式，只要在条件满足后删除ptr时在约束内存顺序即可，为了保证swap操作先执行完，则需在delete ptr 之前用acquire内存序约束一下即可，在delete ptr 上面添加 head.load(std::memory_order_acquire)即可和前面的释放序列构成同步关系。 所以我们最后优化的pop函数为 12345678910111213141516171819202122232425262728293031std::shared_ptr&lt;T&gt; pop() &#123; counted_node_ptr old_head = head.load(); for (;;) &#123; increase_head_count(old_head); count_node* const ptr = old_head.ptr; //1 判断为空责直接返回 if (!ptr) &#123; return std::shared_ptr&lt;T&gt;(); &#125; //2 本线程如果抢先完成head的更新 if (head.compare_exchange_strong(old_head, ptr-&gt;next, std::memory_order_relaxed)) &#123; //返回头部数据 std::shared_ptr&lt;T&gt; res; //交换数据 res.swap(ptr-&gt;data); //3 减少外部引用计数，先统计到目前为止增加了多少外部引用 int const count_increase = old_head.external_count - 2; //4 将内部引用计数添加 if (ptr-&gt;internal_count.fetch_add(count_increase, std::memory_order_release) == -count_increase) &#123; delete ptr; &#125; return res; &#125; else if (ptr-&gt;internal_count.fetch_add(-1, std::memory_order_acquire) == 1) &#123; //5 //如果当前线程操作的head节点已经被别的线程更新，则减少内部引用计数 //当前线程减少内部引用计数，返回之前值为1说明指针仅被当前线程引用 ptr-&gt;internal_count.load(std::memory_order_acquire); delete ptr; &#125; &#125;&#125; 测试为了保证测试效果，我们还是启动三个线程, t1用来向栈中写入20000个数据，t2和t3分别并发从栈中读取10000个数据放入set中，最后我们看到set的大小为20000个即为正常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void TestRefCountStack() &#123; ref_count_stack&lt;int&gt; ref_count_stack; std::set&lt;int&gt; rmv_set; std::mutex set_mtx; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; 20000; i++) &#123; ref_count_stack.push(i); std::cout &lt;&lt; &quot;push data &quot; &lt;&lt; i &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = ref_count_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); std::thread t3([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = ref_count_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); t1.join(); t2.join(); t3.join(); assert(rmv_set.size() == 20000);&#125; 我们在assert处打个断点，可以看到集合大小确实为两万个，而且不存在重复元素，不存在缺失的元素。 总结源码链接：https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day17-LockFreeStack 视频链接：https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用引用计数实现线程安全的无锁栈","date":"2023-12-24T01:23:42.000Z","path":"2023/12/24/concpp20/","text":"简介前文我们通过风险指针的方式实现了无锁栈，但是也提出了一些弊端，比如每次pop都要从风险数组中选择一个空闲的节点作为标记。其次删除节点前要遍历风险数组对比节点是否被风险指针所指涉，如果被风险指针指涉则需放入待删列表。最后pop结束时也要回收待删列表中的节点，还要依次将待删列表中的节点和风险数组对比，如果未被风险指针指涉则需删除，否则跳过。 但是这种方式多次遍历风险数组，会有性能损耗，我们提出一种新的解决方式，利用引用计数实现无锁并发的栈。 引用计数在C++并发编程一书中提出了两个计数，一个外部计数，一个内部计数，二者加起来就是有效的引用计数，很多读者对此费解，为何不用一个引用计数维护呢？那本文就是带着大家如何一步一步去实现并说明单引用计数的不可行性。 那我们先定义一个栈结构，以及它的内部节点结构 12345678910111213141516171819202122232425262728template&lt;typename T&gt;class single_ref_stack &#123;public: single_ref_stack():head(nullptr) &#123; &#125; ~single_ref_stack() &#123; //循环出栈 while (pop()); &#125;private: struct ref_node &#123; //1 数据域智能指针 std::shared_ptr&lt;T&gt; _data; //2 引用计数 std::atomic&lt;int&gt; _ref_count; //3 下一个节点 ref_node* _next; ref_node(T const&amp; data_) : _data(std::make_shared&lt;T&gt;(data_)), _ref_count(1), _next(nullptr) &#123;&#125; &#125;; //头部节点 std::atomic&lt;ref_node*&gt; head;&#125;; 1 single_ref_stack为我们定义的栈结构。内部包含一个head节点，head节点为一个ref_node*类型的原子变量。 2 single_ref_stack的构造函数将head设置为nullptr，析构函数循环pop直到栈为空为止。pop我们之后再实现。 3 定义ref_node结构作为每个栈存储的元素。内部包含_data表示数据域， int类型的原子变量表示引用计数。_next表示下一个节点指针。ref_node的构造函数接收一个T类型的通用数据类型，利用这个参数构造自己的数据域。 接下来我们实现push操作 12345void push(T const&amp; data) &#123; auto new_node = new ref_node(data); new_node-&gt;next = head.load(); while (!head.compare_exchange_weak(new_node-&gt;next, new_node));&#125; push 操作很简单，创建一个ref_node类型的指针对象new_node，将new_node的next指针指向现在的头节点，然后不断地重试(防止其他线程修改head后导致head变化不一致),直到将head更新为new_node. 接下来我们实现pop 12345678910111213141516171819202122232425262728293031323334353637std::shared_ptr&lt;T&gt; pop() &#123; ref_node* old_head = head.load(); for (;;) &#123; if (!old_head) &#123; return std::shared_ptr&lt;T&gt;(); &#125; //1 只要执行pop就对引用计数+1 ++(old_head-&gt;_ref_count); //2 比较head和old_head想等则交换否则说明head已经被其他线程更新 if (head.compare_exchange_strong(old_head, old_head-&gt;_next)) &#123; auto cur_count = old_head-&gt;_ref_count.load(); auto new_count; //3 循环重试保证引用计数安全更新 do &#123; //4 减去本线程增加的1次和初始的1次 new_count = cur_count - 2; &#125; while (!old_head-&gt;_ref_count.compare_exchange_weak(cur_count, new_count)); //返回头部数据 std::shared_ptr&lt;T&gt; res; //5 交换数据 res.swap(old_head-&gt;_data); //6 if (old_head-&gt;_ref_count == 0) &#123; delete old_head; &#125; return res; &#125; else &#123; //7 if (old_head-&gt;_ref_count.fetch_sub(1) == 1) &#123; delete old_head; &#125; &#125; &#125;&#125; 1 上面的代码我们先判断old_head是否为空，如果为空则说明栈为空。 2 然后代码1处 对引用计数+1, 因为是原子变量所以可以保证线程安全。 3 然后代码2处 比较head和old_head是否相等，如果相等则将head更新为old_head的next指向的数据。简而言之就是将head更新为新的栈顶元素。因为存在多个线程并发执行2处代码的情况，导致只有一个线程交换成功，交换成功的线程就承担起返回数据的任务。 并且在4处减少2个引用计数(减去初始的1个加上自己pop开始增加的那一个)，并且在3处循环重试更新引用计数。在6处判断引用计数如果变为0则删除指针。 交换失败的线程是抢占失败的线程，则执行7处代码需减少1次引用计数(因为该线程进入pop时已经增加了1次引用计数)。fetch_sub会将原子变量的数值减1，然后返回减少之前的数值。所以我们判断如果之前的数值为1则说明该线程是最后引用此指针的线程，可以将指针删除。 我们观察上述pop函数，存在严重漏洞 如果线程1和线程2都准备执行1处代码，但是线程2抢先执行，并且更新引用计数_ref_count变为0，则执行删除old_head的操作，此时线程1刚好执行1处代码，引发崩溃。 引发崩溃的原因我们知道了就是old_head被删除了，那我们要做的就是将引用计数提出来，不放在指针里，和指针解耦。 我们将原来的节点结构拆成两个 123456789101112131415161718struct node &#123; //1 数据域智能指针 std::shared_ptr&lt;T&gt; _data; //2 下一个节点 ref_node _next; node(T const&amp; data_) : _data(std::make_shared&lt;T&gt;(data_)) &#123;&#125;&#125;;struct ref_node &#123; // 引用计数 std::atomic&lt;int&gt; _ref_count; node* _node_ptr; ref_node( T const &amp; data_):_node_ptr(new node(data_)), _ref_count(1)&#123;&#125; ref_node():_node_ptr(nullptr),_ref_count(0)&#123;&#125;&#125;; ref_node表示栈存储的节点结构，包括引用计数和节点的指针。而node为实际的节点结构，包括节点的数据域以及下一个节点的地址。 那我们的single_ref_stack结构管理的head是指针类型好还是副本类型好呢？ 我们可以假设head存储的是指针类型 12//头部节点std::atomic&lt;ref_node*&gt; head; 那么pop逻辑就要改为 1234567891011121314151617181920212223242526272829303132333435363738394041424344std::shared_ptr&lt;T&gt; pop() &#123; //0 处 ref_node* old_head = head.load(); for (;;) &#123; //1 只要执行pop就对引用计数+1并更新到head中 ref_node* new_head; do &#123; new_head = old_head; //7 处 new_head-&gt;_ref_count += 1; &#125; while (!head.compare_exchange_weak(old_head, new_head)); //4 old_head = new_head; auto* node_ptr = old_head-&gt;_node_ptr; if (node_ptr == nullptr) &#123; return std::shared_ptr&lt;T&gt;(); &#125; //2 比较head和old_head想等则交换否则说明head已经被其他线程更新 if (head.compare_exchange_strong(old_head, node_ptr-&gt;_next)) &#123; //要返回的值 std::shared_ptr&lt;T&gt; res; //交换智能指针 //5 处 res.swap(node_ptr-&gt;_data); //6 增加的数量 int increase_count = old_head-&gt;_ref_count.fetch_sub(2); //3 处判断仅有当前线程持有指针则删除 if (increase_count == 2) &#123; delete node_ptr; &#125; return res; &#125;else &#123; if (old_head-&gt;_ref_count.fetch_sub(1) == 1) &#123; delete node_ptr; &#125; &#125; &#125;&#125; 解释一下上面的逻辑： 在1处head调用比较交换和old_head做比较，比较分为两个方面，一个是引用计数一个是node*的值。 那我们假设线程1和线程2依次通过了比较交换逻辑(假设线程1先于线程2)，那么假设线程1在4处看到的old_head的引用计数为2，线程2在4处看到old_head的引用计数为3. 而head最后被更新的引用计数为3.所以在2处的判断逻辑里，线程2会进入if的逻辑，线程1会进入else的逻辑,最后会有一个线程回收node_ptr节点，这么看来是正常的。 但是我们仔细分析，看上面的代码有很大漏洞 1 假设线程1比线程2先执行，线程1在2处执行比较交换后head会被更新为新的值。线程2执行比较交换操作会失败，则进入else处理, old_head会被更新为新的head值， 此时old_head的引用计数为1则会被线程2误删，因为线程2此时读到的old_head正是新的head指向的数据。而且没有弹出和修改head的值。这样其他线程pop头部元素时会崩溃。 2 线程1和线程2都执行完0处代码，二者读取的old_head值相同。假设线程1比线程2先执行，线程2因未抢占到cpu的时间片停顿在1处，线程1按次序依次执行最后执行到3处将node_ptr删除。而且现在的head已经指向了新的栈顶元素即old_head的下一个元素。此时线程2抢占到时间片，执行1处代码又将old_head更新为head当前值了，只不过引用计数加了1变为2，但是指向的是下一个节点，所以这种情况下进入仍会进入if条件，对新的old_head节点删除。这种情况倒是正常。 3 还是假设线程1和线程2都执行完0处代码，线程1抢先执行完5处。准备执行6处时，线程2抢占CPU执行了7处代码，尽管会被while比较old_head和head不同而重试，进而更新old_head。但是线程2的do逻辑中第一次的old_head和线程1的old_head指向的是同一个，线程2修改了old_head中的引用计数，导致线程1执行6处代码时不会进入if逻辑。又因为线程2在2处之后while会不断重试，线程2的head已经和old_head指向不同了，导致线程2也不会回收old_head内部节点指向的数据，导致内存泄漏。 这就告诉我们当我们设计pop逻辑的时候尽量不要存储指针，存储指针意味着存在多个线程操作同一块内存的情况。 所以我们得出以下结论 1 head的类型修改为ref_node类型而不是指针。 2 现有的引用保留，我们用其表示增加的引用计数，该引用计数可以用原子类型，也可以不用原子类型。为简化和节省效率我们用普通int类型。 3 新增一个表示减少的引用计数，因为这个表示减少的引用计数要在多个线程中同步，并且要保证安全性，那我们将其放入node类里, 因为node类的指针被存储在栈的节点中，所以可以达到多个线程修改这个减少的引用计数的效果。 4 一个节点能否被回收取决于整体的引用计数是否为0。 改进引用节点按照上面的推论，我们新增_dec_count表示减少的引用计数，放在node结构里。 123456789101112131415161718192021struct ref_node;struct node &#123; //1 数据域智能指针 std::shared_ptr&lt;T&gt; _data; //2 下一个节点 ref_node _next; node(T const&amp; data_) : _data(std::make_shared&lt;T&gt;(data_)) &#123;&#125; //减少的数量 std::atomic&lt;int&gt; _dec_count;&#125;;struct ref_node &#123; // 引用计数 int _ref_count; node* _node_ptr; ref_node( T const &amp; data_):_node_ptr(new node(data_)), _ref_count(1)&#123;&#125; ref_node():_node_ptr(nullptr),_ref_count(0)&#123;&#125;&#125;; 然后将栈中的head结构变为ref_node类型的原子变量。 12//头部节点std::atomic&lt;ref_node&gt; head; 我们重新实现push 12345void push(T const&amp; data) &#123; auto new_node = ref_node(data); new_node._node_ptr-&gt;_next = head.load(); while (!head.compare_exchange_weak(new_node._node_ptr-&gt;_next, new_node));&#125; 我们重新实现pop 12345678910111213141516171819202122232425262728293031323334353637383940414243std::shared_ptr&lt;T&gt; pop() &#123; ref_node old_head = head.load(); for (;;) &#123; //1 只要执行pop就对引用计数+1并更新到head中 ref_node new_head; //2 do &#123; new_head = old_head; new_head._ref_count += 1; &#125; while (!head.compare_exchange_weak(old_head, new_head)); old_head = new_head; //3 auto* node_ptr = old_head._node_ptr; if (node_ptr == nullptr) &#123; return std::shared_ptr&lt;T&gt;(); &#125; //4 比较head和old_head相等则交换否则说明head已经被其他线程更新 if (head.compare_exchange_strong(old_head, node_ptr-&gt;_next)) &#123; //要返回的值 std::shared_ptr&lt;T&gt; res; //交换智能指针 res.swap(node_ptr-&gt;_data); //5 增加的数量 int increase_count = old_head._ref_count - 2; //6 if (node_ptr-&gt;_dec_count.fetch_add(increase_count) == -increase_count) &#123; delete node_ptr; &#125; return res; &#125;else &#123; //7 if (node_ptr-&gt;_dec_count.fetch_sub(1) == 1) &#123; delete node_ptr; &#125; &#125; &#125;&#125; 1 多个线程并发pop如果有线程在2处重试，可能时head和old_head的引用计数不同或者node的地址不同，不过无论如何我们的head采用的是副本存储，所以重试失败增加的引用计数不会影响到其他线程。 2 在代码3处我们将old_head的node地址取出来，留作node_ptr,这样我们以后可以对node_ptr内部的引用计数做减少，因为多个线程操作node_ptr指向的数据，所以引用计数是原子变量，并且多个线程是可见的。 3 在4处进行判断，由于我们的head存储的是ref_node类型，所以多个线程看到的old_head的值可能不一样，但我们能保证仅有一个线程进入if逻辑，进入的线程就是old_head和head匹配的那个，我们定义了res用来返回数据。在5处对增加的引用计数减2操作，获取除了自己以外并行操作这个old_head的线程数。然后我们说过增加引用计数和减少引用计数相加为0就说明可以删除节点。那我们在6处利用fetch_add操作返回操作之前的值，让fetch_add增加increase_count，并且fetch_add返回增加之前_dec_count的值，如果这个值是负的increase_count即表示当前仅有该线程操作这个old_head节点，即可删除。 为了让大家了解这个过程我们假设线程1和线程2都执行到4处之前，线程2没抢占到cpu暂停，而线程1抢占并且执行了4处的交换进入if条件，而此时线程2抢占cpu继续执行else逻辑，将_dec_count减少1，原来的_dec_count为0，减少后变为-1，fetch_sub返回之前的值为0不满足if条件所以线程2不会删除node_ptr。此时线程1继续抢占cpu执行到5处_ref_count为3，increse_count为1，_dec_count为-1，_dec_count进行fetch_add之后变为0,但是fetch_add返回的时相加之前的值即为-1，而increase_count恰好为1，所以线程1回收这个node_ptr。 测试和验证为了测试安全性，效率就不测了，这个无锁的栈后期还要完善，目前我们只要测试安全性即可。 我们启动三个线程t1,t2,t3，t1用来向栈中压入元素,t2和t3用来从栈中弹出元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void TestSingleRefStack() &#123; single_ref_stack&lt;int&gt; single_ref_stack; std::set&lt;int&gt; rmv_set; std::mutex set_mtx; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; 20000; i++) &#123; single_ref_stack.push(i); std::cout &lt;&lt; &quot;push data &quot; &lt;&lt; i &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = single_ref_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); std::thread t3([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = single_ref_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); t1.join(); t2.join(); t3.join(); assert(rmv_set.size() == 20000);&#125; 上面的代码中t1负责压入两万个元素，t2和t3分别从栈中弹出元素我们在assert处打个断点，可以看到集合大小确实为两万个，而且不存在重复元素，不存在缺失的元素。 总结源码链接：https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day17-LockFreeStack 视频链接：https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"风险指针的巧妙运用","date":"2023-12-09T09:19:53.000Z","path":"2023/12/09/concpp19/","text":"简介术语“风险指针”是指Maged Michael发明的一种技法， 后来被IBM申请为专利。前文我们设计了无锁并发栈的结构，对于pop操作回收节点采用的是延时删除的策略，即将要删除的节点放入待删除列表中。但是待删列表中的节点可能永远不会被回收，因为每次多个线程pop就不会触发回收待删列表的操作。上一节我们说可以通过执行pop的最后一个线程执行回收，那为了实现这个目的，我们就要换一种思路。就是我们将要删除的节点做特殊处理，如果有线程使用它，就将他标记为正在使用，那么这个节点的指针就是风险指针，也就是不能被其他线程删除。 改进pop我们假设有一块全局区域存储的是一个风险数组，数组里放的就是风险指针。我们提供一个函数去设置数组中某个节点为风险指针，没被设置为风险指针的节点就是可用的。然后我们再提供一个函数去查找数组中的节点，返回一个可用的节点。假设查找的函数叫做get_hazard_pointer_for_current_thread。 1234567891011121314std::shared_ptr&lt;T&gt; pop()&#123; // 1 std::atomic&lt;void*&gt;&amp; hp=get_hazard_pointer_for_current_thread(); node* old_head=head.load(); // ⇽--- 2 node* temp; do &#123; temp=old_head; hp.store(old_head); // ⇽--- 3 old_head=head.load(); &#125; while(old_head!=temp); // ⇽--- 4 // ...&#125; 1 处获取数组中可用节点指针，用hp存储节点指针的引用。 2 处加载当前头节点保存到old节点里。 3 处将old_head的值赋值给hp。 4 while循环处的作用就是防止多个线程访问pop函数，某一个线程B将head修改，那说明他已经将它的临时变量old节点放入风险数组中，而本线程A的old节点和线程B的old节点指向的是同一个旧有的head，所以线程A就没必要将这个old节点放入风险数组了，需要再次循环获取新的head加载为old节点，再放入风险数组。 我们实现一个完整意义的pop操作 12345678910111213141516171819202122232425262728293031323334353637383940std::shared_ptr&lt;T&gt; pop()&#123; //1 从风险列表中获取一个节点给当前线程 std::atomic&lt;void*&gt;&amp; hp=get_hazard_pointer_for_current_thread(); node* old_head=head.load(); do &#123; node* temp; do &#123; temp=old_head; hp.store(old_head); old_head=head.load(); &#125;//2 如果old_head和temp不等说明head被其他线程更新了，需重试 while(old_head!=temp); &#125;//3 将当前head更新为old_head-&gt;next，如不满足则重试 while(old_head&amp;&amp; !head.compare_exchange_strong(old_head,old_head-&gt;next)); // 4一旦更新了head指针，便将风险指针清零 hp.store(nullptr); std::shared_ptr&lt;T&gt; res; if(old_head) &#123; res.swap(old_head-&gt;data); //5 删除旧有的头节点之前，先核查它是否正被风险指针所指涉 if(outstanding_hazard_pointers_for(old_head)) &#123; //6 延迟删除 reclaim_later(old_head); &#125; else &#123; //7 删除头部节点 delete old_head; &#125; //8 删除没有风险的节点 delete_nodes_with_no_hazards(); &#125; return res;&#125; 1 我们观察1处代码从全局的风险数组中jiu获取一个可用的节点作为风险节点。这样其他线程在回收节点的时候会从这个数组中看到这个风险节点，进而不会删除该节点。 2 处代码做循环比较是为了hp存储的节点为当前线程操作的head，如果其它线程更新了head，那么当前线程就要进行重试。以保证每个线程的hp存储的都是自己看到的最新的head。 3 处将head和old_head做比较，如果相等则更新head为old_head-&gt;next的值。如果不等则再次重复循环，因为有可能有多个线程都满足2处的条件，多个线程的hp和old_head指向相同，所以要重试，保证多线程情况下head的移动唯一。 4 一旦更新了head指针，就可以将这个风险指针清零了，因为其他线程pop操作的head已经不是我们hp存储的old_head了。所以此种情况下是线程安全的。 5 删除旧节点之前，先看它是否被风险指针所指涉。 6 如果要删除的节点被风险指针指涉，则延迟删除，放入待删列表。都则直接删除该节点即可。(7处) 8 每个线程pop后，都要查一下待删列表，将其中没有风险的节点删除。 接下来我们实现从全局连表中返回一个可用的节点 12345std::atomic&lt;void*&gt;&amp; get_hazard_pointer_for_current_thread() &#123; //每个线程都具有自己的风险指针 线程本地变量 thread_local static hp_owner hazzard; return hazzard.get_pointer();&#125; 我们通过一个线程本地变量hazzard存储当前线程正在使用的节点，这个节点被称作风险节点。其他线程不能删除。 接下来我们实现hazard_pointer类，管理风险指针和线程id 1234struct hazard_pointer &#123; std::atomic&lt;std::thread::id&gt; id; std::atomic&lt;void*&gt; pointer;&#125;; id为正在使用该风险指针的id，pointer为指针类型，存储的节点数据地址。当一个线程从风险数组中查找某个闲置节点作为风险节点，则需要将pointer指向节点的数据，并且将id设置为当前的线程id。 我们定义一个全局的风险节点数组，用来存储风险节点。 1hazard_pointer hazard_pointers[max_hazard_pointers]; 然后我们用hp_owner类管理这个风险指针 12345678910111213141516171819202122232425class hp_owner &#123;public: hp_owner(hp_owner const&amp;) = delete; hp_owner operator=(hp_owner const&amp;) = delete; hp_owner():hp(nullptr)&#123; for (unsigned i = 0; i &lt; max_hazard_pointers; ++i) &#123; std::thread::id old_id; if (hazard_pointers[i].id.compare_exchange_strong(old_id, std::this_thread::get_id())) &#123; hp = &amp;hazard_pointers[i]; break; &#125; &#125; if (!hp) &#123; throw std::runtime_error(&quot;No hazard pointers available&quot;); &#125; &#125; ~hp_owner() &#123; hp-&gt;pointer.store(nullptr); hp-&gt;id.store(std::thread::id()); &#125;private: hazard_pointer* hp;&#125;; 每个线程每次调用get_hazard_pointer_for_current_thread只会在第一次的时候构造hp_owner类型的hazzard，之后该线程再次调用该函数不会构造hp_owner，因为是线程本地变量。 当一个线程析构的时候会释放其本地变量hazzard，进而执行hp_owner析构函数，从而恢复初值。 接下来我们要实现hp_owner的get_pointer函数。 123std::atomic&lt;void*&gt;&amp; get_pointer() &#123; return hp-&gt;pointer;&#125; hp_owner 的get_pointer函数返回其成员pointer指向的地址 接下来我们实现判断该节点是否被风险指针所指涉的函数 1234567891011bool outstanding_hazard_pointers_for(void* p)&#123; for (unsigned i = 0; i &lt; max_hazard_pointers; ++i) &#123; if (hazard_pointers[i].pointer.load() == p) &#123; return true; &#125; &#125; return false;&#125; 如果当前节点被风险指针所指涉则将该节点放入待删队列延迟删除 123void reclaim_later(node* old_head) &#123; add_to_reclaim_list(new data_to_reclaim(old_head));&#125; 将节点放入待删列表，我们封装了一个data_to_reclaim类型的节点放入待删列表。 我们定义待删节点的结构体 12345678910//待删节点struct data_to_reclaim &#123; node* data; std::function&lt;void(node*)&gt; deleter; data_to_reclaim* next; data_to_reclaim(node * p):data(p), next(nullptr)&#123;&#125; ~data_to_reclaim() &#123; delete data; &#125;&#125;; 然后在无锁栈中定义一个节点表示待删列表的首节点，因为栈是被多个线程操作的，待删列表也会被多个线程访问，那么我们需要用原子变量表示这个首节点 1std::atomic&lt;data_to_reclaim*&gt; nodes_to_reclaim; 我们实现将节点放入待删列表的逻辑 1234void add_to_reclaim_list(data_to_reclaim* reclaim_node) &#123; reclaim_node-&gt;next = nodes_to_reclaim.load(); while (!nodes_to_reclaim.compare_exchange_weak(reclaim_node-&gt;next, reclaim_node));&#125; 因为可能有多个线程同时将节点放入待删列表，所以此处做重试。接下来实现从待删列表中删除无风险的节点 12345678910111213void delete_nodes_with_no_hazards() &#123; data_to_reclaim* current = nodes_to_reclaim.exchange(nullptr); while (current) &#123; data_to_reclaim* const next = current-&gt;next; if (!outstanding_hazard_pointers_for(current-&gt;data)) &#123; delete current; &#125; else &#123; add_to_reclaim_list(current); &#125; current = next; &#125;&#125; 测试我们依然用之前的方式测试，启动三个线程t1用来向栈中放入数据(总计push20000个), t2和t3用来从栈中pop数据。用一个set记录删除的值，最后判断总共删除的数量是否为2000. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void TestHazardPointer() &#123; hazard_pointer_stack&lt;int&gt; hazard_stack; std::set&lt;int&gt; rmv_set; std::mutex set_mtx; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; 20000; i++) &#123; hazard_stack.push(i); std::cout &lt;&lt; &quot;push data &quot; &lt;&lt; i &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = hazard_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); std::thread t3([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = hazard_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); t1.join(); t2.join(); t3.join(); assert(rmv_set.size() == 20000);&#125; 优劣分析风险指针的机制能保证要删除的节点在合理的时机回收，但是也引发了一些性能问题，比如为了删除某个节点要遍历风险数组判断该节点是否被风险指针所指涉。其次我们对于要删除的节点需要从风险数组中选择一个合适的节点记录其地址，所以也需要便利。C++ 并发编程一书中提出了用空间换取时间和性能的办法，就是开辟2*N个大小的风险数组，只有当使用的节点达到N个时我们才依次判断N个节点是否被风险指针所指涉，这样我i们减少了判断回收的次数。但同样增加内存的开销。另外作者也提及了风险指针为IBM的技术专利，即使我们懂得这种方法也不见得有权利使用，为后文提及了引用计数做了铺垫。 源码链接: https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day17-LockFreeStack 视频链接: https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"无锁栈的实现","date":"2023-12-09T04:58:22.000Z","path":"2023/12/09/concpp18/","text":"简介前文我们通过锁的互斥机制实现了并发安全的栈，队列，查找表，以及链表等结构。接下来本文介绍通过无锁的原子变量的方式实现对应的容器，我们这一篇先从无锁的方式实现栈讲起。 栈的设计思路栈容器是一种先进后出的结构，简单来讲，我们将n个元素1，2，3，4依次入栈，那么出栈的顺序是4，3，2，1. 先考虑单线程情况下操作顺序 1 创建新节点 2 将元素入栈，将新节点的next指针指向现在的head节点。 3 将head节点更新为新节点的值。 再考虑多线程的情况下 假设线程1执行到第2步，没来得及更新head节点的值为新节点的值。此时线程2也执行完第2步，将head更新为线程2插入的新节点，之后线程1又将head更新为线程1的新插入节点，那么此时head的位置就是错的。 如下图 我们可以通过原子变量的compare_exchange(比较交换操作)来控制更新head节点，以此来达到线程安全的目的。 我们先定义节点的结构 123456789template&lt;typename T&gt;struct node&#123; T data; node* next; node(T const&amp; data_) : data(data_) &#123;&#125;&#125;; 一个node节点包含两部分内容，一个T类型的数据域，一个node* 的next指针，指向下一个节点。 我们接下来定义一个无锁栈的结构 1234567891011template&lt;typename T&gt;class lock_free_stack&#123;private: lock_free_stack(const lock_free_stack&amp;) = delete; lock_free_stack&amp; operator = (const lock_free_stack&amp;) = delete; std::atomic&lt;node*&gt; head;public: lock_free_stack() &#123;&#125;&#125; 我们同样将拷贝构造和拷贝赋值删除了，将head设置为原子变量，这样我们实现push操作的时候，可以通过比较交换的方式达到安全更新head的效果。 1234567template&lt;typename T&gt;void push(const T&amp; value)&#123; auto new_node = new Node(value) do&#123; new_node-&gt;next = head.load(); &#125;while(!head.compare_exchange_strong(new_node-&gt;next, new_node));&#125; 当然&lt;Concurrency Programing C++&gt;书中的做法更简略一些 1234567template&lt;typename T&gt;void push(const T&amp; value)&#123; auto new_node = new Node(value) do&#123; new_node-&gt;next = head.load(); &#125;while(!head.compare_exchange_weak(new_node-&gt;next, new_node));&#125; 我还是建议大家用do-while的方式实现，这样我们可以在do-while中增加很多自己的定制逻辑,另外推荐大家用compare_exchange_weak，尽管存在失败的情况，但是他的开销小，所以compare_exchange_weak返回false我们再次重试即可。 单线程情况下pop操作的顺序 1 取出头节点元素 2 更新head为下一个节点。 3 返回取出头节点元素的数据域。 多线程情况下，第1，2点同样存在线程安全问题。此外我们返回节点数据域时会进行拷贝赋值，如果出现异常会造成数据丢失，这一点也要考虑。所以我们同样通过head原子变量比较和交换的方式检测并取出头部节点。 我们先写一个单线程版本 123456template&lt;typename T&gt;void pop(T&amp; value)&#123; node* old_head = head.load(); //1 head = head-&gt;next; //2 value = old_head-&gt;data;&#125; 我们知道1处和2处在多线程情况下会存在线程安全问题。所以我们用原子变量的比较交换操作改写上面的代码 1234567template&lt;typename T&gt;void pop(T&amp; value)&#123; do&#123; node* old_head = head.load(); //1 &#125;while(!head.compare_exchange_weak(old_head, old_head-&gt;next)); //2 value = old_head-&gt;data; //3&#125; 我们通过判断head和old_head的值是否相等，如果相等则将head的值设置为old_head的下一个节点，否则返回false，并且将old_head更新为当前head的值(比较交换函数帮我们做的)。 我们看上面的代码，有三点严重问题 1 未判断空栈的情况，这一点比较好处理，如果为空栈我们可以令pop返回false，或者抛出异常，当然抛出异常不可取。 2 将数据域赋值给引用类型的value时存在拷贝赋值(3处)，我们都知道拷贝赋值会存在异常的情况，当异常发生时元素已经从栈定移除了，破坏了栈的结构，这一点和锁处理时不一样，锁处理的时候是先将元素数据域取出赋值再出栈，所以不会有问题，但是无锁的方式就会出现栈被破坏的情况。解决方式也比较简单，数据域不再存储T类型数据，而是存储std::shared_ptr&lt;T&gt;类型的数据。智能指针在赋值的时候不会产生异常。 3 未释放弹出的节点的内存。 那我们修改之后的代码就是这样了 1234567891011121314151617181920212223242526272829303132333435class lock_free_stack&#123;private: struct node &#123; std::shared_ptr&lt;T&gt; data; node* next; node(T const&amp; data_) : //⇽-- - 1 data(std::make_shared&lt;T&gt;(data_)) &#123;&#125; &#125;; lock_free_stack(const lock_free_stack&amp;) = delete; lock_free_stack&amp; operator = (const lock_free_stack&amp;) = delete; std::atomic&lt;node*&gt; head;public: lock_free_stack() &#123;&#125; void push(T const&amp; data) &#123; node* const new_node = new node(data); //⇽-- - 2 new_node-&gt;next = head.load(); //⇽-- - 3 while (!head.compare_exchange_weak(new_node-&gt;next, new_node)); //⇽-- - 4 &#125; std::shared_ptr&lt;T&gt; pop() &#123; node* old_head = nullptr; //1 do &#123; old_head = head.load(); //2 if (old_head == nullptr) &#123; return nullptr; &#125; &#125; while (!head.compare_exchange_weak(old_head, old_head-&gt;next)); //3 return old_head-&gt;data; //4 &#125;&#125;; 简单描述下pop函数的功能， 1 处初始化一个临时old_head的变量， 2 处加载head节点 3 处通过比较和交换操作，判断head和old_head是否相等，如相等则将head更新为old_head的next节点。如不相等，将old_head更新为head的值(compare_exchange_weak自动帮我们做了),再次进入循环。尽管2处又加载了一次head的值给old_head有些重复，但是为了代码的可读性和指针判空，我觉得这么写更合适一点。 资源回收的问题我们还没处理。我们先实现一个简单的回收处理逻辑 123456789101112131415template&lt;typename T&gt;std::shared_ptr&lt;T&gt; pop() &#123; node* old_head = nullptr; //1 do &#123; old_head = head.load(); if (old_head == nullptr) &#123; return nullptr; &#125; &#125; while (!head.compare_exchange_weak(old_head, old_head-&gt;next)); //2 std::shared_ptr&lt;T&gt; res; //3 res.swap(old_head-&gt;data); //4 delete old_head; //5 return res; //6 &#125; 上面的代码在3处定义了一个T类型的智能指针res用来返回pop的结果，所以在4处将old_head的data值转移给res，这样就相当于清除old_head的data了。 在5处删除了old_head. 意在回收数据，但这存在很大问题，比如线程1执行到5处删除old_head，而线程2刚好执行到2处用到了和线程1相同的old_head，线程2执行compare_exchange_weak的时候old_head-&gt;next会引发崩溃。 所以要引入一个机制，延迟删除节点。将本该及时删除的节点放入待珊节点。基本思路如下 1 如果有多个线程同时pop，而且存在一个线程1已经交换取出head数据并更新了head值，另一个线程2即将基于旧有的head获取next数据，如果线程1删除了旧有head，线程2就有可能产生崩溃。这种情况我们就要将线程1取出的head放入待删除的列表。 2 同一时刻仅有一个线程1执行pop函数，不存在其他线程。那么线程1可以将旧head删除，并删除待删列表中的其他节点。 3 如果线程1已经将head节点交换弹出，线程2还未执行pop操作，当线程1准备将head删除时发现此时线程2进入执行pop操作，那么线程1能将旧head删除，因为线程2读取的head和线程1不同(线程2读取的是线程1交换后新的head值)。此情形和情形1略有不同，情形1是两个线程同时pop只有一个线程交换成功的情况，情形3是一个线程已经将head交换出，准备删除之前发现线程2执行pop进入，所以这种情况下线程1可将head删除，但是线程1不能将待删除列表删除，因为有其他线程可能会用到待删除列表中的节点。 我们思考这种情形 线程1 执行pop已经将head换出 线程2 执行pop函数，发现线程1正在pop操作，线程2就将待删除的节点head(此head非线程1head)放入待删列表. 线程3 和线程2几乎同时执行pop函数但是还未执行head的交换操作，此head和线程2的head相同。 这种情况下线程1可能读取待删列表为空，因为线程2可能还未更新，也可能读取待删列表不为空(线程2已更新)，但是线程1不能删除这个待删列表，因为线程3可能在用。 那基于上述三点，我们可以简单理解为 1 如果head已经被更新，且旧head不会被其他线程引用，那旧head就可以被删除。否则放入待删列表。 2 如果仅有一个线程执行pop操作，那么待删列表可以被删除，如果有多个线程执行pop操作，那么待删列表不可被删除。 我们需要用一个原子变量threads_in_pop记录有几个线程执行pop操作。在pop结束后再减少threads_in_pop。我们需要一个原子变量to_be_deleted记录待删列表的首节点。 那么我们先实现一个改造版本 123456789101112131415161718192021222324std::shared_ptr&lt;T&gt; pop() &#123; //1 计数器首先自增，然后才执行其他操作 ++threads_in_pop; node* old_head = nullptr; do &#123; //2 加载head节点给旧head存储 old_head = head.load(); if (old_head == nullptr) &#123; --threads_in_pop; return nullptr; &#125; &#125; while (!head.compare_exchange_weak(old_head, old_head-&gt;next)); // 3 //3处 比较更新head为旧head的下一个节点 std::shared_ptr&lt;T&gt; res; if (old_head) &#123; // 4 只要有可能，就回收已删除的节点数据 res.swap(old_head-&gt;data); &#125; // 5 从节点提取数据，而非复制指针 try_reclaim(old_head); return res;&#125; 1 在1处我们对原子变量threads_in_pop增加以表示线程执行pop函数。 2 在2处我们将head数据load给old_head。如果old_head为空则直接返回。 3 3处通过head和old_head作比较，如果相等则交换，否则重新do while循环。这么做的目的是为了防止多线程访问，保证只有一个线程将head更新为old_head的下一个节点。 4 将old_head的数据data交换给res。 5 try_reclaim函数就是删除old_head或者将其放入待删列表，以及判断是否删除待删列表。 接下来我们实现try_reclaim函数 123456789101112131415161718192021222324252627void try_reclaim(node* old_head)&#123; //1 原子变量判断仅有一个线程进入 if(threads_in_pop == 1) &#123; //2 当前线程把待删列表取出 node* nodes_to_delete = to_be_deleted.exchange(nullptr); //3 更新原子变量获取准确状态，判断pop是否仅仅正被当前线程唯一调用 if(!--threads_in_pop) &#123; //4 如果唯一调用则将待删列表删除 delete_nodes(nodes_to_delete); &#125;else if(nodes_to_delete) &#123; //5 如果pop还有其他线程调用且待删列表不为空， //则将待删列表首节点更新给to_be_deleted chain_pending_nodes(nodes_to_delete); &#125; delete old_head; &#125; else &#123; //多个线程pop竞争head节点，此时不能删除old_head //将其放入待删列表 chain_pending_node(old_head); --threads_in_pop; &#125;&#125; 1 1处我们判断pop的线程数是否为1，并没有采用load，也就是即便判断的时候其他线程也可以pop，这样不影响效率，即便模糊判断threads_in_pop为1，同一时刻threads_in_pop可能会增加也没关系，threads_in_pop为1仅表示当前时刻走入1处逻辑之前仅有该线程执行pop，那说明没有其他线程竞争head，head已经被更新为新的值，其他线程之后pop读取的head和我们要删除的old_head不是同一个，就是可以被直接删除的。 2 处我们将当前待删除的列表交换给本线程的nodes_to_delete临时变量，表示接管待删除列表。但是能否删除还要判断是不是仅有本线程在执行pop。 3 处更新原子变量获取准确状态，判断pop是否仅仅正被当前线程唯一调用，如果是被唯一调用则删除待删列表，否则将nodes_to_delete临时变量再更新回待删列表。(因为可能有多个线程会用待删列表中的节点) 接下来我们实现delete_nodes函数, 该函数用来删除以nodes为首节点的链表，该函数写成了static函数，也可以用普通函数。 123456789static void delete_nodes(node* nodes)&#123; while (nodes) &#123; node* next = nodes-&gt;next; delete nodes; nodes = next; &#125;&#125; 接下来实现chain_pending_node函数，该函数用来将单个节点放入待删列表 1234void chain_pending_node(node* n)&#123; chain_pending_nodes(n, n); &#125; chain_pending_nodes接受两个参数，分别为链表的头和尾。 123456789void chain_pending_nodes(node* first, node* last)&#123; //1 先将last的next节点更新为待删列表的首节点 last-&gt;next = to_be_deleted; //2 借循环保证 last-&gt;next指向正确 // 将待删列表的首节点更新为first节点 while (!to_be_deleted.compare_exchange_weak( last-&gt;next, first)); &#125; 1 处将last-&gt;next的值更新为to_be_deleted, 这么做的一个好处是如果有其他线程修改了to_be_deleted.能保证当前线程的last-&gt;next指向的是最后修改的to_be_deleted，达到链接待删列表的作用。 2 处可能更新失败，因为其他线程修改了to_be_deleted的值，但是不要紧，我们再次循环直到匹配last-&gt;next的值为to_be_deleted为止，将to_be_deleted更新为first的值。 接下来我们还要实现将nodes_to_delete为首的链表还原到待删列表中, 函数为chain_pending_nodes接受一个参数为待还原的链表的首节点 1234567891011void chain_pending_nodes(node* nodes)&#123; node* last = nodes; //1 沿着next指针前进到链表末端 while (node* const next = last-&gt;next) &#123; last = next; &#125; //2 将链表放入待删链表中 chain_pending_nodes(nodes, last);&#125; 分析上面的无锁栈存在一个问题，就是当多个线程pop时将要删除的节点放入待删列表中，如果每次pop都会被多个线程调用，则要删除的节点就会一直往待删除列表中增加，导致待删除列表无法被回收。这个问题我们可以考虑当pop执行结束时最后一个线程回收待删列表。留作下一节分析。 我们先写一个函数测试以下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void TestLockFreeStack() &#123; lock_free_stack&lt;int&gt; lk_free_stack; std::set&lt;int&gt; rmv_set; std::mutex set_mtx; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; 20000; i++) &#123; lk_free_stack.push(i); std::cout &lt;&lt; &quot;push data &quot; &lt;&lt; i &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = lk_free_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); std::thread t3([&amp;]() &#123; for (int i = 0; i &lt; 10000;) &#123; auto head = lk_free_stack.pop(); if (!head) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; std::lock_guard&lt;std::mutex&gt; lock(set_mtx); rmv_set.insert(*head); std::cout &lt;&lt; &quot;pop data &quot; &lt;&lt; *head &lt;&lt; &quot; success!&quot; &lt;&lt; std::endl; i++; &#125; &#125;); t1.join(); t2.join(); t3.join(); assert(rmv_set.size() == 20000);&#125; 1 线程t1将0到20000个数放入集合中。2 线程t2和t3分别出栈10000次。3 最后我们断言集合的大小为20000. 测试结果如下 可以看到我们的集合大小为20000，且数据唯一。 总结源码链接: https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day17-LockFreeStack 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"线程安全的链表","date":"2023-12-02T13:25:20.000Z","path":"2023/12/02/concpp17/","text":"简介前文介绍了如何基于锁实现线程安全的栈和队列结构，以及实现线程安全的查找表，但是我们上次的查找表是基于list实现的，对于锁的精度控制的不是很准确，提及了接下来会介绍精细控制的链表，用来替换查找表中的链表。这一节我们就介绍如何通过锁控制链表访问的精度。 链表一个常见的链表应该是如下结构，有一个包含数据的数据域以及一个指向下一个节点的指针。 如果做一个支持多线程并发访问的链表，我们首先想到的是用一个互斥量控制整个链表，达到多线程访问时串行的效果。但是这么做精度不够，需要分化互斥量的功能。我们想到的一个办法就是每个节点都维护一个互斥量，这样能保证多个线程操作不同节点时加不同的锁，减少耦合性。 另外我们将head独立为一个虚节点，所谓虚节点就是不存储数据，只做头部标记。我们每次从头部插入只需要修将新的节点的next指针指向原来head的next指向的节点，再将head的next指针指向新的节点。 如下图 源码实现我们先定义一个基本的链表节点 12345678910template&lt;typname T&gt;struct node&#123; std::mutex m; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; node() :next()&#123;&#125; node(T const&amp; value) : data(std::make_shared&lt;T&gt;(value))&#123;&#125;&#125;; 1 data为智能指针,存储的是T类型的数据域。2 next为一个unique类型的智能指针，存储的是下一个节点的地址。3 m 为mutex，控制多线程访问的安全性。我们将mutex分别独立到各个节点中保证锁的精度问题。 接下来我们定义一个链表，初始状态包含一个head的头节点 12345678910111213141516171819202122232425262728template&lt;typename T&gt;class threadsafe_list&#123; struct node &#123; std::mutex m; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; node() : next() &#123;&#125; node(T const&amp; value) : data(std::make_shared&lt;T&gt;(value)) &#123;&#125; &#125;; node head;public: threadsafe_list() &#123;&#125; ~threadsafe_list() &#123; &#125; threadsafe_list(threadsafe_list const&amp; other) = delete; threadsafe_list&amp; operator=(threadsafe_list const&amp; other) = delete;&#125; 我们将拷贝构造和拷贝赋值函数删除。然后链表中初始状态包含了一个头节点。接下来我们实现析构函数，我们期望析构函数能够从头到尾的删除元素，所以先实现一个删除函数 12345678910111213141516171819202122template&lt;typename Predicate&gt;void remove_if(Predicate p)&#123; node* current = &amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while (node* const next = current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); if (p(*next-&gt;data)) &#123; std::unique_ptr&lt;node&gt; old_next = std::move(current-&gt;next); current-&gt;next = std::move(next-&gt;next); next_lk.unlock(); &#125; else &#123; lk.unlock(); current = next; lk = std::move(next_lk); &#125; &#125;&#125; 上面的函数中，我们先取头部节点作为当前节点，然后将将当前节点加锁，只有当前节点加锁了才能访问其next指针。我们在获取next节点后也要对其加锁，这么做的好处就是保证无论是删除还是添加都从当前节点开始依次对其next节点加锁，既能保证互斥也能维护同一顺序防止死锁。 如果next节点的数据域满足谓词p的规则，则将next节点的移动赋值给old_next，随着局部作用域结束，old_next会被释放，也就达到了析构要删除节点的目的。然后我们将next节点的next值(也就是要删除节点的下一个节点)赋值给当前节点的next指针，达到链接删除节点的下一个节点的目的。 但是我们要操作接下来的节点就需要继续锁住下一个节点，达到互斥控制的目的，锁住下个节点是通过while循环不断迭代实现的，通过next_lk达到了锁住下一个节点的目的。 如果下一个节点不满足我们p谓词函数的条件，则需要解锁当前节点，将下一个节点赋值给当前节点，并且将下一个节点的锁移动给当前节点。 如下图演示了current, next以及next-&gt;next节点之间的关系。 接下来我们实现析构函数 1234~threadsafe_list()&#123; remove_if([](node const&amp;) &#123;return true; &#125;);&#125; 析构函数调用remove_if,p谓词就是一个lambda表达式，返回true。 头节点的插入工作也比较简答，将新节点的next指针赋值成头部节点的next指针指向的数据。然后将新节点赋值给头部节点的next指针即可. 1234567void push_front(T const&amp; value)&#123; std::unique_ptr&lt;node&gt; new_node(new node(value)); std::lock_guard&lt;std::mutex&gt; lk(head.m); new_node-&gt;next = std::move(head.next); head.next = std::move(new_node);&#125; 但是大家要注意，插入和删除加锁的顺序要保持一致，都是从头到尾，这样能防止死锁，也能保持互斥。 假设原链表是这样的 调用push_front之后是这样的 接下来是根据谓词p查找对应的节点数据 123456789101112131415161718template&lt;typename Predicate&gt;std::shared_ptr&lt;T&gt; find_first_if(Predicate p)&#123; node* current = &amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while (node* const next = current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); lk.unlock(); if (p(*next-&gt;data)) &#123; return next-&gt;data; &#125; current = next; lk = std::move(next_lk); &#125; return std::shared_ptr&lt;T&gt;();&#125; find_first_if查找到第一个满足条件的节点就返回。查找的步骤也是先对当前节点加锁，判断当前节点的next节点是否为空，不为空则获取下一个节点为next，我们对next加锁，依次锁住当前节点和下一个节点，判断下一个节点是否满足谓词p,如果满足条件则返回next节点的数据即可，更新下一个节点为当前节点，下一个节点的锁next_lk更新给lk，以此锁住新的当前节点，再依次类推遍历直到找到满足条件的节点为止。 那么便利所有节点的接口就可以根据上述思路实现了 1234567891011121314template&lt;typename Function&gt;void for_each(Function f)&#123; node* current = &amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while (node* const next = current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); lk.unlock(); f(*next-&gt;data); current = next; lk = std::move(next_lk); &#125;&#125; 如果我们按照如下测试函数测试上面的接口， 1234567891011121314151617181920212223242526272829303132333435363738394041std::set&lt;int&gt; removeSet;void TestThreadSafeList()&#123; threadsafe_list&lt;MyClass&gt; thread_safe_list; std::thread t1([&amp;]() &#123; for(unsigned int i = 0; i &lt; 100; i++) &#123; MyClass mc(i); thread_safe_list.push_front(mc); &#125; &#125;); std::thread t2([&amp;]() &#123; for (unsigned int i = 0; i &lt; 100; ) &#123; auto find_res = thread_safe_list.find_first_if([&amp;]( auto &amp; mc) &#123; return mc.GetData() == i; &#125;); if(find_res == nullptr) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; removeSet.insert(i); i++; &#125; &#125;); t1.join(); t2.join();&#125; 将删除的数据放入集合set，最后打印set会发现数据全都被删除了。 尾部插入C++ 并发编程中提到了留给读者去实现尾部插入，我们实现尾部插入需要维护一个尾部节点，这个尾部节点我们初始的时候指向head，当插入元素后，尾部节点指向了最后一个节点的地址。 考虑有多个线程并发进行尾部插入，所以要让这些线程互斥，我们需要一个互斥量last_ptr_mtx保证线程穿行，last_node_ptr表示正在操作尾部节点，以此来让多个线程并发操作尾部节点时达到互斥。比如我们的代码可以实现如下 1234567891011void push_back(T const&amp; value) &#123; //防止于push_head同时进行 //并且保证头部或者删除节点更新last_node_ptr唯一, 所以同时加锁 std::unique_ptr&lt;node_d&gt; new_node(new node_d(value)); std::unique_lock&lt;std::mutex&gt; lk(last_node_ptr-&gt;m); std::unique_lock&lt;std::mutex&gt; last_lk(last_ptr_mtx); //原来的最后节点的下一个节点指向新生成的节点 last_node_ptr-&gt;next = std::move(new_node); //将最后一个节点后移 last_node_ptr = last_node_ptr-&gt;next.get();&#125; 头部插入我们也作一些修改 123456789101112void push_front(T const&amp; value)&#123; std::unique_ptr&lt;node_d&gt; new_node(new node_d(value)); std::lock_guard&lt;std::mutex&gt; lk(head.m); new_node-&gt;next = std::move(head.next); head.next = std::move(new_node); //更新最后一个节点 if (head.next-&gt;next == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; last_lk(last_ptr_mtx); last_node_ptr = head.next.get(); &#125;&#125; push_front函数将新节点放入head节点的后边，如果head节点后面没有节点，此时插入新节点后，新的节点就变为尾部节点了。所以判断新插入节点的next为nullptr，那么这个节点就是最后节点，所以要对last_ptr_mtx加锁，更新last_node_ptr值。 我们考虑一下，如果一个线程push_back和另一个线程push_front是否会出现问题？其实两个线程资源竞争的时候仅在队列为空的时候，这时无论push_back还是push_front都会操作head节点，以及更新_last_node_ptr值，但是我们的顺序是先锁住前一个节点，再将当前节点更新为前一个节点的下一个节点。那么从这个角度来说，push_back和push_front不会有线程安全问题。 接下来实现删除操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657template&lt;typename Predicate&gt;void remove_if(Predicate p)&#123; node_d* current = &amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while (node_d* const next = current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); if (p(*next-&gt;data)) &#123; std::unique_ptr&lt;node_d&gt; old_next = std::move(current-&gt;next); current-&gt;next = std::move(next-&gt;next); //判断删除的是否为最后一个节点 if (current-&gt;next == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; last_lk(last_ptr_mtx); last_node_ptr = &amp;head; &#125; next_lk.unlock(); &#125; else &#123; lk.unlock(); current = next; lk = std::move(next_lk); &#125; &#125;&#125;template&lt;typename Predicate&gt;bool remove_first(Predicate p)&#123; node_d* current = &amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while (node_d* const next = current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); if (p(*next-&gt;data)) &#123; std::unique_ptr&lt;node_d&gt; old_next = std::move(current-&gt;next); current-&gt;next = std::move(next-&gt;next); //判断删除的是否为最后一个节点 if (current-&gt;next == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; last_lk(last_ptr_mtx); last_node_ptr = &amp;head; &#125; next_lk.unlock(); return true; &#125; lk.unlock(); current = next; lk = std::move(next_lk); &#125; return false;&#125; 删除的时候，如果将当前节点的下一个节点满足删除条件，则将其移动到old_next节点里。old_next会随着作用域结束析构。 然后将删除节点的下一个节点赋值给当前节点的next指针，这样就达到了当前节点的next指针指向了删除节点的下一个节点的目的，以此达到了删除效果。 我们思考删除操作和push_back是否会产生线程竞争，答案是会的，比如下面这种情况 线程1想要push_back插入节点，他会用到last_node_ptr，也会更新last_node_ptr。 而线程2想要删除最后一个节点，会更新last_node_ptr的值。 尽管我们通过node内部的互斥量可以保证两个线程在同一时刻仅能有一个线程操作最后一个节点，或者删除或者添加。 但是，假设线程2先执行删除操作，节点更新并且更新last_node_ptr的值，而此时线程1因为之前无法抢占最后一个节点(last_node_ptr)自带的互斥量所以挂起，当线程2执行完后，线程1才开始继续执行，但是此时last_node_ptr已经变化了，而线程1可能还用的是旧的last_node_ptr的值，导致插入数据失败(很可能崩溃或者插入到一个分叉的链表)。 如果将push_back修改为先对last_ptr_mtx加锁，这样就能保证一个线程修改last_node_ptr会被另一个线程看到。比如下面这样 1234567891011void push_back(T const&amp; value) &#123; //防止于push_head同时进行 //并且保证头部或者删除节点更新last_node_ptr唯一, 所以同时加锁 std::unique_ptr&lt;node_d&gt; new_node(new node_d(value)); std::unique_lock&lt;std::mutex&gt; last_lk(last_ptr_mtx); std::unique_lock&lt;std::mutex&gt; lk(last_node_ptr-&gt;m); //原来的最后节点的下一个节点指向新生成的节点 last_node_ptr-&gt;next = std::move(new_node); //将最后一个节点后移 last_node_ptr = last_node_ptr-&gt;next.get();&#125; 但是我们这样会发现删除的时候先对node加锁，再对last_ptr_mtx加锁，而push_back的时候先对last_ptr_mtx加锁，再对node加锁。会导致死锁！ 所以我们将push_back修改为对node和last_ptr_mtx加锁，那么就能解决上面的问题。因为push_back必须要等到两个互斥量都竞争成功才操作，所以达到了删除和push_back串行的效果。 改进后的push_back是如下这个样子 123456789101112void push_back(T const&amp; value) &#123; //防止于push_head同时进行 //并且保证头部或者删除节点更新last_node_ptr唯一, 所以同时加锁 std::unique_ptr&lt;node_d&gt; new_node(new node_d(value)); std::lock(last_node_ptr-&gt;m, last_ptr_mtx); std::unique_lock&lt;std::mutex&gt; lk(last_node_ptr-&gt;m, std::adopt_lock); std::unique_lock&lt;std::mutex&gt; last_lk(last_ptr_mtx, std::adopt_lock); //原来的最后节点的下一个节点指向新生成的节点 last_node_ptr-&gt;next = std::move(new_node); //将最后一个节点后移 last_node_ptr = last_node_ptr-&gt;next.get();&#125; 我们可以实现如下函数测试，启动三个线程，线程1执行push_front将0到20000放入链表。线程2执行push_back将20000到40000的数据放入链表。线程3执行删除操作，将数据从0到40000删除。最后我们打印链表为空，验证准确性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void MultiThreadPush()&#123; double_push_list&lt;MyClass&gt; thread_safe_list; std::thread t1([&amp;]() &#123; for (int i = 0; i &lt; 20000; i++) &#123; MyClass mc(i); thread_safe_list.push_front(mc); std::cout &lt;&lt; &quot;push front &quot; &lt;&lt; i &lt;&lt; &quot; success&quot; &lt;&lt; std::endl; &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 20000; i &lt; 40000; i++) &#123; MyClass mc(i); thread_safe_list.push_back(mc); std::cout &lt;&lt; &quot;push back &quot; &lt;&lt; i &lt;&lt; &quot; success&quot; &lt;&lt; std::endl; &#125; &#125;); std::thread t3([&amp;]() &#123; for(int i = 0; i &lt; 40000; ) &#123; bool rmv_res = thread_safe_list.remove_first([&amp;](const MyClass&amp; mc) &#123; return mc.GetData() == i; &#125;); if(!rmv_res) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; &#125; i++; &#125; &#125;); t1.join(); t2.join(); t3.join(); std::cout &lt;&lt; &quot;begin for each print....&quot; &lt;&lt; std::endl; thread_safe_list.for_each([](const MyClass&amp; mc) &#123; std::cout &lt;&lt; &quot;for each print &quot; &lt;&lt; mc &lt;&lt; std::endl; &#125;); std::cout &lt;&lt; &quot;end for each print....&quot; &lt;&lt; std::endl;&#125; 最后程序输出 12345678push back 39995 successpush back 39996 successpush back 39997 successpush back 39998 successpush back 39999 successbegin for each print....end for each print....Hello World! 总结本文介绍了多线程并发访问情况下线程安全的链表实现方式 源码链接: https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day16-threadsafelist 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"基于锁实现线程安全的查找表","date":"2023-11-25T11:59:01.000Z","path":"2023/11/25/concpp16/","text":"简介前文介绍了线程安全的队列和栈，本文继续介绍线程安全的查找结构，实现一个类似线程安全的map结构，但是map基于红黑树实现，假设我们要增加或者删除节点，设计思路是依次要删除或增加节点的父节点，然后修改子节点数据 。尽管这种思路可行，但是难度较大，红黑树节点的插入要修改多个节点的关系。另外加锁的流程也是锁父节点，再锁子节点，尽管在处理子节点时我们已经处理完父节点，可以对父节点解锁，继续对子节点加锁，这种情况锁的粒度也不是很精细，考虑用散列表实现。 散列表散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。 举个例子： 假如我们一共有 50 人参加学校的数学竞赛，然后我们为每个学生分配一个编号，依次是 1 到 50. 如果我们想要快速知道编号对应学生的信息，我们就可以用一个数组来存放学生的信息，编号为 1 的放到数组下标为 1 的位置，编号为 2 的放到数组下标为 2 的位置，依次类推。 现在如果我们想知道编号为 20 的学生的信息，我们只需要把数组下标为 20 的元素取出来就可以了，时间复杂度为 O(1)，是不是效率非常高呢。 但是这些学生肯定来自不同的年级和班级，为了包含更详细的信息，我们在原来编号前边加上年级和班级的信息，比如 030211 ，03 表示年级，02 表示班级，11 原来的编号，这样我们该怎么存储学生的信息，才能够像原来一样使用下标快速查找学生的信息呢？ 思路还是和原来一样，我们通过编号作为下标来储存，但是现在编号多出了年级和班级的信息怎么办呢，我们只需要截取编号的后两位作为数组下标来储存就可以了。 这个过程就是典型的散列思想。其中，参赛学生的编号我们称之为键(key)，我们用它来标识一个学生。然后我们通过一个方法（比如上边的截取编号最后两位数字）把编号转变为数组下标，这个方法叫做散列函数（哈希函数），通过散列函数得到的值叫做散列值（哈希值）。 我们自己在设计散列函数的函数时应该遵循什么规则呢？ 得到的散列值是一个非负整数 两个相同的键，通过散列函数计算出的散列值也相同 两个不同的键，计算出的散列值不同 虽然我们在设计的时候要求满足以上三条要求，但对于第三点很难保证所有不同的建都被计算出不同的散列值。有可能不同的建会计算出相同的值，这叫做哈希冲突。最常见的一些解决哈希冲突的方式是开放寻址法和链表法，我们这里根据链表法，将散列函数得到相同的值的key放到同一个链表中。 如下图 当我们根据key值的后两位计算编号，将编号相同的放入一个链表，比如030211和030311是一个编号，所以将其放入一个链表。 同样的道理040213和060113是一个编号，放入一个链表。 设计思路我们要实现上述逻辑，可以考虑将11，12，13等hash值放入一个vector中。多线程根据key计算得出hash值的过程并不需要加锁，可以实现并行计算。 但是对于链表的增删改查需要加锁。 所以我们考虑将链表封装为一个类bucket_type,支持数据的增删改查。 我们将整体的查找表封装为threadsafe_lookup_table类，实现散列规则和调度bucket_type类。 代码实现我们先实现内部的bucket_type类. 为了threadsafe_lookup_table可以访问他，所以将threadsafe_lookup_table设置为其友元类。 1234class bucket_type&#123; friend class threadsafe_lookup_table;&#125; 我们需要用链表存储键值结构，所以我们可以在bucket_type中添加一个链表存储键值结构。 12345678910//存储元素的类型为pair，由key和value构成typedef std::pair&lt;Key, Value&gt; bucket_value;//由链表存储元素构typedef std::list&lt;bucket_value&gt; bucket_data;//链表的迭代器typedef typename bucket_data::iterator bucket_iterator;//链表数据bucket_data data;//改用共享锁mutable std::shared_mutex mutex; 并且添加了互斥量用于控制链表的读写互斥操作，但是我们采用的是共享互斥量，可以实现读写锁，保证读的时候可以并发读。 接下来我们封装一个私有的查找接口，用来内部使用。 1234567//查找key值，找到返回对应的value，未找到则返回默认值bucket_iterator find_entry_for(const Key &amp; key)&#123; return std::find_if(data.begin(), data.end(), [&amp;](bucket_value const&amp; item) &#123;return item.first == key; &#125;);&#125; 然后我们分别实现返回查找的值操作，以及添加操作，并且删除操作 1234567891011121314151617181920212223242526272829303132 //查找key值，找到返回对应的value，未找到则返回默认值Value value_for(Key const&amp; key, Value const&amp; default_value) &#123; std::shared_lock&lt;std::shared_mutex&gt; lock(mutex); bucket_iterator const found_entry = find_entry_for(key); return (found_entry == data.end()) ? default_value : found_entry-&gt;second;&#125;//添加key和value，找到则更新，没找到则添加void add_or_update_mapping(Key const&amp; key, Value const&amp; value)&#123; std::unique_lock&lt;std::shared_mutex&gt; lock(mutex); bucket_iterator const found_entry = find_entry_for(key); if (found_entry == data.end()) &#123; data.push_back(bucket_value(key, value)); &#125; else &#123; found_entry-&gt;second = value; &#125;&#125;//删除对应的keyvoid remove_mapping(Key const&amp; key)&#123; std::unique_lock&lt;std::shared_mutex&gt; lock(mutex); bucket_iterator const found_entry = find_entry_for(key); if (found_entry != data.end()) &#123; data.erase(found_entry); &#125;&#125; 这样我们设计完成了bucket_type类。 接下来我们设计threadsafe_lookup_table类。我们用一个vector存储上面的bucket_type类型。 因为我们要计算hash值，key可能是多种类型string, int等，所以我们采用std的hash算法作为散列函数即可. 1234567891011121314class threadsafe_lookup_table&#123;private: //用vector存储桶类型 std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; buckets; //hash&lt;Key&gt; 哈希表 用来根据key生成哈希值 Hash hasher; //根据key生成数字，并对桶的大小取余得到下标，根据下标返回对应的桶智能指针 bucket_type&amp; get_bucket(Key const&amp; key) const &#123; std::size_t const bucket_index = hasher(key) % buckets.size(); return *buckets[bucket_index]; &#125;&#125;; get_bucket函数不需要加锁，各个线程可以并行计算哈希值，取出key对应的桶。如果多线程调用同一个bucket的增删改查，就通过bucket内部的互斥解决线程安全问题。接下来我们完善threadsafe_lookup_table的对外接口 1234567891011121314151617181920212223242526272829threadsafe_lookup_table( unsigned num_buckets = 19, Hash const&amp; hasher_ = Hash()) : buckets(num_buckets), hasher(hasher_)&#123; for (unsigned i = 0; i &lt; num_buckets; ++i) &#123; buckets[i].reset(new bucket_type); &#125;&#125;threadsafe_lookup_table(threadsafe_lookup_table const&amp; other) = delete;threadsafe_lookup_table&amp; operator=( threadsafe_lookup_table const&amp; other) = delete;Value value_for(Key const&amp; key, Value const&amp; default_value = Value()) &#123; return get_bucket(key).value_for(key, default_value);&#125;void add_or_update_mapping(Key const&amp; key, Value const&amp; value)&#123; get_bucket(key).add_or_update_mapping(key, value);&#125;void remove_mapping(Key const&amp; key)&#123; get_bucket(key).remove_mapping(key);&#125; 除此之外我们可将当前查找表的副本作为一个map返回 123456789101112131415161718192021std::map&lt;Key, Value&gt; get_map() &#123; std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks; for (unsigned i = 0; i &lt; buckets.size(); ++i) &#123; locks.push_back( std::unique_lock&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex)); &#125; std::map&lt;Key, Value&gt; res; for (unsigned i = 0; i &lt; buckets.size(); ++i) &#123; //需用typename告诉编译器bucket_type::bucket_iterator是一个类型，以后再实例化 //当然此处可简写成auto it = buckets[i]-&gt;data.begin(); typename bucket_type::bucket_iterator it = buckets[i]-&gt;data.begin(); for (;it != buckets[i]-&gt;data.end();++it) &#123; res.insert(*it); &#125; &#125; return res;&#125; 测试与分析我们自定义一个类 1234567891011121314class MyClass&#123;public: MyClass(int i):_data(i)&#123;&#125; friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const MyClass&amp; mc)&#123; os &lt;&lt; mc._data; return os; &#125;private: int _data;&#125;; 接下来我们实现一个函数做测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void TestThreadSafeHash() &#123; std::set&lt;int&gt; removeSet; threadsafe_lookup_table&lt;int, std::shared_ptr&lt;MyClass&gt;&gt; table; std::thread t1([&amp;]() &#123; for(int i = 0; i &lt; 100; i++) &#123; auto class_ptr = std::make_shared&lt;MyClass&gt;(i); table.add_or_update_mapping(i, class_ptr); &#125; &#125;); std::thread t2([&amp;]() &#123; for (int i = 0; i &lt; 100; ) &#123; auto find_res = table.value_for(i, nullptr); if(find_res) &#123; table.remove_mapping(i); removeSet.insert(i); i++; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125;); std::thread t3([&amp;]() &#123; for (int i = 100; i &lt; 200; i++) &#123; auto class_ptr = std::make_shared&lt;MyClass&gt;(i); table.add_or_update_mapping(i, class_ptr); &#125; &#125;); t1.join(); t2.join(); t3.join(); for(auto &amp; i : removeSet) &#123; std::cout &lt;&lt; &quot;remove data is &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; auto copy_map = table.get_map(); for(auto &amp; i : copy_map) &#123; std::cout &lt;&lt; &quot;copy data is &quot; &lt;&lt; *(i.second) &lt;&lt; std::endl; &#125;&#125; t1用来向map中添加数据(从0到99)，t2用来从map中移除数据(从0到99)，如果map中未找到则等待10ms继续尝试，t3则继续继续添加数据(从100到199).然后分别打印插入的集合和获取的map中的数值。打印可以看到输出插入集合为(099)，copy的map集合为(100199). 我们分析一下上述查找表的优劣 1 首先我们的查找表可以支持并发读，并发写，并发读的时候不会阻塞其他线程。但是并发写的时候会卡住其他线程。基本的并发读写没有问题。2 但是对于bucket_type中链表的操作加锁精度并不精细，因为我们采用的是std提供的list容器，所以增删改查等操作都要加同一把锁，导致锁过于粗糙。 下一节会介绍支持并发读写的自定义链表，可以解决bucket_type中的list锁精度不够的短板。 总结本文介绍了线程安全情况下栈和队列的实现方式 源码链接: https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day15-threadsafehash 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"基于锁实现线程安全队列和栈容器","date":"2023-11-19T04:07:55.000Z","path":"2023/11/19/concpp15/","text":"简介本文介绍如何通过互斥锁和条件变量等并发机制实现线程安全的队列和栈容器。 线程安全的栈实现一个线程安全的栈，我们能想到的是基于锁控制push和pop操作，比如下面的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;exception&gt;#include &lt;mutex&gt;#include &lt;stack&gt;#include &lt;condition_variable&gt;struct empty_stack : std::exception&#123; const char* what() const throw();&#125;;template&lt;typename T&gt;class threadsafe_stack&#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack() &#123;&#125; threadsafe_stack(const threadsafe_stack&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.m); data = other.data; &#125; threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); data.push(std::move(new_value)); // ⇽-- - 1 &#125; std::shared_ptr&lt;T&gt; pop() &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if (data.empty()) throw empty_stack(); // ⇽-- - 2 std::shared_ptr&lt;T&gt; const res( std::make_shared&lt;T&gt;(std::move(data.top()))); // ⇽-- - 3 data.pop(); // ⇽-- - 4 return res; &#125; void pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if (data.empty()) throw empty_stack(); value = std::move(data.top()); // ⇽-- - 5 data.pop(); // ⇽-- - 6 &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); &#125;&#125;; 我们实现了push操作和pop操作 push操作里加锁，然后将数据通过std::move的方式移动放入stack中。我们思考如果1处因为机器内存不足push导致异常，此种情况并不会对栈已有的数据产生危险。 但是vector容器大家要考虑，因为vector存在内存不足时将数据拷贝转移到新空间的过程。那么对于vector这种动态扩容的容器该如何保证容器内数据在移动过程中出现了异常仍能不丢失呢？ 我想到的一个方式就是管理vector的capacity，每次push的时候要判断一下vector的size和capacity是否相等，如果相等则手动扩容并将数据转移到新的vector，再释放旧有的vector。 但是同样会存在一个问题就是会造成内存溢出，因为vector的capacity会随着数据增加而增加，当vector中没有数据的时候capacity仍然很大。这种方式也可以通过swap的方式将当前大容量的vector和一个空的vector做交换，快速清空内存。这些操作和思路需结合实际开发情况而定。 pop提供了两个版本，一个是返回智能指针一个是返回bool类型，这两种我们分析，比如3处和4处也很可能因为内存不足导致构造智能指针失败，或者5处赋值失败，这种情况下抛出异常并不会影响栈内数据，因为程序没走到4和6处就抛出异常了。 pop函数内部判断栈是否空，如果为空则抛出异常，这种情况我们不能接受，异常是用来处理和预判突发情况的，对于一个栈为空这种常见现象，仅需根据返回之后判断为空再做尝试或放弃出栈即可。 为了解决栈为空就抛出异常的问题，我们可以做如下优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293template&lt;typename T&gt;class threadsafe_stack_waitable&#123;private: std::stack&lt;T&gt; data; mutable std::mutex m; std::condition_variable cv;public: threadsafe_stack_waitable() &#123;&#125; threadsafe_stack_waitable(const threadsafe_stack_waitable&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.m); data = other.data; &#125; threadsafe_stack_waitable&amp; operator=(const threadsafe_stack_waitable&amp;) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); data.push(std::move(new_value)); // ⇽-- - 1 cv.notify_one(); &#125; std::shared_ptr&lt;T&gt; wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lock(m); cv.wait(lock, [this]() &#123; if(data.empty()) &#123; return false; &#125; return true; &#125;); // ⇽-- - 2 std::shared_ptr&lt;T&gt; const res( std::make_shared&lt;T&gt;(std::move(data.top()))); // ⇽-- - 3 data.pop(); // ⇽-- - 4 return res; &#125; void wait_and_pop(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; lock(m); cv.wait(lock, [this]() &#123; if (data.empty()) &#123; return false; &#125; return true; &#125;); value = std::move(data.top()); // ⇽-- - 5 data.pop(); // ⇽-- - 6 &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); &#125; bool try_pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) &#123; return false; &#125; value = std::move(data.top()); data.pop(); return true; &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) &#123; return std::shared_ptr&lt;T&gt;(); &#125; std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(std::move(data.top()))); data.pop(); return res; &#125;&#125;; 我们将pop优化为四个版本，四个版本又可以分为两个大类，两个大类分别为try_pop版本和wait_and_pop版本。 try_pop版本不阻塞等待队列有数据才返回，而是直接返回，try_pop又有两个版本，分别返回bool值和指针值。如果队列为空返回false或者空指针。 wait_and_pop版本阻塞等待队列有数据才返回，同样有两个版本，分别返回bool值和指针值。 但是上面的代码我们分析，假设此时栈为空，有一个线程A从队列中消费数据，调用wait_and_pop挂起, 此时另一个线程B向栈中放入数据调用push操作，notify一个线程消费队列中的数据。 此时A从wait_and_pop唤醒，但是在执行3或者5处时，因为内存不足引发了异常，我们之前分析过，即使引发异常也不会影响到栈内数据，所以对于栈的数据来说是安全的，但是线程A异常后，其他线程无法从队列中消费数据，除非线程B再执行一次push。因为我们采用的是notify_one的方式，所以仅有一个线程被激活，如果被激活的线程异常了，就不能保证该数据被其他线程消费了，解决这个问题，可以采用几个方案。 wai_and_pop失败的线程修复后再次取一次数据。 将notify_one改为notify_all，这样能保证通知所有线程。但是notify_all将导致所有线程竞争，并不可取。 我们可以通过栈存储智能指针的方式进行，因为智能指针在赋值的时候不会引发异常。 稍后我们提供的线程安全队列的版本使用的就是第三种优化。 线程安全队列队列和栈最大的不同就是队列为先入先出，有了线程安全的栈的开发思路，我们很快实现一个支持线程安全的队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;mutex&gt;#include &lt;queue&gt;template&lt;typename T&gt;class threadsafe_queue&#123;private: mutable std::mutex mut; std::queue&lt;T&gt; data_queue; std::condition_variable data_cond;public: threadsafe_queue() &#123;&#125; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(std::move(new_value)); data_cond.notify_one(); //⇽-- - ① &#125; void wait_and_pop(T&amp; value) //⇽-- - ② &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk, [this] &#123;return !data_queue.empty(); &#125;); value = std::move(data_queue.front()); data_queue.pop(); &#125; std::shared_ptr&lt;T&gt; wait_and_pop() // ⇽-- - ③ &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk, [this] &#123;return !data_queue.empty(); &#125;); // ⇽-- - ④ std::shared_ptr&lt;T&gt; res( std::make_shared&lt;T&gt;(std::move(data_queue.front()))); data_queue.pop(); return res; &#125; bool try_pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if (data_queue.empty()) return false; value = std::move(data_queue.front()); data_queue.pop(); return true; &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if (data_queue.empty()) return std::shared_ptr&lt;T&gt;(); //⇽-- - ⑤ std::shared_ptr&lt;T&gt; res( std::make_shared&lt;T&gt;(std::move(data_queue.front()))); data_queue.pop(); return res; &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); return data_queue.empty(); &#125;&#125;; 关于异常情况的分析和栈一样，上面的队列版本不存在异常导致数据丢失的问题。但是同样面临线程执行wait_and_pop时如果出现了异常，导致数据被滞留在队列中，其他线程也无法被唤醒的情况。 为了解决这种情况，我们前文提到了采用智能指针的方式，重新实现一下线程安全队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758template&lt;typename T&gt;class threadsafe_queue_ptr&#123;private: mutable std::mutex mut; std::queue&lt;std::shared_ptr&lt;T&gt;&gt; data_queue; std::condition_variable data_cond;public: threadsafe_queue_ptr() &#123;&#125; void wait_and_pop(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk, [this] &#123;return !data_queue.empty(); &#125;); value = std::move(*data_queue.front()); //⇽-- - 1 data_queue.pop(); &#125; bool try_pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if (data_queue.empty()) return false; value = std::move(*data_queue.front()); // ⇽-- - 2 data_queue.pop(); return true; &#125; std::shared_ptr&lt;T&gt; wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk, [this] &#123;return !data_queue.empty(); &#125;); std::shared_ptr&lt;T&gt; res = data_queue.front(); // ⇽-- - 3 data_queue.pop(); return res; &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if (data_queue.empty()) return std::shared_ptr&lt;T&gt;(); std::shared_ptr&lt;T&gt; res = data_queue.front(); // ⇽-- - 4 data_queue.pop(); return res; &#125; void push(T new_value) &#123; std::shared_ptr&lt;T&gt; data( std::make_shared&lt;T&gt;(std::move(new_value))); // ⇽-- - 5 std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(data); data_cond.notify_one(); &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); return data_queue.empty(); &#125;&#125;; 在5处，我们push数据时需要先构造智能指针，如果构造的过程失败了也就不会push到队列中，不会污染队列中的数据。 2，3处和4，5处我们仅仅时将智能指针取出来赋值给一个新的智能指针并返回。关于智能指针的赋值不会引发异常这一点在C++并发编程中提及，这一点我觉得有些存疑，我觉得书中表述的意思应该是指针在64位机器占用8个字节，所有智能指针共享引用计数所以在复制时仅为8字节开销，降低了内存消耗。 所以推荐大家存储数据放入容器中时尽量用智能指针，这样能保证复制和移动过程中开销较小，也可以实现一定意义的数据共享。 但是我们分析上面的代码，队列push和pop时采用的是一个mutex，导致push和pop等操作串行化，我们要考虑的是优化锁的精度，提高并发，那有什么办法吗？ 我们分析，队列和栈最本质的区别是队列是首尾操作。我们可以考虑将push和pop操作分化为分别对尾和对首部的操作。对首和尾分别用不同的互斥量管理就可以实现真正意义的并发了。 我们引入虚位节点的概念，表示一个空的节点，没有数据，是一个无效的节点，初始情况下，队列为空，head和tail节点都指向这个虚位节点。 当我们push一个数据，比如为MyClass类型的数据后，tail向后移动一个位置，并且仍旧指向这个虚位节点。 如下图 接下来我们实现这个版本的并发安全队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114template&lt;typename T&gt;class threadsafe_queue_ht&#123;private: struct node &#123; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; &#125;; std::mutex head_mutex; std::unique_ptr&lt;node&gt; head; std::mutex tail_mutex; node* tail; std::condition_variable data_cond; node* get_tail() &#123; std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); return tail; &#125; std::unique_ptr&lt;node&gt; pop_head() &#123; std::unique_ptr&lt;node&gt; old_head = std::move(head); head = std::move(old_head-&gt;next); return old_head; &#125; std::unique_lock&lt;std::mutex&gt; wait_for_data() &#123; std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex); data_cond.wait(head_lock,[&amp;] &#123;return head.get() != get_tail(); &#125;); //5 return std::move(head_lock); &#125; std::unique_ptr&lt;node&gt; wait_pop_head() &#123; std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data()); return pop_head(); &#125; std::unique_ptr&lt;node&gt; wait_pop_head(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data()); value = std::move(*head-&gt;data); return pop_head(); &#125; std::unique_ptr&lt;node&gt; try_pop_head() &#123; std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); if (head.get() == get_tail()) &#123; return std::unique_ptr&lt;node&gt;(); &#125; return pop_head(); &#125; std::unique_ptr&lt;node&gt; try_pop_head(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); if (head.get() == get_tail()) &#123; return std::unique_ptr&lt;node&gt;(); &#125; value = std::move(*head-&gt;data); return pop_head(); &#125;public: threadsafe_queue_ht() : // ⇽-- - 1 head(new node), tail(head.get()) &#123;&#125; threadsafe_queue_ht(const threadsafe_queue_ht&amp; other) = delete; threadsafe_queue_ht&amp; operator=(const threadsafe_queue_ht&amp; other) = delete; std::shared_ptr&lt;T&gt; wait_and_pop() // &lt;------3 &#123; std::unique_ptr&lt;node&gt; const old_head = wait_pop_head(); return old_head-&gt;data; &#125; void wait_and_pop(T&amp; value) // &lt;------4 &#123; std::unique_ptr&lt;node&gt; const old_head = wait_pop_head(value); &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::unique_ptr&lt;node&gt; old_head = try_pop_head(); return old_head ? old_head-&gt;data : std::shared_ptr&lt;T&gt;(); &#125; bool try_pop(T&amp; value) &#123; std::unique_ptr&lt;node&gt; const old_head = try_pop_head(value); return old_head; &#125; bool empty() &#123; std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); return (head.get() == get_tail()); &#125; void push(T new_value) //&lt;------2 &#123; std::shared_ptr&lt;T&gt; new_data( std::make_shared&lt;T&gt;(std::move(new_value))); std::unique_ptr&lt;node&gt; p(new node); node* const new_tail = p.get(); std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); tail-&gt;data = new_data; tail-&gt;next = std::move(p); tail = new_tail; &#125;&#125;; node为节点类型，包含data和next两个成员。 data为智能指针类型存储T类型的数据。next为指向下一个节点的智能指针，以此形成链表。 上述代码我们的head是一个node类型的智能指针。而tail为node类型的普通指针，读者也可以用智能指针。 在1处构造函数那里，我们将head和tail初始指向的位置设置为虚位节点。 在2 处我们push数据的时候先构造T类型的智能指针存储数据new_data，然后我们构造了一个新的智能指针p, p取出裸指针就是新的虚位节点new_tail，我们将new_data赋值给现在的尾节点，并且让尾节点的next指针指向p, 然后将tail更新为我们新的虚位节点。 3，4处都是wait_and_pop的不同版本，内部调用了wait_pop_head，wait_pop_head内部先调用wait_for_data判断队列是否为空，这里判断是否为空主要是判断head是否指向虚位节点。如果不为空则返回unique_lock，我们显示的调用了move操作，返回unique_lock仍保留对互斥量的锁住状态。 回到wait_pop_head中，接下来执行pop_head将数据pop出来。 值得注意的是get_tail()返回tail节点，那么我们思考如果此时有多个线程push数据，tail节点已经变化了，我们此时在5处的判断可能是基于push之前的tail信息，但是不影响逻辑，因为如果head和tail相等则线程挂起，等待通知，如果不等则继续执行，push操作只会将tail向后移动不会导致逻辑问题。 pop_head中我们将head节点移动给一个old_head变量，然后将old_head的next节点更新为新的head。这里我觉得可以简化写为head=head-&gt;next. 测试结果详见源码 总结本文介绍了线程安全情况下栈和队列的实现方式 源码链接: https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day14-ThreadSafeContainer 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用栅栏实现同步","date":"2023-11-11T23:47:48.000Z","path":"2023/11/12/concpp14/","text":"简介前文我们通过原子操作实战实现了无锁队列，今天完善一下无锁的原子操作剩余的知识，包括Relaese和Acquire内存序在什么情况下是存在危险的，以及我们可以利用栅栏机制实现同步等等。 线程可见顺序我们提到过除了memory_order_seq_cst顺序，其他的顺序都不能保证原子变量修改的值在其他多线程中看到的顺序是一致的。 但是可以通过同步机制保证一个线程对原子变量的修改对另一个原子变量可见。通过“Syncronizes With” 的方式达到先行的效果。 但是我们说的先行是指 “A Syncronizes With B ”， 如果A 的结果被B读取，则A 先行于B。 有时候我们线程1对A的store操作采用release内存序，而线程2对B的load采用acquire内存序，并不能保证A 一定比 B先执行。因为两个线程并行执行无法确定先后顺序，我们指的先行不过是说如果B读取了A操作的结果，则称A先行于B。 我们看下面的一段案例 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;cassert&gt;std::atomic&lt;bool&gt; x, y;std::atomic&lt;int&gt; z;void write_x()&#123; x.store(true, std::memory_order_release); //1&#125;void write_y()&#123; y.store(true, std::memory_order_release); //2&#125;void read_x_then_y()&#123; while (!x.load(std::memory_order_acquire)); if (y.load(std::memory_order_acquire)) //3 ++z;&#125;void read_y_then_x()&#123; while (!y.load(std::memory_order_acquire)); if (x.load(std::memory_order_acquire)) //4 ++z;&#125; 我们写一个函数测试，函数TestAR中初始化x和y为false， 启动4个线程a,b,c,d，分别执行write_x, write_y, read_x_then_y, read_y_then_x. 12345678910111213141516void TestAR()&#123; x = false; y = false; z = 0; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load() != 0); //5 std::cout &lt;&lt; &quot;z value is &quot; &lt;&lt; z.load() &lt;&lt; std::endl;&#125; 有的读者可能会觉5处的断言不会被触发，他们认为c和d肯定会有一个线程对z执行++操作。他们的思路是这样的。1 如果c线程执行read_x_then_y没有对z执行加加操作，那么说明c线程读取的x值为true, y值为false。2 之后d线程读取时，如果保证执行到4处说明y为true，等d线程执行4处代码时x必然为true。3 他们的理解是如果x先被store为true，y后被store为true，c线程看到y为false时x已经为true了，那么d线程y为true时x也早就为true了，所以z一定会执行加加操作。 上述理解是不正确的，我们提到过即便是releas和acquire顺序也不能保证多个线程看到的一个变量的值是一致的，更不能保证看到的多个变量的值是一致的。 变量x和y的载入操作3和4有可能都读取false值（与宽松次序的情况一样），因此有可能令断言触发错误。变量x和y分别由不同线程写出，所以两个释放操作都不会影响到对方线程。 看下图 无论x和y的store顺序谁先谁后，线程c和线程d读取的x和y顺序都不一定一致。 从CPU的角度我们可以这么理解 在一个4核CPU结构的主机上，a,b,c,d分别运行在不同的CPU内核上。 a执行x.store(true)先被线程c读取，而此时线程b对y的store还没有被c读取到新的值，所以此时c读取的x为true，y为false。 同样的道理，d可以读取b修改y的最新值，但是没来的及读取x的最新值，那么读取到y为true，x为false。 即使我们采用release和acquire方式也不能保证全局顺序一致。如果一个线程对变量执行release内存序的store操作，另一个线程不一定会马上读取到。这个大家要理解。 栅栏有时候我们可以通过栅栏保证指令编排顺序。 看下面一段代码 123456789101112131415161718192021222324252627#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x_then_y()&#123; x.store(true,std::memory_order_relaxed); // 1 y.store(true,std::memory_order_relaxed); // 2&#125;void read_y_then_x()&#123; while(!y.load(std::memory_order_relaxed)); // 3 if(x.load(std::memory_order_relaxed)) // 4 ++z;&#125;int main()&#123; x=false; y=false; z=0; std::thread a(write_x_then_y); std::thread b(read_y_then_x); a.join(); b.join(); assert(z.load()!=0); //5&#125; 上面的代码我们都采用的是memory_order_relaxed, 所以无法保证a线程将x,y修改后b线程看到的也是先修改x，再修改y的值。b线程可能先看到y被修改为true，x后被修改为true，那么b线程执行到4处时x可能为false导致z不会加加，5处断言会被触发。 那我们之前做法可以解决这个问题 123456789101112void write_x_then_y3()&#123; x.store(true, std::memory_order_relaxed); // 1 y.store(true, std::memory_order_release); // 2&#125;void read_y_then_x3()&#123; while (!y.load(std::memory_order_acquire)); // 3 if (x.load(std::memory_order_relaxed)) // 4 ++z;&#125; 可以通过std::memory_order_release和std::memory_order_acquire形成同步关系。 线程a执行write_x_then_y3，线程b执行read_y_then_x3，如果线程b执行到4处，说明y已经被线程a设置为true。 线程a执行到2，也必然执行了1，因为是memory_order_release的内存顺序，所以线程a能2操作之前的指令在2之前被写入内存。 同样的道理，线程b在3处执行的是memory_order_acquire的内存顺序，所以能保证4不会先于3写入内存，这样我们能知道1一定先行于4. 进而推断出z会加加，所以不会触发assert(z.load() != 0);的断言。 其实我们可以通过栅栏机制保证指令的写入顺序。栅栏的机制和memory_order_release类似。 1234567891011121314void write_x_then_y_fence()&#123; x.store(true, std::memory_order_relaxed); //1 std::atomic_thread_fence(std::memory_order_release); //2 y.store(true, std::memory_order_relaxed); //3&#125;void read_y_then_x_fence()&#123; while (!y.load(std::memory_order_relaxed)); //4 std::atomic_thread_fence(std::memory_order_acquire); //5 if (x.load(std::memory_order_relaxed)) //6 ++z;&#125; 我们写一个函数测试上面的逻辑 1234567891011void TestFence()&#123; x = false; y = false; z = 0; std::thread a(write_x_then_y_fence); std::thread b(read_y_then_x_fence); a.join(); b.join(); assert(z.load() != 0); //7&#125; 7处的断言也不会触发。我们可以分析一下， 线程a运行write_x_then_y_fence，线程b运行read_y_then_x_fence. 当线程b执行到5处时说明4已经结束，此时线程a看到y为true，那么线程a必然已经执行完3. 尽管4和3我们采用的是std::memory_order_relaxed顺序，但是通过逻辑关系保证了3的结果同步给4，进而”3 happens-before 4” 因为我们采用了栅栏std::atomic_fence所以，5处能保证6不会先于5写入内存，(memory_order_acquire保证其后的指令不会先于其写入内存) 2处能保证1处的指令先于2写入内存，进而”1 happens-before 6”, 1的结果会同步给 6 所以”atomic_thread_fence”其实和”release-acquire”相似，都是保证memory_order_release之前的指令不会排到其后，memory_order_acquire之后的指令不会排到其之前。 总结视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day13-fence","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"无锁并发的应用(无锁队列)","date":"2023-11-02T10:43:15.000Z","path":"2023/11/02/concpp13/","text":"简介前文介绍了如何通过内存顺序实现内存模型，本文基于前文的基础，利用内存顺序和内存模型的知识，带着大家探索无锁并发的应用，主要是通过无锁队列的实现来让大家熟悉无锁并发的实现方式。 环形队列我们要实现无锁并发，经常会用到一种结构无锁队列，而无锁队列和我们经常使用的队列颇有不同，它采用的是环状的队列结构，为什么成环呢？主要有两个好处，一个是成环的队列大小是固定的，另外一个我们通过移动头和尾就能实现数据的插入和取出。 我们看下图是一个环形队列的基本结构 图1表示队列为空的时候，头节点和尾节点交会在一起，指向同一个扇区。 图2表示当我们你插入一个数字1后，队列大小为1，此时tail指针移动到下一个扇区，head指向头部，1被存储在头部了。 图3表示当我们将数字1出队后，head指针向后移动一个扇区，此时head和tail指向同一个扇区，表示队列又为空了。那有人会问队列中数字1为什么不清空呢？其实不用清空，因为当我们插入新数据时就可以覆盖掉1这个无效的数据。 比如我们继续3图，连续插入几个数字，将队列填满。 图4说明的就是当我们连续插入了几个数字，插入数据9的时候将原来1的数据覆盖了，所以环形队列删除数据的时候我们不用让数据出队，只要移动head指针即可。 另外我们从图4也能看出，此时tail指向的位置正好是head的前一个位置，这种情况表示队列满了。 用锁实现环形队列我们可以用锁实现上述环形队列，在push和pop时分别加锁，并通过head和tail计算队列是否为满或者空。 代码比较简单，可以看看下面的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;memory&gt;template&lt;typename T, size_t Cap&gt;class CircularQueLk :private std::allocator&lt;T&gt; &#123;public: CircularQueLk() :_max_size(Cap + 1),_data(std::allocator&lt;T&gt;::allocate(_max_size)), _head(0), _tail(0) &#123;&#125; CircularQueLk(const CircularQueLk&amp;) = delete; CircularQueLk&amp; operator = (const CircularQueLk&amp;) volatile = delete; CircularQueLk&amp; operator = (const CircularQueLk&amp;) = delete; ~CircularQueLk() &#123; //循环销毁 std::lock_guard&lt;std::mutex&gt; lock(_mtx); //调用内部元素的析构函数 while (_head != _tail) &#123; std::allocator&lt;T&gt;::destroy(_data + _head); _head = （_head+1）% _max_size; &#125; //调用回收操作 std::allocator&lt;T&gt;::deallocate(_data, _max_size); &#125; //先实现一个可变参数列表版本的插入函数最为基准函数 template &lt;typename ...Args&gt; bool emplace(Args &amp;&amp; ... args) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mtx); //判断队列是否满了 if ((_tail + 1) % _max_size == _head) &#123; std::cout &lt;&lt; &quot;circular que full ! &quot; &lt;&lt; std::endl; return false; &#125; //在尾部位置构造一个T类型的对象，构造参数为args... std::allocator&lt;T&gt;::construct(_data + _tail, std::forward&lt;Args&gt;(args)...); //更新尾部元素位置 _tail = (_tail + 1) % _max_size; return true; &#125; //push 实现两个版本，一个接受左值引用，一个接受右值引用 //接受左值引用版本 bool push(const T&amp; val) &#123; std::cout &lt;&lt; &quot;called push const T&amp; version&quot; &lt;&lt; std::endl; return emplace(val); &#125; //接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用 // 但是因为我们实现了const T&amp; bool push(T&amp;&amp; val) &#123; std::cout &lt;&lt; &quot;called push T&amp;&amp; version&quot; &lt;&lt; std::endl; return emplace(std::move(val)); &#125; //出队函数 bool pop(T&amp; val) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mtx); //判断头部和尾部指针是否重合，如果重合则队列为空 if (_head == _tail) &#123; std::cout &lt;&lt; &quot;circular que empty ! &quot; &lt;&lt; std::endl; return false; &#125; //取出头部指针指向的数据 val = std::move(_data[_head]); //更新头部指针 _head = (_head + 1) % _max_size; return true; &#125;private: size_t _max_size; T* _data; std::mutex _mtx; size_t _head = 0; size_t _tail = 0;&#125;; 测试也比较简单，我们写一个函数，初始化队列大小为5，测试队列push满的情况和pop直到为空的情况 12345678910111213141516171819202122232425262728void TestCircularQue() &#123; //最大容量为10 CircularQueLk&lt;MyClass, 5&gt; cq_lk; MyClass mc1(1); MyClass mc2(2); cq_lk.push(mc1); cq_lk.push(std::move(mc2)); for (int i = 3; i &lt;= 5; i++) &#123; MyClass mc(i); auto res = cq_lk.push(mc); if (res == false) &#123; break; &#125; &#125; cq_lk.push(mc2); for (int i = 0; i &lt; 5; i++) &#123; MyClass mc1; auto res = cq_lk.pop(mc1); if (!res) &#123; break; &#125; std::cout &lt;&lt; &quot;pop success, &quot; &lt;&lt; mc1 &lt;&lt; std::endl; &#125; auto res = cq_lk.pop(mc1);&#125; 结果如下 1234567891011121314called push const T&amp; versioncalled push T&amp;&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncircular que full !pop success, MyClass Data is 1pop success, MyClass Data is 2pop success, MyClass Data is 3pop success, MyClass Data is 4pop success, MyClass Data is 5circular que empty ! 无锁队列那如果我们用原子变量而不是用锁实现环形队列，那就是无锁并发的队列了。还记得我们之前提到的原子变量的读改写操作吗？ 12bool std::atomic&lt;T&gt;::compare_exchange_weak(T &amp;expected, T desired);bool std::atomic&lt;T&gt;::compare_exchange_strong(T &amp;expected, T desired); compare_exchange_strong会比较原子变量atomic&lt;T&gt;的值和expected的值是否相等，如果相等则执行交换操作，将atomic&lt;T&gt;的值换为desired并且返回true,否则将expected的值修改为bool变量的值，并且返回false. 其伪代码可以这么理解 12345678template &lt;typename T&gt;bool atomic&lt;T&gt;::compare_exchange_strong(T &amp;expected, T desired) &#123; std::lock_guard&lt;std::mutex&gt; guard(m_lock); if (m_val == expected) return m_val = desired, true; else return expected = m_val, false;&#125; compare_exchange_weak功能比compare_exchange_strong弱一些，他不能保证atomic&lt;T&gt;的值和expected的值相等时也会做交换，很可能原子变量和预期值相等也会返回false，所以使用要多次循环使用。 我们们定义一个类CircularQueSeq, 其内容和之前我们定义的类CircularQueLk差不多，只不过将类的成员变量mutex换成atomic类型的原子变量, 我们可以利用自旋锁的思路将锁替换为原子变量循环检测的方式，进而达到锁住互斥逻辑的效果。 大家可以先看一下全部的代码感受一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129template&lt;typename T, size_t Cap&gt;class CircularQueSeq :private std::allocator&lt;T&gt; &#123;public: CircularQueSeq() :_max_size(Cap + 1), _data(std::allocator&lt;T&gt;::allocate(_max_size)), _atomic_using(false),_head(0), _tail(0) &#123;&#125; CircularQueSeq(const CircularQueSeq&amp;) = delete; CircularQueSeq&amp; operator = (const CircularQueSeq&amp;) volatile = delete; CircularQueSeq&amp; operator = (const CircularQueSeq&amp;) = delete; ~CircularQueSeq() &#123; //循环销毁 bool use_expected = false; bool use_desired = true; do &#123; use_expected = false; use_desired = true; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); //调用内部元素的析构函数 while (_head != _tail) &#123; std::allocator&lt;T&gt;::destroy(_data + _head); _head = （_head+1）% _max_size; &#125; //调用回收操作 std::allocator&lt;T&gt;::deallocate(_data, _max_size); do &#123; use_expected = true; use_desired = false; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); &#125; //先实现一个可变参数列表版本的插入函数最为基准函数 template &lt;typename ...Args&gt; bool emplace(Args &amp;&amp; ... args) &#123; bool use_expected = false; bool use_desired = true; do &#123; use_expected = false; use_desired = true; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); //判断队列是否满了 if ((_tail + 1) % _max_size == _head) &#123; std::cout &lt;&lt; &quot;circular que full ! &quot; &lt;&lt; std::endl; do &#123; use_expected = true; use_desired = false; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); return false; &#125; //在尾部位置构造一个T类型的对象，构造参数为args... std::allocator&lt;T&gt;::construct(_data + _tail, std::forward&lt;Args&gt;(args)...); //更新尾部元素位置 _tail = (_tail + 1) % _max_size; do &#123; use_expected = true; use_desired = false; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); return true; &#125; //push 实现两个版本，一个接受左值引用，一个接受右值引用 //接受左值引用版本 bool push(const T&amp; val) &#123; std::cout &lt;&lt; &quot;called push const T&amp; version&quot; &lt;&lt; std::endl; return emplace(val); &#125; //接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用 // 但是因为我们实现了const T&amp; bool push(T&amp;&amp; val) &#123; std::cout &lt;&lt; &quot;called push T&amp;&amp; version&quot; &lt;&lt; std::endl; return emplace(std::move(val)); &#125; //出队函数 bool pop(T&amp; val) &#123; bool use_expected = false; bool use_desired = true; do &#123; use_desired = true; use_expected = false; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); //判断头部和尾部指针是否重合，如果重合则队列为空 if (_head == _tail) &#123; std::cout &lt;&lt; &quot;circular que empty ! &quot; &lt;&lt; std::endl; do &#123; use_expected = true; use_desired = false; &#125; while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); return false; &#125; //取出头部指针指向的数据 val = std::move(_data[_head]); //更新头部指针 _head = (_head + 1) % _max_size; do &#123; use_expected = true; use_desired = false; &#125;while (!_atomic_using.compare_exchange_strong(use_expected, use_desired)); return true; &#125;private: size_t _max_size; T* _data; std::atomic&lt;bool&gt; _atomic_using; size_t _head = 0; size_t _tail = 0;&#125;; 我们可以看到emplace函数以及pop函数等将锁替换为原子变量。采用do while的方式就是因为compare_exchange_strong比较原子变量和use_expected的值不同的时候会使use_expected改变，所以我们需要在再次循环之前重置use_expected和use_desired的值。 我们可以写一个函数在单线程情况下下测试一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void TestCircularQueSeq()&#123; CircularQueSeq&lt;MyClass, 3&gt; cq_seq; for(int i = 0; i &lt; 4; i++) &#123; MyClass mc1(i); auto res = cq_seq.push(mc1); if(!res) &#123; break; &#125; &#125; for(int i = 0; i &lt; 4; i++) &#123; MyClass mc1; auto res = cq_seq.pop(mc1); if(!res) &#123; break; &#125; std::cout &lt;&lt; &quot;pop success, &quot; &lt;&lt; mc1 &lt;&lt; std::endl; &#125; for (int i = 0; i &lt; 4; i++) &#123; MyClass mc1(i); auto res = cq_seq.push(mc1); if (!res) &#123; break; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; MyClass mc1; auto res = cq_seq.pop(mc1); if (!res) &#123; break; &#125; std::cout &lt;&lt; &quot;pop success, &quot; &lt;&lt; mc1 &lt;&lt; std::endl; &#125;&#125; 运行结果 123456789101112131415161718called push const T&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncircular que full !pop success, MyClass Data is 0pop success, MyClass Data is 1pop success, MyClass Data is 2circular que empty !called push const T&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncalled push const T&amp; versioncircular que full !pop success, MyClass Data is 0pop success, MyClass Data is 1pop success, MyClass Data is 2circular que empty ! 多线程情况下也能保证安全是因为原子变量循环检测保证有且只有一个线程修改成功。读取也是这样。 单一原子变量的弊端我们考虑上述单一原子变量的弊端 多个线程push和pop操作耦合读太高，同一时刻仅有一个线程pop或者push，而且互斥逻辑的精度不够。影响效率。 我们需要考虑将pop和push操作解耦，我们采用的是环形队列，将tail和head作为原子变量可以实现精细控制。 比如我们做push操作的时候，一个线程更新万tail标签和数据后，其他线程就可以pop或者push了，精细控制的好处就是效率提升。 我们定义一个新的类CircularQueLight，类的基本数据结构和CircularQueSeq差不多。 1234567891011121314151617template&lt;typename T, size_t Cap&gt;class CircularQueLight: private std::allocator&lt;T&gt;&#123;public: CircularQueLight():_max_size(Cap + 1), _data(std::allocator&lt;T&gt;::allocate(_max_size)) , _head(0), _tail(0) &#123;&#125; CircularQueLight(const CircularQueLight&amp;) = delete; CircularQueLight&amp; operator = (const CircularQueLight&amp;) volatile = delete; CircularQueLight&amp; operator = (const CircularQueLight&amp;) = delete;private: size_t _max_size; T* _data; std::atomic&lt;size_t&gt; _head; std::atomic&lt;size_t&gt; _tail;&#125;; 我们将_head 和_tail 替换为原子变量。 接下来我们考虑pop逻辑 123456789101112131415161718bool pop(T&amp; val) &#123; size_t h; do &#123; h = _head.load(); //1 处 //判断头部和尾部指针是否重合，如果重合则队列为空 if(h == _tail.load()) &#123; return false; &#125; val = _data[h]; // 2处 &#125; while (!_head.compare_exchange_strong(h, (h+1)% _max_size)); //3 处 return true; &#125; 在pop逻辑里我们在1处load获取头部head的值，在2处采用了复制的方式将头部元素取出赋值给val，而不是通过std::move，因为多个线程同时pop最后只有一个线程成功执行3处代码退出，而失败的则需要继续循环，从更新后的head处pop元素。所以不能用std::move，否则会破坏原有的队列数据。 接下来我们来做push的函数逻辑 12345678910111213141516171819 bool push(T&amp; val)&#123; size_t t; do &#123; t = _tail.load(); //1 //判断队列是否满 if( (t+1)%_max_size == _head.load()) &#123; return false; &#125; _data[t] = val; //2 &#125; while (!_tail.compare_exchange_strong(t, (t + 1) % _max_size)); //3 return true;&#125; push函数的逻辑乍一看和pop一样，但是我们会发现多线程push的情况存在线程安全问题。 比如我们线程1 push(1) 而线程2 push(2). 很有可能的顺序是 1.1 -&gt; 1.2 -&gt; 2.1 -&gt; 2.2 -&gt; 1.3 这样我们看到的效果就是_data[t]被存储为2了，而实际情况应该是被存储为1，因为线程1的原子变量生效，而线程2的原子变量不满足需继续循环。所以_data[t]必须修改为1. 那我们改进一下push的函数 123456789101112131415161718192021 bool push(T&amp; val)&#123; size_t t; do &#123; t = _tail.load(); //1 //判断队列是否满 if( (t+1)%_max_size == _head.load()) &#123; return false; &#125; &#125; while (!_tail.compare_exchange_strong(t, (t + 1) % _max_size)); //3 _data[t] = val; //2 return true;&#125; 我们将2处的代码移动到循环之外，这样能保证多个线程push，仅有一个线程生效时，他写入的数据一定是本线程要写入到tail的数据，而此时tail被缓存在t里，那是一个线程本地变量，所以在这种情况下我们能确定即使多个线程运行到2处，他们的t值也是不同的，并不会产生线程安全问题。 毕竟多个线程push数据时对资源的竞争仅限tail。 但是这种push操作仍然会有安全问题 我们思考这种情况 此时head和tail都指向1这个位置，当我们执行push(9)时，按照我们的逻辑会先执行3再执行2. 也就是会先将tail移动，然后更新1的值为9. 那如果我们更新了tail之后，还没来的及更新1为9，那么此时如果有其他的线程读取head的值，会读取到1，而不是9. 从多线程安全角度来讲这是不安全的，我们理想的情况是一个线程写完数据后另一个线程读取的就是之前写入的最新值。 为了解决这个问题，我们可以增加另一个原子变量_tail_update来标记尾部数据是否修改完成，如果尾部数据没有修改完成，此时其他线程pop时获取的数据就是不安全的，所以pop要返回false。 先实现push版本 123456789101112131415161718192021222324252627 bool push(const T&amp; val)&#123; size_t t; do &#123; t = _tail.load(); //1 //判断队列是否满 if( (t+1)%_max_size == _head.load()) &#123; return false; &#125; &#125; while (!_tail.compare_exchange_strong(t, (t + 1) % _max_size)); //3 _data[t] = val; //2 size_t tailup; do &#123; tailup = t; &#125; while (_tail_update.compare_exchange_strong(tailup, (tailup + 1) % _max_size)); return true;&#125; 再实现pop版本 123456789101112131415161718192021222324bool pop(T&amp; val) &#123; size_t h; do &#123; h = _head.load(); //1 处 //判断头部和尾部指针是否重合，如果重合则队列为空 if(h == _tail.load()) &#123; return false; &#125; //判断如果此时要读取的数据和tail_update是否一致，如果一致说明尾部数据未更新完 if(h == _tail_update.load()) &#123; return false; &#125; val = _data[h]; // 2处 &#125; while (!_head.compare_exchange_strong(h, (h+1)% _max_size)); //3 处 return true; &#125; pop版本也是，先判断队列是否为空，再判断h是否和_tail_update的值相等，如果相等说明有写数据的没更新完，直接返回false或者循环等待也行，为了方便我们直接返回false即可。 因为我们知道原子操作默认采用的是memory_order_seq_cst内存顺序，性能上不是最优的，我们可以用acquire和release的内存顺序实现同步的效果。 优化性能我们用acquire和release模型优化上述代码，实现同步。最简单的方式就是将load的地方变为memory_order_relaxed，compare_exchange_strong的地方变为memory_order_release 我们先看pop操作 12345678910111213141516171819202122232425bool pop(T&amp; val) &#123; size_t h; do &#123; h = _head.load(std::memory_order_relaxed); //1 处 //判断头部和尾部指针是否重合，如果重合则队列为空 if (h == _tail.load(std::memory_order_acquire)) //2处 &#123; std::cout &lt;&lt; &quot;circular que empty ! &quot; &lt;&lt; std::endl; return false; &#125; //判断如果此时要读取的数据和tail_update是否一致，如果一致说明尾部数据未更新完 if (h == _tail_update.load(std::memory_order_acquire)) //3处 &#123; return false; &#125; val = _data[h]; // 2处 &#125; while (!_head.compare_exchange_strong(h, (h + 1) % _max_size, std::memory_order_release, std::memory_order_relaxed)); //4 处 std::cout &lt;&lt; &quot;pop data success, data is &quot; &lt;&lt; val &lt;&lt; std::endl; return true;&#125; 1 处为memory_order_relaxed是因为即使多个线程pop，每个线程获取的head可能不及时，这个没关系，因为我们有4处的while来重试。 2 compare_exchange_strong操作，在期望的条件匹配时采用memory_order_release, 期望的条件不匹配时memory_order_relaxed可以提升效率，毕竟还是要重试的。 我们再看push 操作 123456789101112131415161718192021222324252627282930bool push(const T&amp; val)&#123; size_t t; do &#123; t = _tail.load(std::memory_order_relaxed); //5 //判断队列是否满 if ((t + 1) % _max_size == _head.load(std::memory_order_acquire)) &#123; std::cout &lt;&lt; &quot;circular que full ! &quot; &lt;&lt; std::endl; return false; &#125; &#125; while (!_tail.compare_exchange_strong(t, (t + 1) % _max_size, std::memory_order_release, std::memory_order_relaxed)); //6 _data[t] = val; size_t tailup; do &#123; tailup = t; &#125; while (_tail_update.compare_exchange_strong(tailup, (tailup + 1) % _max_size, std::memory_order_release, std::memory_order_relaxed)); //7 std::cout &lt;&lt; &quot;called push data success &quot; &lt;&lt; val &lt;&lt; std::endl; return true;&#125; 两个线程协同工作，一个线程先push，另一个线程后pop，那么对于tail部分和_tail_update，我们要保证push的结果_data[t] = val;先于pop的结果val = _data[h]; 所以push线程中对于_tail_update的compare_exchange_strong操作采用memory_order_release方式。 pop线程对于_tail_update的load操作采用memory_order_acquire。 如果一个线程先pop，另一个线程先push，那么对于head部分，我们要保证pop的结果val = _data[h];先于pop的结果_data[t] = val;。 思考优势 无锁高并发. 虽然存在循环重试, 但是这只会在相同操作并发的时候出现. push 不会因为与 pop 并发而重试, 反之亦然. 缺陷 这样队列只应该存储标量, 如果存储类对象时，多个push线程只有一个线程push成功，而拷贝复制的开销很大，其他线程会循环重试，每次重试都会有开销。 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day12-circularque","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"用内存顺序实现内存模型","date":"2023-10-25T13:08:07.000Z","path":"2023/10/25/concpp12/","text":"前情回顾前文我们介绍了六种内存顺序，以及三种内存模型，本文通过代码示例讲解六种内存顺序使用方法，并实现相应的内存模型。 memory_order_seq_cstmemory_order_seq_cst代表全局一致性顺序，可以用于 store, load 和 read-modify-write 操作, 实现 sequencial consistent 的顺序模型. 在这个模型下, 所有线程看到的所有操作都有一个一致的顺序, 即使这些操作可能针对不同的变量, 运行在不同的线程. 我们看一下之前写的代码 123456789101112131415161718192021222324252627std::atomic&lt;bool&gt; x, y;std::atomic&lt;int&gt; z;void write_x_then_y() &#123; x.store(true, std::memory_order_relaxed); // 1 y.store(true, std::memory_order_relaxed); // 2&#125;void read_y_then_x() &#123; while (!y.load(std::memory_order_relaxed)) &#123; // 3 std::cout &lt;&lt; &quot;y load false&quot; &lt;&lt; std::endl; &#125; if (x.load(std::memory_order_relaxed)) &#123; //4 ++z; &#125;&#125;void TestOrderRelaxed() &#123; std::thread t1(write_x_then_y); std::thread t2(read_y_then_x); t1.join(); t2.join(); assert(z.load() != 0); // 5&#125; 上面的代码load和store都采用的是memory_order_relaxed。线程t1按次序执行1和2，但是线程t2看到的可能是y为true,x为false。进而导致TestOrderRelaxed触发断言z为0.如果换成memory_order_seq_cst则能保证所有线程看到的执行顺序是一致的。 1234567891011121314151617181920212223242526void write_x_then_y() &#123; x.store(true, std::memory_order_seq_cst); // 1 y.store(true, std::memory_order_seq_cst); // 2&#125;void read_y_then_x() &#123; while (!y.load(std::memory_order_seq_cst)) &#123; // 3 std::cout &lt;&lt; &quot;y load false&quot; &lt;&lt; std::endl; &#125; if (x.load(std::memory_order_seq_cst)) &#123; //4 ++z; &#125;&#125;void TestOrderSeqCst() &#123; std::thread t1(write_x_then_y); std::thread t2(read_y_then_x); t1.join(); t2.join(); assert(z.load() != 0); // 5&#125; 上面的代码x和y采用的是memory_order_seq_cst, 所以当线程t2执行到3处并退出循环时我们可以断定y为true，因为是全局一致性顺序，所以线程t1已经执行完2处将y设置为true，那么线程t1也一定执行完1处代码并对t2可见，所以当t2执行至4处时x为true，那么会执行z++保证z不为零，从而不会触发断言。 实现 sequencial consistent 模型有一定的开销. 现代 CPU 通常有多核, 每个核心还有自己的缓存. 为了做到全局顺序一致, 每次写入操作都必须同步给其他核心. 为了减少性能开销, 如果不需要全局顺序一致, 我们应该考虑使用更加宽松的顺序模型. memory_order_relaxedmemory_order_relaxed 可以用于 store, load 和 read-modify-write 操作, 实现 relaxed 的顺序模型.前文我们介绍过这种模型下, 只能保证操作的原子性和修改顺序 (modification order) 一致性, 无法实现 synchronizes-with 的关系。 123456789101112131415161718void TestOrderRelaxed() &#123; std::atomic&lt;bool&gt; rx, ry; std::thread t1([&amp;]() &#123; rx.store(true, std::memory_order_relaxed); // 1 ry.store(true, std::memory_order_relaxed); // 2 &#125;); std::thread t2([&amp;]() &#123; while (!ry.load(std::memory_order_relaxed)); //3 assert(rx.load(std::memory_order_relaxed)); //4 &#125;); t1.join(); t2.join();&#125; 上面的代码在一定程度上会触发断言。因为线程t1执行完1，2之后，有可能2操作的结果先放入内存中被t2看到，此时t2执行退出3循环进而执行4，此时t2看到的rx值为false触发断言。 我们称2和3不构成同步关系， 2 “ not synchronizes with “ 3 如果能保证2的结果立即被3看到, 那么称 2 “synchronizes with “ 3。 如果2 同步于 3还有一层意思就是 如果在线程t1 中 1 先于 2(sequence before)， 那么 1先行于3。那我们可以理解t2执行到3处时，可以获取到t1执行1操作的结果，也就是rx为true. t2线程中3先于4（sequence before），那么1 操作先行于 4. 也就是1 操作的结果可以立即被4获取。进而不会触发断言。 怎样保证2 同步于 3 是解决问题的关键， 我们引入 Acquire-Release 内存顺序。 Acquire-Release在 acquire-release 模型中, 会使用 memory_order_acquire, memory_order_release 和 memory_order_acq_rel 这三种内存顺序. 它们的用法具体是这样的: 对原子变量的 load 可以使用 memory_order_acquire 内存顺序. 这称为 acquire 操作. 对原子变量的 store 可以使用 memory_order_release 内存顺序. 这称为 release 操作. read-modify-write 操作即读 (load) 又写 (store), 它可以使用 memory_order_acquire, memory_order_release 和 memory_order_acq_rel: 如果使用 memory_order_acquire, 则作为 acquire 操作; 如果使用 memory_order_release, 则作为 release 操作; 如果使用 memory_order_acq_rel, 则同时为两者. Acquire-release 可以实现 synchronizes-with 的关系. 如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值, 则这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们可以通过Acquire-release 修正 TestOrderRelaxed函数以达到同步的效果 1234567891011121314151617void TestReleaseAcquire() &#123; std::atomic&lt;bool&gt; rx, ry; std::thread t1([&amp;]() &#123; rx.store(true, std::memory_order_relaxed); // 1 ry.store(true, std::memory_order_release); // 2 &#125;); std::thread t2([&amp;]() &#123; while (!ry.load(std::memory_order_acquire)); //3 assert(rx.load(std::memory_order_relaxed)); //4 &#125;); t1.join(); t2.join();&#125; 上面的例子中我们看到ry.store使用的是std::memory_order_release, ry.load使用的是std::memory_order_relaxed. t1执行到2将ry 设置为true, 因为使用了Acquire-release 顺序， 所以 t2 执行到3时读取ry为true， 因此2和3 可以构成同步关系。 又因为单线程t1内 1 sequence before 2,所以1 happens-before 3.因为单线程t2内 3 sequence before 4. 所以 1 happens-before 4. 可以断定4 不会触发断言。 我们从cpu结构图理解这一情景 到此大家一定要记住仅 Acquire-release能配合达到 synchronizes-with效果，再就是memory_order_seq_cst可以保证全局顺序唯一，其他情况的内存顺序都能保证顺序，使用时需注意。 Acquire-release 的开销比 sequencial consistent 小. 在 x86 架构下, memory_order_acquire 和 memory_order_release 的操作不会产生任何其他的指令, 只会影响编译器的优化: 任何指令都不能重排到 acquire 操作的前面, 且不能重排到 release 操作的后面; 否则会违反 acquire-release 的语义. 因此很多需要实现 synchronizes-with 关系的场景都会使用 acquire-release. Release sequences我们再考虑一种情况，多个线程对同一个变量release操作，另一个线程对这个变量acquire，那么只有一个线程的release操作喝这个acquire线程构成同步关系。 看下面的代码 ： 1234567891011121314151617181920212223void ReleasAcquireDanger2() &#123; std::atomic&lt;int&gt; xd&#123;0&#125;, yd&#123; 0 &#125;; std::atomic&lt;int&gt; zd; std::thread t1([&amp;]() &#123; xd.store(1, std::memory_order_release); // (1) yd.store(1, std::memory_order_release); // (2) &#125;); std::thread t2([&amp;]() &#123; yd.store(2, std::memory_order_release); // (3) &#125;); std::thread t3([&amp;]() &#123; while (!yd.load(std::memory_order_acquire)); //（4） assert(xd.load(std::memory_order_acquire) == 1); // (5) &#125;); t1.join(); t2.join(); t3.join();&#125; 我们可以看到t3在yd为true的时候才会退出，那么导致yd为true的有两种情况，一种是1，另一种是2， 所以5处可能触发断言。 并不是只有在 acquire 操作读取到 release 操作写入的值时才能构成 synchronizes-with 关系. 为了说这种情况, 我们需要引入 release sequence 这个概念. 针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. 如果这一连串操作是由 同一线程上的写操作 任意线程上的 read-modify-write 操作这两种构成的, 则称这一连串的操作为以 release 操作 A 为首的 release sequence. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序. 如果一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作. 看下面的代码 123456789101112131415161718192021222324void ReleaseSequence() &#123; std::vector&lt;int&gt; data; std::atomic&lt;int&gt; flag&#123; 0 &#125;; std::thread t1([&amp;]() &#123; data.push_back(42); //(1) flag.store(1, std::memory_order_release); //(2) &#125;); std::thread t2([&amp;]() &#123; int expected = 1; while (!flag.compare_exchange_strong(expected, 2, std::memory_order_relaxed)) // (3) expected = 1; &#125;); std::thread t3([&amp;]() &#123; while (flag.load(std::memory_order_acquire) &lt; 2); // (4) assert(data.at(0) == 42); // (5) &#125;); t1.join(); t2.join(); t3.join();&#125; 我们考虑t3要想退出首先flag要等于2，那么就要等到t2将flag设置为2，而flag设置为2又要等到t1将flag设置为1. 所以我们捋一下顺序 2-&gt;3-&gt;4 t1中操作2是release操作，以2为开始，其他线程(t2)的读改写在release操作之后，我们称之为release sequence， t3要读取release sequence写入的值，所以我们称t1的release操作 “synchronizes with “ t3的 acquire 操作。 memory_order_consumememory_order_consume 其实是 acquire-release 模型的一部分, 但是它比较特殊, 它涉及到数据间相互依赖的关系. 就是前文我们提及的 carries dependency和 dependency-ordered before. 我们复习一下 如果操作 a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 一般来说, 如果 a 的值用作 b 的一个操作数, 或者 b 读取到了 a 写入的值, 都可以称为 b 依赖于 a 123p++; // (1)i++; // (2)p[i] // (3) (1) “sequenced-before” (2), (2) “sequenced-before” (3), 而(1)和(2)的值作为(3)的下表运算符[]的操作数。 我们可以称(1) “carries a dependency into “ (3), (2) “carries a dependency into “ (3), 但是(1)和(2)不是依赖关系。 memory_order_consume 可以用于 load 操作. 使用 memory_order_consume 的 load 称为 consume 操作. 如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值, 或以其为首的 release sequence 写入的值, 则这个 release 操作 “dependency-ordered before” 这个 consume 操作. 看下面这个例子 1234567891011121314151617181920void ConsumeDependency() &#123; std::atomic&lt;std::string*&gt; ptr; int data; std::thread t1([&amp;]() &#123; std::string* p = new std::string(&quot;Hello World&quot;); // (1) data = 42; // (2) ptr.store(p, std::memory_order_release); // (3) &#125;); std::thread t2([&amp;]() &#123; std::string* p2; while (!(p2 = ptr.load(std::memory_order_consume))); // (4) assert(*p2 == &quot;Hello World&quot;); // (5) assert(data == 42); // (6) &#125;); t1.join(); t2.join();&#125; t2执行到(4)处时，需要等到ptr非空才能退出循环，这就依赖t1执行完(3)操作。 因此(3) “dependency-ordered before” (4), 根据前文我们介绍了dependency等同于synchronizes ，所以(3) “inter-thread happens-before”. （4） 因为(2) “sequenced before” (3), 所以(2) “happens-before “ (4) 因为(4) “sequenced before” (5), 所以(2) “happens-before “ (5) 因为(5) “sequenced before” (6), 所以(2) “happens-before “ (6) 所以(6)处断言不会触发，同样的道理(5)处断言也不会触发。 单例模式改良还记得我们之前用智能指针双重检测方式实现的单例模式吗？我当时说过是存在线程安全问题的，看看下面这段单例模式 1234567891011121314151617181920212223242526272829303132333435363738//利用智能指针解决释放问题class SingleAuto&#123;private: SingleAuto() &#123; &#125; SingleAuto(const SingleAuto&amp;) = delete; SingleAuto&amp; operator=(const SingleAuto&amp;) = delete;public: ~SingleAuto() &#123; std::cout &lt;&lt; &quot;single auto delete success &quot; &lt;&lt; std::endl; &#125; static std::shared_ptr&lt;SingleAuto&gt; GetInst() &#123; // 1 处 if (single != nullptr) &#123; return single; &#125; // 2 处 s_mutex.lock(); // 3 处 if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; // 4处 single = std::shared_ptr&lt;SingleAuto&gt;(new SingleAuto); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAuto&gt; single; static std::mutex s_mutex;&#125;; 我们写一段代码测试一下 123456789101112131415std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = nullptr;std::mutex SingleAuto::s_mutex;void TestSingle() &#123; std::thread t1([]() &#123; std::cout &lt;&lt; &quot;thread t1 singleton address is 0X: &quot; &lt;&lt; SingleAuto::GetInst() &lt;&lt; std::endl; &#125;); std::thread t2([]() &#123; std::cout &lt;&lt; &quot;thread t2 singleton address is 0X: &quot; &lt;&lt; SingleAuto::GetInst() &lt;&lt; std::endl; &#125;); t2.join(); t1.join();&#125; 虽然可以正常输出两次的地址都是同一个，但是我们的单例会存在安全隐患。1处和4处代码存在线程安全问题，因为4处代码在之前的文章中我谈过，new一个对象再赋值给变量时会存在多个指令顺序 第一种情况 1231 为对象allocate一块内存空间2 调用construct构造对象3 将构造到的对象地址返回 第二种情况 1231 为对象allocate一块内存空间2 先将开辟的空间地址返回3 调用construct构造对象 如果是第二种情况，在4处还未构造对象就将地址返回赋值给single，而此时有线程运行至1处判断single不为空直接返回单例实例，如果该线程调用这个单例的成员函数就会崩溃。 为了解决这个问题，我们可以通过内存模型来解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344//利用智能指针解决释放问题class SingleMemoryModel&#123;private: SingleMemoryModel() &#123; &#125; SingleMemoryModel(const SingleMemoryModel&amp;) = delete; SingleMemoryModel&amp; operator=(const SingleMemoryModel&amp;) = delete;public: ~SingleMemoryModel() &#123; std::cout &lt;&lt; &quot;single auto delete success &quot; &lt;&lt; std::endl; &#125; static std::shared_ptr&lt;SingleMemoryModel&gt; GetInst() &#123; // 1 处 if (_b_init.load(std::memory_order_acquire)) &#123; return single; &#125; // 2 处 s_mutex.lock(); // 3 处 if (_b_init.load(std::memory_order_relaxed)) &#123; s_mutex.unlock(); return single; &#125; // 4处 single = std::shared_ptr&lt;SingleMemoryModel&gt;(new SingleMemoryModel); _b_init.store(true, std::memory_order_release); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleMemoryModel&gt; single; static std::mutex s_mutex; static std::atomic&lt;bool&gt; _b_init ;&#125;;std::shared_ptr&lt;SingleMemoryModel&gt; SingleMemoryModel::single = nullptr;std::mutex SingleMemoryModel::s_mutex;std::atomic&lt;bool&gt; SingleMemoryModel::_b_init = false; 然后我们测试 123456789101112void TestSingleMemory() &#123; std::thread t1([]() &#123; std::cout &lt;&lt; &quot;thread t1 singleton address is 0x: &quot; &lt;&lt; SingleMemoryModel::GetInst() &lt;&lt; std::endl; &#125;); std::thread t2([]() &#123; std::cout &lt;&lt; &quot;thread t2 singleton address is 0x: &quot; &lt;&lt; SingleMemoryModel::GetInst() &lt;&lt; std::endl; &#125;); t2.join(); t1.join();&#125; 也可以看到输出的地址一致，但是我们这个改进的版本防止了线程安全问题。 总结本文介绍了如何通过内存顺序实现内存模型，以及优化了单例模式。 源码链接 https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day11-AcquireRelease 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 原子操作和内存模型","date":"2023-10-16T05:57:33.000Z","path":"2023/10/16/concpp11/","text":"简介本文介绍C++ 内存模型相关知识，包含几种常见的内存访问策略。 改动序列在一个C++程序中，每个对象都具有一个改动序列，它由所有线程在对象上的全部写操作构成，其中第一个写操作即为对象的初始化。大部分情况下，这个序列会随程序的多次运行而发生变化，但是在程序的任意一次运行过程中，所含的全部线程都必须形成相同的改动序列。 改动序列基本要求如下 1 只要某线程看到过某个对象，则该线程的后续读操作必须获得相对新近的值，并且，该线程就同一对象的后续写操作，必然出现在改动序列后方。2 如果某线程先向一个对象写数据，过后再读取它，那么必须读取前面写的值。3 若在改动序列中，上述读写操作之间还有别的写操作，则必须读取最后写的值。4 在程序内部，对于同一个对象，全部线程都必须就其形成相同的改动序列，并且在所有对象上都要求如此.5 多个对象上的改动序列只是相对关系，线程之间不必达成一致 原子类型标准原子类型的定义位于头文件&lt;atomic&gt;内。我们可以通过atomic&lt;&gt;定义一些原子类型的变量，如atomic&lt;bool&gt;,atomic&lt;int&gt; 这些类型的操作全是原子化的。 从C++17开始，所有的原子类型都包含一个静态常量表达式成员变量，std::atomic::is_always_lock_free。这个成员变量的值表示在任意给定的目标硬件上，原子类型X是否始终以无锁结构形式实现。如果在所有支持该程序运行的硬件上，原子类型X都以无锁结构形式实现，那么这个成员变量的值就为true；否则为false。 只有一个原子类型不提供is_lock_free()成员函数：std::atomic_flag 。类型std::atomic_flag的对象在初始化时清零，随后即可通过成员函数test_and_set()查值并设置成立，或者由clear()清零。整个过程只有这两个操作。其他的atomic&lt;&gt;的原子类型都可以基于其实现。 std::atomic_flag的test_and_set成员函数是一个原子操作，他会先检查std::atomic_flag当前的状态是否被设置过， 1 如果没被设置过(比如初始状态或者清除后)，将std::atomic_flag当前的状态设置为true，并返回false。 2 如果被设置过则直接返回ture。 对于std::atomic&lt;T&gt;类型的原子变量，还支持load()和store()、exchange()、compare_exchange_weak()和compare_exchange_strong()等操作。 内存次序对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类std::memory_order取值，用于设定所需的内存次序语义（memory-ordering semantics）。 枚举类std::memory_order具有6个可能的值， 包括std::memory_order_relaxed、std:: memory_order_acquire、std::memory_order_consume、 std::memory_order_acq_rel、std::memory_order_release和 std::memory_order_seq_cst。 存储（store）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_release或std::memory_order_seq_cst。 载入（load）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire或std::memory_order_seq_cst。 “读-改-写”（read-modify-write）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire、std::memory_order_release、std::memory_order_acq_rel或std::memory_order_seq_cst。 原子操作默认使用的是std::memory_order_seq_cst次序。 这六种内存顺序相互组合可以实现三种顺序模型 (ordering model) Sequencial consistent ordering. 实现同步, 且保证全局顺序一致 (single total order) 的模型. 是一致性最强的模型, 也是默认的顺序模型.Acquire-release ordering. 实现同步, 但不保证保证全局顺序一致的模型.Relaxed ordering. 不能实现同步, 只保证原子性的模型. 实现自旋锁自旋锁是一种在多线程环境下保护共享资源的同步机制。它的基本思想是，当一个线程尝试获取锁时，如果锁已经被其他线程持有，那么该线程就会不断地循环检查锁的状态，直到成功获取到锁为止。 那我们用这个std:atomic_flag实现一个自旋锁。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;thread&gt;class SpinLock &#123;public: void lock() &#123; //1 处 while (flag.test_and_set(std::memory_order_acquire)); // 自旋等待，直到成功获取到锁 &#125; void unlock() &#123; //2 处 flag.clear(std::memory_order_release); // 释放锁 &#125;private: std::atomic_flag flag = ATOMIC_FLAG_INIT;&#125;; 我们实现一个测试函数 12345678910111213141516171819202122232425void TestSpinLock() &#123; SpinLock spinlock; std::thread t1([&amp;spinlock]() &#123; spinlock.lock(); for (int i = 0; i &lt; 3; i++) &#123; std::cout &lt;&lt; &quot;*&quot;; &#125; std::cout &lt;&lt; std::endl; spinlock.unlock(); &#125;); std::thread t2([&amp;spinlock]() &#123; spinlock.lock(); for (int i = 0; i &lt; 3; i++) &#123; std::cout &lt;&lt; &quot;?&quot;; &#125; std::cout &lt;&lt; std::endl; spinlock.unlock(); &#125;); t1.join(); t2.join();&#125; 在主函数执行上述代码会看到如下输出 12***??? 1 处 在多线程调用时，仅有一个线程在同一时刻进入test_and_set，因为atomic_flag初始状态为false,所以test_and_set将atomic_flag设置为true，并且返回false。 比如线程A调用了test_and_set返回false，这样lock函数返回，线程A继续执行加锁区域的逻辑。此时线程B调用test_and_set，test_and_set会返回true,导致线程B在while循环中循环等待，达到自旋检测标记的效果。当线程A直行至2处调用clear操作后，atomic_flag被设置为清空状态，线程B调用test_and_set会将状态设为成立并返回false，B线程执行加锁区域的逻辑。 我们看到在设置时使用memory_order_acquire内存次序，在清除时使用了memory_order_release内存次序。 宽松内存序为了给大家介绍不同的字节序，我们先从最简单的字节序std::memory_order_relaxed(宽松字节序)介绍。因为字节序是为了实现改动序列的，所以为了理解字节序还要结合改动序列讲起。 我们先看一个CPU和内存结构图 其中StoreBuffer就是一级Cache， Catche是二级Cache，Memory是三级Cache。 每个标识CPU的块就是core，上图画的就是4核结构。每两个core构成一个bank，共享一个cache。四个core共享memory。 每个CPU所作的store均会写到store buffer中，每个CPU会在任何时刻将store buffer中结果写入到cache或者memory中。 那该如何保证数据一致性？这就要提及MESI一致性协议。 MESI 协议，是一种叫作写失效（Write Invalidate）的协议。在写失效协议里，只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。 MESI 协议对应的四个不同的标记，分别是： M：代表已修改（Modified） E：代表独占（Exclusive） S：代表共享（Shared） I：代表已失效（Invalidated） “已修改”用来告诉其他cpu已经修改完成，其他cpu可以向cache中写入数据。 “独占”表示数据只是加载到当前 CPU核 的store buffer中，其他的 CPU 核，并没有加载对应的数据到自己的 store buffer 里。 这个时候，如果要向独占的 store buffer 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。 那么对应的，共享状态就是在多核中同时加载了同一份数据。所以在共享状态下想要修改数据要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 cache ，都变成无效的状态，然后再更新当前 cache 里面的数据。 我们可以这么理解，如果变量a此刻在各个cpu的StoreBuffer中，那么CPU1核修改这个a的值，放入cache时通知其他CPU核写失效，因为同一时刻仅有一个CPU核可以写数据，但是其他CPU核是可以读数据的，那么其他核读到的数据可能是CPU1核修改之前的。这就涉及我们提到的改动序列了。 这里给大家简单介绍两个改动序列的术语 1 “synchronizes-with“ : 同步, “A synchronizes-with B” 的意思就是 A和B同步，简单来说如果多线程环境下，有一个线程先修改了变量m，我们将这个操作叫做A，之后有另一个线程读取变量m，我们将这个操作叫做B，那么B一定读取A修改m之后的最新值。也可以称作 A “happens-before“ B，即A操作的结果对B操作可见。 2 “happens-before“ : 先行，”A happens-before B” 的意思是如果A操作先于B操作，那么A操作的结果对B操作可见。”happens-before“包含很多种境况，不仅仅是我们上面提到的”synchronizes-with“,之后给大家一个脑图详细说明”happens-before“的几种情况。 我们接下来谈谈std::memory_order_relaxed。 关于std::memory_order_relaxed具备如下几个功能： 1 作用于原子变量2 不具有synchronizes-with关系3 对于同一个原子变量，在同一个线程中具有happens-before关系, 在同一线程中不同的原子变量不具有happens-before关系，可以乱序执行。4 多线程情况下不具有happens-before关系。 由上述可知，如果采用最松散的内存顺序模型，在一个线程中，如果某个表达式已经看到原子变量的某个值a，则该表达式的后续表达式只能看到a或者比a更新的值。 我们看下面的代码 123456789101112131415161718std::atomic&lt;bool&gt; x, y;std::atomic&lt;int&gt; z;void write_x_then_y() &#123; x.store(true, std::memory_order_relaxed); // 1 y.store(true, std::memory_order_relaxed); // 2&#125;void read_y_then_x() &#123; while (!y.load(std::memory_order_relaxed)) &#123; // 3 std::cout &lt;&lt; &quot;y load false&quot; &lt;&lt; std::endl; &#125; if (x.load(std::memory_order_relaxed)) &#123; //4 ++z; &#125;&#125; 上面的代码封装了两个函数，write_x_then_y负责将x和y存储为true。read_y_then_x负责读取x和y的值。 接下来我们写如下函数调用上面的两个函数 1234567void TestOrderRelaxed() &#123; std::thread t1(write_x_then_y); std::thread t2(read_y_then_x); t1.join(); t2.join(); assert(z.load() != 0); // 5&#125; 上面的代码assert断言z不为0，但有时运行到5处z会等于0触发断言。 我们从两个角度分析 1 从cpu架构分析 假设线程t1运行在CPU1上，t2运行在CPU3上，那么t1对x和y的操作，t2是看不到的。 比如当线程t1运行至1处将x设置为true，t1运行至2处将y设置为true。这些操作仅在CPU1的store buffer中，还未放入cache和memory中，CPU2自然不知道。 如果CPU1先将y放入memory，那么CPU2就会读取y的值为true。那么t2就会运行至3处从while循环退出，进而运行至4处，此时CPU1还未将x的值写入memory， t2读取的x值为false，进而线程t2运行结束，然后CPU1将x写入true, t1结束运行，最后主线程运行至5处，因为z为0,所以触发断言。 2 从宽松内存序分析 因为memory_order_relaxed是宽松的内存序列，它只保证操作的原子性，并不能保证多个变量之间的顺序性，也不能保证同一个变量在不同线程之间的可见顺序。 比如t1可能先运行2处代码再运行1处代码，因为我们的代码会被编排成指令执行，编译器在不破坏语义的情况下(2处和1处代码无耦合，可调整顺序)，2可能先于1执行。如果这样，t2运行至3处退出while循环，继续运行4处，此时t1还未执行1初代码，则t2运行4处条件不成立不会对z做增加，t2结束。这样也会导致z为0引发断言。 画个图说明上述情况 我们在看一个例子 12345678910111213141516171819202122232425262728293031323334353637383940void TestOderRelaxed2() &#123; std::atomic&lt;int&gt; a&#123; 0 &#125;; std::vector&lt;int&gt; v3, v4; std::thread t1([&amp;a]() &#123; for (int i = 0; i &lt; 10; i += 2) &#123; a.store(i, std::memory_order_relaxed); &#125; &#125;); std::thread t2([&amp;a]() &#123; for (int i = 1; i &lt; 10; i += 2) a.store(i, std::memory_order_relaxed); &#125;); std::thread t3([&amp;v3, &amp;a]() &#123; for (int i = 0; i &lt; 10; ++i) v3.push_back(a.load(std::memory_order_relaxed)); &#125;); std::thread t4([&amp;v4, &amp;a]() &#123; for (int i = 0; i &lt; 10; ++i) v4.push_back(a.load(std::memory_order_relaxed)); &#125;); t1.join(); t2.join(); t3.join(); t4.join(); for (int i : v3) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; for (int i : v4) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125; 线程t1向a中存储偶数,线程t2向a中存储奇数。线程t3从a读取数据写入v3中，线程t4从线程a中读取数据写入v4中。这四个线程并发执行，最后打印v3和v4的数据。如果机器性能足够好我们看到的可能是这种输出 129 9 9 9 9 9 9 9 9 99 9 9 9 9 9 9 9 9 9 也可能是这种 120 1 7 6 8 9 9 9 9 9 0 2 1 4 5 7 6 8 9 9 但我们能确定的是如果v3中7先于6，8，9等，那么v4中也是7先于6，8，9。 因为多个线程仅操作了a变量，通过memory_order_relaxed的方式仅能保证对a的操作是原子的(同一时刻仅有一个线程写a的值，但是可能多个线程读取a的值)。 但是多个线程之间操作不具备同步关系，也就是线程t1将a改为7，那么线程t3不知道a改动的最新值为7，它读到a的值为1。只是要过一阵子可能会读到7或者a变为7之后又改动的其他值。 但是t3,t4两个线程读取a的次序是一致的，比如t3和t4都读取了7和9，t3读到7在9之前，那么t4也读取到7在9之前。 因为我们memory_order_relaxed保证了多线程对同一个变量的原子操作的安全性，只是可见性会有延迟罢了。 先行(Happens-before)Happens-before 是一个非常重要的概念. 如前文我们提及：如果操作 a “happens-before” 操作 b, 则操作 a 的结果对于操作 b 可见. happens-before 的关系可以建立在用一个线程的两个操作之间, 也可以建立在不同的线程的两个操作之间。 顺序先行(sequenced-before)单线程情况下前面的语句先执行，后面的语句后执行。操作a先于操作b，那么操作b可以看到操作a的结果。我们称操作a顺序先行于操作b。也就是”a sequenced-before b”。 这种情况下”a happens before b” 比如下面 123456int main()&#123; //操作a int m = 100; //操作b std::cout &lt;&lt; &quot;m is &quot; &lt;&lt; std::endl;&#125; 上面操作b 能读取m的值为100. “sequencde-before”具备传递性，比如操作 a “sequenced-before” 操作 b, 且操作 b “sequenced-before” 操作 m, 则操作 a “sequenced-before” 操作 m. 线程间先行线程间先行又叫做”inter-thread-happens-before”，这是多线程情况的”happens-before”. 我们前面提到的”synchronizes-with” 可以构成 “happens-before”。 如果线程 1 中的操作 a “synchronizes-with” 线程 2 中的操作 b, 则操作 a “inter-thread happens-before” 操作 b. 此外 synchronizes-with 还可以 “后接” 一个 sequenced-before 关系组合成 inter-thread happens-before 的关系: 比如操作 a “synchronizes-with” 操作 b, 且操作 b “sequenced-before” 操作 m, 则操作 a “inter-thread happens-before” 操作 m. 那同样的道理， Inter-thread happens-before 关系则可以 “前接” 一个 sequenced-before 关系以延伸它的范围; 而且 inter-thread happens-before 关系具有传递性: 1 如果操作 a “sequenced-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b. 2 如果操作 a “inter-thread happens-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b. 依赖关系依赖关系有 carries dependency 和 dependency-ordered before. 单线程情况下a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 称作 a 将依赖关系带给 b, 也理解为b依赖于a。 看下面的代码 12345678void TestDependency() &#123; // 1 处 std::string str = &quot;hello world!&quot;; // 2 处 int i = 3; // 3 处 std::cout &lt;&lt; str[i] &lt;&lt; std::endl;&#125; 函数TestDependency内部打印str[i]的值。3处代码需要依赖1处和2处两个变量的值，所以达成依赖关系。 我们看单线程情况下按顺序执行1，2，3处代码，1 “sequenced-before” 3，且3 依赖 1的数据，则 1 “carries a dependency into” 3 同样的道理 2 “sequenced-before” 3, 且3依赖2 的数据，则2 “carries a dependency into” 3. “carries a dependency into” 也被归为”happens-before”。 2 多线程情况下 线程1执行操作A(比如对i自增)，线程2执行操作B(比如根据i访问字符串下表的元素), 如果线程1先于线程2执行，且操作A的结果对操作B可见，我们将这种叫做A “dependency-ordered before” B. 有人会说这不是前面说到的A “synchronizes with “ B吗？你可以这么理解。就当作他们达到的效果是一致的，只不过A “dependency-ordered before” B 更细化一点，表述了一种依赖，比如操作A仅仅对i增加，而没有对字符串修改。而操作B需要通过i访问字符串数据。那操作B实际上是依赖于A的。 Happens-before不代表指令执行顺序Happens-before不代表指令实际执行顺序，C++编译器可以对不相关的指令任意编排达到优化效果，Happens-before仅是C++语义层面的描述，表示 a “Happens-before” b仅能说明a操作的结果对b操作可见。 看这样一段代码 123456789int Add() &#123; int a = 0, b = 0; //1 处 a++; // 2 处 b++; // 3 处 return a + b;&#125; 单线程执行上述代码，操作1一定是happens-before 操作2 的(a “sequenced-before” b)，就是我们理解的 a++ 先于 b++。 但是计算机的指令可能不是这样，一条C++语句对于多条计算机指令。 有可能是先将b值放入寄存器eax做加1，再将a的值放入寄存器edx做加1，然后再将eax寄存器的值写回a，将edx写回b。 因为对于计算机来说1处操作和2处操作的顺序对于3处来说并无影响。只要3处返回a+b之前能保证a和b的值是增加过的即可。 那我们语义上的”Happens-before”有意义吗？ 是有意义的，因为如果 a “sequenced-before” b, 那么无论指令如何编排，最终写入内存的顺序一定是a先于b。 只不过C++编译器不断优化尽可能不造成指令编排和语义理解的差异，上面C++的代码转换为汇编指令如下 1234567891011121314151617 int a = 0, b = 0;00A1C8F5 mov dword ptr [a],0 00A1C8FC mov dword ptr [b],0 //1 处 a++; 00A1C903 mov eax,dword ptr [a] 00A1C906 add eax,1 00A1C909 mov dword ptr [a],eax // 2 处 b++;00A1C90C mov eax,dword ptr [b] 00A1C90F add eax,1 00A1C912 mov dword ptr [b],eax return a + b;00A1C915 mov eax,dword ptr [a] 00A1C918 add eax,dword ptr [b] 可以看到C++编译器尽可能不造成语义理解和指令编排上的歧义。 脑图我们将”happens-before” 的几种情况做成脑图，方便理解 我们画一个框将”happens-before” 的几种情况框起来 总结本文介绍了3种内存模型，包括全局一致性模型，同步模型以及最宽松的原子模型，以及6种内存序，下一篇将介绍如何利用6中内存序达到三种模型的效果。 详细源码 https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day10-MemoryModel 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"thread,async源码解析","date":"2023-10-11T11:53:21.000Z","path":"2023/10/11/concpp10/","text":"简介本文件汇总粉丝提出的关于并发的几个问题，做个备份，方便大家理解和学习。 局部变量返回值关于局部变量返回值的问题我曾在视频中说会通过构造函数返回一个局部变量给调用者，编译器会先执行拷贝构造，如果没有拷贝构造再寻找移动构造。这么说是有问题的。有热心的粉丝查询了chatgpt，当函数返回一个类类型的局部变量时会先调用移动构造，如果没有移动构造再调用拷贝构造。所以对于一些没有拷贝构造但是实现了移动构造的类类型也支持通过函数返回局部变量。在 C++11 之后，编译器会默认使用移动语义（move semantics）来提高性能 看个例子 123456789101112131415class TestCopy &#123;public: TestCopy()&#123;&#125; TestCopy(const TestCopy&amp; tp) &#123; std::cout &lt;&lt; &quot;Test Copy Copy &quot; &lt;&lt; std::endl; &#125; TestCopy(TestCopy&amp;&amp; cp) &#123; std::cout &lt;&lt; &quot;Test Copy Move &quot; &lt;&lt; std::endl; &#125;&#125;;TestCopy TestCp() &#123; TestCopy tp; return tp;&#125; main 函数中调用TestCp 1234int main()&#123; TestCp(); return 0;&#125; 发现打印的是”Test Copy Move” .这说明优先调用的是移动构造，这也提醒我们，如果我们自定义的类实现了拷贝构造和移动构造，而这个类的移动给构造和拷贝构造实现方式不同时，要注意通过函数内部局部变量返回该类时调用移动构造是否会存在一些逻辑或安全的问题。 优先按照移动构造的方式返回局部的类对象，有一个好处就是可以返回一些只支持移动构造的类型 1234567891011121314151617181920std::unique_ptr&lt;int&gt; ReturnUniquePtr() &#123; std::unique_ptr&lt;int&gt; uq_ptr = std::make_unique&lt;int&gt;(100); return uq_ptr;&#125;std::thread ReturnThread() &#123; std::thread t([]() &#123; int i = 0; while (true) &#123; std::cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; std::endl; i++; if (i == 5) &#123; break; &#125; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;); return t;&#125; main函数中调用后，可以看到线程和unique_ptr都可被函数作为局部变量返回，而且返回的线程可以继续运行。 1234567int main()&#123; auto rt_ptr = ReturnUniquePtr(); std::cout &lt;&lt; &quot;rt_ptr value is &quot; &lt;&lt; *rt_ptr &lt;&lt; std::endl; std::thread rt_thread = ReturnThread(); rt_thread.join(); return 0;&#125; 线程归属权问题有粉丝反馈在使用thread时遇到崩溃，主要原因在于线程归属权没有理解好，我们不能将一个线程的归属权转移给一个已经绑定线程的变量。 比如下面的调用 1234567891011121314151617181920212223void ThreadOp() &#123; std::thread t1([]() &#123; int i = 0; while (i &lt; 5) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); i++; &#125; &#125;); std::thread t2([]() &#123; int i = 0; while (i &lt; 10) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); i++; &#125; &#125;); //不能将一个线程归属权绑定给一个已经绑定线程的变量，否则会触发terminate导致崩溃 t1 = std::move(t2); t1.join(); t2.join();&#125; 我们在主函数中执行上述函数，会触发崩溃如下图 t1已经绑定了一个线程执行循环操作直到i&lt;5。如果在t1没运行完的情况下将t2的归属权给t1，则会引发terminate崩溃错误。 具体原因我们可以看看thread在做移动赋值时的源码 12345678thread&amp; operator=(thread&amp;&amp; _Other) noexcept &#123; if (joinable()) &#123; _STD terminate(); &#125; _Thr = _STD exchange(_Other._Thr, &#123;&#125;); return *this;&#125; 在线程joinable()返回true时，会触发terminate()操作，也就是被赋值的线程没有被join过，此时执行operator=操作会导致terminate()。至于terminate()实现比较简单 1_ACRTIMP __declspec(noreturn) void __cdecl terminate() throw(); 可以看到terminate()就是抛出异常。 所以我们在之前的课程封装了了自动join的线程类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class joining_thread &#123; std::thread _t;public: joining_thread() noexcept = default; template&lt;typename Callable, typename ... Args&gt; explicit joining_thread(Callable&amp;&amp; func, Args&amp;&amp; ...args): t(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args)...)&#123;&#125; explicit joining_thread(std::thread t) noexcept: _t(std::move(t))&#123;&#125; joining_thread(joining_thread&amp;&amp; other) noexcept: _t(std::move(other._t))&#123;&#125; joining_thread&amp; operator=(joining_thread&amp;&amp; other) noexcept &#123; //如果当前线程可汇合，则汇合等待线程完成再赋值 if (joinable()) &#123; join(); &#125; _t = std::move(other._t); return *this; &#125; joining_thread&amp; operator=(joining_thread other) noexcept &#123; //如果当前线程可汇合，则汇合等待线程完成再赋值 if (joinable()) &#123; join(); &#125; _t = std::move(other._t); return *this; &#125; ~joining_thread() noexcept &#123; if (joinable()) &#123; join(); &#125; &#125; void swap(joining_thread&amp; other) noexcept &#123; _t.swap(other._t); &#125; std::thread::id get_id() const noexcept &#123; return _t.get_id(); &#125; bool joinable() const noexcept &#123; return _t.joinable(); &#125; void join() &#123; _t.join(); &#125; void detach() &#123; _t.detach(); &#125; std::thread&amp; as_thread() noexcept &#123; return _t; &#125; const std::thread&amp; as_thread() const noexcept &#123; return _t; &#125;&#125;; thread参数值拷贝之前讲到构造std::thread对象传递回调函数和参数，回调函数的参数绑定都是值拷贝的方式，这里再梳理一次下面是thread的构造函数 1234template &lt;class _Fn, class... _Args, enable_if_t&lt;!is_same_v&lt;_Remove_cvref_t&lt;_Fn&gt;, thread&gt;, int&gt; = 0&gt; _NODISCARD_CTOR explicit thread(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123; _Start(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...); &#125; 构造函数内调用了_Start函数 12345678910111213141516171819202122232425 template &lt;class _Fn, class... _Args&gt; void _Start(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123; // 1 处 using _Tuple = tuple&lt;decay_t&lt;_Fn&gt;, decay_t&lt;_Args&gt;...&gt;; // 2 处 auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...); // 3 处 constexpr auto _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;1 + sizeof...(_Args)&gt;&#123;&#125;);#pragma warning(push)#pragma warning(disable : 5039) // pointer or reference to potentially throwing function passed to // extern C function under -EHc. Undefined behavior may occur // if this function throws an exception. (/Wall) // 4处 _Thr._Hnd = reinterpret_cast&lt;void*&gt;(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &amp;_Thr._Id));#pragma warning(pop) if (_Thr._Hnd) &#123; // ownership transferred to the thread (void) _Decay_copied.release(); &#125; else &#123; // failed to start thread _Thr._Id = 0; _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN); &#125; &#125; 我们从上面的代码 1处 可以看到_Tuple是一个去引用的类型，因为其内部存储的都是decay_t过后的类型，所以无论左值引用还是右值引用到这里都变为去引用的类型。 所以2处就是将参数和函数按照值拷贝的方式存在tuple中。 3处定义了一个可调用对象_Invoker_proc 4处启动线程调用_Invoker_proc进而调用我们传递的回调函数和参数。 所以综上所述，std::thread向回调函数传递值是以副本的方式,回调函数参数是引用类型，可以将传递的实参用std::ref包装达到修改的效果。因为std::ref其实是构造了reference_wrapper类对象，这个类实现了仿函数 123_CONSTEXPR20 operator _Ty&amp;() const noexcept &#123; return *_Ptr;&#125; 所以当线程接收std::ref包裹的参数时会调用仿函数通过指针解引用的方式获取外部实参，以_Ty&amp;返回，从而达到修改的效果。 那么如下调用就会报错，提示“invoke”: 未找到匹配的重载函数。 12345678void ChangeValue() &#123; int m = 100; std::thread t1&#123; [](int&amp; rm) &#123; rm++; &#125;, m &#125;; t1.join();&#125; 因为 invoke函数调用时会将参数以右值的方式移动给回调函数，这会造成左值引用绑定右值的情况，所以编译报错。 改为下面这样写就没问题了 12345678void ChangeValue() &#123; int m = 100; std::thread t1&#123; [](int&amp; rm) &#123; rm++; &#125;, std::ref(m) &#125;; t1.join();&#125; async注意事项部分粉丝反馈async不能像js那样实现完全的纯异步，确实是存在这样的情况，因为于js不同，js是单线程的，而C++需要关注线程的生命周期。 我们使用async时，其实其内部调用了thread,pacakged_task,future等机制。async会返回一个future这个future如果会在被析构时等待其绑定的线程任务是否执行完成。 我们看一段cppreference.com中的描述 “The creator of the asynchronous operation can then use a variety of methods to query, wait for, or extract a value from the std::future. These methods may block if the asynchronous operation has not yet provided a value.” 异步操作async返回std::future, 调用者可以通过query,wait for等方式从std::future中查询状态。但是如果async直接调用而不适用返回值则可能会阻塞。如下例子 12345678910void BlockAsync() &#123; std::cout &lt;&lt; &quot;begin block async&quot; &lt;&lt; std::endl; &#123; std::async(std::launch::async, []() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout &lt;&lt; &quot;std::async called &quot; &lt;&lt; std::endl; &#125;); &#125; std::cout &lt;&lt; &quot;end block async&quot; &lt;&lt; std::endl;&#125; 我们在主函数调用BlockAsync()， 发现async并没有异步执行任务，而是按次序输出如下 123begin block asyncstd::async calledend block async 因为async返回一个右值类型的future，无论左值还是右值，future都要被析构，因为其处于一个局部作用域&#123;&#125;中。当编译器执行到&#125;时会触发future析构。但是future析构要保证其关联的任务完成，所以需要等待任务完成future才被析构，所以也就成了串行的效果了。 所以C++ 官方文档说 如果调用析构函数的那个future是某一shared state的最后持有者，而相关的task已启动但尚未结束，析构函数会造成阻塞，直到任务结束 至于为什么future析构要等到其关联的任务完成我们可以看一下async源码 12345678910111213template &lt;class _Fty, class... _ArgTypes&gt;_NODISCARD future&lt;_Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;&gt; async( launch _Policy, _Fty&amp;&amp; _Fnarg, _ArgTypes&amp;&amp;... _Args) &#123; // manages a callable object launched with supplied policy using _Ret = _Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;; using _Ptype = typename _P_arg_type&lt;_Ret&gt;::type; //1 处 _Promise&lt;_Ptype&gt; _Pr( _Get_associated_state&lt;_Ret&gt;(_Policy, _Fake_no_copy_callable_adapter&lt;_Fty, _ArgTypes...&gt;( _STD forward&lt;_Fty&gt;(_Fnarg), _STD forward&lt;_ArgTypes&gt;(_Args)...))); //2 处 return future&lt;_Ret&gt;(_Pr._Get_state_for_future(), _Nil());&#125; 我们先看看_Get_associated_state的源码 1234567891011template &lt;class _Ret, class _Fty&gt;_Associated_state&lt;typename _P_arg_type&lt;_Ret&gt;::type&gt;* _Get_associated_state( launch _Psync, _Fty&amp;&amp; _Fnarg) &#123; // construct associated asynchronous state object for the launch type switch (_Psync) &#123; // select launch type case launch::deferred: return new _Deferred_async_state&lt;_Ret&gt;(_STD forward&lt;_Fty&gt;(_Fnarg)); case launch::async: // TRANSITION, fixed in vMajorNext, should create a new thread here default: return new _Task_async_state&lt;_Ret&gt;(_STD forward&lt;_Fty&gt;(_Fnarg)); &#125;&#125; _Get_associated_state 做的事情很简单，根据我们不同的策略deferred还是async去构造不同的异步状态。如果是launch::async策略，我们创建一个_Task_async_state类型的指针对象，我们将这个指针转化为_Associated_state指针返回，_Associated_state为_Task_async_state的基类。 async内 1处用该返回值构造了一个_Promise&lt;_Ptype&gt;类型的对象_Pr async内 2处 用_Pr._Get_state_for_future()返回值构造了future，该返回值是_State_manager&lt;_Ty&gt;类型对象。 因为future继承于_State_manager，所以_Pr._Get_state_for_future()返回的值主要用来构造future的基类。 析构future时要析构future子类再析构其基类，future本身的析构没有什么，而其基类_State_manager&lt;_Ty&gt;析构时调用如下 12345~_State_manager() noexcept &#123; if (_Assoc_state) &#123; _Assoc_state-&gt;_Release(); &#125; &#125; 看源码我们知道_Assoc_state 是 _Associated_state&lt;_Ty&gt; *类型 1_Associated_state&lt;_Ty&gt;* _Assoc_state; _Assoc_state * 就是我们之前在_Get_associated_state中开辟并返回的_Task_async_state*类型转化的。 我们沿着_Assoc_state-&gt;_Release一路追踪，会发现最终调用了下面的代码 1234567void _Delete_this() &#123; // delete this object if (_Deleter) &#123; _Deleter-&gt;_Delete(this); &#125; else &#123; delete this; &#125; &#125; 如果没有删除器则会直接调用delete this, 会调用_Assoc_state的析构函数，因其析构函数为虚析构，进而调用_Task_async_state的析构函数 所以我们 ~_State_manager()调用的其实是_Task_async_state的析构函数, 我们看一下_Task_async_state的析构函数源码 1234567virtual ~_Task_async_state() noexcept &#123; _Wait();&#125;virtual void _Wait() override &#123; // wait for completion _Task.wait(); &#125; 从源码中可以看到_Task_async_state 被析构时会等待任务完成，这也就是future需等待任务完成后才析构的原因。 仅仅介绍这个事情不是我得初衷，我们介绍一种更为隐晦的死锁情况, 看下面的代码 1234567891011121314void DeadLock() &#123; std::mutex mtx; std::cout &lt;&lt; &quot;DeadLock begin &quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; dklock(mtx); &#123; std::future&lt;void&gt; futures = std::async(std::launch::async, [&amp;mtx]() &#123; std::cout &lt;&lt; &quot;std::async called &quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; dklock(mtx); std::cout &lt;&lt; &quot;async working....&quot; &lt;&lt; std::endl; &#125;); &#125; std::cout &lt;&lt; &quot;DeadLock end &quot; &lt;&lt; std::endl;&#125; 上面函数的作用意图在主线程中先执行加锁，再通过async启动一个线程异步执行任务，执行的任务与主线程互斥，所以在lambda表达式中加锁。但是这么做会造成死锁，因为主线程输出”DeadLock begin “加锁，此时async启动一个线程，那么lambda表达式会先输出”std::async called “.但是在子线程中无法加锁成功，因为主线程没有释放锁。而主线程无法释放锁，因为主线程要等待async执行完。因为我们上面提到过，futures处于局部作用域，即将析构，而析构又要等待任务完成，任务需要加锁，所以永远完成不了，这样就死锁了。 所以使用async要注意其返回的future是不是shared state的最后持有者。 这里有个粉丝问道能不能用async实现这样的需求 你的需求是func1 中要异步执行asyncFunc函数。 func2中先收集asyncFunc函数运行的结果，只有结果正确才执行 func1启动异步任务后继续执行，执行完直接退出不用等到asyncFunc运行完 如果我们理解了async的原理后不难实现如下代码 1234567891011121314151617181920212223242526272829int asyncFunc() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout &lt;&lt; &quot;this is asyncFunc&quot; &lt;&lt; std::endl; return 0;&#125;void func1(std::future&lt;int&gt;&amp; future_ref) &#123; std::cout &lt;&lt; &quot;this is func1&quot; &lt;&lt; std::endl; future_ref = std::async(std::launch::async, asyncFunc);&#125;void func2(std::future&lt;int&gt;&amp; future_ref) &#123; std::cout &lt;&lt; &quot;this is func2&quot; &lt;&lt; std::endl; auto future_res = future_ref.get(); if (future_res == 0) &#123; std::cout &lt;&lt; &quot;get asyncFunc result success !&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;get asyncFunc result failed !&quot; &lt;&lt; std::endl; return; &#125;&#125;//提供多种思路，这是第一种void first_method() &#123; std::future&lt;int&gt; future_tmp; func1(future_tmp); func2(future_tmp);&#125; 上面的例子我们保证在func1和func2使用的是future的引用即可。这样func1内不会因为启动async而阻塞，因为future_ref不是shared state最后持有者。 如果真的想实现一个纯异步的操作倒也不难，可以这样实现 123456789101112template&lt;typename Func, typename... Args &gt;auto ParallenExe(Func&amp;&amp; func, Args &amp;&amp; ... args) -&gt; std::future&lt;decltype(func(args...))&gt; &#123; typedef decltype(func(args...)) RetType; std::function&lt;RetType()&gt; bind_func = std::bind(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...); std::packaged_task&lt;RetType()&gt; task(bind_func); auto rt_future = task.get_future(); std::thread t(std::move(task)); t.detach(); return rt_future;&#125; 上面的函数ParallenExe内部我们通过bind操作将函数和参数绑定，生成一个返回值为RetType类型，参数为void的函数bind_func。接着我们用这个函数生成了一个packaged_task类型的对象task，这个task获取future留作以后函数结束时返回。我们启动了一个线程处理这个task，并将这个线程detach，保证其分离独立运行。返回的rt_future并不是shared state最后持有者，因为task内部也会持有shared_state，引用计数并不会变为0，所以并不会触发如下析构 12345void _Release() &#123; // decrement reference count and destroy when zero if (_MT_DECR(_Refs) == 0) &#123; _Delete_this(); &#125;&#125; 那么我们写一个函数测试一下 123456789101112131415void TestParallen1() &#123; int i = 0; std::cout &lt;&lt; &quot;Begin TestParallen1 ...&quot; &lt;&lt; std::endl; &#123; ParallenExe([](int i) &#123; while (i &lt; 3) &#123; i++; std::cout &lt;&lt; &quot;ParllenExe thread func &quot; &lt;&lt; i &lt;&lt; &quot; times&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;, i); &#125; std::cout &lt;&lt; &quot;End TestParallen1 ...&quot; &lt;&lt; std::endl;&#125; 在上面的函数中我们有意让ParallenExe放在一个局部的&#123;&#125;中执行，意在局部作用域结束后ParallenExe返回的future引用计数-1,以此证明其引用计数是否为0， 如果引用计数为0，则会执行future的析构进而等待任务执行完成，那么看到的输出将是 12345Begin TestParallen1 ...ParllenExe thread func 1 timesParllenExe thread func 2 timesParllenExe thread func 3 timesEnd TestParallen1 ... 如果引用计数不会为0，则不会执行future的析构函数，那么看到的输出是这样的 12345Begin TestParallen1 ...End TestParallen1 ...ParllenExe thread func 1 timesParllenExe thread func 2 timesParllenExe thread func 3 times 我们在main函数中调用做测试, 因为要防止主线程过早退出，所以我们先让主线程睡眠4秒 123456int main()&#123; TestParallen1(); std::this_thread::sleep_for(std::chrono::seconds(4)); std::cout &lt;&lt; &quot;Main Exited!\\n&quot;;&#125; 而事实证明是第二种，输出如下 12345Begin TestParallen1 ...End TestParallen1 ...ParllenExe thread func 1 timesParllenExe thread func 2 timesParllenExe thread func 3 times 由此可见我们实现了不会阻塞的并发函数，但是也会存在一些顾虑，比如我们的主线程如果不睡眠4秒，那很可能主线程退出了子线程的任务没执行完而被强制回收。所以归根结底，这种方式我们也需要在合适的时候等待汇合，比如调用future的get或wait操作 12345678910111213141516void TestParallen2() &#123; int i = 0; std::cout &lt;&lt; &quot;Begin TestParallen2 ...&quot; &lt;&lt; std::endl; auto rt_future = ParallenExe([](int i) &#123; while (i &lt; 3) &#123; i++; std::cout &lt;&lt; &quot;ParllenExe thread func &quot; &lt;&lt; i &lt;&lt; &quot; times&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;, i); std::cout &lt;&lt; &quot;End TestParallen2 ...&quot; &lt;&lt; std::endl; rt_future.wait();&#125; 这就是我说的，归根结底C++和js的体系不一样，C++要管理开辟的线程生命周期，我们总归要在合适的时机汇合。所以std::async会返回future, future会判断是不是最后持有的shared_state进而帮我们做汇合操作,这并不是缺陷而是安全性的保证。至于我们不想在该处汇合，只要保证该处future不会是最后持有shared_state的即可。 总结本文介绍了thread和async的源码级分析，回答了大家常遇到的问题。 详细源码 https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day09-QASummary 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"Actor和CSP设计模式","date":"2023-10-06T01:17:35.000Z","path":"2023/10/06/concpp09/","text":"简介本文介绍两种并发设计中常用的设计模式，包括Actor和CSP模式。传统的并发设计经常都是通过共享内存加锁保证逻辑安全，这种模式有几个缺点，包括1 频繁加锁影响性能，2 耦合度高。后来大家提出了Actor和CSP设计模式。 Actor设计模式简单点说，actor通过消息传递的方式与外界通信。消息传递是异步的。每个actor都有一个邮箱，该邮箱接收并缓存其他actor发过来的消息，actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息，不能做任何其他操作。每一个类独立在一个线程里称作Actor，Actor之间通过队列通信，比如Actor1 发消息给Actor2， Actor2 发消息给Actor1都是投递到对方的队列中。好像给对方发邮件，对方从邮箱中取出一样。如下图 Actor模型的另一个好处就是可以消除共享状态，因为它每次只能处理一条消息，所以actor内部可以安全的处理状态，而不用考虑锁机制。 我们在网络编程中对于逻辑层的处理就采用了将要处理的逻辑消息封装成包投递给逻辑队列，逻辑类从队列中消费的思想，其实就是一种Actor设计模式。Erlang是天然支持Actor的语言。 CSP模式CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。go是天然支持csp模式的语言。 CSP和Actor类似，只不过CSP将消息投递给channel，至于谁从channel中取数据，发送的一方是不关注的。简单的说Actor在发送消息前是直到接收方是谁，而接受方收到消息后也知道发送方是谁，更像是邮件的通信模式。而csp是完全解耦合的。 无论Actor还是CSP，他们都有一个共同的特性”Do not communicate by sharing memory; instead, share memory by communicating” go风格的csp我们通过生产者和消费者模型给大家演示csp模式的使用方式，用go来做示例 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;cspdemo/message&quot; &quot;fmt&quot; &quot;os&quot; &quot;os/signal&quot; &quot;syscall&quot;)var closeChan chan struct&#123;&#125;var sigs chan os.Signalfunc init() &#123; //类似于auto sigs = make(chan os.Signal) //具体类型初始化 closeChan = make(chan struct&#123;&#125;) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) //可以理解为C++ 的匿名函数，或者js的匿名函数，此处通过go原语启动一个协程并行执行 go func() &#123; sig := &lt;-sigs fmt.Println(&quot;receive signal is &quot;, sig) close(closeChan) message.ConsumerInst().Exit() message.ProducerInst().Exit() &#125;()&#125;func main() &#123; fmt.Println(&quot;Main Process begin!&quot;) &lt;-closeChan message.ConsumerInst().Join() message.ProducerInst().Join() fmt.Println(&quot;Main Process exit!&quot;)&#125; 在上面的代码中我们启动了一个协程监听Ctrl+C等退出操作，当收到Ctrl+C的信号后，会关闭closeChan这个channel。这样主函数中&lt;-closeChan就会从channel中取出数据。然后等待消费者和生产者退出。 接下来我们将生产者和消费者的实现放入message包，先看下message公共数据的定义 12345package messageconst MAX_COUNT = 200var msgChan = make(chan int, MAX_COUNT) 上面的代码中我们定义了一个channel，大小为200，大家可以理解为仓库的大小为200，生产者向仓库中投递数据如果达到200就会阻塞。直到有消费者从中消费数据，如果消费者发现channel中数据为0，则阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package messageimport ( &quot;context&quot; &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)var producer *Producer = nilvar producer_once sync.Oncefunc init() &#123; // Consumer1 = new(Consumer) //类似于C++ std::call_once producer_once.Do(func() &#123; producer = new(Producer) producer._exited = make(chan struct&#123;&#125;) producer._ctx, producer._cancel = context.WithCancel(context.Background()) producer.StartWork() &#125;)&#125;func ProducerInst() *Producer &#123; return producer&#125;type Producer struct &#123; _exited chan struct&#123;&#125; _ctx context.Context _cancel context.CancelFunc&#125;func (producer *Producer) Join() &#123; &lt;-producer._exited fmt.Println(&quot;producer exited&quot;)&#125;func (producer *Producer) Exit() &#123; producer._cancel()&#125;func (producer *Producer) StartWork() &#123; go func() &#123; i := 0 for &#123; i++ select &#123; case &lt;-producer._ctx.Done(): &#123; close(producer._exited) return &#125; case msgChan &lt;- i: fmt.Println(&quot;producer produce number is &quot;, i) &#125; time.Sleep(50 * time.Millisecond) &#125; &#125;()&#125; 我们通过init函数中只调用一次的方式初始化了producer，之后生成了一个名为_exited的channel，用来通知Join返回。同样我们还初始化了一个可以取消的context，主要是在Exit函数内调用cancel取消上下文，会触发StartWork中producer._ctx.Done()进而终止生产工作，再发出退出信号，达到优雅退出的效果。 类似的消费者也是相似逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package messageimport ( &quot;context&quot; &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)var consumer *Consumer = nilvar consumer_once sync.Oncefunc init() &#123; // Consumer1 = new(Consumer) //类似于C++ std::call_once consumer_once.Do(func() &#123; consumer = new(Consumer) consumer._exited = make(chan struct&#123;&#125;) consumer._ctx, consumer._cancel = context.WithCancel(context.Background()) consumer.StartWork() &#125;)&#125;func ConsumerInst() *Consumer &#123; return consumer&#125;type Consumer struct &#123; _exited chan struct&#123;&#125; _ctx context.Context _cancel context.CancelFunc&#125;func (consumer *Consumer) Join() &#123; &lt;-consumer._exited fmt.Println(&quot;consumer exited&quot;)&#125;func (consumer *Consumer) Exit() &#123; consumer._cancel()&#125;func (consumer *Consumer) StartWork() &#123; go func() &#123; i := 0 for &#123; select &#123; case &lt;-consumer._ctx.Done(): &#123; close(consumer._exited) return &#125; case i = &lt;-msgChan: fmt.Println(&quot;consumer consum number is &quot;, i) &#125; time.Sleep(100 * time.Millisecond) &#125; &#125;()&#125; C++ 风格的cspC++是万能的，我们可以用C++实现一个类似于go的channel，采用csp模式解耦合，实现类似的生产者和消费者问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;template &lt;typename T&gt;class Channel &#123;private: std::queue&lt;T&gt; queue_; std::mutex mtx_; std::condition_variable cv_producer_; std::condition_variable cv_consumer_; size_t capacity_; bool closed_ = false;public: Channel(size_t capacity = 0) : capacity_(capacity) &#123;&#125; bool send(T value) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_); cv_producer_.wait(lock, [this]() &#123; // 对于无缓冲的channel，我们应该等待直到有消费者准备好 return (capacity_ == 0 &amp;&amp; queue_.empty()) || queue_.size() &lt; capacity_ || closed_; &#125;); if (closed_) &#123; return false; &#125; queue_.push(value); cv_consumer_.notify_one(); return true; &#125; bool receive(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_); cv_consumer_.wait(lock, [this]() &#123; return !queue_.empty() || closed_; &#125;); if (closed_ &amp;&amp; queue_.empty()) &#123; return false; &#125; value = queue_.front(); queue_.pop(); cv_producer_.notify_one(); return true; &#125; void close() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_); closed_ = true; cv_producer_.notify_all(); cv_consumer_.notify_all(); &#125;&#125;;// 示例使用int main() &#123; Channel&lt;int&gt; ch(10); // 10缓冲的channel std::thread producer([&amp;]() &#123; for (int i = 0; i &lt; 5; ++i) &#123; ch.send(i); std::cout &lt;&lt; &quot;Sent: &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; ch.close(); &#125;); std::thread consumer([&amp;]() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(500)); // 故意延迟消费者开始消费 int val; while (ch.receive(val)) &#123; std::cout &lt;&lt; &quot;Received: &quot; &lt;&lt; val &lt;&lt; std::endl; &#125; &#125;); producer.join(); consumer.join(); return 0;&#125; 简单来说就是通过条件变量实现通信的阻塞和同步的。 利用csp思想实现取款逻辑《C++并发编程实战》一书中提及了用csp思想实现atm机取款逻辑，我根据书中思想，整理了通信的示意图，书中部分代码存在问题，也一并修复了。 主函数实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Actor.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &quot;message.h&quot;#include &quot;withdraw_msg.h&quot;#include &quot;atm.h&quot;#include &quot;dispatcher.h&quot;#include &quot;bank_matchine.h&quot;#include &quot;interface_matchine.h&quot;int main()&#123; bank_machine bank; interface_machine interface_hardware; atm machine(bank.get_sender(), interface_hardware.get_sender()); std::thread bank_thread(&amp;bank_machine::run, &amp;bank); std::thread if_thread(&amp;interface_machine::run, &amp;interface_hardware); std::thread atm_thread(&amp;atm::run, &amp;machine); messaging::sender atmqueue(machine.get_sender()); bool quit_pressed = false; while (!quit_pressed) &#123; char c = getchar(); switch (c) &#123; case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;: atmqueue.send(digit_pressed(c)); break; case &#x27;b&#x27;: atmqueue.send(balance_pressed()); break; case &#x27;w&#x27;: atmqueue.send(withdraw_pressed(50)); break; case &#x27;c&#x27;: atmqueue.send(cancel_pressed()); break; case &#x27;q&#x27;: quit_pressed = true; break; case &#x27;i&#x27;: atmqueue.send(card_inserted(&quot;acc1234&quot;)); break; &#125; &#125; bank.done(); machine.done(); interface_hardware.done(); atm_thread.join(); bank_thread.join(); if_thread.join();&#125; 主函数中启动了三个线程，分别处理bank，machine以及interface的操作。由于代码复杂解析来只列举atm类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#pragma once#include &quot;dispatcher.h&quot;#include &lt;functional&gt;#include &lt;iostream&gt;class atm&#123; messaging::receiver incoming; messaging::sender bank; messaging::sender interface_hardware; void (atm::* state)(); std::string account; unsigned withdrawal_amount; std::string pin; void process_withdrawal() &#123; incoming.wait().handle&lt;withdraw_ok, std::function&lt;void(withdraw_ok const&amp; msg)&gt;, messaging::dispatcher &gt;( [&amp;](withdraw_ok const&amp; msg) &#123; interface_hardware.send( issue_money(withdrawal_amount)); bank.send( withdrawal_processed(account, withdrawal_amount)); state = &amp;atm::done_processing; &#125;, &quot;withdraw_ok&quot;).handle&lt;withdraw_denied, std::function&lt;void(withdraw_denied const&amp; msg)&gt;&gt;( [&amp;](withdraw_denied const&amp; msg) &#123; interface_hardware.send(display_insufficient_funds()); state = &amp;atm::done_processing; &#125;, &quot;withdraw_denied&quot;).handle&lt;cancel_pressed, std::function&lt;void(cancel_pressed const&amp; msg)&gt;&gt;( [&amp;](cancel_pressed const&amp; msg) &#123; bank.send( cancel_withdrawal(account, withdrawal_amount)); interface_hardware.send( display_withdrawal_cancelled()); state = &amp;atm::done_processing; &#125;, &quot;cancel_pressed&quot; ); &#125; void process_balance() &#123; incoming.wait() .handle&lt;balance, std::function&lt;void(balance const&amp; msg)&gt;, messaging::dispatcher&gt;( [&amp;](balance const&amp; msg) &#123; interface_hardware.send(display_balance(msg.amount)); state = &amp;atm::wait_for_action; &#125;,&quot;balance&quot; ).handle &lt; cancel_pressed, std::function&lt;void(cancel_pressed const&amp; msg) &gt;&gt;( [&amp;](cancel_pressed const&amp; msg) &#123; state = &amp;atm::done_processing; &#125;, &quot;cancel_pressed&quot; ); &#125; void wait_for_action() &#123; interface_hardware.send(display_withdrawal_options()); incoming.wait() .handle&lt;withdraw_pressed, std::function&lt;void(withdraw_pressed const&amp; msg)&gt;, messaging::dispatcher&gt;( [&amp;](withdraw_pressed const&amp; msg) &#123; withdrawal_amount = msg.amount; bank.send(withdraw(account, msg.amount, incoming)); state = &amp;atm::process_withdrawal; &#125;, &quot;withdraw_pressed&quot; ).handle &lt; balance_pressed, std::function&lt;void(balance_pressed const&amp; msg) &gt;&gt;( [&amp;](balance_pressed const&amp; msg) &#123; bank.send(get_balance(account, incoming)); state = &amp;atm::process_balance; &#125;, &quot;balance_pressed&quot; ).handle&lt;cancel_pressed, std::function&lt;void(cancel_pressed const&amp; msg) &gt;&gt;( [&amp;](cancel_pressed const&amp; msg) &#123; state = &amp;atm::done_processing; &#125;, &quot;cancel_pressed&quot; ); &#125; void verifying_pin() &#123; incoming.wait() .handle&lt;pin_verified, std::function&lt;void(pin_verified const&amp; msg)&gt;, messaging::dispatcher&gt;( [&amp;](pin_verified const&amp; msg) &#123; state = &amp;atm::wait_for_action; &#125;, &quot;pin_verified&quot; ).handle&lt;pin_incorrect, std::function&lt;void(pin_incorrect const&amp; msg)&gt;&gt;( [&amp;](pin_incorrect const&amp; msg) &#123; interface_hardware.send( display_pin_incorrect_message()); state = &amp;atm::done_processing; &#125;, &quot;pin_incorrect&quot; ).handle&lt;cancel_pressed, std::function&lt;void(cancel_pressed const&amp; msg)&gt;&gt;( [&amp;](cancel_pressed const&amp; msg) &#123; state = &amp;atm::done_processing; &#125;, &quot;cancel_pressed&quot; ); &#125; void getting_pin() &#123; incoming.wait().handle&lt;digit_pressed, std::function&lt;void(digit_pressed const&amp; msg)&gt;, messaging::dispatcher&gt;( [&amp;](digit_pressed const&amp; msg) &#123; unsigned const pin_length = 6; pin += msg.digit; if (pin.length() == pin_length) &#123; bank.send(verify_pin(account, pin, incoming)); state = &amp;atm::verifying_pin; &#125; &#125;, &quot;digit_pressed&quot; ).handle&lt;clear_last_pressed, std::function&lt;void(clear_last_pressed const&amp; msg)&gt;&gt;( [&amp;](clear_last_pressed const&amp; msg) &#123; if (!pin.empty()) &#123; pin.pop_back(); &#125; &#125;, &quot;clear_last_pressed&quot; ).handle&lt;cancel_pressed, std::function&lt;void(cancel_pressed const&amp; msg)&gt;&gt;( [&amp;](cancel_pressed const&amp; msg) &#123; state = &amp;atm::done_processing; &#125;, &quot;cancel_pressed&quot; ); &#125; void waiting_for_card() &#123; interface_hardware.send(display_enter_card()); incoming.wait().handle&lt;card_inserted, std::function&lt;void(card_inserted const&amp; msg)&gt;, messaging::dispatcher&gt;( [&amp;](card_inserted const&amp; msg) &#123; account = msg.account; pin = &quot;&quot;; interface_hardware.send(display_enter_pin()); state = &amp;atm::getting_pin; &#125;, &quot;card_inserted&quot; ); &#125; void done_processing() &#123; interface_hardware.send(eject_card()); state = &amp;atm::waiting_for_card; &#125; atm(atm const&amp;) = delete; atm&amp; operator=(atm const&amp;) = delete;public: atm(messaging::sender bank_, messaging::sender interface_hardware_) : bank(bank_), interface_hardware(interface_hardware_) &#123;&#125; void done() &#123; get_sender().send(messaging::close_queue()); &#125; void run() &#123; state = &amp;atm::waiting_for_card; try &#123; for (;;) &#123; (this-&gt;*state)(); &#125; &#125; catch (messaging::close_queue const&amp;) &#123; &#125; &#125; messaging::sender get_sender() &#123; return incoming; &#125;&#125;; atm 主要功能就是通过状态机不断地切换状态监听想要处理的函数。 详细源码可参考https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day08-actor/Actor 总结本文讲述了Actor设计模式和CSP设计模式，并通过go和C++等语言给大家展示了csp并发设计的demo，最后通过讲解《C++并发编程实战》中取款的案例，展示了csp的用法。 详细源码 https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day08-actor/Actor 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用并行和函数式编程提高运算效率","date":"2023-09-24T09:12:55.000Z","path":"2023/09/24/concpp08/","text":"简介前文介绍了async用法，很多朋友说用的不多，我对async的理解就是开辟一个一次性的线程执行并行任务，主线程可以通过future在合适的时机执行等待汇总结果。本文通过并行和函数式编程，演示快速排序提升效率的一种方式。 快速排序快速排序（Quick Sort）是一种高效的排序算法，采用分治法的思想进行排序。以下是快速排序的基本步骤： 选择一个基准元素（pivot）：从数组中选择一个元素作为基准元素。选择基准元素的方式有很多种，常见的是选择数组的第一个元素或最后一个元素。 分区（partitioning）：重新排列数组，把比基准元素小的元素放在它的左边，把比基准元素大的元素放在它的右边。在这个过程结束时，基准元素就处于数组的最终位置。 递归排序子数组：递归地对基准元素左边和右边的两个子数组进行快速排序。 以下是一个基本的快速排序的C++实现： 12345678910111213141516171819202122232425//c++ 版本的快速排序算法template&lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) &#123; if (start &gt;= end) return; T key = arr[start]; int left = start, right = end; while(left &lt; right) &#123; while (arr[right] &gt;= key &amp;&amp; left &lt; right) right--; while (arr[left] &lt;= key &amp;&amp; left &lt; right) left++; std::swap(arr[left], arr[right]); &#125; if (arr[left] &lt; key) &#123; std::swap(arr[left], arr[start]); &#125; quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end);&#125;template&lt;typename T&gt;void quick_sort(T arr[], int len) &#123; quick_sort_recursive(arr, 0, len - 1);&#125; 排序演示 假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。 此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。 此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。 此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。 此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。 此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。 此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。 调用比较简单 123456789101112void test_quick_sort() &#123; int num_arr[] = &#123; 5，3，7，6，4，1，0，2，9，10，8 &#125;; int length = sizeof(num_arr) / sizeof(int); quick_sort(num_arr, length ); std::cout &lt;&lt; &quot;sorted result is &quot;; for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; num_arr[i]; &#125; std::cout &lt;&lt; std::endl; &#125; 这种实现方式比较依赖存储数据的数据结构，比如上面是通过数组存储的，那如果我想实现list容器中元素的排序怎么办？我既不想关注存储的容器，也不想关注存储的类型，想实现一套通用的比较规则？那就需要函数式编程来解决 函数式编程C++函数式编程是一种编程范式，它将计算视为数学上的函数求值，并避免改变状态和使用可变数据。在函数式编程中，程序是由一系列函数组成的，每个函数都接受输入并产生输出，而且没有任何副作用。 在C++中，函数式编程可以使用函数指针、函数对象（functor）和lambda表达式等机制来实现。这些机制允许您编写可以像普通函数一样调用的代码块，并将它们作为参数传递给其他函数或作为返回值返回。 C++11引入了一些新功能，如constexpr函数和表达式模板，这些功能使得在C++中进行函数式编程更加容易和直观。 我们用函数式编程修改上面的快速排序 12345678910111213141516171819202122232425262728293031323334353637383940template&lt;typename T&gt;std::list&lt;T&gt; sequential_quick_sort(std::list&lt;T&gt; input)&#123; if (input.empty()) &#123; return input; &#125; std::list&lt;T&gt; result; // ① 将input中的第一个元素放入result中，并且将这第一个元素从input中删除 result.splice(result.begin(), input, input.begin()); // ② 取result的第一个元素，将来用这个元素做切割，切割input中的列表。 T const&amp; pivot = *result.begin(); // ③std::partition 是一个标准库函数，用于将容器或数组中的元素按照指定的条件进行分区， // 使得满足条件的元素排在不满足条件的元素之前。 // 所以经过计算divide_point指向的是input中第一个大于等于pivot的元素 auto divide_point = std::partition(input.begin(), input.end(), [&amp;](T const&amp; t) &#123;return t &lt; pivot; &#125;); // ④ 我们将小于pivot的元素放入lower_part中 std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.end(), input, input.begin(), divide_point); // ⑤我们将lower_part传递给sequential_quick_sort 返回一个新的有序的从小到大的序列 //lower_part 中都是小于divide_point的值 auto new_lower( sequential_quick_sort(std::move(lower_part))); // ⑥我们剩余的input列表传递给sequential_quick_sort递归调用，input中都是大于divide_point的值。 auto new_higher( sequential_quick_sort(std::move(input))); //⑦到此时new_higher和new_lower都是从小到大排序好的列表 //将new_higher 拼接到result的尾部 result.splice(result.end(), new_higher); //将new_lower 拼接到result的头部 result.splice(result.begin(), new_lower); return result;&#125; 用如下方式调用 123456789void test_sequential_quick() &#123; std::list&lt;int&gt; numlists = &#123; 6,1,0,7,5,2,9,-1 &#125;; auto sort_result = sequential_quick_sort(numlists); std::cout &lt;&lt; &quot;sorted result is &quot;; for (auto iter = sort_result.begin(); iter != sort_result.end(); iter++) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; (*iter); &#125; std::cout &lt;&lt; std::endl;&#125; 这个函数是一个使用快速排序算法对链表进行排序的实现。快速排序是一种常用的排序算法，它的基本思想是选择一个基准元素，然后将数组分为两部分，一部分是小于基准元素的元素，另一部分是大于基准元素的元素。然后对这两部分再分别进行快速排序。这个函数使用了C++的模板，可以处理任何数据类型的链表。函数的主要步骤包括： 将链表的第一个元素作为基准元素，并将其从链表中删除。 使用std::partition函数将链表分为两部分，一部分是小于基准元素的元素，另一部分是大于或等于基准元素的元素。 对这两部分分别进行递归排序。\\n4. 将排序后的两部分和基准元素合并，返回排序后的链表。 并行方式我们提供并行方式的函数式编程，可以极大的利用cpu多核的优势，这在并行计算中很常见。 12345678910111213141516171819202122232425262728//并行版本template&lt;typename T&gt;std::list&lt;T&gt; parallel_quick_sort(std::list&lt;T&gt; input)&#123; if (input.empty()) &#123; return input; &#125; std::list&lt;T&gt; result; result.splice(result.begin(), input, input.begin()); T const&amp; pivot = *result.begin(); auto divide_point = std::partition(input.begin(), input.end(), [&amp;](T const&amp; t) &#123;return t &lt; pivot; &#125;); std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.end(), input, input.begin(), divide_point); // ①因为lower_part是副本，所以并行操作不会引发逻辑错误，这里可以启动future做排序 std::future&lt;std::list&lt;T&gt;&gt; new_lower( std::async(&amp;parallel_quick_sort&lt;T&gt;, std::move(lower_part))); // ② auto new_higher( parallel_quick_sort(std::move(input))); result.splice(result.end(), new_higher); result.splice(result.begin(), new_lower.get()); return result;&#125; 测试调用如下 123456789void test_sequential_quick() &#123; std::list&lt;int&gt; numlists = &#123; 6,1,0,7,5,2,9,-1 &#125;; auto sort_result = sequential_quick_sort(numlists); std::cout &lt;&lt; &quot;sorted result is &quot;; for (auto iter = sort_result.begin(); iter != sort_result.end(); iter++) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; (*iter); &#125; std::cout &lt;&lt; std::endl;&#125; 我们对lower_part的排序调用了std::async并行处理。而higher_part则是串行执行的。这么做提高了计算的并行能力，但有人会问如果数组的大小为1024，那么就是2的10次方，需要启动10个线程执行，这仅是对一个1024大小的数组的排序，如果有多个数组排序，开辟线程会不会很多？其实不用担心这个，因为async的实现方式在上一节中已经提及了，是通过std::launch::async或者std::launch::deffered完成的。编译器会计算当前能否开辟线程，如果能则使用std::launch::async模式开辟线程，如果不能则采用std::launch::deffered串行执行。当然，我们也可以通过我们上文提及的线程池方式实现并行计算 ThreadPool方式的并行排序1234567891011121314151617181920212223242526//线程池版本//并行版本template&lt;typename T&gt;std::list&lt;T&gt; thread_pool_quick_sort(std::list&lt;T&gt; input)&#123; if (input.empty()) &#123; return input; &#125; std::list&lt;T&gt; result; result.splice(result.begin(), input, input.begin()); T const&amp; pivot = *result.begin(); auto divide_point = std::partition(input.begin(), input.end(), [&amp;](T const&amp; t) &#123;return t &lt; pivot; &#125;); std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.end(), input, input.begin(), divide_point); // ①因为lower_part是副本，所以并行操作不会引发逻辑错误，这里投递给线程池处理 auto new_lower = ThreadPool::commit(&amp;parallel_quick_sort&lt;T&gt;, std::move(lower_part)); // ② auto new_higher( parallel_quick_sort(std::move(input))); result.splice(result.end(), new_higher); result.splice(result.begin(), new_lower.get()); return result;&#125; 通过如下方式测试 123456789void test_thread_pool_sort() &#123; std::list&lt;int&gt; numlists = &#123; 6,1,0,7,5,2,9,-1 &#125;; auto sort_result = thread_pool_quick_sort(numlists); std::cout &lt;&lt; &quot;sorted result is &quot;; for (auto iter = sort_result.begin(); iter != sort_result.end(); iter++) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; (*iter); &#125; std::cout &lt;&lt; std::endl;&#125; 到此我们实现了多种版本的快速排序，并不是鼓励读者造轮子，而是提供一种并行处理的思想，相信读者在后续的工作中在合适的时机采用并行处理的方式，可以极大的提高程序处理问题的效率。 总结本文介绍了如何使用future, promise以及async用法 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 并发三剑客future, promise和async","date":"2023-09-17T07:11:40.000Z","path":"2023/09/17/concpp07/","text":"简介本文介绍C++ 并发三剑客， future, promise以及async用法。这三个类是实现并发技术的关键，接下来详细介绍一下 async用法std::async 是一个用于异步执行函数的模板函数，它返回一个 std::future 对象，该对象用于获取函数的返回值。 以下是一个使用 std::async 的示例： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;// 定义一个异步任务std::string fetchDataFromDB(std::string query) &#123; // 模拟一个异步任务，比如从数据库中获取数据 std::this_thread::sleep_for(std::chrono::seconds(5)); return &quot;Data: &quot; + query;&#125;int main() &#123; // 使用 std::async 异步调用 fetchDataFromDB std::future&lt;std::string&gt; resultFromDB = std::async(std::launch::async, fetchDataFromDB, &quot;Data&quot;); // 在主线程中做其他事情 std::cout &lt;&lt; &quot;Doing something else...&quot; &lt;&lt; std::endl; // 从 future 对象中获取数据 std::string dbData = resultFromDB.get(); std::cout &lt;&lt; dbData &lt;&lt; std::endl; return 0;&#125; 在这个示例中，std::async 创建了一个新的线程（或从内部线程池中挑选一个线程）并自动与一个 std::promise 对象相关联。std::promise 对象被传递给 fetchDataFromDB 函数，函数的返回值被存储在 std::future 对象中。在主线程中，我们可以使用 std::future::get 方法从 std::future 对象中获取数据。注意，在使用 std::async 的情况下，我们必须使用 std::launch::async 标志来明确表明我们希望函数异步执行。 上面的例子输出 12Doing something else...Data: Data async的启动策略std::async函数可以接受几个不同的启动策略，这些策略在std::launch枚举中定义。除了std::launch::async之外，还有以下启动策略： std::launch::deferred：这种策略意味着任务将在调用std::future::get()或std::future::wait()函数时延迟执行。换句话说，任务将在需要结果时同步执行。 std::launch::async | std::launch::deferred：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。 默认情况下，std::async使用std::launch::async | std::launch::deferred策略。这意味着任务可能异步执行，也可能延迟执行，具体取决于实现。需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。 future的wait和getstd::future::get() 和 std::future::wait() 是 C++ 中用于处理异步任务的两个方法，它们的功能和用法有一些重要的区别。 std::future::get(): std::future::get() 是一个阻塞调用，用于获取 std::future 对象表示的值或异常。如果异步任务还没有完成，get() 会阻塞当前线程，直到任务完成。如果任务已经完成，get() 会立即返回任务的结果。重要的是，get() 只能调用一次，因为它会移动或消耗掉 std::future 对象的状态。一旦 get() 被调用，std::future 对象就不能再被用来获取结果。2. std::future::wait(): std::future::wait() 也是一个阻塞调用，但它与 get() 的主要区别在于 wait() 不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，wait() 会立即返回。如果任务还没有完成，wait() 会阻塞当前线程，直到任务完成。与 get() 不同，wait() 可以被多次调用，它不会消耗掉 std::future 对象的状态。 总结一下，这两个方法的主要区别在于： std::future::get() 用于获取并返回任务的结果，而 std::future::wait() 只是等待任务完成。 get() 只能调用一次，而 wait() 可以被多次调用。 如果任务还没有完成，get() 和 wait() 都会阻塞当前线程，但 get() 会一直阻塞直到任务完成并返回结果，而 wait() 只是在等待任务完成。 你可以使用std::future的wait_for()或wait_until()方法来检查异步操作是否已完成。这些方法返回一个表示操作状态的std::future_status值。 12345if(fut.wait_for(std::chrono::seconds(0)) == std::future_status::ready) &#123; // 操作已完成 &#125; else &#123; // 操作尚未完成 &#125; 将任务和future关联std::packaged_task和std::future是C++11中引入的两个类，它们用于处理异步任务的结果。 std::packaged_task是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在std::future对象中，以便以后使用。 std::future代表一个异步操作的结果。它可以用于从异步任务中获取返回值或异常。 以下是使用std::packaged_task和std::future的基本步骤： 创建一个std::packaged_task对象，该对象包装了要执行的任务。 调用std::packaged_task对象的get_future()方法，该方法返回一个与任务关联的std::future对象。 在另一个线程上调用std::packaged_task对象的operator()，以执行任务。 在需要任务结果的地方，调用与任务关联的std::future对象的get()方法，以获取任务的返回值或异常。 以下是一个简单的示例代码： 12345678910111213141516171819202122int my_task() &#123; std::this_thread::sleep_for(std::chrono::seconds(5)); std::cout &lt;&lt; &quot;my task run 5 s&quot; &lt;&lt; std::endl; return 42;&#125;void use_package() &#123; // 创建一个包装了任务的 std::packaged_task 对象 std::packaged_task&lt;int()&gt; task(my_task); // 获取与任务关联的 std::future 对象 std::future&lt;int&gt; result = task.get_future(); // 在另一个线程上执行任务 std::thread t(std::move(task)); t.detach(); // 将线程与主线程分离，以便主线程可以等待任务完成 // 等待任务完成并获取结果 int value = result.get(); std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125; 在上面的示例中，我们创建了一个包装了任务的std::packaged_task对象，并获取了与任务关联的std::future对象。然后，我们在另一个线程上执行任务，并等待任务完成并获取结果。最后，我们输出结果。 我们可以使用 std::function 和 std::package_task 来包装带参数的函数。std::package_task 是一个模板类，它包装了一个可调用对象，并允许我们将其作为异步任务传递。 promise 用法C++11引入了std::promise和std::future两个类，用于实现异步编程。std::promise用于在某一线程中设置某个值或异常，而std::future则用于在另一线程中获取这个值或异常。 下面是std::promise的基本用法： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;void set_value(std::promise&lt;int&gt; prom) &#123; // 设置 promise 的值 prom.set_value(10);&#125;int main() &#123; // 创建一个 promise 对象 std::promise&lt;int&gt; prom; // 获取与 promise 相关联的 future 对象 std::future&lt;int&gt; fut = prom.get_future(); // 在新线程中设置 promise 的值 std::thread t(set_value, std::move(prom)); // 在主线程中获取 future 的值 std::cout &lt;&lt; &quot;Waiting for the thread to set the value...\\n&quot;; std::cout &lt;&lt; &quot;Value set by the thread: &quot; &lt;&lt; fut.get() &lt;&lt; &#x27;\\n&#x27;; t.join(); return 0;&#125; 程序输出 123Waiting for the thread to set the value...promise set value successValue set by the thread:10 在上面的代码中，我们首先创建了一个std::promise&lt;int&gt;对象，然后通过调用get_future()方法获取与之相关联的std::future&lt;int&gt;对象。然后，我们在新线程中通过调用set_value()方法设置promise的值，并在主线程中通过调用fut.get()方法获取这个值。注意，在调用fut.get()方法时，如果promise的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。 除了set_value()方法外，std::promise还有一个set_exception()方法，用于设置异常。该方法接受一个std::exception_ptr参数，该参数可以通过调用std::current_exception()方法获取。下面是一个例子： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;void set_exception(std::promise&lt;void&gt; prom) &#123; try &#123; // 抛出一个异常 throw std::runtime_error(&quot;An error occurred!&quot;); &#125; catch(...) &#123; // 设置 promise 的异常 prom.set_exception(std::current_exception()); &#125;&#125;int main() &#123; // 创建一个 promise 对象 std::promise&lt;void&gt; prom; // 获取与 promise 相关联的 future 对象 std::future&lt;void&gt; fut = prom.get_future(); // 在新线程中设置 promise 的异常 std::thread t(set_exception, std::move(prom)); // 在主线程中获取 future 的异常 try &#123; std::cout &lt;&lt; &quot;Waiting for the thread to set the exception...\\n&quot;; fut.get(); &#125; catch(const std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception set by the thread: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; t.join(); return 0;&#125; 上述代码输出 12Waiting for the thread to set the exception...Exception set by the thread: An error occurred! 当然我们使用promise时要注意一点，如果promise被释放了，而其他的线程还未使用与promise关联的future，当其使用这个future时会报错。如下是一段错误展示 12345678910111213141516void use_promise_destruct() &#123; std::thread t; std::future&lt;int&gt; fut; &#123; // 创建一个 promise 对象 std::promise&lt;int&gt; prom; // 获取与 promise 相关联的 future 对象 fut = prom.get_future(); // 在新线程中设置 promise 的值 t = std::thread(set_value, std::move(prom)); &#125; // 在主线程中获取 future 的值 std::cout &lt;&lt; &quot;Waiting for the thread to set the value...\\n&quot;; std::cout &lt;&lt; &quot;Value set by the thread: &quot; &lt;&lt; fut.get() &lt;&lt; &#x27;\\n&#x27;; t.join();&#125; 随着局部作用域&#125;的结束，prom可能被释放也可能会被延迟释放，如果立即释放则fut.get()获取的值会报error_value的错误。 共享类型的future当我们需要多个线程等待同一个执行结果时，需要使用std::shared_future 以下是一个适合使用std::shared_future的场景，多个线程等待同一个异步操作的结果： 假设你有一个异步任务，需要多个线程等待其完成，然后这些线程需要访问任务的结果。在这种情况下，你可以使用std::shared_future来共享异步任务的结果。 1234567891011121314151617181920212223242526272829303132void myFunction(std::promise&lt;int&gt;&amp;&amp; promise) &#123; // 模拟一些工作 std::this_thread::sleep_for(std::chrono::seconds(1)); promise.set_value(42); // 设置 promise 的值&#125;void threadFunction(std::shared_future&lt;int&gt; future) &#123; try &#123; int result = future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; &#125; catch (const std::future_error&amp; e) &#123; std::cout &lt;&lt; &quot;Future error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125;void use_shared_future() &#123; std::promise&lt;int&gt; promise; std::shared_future&lt;int&gt; future = promise.get_future(); std::thread myThread1(myFunction, std::move(promise)); // 将 promise 移动到线程中 // 使用 share() 方法获取新的 shared_future 对象 std::thread myThread2(threadFunction, future); std::thread myThread3(threadFunction, future); myThread1.join(); myThread2.join(); myThread3.join();&#125; 在这个示例中，我们创建了一个std::promise&lt;int&gt;对象promise和一个与之关联的std::shared_future&lt;int&gt;对象future。然后，我们将promise对象移动到另一个线程myThread1中，该线程将执行myFunction函数，并在完成后设置promise的值。我们还创建了两个线程myThread2和myThread3，它们将等待future对象的结果。如果myThread1成功地设置了promise的值，那么future.get()将返回该值。这些线程可以同时访问和等待future对象的结果，而不会相互干扰。 但是大家要注意，如果一个future被移动给两个shared_future是错误的。 12345678910111213void use_shared_future() &#123; std::promise&lt;int&gt; promise; std::shared_future&lt;int&gt; future = promise.get_future(); std::thread myThread1(myFunction, std::move(promise)); // 将 promise 移动到线程中 std::thread myThread2(threadFunction, std::move(future)); std::thread myThread3(threadFunction, std::move(future)); myThread1.join(); myThread2.join(); myThread3.join();&#125; 这种用法是错误的，一个future通过隐式构造传递给shared_future之后，这个shared_future被移动传递给两个线程是不合理的，因为第一次移动后shared_future的生命周期被转移了，接下来myThread3构造时用的std::move(future)future已经失效了，会报错，一般都是no state 之类的错误。 异常处理std::future 是C++的一个模板类，它用于表示一个可能还没有准备好的异步操作的结果。你可以通过调用 std::future::get 方法来获取这个结果。如果在获取结果时发生了异常，那么 std::future::get 会重新抛出这个异常。 以下是一个例子，演示了如何在 std::future 中获取异常： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;stdexcept&gt;#include &lt;thread&gt;void may_throw()&#123; // 这里我们抛出一个异常。在实际的程序中，这可能在任何地方发生。 throw std::runtime_error(&quot;Oops, something went wrong!&quot;);&#125;int main()&#123; // 创建一个异步任务 std::future&lt;void&gt; result(std::async(std::launch::async, may_throw)); try &#123; // 获取结果（如果在获取结果时发生了异常，那么会重新抛出这个异常） result.get(); &#125; catch (const std::exception &amp;e) &#123; // 捕获并打印异常 std::cerr &lt;&lt; &quot;Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 在这个例子中，我们创建了一个异步任务 may_throw，这个任务会抛出一个异常。然后，我们创建一个 std::future 对象 result 来表示这个任务的结果。在 main 函数中，我们调用 result.get() 来获取任务的结果。如果在获取结果时发生了异常，那么 result.get() 会重新抛出这个异常，然后我们在 catch 块中捕获并打印这个异常。 上面的例子输出 1Caught exception: Oops, something went wrong! 线程池我们可以利用上面提到的std::packaged_task和std::promise构建线程池，提高程序的并发能力。先了解什么是线程池： 线程池是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。 线程池可以避免在处理短时间任务时创建与销毁线程的代价，它维护着多个线程，等待着监督管理者分配可并发执行的任务，从而提高了整体性能。 下面是我提供的一套线程池源码，目前用在公司的项目中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#ifndef __THREAD_POOL_H__#define __THREAD_POOL_H__#include &lt;atomic&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;vector&gt;class ThreadPool &#123;public: ThreadPool(const ThreadPool&amp;) = delete; ThreadPool&amp; operator=(const ThreadPool&amp;) = delete; static ThreadPool&amp; instance() &#123; static ThreadPool ins; return ins; &#125; using Task = std::packaged_task&lt;void()&gt;; ~ThreadPool() &#123; stop(); &#125; template &lt;class F, class... Args&gt; auto commit(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;decltype(f(args...))&gt; &#123; using RetType = decltype(f(args...)); if (stop_.load()) return std::future&lt;RetType&gt;&#123;&#125;; auto task = std::make_shared&lt;std::packaged_task&lt;RetType()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)); std::future&lt;RetType&gt; ret = task-&gt;get_future(); &#123; std::lock_guard&lt;std::mutex&gt; cv_mt(cv_mt_); tasks_.emplace([task] &#123; (*task)(); &#125;); &#125; cv_lock_.notify_one(); return ret; &#125; int idleThreadCount() &#123; return thread_num_; &#125;private: ThreadPool(unsigned int num = 5) : stop_(false) &#123; &#123; if (num &lt; 1) thread_num_ = 1; else thread_num_ = num; &#125; start(); &#125; void start() &#123; for (int i = 0; i &lt; thread_num_; ++i) &#123; pool_.emplace_back([this]() &#123; while (!this-&gt;stop_.load()) &#123; Task task; &#123; std::unique_lock&lt;std::mutex&gt; cv_mt(cv_mt_); this-&gt;cv_lock_.wait(cv_mt, [this] &#123; return this-&gt;stop_.load() || !this-&gt;tasks_.empty(); &#125;); if (this-&gt;tasks_.empty()) return; task = std::move(this-&gt;tasks_.front()); this-&gt;tasks_.pop(); &#125; this-&gt;thread_num_--; task(); this-&gt;thread_num_++; &#125; &#125;); &#125; &#125; void stop() &#123; stop_.store(true); cv_lock_.notify_all(); for (auto&amp; td : pool_) &#123; if (td.joinable()) &#123; std::cout &lt;&lt; &quot;join thread &quot; &lt;&lt; td.get_id() &lt;&lt; std::endl; td.join(); &#125; &#125; &#125;private: std::mutex cv_mt_; std::condition_variable cv_lock_; std::atomic_bool stop_; std::atomic_int thread_num_; std::queue&lt;Task&gt; tasks_; std::vector&lt;std::thread&gt; pool_;&#125;;#endif // !__THREAD_POOL_H__ 总结本文介绍了如何使用future, promise以及async用法 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用条件变量构造线程安全队列","date":"2023-09-09T07:00:01.000Z","path":"2023/09/09/concpp06/","text":"简介本文介绍如何使用条件变量控制并发的同步操作，试想有一个线程A一直输出1，另一个线程B一直输出2。我想让两个线程交替输出1，2，1，2…之类的效果，该如何实现？有的同学可能会说不是有互斥量mutex吗？可以用一个全局变量num表示应该哪个线程输出，比如num为1则线程A输出1，num为2则线程B输出2，mutex控制两个线程访问num，如果num和线程不匹配，就让该线程睡一会，这不就实现了吗？比如线程A加锁后发现当前num为2则表示它不能输出1，就解锁，将锁的使用权交给线程A，线程B就sleep一会。 不良实现上面说的方式可以实现我们需要的功能，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041void PoorImpleman() &#123; std::thread t1([]() &#123; for (;;) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx_num); if (num == 1) &#123; std::cout &lt;&lt; &quot;thread A print 1.....&quot; &lt;&lt; std::endl; num++; continue; &#125; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#125; &#125;); std::thread t2([]() &#123; for (;;) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx_num); if (num == 2) &#123; std::cout &lt;&lt; &quot;thread B print 2.....&quot; &lt;&lt; std::endl; num--; continue; &#125; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#125; &#125;); t1.join(); t2.join();&#125; PoorImpleman虽然能实现我们交替打印的功能，会造成消息处理的不及时，因为线程A要循环检测num值，如果num不为1，则线程A就睡眠了，在线程A睡眠这段时间很可能B已经处理完打印了，此时A还在睡眠，是对资源的浪费，也错过了最佳的处理时机。所以我们提出了用条件变量来通知线程的机制，当线程A发现条件不满足时可以挂起，等待线程B通知，线程B通知A后，A被唤醒继续处理。 条件变量我们这里用条件变量实现上面的逻辑 12345678910111213141516171819202122232425262728293031323334void ResonableImplemention() &#123; std::thread t1([]() &#123; for (;;) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_num); cvA.wait(lock, []() &#123; return num == 1; &#125;); num++; std::cout &lt;&lt; &quot;thread A print 1.....&quot; &lt;&lt; std::endl; cvB.notify_one(); &#125; &#125;); std::thread t2([]() &#123; for (;;) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_num); cvB.wait(lock, []() &#123; return num == 2; &#125;); num--; std::cout &lt;&lt; &quot;thread B print 2.....&quot; &lt;&lt; std::endl; cvA.notify_one(); &#125; &#125;); t1.join(); t2.join();&#125; 当条件不满足时(num 不等于1 时)cvA.wait就会挂起，等待线程B通知通知线程A唤醒，线程B采用的是cvA.notifyone。这么做的好处就是线程交替处理非常及时。比起sleep的方式，我们可以从控制台上看出差异效果，sleep的方式看出日志基本是每隔1秒才打印一次，效率不高。 线程安全队列之前我们实现过线程安全的栈，对于pop操作，我们如果在线程中调用empty判断是否为空，如果不为空，则pop，因为empty和pop内部分别加锁，是两个原子操作，导致pop时可能会因为其他线程提前pop导致队列为空，从而引发崩溃。我们当时的处理方式是实现了两个版本的pop，一种是返回智能指针类型，一种通过参数为引用的方式返回。对于智能指针版本我们发现队列为空则返回空指针，对于引用版本，发现队列为空则抛出异常，这么做并不是很友好，所以我们可以通过条件变量完善之前的程序，不过这次我们重新实现一个线程安全队列。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;template&lt;typename T&gt;class threadsafe_queue&#123;private: std::mutex mut; std::queue&lt;T&gt; data_queue; std::condition_variable data_cond;public: void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(new_value); data_cond.notify_one(); &#125; void wait_and_pop(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;); value=data_queue.front(); data_queue.pop(); &#125;&#125;;threadsafe_queue&lt;data_chunk&gt; data_queue; void data_preparation_thread()&#123; while(more_data_to_prepare()) &#123; data_chunk const data=prepare_data(); data_queue.push(data); ⇽--- ② &#125;&#125;void data_processing_thread()&#123; while(true) &#123; data_chunk data; data_queue.wait_and_pop(data); process(data); if(is_last_chunk(data)) break; &#125;&#125; 我们可以启动三个线程，一个producer线程用来向队列中放入数据。一个consumer1线程用来阻塞等待pop队列中的元素。 另一个consumer2尝试从队列中pop元素，如果队列为空则直接返回，如果非空则pop元素。 打印时为了保证线程输出在屏幕上不会乱掉，所以加了锁保证互斥输出 测试代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void test_safe_que() &#123; threadsafe_queue&lt;int&gt; safe_que; std::mutex mtx_print; std::thread producer( [&amp;]() &#123; for (int i = 0; ;i++) &#123; safe_que.push(i); &#123; std::lock_guard&lt;std::mutex&gt; printlk(mtx_print); std::cout &lt;&lt; &quot;producer push data is &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(200)); &#125; &#125; ); std::thread consumer1( [&amp;]() &#123; for (;;) &#123; auto data = safe_que.wait_and_pop(); &#123; std::lock_guard&lt;std::mutex&gt; printlk(mtx_print); std::cout &lt;&lt; &quot;consumer1 wait and pop data is &quot; &lt;&lt; *data &lt;&lt; std::endl; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#125; &#125; ); std::thread consumer2( [&amp;]() &#123; for (;;) &#123; auto data = safe_que.try_pop(); if (data != nullptr) &#123; &#123; std::lock_guard&lt;std::mutex&gt; printlk(mtx_print); std::cout &lt;&lt; &quot;consumer2 try_pop data is &quot; &lt;&lt; *data &lt;&lt; std::endl; &#125; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#125; &#125; ); producer.join(); consumer1.join(); consumer2.join();&#125; 测试效果如下 123456789101112131415producer push data is 0consumer1 wait and pop data is 0producer push data is 1producer push data is 2consumer2 try_pop data is 1consumer1 wait and pop data is 2producer push data is 3producer push data is 4consumer2 try_pop data is 3consumer1 wait and pop data is 4producer push data is 5producer push data is 6producer push data is 7consumer2 try_pop data is 5consumer1 wait and pop data is 6 我们能看到consumer1和consumer2是并发消费的 总结本文介绍了如何通过条件变量实现并发线程的同步处理。 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"线程安全的单例模式","date":"2023-09-03T03:36:47.000Z","path":"2023/09/03/concpp05/","text":"简介本文介绍C++ 线程安全的单例模式如何实现，通过介绍单例模式的演变历程，给读者更完备的实现单例模式的方案。 局部静态变量我们知道当一个函数中定义一个局部静态变量，那么这个局部静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的局部静态变量都不再初始化。那我们可以利用局部静态变量这一特点实现单例 1234567891011121314class Single2 &#123;private: Single2() &#123; &#125; Single2(const Single2&amp;) = delete; Single2&amp; operator=(const Single2&amp;) = delete;public: static Single2&amp; GetInst() &#123; static Single2 single; return single; &#125;&#125;; 上述版本的单例模式在C++11 以前存在多线程不安全的情况，编译器可能会初始化多个静态变量。但是C++11推出以后，各厂商优化编译器，能保证线程安全。所以为了保证运行安全请确保使用C++11以上的标准。 饿汉式初始化在C++11 推出以前，局部静态变量的方式实现单例存在线程安全问题，所以部分人推出了一种方案，就是在主线程启动后，其他线程没有启动前，由主线程先初始化单例资源，这样其他线程获取的资源就不涉及重复初始化的情况了。 123456789101112131415161718192021//饿汉式class Single2Hungry&#123;private: Single2Hungry() &#123; &#125; Single2Hungry(const Single2Hungry&amp;) = delete; Single2Hungry&amp; operator=(const Single2Hungry&amp;) = delete;public: static Single2Hungry* GetInst() &#123; if (single == nullptr) &#123; single = new Single2Hungry(); &#125; return single; &#125;private: static Single2Hungry* single;&#125;; 调用如下 1234567891011121314151617//饿汉式初始化Single2Hungry* Single2Hungry::single = Single2Hungry::GetInst();void thread_func_s2(int i)&#123; std::cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; i &lt;&lt; std::endl; std::cout &lt;&lt; &quot;inst is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; std::endl;&#125;void test_single2hungry()&#123; std::cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; std::endl; for (int i = 0; i &lt; 3; i++) &#123; std::thread tid(thread_func_s2, i); tid.join(); &#125;&#125; 饿汉式是从使用角度规避多线程的安全问题，很多情况下我们很难从规则角度限制开发人员，所以这种方式不是很推荐。 懒汉式初始化很多人觉得什么时候调用初始化是用户的权利，不应该加以限制，所以就有了懒汉式方式初始化资源，在用到时如果没有初始化单例则初始化，如果初始化了则直接使用.所以这种方式我们要加锁，防止资源被重复初始化。 1234567891011121314151617181920212223242526272829class SinglePointer&#123;private: SinglePointer() &#123; &#125; SinglePointer(const SinglePointer&amp;) = delete; SinglePointer&amp; operator=(const SinglePointer&amp;) = delete;public: static SinglePointer* GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; single = new SinglePointer(); s_mutex.unlock(); return single; &#125;private: static SinglePointer* single; static std::mutex s_mutex;&#125;; 调用如下 12345678910111213141516SinglePointer* SinglePointer::single = nullptr;std::mutex SinglePointer::s_mutex;void thread_func_lazy(int i)&#123; std::cout &lt;&lt; &quot;this is lazy thread &quot; &lt;&lt; i &lt;&lt; std::endl; std::cout &lt;&lt; &quot;inst is &quot; &lt;&lt; SinglePointer::GetInst() &lt;&lt; std::endl;&#125;void test_singlelazy()&#123; for (int i = 0; i &lt; 3; i++) &#123; std::thread tid(thread_func_lazy, i); tid.join(); &#125; //何时释放new的对象？造成内存泄漏&#125; 这种方式存在一个很严重的问题，就是当多个线程都调用单例函数时，我们不确定资源是被哪个线程初始化的。回收指针存在问题，存在多重释放或者不知道哪个指针释放的问题。 智能指针我们能想到一个自动初始化资源并且自动释放的方式就是智能指针。利用智能指针自动回收资源。 1234567891011121314151617181920212223242526272829303132333435//可以利用智能指针完成自动回收class SingleAuto&#123;private: SingleAuto() &#123; &#125; SingleAuto(const SingleAuto&amp;) = delete; SingleAuto&amp; operator=(const SingleAuto&amp;) = delete;public: ~SingleAuto() &#123; std::cout &lt;&lt; &quot;single auto delete success &quot; &lt;&lt; std::endl; &#125; static std::shared_ptr&lt;SingleAuto&gt; GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; single = std::shared_ptr&lt;SingleAuto&gt;(new SingleAuto); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAuto&gt; single; static std::mutex s_mutex;&#125;; 调用方式如下 1234567891011std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = nullptr;std::mutex SingleAuto::s_mutex;void test_singleauto()&#123; auto sp1 = SingleAuto::GetInst(); auto sp2 = SingleAuto::GetInst(); std::cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; std::endl; //此时存在隐患，可以手动删除裸指针，造成崩溃 // delete sp1.get();&#125; 这样开辟的资源交给智能指针管理免去了回收资源的麻烦。但是有些人觉得虽然智能指针能自动回收内存，如果有开发人员手动delete指针怎么办？所以有人提出了利用辅助类帮助智能指针释放资源，将智能指针的析构设置为私有。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//为了规避用户手动释放内存，可以提供一个辅助类帮忙回收内存//并将单例类的析构函数写为私有class SingleAutoSafe;class SafeDeletor&#123;public: void operator()(SingleAutoSafe* sf) &#123; std::cout &lt;&lt; &quot;this is safe deleter operator()&quot; &lt;&lt; std::endl; delete sf; &#125;&#125;;class SingleAutoSafe&#123;private: SingleAutoSafe() &#123;&#125; ~SingleAutoSafe() &#123; std::cout &lt;&lt; &quot;this is single auto safe deletor&quot; &lt;&lt; std::endl; &#125; SingleAutoSafe(const SingleAutoSafe&amp;) = delete; SingleAutoSafe&amp; operator=(const SingleAutoSafe&amp;) = delete; //定义友元类，通过友元类调用该类析构函数 friend class SafeDeletor;public: static std::shared_ptr&lt;SingleAutoSafe&gt; GetInst() &#123; //1处 if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); //2处 if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; //额外指定删除器 //3 处 single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDeletor()); //也可以指定删除函数 // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAutoSafe&gt; single; static std::mutex s_mutex;&#125;; SafeDeletor就是删除的辅助类，实现了仿函数。构造智能指针时指定了SafeDeletor对象，这样就能帮助智能指针释放了。 但是上面的代码存在危险，比如懒汉式的使用方式，当多个线程调用单例时，有一个线程加锁进入3处的逻辑。其他的线程有的在1处，判断指针非空则跳过初始化直接使用单例的内存会存在问题。主要原因在于SingleAutoSafe * temp = new SingleAutoSafe() 这个操作是由三部分组成的1 调用allocate开辟内存2 调用construct执行SingleAutoSafe的构造函数3 调用赋值操作将地址赋值给temp 而现实中2和3的步骤可能颠倒，所以有可能在一些编译器中通过优化是1，3，2的调用顺序，其他线程取到的指针就是非空，还没来的及调用构造函数就交给外部使用造成不可预知错误。为解决这个问题，C++11 推出了std::call_once函数保证多个线程只执行一次 call_onceC++11 提出了call_once函数，我们可以配合一个局部的静态变量once_flag实现线程安全的初始化。多线程调用call_once函数时，会判断once_flag是否被初始化，如没被初始化则进入初始化流程，调用我们提供的初始化函数。但是同一时刻只有一个线程能进入这个初始化函数。 12345678910111213141516171819202122232425262728class SingletonOnce &#123;private: SingletonOnce() = default; SingletonOnce(const SingletonOnce&amp;) = delete; SingletonOnce&amp; operator = (const SingletonOnce&amp; st) = delete; static std::shared_ptr&lt;SingletonOnce&gt; _instance;public : static std::shared_ptr&lt;SingletonOnce&gt; GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = std::shared_ptr&lt;SingletonOnce&gt;(new SingletonOnce); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; std::endl; &#125; ~SingletonOnce() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;&#125;;std::shared_ptr&lt;SingletonOnce&gt; SingletonOnce::_instance = nullptr; 调用方式如下 123456789101112131415void TestSingle() &#123; std::thread t1([]() &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); SingletonOnce::GetInstance()-&gt;PrintAddress(); &#125;); std::thread t2([]() &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); SingletonOnce::GetInstance()-&gt;PrintAddress(); &#125;); t1.join(); t2.join();&#125; 为了使用单例类更通用，比如项目中使用多个单例类，可以通过继承实现多个单例类 12345678910111213141516171819202122232425//为了让单例更加通用，可以做成模板类template &lt;typename T&gt;class Singleton &#123;protected: Singleton() = default; Singleton(const Singleton&lt;T&gt;&amp;) = delete; Singleton&amp; operator=(const Singleton&lt;T&gt;&amp; st) = delete; static std::shared_ptr&lt;T&gt; _instance;public: static std::shared_ptr&lt;T&gt; GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = std::shared_ptr&lt;T&gt;(new T); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; std::endl; &#125; ~Singleton() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr; 比如我们想实现单例类，就像我们之前在网络编程中介绍的那样，可以通过继承实现单例模式 123456789//想使用单例类，可以继承上面的模板，我们在网络编程中逻辑单例类用的就是这种方式class LogicSystem :public Singleton&lt;LogicSystem&gt;&#123; friend class Singleton&lt;LogicSystem&gt;;public: ~LogicSystem()&#123;&#125;private: LogicSystem()&#123;&#125;&#125;; 总结如果你只是实现一个简单的单例类推荐使用返回局部静态变量的方式如果想大规模实现多个单例类可以用call_once实现的模板类。 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 并发(4) unique_lock，读写锁以及递归锁","date":"2023-08-31T02:14:12.000Z","path":"2023/08/31/concpp04/","text":"简介本文介绍C++ 并发中使用的其他类型的锁，包括unique_lock，shared_lock, 以及recursive_lock等。shared_lock和unique_lock比较常用，而recursive_lock用的不多，或尽可能规避用这种锁。 unique_lockunique_lock和lock_guard基本用法相同，构造时默认加锁，析构时默认解锁，但unique_lock有个好处就是可以手动解锁。这一点尤为重要，方便我们控制锁住区域的粒度(加锁的范围大小),也能支持和条件变量配套使用，至于条件变量我们之后再介绍，本文主要介绍锁的相关操作。 12345678910//unique_lock 基本用法std::mutex mtx;int shared_data = 0;void use_unique() &#123; //lock可自动解锁，也可手动解锁 std::unique_lock&lt;std::mutex&gt; lock(mtx); std::cout &lt;&lt; &quot;lock success&quot; &lt;&lt; std::endl; shared_data++; lock.unlock();&#125; 我们可以通过unique_lock的owns_lock判断是否持有锁 1234567891011121314151617181920//可判断是否占有锁void owns_lock() &#123; //lock可自动解锁，也可手动解锁 std::unique_lock&lt;std::mutex&gt; lock(mtx); shared_data++; if (lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;owns lock&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;doesn&#x27;t own lock&quot; &lt;&lt; std::endl; &#125; lock.unlock(); if (lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;owns lock&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;doesn&#x27;t own lock&quot; &lt;&lt; std::endl; &#125;&#125; 上述代码输出 12owns lockdoesn&#x27;t own lock unique_lock可以延迟加锁 123456789 //可以延迟加锁void defer_lock() &#123; //延迟加锁 std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); //可以加锁 lock.lock(); //可以自动析构解锁，也可以手动解锁 lock.unlock();&#125; 那我们写一段代码综合运用owns_lock和defer_lock 1234567891011121314151617181920212223242526272829303132333435363738394041424344//同时使用owns和defervoid use_own_defer() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); // 判断是否拥有锁 if (lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;Main thread has the lock.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Main thread does not have the lock.&quot; &lt;&lt; std::endl; &#125; std::thread t([]() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); // 判断是否拥有锁 if (lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;Thread has the lock.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Thread does not have the lock.&quot; &lt;&lt; std::endl; &#125; // 加锁 lock.lock(); // 判断是否拥有锁 if (lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;Thread has the lock.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Thread does not have the lock.&quot; &lt;&lt; std::endl; &#125; // 解锁 lock.unlock(); &#125;); t.join();&#125; 上述代码回依次输出, 但是程序会阻塞，因为子线程会卡在加锁的逻辑上，因为主线程未释放锁，而主线程又等待子线程退出，导致整个程序卡住。 12Main thread has the lock.Thread does not have the lock. 和lock_guard一样，unique_lock也支持领养锁 123456789101112//同样支持领养操作void use_own_adopt() &#123; mtx.lock(); std::unique_lock&lt;std::mutex&gt; lock(mtx, std::adopt_lock); if (lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;owns lock&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;does not have the lock&quot; &lt;&lt; std::endl; &#125; lock.unlock();&#125; 尽管是领养的，但是打印还是会出现owns lock，因为不管如何锁被加上，就会输出owns lock。 既然unique_lock支持领养操作也支持延迟加锁，那么可以用两种方式实现前文lock_guard实现的swap操作。 1234567891011121314151617181920212223242526//之前的交换代码可以可以用如下方式等价实现int a = 10;int b = 99;std::mutex mtx1;std::mutex mtx2;void safe_swap() &#123; std::lock(mtx1, mtx2); std::unique_lock&lt;std::mutex&gt; lock1(mtx1, std::adopt_lock); std::unique_lock&lt;std::mutex&gt; lock2(mtx2, std::adopt_lock); std::swap(a, b); //错误用法 //mtx1.unlock(); //mtx2.unlock();&#125;void safe_swap2() &#123; std::unique_lock&lt;std::mutex&gt; lock1(mtx1, std::defer_lock); std::unique_lock&lt;std::mutex&gt; lock2(mtx2, std::defer_lock); //需用lock1,lock2加锁 std::lock(lock1, lock2); //错误用法 //std::lock(mtx1, mtx2); std::swap(a, b);&#125; 大家注意一旦mutex被unique_lock管理，加锁和释放的操作就交给unique_lock，不能调用mutex加锁和解锁，因为锁的使用权已经交给unique_lock了。 我们知道mutex是不支持移动和拷贝的，但是unique_lock支持移动，当一个mutex被转移给unique_lock后，可以通过unique_ptr转移其归属权. 123456789101112//转移互斥量所有权//互斥量本身不支持move操作，但是unique_lock支持std::unique_lock &lt;std::mutex&gt; get_lock() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); shared_data++; return lock;&#125;void use_return() &#123; std::unique_lock&lt;std::mutex&gt; lock(get_lock()); shared_data++;&#125; 锁的粒度表示加锁的精细程度，一个锁的粒度要足够大，保证可以锁住要访问的共享数据。 同时一个锁的粒度要足够小，保证非共享数据不被锁住影响性能。 而unique_ptr则很好的支持手动解锁。 123456789void precision_lock() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); shared_data++; lock.unlock(); //不设计共享数据的耗时操作不要放在锁内执行 std::this_thread::sleep_for(std::chrono::seconds(1)); lock.lock(); shared_data++;&#125; 共享锁试想这样一个场景，对于一个DNS服务，我们可以根据域名查询服务对应的ip地址，它很久才更新一次，比如新增记录，删除记录或者更新记录等。平时大部分时间都是提供给外部查询，对于查询操作，即使多个线程并发查询不加锁也不会有问题，但是当有线程修改DNS服务的ip记录或者增减记录时，其他线程不能查询，需等待修改完再查询。或者等待查询完，线程才能修改。也就是说读操作并不是互斥的，同一时间可以有多个线程同时读，但是写和读是互斥的，写与写是互斥的，简而言之，写操作需要独占锁。而读操作需要共享锁。 要想使用共享锁，需使用共享互斥量std::shared_mutex,std::shared_mutex是C++17标准提出的。C++14标准可以使用std::shared_time_mutex, std::shared_mutex 和 std::shared_timed_mutex 都是用于实现多线程并发访问共享数据的互斥锁，但它们之间存在一些区别： std::shared_mutex： * 提供了 `lock()`, `try_lock()`, 和 `try_lock_for()` 以及 `try_lock_until()` 函数，这些函数都可以用于获取互斥锁。 * 提供了 `try_lock_shared()` 和 `lock_shared()` 函数，这些函数可以用于获取共享锁。 * 当 `std::shared_mutex` 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁。 std::shared_timed_mutex： * 与 `std::shared_mutex` 类似，也提供了 `lock()`, `try_lock()`, 和 `try_lock_for()` 以及 `try_lock_until()` 函数用于获取互斥锁。 * 与 `std::shared_mutex` 不同的是，它还提供了 `try_lock_shared()` 和 `lock_shared()` 函数用于获取共享锁，这些函数在尝试获取共享锁时具有超时机制。 * 当 `std::shared_timed_mutex` 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁，这与 `std::shared_mutex` 相同。然而，当尝试获取共享锁时，如果不能立即获得锁，`std::shared_timed_mutex` 会设置一个超时，超时过后如果仍然没有获取到锁，则操作将返回失败。 因此，std::shared_timed_mutex 提供了额外的超时机制，这使得它在某些情况下更适合于需要处理超时的并发控制。然而，如果不需要超时机制，可以使用更简单的 std::shared_mutex。 C++11标准没有共享互斥量，可以使用boost提供的boost::shared_mutex。 如果我们想构造共享锁，可以使用std::shared_lock，如果我们想构造独占锁, 可以使用std::lock_gurad. 我们用一个类DNService代表DNS服务，查询操作使用共享锁，而写操作使用独占锁，可以是如下方式的。 1234567891011121314151617181920212223class DNService &#123;public: DNService() &#123;&#125; //读操作采用共享锁 std::string QueryDNS(std::string dnsname) &#123; std::shared_lock&lt;std::shared_mutex&gt; shared_locks(_shared_mtx); auto iter = _dns_info.find(dnsname); if (iter != _dns_info.end()) &#123; return iter-&gt;second; &#125; return &quot;&quot;; &#125; //写操作采用独占锁 void AddDNSInfo(std::string dnsname, std::string dnsentry) &#123; std::lock_guard&lt;std::shared_mutex&gt; guard_locks(_shared_mtx); _dns_info.insert(std::make_pair(dnsname, dnsentry)); &#125;private: std::map&lt;std::string, std::string&gt; _dns_info; mutable std::shared_mutex _shared_mtx;&#125;; QueryDNS 用来查询dns信息，多个线程可同时访问。AddDNSInfo 用来添加dns信息，属独占锁，同一时刻只有一个线程在修改。 递归锁有时候我们在实现接口的时候内部加锁，接口内部调用完结束自动解锁。会出现一个接口调用另一个接口的情况，如果用普通的std::mutex就会出现卡死，因为嵌套加锁导致卡死。但是我们可以使用递归锁。 但我个人并不推荐递归锁，可以从设计源头规避嵌套加锁的情况，我们可以将接口相同的功能抽象出来，统一加锁。下面的设计演示了如何使用递归锁 1234567891011121314151617181920212223242526272829303132333435363738394041class RecursiveDemo &#123;public: RecursiveDemo() &#123;&#125; bool QueryStudent(std::string name) &#123; std::lock_guard&lt;std::recursive_mutex&gt; recursive_lock(_recursive_mtx); auto iter_find = _students_info.find(name); if (iter_find == _students_info.end()) &#123; return false; &#125; return true; &#125; void AddScore(std::string name, int score) &#123; std::lock_guard&lt;std::recursive_mutex&gt; recursive_lock(_recursive_mtx); if (!QueryStudent(name)) &#123; _students_info.insert(std::make_pair(name, score)); return; &#125; _students_info[name] = _students_info[name] + score; &#125; //不推荐采用递归锁，使用递归锁说明设计思路并不理想，需优化设计 //推荐拆分逻辑，将共有逻辑拆分为统一接口 void AddScoreAtomic(std::string name, int score) &#123; std::lock_guard&lt;std::recursive_mutex&gt; recursive_lock(_recursive_mtx); auto iter_find = _students_info.find(name); if (iter_find == _students_info.end()) &#123; _students_info.insert(std::make_pair(name, score)); return; &#125; _students_info[name] = _students_info[name] + score; return; &#125;private: std::map&lt;std::string, int&gt; _students_info; std::recursive_mutex _recursive_mtx;&#125;; 我们可以看到AddScore函数内部调用了QueryStudent, 所以采用了递归锁。 但是我们同样可以改变设计，将两者公有的部分抽离出来生成一个新的接口AddScoreAtomic. AddScoreAtomic可以不适用递归锁，照样能完成线程安全操作的目的。 总结本文介绍了unique_lock，共享锁，递归锁等的使用，较为全面的介绍了这几种锁的使用场景和潜在风险。 视频链接 https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接 https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 并发(3) 互斥与死锁","date":"2023-08-20T02:46:40.000Z","path":"2023/08/20/concpp03/","text":"简介本文介绍如何使用互斥量保证共享数据的安全，并讲述死锁的相关处理方案。 锁的使用我们可以通过mutex对共享数据进行夹所，防止多线程访问共享区造成数据不一致问题。如下，我们初始化一个共享变量shared_data，然后定义了一个互斥量std::mutex，接下来启动了两个线程，分别执行use_lock增加数据，和一个lambda表达式减少数据。结果可以看到两个线程对于共享数据的访问是独占的，单位时间片只有一个线程访问并输出日志。 123456789101112131415161718192021222324252627282930313233std::mutex mtx1;int shared_data = 100;void use_lock() &#123; while (true) &#123; mtx1.lock(); shared_data++; std::cout &lt;&lt; &quot;current thread is &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sharad data is &quot; &lt;&lt; shared_data &lt;&lt; std::endl; mtx1.unlock(); std::this_thread::sleep_for(std::chrono::microseconds(10)); &#125;&#125;void test_lock() &#123; std::thread t1(use_lock); std::thread t2([]() &#123; while (true) &#123; mtx1.lock(); shared_data--; std::cout &lt;&lt; &quot;current thread is &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sharad data is &quot; &lt;&lt; shared_data &lt;&lt; std::endl; mtx1.unlock(); std::this_thread::sleep_for(std::chrono::microseconds(10)); &#125; &#125;); t1.join(); t2.join();&#125; lock_guard的使用当然我们可以用lock_guard自动加锁和解锁,比如上面的函数可以等价简化为 12345678910void use_lock() &#123; while (true) &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx1); shared_data++; std::cout &lt;&lt; &quot;current thread is &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sharad data is &quot; &lt;&lt; shared_data &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(10)); &#125;&#125; lock_guard在作用域结束时自动调用其析构函数解锁，这么做的一个好处是简化了一些特殊情况从函数中返回的写法，比如异常或者条件不满足时，函数内部直接return，锁也会自动解开。 如何保证数据安全有时候我们可以将对共享数据的访问和修改聚合到一个函数，在函数内加锁保证数据的安全性。但是对于读取类型的操作，即使读取函数是线程安全的，但是返回值抛给外边使用，存在不安全性。比如一个栈对象，我们要保证其在多线程访问的时候是安全的，可以在判断栈是否为空，判断操作内部我们可以加锁，但是判断结束后返回值就不在加锁了，就会存在线程安全问题。 比如我定义了如下栈, 对于多线程访问时判断栈是否为空，此后两个线程同时出栈，可能会造成崩溃。 123456789101112131415161718192021222324252627282930313233343536template&lt;typename T&gt;class threadsafe_stack1&#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack1() &#123;&#125; threadsafe_stack1(const threadsafe_stack1&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.m); //①在构造函数的函数体（constructor body）内进行复制操作 data = other.data; &#125; threadsafe_stack1&amp; operator=(const threadsafe_stack1&amp;) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); data.push(std::move(new_value)); &#125; //问题代码 T pop() &#123; std::lock_guard&lt;std::mutex&gt; lock(m); auto element = data.top(); data.pop(); return element; &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); &#125;&#125;; 如下, 线程1和线程2先后判断栈都不为空，之后执行出战操作，会造成崩溃。 123456789101112131415161718192021void test_threadsafe_stack1() &#123; threadsafe_stack1&lt;int&gt; safe_stack; safe_stack.push(1); std::thread t1([&amp;safe_stack]() &#123; if (!safe_stack.empty()) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); safe_stack.pop(); &#125; &#125;); std::thread t2([&amp;safe_stack]() &#123; if (!safe_stack.empty()) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); safe_stack.pop(); &#125; &#125;); t1.join(); t2.join();&#125; 解决这个问题我们可以用抛出异常的方式，比如定义一个空栈的异常 1234struct empty_stack : std::exception&#123; const char* what() const throw();&#125;; 然后实现我们的出栈函数 12345678T pop()&#123; std::lock_guard&lt;std::mutex&gt; lock(m); if (data.empty()) throw empty_stack(); auto element = data.top(); data.pop(); return element;&#125; 这么做就需要在外层使用的时候捕获异常。这是C++ 并发编程中提及的建议。但是我觉得可以在函数pop内部再次判断栈是否为空，若为空则返回一个非法数据，这样比抛出异常好一些。但是如果T是一个复杂类型，我们很难定义一个非法值给外界知晓，这一点可以通过智能指针进行优化。之后我们再介绍更优化的方案，因为现在这个pop函数仍存在问题，比如T是一个vector&lt;int&gt;类型，那么在pop函数内部element就是vector&lt;int&gt;类型，开始element存储了一些int值，程序没问题，函数执行pop操作， 假设此时程序内存暴增，导致当程序使用的内存足够大时，可用的有效空间不够， 函数返回element时，就会就会存在vector做拷贝赋值时造成失败。即使我们捕获异常，释放部分空间但也会导致栈元素已经出栈，数据丢失了。这其实是内存管理不当造成的，但是C++ 并发编程一书中给出了优化方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct empty_stack : std::exception&#123; const char* what() const throw();&#125;;template&lt;typename T&gt;class threadsafe_stack&#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack() &#123;&#125; threadsafe_stack(const threadsafe_stack&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.m); //①在构造函数的函数体（constructor body）内进行复制操作 data = other.data; &#125; threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); data.push(std::move(new_value)); &#125; std::shared_ptr&lt;T&gt; pop() &#123; std::lock_guard&lt;std::mutex&gt; lock(m); //②试图弹出前检查是否为空栈 if (data.empty()) throw empty_stack(); //③改动栈容器前设置返回值 std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top())); data.pop(); return res; &#125; void pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if (data.empty()) throw empty_stack(); value = data.top(); data.pop(); &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); &#125;&#125;; 我们提供了两个版本的pop操作，一个是带引用类型的参数的，一个是直接pop出智能指针类型，这样在pop函数内部减少了数据的拷贝，防止内存溢出，其实这两种做法确实是相比之前直接pop固定类型的值更节省内存，运行效率也好很多。我们也完全可以基于之前的思想，在pop时如果队列为空则返回空指针，这样比抛出异常更有好一些 12345678910std::shared_ptr&lt;T&gt; pop()&#123; std::lock_guard&lt;std::mutex&gt; lock(m); //②试图弹出前检查是否为空栈 if (data.empty()) return nullptr; //③改动栈容器前设置返回值 std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top())); data.pop(); return res;&#125; 死锁怎么造成的死锁一般是由于调运顺序不一致导致的，比如两个线程循环调用。当线程1先加锁A，再加锁B，而线程2先加锁B，再加锁A。那么在某一时刻就可能造成死锁。比如线程1对A已经加锁，线程2对B已经加锁，那么他们都希望彼此占有对方的锁，又不释放自己占有的锁导致了死锁。举个例子 1234567891011121314151617181920212223242526272829303132std::mutex t_lock1;std::mutex t_lock2;int m_1 = 0;int m_2 = 1;void dead_lock1() &#123; while (true) &#123; std::cout &lt;&lt; &quot;dead_lock1 begin &quot; &lt;&lt; std::endl; t_lock1.lock(); m_1 = 1024; t_lock2.lock(); m_2 = 2048; t_lock2.unlock(); t_lock1.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); std::cout &lt;&lt; &quot;dead_lock2 end &quot; &lt;&lt; std::endl; &#125;&#125;void dead_lock2() &#123; while (true) &#123; std::cout &lt;&lt; &quot;dead_lock2 begin &quot; &lt;&lt; std::endl; t_lock2.lock(); m_2 = 2048; t_lock1.lock(); m_1 = 1024; t_lock1.unlock(); t_lock2.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); std::cout &lt;&lt; &quot;dead_lock2 end &quot; &lt;&lt; std::endl; &#125;&#125; 然后我们启动两个线程 123456void test_dead_lock() &#123; std::thread t1(dead_lock1); std::thread t2(dead_lock2); t1.join(); t2.join();&#125; 这样运行之后在某一个时刻一定会导致死锁。实际工作中避免死锁的一个方式就是将加锁和解锁的功能封装为独立的函数，这样能保证在独立的函数里执行完操作后就解锁，不会导致一个函数里使用多个锁的情况 123456789101112131415161718192021222324252627282930313233343536373839//加锁和解锁作为原子操作解耦合，各自只管理自己的功能void atomic_lock1() &#123; std::cout &lt;&lt; &quot;lock1 begin lock&quot; &lt;&lt; std::endl; t_lock1.lock(); m_1 = 1024; t_lock1.unlock(); std::cout &lt;&lt; &quot;lock1 end lock&quot; &lt;&lt; std::endl;&#125;void atomic_lock2() &#123; std::cout &lt;&lt; &quot;lock2 begin lock&quot; &lt;&lt; std::endl; t_lock2.lock(); m_2 = 2048; t_lock2.unlock(); std::cout &lt;&lt; &quot;lock2 end lock&quot; &lt;&lt; std::endl;&#125;void safe_lock1() &#123; while (true) &#123; atomic_lock1(); atomic_lock2(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125;&#125;void safe_lock2() &#123; while (true) &#123; atomic_lock2(); atomic_lock1(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125;&#125;void test_safe_lock() &#123; std::thread t1(safe_lock1); std::thread t2(safe_lock2); t1.join(); t2.join();&#125; 同时加锁当我们无法避免在一个函数内部使用两个互斥量，并且都要解锁的情况，那我们可以采取同时加锁的方式。我们先定义一个类,假设这个类不推荐拷贝构造，但我们也提供了这个类的拷贝构造和移动构造 1234567891011121314151617181920212223242526272829303132333435class som_big_object &#123;public: som_big_object(int data) :_data(data) &#123;&#125; //拷贝构造 som_big_object(const som_big_object&amp; b2) :_data(b2._data) &#123; _data = b2._data; &#125; //移动构造 som_big_object(som_big_object&amp;&amp; b2) :_data(std::move(b2._data)) &#123; &#125; //重载输出运算符 friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const som_big_object&amp; big_obj) &#123; os &lt;&lt; big_obj._data; return os; &#125; //重载赋值运算符 som_big_object&amp; operator = (const som_big_object&amp; b2) &#123; if (this == &amp;b2) &#123; return *this; &#125; _data = b2._data; return *this; &#125; //交换数据 friend void swap(som_big_object&amp; b1, som_big_object&amp; b2) &#123; som_big_object temp = std::move(b1); b1 = std::move(b2); b2 = std::move(temp); &#125;private: int _data;&#125;; 接下来我们定义一个类对上面的类做管理，为防止多线程情况下数据混乱， 包含了一个互斥量。 12345678910111213class big_object_mgr &#123;public: big_object_mgr(int data = 0) :_obj(data) &#123;&#125; void printinfo() &#123; std::cout &lt;&lt; &quot;current obj data is &quot; &lt;&lt; _obj &lt;&lt; std::endl; &#125; friend void danger_swap(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2); friend void safe_swap(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2); friend void safe_swap_scope(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2);private: std::mutex _mtx; som_big_object _obj;&#125;; 为了方便演示哪些交换是安全的，哪些是危险的，所以写了三个函数。 123456789101112void danger_swap(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2) &#123; std::cout &lt;&lt; &quot;thread [ &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ] begin&quot; &lt;&lt; std::endl; if (&amp;objm1 == &amp;objm2) &#123; return; &#125; std::lock_guard &lt;std::mutex&gt; gurad1(objm1._mtx); //此处为了故意制造死锁，我们让线程小睡一会 std::this_thread::sleep_for(std::chrono::seconds(1)); std::lock_guard&lt;std::mutex&gt; guard2(objm2._mtx); swap(objm1._obj, objm2._obj); std::cout &lt;&lt; &quot;thread [ &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ] end&quot; &lt;&lt; std::endl;&#125; danger_swap是危险的交换方式。比如如下调用 123456789101112void test_danger_swap() &#123; big_object_mgr objm1(5); big_object_mgr objm2(100); std::thread t1(danger_swap, std::ref(objm1), std::ref(objm2)); std::thread t2(danger_swap, std::ref(objm2), std::ref(objm1)); t1.join(); t2.join(); objm1.printinfo(); objm2.printinfo();&#125; 这种调用方式存在隐患，因为danger_swap函数在两个线程中使用会造成互相竞争加锁的情况。那就需要用锁同时锁住两个锁。 123456789101112131415161718void safe_swap(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2) &#123; std::cout &lt;&lt; &quot;thread [ &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ] begin&quot; &lt;&lt; std::endl; if (&amp;objm1 == &amp;objm2) &#123; return; &#125; std::lock(objm1._mtx, objm2._mtx); //领养锁管理它自动释放 std::lock_guard &lt;std::mutex&gt; gurad1(objm1._mtx, std::adopt_lock); //此处为了故意制造死锁，我们让线程小睡一会 std::this_thread::sleep_for(std::chrono::seconds(1)); std::lock_guard &lt;std::mutex&gt; gurad2(objm2._mtx, std::adopt_lock); swap(objm1._obj, objm2._obj); std::cout &lt;&lt; &quot;thread [ &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ] end&quot; &lt;&lt; std::endl;&#125; 比如下面的调用就是合理的 123456789101112void test_safe_swap() &#123; big_object_mgr objm1(5); big_object_mgr objm2(100); std::thread t1(safe_swap, std::ref(objm1), std::ref(objm2)); std::thread t2(safe_swap, std::ref(objm2), std::ref(objm1)); t1.join(); t2.join(); objm1.printinfo(); objm2.printinfo();&#125; 当然上面加锁的方式可以简化，C++17 scope_lock可以对多个互斥量同时加锁，并且自动释放 12345678910111213//上述代码可以简化为以下方式void safe_swap_scope(big_object_mgr&amp; objm1, big_object_mgr&amp; objm2) &#123; std::cout &lt;&lt; &quot;thread [ &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ] begin&quot; &lt;&lt; std::endl; if (&amp;objm1 == &amp;objm2) &#123; return; &#125; std::scoped_lock guard(objm1._mtx, objm2._mtx); //等价于 //std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(objm1._mtx, objm2._mtx); swap(objm1._obj, objm2._obj); std::cout &lt;&lt; &quot;thread [ &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ] end&quot; &lt;&lt; std::endl;&#125; 层级锁现实开发中常常很难规避同一个函数内部加多个锁的情况，我们要尽可能避免循环加锁，所以可以自定义一个层级锁，保证实际项目中对多个互斥量加锁时是有序的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//层级锁class hierarchical_mutex &#123;public: explicit hierarchical_mutex(unsigned long value) :_hierarchy_value(value), _previous_hierarchy_value(0) &#123;&#125; hierarchical_mutex(const hierarchical_mutex&amp;) = delete; hierarchical_mutex&amp; operator=(const hierarchical_mutex&amp;) = delete; void lock() &#123; check_for_hierarchy_violation(); _internal_mutex.lock(); update_hierarchy_value(); &#125; void unlock() &#123; if (_this_thread_hierarchy_value != _hierarchy_value) &#123; throw std::logic_error(&quot;mutex hierarchy violated&quot;); &#125; _this_thread_hierarchy_value = _previous_hierarchy_value; _internal_mutex.unlock(); &#125; bool try_lock() &#123; check_for_hierarchy_violation(); if (!_internal_mutex.try_lock()) &#123; return false; &#125; update_hierarchy_value(); return true; &#125;private: std::mutex _internal_mutex; //当前层级值 unsigned long const _hierarchy_value; //上一次层级值 unsigned long _previous_hierarchy_value; //本线程记录的层级值 static thread_local unsigned long _this_thread_hierarchy_value; void check_for_hierarchy_violation() &#123; if (_this_thread_hierarchy_value &lt;= _hierarchy_value) &#123; throw std::logic_error(&quot;mutex hierarchy violated&quot;); &#125; &#125; void update_hierarchy_value() &#123; _previous_hierarchy_value = _this_thread_hierarchy_value; _this_thread_hierarchy_value = _hierarchy_value; &#125;&#125;;thread_local unsigned long hierarchical_mutex::_this_thread_hierarchy_value(ULONG_MAX);void test_hierarchy_lock() &#123; hierarchical_mutex hmtx1(1000); hierarchical_mutex hmtx2(500); std::thread t1([&amp;hmtx1, &amp;hmtx2]() &#123; hmtx1.lock(); hmtx2.lock(); hmtx2.unlock(); hmtx1.unlock(); &#125;); std::thread t2([&amp;hmtx1, &amp;hmtx2]() &#123; hmtx2.lock(); hmtx1.lock(); hmtx1.unlock(); hmtx2.unlock(); &#125;); t1.join(); t2.join();&#125; 层级锁能保证我们每个线程加锁时，一定是先加权重高的锁。并且释放时也保证了顺序。主要原理就是将当前锁的权重保存在线程变量中，这样该线程再次加锁时判断线程变量的权重和锁的权重是否大于，如果满足条件则继续加锁。 总结本文介绍了线程互斥的常见问题和基本处理方案，在实际开发中，根据具体情境具体分析。 视频链接https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 并发(2) 线程管控","date":"2023-08-12T05:17:54.000Z","path":"2023/08/12/concpp02/","text":"简介本节介绍C++线程管控，包括移交线程的归属权，线程并发数量控制以及获取线程id等基本操作。 线程归属权我们之前介绍了线程可以通过detach在后台运行或者让开辟这个线程的父线程等待该线程完成。但每个线程都应该有其归属权，也就是归属给某个变量管理。比如 12345void some_function() &#123;&#125;std::thread t1(some_function); t1是一个线程变量，管理一个线程，该线程执行some_function()对于std::thread C++ 不允许其执行拷贝构造和拷贝赋值, 所以只能通过移动和局部变量返回的方式将线程变量管理的线程转移给其他变量管理。C++ 中类似的类型还有std::mutex, std::ifstream, std::unique_ptr。比如下面，我们说明了线程归属权的转移方式 12345678910111213141516171819202122232425void some_function() &#123; while (true) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125;&#125;void some_other_function() &#123; while (true) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125;&#125;//t1 绑定some_functionstd::thread t1(some_function); //2 转移t1管理的线程给t2，转移后t1无效std::thread t2 = std::move(t1);//3 t1 可继续绑定其他线程,执行some_other_functiont1 = std::thread(some_other_function);//4 创建一个线程变量t3std::thread t3;//5 转移t2管理的线程给t3t3 = std::move(t2);//6 转移t3管理的线程给t1t1 = std::move(t3);std::this_thread::sleep_for(std::chrono::seconds(2000)); 上面的代码会引发崩溃，是因为步骤6造成的崩溃。让主函数睡眠2000秒，是为了告诉规避主函数退出引发崩溃的问题，因为我们在之前给大家演示过，如果线程不detach或者join，主线程退出时会引发崩溃，而我们这些线程没有join和detach，为了给大家演示是因为步骤6引发的崩溃，所以让主线程睡眠2000秒暂时不退出，但是程序仍然会崩溃，说明是步骤6导致的崩溃。 上面代码将t2管理的线程交给t3之后将t3管理的线程交给t1，此时t1管理线程运行着 some_function步骤6导致崩溃的原因就是将t3管理的线程交给t1，而此时t1正在管理线程运行some_other_function。所以我们可以得出一个结论，就是不要将一个线程的管理权交给一个已经绑定线程的变量，否则会触发线程的terminate函数引发崩溃。 和std::unique_ptr一样，我们可以在函数内部返回一个局部的std::thread变量。如下: 12345678910111213std::thread f() &#123; return std::thread(some_function);&#125;void param_function(int a) &#123; while (true) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125;&#125;std::thread g() &#123; std::thread t(param_function, 43);&#125; 因为C++ 在返回局部变量时，会优先寻找这个类的拷贝构造函数，如果没有就会使用这个类的移动构造函数。 joining_thread曾经有一份C++17标准的备选提案，主张引入新的类joining_thread，它与std::thread类似，但只要其执行析构函数，线程即能自动汇合，这点与scoped_thread非常像。可惜C++标准委员会未能达成共识，结果C++17标准没有引入这个类，后来它改名为std::jthread，依然进入了C++20标准的议程（现已被正式纳入C++20标准）。除去这些，实际上joining_thread类的代码相对容易编写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class joining_thread &#123; std::thread _t;public: joining_thread() noexcept = default; template&lt;typename Callable, typename ... Args&gt; explicit joining_thread(Callable&amp;&amp; func, Args&amp;&amp; ...args): t(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args)...)&#123;&#125; explicit joining_thread(std::thread t) noexcept: _t(std::move(t))&#123;&#125; joining_thread(joining_thread&amp;&amp; other) noexcept: _t(std::move(other._t))&#123;&#125; joining_thread&amp; operator=(joining_thread&amp;&amp; other) noexcept &#123; //如果当前线程可汇合，则汇合等待线程完成再赋值 if (joinable()) &#123; join(); &#125; _t = std::move(other._t); return *this; &#125; joining_thread&amp; operator=(joining_thread other) noexcept &#123; //如果当前线程可汇合，则汇合等待线程完成再赋值 if (joinable()) &#123; join(); &#125; _t = std::move(other._t); return *this; &#125; ~joining_thread() noexcept &#123; if (joinable()) &#123; join(); &#125; &#125; void swap(joining_thread&amp; other) noexcept &#123; _t.swap(other._t); &#125; std::thread::id get_id() const noexcept &#123; return _t.get_id(); &#125; bool joinable() const noexcept &#123; return _t.joinable(); &#125; void join() &#123; _t.join(); &#125; void detach() &#123; _t.detach(); &#125; std::thread&amp; as_thread() noexcept &#123; return _t; &#125; const std::thread&amp; as_thread() const noexcept &#123; return _t; &#125;&#125;; 使用起来比较简单，我们直接构造一个joining_thread对象即可。 12345678910111213141516171819202122232425262728293031323334void use_jointhread() &#123; //1 根据线程构造函数构造joiningthread joining_thread j1([](int maxindex) &#123; for (int i = 0; i &lt; maxindex; i++) &#123; std::cout &lt;&lt; &quot;in thread id &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; cur index is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;, 10); //2 根据thread构造joiningthread joining_thread j2(std::thread([](int maxindex) &#123; for (int i = 0; i &lt; maxindex; i++) &#123; std::cout &lt;&lt; &quot;in thread id &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; cur index is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;, 10)); //3 根据thread构造j3 joining_thread j3(std::thread([](int maxindex) &#123; for (int i = 0; i &lt; maxindex; i++) &#123; std::cout &lt;&lt; &quot;in thread id &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; cur index is &quot; &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;, 10)); //4 把j3赋值给j1，joining_thread内部会等待j1汇合结束后 //再将j3赋值给j1 j1 = std::move(j3);ervice&#125; 容器存储容器存储线程时，比如vector,如果用push_back操作势必会调用std::thread，这样会引发编译错误，因为std::thread没有拷贝构造函数。我们在之前网络编程实现IOServicePool或者IOThreadPool时初始化了多个线程存储在vector中, 采用的时emplace方式，可以直接根据线程构造函数需要的参数构造，这样就避免了调用thread的拷贝构造函数。 类似于这种 12345678910void use_vector() &#123; std::vector&lt;std::thread&gt; threads; for (unsigned i = 0; i &lt; 10; ++i) &#123; threads.emplace_back(param_function, i); &#125; for (auto&amp; entry : threads) &#123; entry.join(); &#125;&#125; 选择运行数量借用C++标准库的std::thread::hardware_concurrency()函数，它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量.我们可以模拟实现一个并行计算的功能，计算容器内所有元素的和 123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;typename Iterator, typename T&gt;T parallel_accumulate(Iterator first, Iterator last, T init)&#123; unsigned long const length = std::distance(first, last); if (!length) return init; //⇽-- - ① unsigned long const min_per_thread = 25; unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread; //⇽-- - ② unsigned long const hardware_threads = std::thread::hardware_concurrency(); unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); //⇽-- - ③ unsigned long const block_size = length / num_threads; //⇽-- - ④ std::vector&lt;T&gt; results(num_threads); std::vector&lt;std::thread&gt; threads(num_threads - 1); // ⇽-- - ⑤ Iterator block_start = first; for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123; Iterator block_end = block_start; std::advance(block_end, block_size); //⇽-- - ⑥ threads[i] = std::thread(//⇽-- - ⑦ accumulate_block&lt;Iterator, T&gt;(), block_start, block_end, std::ref(results[i])); block_start = block_end; //⇽-- - ⑧ &#125; accumulate_block&lt;Iterator, T&gt;()( block_start, last, results[num_threads - 1]); //⇽-- - ⑨ for (auto&amp; entry : threads) entry.join(); //⇽-- - ⑩ return std::accumulate(results.begin(), results.end(), init); //⇽-- - ⑪&#125;void use_parallel_acc() &#123; std::vector &lt;int&gt; vec(10000); for (int i = 0; i &lt; 10000; i++) &#123; vec.push_back(i); &#125; int sum = 0; sum = parallel_accumulate&lt;std::vector&lt;int&gt;::iterator, int&gt;(vec.begin(), vec.end(), sum); std::cout &lt;&lt; &quot;sum is &quot; &lt;&lt; sum &lt;&lt; std::endl;&#125; 上面的代码1处判断要计算的容器内元素为0个则返回。 2处计算最大开辟的线程数，我们预估每个线程计算25个数据长度。 但是我们可以通过std::thread::hardware_concurrency返回cpu的核数，我们期待的是开辟的线 程数小于等于cpu核数，这样才不会造成线程过多时间片切换开销。 所以3处计算了适合开辟线程数的最小值。 4处计算了步长，根据步长移动迭代器然后开辟线程计算。 5处初始化了线程数-1个大小的vector，因为主线程也参与计算，所以这里-1. 6处移动步长，7处开辟线程，8处更新起始位置。 9处为主线程计算。 10 处让所有线程join 11 处最后将所有计算结果再次调用std的accumulate算出结果。 识别线程所谓识别线程就是获取线程id，可以根据线程id是否相同判断是否同一个线程。比如我们启动了一个线程,我们可以通过线程变量的get_id()获取线程id 12345std::thread t([]()&#123; std::cout &lt;&lt; &quot;thread start&quot; &lt;&lt; std::endl;&#125;);t.get_id(); 但是如果我们想在线程的运行函数中区分线程，或者判断哪些是主线程或者子线程，可以通过这总方式 12345std::thread t([]()&#123; std::cout &lt;&lt; &quot;in thread id &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;thread start&quot; &lt;&lt; std::endl;&#125;); 总结本文介绍了线程管控相关的知识，包括线程的join,detach，以及识别线程，归属权转移，如何管理等等。 本文介绍了std::thread的基本操作，具体视频可以去B站看看我的C++视频讲解 https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101&amp;ctype=0 代码链接 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 并发(1) 线程基础","date":"2023-07-31T08:13:10.000Z","path":"2023/07/31/concpp/","text":"简介本文主要介绍线程的基本管控，包括线程的发起，等待，异常条件下如何等待以及后台运行等基础操作。 线程发起线程发起顾名思义就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程 123456void thead_work1(std::string str) &#123; std::cout &lt;&lt; &quot;str is &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;//1 通过()初始化并启动一个线程std::thread t1(thead_work1, hellostr); 线程等待当我们启动一个线程后，线程可能没有立即执行，如果在局部作用域启动了一个线程，或者main函数中，很可能子线程没运行就被回收了，回收时会调用线程的析构函数，执行terminate操作。所以为了防止主线程退出或者局部作用域结束导致子线程被析构的情况，我们可以通过join，让主线程等待子线程启动运行，子线程运行结束后主线程再运行。 12345std::string hellostr = &quot;hello world!&quot;;//1 通过()初始化并启动一个线程std::thread t1(thead_work1, hellostr);//2 主线程等待子线程退出t1.join(); 仿函数作为参数当我们用仿函数作为参数传递给线程时，也可以达到启动线程执行某种操作的含义 123456class background_task &#123;public: void operator()(std::string str) &#123; std::cout &lt;&lt; &quot;str is &quot; &lt;&lt; str &lt;&lt; std::endl; &#125;&#125;; 如果采用如下方式启动函数，那一定会报错的。 12std::thread t2(background_task());t2.join(); 因为编译器会将t2当成一个函数对象, 返回一个std::thread类型的值, 函数的参数为一个函数指针,该函数指针返回值为background_task, 参数为void。可以理解为如下 1&quot;std::thread (*)(background_task (*)())&quot; 修改的方式很简单 1234567//可多加一层()std::thread t2((background_task()));t2.join(); //可使用&#123;&#125;方式初始化std::thread t3&#123; background_task() &#125;;t3.join(); lambda表达式lambda 表达式也可以作为线程的参数传递给thread 123456std::thread t4([](std::string str) &#123; std::cout &lt;&lt; &quot;str is &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;, hellostr);t4.join(); 线程detach线程允许采用分离的方式在后台独自运行，C++ concurrent programing书中称其为守护线程。 1234567891011121314151617181920212223242526struct func &#123; int&amp; _i; func(int &amp; i): _i(i)&#123;&#125; void operator()() &#123; for (int i = 0; i &lt; 3; i++) &#123; _i = i; std::cout &lt;&lt; &quot;_i is &quot; &lt;&lt; _i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;&#125;;void oops() &#123; int some_local_state = 0; func myfunc(some_local_state); std::thread functhread(myfunc); //隐患，访问局部变量，局部变量可能会随着&#125;结束而回收或随着主线程退出而回收 functhread.detach(); &#125;// detach 注意事项oops();//防止主线程退出过快，需要停顿一下，让子线程跑起来detachstd::this_thread::sleep_for(std::chrono::seconds(1)); 上面的例子存在隐患，因为some_local_state是局部变量, 当oops调用结束后局部变量some_local_state就可能被释放了，而线程还在detach后台运行，容易出现崩溃。所以当我们在线程中使用局部变量的时候可以采取几个措施解决局部变量的问题 通过智能指针传递参数，因为引用计数会随着赋值增加，可保证局部变量在使用期间不被释放，这也就是我们之前提到的伪闭包策略。 将局部变量的值作为参数传递，这么做需要局部变量有拷贝复制的功能，而且拷贝耗费空间和效率。 将线程运行的方式修改为join，这样能保证局部变量被释放前线程已经运行结束。但是这么做可能会影响运行逻辑。比如下面的修改123456789void use_join() &#123; int some_local_state = 0; func myfunc(some_local_state); std::thread functhread(myfunc); functhread.join();&#125;// join 用法use_join(); 异常处理 当我们启动一个线程后，如果主线程产生崩溃，会导致子线程也会异常退出，就是调用terminate，如果子线程在进行一些重要的操作比如将充值信息入库等，丢失这些信息是很危险的。所以常用的做法是捕获异常，并且在异常情况下保证子线程稳定运行结束后，主线程抛出异常结束运行。如下面的逻辑 1234567891011121314void catch_exception() &#123; int some_local_state = 0; func myfunc(some_local_state); std::thread functhread&#123; myfunc &#125;; try &#123; //本线程做一些事情,可能引发崩溃 std::this_thread::sleep_for(std::chrono::seconds(1)); &#125;catch (std::exception&amp; e) &#123; functhread.join(); throw; &#125; functhread.join();&#125; 但是用这种方式编码，会显得臃肿，可以采用RAII技术，保证线程对象析构的时候等待线程运行结束，回收资源。如果大家还记得我基于asio实现异步服务时，逻辑处理类LogicSystem的析构函数里等待线程退出。那我们写一个简单的线程守卫 123456789101112131415class thread_guard &#123;private: std::thread&amp; _t;public: explicit thread_guard(std::thread&amp; t):_t(t)&#123;&#125; ~thread_guard() &#123; //join只能调用一次 if (_t.joinable()) &#123; _t.join(); &#125; &#125; thread_guard(thread_guard const&amp;) = delete; thread_guard&amp; operator=(thread_guard const&amp;) = delete;&#125;; 可以这么使用 12345678910void auto_guard() &#123; int some_local_state = 0; func my_func(some_local_state); std::thread t(my_func); thread_guard g(t); //本线程做一些事情 std::cout &lt;&lt; &quot;auto guard finished &quot; &lt;&lt; std::endl;&#125;auto_guard(); 慎用隐式转换C++中会有一些隐式转换，比如char* 转换为string等。这些隐式转换在线程的调用上可能会造成崩溃问题 12345678910void danger_oops(int som_param) &#123; char buffer[1024]; sprintf(buffer, &quot;%i&quot;, som_param); //在线程内部将char const* 转化为std::string //指针常量 char const* 指针本身不能变 //常量指针 const char * 指向的内容不能变 std::thread t(print_str, 3, buffer); t.detach(); std::cout &lt;&lt; &quot;danger oops finished &quot; &lt;&lt; std::endl;&#125; 当我们定义一个线程变量thread t时，传递给这个线程的参数buffer会被保存到thread的成员变量中。而在线程对象t内部启动并运行线程时，参数才会被传递给调用函数print_str。而此时buffer可能随着&#125;运行结束而释放了。改进的方式很简单，我们将参数传递给thread时显示转换为string就可以了，这样thread内部保存的是string类型。 123456void safe_oops(int some_param) &#123; char buffer[1024]; sprintf(buffer, &quot;%i&quot;, some_param); std::thread t(print_str, 3, std::string(buffer)); t.detach();&#125; 关于为什么参数会像我说的这样保存和调用，我在之后会按照源码给大家讲一讲。 引用参数当线程要调用的回调函数参数为引用类型时，需要将参数显示转化为引用对象传递给线程的构造函数，如果采用如下调用会编译失败 123456789101112void change_param(int&amp; param) &#123; param++;&#125;void ref_oops(int some_param) &#123; std::cout &lt;&lt; &quot;before change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl; //需使用引用显示转换 std::thread t2(change_param, some_param); t2.join(); std::cout &lt;&lt; &quot;after change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl;&#125; 即使函数change_param的参数为int&amp;类型，我们传递给t2的构造函数为some_param,也不会达到在change_param函数内部修改关联到外部some_param的效果。因为some_param在传递给thread的构造函数后会转变为右值保存，右值传递给一个左值引用会出问题，所以编译出了问题。改为如下调用就可以了 1234567void ref_oops(int some_param) &#123; std::cout &lt;&lt; &quot;before change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl; //需使用引用显示转换 std::thread t2(change_param, std::ref(some_param)); t2.join(); std::cout &lt;&lt; &quot;after change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl;&#125; thread原理为了详细说明thread参数传递和调用原理，我们看看源码 1234template &lt;class _Fn, class... _Args, enable_if_t&lt;!is_same_v&lt;_Remove_cvref_t&lt;_Fn&gt;, thread&gt;, int&gt; = 0&gt;_NODISCARD_CTOR explicit thread(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123; _Start(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);&#125; thread构造函数内部通过forward原样转换传递给_Start函数。关于原样转换的知识可以看我之前写的文章。_Start 函数内部就是启动了一个线程_beginthreadex执行回调函数。 123456789101112131415161718192021template &lt;class _Fn, class... _Args&gt; void _Start(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123; using _Tuple = tuple&lt;decay_t&lt;_Fn&gt;, decay_t&lt;_Args&gt;...&gt;; auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...); constexpr auto _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;1 + sizeof...(_Args)&gt;&#123;&#125;);#pragma warning(push)#pragma warning(disable : 5039) // pointer or reference to potentially throwing function passed to // extern C function under -EHc. Undefined behavior may occur // if this function throws an exception. (/Wall) _Thr._Hnd = reinterpret_cast&lt;void*&gt;(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &amp;_Thr._Id));#pragma warning(pop) if (_Thr._Hnd) &#123; // ownership transferred to the thread (void) _Decay_copied.release(); &#125; else &#123; // failed to start thread _Thr._Id = 0; _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN); &#125; &#125; 我们对应ref_oops内部函数的调用，_Start的参数就是void _Start(change_param&amp;&amp; _Fx, int&amp;&amp; Ax) _beginthreadex函数参数分别是安全参数，栈大小，调用函数地址，调用函数参数，初始标记，第三方参数地址。我们关注_beginthreadex的调用函数和参数，调用函数为_Invoker_proc,参数为_Decay_copied我们看看这两个变量的定义 12auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;constexpr auto _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;1 + sizeof...(_Args)&gt;&#123;&#125;); _Decay_copied 可以理解为 1auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;change_param&gt;(_Fx), _STD forward&lt;int&gt; _Invoker_proc 可以理解为封装的可调用对象 1constexpr auto _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;1 + sizeof...(int)&gt;&#123;&#125;); 我们做一个简化 1constexpr auto _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;2&gt;&#123;&#125;); 其实就是将参数的索引0,1按照序列传递给_Get_invoke_Get_invoke原型为 123_NODISCARD static constexpr auto _Get_invoke(index_sequence&lt;_Indices...&gt;) noexcept &#123; return &amp;_Invoke&lt;_Tuple, _Indices...&gt;;&#125; 所以_Get_invoke函数原型为 123456789template &lt;class _Tuple, size_t... _Indices&gt;static unsigned int __stdcall _Invoke(void* _RawVals) noexcept /* terminates */ &#123;// adapt invoke of user&#x27;s callable object to _beginthreadex&#x27;s thread procedureconst unique_ptr&lt;_Tuple&gt; _FnVals(static_cast&lt;_Tuple*&gt;(_RawVals));_Tuple&amp; _Tup = *_FnVals;_STD invoke(_STD move(_STD get&lt;_Indices&gt;(_Tup))...);_Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABIreturn 0;&#125; 所以我们可以理解为调用_Get_invoke就是调用invoke(_STD move(_STD get&lt;_Indices&gt;(_Tup))...);invoke(_STD move(_STD get&lt;_Indices&gt;(_Tup))...);就是将回调函数和参数传递给invoke 123CONSTEXPR17 auto invoke(_Callable&amp;&amp; _Obj, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept( noexcept(_Invoker1&lt;_Callable, _Ty1&gt;::_Call( static_cast&lt;_Callable&amp;&amp;&gt;(_Obj), static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1), static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...))) invoke实际就是调用了_Call函数,_Call的作用就是调用回调函数，并传递给回调函数参数，可以理解为向change_param传递int类型的右值数据 1change_param(int&amp;&amp; _Arg1) 这与change_param的定义不符合，change_param参数为左值引用， 不能绑定右值，也就是编译错误的原因。 所以在这里大家就理解了传递给thread 的参数都是按照右值的方式构造为Tuple类型，传递给系统级别函数_beginthreadex调用的。那为什么使用std::ref就可以实现引用效果呢？这里我们看下std::ref的源码 1234template &lt;class _Ty&gt;_NODISCARD _CONSTEXPR20 reference_wrapper&lt;_Ty&gt; ref(_Ty&amp; _Val) noexcept &#123; return reference_wrapper&lt;_Ty&gt;(_Val);&#125; reference_wrapper是一个类类型，说白了就是将参数的地址和类型保存起来。 1234_CONSTEXPR20 reference_wrapper(_Uty&amp;&amp; _Val) noexcept(noexcept(_Refwrap_ctor_fun&lt;_Ty&gt;(_STD declval&lt;_Uty&gt;()))) &#123; _Ty&amp; _Ref = static_cast&lt;_Uty&amp;&amp;&gt;(_Val); _Ptr = _STD addressof(_Ref);&#125; 当我们要使用这个类对象时，自动转化为取内部参数的地址里的数据即可，就达到了和实参关联的效果 1234567 _CONSTEXPR20 operator _Ty&amp;() const noexcept &#123; return *_Ptr;&#125;_NODISCARD _CONSTEXPR20 _Ty&amp; get() const noexcept &#123; return *_Ptr;&#125; 所以我们可以这么理解传递给thread对象构造函数的参数，仍然作为右值被保存，如ref(int)实际是作为reference_wrapper(int)对象保存在threa的类成员里。而调用的时候触发了仿函数()进而获取到外部实参的地址内的数据。 绑定类成员函数有时候我们需要绑定一个类的成员函数 12345678910111213class X&#123;public: void do_lengthy_work() &#123; std::cout &lt;&lt; &quot;do_lengthy_work &quot; &lt;&lt; std::endl; &#125;&#125;;void bind_class_oops() &#123; X my_x; std::thread t(&amp;X::do_lengthy_work, &amp;my_x); t.join();&#125; 这里大家注意一下，如果thread绑定的回调函数是普通函数，可以在函数前加&amp;或者不加&amp;，因为编译器默认将普通函数名作为函数地址，如下两种写法都正确 12345678void thead_work1(std::string str) &#123; std::cout &lt;&lt; &quot;str is &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;std::string hellostr = &quot;hello world!&quot;;//两种方式都正确std::thread t1(thead_work1, hellostr);std::thread t2(&amp;thead_work1, hellostr); 但是如果是绑定类的成员函数，必须添加&amp; 使用move操作有时候传递给线程的参数是独占的，所谓独占就是不支持拷贝赋值和构造，但是我们可以通过std::move的方式将参数的所有权转移给线程，如下 1234567891011121314void deal_unique(std::unique_ptr&lt;int&gt; p) &#123; std::cout &lt;&lt; &quot;unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl; (*p)++; std::cout &lt;&lt; &quot;after unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl;&#125;void move_oops() &#123; auto p = std::make_unique&lt;int&gt;(100); std::thread t(deal_unique, std::move(p)); t.join(); //不能再使用p了，p已经被move废弃 // std::cout &lt;&lt; &quot;after unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl;&#125; 总结本文介绍了std::thread的基本操作，具体视频可以去B站看看我的C++视频讲解 https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101&amp;ctype=0 代码链接 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"Linux C++ 安装和使用grpc和jsoncpp库","date":"2023-07-30T11:29:37.000Z","path":"2023/07/30/asio27/","text":"简介本文主要教会大家如何在Linux环境搭建C++ 所需的grpc和jsoncpp库，并教会大家如何编写cmake，并配置使用这些库。 解决vim乱码为了解决Linux环境下打开vim中文乱码的问题用vim打开用户目录下的vim配置文件 1vim ~/.vimrc 配置如下 123set termencoding=utf-8set encoding=utf8set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030 配置和使用jsoncpp如果你是ubuntu系统，可以通过如下命令直接安装 1可以通过指令apt install libjsoncpp-dev 安装 但是如果是其他Linux系统最好是手动安装源码包，我的操作都是在ubuntu为基础镜像生成的docker中进行的，如果大家使用的是宿主机，可以直接安装。推荐源码安装，去github下载 https://github.com/open-source-parsers/jsoncpp/releases 可以选择用wget 命令我在电脑下好后传到云服务器上然后在云服务器上copy到docker里, 如果你是在宿主机进行的，可以略去这一步。 1docker cp /home/ubuntu/download/jsoncpp-1.9.5.tar.gz cppubuntu:/test 进入容器 1docker exec -it cppubuntu /bin/bash 接下来解压压缩包，无论docker还是宿主机内，都需执行如下命令 1tar zxvf ./jsoncpp-1.9.5.tar.gz 进入到源码目录 1cd ./json 创建目录 1mkdir build 进入目录 1cd build 执行cmake生成makefile 1cmake ../ 执行make 1make 执行安装 1make install 更新库 1ldconfig 写一个jsoncpp的测试cpp 12345678910111213141516#include&lt;json/json.h&gt;#include&lt;iostream&gt;using namespace std; int main(int argc, char** argv) &#123;Json::Value root;Json::FastWriter fast;root[&quot;ModuleType&quot;]= Json::Value(&quot;你好&quot;);root[&quot;ModuleCode&quot;]= Json::Value(&quot;22&quot;);root[&quot;ModuleDesc&quot;]= Json::Value(&quot;33&quot;);root[&quot;DateTime&quot;]= Json::Value(&quot;44&quot;);root[&quot;LogType&quot;]= Json::Value(&quot;55&quot;);cout&lt;&lt;fast.write(root)&lt;&lt;endl;return 0;&#125; 执行 编译 1g++ jsontest.cpp -o jsontest -ljsoncpp 或者写个cmake 1234567891011121314151617181920cmake_minimum_required(VERSION 3.12)project(jsontest)# 设置 C++ 标准set(CMAKE_CXX_STANDARD 17)# 添加可执行文件和源文件file(GLOB SOURCES $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)set(JSONCPP_INC_DIR /usr/local/include)add_executable(jsontest $&#123;SOURCES&#125;)# 包含头文件路径（包括其他目录）target_include_directories(jsontest PRIVATE $&#123;JSONCPP_INC_DIR&#125;)# 链接 Boost 库target_link_libraries(jsontest PRIVATE jsoncpp) 运行 ./jsontest输出 1&#123;&quot;DateTime&quot;:&quot;44&quot;,&quot;LogType&quot;:&quot;55&quot;,&quot;ModuleCode&quot;:&quot;22&quot;,&quot;ModuleDesc&quot;:&quot;33&quot;,&quot;ModuleType&quot;:&quot;\\u4f60\\u597d&quot;&#125; grpc配置和使用克隆grpc指定分支 1git clone -b v1.34.0 https://gitee.com/mirrors/grpc-framework.git grpc 进入目录并更新子模块 12cd grpcgit submodule update --init 编译并生成grpc库 1234567cd grpcmkdir buildcd build// 指定安装路径 /usr/local cmake -DCMAKE_INSTALL_PREFIX=/usr/local ..make -j2sudo make install 测试安装成功与否 编译源代码中的helloworld文件夹下的文件，步骤如下： 1234567#进入grpc文件夹下cd examples/cpp/helloworldmkdir buildcd build# 编译cmake ..make -j8 编译完成后，分别执行greeter_server和greeter_client即可测试。 项目应用grpc我们的项目中也用到了grpc， 需要编写一个CMakeLists.txt 配置grpc。大家可以克隆我的boost项目代码 https://gitee.com/secondtonone1/boostasio-learn 进入day19-Grpc-Server目录，我们编写如下的CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839cmake_minimum_required(VERSION 3.1)project(GrpcServer LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)#假设已经安装好grpc了find_package(Threads REQUIRED)set(protobuf_MODULE_COMPATIBLE TRUE)find_package(Protobuf CONFIG REQUIRED)message(STATUS &quot;Using protobuf $&#123;Protobuf_VERSION&#125;&quot;)set(_PROTOBUF_LIBPROTOBUF protobuf::libprotobuf)set(_REFLECTION gRPC::grpc++_reflection)# Find gRPC installation# Looks for gRPCConfig.cmake file installed by gRPC&#x27;s cmake installation.find_package(gRPC CONFIG REQUIRED)message(STATUS &quot;Using gRPC $&#123;gRPC_VERSION&#125;&quot;)set(_GRPC_GRPCPP gRPC::grpc++)# 添加可执行文件和源文件file(GLOB SOURCES $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)file(GLOB PBSOURCES $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cc)add_executable(GrpcServer $&#123;SOURCES&#125; $&#123;PBSOURCES&#125;) target_link_libraries(GrpcServer $&#123;_REFLECTION&#125; $&#123;_GRPC_GRPCPP&#125; $&#123;_PROTOBUF_LIBPROTOBUF&#125;) 我们新建一个build文件夹 1mkdir build 进入build文件夹里，执行cmake .., 再执行make即可。直接执行GrpcServer就可以看到我们的程序跑起来了。 总结本文介绍了如何使用Linux环境下配置和使用grpc和cppjson库，我将docker打包为镜像提交到了网盘上，大家感兴趣可以下载看看 链接提取码：5wng","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"可变参数模板+异步队列实现异步打印功能","date":"2023-07-23T07:51:35.000Z","path":"2023/07/23/cpp43/","text":"场景公司有成熟的日志库，但是打印日志的功能是在调用线程里触发的，简而言之就是哪个线程调用了日志库的打印功能，就在哪个线程里输出，如果打印功能频繁，可能会影响该线程的逻辑处理。目前公司的软件界面显示和计算等逻辑很频繁，考虑用异步的方式实现打印。 思路1 需要把要写的参数封装成一个数据结构然后投递到异步队列里。2 因为参数类型多变，需要用模板实现写日志的函数。参数个数也不确定，就需要用可变参数模板。3 需要另一个线程从队列中取数据并打印日志，也可调用第三饭日志库打印。为减少线程调度开销，在队列为空时，需要将队列挂起。 具体实现日志等级定义为几个级别 123456 enum LogLv &#123; DEBUGS = 0, INFO = 1, WARN = 2, ERRORS = 3,&#125;; 定义要投递给队列的任务结构 123456789 class LogTask &#123;public: LogTask()&#123;&#125; LogTask(const LogTask&amp; src):_level(src._level), _logdatas(src._logdatas)&#123;&#125; LogTask(const LogTask&amp;&amp; src):_level(src._level), _logdatas(std::move(src._logdatas))&#123;&#125; LogLv _level; QQueue&lt;QVariant&gt; _logdatas;&#125;; 定义异步处理的日志类，先给出全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 class AsyncLog : public QThread &#123;public: static AsyncLog&amp; Instance()&#123; static AsyncLog instance; return instance; &#125; //如果不支持C++17,可采用如下函数入队 template&lt;typename Arg, typename ...Args&gt; void TaskEnque(std::shared_ptr&lt;LogTask&gt; task, Arg&amp;&amp; arg, Args&amp;&amp;... args)&#123; task-&gt;_logdatas.enqueue(QVariant(std::forward&lt;Arg&gt;(arg))); qDebug() &lt;&lt; &quot;enque task data is &quot; &lt;&lt; arg &lt;&lt; endl; TaskEnque(task,std::forward&lt;Args&gt;(args)...); &#125; template&lt;typename Arg&gt; void TaskEnque(std::shared_ptr&lt;LogTask&gt; task, Arg&amp;&amp; arg)&#123; task-&gt;_logdatas.enqueue(QVariant(std::forward&lt;Arg&gt;(arg))); qDebug() &lt;&lt; &quot;enque task data is &quot; &lt;&lt; arg &lt;&lt; endl; &#125; //可变参数列表，异步写 template&lt;typename... Args&gt; void AsyncWrite(LogLv level, Args&amp;&amp;... args) &#123; auto task = std::make_shared&lt;LogTask&gt;(); //折叠表达式依次将可变参数写入队列,需C++17版本支持 (task-&gt;_logdatas.enqueue(QVariant(std::forward&lt;Args&gt;(args))), ...); //如不支持C++17 请用这个版本入队 //TaskEnque(task, args...); task-&gt;_level = level; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _queue.enqueue(task); bool notify = (_queue.size() == 1)?true:false; lock.unlock(); // 通知等待的线程有新的任务可处理 if(notify)&#123; _empty_cond.notify_one(); &#125; &#125; void Stop()&#123; _b_stop = true; _empty_cond.notify_one(); &#125;private: AsyncLog(const AsyncLog&amp;) = delete; AsyncLog&amp; operator = (const AsyncLog&amp;) = delete; AsyncLog(QObject* parent = nullptr):QThread(parent),_b_stop(false)&#123; &#125; void run()&#123; for(;;)&#123; std::unique_lock&lt;std::mutex&gt; lock(_mtx); while(_queue.empty() &amp;&amp; !_b_stop)&#123; _empty_cond.wait(lock); &#125; if(_b_stop)&#123; return; &#125; auto logtask = _queue.dequeue(); lock.unlock(); processTask(logtask); &#125; &#125; void processTask(std::shared_ptr&lt;LogTask&gt; task)&#123; qDebug() &lt;&lt; &quot;log level is &quot; &lt;&lt; task-&gt;_level &lt;&lt; endl; if(task-&gt;_logdatas.empty())&#123; return; &#125; // 队列首元素 auto head = task-&gt;_logdatas.dequeue(); auto formatstr = head.toString().toStdString(); for(;!(task-&gt;_logdatas.empty());)&#123; auto data = task-&gt;_logdatas.dequeue(); qDebug() &lt;&lt; &quot;deque task data is &quot; &lt;&lt; data; formatstr=formatString(formatstr, data); &#125; qDebug() &lt;&lt; &quot;formatstr is &quot; &lt;&lt; QString::fromStdString(formatstr) &lt;&lt; endl; &#125; template&lt;typename... Args&gt; std::string formatString(const std::string&amp; format, Args&amp;&amp;... args) &#123; std::string result = format; size_t pos = 0; //lambda表达式查找并替换字符串 auto replacePlaceholder = [&amp;](const std::string&amp; placeholder, const std::string&amp; replacement) &#123; size_t placeholderPos = result.find(placeholder, pos); if (placeholderPos != std::string::npos) &#123; result.replace(placeholderPos, placeholder.length(), replacement); pos = placeholderPos + replacement.length(); &#125;else&#123; result = result + &quot; &quot; + replacement; &#125; &#125;; (replacePlaceholder(&quot;&#123;&#125;&quot;, QVariant(std::forward&lt;Args&gt;(args)).toString().toStdString()), ...); qDebug() &lt;&lt; &quot;result is : &quot; &lt;&lt; QString::fromStdString(result) &lt;&lt; endl; return result; &#125; std::condition_variable _empty_cond; QQueue&lt;std::shared_ptr&lt;LogTask&gt; &gt; _queue; bool _b_stop; std::mutex _mtx;&#125;; 下面分别解释每段含义我们先定义了一个单例类 1234static AsyncLog&amp; Instance()&#123; static AsyncLog instance; return instance; &#125; 通过可变参数列表，实现异步写功能 123456789101112131415161718 //可变参数列表，异步写 template&lt;typename... Args&gt; void AsyncWrite(LogLv level, Args&amp;&amp;... args) &#123; auto task = std::make_shared&lt;LogTask&gt;(); //折叠表达式依次将可变参数写入队列,需C++17版本支持 (task-&gt;_logdatas.enqueue(QVariant(std::forward&lt;Args&gt;(args))), ...); //如不支持C++17 请用这个版本入队 //TaskEnque(task, args...); task-&gt;_level = level; std::unique_lock&lt;std::mutex&gt; lock(_mtx); _queue.enqueue(task); bool notify = (_queue.size() == 1)?true:false; lock.unlock(); // 通知等待的线程有新的任务可处理 if(notify)&#123; _empty_cond.notify_one(); &#125;&#125; AsyncWrite用到了可变参数模板，类型为模板类型的右值引用，这被称作万能引用，使用该引用有几个好处1 支持右值传递2 支持完美转发函数内用到了折叠表达式，折叠表达式基本语法如下 1(表达式, ...) 折叠表达式会循环执行表达式，直到参数列表用完。AsyncWrite主要实现了将可变参数封装为task然后投递到队列里，如果队列由空到满则需激活消费者线程取消费队列。如果你的编译器不支持C++17， 可以改为实现两个模板函数TaskEnque入队。 接下来的run函数重载了QThread的run函数，意在启动一个线程处理任务。 processTask 是处理打印日志的功能。formatString 为多参数模板函数，意在模拟将多个参数匹配和拼接的功能，当然这个函数可替代为你使用的第三方库。 测试和使用我们在主函数内初始化日志类，然后启动一个界面阻塞主线程，点击关闭界面后，会销毁日志类开辟的线程。 123456789101112131415161718192021int main(int argc, char *argv[])&#123; QApplication a(argc, argv); auto &amp; instance = AsyncLog::AsyncLog::Instance(); instance.AsyncWrite(AsyncLog::LogLv::ERRORS, &quot;hello&quot;, &quot;world !&quot;, &quot;my name is &#123;&#125; &quot;, &quot;zack &#123;&#125;&quot;, &quot;fair&quot;); instance.start(); MainWindow main; main.show(); a.exec(); qDebug() &lt;&lt; &quot;Application Quitting, Please Wait...&quot;; AsyncLog::AsyncLog::Instance().Stop(); // 暂停执行500毫秒（0.5秒） std::this_thread::sleep_for(std::chrono::milliseconds(500)); qDebug() &lt;&lt; &quot;Application exited...&quot;; return 0;&#125; 函数运行后输出如下 1234formatstr is &quot;hello world ! my name is zack fair &quot; Application Quitting, Please Wait...Application exited... 总结本文介绍了如何用模板和可变参数构造一个异步打印功能的类，是基于QT实现的，之后又实现了C++标准版本的。源码链接如下 QT版本 C++版本","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用Docker搭建Linux C++ Boost开发环境","date":"2023-07-21T02:15:46.000Z","path":"2023/07/21/asio26/","text":"简介本文介绍如何使用Docker搭建Linux环境下C++的开发环境。众所周知C++的开发环境分为Windows和Linux两种，在windows配置C++开发环境并实现了Asio服务器的开发，我们也做过QT的配置和使用，前面的教程已经很完善了，接下来介绍如何在Linux系统部署C++开发环境。 宿主机和Docker对于Linux系统，选择性很多包括Centos, Redhat, Ubuntu等，大家可以选择在宿主机上直接安装Linux某个版本的系统，也可选择Docker环境部署C++开发环境。选择Docker的好处如下：1 可移植性好，不会因为宿主机的差异导致程序移植后无法运行2 Docker安装的库不会影响宿主机环境，也不会被宿主机环境影响，程序运行环境纯净。3 共享性好，可以将配置好的容器打包成镜像提交到Docker Hub或者压缩成压缩包供他人使用，提升开发效率。为了方便给大家演示并提供给大家一个可移植的环境，我选择用Docker配置C++开发环境。 Docker安装根据不同的Linux系统可以选择不同的方式安装，我的是Ubuntu系统，所以简单列举下我的安装步骤1 更新系统软件包列表：执行以下命令以确保您的软件包列表是最新的： 1sudo apt update 2 安装依赖项以允许使用 HTTPS 通过 APT 获取 Docker：执行以下命令安装所需的软件包： 1sudo apt install -y apt-transport-https ca-certificates curl software-properties-common 3 添加 Docker GPG 密钥：执行以下命令以添加 Docker 的官方 GPG 密钥： 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 4 添加 Docker APT 软件仓库：执行以下命令以将 Docker APT 软件仓库添加到系统中： 1echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 5 更新软件包列表并安装 Docker：执行以下命令以更新软件包列表，并安装 Docker CE： 12sudo apt updatesudo apt install -y docker-ce docker-ce-cli containerd.io 6 验证 Docker 安装是否成功：执行以下命令以验证 Docker 是否已成功安装： 1sudo docker run hello-world 如果一切正常，您将看到一个欢迎消息，表示 Docker 已成功安装并正在运行 搭建C++环境我们基于ubuntu系统的镜像搭建容器，当然你也可以选择其他的系统如centos等，如果小伙伴不喜欢用Docker，可以直接在宿主机操作。 1 启动ubuntu:18.04容器 1docker run -itd --name cppubuntu ubuntu:18.04 2 容器内更新源，这样能安装最新的软件包 1apt-get update 3 容器内安装gcc/g++工具包 1sudo apt install build-essential 4 容器内测试g++版本和命令 1234echo &#x27;#include &lt;iostream&gt;&#x27; &gt; test.cppecho &#x27;int main() &#123; std::cout &lt;&lt; __cplusplus &lt;&lt; std::endl; return 0; &#125;&#x27; &gt;&gt; test.cppg++ -std=c++17 test.cpp -o test./test 输出201703L即证明支持C++17 5 容器内安装wget 1apt install wget 6 容器内安装boost 6.1 获取源码包 1wget https://boostorg.jfrog.io/artifactory/main/release/1.82.0/source/boost_1_82_0.tar.gz 获取速度较慢，我用windows下载好后用filezilla传递到云服务上，再从云服务上执行拷贝操作放入docker 1docker cp /home/ubuntu/boost_1_82_0.tar.gz cppubuntu:/test 6.2 下载boost需要的库 1apt-get install python-dev autotools-dev libicu-dev build-essential libbz2-dev libboost-all-dev 6.3 解压缩并安装 1234tar zxvf boost_1_82_0.tar.gzcd ./boost_1_82_0./bootstrap.sh --prefix=/usr/./b2 install 6.4 编码测试 1vim ./boosthello.cpp 写如下代码 1234567#include &lt;iostream&gt;#include &lt;boost/version.hpp&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Boost 版本&quot; &lt;&lt; BOOST_VERSION &lt;&lt; endl; return 0;&#125; 编译运行 1g++ -o boosthello ./boosthello.cpp 执行./boosthello 输出 1Boost 版本108200 7 容器内安装git 1apt install git 8 拉取项目代码 1git clone https://gitee.com/secondtonone1/boostasio-learn.git 9 配置git 12git config --global user.name &quot;secondtonone1&quot;git config --global user.email &quot;secondtonone1@163.com&quot; 可以验证一下 12git config --global user.namegit config --global user.email 10 下载cmake 1wget https://github.com/Kitware/CMake/releases/download/v3.27.0/cmake-3.27.0.tar.gz 安装必要的ssl库 1apt install libssl-dev 解压缩 1tar -zxvf cmake-3.27.0.tar.gz 设置引导程序 1./bootstrap 编译 1make 安装 1make install 测试安装情况 1cmake --version 11 编写CMakeLists.txt, 在AsyncServer外层目录 123456789101112131415161718192021222324252627282930cmake_minimum_required(VERSION 3.12)project(AsyncServer)# 设置 C++ 标准set(CMAKE_CXX_STANDARD 17)# 设置 Boost 的路径set(BOOST_ROOT /usr)# 查找 Boost 库的组件find_package(Boost REQUIRED COMPONENTS system thread)# 添加可执行文件和源文件file(GLOB SOURCES $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/day06-AsyncServer/*.cpp)add_executable(AsyncServer $&#123;SOURCES&#125;)# 包含头文件路径（包括其他目录）target_include_directories(AsyncServer PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/day06-AsyncServer $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/other_directory # 添加其他目录路径...)# 包含 Boost 头文件路径target_include_directories(AsyncServer PRIVATE $&#123;Boost_INCLUDE_DIRS&#125;)# 链接 Boost 库target_link_libraries(AsyncServer PRIVATE $&#123;Boost_LIBRARIES&#125;) 新建目录build, 进入build目录，执行cmake ..生成makefile文件。 在该文件夹执行make 生成可执行文件AsyncServer， 测试可运行。 12 打包容器生成镜像 1docker commit cppubuntu cppubuntu:1.0 将镜像压缩成tar 1docker save -o cppubuntu.tar cppubuntu:1.0 传输到百度网盘，大家可以直接使用我的开发环境了。 链接: https://pan.baidu.com/s/1xHP5pSRjFZFiV5qRpgw0KQ?pwd=y468 提取码: y468 总结本文总结了如何使用Docker搭建Linux C++开发环境，读者也可以根据文档提供的步骤在宿主机直接搭建。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"网络答疑汇总","date":"2023-07-15T12:20:05.000Z","path":"2023/07/15/asio25/","text":"简介总结下目前视频教程中读者提出的问题，并逐一回答。视频地址在哔哩哔哩https://space.bilibili.com/271469206 boost编译方法补充很多同学提出windows环境下boost编译失败问题，这里在介绍一下，原文为https://llfc.club/articlepage?id=2LUMUrk6n3nNEMHUOyWFwiPZZyo 当我们把boost库下载后解压，进入文件夹执行bootstrap.bat,就会生成b2.exe可执行文件。 之前我告诉大家执行的编译命令是 1.\\b2.exe toolset=gcc 这样生成的库是linux的.a库。我们要用到生成windows使用的库 1.\\b2.exe install --toolset=msvc-14.2 --build-type=complete --prefix=&quot;D:\\cppsoft\\boost_1_81_0&quot; link=static runtime-link=shared threading=multi debug release 先逐一解释各参数含义 install可以更改为stage, stage表示只生成库(dll和lib), install还会生成包含头文件的include目录。一般来说用stage就可以了，我们将生成的lib和下载的源码包的include头文件夹放到项目要用的地方即可。 toolset 指定编译器，gcc用来编译生成linux用的库，msvc-14.2（VS2019）用来编译windows使用的库，版本号看你的编译器比如msvc-10.0（VS2010），我的是VS2019所以是msvc-14.2。 如果选择的是install 命令，指定生成的库文件夹要用--prefix，如果使用的是stage命令，需要用--stagedir指定。 link 表示生成动态库还是静态库，static表示生成lib库，shared表示生成dll库。 runtime-link 表示用于指定运行时链接方式为静态库还是动态库，指定为static就是MT模式，指定shared就是MD模式。MD 和 MT 是微软 Visual C++ 编译器的选项，用于指定运行时库的链接方式。这两个选项有以下区别： /MD：表示使用多线程 DLL（Dynamic Link Library）版本的运行时库。这意味着你的应用程序将使用动态链接的运行时库（MSVCRT.dll）。这样的设置可以减小最终可执行文件的大小，并且允许应用程序与其他使用相同运行时库版本的程序共享代码和数据。 /MT：表示使用多线程静态库（Static Library）版本的运行时库。这意味着所有的运行时函数将被静态链接到应用程序中，使得应用程序不再依赖于动态链接的运行时库。这样可以确保应用程序在没有额外依赖的情况下独立运行，但可能会导致最终可执行文件的体积增大。 执行上述命令后就会在指定目录生成lib库了，我们将lib库拷贝到要使用的地方即可。 运行时库类型的错误windows平台有时我们使用多个第三方库时，每个库编译选择的运行库版本不同的，有的是static，有的是shared，也就是MT和MD。这两种类型不能混用，比如我们使用grpc通信时，也会使用jsoncpp库序列化，那如果这两个库版本不同就会报如下链接错误 解决这个问题也比较简单，将运行时库类型统一修改为MD或MT 我们目前的项目采用的运行库类型都改为了MD,大家可以看源码https://gitee.com/secondtonone1/boostasio-learn 注意条件变量激活信号发送的时机我们使用条件变量激活其他线程时需要cond_variable.notifyone或者cond_variable.notifyall。但是发送前一定要解锁，如果不解锁其他线程处于wait状态将无法被激活，因为锁可能还被通知线程占用。目前项目中已解决该隐患。那我们用代码模仿消费者和生产者逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116int main()&#123; //控制队列安全mtx std::mutex mtx; //消息队列 std::queue&lt;int&gt; que; //队列最大长度 int que_max = 1024; //消费者条件变量 std::condition_variable consumer_cv; //生产者条件变量 std::condition_variable producer_cv; //退出标记 bool bexit = false; auto consumer = std::thread([&amp;]() &#123; for (;;) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); //队列为空则则挂起等待 while (que.empty() &amp;&amp; !bexit) &#123; consumer_cv.wait(lock); &#125; //收到退出信号 if (bexit) &#123; return; &#125; //自动加锁消费队列 auto num = que.front(); std::cout &lt;&lt; &quot;consumer consume &quot; &lt;&lt; num &lt;&lt; std::endl; que.pop(); //判断是否需要通知 bool bnotify = (que.size() == que_max - 1) ? true:false; lock.unlock(); if (bnotify) &#123; //通知生产者 producer_cv.notify_one(); &#125; // 创建随机数引擎 std::random_device rd; std::mt19937 gen(rd()); // 创建分布器，这里以生成范围在[0, 100]的整数为例 std::uniform_int_distribution&lt;&gt; dis(1, 3); // 生成随机数 int randomValue = dis(gen); // 睡眠一毫秒 std::this_thread::sleep_for(std::chrono::milliseconds(randomValue)); &#125; &#125;); auto producer = std::thread([&amp;]() &#123; for (int index = 0;;index++) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); //队列满并且没有设置退出标记则挂起 while (que.size() == que_max &amp;&amp; !bexit) &#123; producer_cv.wait(lock); &#125; //判断是否为退出标记 if (bexit) &#123; return; &#125; que.push(index); std::cout &lt;&lt; &quot;producer produce &quot; &lt;&lt; index &lt;&lt; std::endl; bool bnotify = (que.size() == 1) ? true : false; lock.unlock(); if (bnotify) &#123; consumer_cv.notify_one(); &#125; // 创建随机数引擎 std::random_device rd; std::mt19937 gen(rd()); // 创建分布器，这里以生成范围在[0, 100]的整数为例 std::uniform_int_distribution&lt;&gt; dis(1, 3); // 生成随机数 int randomValue = dis(gen); // 睡眠一毫秒 std::this_thread::sleep_for(std::chrono::milliseconds(randomValue)); &#125; &#125;); // 全局 io_context 对象 boost::asio::io_context ioContext; // 创建一个信号集对象 boost::asio::signal_set signals(ioContext, SIGINT); // 异步等待信号 signals.async_wait([&amp;](const boost::system::error_code&amp; error, int signalNumber) &#123; std::cout &lt;&lt; &quot;Received signal: &quot; &lt;&lt; signalNumber &lt;&lt; std::endl; bexit = true; consumer_cv.notify_one(); producer_cv.notify_one(); // 停止 io_context ioContext.stop(); &#125;); // 运行 io_context ioContext.run(); //等待线程退出 consumer.join(); producer.join(); std::cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; std::endl;&#125; io_context监听事件要启动我们将iocontext的读写事件注册后，一定要执行iocontext.run，这样事件才会被asio底层派发。项目中StrandServer和ThreadServer都遗漏了信号事件绑定的iocontext的run调用，目前已修复。 io_context::work析构后io_context不一会退出io_context::work主要是用来监听io_context，防止io_context在没有事件绑定的时候退出。io_context::work 析构后，如果io_context没有事件绑定则自动退出。但是当io_context有事件监听，则io_context无法退出。我们的代码中用智能指针管理io_context::work 12 using Work = boost::asio::io_context::work;using WorkPtr = std::unique_ptr&lt;Work&gt;; 当智能指针reset后调用work的析构函数，但是如果iocontext已经绑定了读或写事件，则无法停止。所以当我们执行Pool的stop函数无法正常退出，这个问题已经修复，详见代码仓库。 grpc应用场景grpc主要用于服务内部通信的情况，简言之后台网络中多个服务器通信的方式。如果是客户端和服务器通信最好使用并发性能好一点的网络库，同时也能支持根据自己的需求实现并发逻辑。如果客户端较少，则也可以考虑用grpc的方式通信。 接下来视频走向 搭建Linux环境下C++ 开发环境 C++ 并发编程技术讲解 项目实战，QT聊天客户端和asio服务器全栈设计。 总结本文回答了大家遇到的各种问题 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"beast网络库实现websocket服务器","date":"2023-06-25T07:12:48.000Z","path":"2023/06/25/asio24/","text":"简介使用beast网络库实现websocket服务器，一般来说websocket是一个长连接的协议，但是自动包含了解包处理，当我们在浏览器输入一个http请求时如果是以ws开头的如ws://127.0.0.1:9501就是请求本地9501端口的websocket服务器处理。而beast为我们提供了websocket的处理方案，我们可以在http服务器的基础上升级协议为websocket，处理部分websocket请求。如果服务器收到的是普通的http请求则按照http请求处理。我们可以从官方文档中按照示例逐步搭建websocket服务器。 构造websocket在开始前我们先准备几个变量 123456789101112#include &lt;boost/beast.hpp&gt;#include &lt;boost/beast/ssl.hpp&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/asio/ssl.hpp&gt;namespace net = boost::asio;namespace beast = boost::beast;using namespace boost::beast;using namespace boost::beast::websocket;net::io_context ioc;tcp_stream sock(ioc);net::ssl::context ctx(net::ssl::context::tlsv12); WebSocket连接需要一个有状态对象，由Beast中的一个类模板websocket::stream表示。该接口使用分层流模型。一个websocket stream对象包含另一个流对象，称为“下一层”，它用于执行I/O操作。以下是每个模板参数的描述： 123456789101112namespace boost &#123;namespace beast &#123;namespace websocket &#123;template&lt; class NextLayer, bool deflateSupported = true&gt;class stream;&#125; // websocket&#125; // beast&#125; // boost 这段代码定义了Beast库中WebSocket实现的命名空间。其中，websocket命名空间下包含一个模板类stream，用于表示WebSocket连接。 stream类有两个模板参数：NextLayer和deflateSupported。其中，NextLayer表示WebSocket连接使用的下一层流类型，例如TCP套接字或TLS握手后的数据流；而deflateSupported则是一个bool值，表示是否支持WebSocket协议内置的压缩功能。 这些代码所在的三个命名空间分别是boost、beast和websocket，是为了防止与其他库或用户代码发生名称冲突而创建的。将Beast库放在beast命名空间下是为了与Boost库本身分离，方便管理和维护。当创建一个WebSocket流对象时，构造函数提供的任何参数都会被传递给下一层对象的构造函数。以下示例代码声明了一个基于TCP/IP套接字和I/O上下文的WebSocket流对象： 1stream&lt;tcp_stream&gt; ws(ioc); 上述代码创建了一个基于TCP流的WebSocket流对象，使用了指定的I/O上下文，该代码中的stream是Beast库中WebSocket流类模板的别名，其下一层流类型为tcp_stream。 需要注意的是，WebSocket流使用自己特定的超时功能来管理连接。如果使用tcp_stream或basic_stream类模板与WebSocket流一起使用，那么在连接建立后应该禁用TCP或basic流上的超时设置，否则流的行为将是不确定的。 这是因为WebSocket协议本身包含了超时机制，当流上发生超时时，WebSocket库会优先处理超时并关闭连接，而不会将超时事件传递给下层TCP或basic流。如果同时在WebSocket和TCP或basic流上启用超时设置，就可能出现冲突和未定义的行为。 因此，当使用WebSocket流时，应该避免在底层的TCP或basic流上设置超时，而是可以通过WebSocket流对象的set_option函数来设置WebSocket连接的超时时间。这样可以确保WebSocket连接中的超时机制正常工作，并且不会干扰底层流的超时设置。 与大多数I/O对象一样，WebSocket流对象也不是线程安全的。如果两个不同的线程同时访问该对象，则会产生未定义行为。 对于多线程程序，可以通过在构造tcp_stream对象时使用executor（如strand）来保证线程安全。下面的代码声明了一个使用strand来调用所有完成处理程序的WebSocket流： 1stream&lt;tcp_stream&gt; ws(net::make_strand(ioc)); 如果下一层流支持移动构造，那么WebSocket流对象可以从一个已移动的对象中构造。 这意味着，在创建WebSocket流对象时，可以将下一层流对象的所有权转移到WebSocket流对象中，而不需要进行复制或重新分配。这种方式可以避免额外的内存开销和数据拷贝操作，提高程序运行效率。 例如，可以使用std::move函数将一个已存在的TCP套接字对象移动到WebSocket流中： 1stream&lt;tcp_stream&gt; ws(std::move(sock)); 可以通过调用WebSocket流对象的next_layer函数来访问下一层流对象。 1ws.next_layer().close(); 使用SSL使用”net::ssl::stream”类模板作为流的模板类型，并且将”net::io_context”和”net::ssl::context”参数传递给包装流的构造函数。 1stream&lt;ssl_stream&lt;tcp_stream&gt;&gt; wss(net::make_strand(ioc), ctx); 当然如果websocket stream 使用SSL类型需要包含&lt;boost/beast/websocket/ssl.hpp&gt;next_layer() 函数用于访问底层的 SSL 流。ssl::stream 类中的 next_layer() 函数返回对底层 ssl_stream 的引用，它代表了建立在 SSL/TLS 层之上的网络流。 1wss.next_layer().handshake(net::ssl::stream_base::client); 在上述声明的多层流（如 SSL 流）中，使用 next_layer 进行链式调用访问每个层可能会很麻烦。为了简化这个过程，Boost.Beast 提供了 get_lowest_layer() 函数，用于获取多层流中的最底层流。 通过调用 get_lowest_layer() 函数，您可以直接获取多层流中的最底层流，而无需逐层调用 next_layer()。这对于取消所有未完成的 I/O 操作非常有用，例如在关闭连接之前取消所有挂起的异步操作。 1get_lowest_layer(wss).cancel(); 连接在进行 WebSocket 通信之前，需要首先连接 WebSocket 流，然后执行 WebSocket 握手。WebSocket 流将建立连接的任务委托给下一层流。例如，如果下一层是可连接的流或套接字对象，则可以访问它以调用必要的连接函数。以下是作为客户端执行的示例代码 123stream&lt;tcp_stream&gt; ws(ioc);net::ip::tcp::resolver resolver(ioc);get_lowest_layer(ws).connect(resolver.resolve(&quot;example.com&quot;, &quot;ws&quot;)); 对于服务器接收连接，在WebSocket服务器中使用一个acceptor来接受传入的连接。当建立了一个传入连接时，可以从acceptor返回的socket构造WebSocket流。 1234net::ip::tcp::acceptor acceptor(ioc);acceptor.bind(net::ip::tcp::endpoint(net::ip::tcp::v4(), 0));acceptor.listen();stream&lt;tcp_stream&gt; ws(acceptor.accept()); 也可以通过使用acceptor成员函数的另一个重载，将传入连接直接接受到WebSocket流拥有的socket中 12stream&lt;tcp_stream&gt; ws(net::make_strand(ioc));acceptor.accept(get_lowest_layer(ws).socket()); 握手websocket通过握手将http升级为websocket协议，一个websocket协议如下 1234567GET / HTTP/1.1Host: www.example.comUpgrade: websocketConnection: upgradeSec-WebSocket-Key: 2pGeTR0DsE4dfZs2pH+8MA==Sec-WebSocket-Version: 13User-Agent: Boost.Beast/216 先说客户端如何升级这段代码使用websocket::stream的成员函数handshake和async_handshake，用于使用所需的主机名和目标字符串发送请求。该代码连接到从主机名查找返回的IP地址，然后在客户端角色中执行WebSocket握手 1234567stream&lt;tcp_stream&gt; ws(ioc);net::ip::tcp::resolver resolver(ioc);get_lowest_layer(ws).connect(resolver.resolve(&quot;www.example.com&quot;, &quot;ws&quot;));ws.handshake( &quot;www.example.com&quot;, // The Host field &quot;/&quot; // The request-target); 在客户端收到来自服务器的HTTP Upgrade响应并指示成功升级时，调用者可能希望对接收到的HTTP响应消息进行额外的验证。例如，检查对基本身份验证挑战的响应是否有效。为了实现这一目的，handshake成员函数提供了重载形式，允许调用者将接收到的HTTP消息存储在类型为response_type的输出引用参数中。 123456response_type res;ws.handshake( res, // Receives the HTTP response &quot;www.example.com&quot;, // The Host field &quot;/&quot; // The request-target); 所以上述握手函数根据自己的需求调用一个即可。 再说服务器如何升级 对于接受传入连接的服务器，websocket::stream可以读取传入的升级请求并自动回复。如果握手符合要求，流将发送带有101切换协议状态码的升级响应。如果握手不符合要求，或者超出了调用者之前设置的流选项允许的参数范围，流将发送一个带有表示错误的状态码的HTTP响应。根据保持活动设置，连接可能保持打开状态，以进行后续握手尝试。在接收到升级请求握手后，由实现创建和发送的典型HTTP升级响应如下所示： 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: upgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Server: Boost.Beast stream的accept和async_accept成员函数用于从已连接到传入对等方的流中读取WebSocket HTTP升级请求握手，然后发送WebSocket HTTP升级响应。示例如下 1ws.accept(); 在某些情况下，服务器可能需要从流中读取数据，并在稍后决定将缓冲的字节解释为WebSocket升级请求。为了满足这种需求，accept和async_accept提供了接受额外缓冲区参数的重载版本。 以下是一个示例，展示了服务器如何将初始的HTTP请求头部读取到一个动态缓冲区中，然后稍后使用缓冲的数据尝试进行WebSocket升级： 123std::string s;net::read_until(sock, net::dynamic_buffer(s), &quot;\\r\\n\\r\\n&quot;);ws.accept(net::buffer(s)); 在实现同时支持WebSocket的HTTP服务器时，服务器通常需要从客户端读取HTTP请求。为了检测传入的HTTP请求是否是WebSocket升级请求，可以使用函数is_upgrade。 一旦调用者确定HTTP请求是WebSocket升级请求，就会提供额外的accept和async_accept重载版本，这些版本接收整个HTTP请求头作为一个对象，以进行握手处理。通过手动读取请求，程序可以处理普通的HTTP请求以及升级请求。程序还可以根据HTTP字段强制执行策略，例如基本身份验证。在这个示例中，首先使用HTTP算法读取请求，然后将其传递给新构建的流： 123456789101112131415flat_buffer buffer;http::request&lt;http::string_body&gt; req;http::read(sock, buffer, req);if(websocket::is_upgrade(req))&#123; stream&lt;tcp_stream&gt; ws(std::move(sock)); BOOST_ASSERT(buffer.size() == 0); ws.accept(req);&#125;else&#123;&#125; 所以综上所述，在构建websocket升级时，可以用两种方式，一种是websocket来accept，另一种是在处理http的请求时将请求升级为websocket。而这两种我们在实战的代码中都有实现，可以下载源码查看。 收发数据当我们建立好websocket的握手后，就可以通过读写操作收发数据了。 12345flat_buffer buffer;ws.read(buffer);ws.text(ws.got_text());ws.write(buffer.data());buffer.consume(buffer.size()); 上面的代码片段采用同步读和同步写的方式，根据接收消息的类型设置 WebSocket 连接的模式。回显接收到的消息给对等端。清空缓冲区，以便下一次读取可以开始构建新的消息。 但有些场景我们不能通过buffer一次性的读出数据 这是一些使用场景，这些场景中无法预先缓冲整个消息： 向终端流式传输多媒体：在流式传输多媒体到终端时，通常不适合或不可能预先缓冲整个消息。例如，在实时视频流或音频流的传输过程中，数据可能以非常大的速率产生，并且需要立即传输给接收端进行实时播放。由于数据量巨大且需即时传输，预先缓冲整个消息可能会导致延迟或资源耗尽。 发送超出内存容量的消息：有时候需要发送的消息太大，无法一次性完全存储在内存中。这可能发生在需要传输大型文件或大量数据的情况下。如果尝试将整个消息加载到内存中，可能会导致内存溢出或系统性能下降。在这种情况下，需要通过分块或逐步读取的方式来发送消息，以便逐步加载和传输数据。 提供增量结果：在某些情况下，需要在处理过程中提供增量的结果，而不是等待整个处理完成后再返回结果。这可以在长时间运行的计算、搜索或处理任务中发生。通过逐步提供部分结果，可以让用户或应用程序更早地获得一些数据，并可以在处理过程中进行进一步的操作或显示。这种方式可以改善用户体验，并减少等待时间。 在这些特定的使用场景中，需要采用逐步处理、流式传输或增量输出的方式，而不是依赖于预先缓冲整个消息。这样可以提高性能、降低内存消耗，并满足特定需求。 如下是asio提供的官方案例，通过流式读取的方式获取对端信息 123456789101112131415161718192021222324252627282930multi_buffer buffer;do&#123; ws.read_some(buffer, 512);&#125;while(! ws.is_message_done());ws.binary(ws.got_binary());buffers_suffix&lt;multi_buffer::const_buffers_type&gt; cb&#123;buffer.data()&#125;;for(;;)&#123; if(buffer_bytes(cb) &gt; 512) &#123; ws.write_some(false, buffers_prefix(512, cb)); cb.consume(512); &#125; else &#123; ws.write_some(true, cb); break; &#125;&#125;buffer.consume(buffer.size()); 这段代码涉及 WebSocket 数据的读取和写入操作。以下是对每个部分的解释： 1 multi_buffer buffer;这行代码定义了一个名为 buffer 的 multi_buffer 对象，用于存储读取的 WebSocket 数据。 2 do &#123; ... &#125; while(! ws.is_message_done());这部分代码使用一个循环，连续调用 ws.read_some 方法从 WebSocket 连接中读取数据，并将其存储到 buffer 中，直到 WebSocket 消息全部接收完成。 3 ws.binary(ws.got_binary());此行代码将 WebSocket 连接设置为二进制模式，以便在后续的写入操作中正确处理二进制数据。 4 buffers_suffix&lt;multi_buffer::const_buffers_type&gt; cb&#123;buffer.data()&#125;;这行代码创建了一个 cb 对象，它是 buffer 的后缀子序列。它提供了对 buffer 中已接收数据的访问。 5 if(buffer_bytes(cb) &gt; 512) &#123; ... &#125; else &#123; ... &#125;这段代码检查 cb 中的数据量是否大于 512 字节。如果是，将执行 if 语句块；否则，将执行 else 语句块。 6 ws.write_some(false, buffers_prefix(512, cb));如果 cb 中的数据量大于 512 字节，此行代码将发送 cb 的前缀（前 512 字节）到 WebSocket 连接中，并保留剩余的数据。 7 cb.consume(512);这行代码告知 cb 对象消耗了前 512 字节的数据，以便在后续迭代中更新迭代范围。 8 ws.write_some(true, cb);如果 cb 中的数据量少于等于 512 字节，此行代码将发送 cb 中的所有数据到 WebSocket 连接中。 buffer.consume(buffer.size());这行代码清空 buffer 中存储的数据，使其为空。 总体来说，这段代码的作用是读取 WebSocket 数据并将其写回 WebSocket 连接，确保数据按照预期进行处理。最后，通过 buffer.consume(buffer.size()) 清空缓冲区，准备下一次数据读取操作。 关闭连接当我们想关闭连接时，可以通过close 或 async_close 的关闭函数。具体而言，WebSocket 协议规定了两种关闭方式： close这是一个同步操作的函数，用于关闭 WebSocket 会话。当调用 close 时，客户端或服务器会向对方发送一个关闭帧，并且在收到对方的关闭帧后，会话将被正常关闭。 async_close这是一个异步操作的函数，用于关闭 WebSocket 会话。与 close 不同，async_close 是一个非阻塞操作，它不会等待对方的关闭帧，而是立即返回，并触发一个异步关闭操作。这样可以在关闭过程中继续处理其他任务，而不必等待关闭完成。 这些关闭函数允许主机在 WebSocket 会话中发起关闭请求，以便安全地终止连接。应用程序可以根据需要选择适合的关闭函数，具体取决于其对同步或异步关闭的要求。 因为一个websocket会包含多个层，所以我们可以通过获取最底层，再执行关闭。这样保证所有层都安全关闭。 1get_lowest_layer(wss).close(); 总结上面讲述了beast网络库websocket的使用方法，我通过实战，利用异步函数封装了一个websocket服务器，可以从下面的源码连接里看看项目代码。 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"beast网络库搭建http服务器","date":"2023-06-24T09:21:08.000Z","path":"2023/06/24/asio23/","text":"简介前面的几篇文章已经介绍了如何使用asio搭建高并发的tcp服务器，以及http服务器。但是纯手写http服务器太麻烦了，有网络库beast已经帮我们实现了。这一期讲讲如何使用beast实现一个http服务器。 连接类我们先实现http_server函数 12345678910void http_server(tcp::acceptor&amp; acceptor, tcp::socket&amp; socket)&#123; acceptor.async_accept(socket, [&amp;](beast::error_code ec) &#123; if (!ec) std::make_shared&lt;http_connection&gt;(std::move(socket))-&gt;start(); http_server(acceptor, socket); &#125;);&#125; http_server中添加了异步接收连接的逻辑，当有新的连接到来时创建http_connection,然后启动服务，新连接监听对端数据。接下来http_server继续监听对端的新连接。连接类http_connection里实现了start函数监听对端数据 12345void start()&#123; read_request(); check_deadline();&#125; 处理读请求,将读到的数据存储再成员变量request_中，然后调用process_request处理请求 12345678910111213141516void read_request()&#123; auto self = shared_from_this(); http::async_read( socket_, buffer_, request_, [self](beast::error_code ec, std::size_t bytes_transferred) &#123; boost::ignore_unused(bytes_transferred); if (!ec) self-&gt;process_request(); &#125;);&#125; check_deadline主要时用来检测超时，当超过一定时间后自动关闭连接，因为http请求时短链接 123456789101112131415void check_deadline()&#123; auto self = shared_from_this(); deadline_.async_wait( [self](beast::error_code ec) &#123; if (!ec) &#123; // Close socket to cancel any outstanding operation. self-&gt;socket_.close(ec); &#125; &#125;);&#125; process_request函数中区分请求的类型，进行不同类型的处理如post还是get请求 12345678910111213141516171819202122232425262728293031void process_request()&#123; response_.version(request_.version()); response_.keep_alive(false); switch (request_.method()) &#123; case http::verb::get: response_.result(http::status::ok); response_.set(http::field::server, &quot;Beast&quot;); create_response(); break; case http::verb::post: response_.result(http::status::ok); response_.set(http::field::server, &quot;Beast&quot;); create_post_response(); break; default: // We return responses indicating an error if // we do not recognize the request method. response_.result(http::status::bad_request); response_.set(http::field::content_type, &quot;text/plain&quot;); beast::ostream(response_.body()) &lt;&lt; &quot;Invalid request-method &#x27;&quot; &lt;&lt; std::string(request_.method_string()) &lt;&lt; &quot;&#x27;&quot;; break; &#125; write_response();&#125; create_response函数中解析了不同的路由处理get请求 1234567891011121314151617181920212223242526272829303132333435363738void create_response()&#123; if (request_.target() == &quot;/count&quot;) &#123; response_.set(http::field::content_type, &quot;text/html&quot;); beast::ostream(response_.body()) &lt;&lt; &quot;&lt;html&gt;\\n&quot; &lt;&lt; &quot;&lt;head&gt;&lt;title&gt;Request count&lt;/title&gt;&lt;/head&gt;\\n&quot; &lt;&lt; &quot;&lt;body&gt;\\n&quot; &lt;&lt; &quot;&lt;h1&gt;Request count&lt;/h1&gt;\\n&quot; &lt;&lt; &quot;&lt;p&gt;There have been &quot; &lt;&lt; my_program_state::request_count() &lt;&lt; &quot; requests so far.&lt;/p&gt;\\n&quot; &lt;&lt; &quot;&lt;/body&gt;\\n&quot; &lt;&lt; &quot;&lt;/html&gt;\\n&quot;; &#125; else if (request_.target() == &quot;/time&quot;) &#123; response_.set(http::field::content_type, &quot;text/html&quot;); beast::ostream(response_.body()) &lt;&lt; &quot;&lt;html&gt;\\n&quot; &lt;&lt; &quot;&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;\\n&quot; &lt;&lt; &quot;&lt;body&gt;\\n&quot; &lt;&lt; &quot;&lt;h1&gt;Current time&lt;/h1&gt;\\n&quot; &lt;&lt; &quot;&lt;p&gt;The current time is &quot; &lt;&lt; my_program_state::now() &lt;&lt; &quot; seconds since the epoch.&lt;/p&gt;\\n&quot; &lt;&lt; &quot;&lt;/body&gt;\\n&quot; &lt;&lt; &quot;&lt;/html&gt;\\n&quot;; &#125; else &#123; response_.result(http::status::not_found); response_.set(http::field::content_type, &quot;text/plain&quot;); beast::ostream(response_.body()) &lt;&lt; &quot;File not found\\r\\n&quot;; &#125;&#125; create_post_response处理了post请求中的一部分路由 1234567891011121314151617181920212223242526272829303132333435void create_post_response() &#123; if (request_.target() == &quot;/email&quot;) &#123; auto&amp; body = this-&gt;request_.body(); auto body_str = boost::beast::buffers_to_string(body.data()); std::cout &lt;&lt; &quot;receive body is &quot; &lt;&lt; body_str &lt;&lt; std::endl; this-&gt;response_.set(http::field::content_type, &quot;text/json&quot;); Json::Value root; Json::Reader reader; Json::Value src_root; bool parse_success = reader.parse(body_str, src_root); if (!parse_success) &#123; std::cout &lt;&lt; &quot;Failed to parse JSON data!&quot; &lt;&lt; std::endl; root[&quot;error&quot;] = 1001; std::string jsonstr = root.toStyledString(); beast::ostream(this-&gt;response_.body()) &lt;&lt; jsonstr; return ; &#125; auto email = src_root[&quot;email&quot;].asString(); std::cout &lt;&lt; &quot;email is &quot; &lt;&lt; email &lt;&lt; std::endl; root[&quot;error&quot;] = 0; root[&quot;email&quot;] = src_root[&quot;email&quot;]; root[&quot;msg&quot;] = &quot;recevie email post success&quot;; std::string jsonstr = root.toStyledString(); beast::ostream(this-&gt;response_.body()) &lt;&lt; jsonstr; &#125; else &#123; response_.result(http::status::not_found); response_.set(http::field::content_type, &quot;text/plain&quot;); beast::ostream(response_.body()) &lt;&lt; &quot;File not found\\r\\n&quot;; &#125;&#125; write_response发送请求 123456789101112131415void write_response()&#123; auto self = shared_from_this(); response_.content_length(response_.body().size()); http::async_write( socket_, response_, [self](beast::error_code ec, std::size_t) &#123; self-&gt;socket_.shutdown(tcp::socket::shutdown_send, ec); self-&gt;deadline_.cancel(); &#125;);&#125; 总结本文介绍了如何使用beast网络库实现http服务器 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"asio实现http服务器","date":"2023-06-23T03:56:51.000Z","path":"2023/06/23/asio22/","text":"简介前文介绍了asio如何实现并发的长连接tcp服务器，今天介绍如何实现http服务器，在介绍实现http服务器之前，需要讲述下http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。 HTTP包头信息一个标准的HTTP报文头通常由请求头和响应头两部分组成。 HTTP 请求头HTTP请求头包括以下字段： Request-line：包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。 Host：指定被请求资源的主机名或IP地址和端口号。 Accept：指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text/plain, text/html。 User-Agent：客户端使用的浏览器类型和版本号，供服务器统计用户代理信息。 Cookie：如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。 Connection：表示是否需要持久连接（keep-alive）。 比如下面就是一个实际应用 1234567GET /index.html HTTP/1.1Host: www.example.comAccept: text/html, application/xhtml+xml, */*User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0Cookie: sessionid=abcdefg1234567Connection: keep-alive 上述请求头包括了以下字段： Request-line：指定使用GET方法请求/index.html资源，并使用HTTP/1.1协议版本。 Host：指定被请求资源所在主机名或IP地址和端口号。 Accept：客户端期望接收的媒体类型列表，本例中指定了text/html、application/xhtml+xml和任意类型的文件（*/*）。 User-Agent：客户端浏览器类型和版本号。 Cookie：客户端发送给服务器的cookie信息。 Connection：客户端请求后是否需要保持长连接。 HTTP 响应头HTTP响应头包括以下字段： Status-line：包含协议版本、状态码和状态消息。 Content-Type：响应体的MIME类型。 Content-Length：响应体的字节数。 Set-Cookie：服务器向客户端发送cookie信息时使用该字段。 Server：服务器类型和版本号。 Connection：表示是否需要保持长连接（keep-alive）。 在实际的HTTP报文头中，还可以包含其他可选字段。如下是一个http响应头的示例 123456HTTP/1.1 200 OKContent-Type: text/html; charset=UTF-8Content-Length: 1024Set-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/Server: Apache/2.2.32 (Unix) mod_ssl/2.2.32 OpenSSL/1.0.1e-fips mod_bwlimited/1.4Connection: keep-alive 上述响应头包括了以下字段： Status-line：指定HTTP协议版本、状态码和状态消息。 Content-Type：指定响应体的MIME类型及字符编码格式。 Content-Length：指定响应体的字节数。 Set-Cookie：服务器向客户端发送cookie信息时使用该字段。 Server：服务器类型和版本号。 Connection：服务器是否需要保持长连接。 客户端的编写客户端每次发送数据都要携带头部信息，所以为了减少每次重新构造头部的开销，我们在客户端的构造函数里将头部信息构造好，作为一个成员放入客户端的类成员里。 12345678910111213141516171819202122232425 client(boost::asio::io_context&amp; io_context, const std::string&amp; server, const std::string&amp; path) : resolver_(io_context), socket_(io_context) &#123; // Form the request. We specify the &quot;Connection: close&quot; header so that the // server will close the socket after transmitting the response. This will // allow us to treat all data up until the EOF as the content. std::ostream request_stream(&amp;request_); request_stream &lt;&lt; &quot;GET &quot; &lt;&lt; path &lt;&lt; &quot; HTTP/1.0\\r\\n&quot;; request_stream &lt;&lt; &quot;Host: &quot; &lt;&lt; server &lt;&lt; &quot;\\r\\n&quot;; request_stream &lt;&lt; &quot;Accept: */*\\r\\n&quot;; request_stream &lt;&lt; &quot;Connection: close\\r\\n\\r\\n&quot;;size_t pos = server.find(&quot;:&quot;);std::string ip = server.substr(0, pos);std::string port = server.substr(pos + 1); // Start an asynchronous resolve to translate the server and service names // into a list of endpoints. resolver_.async_resolve(ip, port, boost::bind(&amp;client::handle_resolve, this, boost::asio::placeholders::error, boost::asio::placeholders::results)); &#125; 我们的客户端构造了一个request_成员变量，依次写入请求的路径，主机地址，期望接受的媒体类型，以及每次收到请求后断开连接，也就是短链接的方式。接着又异步解析ip和端口，解析成功后调用handle_resolve函数。handle_resolve函数里异步处理连接 12345678910111213141516void handle_resolve(const boost::system::error_code&amp; err, const tcp::resolver::results_type&amp; endpoints) &#123; if (!err) &#123; // Attempt a connection to each endpoint in the list until we // successfully establish a connection. boost::asio::async_connect(socket_, endpoints, boost::bind(&amp;client::handle_connect, this, boost::asio::placeholders::error)); &#125; else &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; err.message() &lt;&lt; &quot;\\n&quot;; &#125; &#125; 处理连接 1234567891011121314void handle_connect(const boost::system::error_code&amp; err) &#123; if (!err) &#123; // The connection was successful. Send the request. boost::asio::async_write(socket_, request_, boost::bind(&amp;client::handle_write_request, this, boost::asio::placeholders::error)); &#125; else &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; err.message() &lt;&lt; &quot;\\n&quot;; &#125; &#125; 在连接成功后，我们首先将头部信息发送给服务器,发送完成后监听对端发送的数据 12345678910111213141516void handle_write_request(const boost::system::error_code&amp; err)&#123; if (!err) &#123; // Read the response status line. The response_ streambuf will // automatically grow to accommodate the entire line. The growth may be // limited by passing a maximum size to the streambuf constructor. boost::asio::async_read_until(socket_, response_, &quot;\\r\\n&quot;, boost::bind(&amp;client::handle_read_status_line, this, boost::asio::placeholders::error)); &#125; else &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; err.message() &lt;&lt; &quot;\\n&quot;; &#125;&#125; 当收到对方数据时，先解析响应的头部信息 12345678910111213141516171819202122232425262728293031323334void handle_read_status_line(const boost::system::error_code&amp; err)&#123; if (!err) &#123; // Check that response is OK. std::istream response_stream(&amp;response_); std::string http_version; response_stream &gt;&gt; http_version; unsigned int status_code; response_stream &gt;&gt; status_code; std::string status_message; std::getline(response_stream, status_message); if (!response_stream || http_version.substr(0, 5) != &quot;HTTP/&quot;) &#123; std::cout &lt;&lt; &quot;Invalid response\\n&quot;; return; &#125; if (status_code != 200) &#123; std::cout &lt;&lt; &quot;Response returned with status code &quot;; std::cout &lt;&lt; status_code &lt;&lt; &quot;\\n&quot;; return; &#125; // Read the response headers, which are terminated by a blank line. boost::asio::async_read_until(socket_, response_, &quot;\\r\\n\\r\\n&quot;, boost::bind(&amp;client::handle_read_headers, this, boost::asio::placeholders::error)); &#125; else &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\\n&quot;; &#125;&#125; 上面的代码先读出HTTP版本，以及返回的状态码，如果状态码不是200，则返回，是200说明响应成功。接下来把所有的头部信息都读出来。 1234567891011121314151617181920212223242526void handle_read_headers(const boost::system::error_code&amp; err)&#123; if (!err) &#123; // Process the response headers. std::istream response_stream(&amp;response_); std::string header; while (std::getline(response_stream, header) &amp;&amp; header != &quot;\\r&quot;) std::cout &lt;&lt; header &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;\\n&quot;; // Write whatever content we already have to output. if (response_.size() &gt; 0) std::cout &lt;&lt; &amp;response_; // Start reading remaining data until EOF. boost::asio::async_read(socket_, response_, boost::asio::transfer_at_least(1), boost::bind(&amp;client::handle_read_content, this, boost::asio::placeholders::error)); &#125; else &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\\n&quot;; &#125;&#125; 上面的代码逐行读出头部信息，然后读出响应的内容，继续监听读事件读取相应的内容，直到接收到EOF信息，也就是对方关闭，继续监听读事件是因为有可能是长连接的方式，当然如果是短链接，则服务器关闭连接后，客户端也是通过异步函数读取EOF进而结束请求。 123456789101112131415161718void handle_read_content(const boost::system::error_code&amp; err)&#123; if (!err) &#123; // Write all of the data that has been read so far. std::cout &lt;&lt; &amp;response_; // Continue reading remaining data until EOF. boost::asio::async_read(socket_, response_, boost::asio::transfer_at_least(1), boost::bind(&amp;client::handle_read_content, this, boost::asio::placeholders::error)); &#125; else if (err != boost::asio::error::eof) &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\\n&quot;; &#125;&#125; 在主函数中调用客户端请求服务器信息, 请求的路由地址为/ 12345678910111213141516int main(int argc, char* argv[])&#123; try &#123; boost::asio::io_context io_context; client c(io_context, &quot;127.0.0.1:8080&quot;, &quot;/&quot;); io_context.run(); getchar(); &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 服务器设计为了方便理解，我们从服务器的调用流程讲起 12345678910111213141516171819202122int main(int argc, char* argv[])&#123; try &#123; std::filesystem::path path = std::filesystem::current_path() / &quot;res&quot;; // 使用 std::cout 输出拼接后的路径 std::cout &lt;&lt; &quot;Path: &quot; &lt;&lt; path.string() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot;Usage: http_server &lt;127.0.0.1&gt; &lt;8080&gt; &quot;&lt;&lt; path.string() &lt;&lt;&quot;\\n&quot;; // Initialise the server. http::server::server s(&quot;127.0.0.1&quot;, &quot;8080&quot;, path.string()); // Run the server until stopped. s.run(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;exception: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 主函数里构造了一个server对象，然后调用了run函数使其跑起来。run函数其实就是调用了server类成员的ioservice 1234void server::run()&#123; io_service_.run();&#125; server类的构造函数里初始化一些成员变量，比如acceptor连接器，绑定了终止信号，并且监听对端连接 1234567891011121314151617181920212223server::server(const std::string&amp; address, const std::string&amp; port, const std::string&amp; doc_root) : io_service_(), signals_(io_service_), acceptor_(io_service_), connection_manager_(), socket_(io_service_), request_handler_(doc_root) &#123; signals_.add(SIGINT); signals_.add(SIGTERM);#if defined(SIGQUIT) signals_.add(SIGQUIT);#endif do_await_stop(); boost::asio::ip::tcp::resolver resolver(io_service_); boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve(&#123; address, port &#125;); acceptor_.open(endpoint.protocol()); acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true)); acceptor_.bind(endpoint); acceptor_.listen(); do_accept(); &#125; 接收连接 1234567891011121314151617181920void server::do_accept()&#123; acceptor_.async_accept(socket_, [this](boost::system::error_code ec) &#123; if (!acceptor_.is_open()) &#123; return; &#125; if (!ec) &#123; connection_manager_.start(std::make_shared&lt;connection&gt;( std::move(socket_), connection_manager_, request_handler_)); &#125; do_accept(); &#125;); &#125; 接收函数里通过connection_manager_启动了一个新的连接，用来处理读写函数。处理方式和我们之前的写法类似，只是我们之前管理连接用的server，这次用的conneciton_manager 12345void connection_manager::start(connection_ptr c)&#123; connections_.insert(c); c-&gt;start();&#125; start函数里处理读写 1234void connection::start()&#123; do_read();&#125; 处理读数据比较复杂，我们分部分解释 123456789101112131415161718192021222324252627282930313233void connection::do_read()&#123; auto self(shared_from_this()); socket_.async_read_some(boost::asio::buffer(buffer_), [this, self](boost::system::error_code ec, std::size_t bytes_transferred) &#123; if (!ec) &#123; request_parser::result_type result; std::tie(result, std::ignore) = request_parser_.parse( request_, buffer_.data(), buffer_.data() + bytes_transferred); if (result == request_parser::good) &#123; request_handler_.handle_request(request_, reply_); do_write(); &#125; else if (result == request_parser::bad) &#123; reply_ = reply::stock_reply(reply::bad_request); do_write(); &#125; else &#123; do_read(); &#125; &#125; else if (ec != boost::asio::error::operation_aborted) &#123; connection_manager_.stop(shared_from_this()); &#125; &#125;);&#125; 通过request_parser_解析请求，然后根据请求结果选择处理请求还是返回错误。 1234567891011std::tuple&lt;result_type, InputIterator&gt; parse(request&amp; req, InputIterator begin, InputIterator end)&#123; while (begin != end) &#123; result_type result = consume(req, *begin++); if (result == good || result == bad) return std::make_tuple(result, begin); &#125; return std::make_tuple(indeterminate, begin);&#125; parse是解析请求的函数，内部调用了consume不断处理请求头中的数据，其实就是一个逐行解析的过程, consume函数很长，这里就不解释了，其实就是每解析一行就更改一下状态，这样可以继续解析。具体可以看看源码。 在consume()函数中，根据每个字符输入的不同情况，判断当前所处状态state_，进而执行相应的操作，包括： 将HTTP请求方法、URI和HTTP版本号解析到request结构体中。 解析每个请求头部字段的名称和值，并将其添加到request结构体中的headers vector中。 如果输入字符为\\r\\n，则修改状态以开始下一行的解析。 最后，返回一个枚举类型request_parser::result_type作为解析结果，包括indeterminate、good和bad三种状态。其中，indeterminate表示还需要继续等待更多字符输入；good表示成功解析出了一个完整的HTTP请求头部；bad表示遇到无效字符或格式错误，解析失败。 解析完成头部后会调用处理请求的函数,这里只是简单的写了一个作为资源服务器解析资源请求的逻辑，具体可以看源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void request_handler::handle_request(const request&amp; req, reply&amp; rep)&#123; // Decode url to path. std::string request_path; if (!url_decode(req.uri, request_path)) &#123; rep = reply::stock_reply(reply::bad_request); return; &#125; // Request path must be absolute and not contain &quot;..&quot;. if (request_path.empty() || request_path[0] != &#x27;/&#x27; || request_path.find(&quot;..&quot;) != std::string::npos) &#123; rep = reply::stock_reply(reply::bad_request); return; &#125; // If path ends in slash (i.e. is a directory) then add &quot;index.html&quot;. if (request_path[request_path.size() - 1] == &#x27;/&#x27;) &#123; request_path += &quot;index.html&quot;; &#125; // Determine the file extension. std::size_t last_slash_pos = request_path.find_last_of(&quot;/&quot;); std::size_t last_dot_pos = request_path.find_last_of(&quot;.&quot;); std::string extension; if (last_dot_pos != std::string::npos &amp;&amp; last_dot_pos &gt; last_slash_pos) &#123; extension = request_path.substr(last_dot_pos + 1); &#125; // Open the file to send back. std::string full_path = doc_root_ + request_path; std::ifstream is(full_path.c_str(), std::ios::in | std::ios::binary); if (!is) &#123; rep = reply::stock_reply(reply::not_found); return; &#125; // Fill out the reply to be sent to the client. rep.status = reply::ok; char buf[512]; while (is.read(buf, sizeof(buf)).gcount() &gt; 0) rep.content.append(buf, is.gcount()); rep.headers.resize(2); rep.headers[0].name = &quot;Content-Length&quot;; rep.headers[0].value = std::to_string(rep.content.size()); rep.headers[1].name = &quot;Content-Type&quot;; rep.headers[1].value = mime_types::extension_to_type(extension); &#125; 上述代码根据url中的.来做切割，获取请求的文件类型，然后根据/切割url，获取资源目录，最后返回资源文件。如果你想实现普通的路由请求返回json或者text格式，可以重写处理请求的逻辑。 总结本文介绍了如何使用asio实现http服务器，具体可以查看下方源码，其实这些仅作为了解即可，不推荐从头造轮子，我们可以用一些C++ 成熟的http服务库比如beast，下一节再介绍。 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用asio协程调度实现并发服务器","date":"2023-06-16T02:41:26.000Z","path":"2023/06/16/asio21/","text":"简介之前介绍了asio服务器并发编程的几种模型，包括单线程，多线程IOServicePool，多线程IOThreadPool等，今天带着大家利用asio协程实现并发服务器。利用协程实现并发程序有两个好处1 &emsp; 将回调函数改写为顺序调用，提高开发效率。2 &emsp; 协程调度比线程调度更轻量化，因为协程是运行在用户空间的，线程切换需要在用户空间和内核空间切换。 协程案例asio官网提供了一个协程并发编程的案例，我们列举一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;boost/asio/co_spawn.hpp&gt;#include &lt;boost/asio/detached.hpp&gt;#include &lt;boost/asio/io_context.hpp&gt;#include &lt;boost/asio/ip/tcp.hpp&gt;#include &lt;boost/asio/signal_set.hpp&gt;#include &lt;boost/asio/write.hpp&gt;#include &lt;cstdio&gt;using boost::asio::ip::tcp;using boost::asio::awaitable;using boost::asio::co_spawn;using boost::asio::detached;using boost::asio::use_awaitable;namespace this_coro = boost::asio::this_coro;#if defined(BOOST_ASIO_ENABLE_HANDLER_TRACKING)# define use_awaitable \\ boost::asio::use_awaitable_t(__FILE__, __LINE__, __PRETTY_FUNCTION__)#endifawaitable&lt;void&gt; echo(tcp::socket socket)&#123; try &#123; char data[1024]; for (;;) &#123; std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), use_awaitable); co_await async_write(socket, boost::asio::buffer(data, n), use_awaitable); &#125; &#125; catch (std::exception&amp; e) &#123; std::printf(&quot;echo Exception: %s\\n&quot;, e.what()); &#125;&#125;awaitable&lt;void&gt; listener()&#123; auto executor = co_await this_coro::executor; tcp::acceptor acceptor(executor, &#123; tcp::v4(), 10086 &#125;); for (;;) &#123; tcp::socket socket = co_await acceptor.async_accept(use_awaitable); co_spawn(executor, echo(std::move(socket)), detached); &#125;&#125;int main()&#123; try &#123; boost::asio::io_context io_context(1); boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); signals.async_wait([&amp;](auto, auto) &#123; io_context.stop(); &#125;); co_spawn(io_context, listener(), detached); io_context.run(); &#125; catch (std::exception&amp; e) &#123; std::printf(&quot;Exception: %s\\n&quot;, e.what()); &#125;&#125; 1 &emsp; 我们用awaitable声明了一个函数，那么这个函数就变为可等待的函数了，比如listener被添加awaitable&lt;void&gt;之后，就可以被协程调用和等待了。2 &emsp; co_spawn表示启动一个协程，参数分别为调度器，执行的函数，以及启动方式, 比如我们启动了一个协程，deatched表示将协程对象分离出来，这种启动方式可以启动多个协程，他们都是独立的，如何调度取决于调度器，在用户的感知上更像是线程调度的模式，类似于并发运行，其实底层都是串行的。 1co_spawn(io_context, listener(), detached); 我们启动了一个协程，执行listener中的逻辑，listener内部co_await 等待 acceptor接收连接，如果没有连接到来则挂起协程。执行之后的io_context.run()逻辑。所以协程实际上是在一个线程中串行调度的，只是感知上像是并发而已。3 &emsp; 当acceptor接收到连接后，继续调用co_spawn启动一个协程，用来执行echo逻辑。echo逻辑里也是通过co_wait的方式接收和发送数据的，如果对端不发数据，执行echo的协程就会挂起，另一个协程启动，继续接收新的连接。当没有连接到来，接收新连接的协程挂起，如果所有协程都挂起，则等待新的就绪事件(对端发数据，或者新连接)到来唤醒。 改进服务器我们可以利用协程改进服务器编码流程，用一个iocontext管理绑定acceptor用来接收新的连接，再用一个iocontext或以IOServicePool的方式管理连接的收发操作，在每个连接的接收数据时改为启动一个协程，通过顺序的方式读取收到的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void CSession::Start() &#123; auto shared_this = shared_from_this(); //开启接收协程 co_spawn(_io_context, [=]()-&gt;awaitable&lt;void&gt; &#123; try &#123; for (;!_b_close;) &#123; _recv_head_node-&gt;Clear(); std::size_t n = co_await boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_TOTAL_LEN), use_awaitable); if (n == 0) &#123; std::cout &lt;&lt; &quot;receive peer closed&quot; &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); co_return; &#125; //获取头部MSGID数据 short msg_id = 0; memcpy(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN); //网络字节序转化为本地字节序 msg_id = boost::asio::detail::socket_ops::network_to_host_short(msg_id); std::cout &lt;&lt; &quot;msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; //id非法 if (msg_id &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; _server-&gt;ClearSession(_uuid); co_return; &#125; short msg_len = 0; memcpy(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN); //网络字节序转化为本地字节序 msg_len = boost::asio::detail::socket_ops::network_to_host_short(msg_len); std::cout &lt;&lt; &quot;msg_len is &quot; &lt;&lt; msg_len &lt;&lt; endl; //长度非法 if (msg_len &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; msg_len &lt;&lt; endl; _server-&gt;ClearSession(_uuid); co_return; &#125; _recv_msg_node = make_shared&lt;RecvNode&gt;(msg_len, msg_id); //读出包体 n = co_await boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), use_awaitable); if (n == 0) &#123; std::cout &lt;&lt; &quot;receive peer closed&quot; &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); co_return; &#125; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //投递给逻辑线程 LogicSystem::GetInstance().PostMsgToQue(make_shared&lt;LogicNode&gt;(shared_from_this(), _recv_msg_node)); &#125; &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;exception is &quot; &lt;&lt; e.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); &#125; &#125;, detached); &#125; 其余的逻辑和之前大体相同，测试了一下在一个iocontext负责接收新连接，一个iocontext负责接收数据和发送数据的情况下，客户端创建100个连接，收发500次，总用时为55s","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"asio多线程模型IOThreadPool","date":"2023-06-07T00:59:25.000Z","path":"2023/06/07/asio20/","text":"简介今天给大家介绍asio多线程模式的第二种，之前我们介绍了IOServicePool的方式，一个IOServicePool开启n个线程和n个iocontext，每个线程内独立运行iocontext, 各个iocontext监听各自绑定的socket是否就绪，如果就绪就在各自线程里触发回调函数。为避免线程安全问题，我们将网络数据封装为逻辑包投递给逻辑系统，逻辑系统有一个单独线程处理，这样将网络IO和逻辑处理解耦合，极大的提高了服务器IO层面的吞吐率。这一次介绍的另一种多线程模式IOThreadPool，我们只初始化一个iocontext用来监听服务器的读写事件，包括新连接到来的监听也用这个iocontext。只是我们让iocontext.run在多个线程中调用，这样回调函数就会被不同的线程触发，从这个角度看回调函数被并发调用了。 结构图线程池模式的多线程模型调度结构图,如下 先实现IOThreadPool 123456789101112131415161718#include &lt;boost/asio.hpp&gt;#include &quot;Singleton.h&quot;class AsioThreadPool:public Singleton&lt;AsioThreadPool&gt;&#123;public: friend class Singleton&lt;AsioThreadPool&gt;; ~AsioThreadPool()&#123;&#125; AsioThreadPool&amp; operator=(const AsioThreadPool&amp;) = delete; AsioThreadPool(const AsioThreadPool&amp;) = delete; boost::asio::io_context&amp; GetIOService(); void Stop();private: AsioThreadPool(int threadNum = std::thread::hardware_concurrency()); boost::asio::io_context _service; std::unique_ptr&lt;boost::asio::io_context::work&gt; _work; std::vector&lt;std::thread&gt; _threads;&#125;; AsioThreadPool继承了Singleton&lt;AsioThreadPool&gt;，实现了一个函数GetIOService获取iocontext 接下来我们看看具体实现 123456789101112131415161718192021#include &quot;AsioThreadPool.h&quot;AsioThreadPool::AsioThreadPool(int threadNum ):_work(new boost::asio::io_context::work(_service))&#123; for (int i = 0; i &lt; threadNum; ++i) &#123; _threads.emplace_back([this]() &#123; _service.run(); &#125;); &#125;&#125;boost::asio::io_context&amp; AsioThreadPool::GetIOService() &#123; return _service;&#125;void AsioThreadPool::Stop() &#123; _work.reset(); for (auto&amp; t : _threads) &#123; t.join(); &#125;&#125; 构造函数中实现了一个线程池，线程池里每个线程都会运行_service.run函数，_service.run函数内部就是从iocp或者epoll获取就绪描述符和绑定的回调函数，进而调用回调函数，因为回调函数是在不同的线程里调用的，所以会存在不同的线程调用同一个socket的回调函数的情况。_service.run 内部在Linux环境下调用的是epoll_wait返回所有就绪的描述符列表，在windows上会循环调用GetQueuedCompletionStatus函数返回就绪的描述符，二者原理类似，进而通过描述符找到对应的注册的回调函数，然后调用回调函数。比如iocp的流程是这样的 123456IOCP的使用主要分为以下几步：1 创建完成端口(iocp)对象2 创建一个或多个工作线程，在完成端口上执行并处理投递到完成端口上的I/O请求3 Socket关联iocp对象，在Socket上投递网络事件4 工作线程调用GetQueuedCompletionStatus函数获取完成通知封包，取得事件信息并进行处理 epoll的流程是这样的 12341 调用epoll_creat在内核中创建一张epoll表2 开辟一片包含n个epoll_event大小的连续空间3 将要监听的socket注册到epoll表里4 调用epoll_wait，传入之前我们开辟的连续空间，epoll_wait返回就绪的epoll_event列表，epoll会将就绪的socket信息写入我们之前开辟的连续空间 隐患IOThreadPool模式有一个隐患，同一个socket的就绪后，触发的回调函数可能在不同的线程里，比如第一次是在线程1，第二次是在线程3，如果这两次触发间隔时间不大，那么很可能出现不同线程并发访问数据的情况，比如在处理读事件时，第一次回调触发后我们从socket的接收缓冲区读数据出来，第二次回调触发,还是从socket的接收缓冲区读数据，就会造成两个线程同时从socket中读数据的情况，会造成数据混乱。 利用strand改进对于多线程触发回调函数的情况，我们可以利用asio提供的串行类strand封装一下，这样就可以被串行调用了，其基本原理就是在线程各自调用函数时取消了直接调用的方式，而是利用一个strand类型的对象将要调用的函数投递到strand管理的队列中，再由一个统一的线程调用回调函数，调用是串行的，解决了线程并发带来的安全问题。 图中当socket就绪后并不是由多个线程调用每个socket注册的回调函数，而是将回调函数投递给strand管理的队列，再由strand统一调度派发。 为了让回调函数被派发到strand的队列，我们只需要在注册回调函数时加一层strand的包装即可。 在CSession类中添加一个成员变量 1strand&lt;io_context::executor_type&gt; _strand; CSession的构造函数 1234567CSession::CSession(boost::asio::io_context&amp; io_context, CServer* server): _socket(io_context), _server(server), _b_close(false), _b_head_parse(false), _strand(io_context.get_executor())&#123; boost::uuids::uuid a_uuid = boost::uuids::random_generator()(); _uuid = boost::uuids::to_string(a_uuid); _recv_head_node = make_shared&lt;MsgNode&gt;(HEAD_TOTAL_LEN);&#125; 可以看到_strand的初始化是放在初始化列表里，利用io_context.get_executor()返回的执行器构造strand。 因为在asio中无论iocontext还是strand，底层都是通过executor调度的，我们将他理解为调度器就可以了，如果多个iocontext和strand的调度器是一个，那他们的消息派发统一由这个调度器执行。 我们利用iocontext的调度器构造strand，这样他们统一由一个调度器管理。在绑定回调函数的调度器时，我们选择strand绑定即可。 比如我们在Start函数里添加绑定 ，将回调函数的调用者绑定为_strand 1234567void CSession::Start()&#123; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), boost::asio::bind_executor(_strand, std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, SharedSelf())));&#125; 同样的道理，在所有收发的地方，都将调度器绑定为_strand， 比如发送部分我们需要修改为如下 1234auto&amp; msgnode = _send_que.front();boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_total_len), boost::asio::bind_executor(_strand, std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, SharedSelf())) ); 回调函数的处理部分也做对应的修改即可。 性能对比为了比较两种服务器多线程模式的性能，我们还是利用之前测试的客户端，客户端每隔10ms建立一个连接，总共建立100个连接，每个连接收发500次，总计10万个数据包，测试一下性能。 客户端测试代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;thread&gt;#include &lt;json/json.h&gt;#include &lt;json/value.h&gt;#include &lt;json/reader.h&gt;#include &lt;chrono&gt;using namespace std;using namespace boost::asio::ip;const int MAX_LENGTH = 1024 * 2;const int HEAD_LENGTH = 2;const int HEAD_TOTAL = 4;std::vector&lt;thread&gt; vec_threads;int main()&#123; auto start = std::chrono::high_resolution_clock::now(); // 获取开始时间 for (int i = 0; i &lt; 100; i++) &#123; vec_threads.emplace_back([]() &#123; try &#123; //创建上下文服务 boost::asio::io_context ioc; //构造endpoint tcp::endpoint remote_ep(address::from_string(&quot;127.0.0.1&quot;), 10086); tcp::socket sock(ioc); boost::system::error_code error = boost::asio::error::host_not_found; ; sock.connect(remote_ep, error); if (error) &#123; cout &lt;&lt; &quot;connect failed, code is &quot; &lt;&lt; error.value() &lt;&lt; &quot; error msg is &quot; &lt;&lt; error.message(); return 0; &#125; int i = 0; while (i &lt; 500) &#123; Json::Value root; root[&quot;id&quot;] = 1001; root[&quot;data&quot;] = &quot;hello world&quot;; std::string request = root.toStyledString(); size_t request_length = request.length(); char send_data[MAX_LENGTH] = &#123; 0 &#125;; int msgid = 1001; int msgid_host = boost::asio::detail::socket_ops::host_to_network_short(msgid); memcpy(send_data, &amp;msgid_host, 2); //转为网络字节序 int request_host_length = boost::asio::detail::socket_ops::host_to_network_short(request_length); memcpy(send_data + 2, &amp;request_host_length, 2); memcpy(send_data + 4, request.c_str(), request_length); boost::asio::write(sock, boost::asio::buffer(send_data, request_length + 4)); cout &lt;&lt; &quot;begin to receive...&quot; &lt;&lt; endl; char reply_head[HEAD_TOTAL]; size_t reply_length = boost::asio::read(sock, boost::asio::buffer(reply_head, HEAD_TOTAL)); msgid = 0; memcpy(&amp;msgid, reply_head, HEAD_LENGTH); short msglen = 0; memcpy(&amp;msglen, reply_head + 2, HEAD_LENGTH); //转为本地字节序 msglen = boost::asio::detail::socket_ops::network_to_host_short(msglen); msgid = boost::asio::detail::socket_ops::network_to_host_short(msgid); char msg[MAX_LENGTH] = &#123; 0 &#125;; size_t msg_length = boost::asio::read(sock, boost::asio::buffer(msg, msglen)); Json::Reader reader; reader.parse(std::string(msg, msg_length), root); std::cout &lt;&lt; &quot;msg id is &quot; &lt;&lt; root[&quot;id&quot;] &lt;&lt; &quot; msg is &quot; &lt;&lt; root[&quot;data&quot;] &lt;&lt; endl; i++; &#125; &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; &#125;); std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; for (auto&amp; t : vec_threads) &#123; t.join(); &#125; // 执行一些需要计时的操作 auto end = std::chrono::high_resolution_clock::now(); // 获取结束时间 auto duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(end - start); // 计算时间差，单位为微秒 std::cout &lt;&lt; &quot;Time spent: &quot; &lt;&lt; duration.count() &lt;&lt; &quot; seconds.&quot; &lt;&lt; std::endl; // 输 getchar(); return 0;&#125; 我们先启动之前实现的AsioIOServicePool多线程模式的服务器测试,10万个数据包收发完成总计46秒 接下来我们启动ASIOThreadPool多线程模式的服务器测试，10万个数据包收发完成总计53秒 可以看出今天实现的多线程模式较之前的IOServicePool版本慢了7秒 取舍实际的生产和开发中，我们尽可能利用C++特性，使用多核的优势，将iocontext分布在不同的线程中效率更可取一点，但也要防止线程过多导致cpu切换带来的时间片开销，所以尽量让开辟的线程数小于或等于cpu的核数，从而利用多核优势。 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"asio多线程模型IOServicePool","date":"2023-06-04T01:48:11.000Z","path":"2023/06/04/asio19/","text":"简介前面的设计，我们对asio的使用都是单线程模式，为了提升网络io并发处理的效率，这一次我们设计多线程模式下asio的使用方式。总体来说asio有两个多线程模型，第一个是启动多个线程，每个线程管理一个iocontext。第二种是只启动一个iocontext，被多个线程共享，后面的文章会对比两个模式的区别，这里先介绍第一种模式，多个线程，每个线程管理独立的iocontext服务。 单线程和多线程对比之前的单线程模式图如下 我们设计的IOServicePool类型的多线程模型如下： IOServicePool多线程模式特点 1 &emsp; 每一个io_context跑在不同的线程里，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。 2 &emsp; 但是对于不同的socket，回调函数的触发可能是同一个线程(两个socket被分配到同一个io_context)，也可能不是同一个线程(两个socket被分配到不同的io_context里)。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket2代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。 3 &emsp; 多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个socket被部署到不同的iocontext上，但是当两个socket部署到同一个iocontext上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。 IOServicePool实现IOServicePool本质上是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和iocontext，然后每个线程跑一个iocontext，这样就可以并发处理不同iocontext读写事件了。 IOServicePool的声明 1234567891011121314151617181920class AsioIOServicePool:public Singleton&lt;AsioIOServicePool&gt;&#123; friend Singleton&lt;AsioIOServicePool&gt;;public: using IOService = boost::asio::io_context; using Work = boost::asio::io_context::work; using WorkPtr = std::unique_ptr&lt;Work&gt;; ~AsioIOServicePool(); AsioIOServicePool(const AsioIOServicePool&amp;) = delete; AsioIOServicePool&amp; operator=(const AsioIOServicePool&amp;) = delete; // 使用 round-robin 的方式返回一个 io_service boost::asio::io_context&amp; GetIOService(); void Stop();private: AsioIOServicePool(std::size_t size = std::thread::hardware_concurrency()); std::vector&lt;IOService&gt; _ioServices; std::vector&lt;WorkPtr&gt; _works; std::vector&lt;std::thread&gt; _threads; std::size_t _nextIOService;&#125;; 1 &emsp; _ioServices是一个IOService的vector变量，用来存储初始化的多个IOService。 2 &emsp; WorkPtr是boost::asio::io_context::work类型的unique指针。在实际使用中，我们通常会将一些异步操作提交给io_context进行处理，然后该操作会被异步执行，而不会立即返回结果。如果没有其他任务需要执行，那么io_context就会停止工作，导致所有正在进行的异步操作都被取消。这时，我们需要使用boost::asio::io_context::work对象来防止io_context停止工作。 boost::asio::io_context::work的作用是持有一个指向io_context的引用，并通过创建一个“工作”项来保证io_context不会停止工作，直到work对象被销毁或者调用reset()方法为止。当所有异步操作完成后，程序可以使用work.reset()方法来释放io_context，从而让其正常退出。 3 &emsp; _threads是一个线程vector,管理我们开辟的所有线程。 4 &emsp; _nextIOService是一个轮询索引，我们用最简单的轮询算法为每个新创建的连接分配io_context. 5 &emsp; 因为IOServicePool不允许被copy构造，所以我们将其拷贝构造和拷贝复制函数置为delete 接下来我们实现构造函数 12345678910111213AsioIOServicePool::AsioIOServicePool(std::size_t size):_ioServices(size),_works(size), _nextIOService(0)&#123; for (std::size_t i = 0; i &lt; size; ++i) &#123; _works[i] = std::unique_ptr&lt;Work&gt;(new Work(_ioServices[i])); &#125; //遍历多个ioservice，创建多个线程，每个线程内部启动ioservice for (std::size_t i = 0; i &lt; _ioServices.size(); ++i) &#123; _threads.emplace_back([this, i]() &#123; _ioServices[i].run(); &#125;); &#125;&#125; _works是unique_ptr的vector类型，所以初始化时要么放在构造函数初始化列表里初始化，要么通过一个临时的std::unique_ptr右值初始化，我们采取的是第二种。 实现获取io_context&amp;的函数 1234567boost::asio::io_context&amp; AsioIOServicePool::GetIOService() &#123; auto&amp; service = _ioServices[_nextIOService++]; if (_nextIOService == _ioServices.size()) &#123; _nextIOService = 0; &#125; return service;&#125; 我们根据_nextIOService作为索引，轮询获取io_context&amp;。 同样我们要实现Stop函数，控制AsioIOServicePool停止的行为。因为我们要保证每个线程安全退出后再让AsioIOServicePool停止。 123456789void AsioIOServicePool::Stop()&#123; for (auto&amp; work : _works) &#123; work.reset(); &#125; for (auto&amp; t : _threads) &#123; t.join(); &#125;&#125; 其中work.reset()是让unique指针置空并释放，那么work的析构函数就会被调用，work被析构，其管理的io_service在没有事件监听时就会被释放。 优雅退出IOServicePool多线程服务器退出时，需要捕获退出信号如SIGINT,SIGTERM等，将退出信号和一个iocontext绑定，当收到退出信号时，我们将IOServicePool停止，并且停止iocontext即可。 123456789101112131415161718int main()&#123; try &#123; auto pool = AsioIOServicePool::GetInstance(); boost::asio::io_context io_context; boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); signals.async_wait([&amp;io_context,pool](auto, auto) &#123; io_context.stop(); pool-&gt;Stop(); &#125;); CServer s(io_context, 10086); io_context.run(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125; 上例中，我们将一个iocontext绑定给Server，当收到退出消息后停止这个iocontext，并且停止IOServicePool。 总结本文总结了如何使用IOServicePool模式构造多线程模型的asio服务器。 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"逻辑层设计","date":"2023-06-03T01:49:07.000Z","path":"2023/06/03/asio18/","text":"优雅退出服务器优雅退出一直是服务器设计必须考虑的一个方向，意在能通过捕获信号使服务器安全退出。我们可以通过asio提供的信号机制绑定回调函数即可实现优雅退出。在主函数中我们添加 123456789101112131415int main()&#123; try &#123; boost::asio::io_context io_context; boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); signals.async_wait([&amp;io_context](auto, auto) &#123; io_context.stop(); &#125;); CServer s(io_context, 10086); io_context.run(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125; 利用signal_set 定义了一系列信号合集，并且绑定了一个匿名函数，匿名函数捕获了io_context的引用，并且函数中设置了停止操作，也就是说当捕获到SIGINT,SIGTERM等信号时，会调用io_context.stop。 单例模板类接下来我们实现一个单例模板类，因为服务器的逻辑处理需要单例模式，后期可能还会有一些模块的设计也需要单例模式，所以先实现一个单例模板类，然后其他想实现单例类只需要继承这个模板类即可。 12345678910111213141516171819202122232425262728293031#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Singleton &#123;protected: Singleton() = default; Singleton(const Singleton&lt;T&gt;&amp;) = delete; Singleton&amp; operator=(const Singleton&lt;T&gt;&amp; st) = delete; static std::shared_ptr&lt;T&gt; _instance;public: static std::shared_ptr&lt;T&gt; GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = shared_ptr&lt;T&gt;(new T); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; endl; &#125; ~Singleton() &#123; std::cout &lt;&lt; &quot;this is singleton destruct&quot; &lt;&lt; std::endl; &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr; 单例模式模板类将无参构造，拷贝构造，拷贝赋值都设定为protected属性，其他的类无法访问，其实也可以设置为私有属性。析构函数设置为公有的，其实设置为私有的更合理一点。Singleton有一个static类型的属性_instance, 它是我们实际要开辟类型的智能指针类型。s_flag是函数GetInstance内的局部静态变量，该变量在函数GetInstance第一次调用时被初始化。以后无论调用多少次GetInstance s_flag都不会被重复初始化，而且s_flag存在静态区，会随着进程结束而自动释放。call_once只会调用一次，而且是线程安全的， 其内部的原理就是调用该函数时加锁，然后设置s_flag内部的标记，设置为已经初始化，执行lambda表达式逻辑初始化智能指针，然后解锁。第二次调用GetInstance 内部还会调用call_once, 只是call_once判断s_flag已经被初始化了就不执行初始化智能指针的操作了。 LogicSystem单例类我们实现逻辑系统的单例类，继承自Singleton&lt;LogicSystem&gt;，这样LogicSystem的构造函数和拷贝构造函数就都变为私有的了，因为基类的构造函数和拷贝构造函数都是私有的。另外LogicSystem也用了基类的成员_instance和GetInstance函数。从而达到单例效果。 12345678910111213141516171819typedef function&lt;void(shared_ptr&lt;CSession&gt;, short msg_id, string msg_data)&gt; FunCallBack;class LogicSystem:public Singleton&lt;LogicSystem&gt;&#123; friend class Singleton&lt;LogicSystem&gt;;public: ~LogicSystem(); void PostMsgToQue(shared_ptr &lt; LogicNode&gt; msg);private: LogicSystem(); void DealMsg(); void RegisterCallBacks(); void HelloWordCallBack(shared_ptr&lt;CSession&gt;, short msg_id, string msg_data); std::thread _worker_thread; std::queue&lt;shared_ptr&lt;LogicNode&gt;&gt; _msg_que; std::mutex _mutex; std::condition_variable _consume; bool _b_stop; std::map&lt;short, FunCallBack&gt; _fun_callbacks;&#125;; 1 &emsp; FunCallBack为要注册的回调函数类型，其参数为绘画类智能指针，消息id，以及消息内容。 2 &emsp; _msg_que为逻辑队列 3 &emsp; _mutex 为保证逻辑队列安全的互斥量 4 &emsp; _consume表示消费者条件变量，用来控制当逻辑队列为空时保证线程暂时挂起等待，不要干扰其他线程。 5 &emsp; _fun_callbacks表示回调函数的map，根据id查找对应的逻辑处理函数。 6 &emsp; _worker_thread表示工作线程，用来从逻辑队列中取数据并执行回调函数。 7 &emsp; _b_stop表示收到外部的停止信号，逻辑类要中止工作线程并优雅退出。 LogicNode定义在CSession.h中 12345678class LogicNode &#123; friend class LogicSystem;public: LogicNode(shared_ptr&lt;CSession&gt;, shared_ptr&lt;RecvNode&gt;);private: shared_ptr&lt;CSession&gt; _session; shared_ptr&lt;RecvNode&gt; _recvnode;&#125;; 其包含算了会话类的智能指针，主要是为了实现伪闭包，防止session被释放。其次包含了接收消息的节点类的智能指针。实现如下 1234LogicNode::LogicNode(shared_ptr&lt;CSession&gt; session, shared_ptr&lt;RecvNode&gt; recvnode):_session(session),_recvnode(recvnode) &#123; &#125; LogicSystem的构造函数如下 1234LogicSystem::LogicSystem():_b_stop(false)&#123; RegisterCallBacks(); _worker_thread = std::thread (&amp;LogicSystem::DealMsg, this);&#125; 构造函数中将停止信息初始化为false，注册消息处理函数并且启动了一个工作线程，工作线程执行DealMsg逻辑。注册消息处理函数的逻辑如下 1234void LogicSystem::RegisterCallBacks() &#123; _fun_callbacks[MSG_HELLO_WORD] = std::bind(&amp;LogicSystem::HelloWordCallBack, this, placeholders::_1, placeholders::_2, placeholders::_3);&#125; MSG_HELLO_WORD定义在const.h中 123enum MSG_IDS &#123; MSG_HELLO_WORD = 1001&#125;; MSG_HELLO_WORD表示消息id，HelloWordCallBack为对应的回调处理函数 12345678910void LogicSystem::HelloWordCallBack(shared_ptr&lt;CSession&gt; session, short msg_id, string msg_data) &#123; Json::Reader reader; Json::Value root; reader.parse(msg_data, root); std::cout &lt;&lt; &quot;recevie msg id is &quot; &lt;&lt; root[&quot;id&quot;].asInt() &lt;&lt; &quot; msg data is &quot; &lt;&lt; root[&quot;data&quot;].asString() &lt;&lt; endl; root[&quot;data&quot;] = &quot;server has received msg, msg data is &quot; + root[&quot;data&quot;].asString(); std::string return_str = root.toStyledString(); session-&gt;Send(return_str, root[&quot;id&quot;].asInt());&#125; 在HelloWordCallBack里我们根据消息id和收到的消息，做了相应的处理并且回应给客户端。 工作线程的处理函数DealMsg逻辑 1234567891011121314151617181920212223242526272829303132333435363738void LogicSystem::DealMsg() &#123; for (;;) &#123; std::unique_lock&lt;std::mutex&gt; unique_lk(_mutex); //判断队列为空则用条件变量阻塞等待，并释放锁 while (_msg_que.empty() &amp;&amp; !_b_stop) &#123; _consume.wait(unique_lk); &#125; //判断是否为关闭状态，把所有逻辑执行完后则退出循环 if (_b_stop ) &#123; while (!_msg_que.empty()) &#123; auto msg_node = _msg_que.front(); cout &lt;&lt; &quot;recv_msg id is &quot; &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; endl; auto call_back_iter = _fun_callbacks.find(msg_node-&gt;_recvnode-&gt;_msg_id); if (call_back_iter == _fun_callbacks.end()) &#123; _msg_que.pop(); continue; &#125; call_back_iter-&gt;second(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id, std::string(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len)); _msg_que.pop(); &#125; break; &#125; //如果没有停服，且说明队列中有数据 auto msg_node = _msg_que.front(); cout &lt;&lt; &quot;recv_msg id is &quot; &lt;&lt; msg_node-&gt;_recvnode-&gt;_msg_id &lt;&lt; endl; auto call_back_iter = _fun_callbacks.find(msg_node-&gt;_recvnode-&gt;_msg_id); if (call_back_iter == _fun_callbacks.end()) &#123; _msg_que.pop(); continue; &#125; call_back_iter-&gt;second(msg_node-&gt;_session, msg_node-&gt;_recvnode-&gt;_msg_id, std::string(msg_node-&gt;_recvnode-&gt;_data, msg_node-&gt;_recvnode-&gt;_cur_len)); _msg_que.pop(); &#125;&#125; 1 &emsp; DealMsg逻辑中初始化了一个unique_lock，主要是用来控制队列安全，并且配合条件变量可以随时解锁。lock_guard不具备解锁功能，所以此处用unique_lock。2 &emsp; 我们判断队列为空，并且不是停止状态，就挂起线程。否则继续执行之后的逻辑，如果_b_stop为true，说明处于停服状态，则将队列中未处理的消息全部处理完然后退出循环。如果_b_stop未false，则说明没有停服，是consumer发送的激活信号激活了线程，则继续取队列中的数据处理。 LogicSystem的析构函数需要等待工作线程处理完再退出，但是工作线程可能处于挂起状态，所以要发送一个激活信号唤醒工作线程。并且将_b_stop标记设置为true。 12345LogicSystem::~LogicSystem()&#123; _b_stop = true; _consume.notify_one(); _worker_thread.join();&#125; 因为网络层收到消息后我们需要将消息投递给逻辑队列进行处理，那么LogicSystem就要封装一个投递函数 12345678void LogicSystem::PostMsgToQue(shared_ptr &lt; LogicNode&gt; msg) &#123; std::unique_lock&lt;std::mutex&gt; unique_lk(_mutex); _msg_que.push(msg); //由0变为1则发送通知信号 if (_msg_que.size() == 1) &#123; _consume.notify_one(); &#125;&#125; 在Session收到数据时这样调用 1LogicSystem::GetInstance()-&gt;PostMsgToQue(make_shared&lt;LogicNode&gt;(shared_from_this(), _recv_msg_node)); 再次启动服务器，编译启动，和之前一样可以看到数据收发正常。如下图: 总结本文实现了服务器的逻辑类，包括并发控制等手段。 视频连接https://space.bilibili.com/271469206/channel/collectiondetail?sid=313101 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"逻辑层设计和消息完善","date":"2023-06-01T10:45:58.000Z","path":"2023/06/01/asio17/","text":"简介本文概述基于boost::asio实现的服务器逻辑层结构，并且完善之前设计的消息结构。因为为了简化粘包处理，我们简化了发送数据的结构,这次我们给出完整的消息设计，以及服务器架构设计。 服务器架构设计之前我们设计了Session(会话层)，并且给大家讲述了Asio底层的通信过程，如下图 我们接下来要设计的服务器结构是这样的 消息头完善我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。之前我们设计的消息结构是这样的 现在将其完善为如下的样子 为了减少耦合和歧义，我们重新设计消息节点。MsgNode表示消息节点的基类，头部的消息用这个结构存储。RecvNode表示接收消息的节点。SendNode表示发送消息的节点。我们将上述结构定义在MsgNode.h中 123456789101112131415161718192021222324252627282930313233343536class MsgNode&#123;public: MsgNode(short max_len) :_total_len(max_len), _cur_len(0) &#123; _data = new char[_total_len + 1](); _data[_total_len] = &#x27;\\0&#x27;; &#125; ~MsgNode() &#123; std::cout &lt;&lt; &quot;destruct MsgNode&quot; &lt;&lt; endl; delete[] _data; &#125; void Clear() &#123; ::memset(_data, 0, _total_len); _cur_len = 0; &#125; short _cur_len; short _total_len; char* _data;&#125;;class RecvNode :public MsgNode &#123;public: RecvNode(short max_len, short msg_id);private: short _msg_id;&#125;;class SendNode:public MsgNode &#123;public: SendNode(const char* msg,short max_len, short msg_id);private: short _msg_id;&#125;; 实现如下 1234567891011121314151617#include &quot;MsgNode.h&quot;RecvNode::RecvNode(short max_len, short msg_id):MsgNode(max_len),_msg_id(msg_id)&#123;&#125;SendNode::SendNode(const char* msg, short max_len, short msg_id):MsgNode(max_len + HEAD_TOTAL_LEN), _msg_id(msg_id)&#123; //先发送id, 转为网络字节序 short msg_id_host = boost::asio::detail::socket_ops::host_to_network_short(msg_id); memcpy(_data, &amp;msg_id_host, HEAD_ID_LEN); //转为网络字节序 short max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len); memcpy(_data + HEAD_ID_LEN, &amp;max_len_host, HEAD_DATA_LEN); memcpy(_data + HEAD_ID_LEN + HEAD_DATA_LEN, msg, max_len);&#125; SendNode发送节点构造时，先将id转为网络字节序，然后写入_data数据域。然后将要发送数据的长度转为大端字节序，写入_data数据域，注意要偏移HEAD_ID_LEN长度。最后将要发送的数据msg写入_data数据域，注意要偏移HEAD_ID_LEN+HEAD_DATA_LEN Session类改写因为消息结构改变了，所以我们接收和发送数据的逻辑要做对应的修改，我们先修改Session类中收发消息结构如下 1234567std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;std::mutex _send_lock;//收到的消息结构std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;bool _b_head_parse;//收到的头部结构std::shared_ptr&lt;MsgNode&gt; _recv_head_node; 因为头部数据只为4字节，所以我们在Session的构造函数中创建头部节点时选择HEAD_TOTAL_LEN(4字节)大小。 123456CSession::CSession(boost::asio::io_context&amp; io_context, CServer* server): _socket(io_context), _server(server), _b_close(false),_b_head_parse(false)&#123; boost::uuids::uuid a_uuid = boost::uuids::random_generator()(); _uuid = boost::uuids::to_string(a_uuid); _recv_head_node = make_shared&lt;MsgNode&gt;(HEAD_TOTAL_LEN);&#125; 发送时我们构造发送节点，放到队列中即可 12345678910111213141516void CSession::Send(char* msg, short max_length, short msgid) &#123; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); int send_que_size = _send_que.size(); if (send_que_size &gt; MAX_SENDQUE) &#123; std::cout &lt;&lt; &quot;session: &quot; &lt;&lt; _uuid &lt;&lt; &quot; send que fulled, size is &quot; &lt;&lt; MAX_SENDQUE &lt;&lt; endl; return; &#125; _send_que.push(make_shared&lt;SendNode&gt;(msg, max_length, msgid)); if (send_que_size&gt;0) &#123; return; &#125; auto&amp; msgnode = _send_que.front(); boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_total_len), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, SharedSelf()));&#125; 当然我们也实现了一个重载版本 12345678910111213141516void CSession::Send(std::string msg, short msgid) &#123; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); int send_que_size = _send_que.size(); if (send_que_size &gt; MAX_SENDQUE) &#123; std::cout &lt;&lt; &quot;session: &quot; &lt;&lt; _uuid &lt;&lt; &quot; send que fulled, size is &quot; &lt;&lt; MAX_SENDQUE &lt;&lt; endl; return; &#125; _send_que.push(make_shared&lt;SendNode&gt;(msg.c_str(), msg.length(), msgid)); if (send_que_size &gt; 0) &#123; return; &#125; auto&amp; msgnode = _send_que.front(); boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_total_len), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, SharedSelf()));&#125; 在接收数据时我们解析头部也要解析id字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136void CSession::HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)&#123; try &#123; if (!error) &#123; //已经移动的字符数 int copy_len = 0; while (bytes_transferred &gt; 0) &#123; if (!_b_head_parse) &#123; //收到的数据不足头部大小 if (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LEN) &#123; memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred); _recv_head_node-&gt;_cur_len += bytes_transferred; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; //收到的数据比头部多 //头部剩余未复制的长度 int head_remain = HEAD_TOTAL_LEN - _recv_head_node-&gt;_cur_len; memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain); //更新已处理的data长度和剩余未处理的长度 copy_len += head_remain; bytes_transferred -= head_remain; //获取头部MSGID数据 short msg_id = 0; memcpy(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN); //网络字节序转化为本地字节序 msg_id = boost::asio::detail::socket_ops::network_to_host_short(msg_id); std::cout &lt;&lt; &quot;msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; //id非法 if (msg_id &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return; &#125; short msg_len = 0; memcpy(&amp;msg_len, _recv_head_node-&gt;_data+HEAD_ID_LEN, HEAD_DATA_LEN); //网络字节序转化为本地字节序 msg_len = boost::asio::detail::socket_ops::network_to_host_short(msg_len); std::cout &lt;&lt; &quot;msg_len is &quot; &lt;&lt; msg_len &lt;&lt; endl; //id非法 if (msg_len &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; msg_len &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return; &#125; _recv_msg_node = make_shared&lt;RecvNode&gt;(msg_len, msg_id); //消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里 if (bytes_transferred &lt; msg_len) &#123; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred); _recv_msg_node-&gt;_cur_len += bytes_transferred; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); //头部处理完成 _b_head_parse = true; return; &#125; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len); _recv_msg_node-&gt;_cur_len += msg_len; copy_len += msg_len; bytes_transferred -= msg_len; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; //cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //此处可以调用Send发送测试 Json::Reader reader; Json::Value root; reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root); std::cout &lt;&lt; &quot;recevie msg id is &quot; &lt;&lt; root[&quot;id&quot;].asInt() &lt;&lt; &quot; msg data is &quot; &lt;&lt; root[&quot;data&quot;].asString() &lt;&lt; endl; root[&quot;data&quot;] = &quot;server has received msg, msg data is &quot; + root[&quot;data&quot;].asString(); std::string return_str = root.toStyledString(); Send(return_str, root[&quot;id&quot;].asInt()); //继续轮询剩余未处理数据 _b_head_parse = false; _recv_head_node-&gt;Clear(); if (bytes_transferred &lt;= 0) &#123; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; continue; &#125; //已经处理完头部，处理上次未接受完的消息数据 //接收的数据仍不足剩余未处理的 int remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len; if (bytes_transferred &lt; remain_msg) &#123; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred); _recv_msg_node-&gt;_cur_len += bytes_transferred; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg); _recv_msg_node-&gt;_cur_len += remain_msg; bytes_transferred -= remain_msg; copy_len += remain_msg; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; //cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //此处可以调用Send发送测试 Json::Reader reader; Json::Value root; reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root); std::cout &lt;&lt; &quot;recevie msg id is &quot; &lt;&lt; root[&quot;id&quot;].asInt() &lt;&lt; &quot; msg data is &quot; &lt;&lt; root[&quot;data&quot;].asString() &lt;&lt; endl; root[&quot;data&quot;] = &quot;server has received msg, msg data is &quot; + root[&quot;data&quot;].asString(); std::string return_str = root.toStyledString(); Send(return_str, root[&quot;id&quot;].asInt()); //继续轮询剩余未处理数据 _b_head_parse = false; _recv_head_node-&gt;Clear(); if (bytes_transferred &lt;= 0) &#123; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; continue; &#125; &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); &#125; &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception code is &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125; 先解析头部id，再解析长度，然后根据id和长度构造消息节点，copy剩下的消息体, 把上面代码中处理消息头的逻辑截取如下 1234567891011121314151617181920212223242526 //获取头部MSGID数据short msg_id = 0;memcpy(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);//网络字节序转化为本地字节序msg_id = boost::asio::detail::socket_ops::network_to_host_short(msg_id);std::cout &lt;&lt; &quot;msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl;//id非法if (msg_id &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid msg_id is &quot; &lt;&lt; msg_id &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return;&#125; short msg_len = 0;memcpy(&amp;msg_len, _recv_head_node-&gt;_data+HEAD_ID_LEN, HEAD_DATA_LEN);//网络字节序转化为本地字节序msg_len = boost::asio::detail::socket_ops::network_to_host_short(msg_len);std::cout &lt;&lt; &quot;msg_len is &quot; &lt;&lt; msg_len &lt;&lt; endl;//id非法if (msg_len &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; msg_len &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return;&#125;_recv_msg_node = make_shared&lt;RecvNode&gt;(msg_len, msg_id); 其余的没什么变动。 总结本文介绍了服务器逻辑和网络层的设计，并且基于这个架构，完善了消息发送结构，下一篇带着大家设计逻辑类和逻辑队列。 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"windows配置和使用grpc","date":"2023-05-31T10:41:39.000Z","path":"2023/05/31/asio16/","text":"简介本文主要讲述如何在Windows环境下使用visual studio配置grpc，并且实现grpc通信的例子。前文windows配置和编译grpc已经介绍了如何在windows环境配置grpc，接下来我们利用之前编译好的库配置到项目中，并实现grpc通信。 项目配置我们为了方便配置，将之前下载和编译好的项目放在D盘cppsoft文件夹下，路径为D:\\cppsoft\\grpc。 接下来我们创建一个项目，名字叫Grpc-Server,在项目的根目录下创建一个proto名字为demo.proto 123456789101112131415syntax = &quot;proto3&quot;;package hello;service Greeter &#123; rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125;message HelloRequest &#123; string message = 1;&#125;message HelloReply &#123; string message = 1;&#125; 接下来我们利用grpc编译后生成的proc.exe生成proto的头文件和源文件 1D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe -I=&quot;.&quot; --grpc_out=&quot;.&quot; --plugin=protoc-gen-grpc=&quot;D:\\cppsoft\\grpc\\visualpro\\Debug\\grpc_cpp_plugin.exe&quot; &quot;demo.proto&quot; 上述命令会生成demo.grpc.pb.h和demo.grpc.pb.cc文件。 D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe 表示protoc.exe所在的路径，你可以将其放在指定目录并配置环境变量，直接使用protoc.exe就行了。 -I=&quot;.&quot; 指定 demo.proto所在的路径为当前路径。 --grpc_out=&quot;.&quot; 表示生成的pb.h和pb.cc文件的输出目录。 --plugin=protoc-gen-grpc=&quot;D:\\cppsoft\\grpc\\visualpro\\Debug\\grpc_cpp_plugin.exe&quot;表示要使用的插件为cpp插件，也就是生成cpp类的头文件和源文件。 接下来我们生成grpc类需要的pb文件，因为要序列化数据。 1D:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\Debug\\protoc.exe --cpp_out=. &quot;demo.proto&quot; 上述命令会生成demo.pb.h和demo.pb.cc文件。 接下来我们在项目中配置grpc库的包含目录和库目录。为了方便调试，我们配置debug版本 项目属性中选择C++下的常规选项，在附加包含目录中添加我们grpc生成debug库 这里列举下要包含的目录 12345D:\\workspace\\github\\grpc\\third_party\\re2D:\\workspace\\github\\grpc\\third_party\\address_sorting\\includeD:\\workspace\\github\\grpc\\third_party\\abseil-cppD:\\workspace\\github\\grpc\\third_party\\protobuf\\srcD:\\workspace\\github\\grpc\\include 接下来配置库路径, 在链接器常规选项下，点击附加库目录，添加我们需要的库目录。 同样，我们配置的是debug版本 要配置的库目录很多，这里详细列举一下 123456789101112131415161718D:\\cppsoft\\grpc\\visualpro\\third_party\\re2\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\types\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\synchronization\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\status\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\random\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\flags\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\debugging\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\container\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\hash\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\boringssl-with-bazel\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\numeric\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\time\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\base\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\abseil-cpp\\absl\\strings\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\protobuf\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\zlib\\DebugD:\\cppsoft\\grpc\\visualpro\\DebugD:\\cppsoft\\grpc\\visualpro\\third_party\\cares\\cares\\lib\\Debug 另外，我们虽然配置了库目录，但还要将要使用的库链接到项目在链接器输入选项下，点击附加依赖项添加依赖的库名字 库配置 库名字列举如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667libprotobufd.libgpr.libgrpc.libgrpc++.libgrpc++_reflection.libaddress_sorting.libws2_32.libcares.libzlibstaticd.libupb.libssl.libcrypto.libabsl_bad_any_cast_impl.libabsl_bad_optional_access.libabsl_bad_variant_access.libabsl_base.libabsl_city.libabsl_civil_time.libabsl_cord.libabsl_debugging_internal.libabsl_demangle_internal.libabsl_examine_stack.libabsl_exponential_biased.libabsl_failure_signal_handler.libabsl_flags.libabsl_flags_config.libabsl_flags_internal.libabsl_flags_marshalling.libabsl_flags_parse.libabsl_flags_program_name.libabsl_flags_usage.libabsl_flags_usage_internal.libabsl_graphcycles_internal.libabsl_hash.libabsl_hashtablez_sampler.libabsl_int128.libabsl_leak_check.libabsl_leak_check_disable.libabsl_log_severity.libabsl_malloc_internal.libabsl_periodic_sampler.libabsl_random_distributions.libabsl_random_internal_distribution_test_util.libabsl_random_internal_pool_urbg.libabsl_random_internal_randen.libabsl_random_internal_randen_hwaes.libabsl_random_internal_randen_hwaes_impl.libabsl_random_internal_randen_slow.libabsl_random_internal_seed_material.libabsl_random_seed_gen_exception.libabsl_random_seed_sequences.libabsl_raw_hash_set.libabsl_raw_logging_internal.libabsl_scoped_set_env.libabsl_spinlock_wait.libabsl_stacktrace.libabsl_status.libabsl_strings.libabsl_strings_internal.libabsl_str_format_internal.libabsl_symbolize.libabsl_synchronization.libabsl_throw_delegate.libabsl_time.libabsl_time_zone.libabsl_statusor.libre2.lib grpc服务器接下来我们写代码，实现grpc服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;grpcpp/grpcpp.h&gt;#include &quot;demo.grpc.pb.h&quot;using grpc::Server;using grpc::ServerBuilder;using grpc::ServerContext;using grpc::Status;using hello::HelloRequest;using hello::HelloReply;using hello::Greeter;// Logic and data behind the server&#x27;s behavior.class GreeterServiceImpl final : public Greeter::Service &#123; Status SayHello(ServerContext* context, const HelloRequest* request, HelloReply* reply) override &#123; std::string prefix(&quot;llfc grpc server has received : &quot;); reply-&gt;set_message(prefix + request-&gt;message()); return Status::OK; &#125;&#125;;void RunServer() &#123; std::string server_address(&quot;127.0.0.1:50051&quot;); GreeterServiceImpl service; ServerBuilder builder; // Listen on the given address without any authentication mechanism. // 监听给定的地址 builder.AddListeningPort(server_address, grpc::InsecureServerCredentials()); // Register &quot;service&quot; as the instance through which we&#x27;ll communicate with // clients. In this case it corresponds to an *synchronous* service. builder.RegisterService(&amp;service); // Finally assemble the server. std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart()); std::cout &lt;&lt; &quot;Server listening on &quot; &lt;&lt; server_address &lt;&lt; std::endl; // Wait for the server to shutdown. Note that some other thread must be // responsible for shutting down the server for this call to ever return. server-&gt;Wait();&#125;int main(int argc, char** argv) &#123; RunServer(); return 0;&#125; GreeterServiceImpl 继承自 Greeter::Service，重写了SayHello函数，当收到客户端发送的SayHello请求后执行重写函数功能的逻辑。 grpc客户端grpc客户端比较简单，直接调用发送接口发送数据即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;grpcpp/grpcpp.h&gt;#include &quot;demo.grpc.pb.h&quot;using grpc::ClientContext;using grpc::Channel;using grpc::Status;using hello::HelloReply;using hello::HelloRequest;using hello::Greeter;// static method : Greeter::NewStubclass FCClient &#123;public: FCClient(std::shared_ptr&lt;Channel&gt; channel) :stub_(Greeter::NewStub(channel)) &#123; &#125; std::string SayHello(std::string name) &#123; ClientContext context; HelloReply reply; HelloRequest request; request.set_message(name); Status status = stub_-&gt;SayHello(&amp;context, request, &amp;reply); if (status.ok()) &#123; return reply.message(); &#125; else &#123; return &quot;failure &quot; + status.error_message(); &#125; &#125;private: std::unique_ptr&lt;Greeter::Stub&gt; stub_;&#125;;int main(int argc, char* argv[]) &#123; auto channel = grpc::CreateChannel(&quot;127.0.0.1:50051&quot;, grpc::InsecureChannelCredentials()); FCClient client(channel); // block until get result from RPC server std::string result = client.SayHello(&quot;hello , llfc.club !&quot;); printf(&quot;get result [%s]\\n&quot;, result.c_str()); return 0;&#125; 客户端创建了一个channel，然后调用NewStub生成stub，接下来就可以发送数据了，下面是运行的效果 总结本文介绍了grpc在windows环境下的配置和使用 源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"QT 实现电子相册(六)--总结","date":"2023-05-29T07:44:35.000Z","path":"2023/05/29/qt27/","text":"简介前面几篇的讲解，我们已经完成QT电子相册的开发，这里做一个总结，说明各个类的功能，以及关联和使用情况。 类功能介绍QMainWindow该类主要用来管理主窗口，包括菜单的显示与交互等。基本功能包括:1 &emsp; 主界面显示为左侧的文件列表框和右侧的图片展示区，其内部包含目录树类和图片展示类的指针。2 &emsp; 显示菜单项并将菜单项与点击逻辑关联。3 &emsp; 支持打开和创建项目操作。4 &emsp; 通过map管理所有创建或打开的项目，对于创建项目时，采取的是建立指定文件夹，对于打开项目时，直接打开指定的文件夹。 向导类Wizard当我们创建项目时，会按步骤提示用户操作，需要用到向导类。该类继承于QWizard，重写了done函数，保证用户操作完成时发送SigProSettings信号给目录树类ProTree。向导类内部包含了两个向导页，一个是项目属性设置页面ProSetPage,一个是确认页面ConfirmPage。ProSetPage页面可以输入项目名称和路径，也支持打开文件夹自动录入路径功能。同时支持录入过程中检测输入是否合法，包括路径是否已经存在，项目名称是否已经存在等。这部分功能通过重写isComplete函数实现逻辑判断。ConfirmPage用来确认用户操作，用户可以选择取消，如果取消则中止创建项目流程。 目录树ProTree类该类主要控制主界面左侧显示目录树，包括基于目录树的一些操作，功能包括如下 1 &emsp; 接收向导类的SigProSettings信号，将项目添加至左侧目录区。2 &emsp; 支持导入文件操作，右键项目名称在弹出菜单选择导入文件会弹出导入文件夹对话框，选择要导入的文件即可。3 &emsp; 设置活动项目，设置为活动项目的条目会被指定为默认选中的项目，项目处于高亮并字体变粗。4 &emsp; 轮播图播放，当点击轮播图播放时会依次播放目录树下的每张图片。5 &emsp; ProTree类内部管理了ui文件，ui文件中QTreeWidget被升级为我们自定义的ProTreeWidget类型。进而支持上述菜单操作。成员函数和变量介绍：1 &emsp; Ui::ProTree *ui 表示ProTree的ui类。2 &emsp; AddProToTree 该函数和主界面发送的SigProSettings信号连接，在左侧创建目录文件夹。3 &emsp; GetTreeWidget 该函数返回ui内管理的ProTreeWidget对象的指针。 目录树ui类ProTreeWidget该类继承于QTreeWidget类，用于实现目录列表，该类放在ProTree的ui文件里，将QTreeWidget升级为该类型，同时也可以响应主窗口发送过来的打开项目和创建项目信号。其功能包括如下： 1 &emsp; 包括一个集合_set_path，防止重复导入相同项目，规则为根据路径和项目名组合生成的字符串是否已经在集合中，如果在则不插入目录树。2 &emsp; 支持右键点击item，生成弹出菜单，菜单包括导入文件，关闭项目，幻灯片放映以及设为启动项目等菜单项。3 &emsp; 根据主界面发送的导入或创建项目信号，执行导入逻辑和创建逻辑。因为导入和创建逻辑会占用cpu，为提升性能，启动导入线程OpenTreeThread和创建线程ProTreeThread。4 &emsp; 导入和创建项目时更新进度条对话框5 &emsp; 支持中途取消导入和创建项目。6 &emsp; 支持双击条目显示图片，支持点击右侧显示区的切换按钮进行切换图片。7 &emsp; 支持处理主界面发送的设置音乐请求 类成员说明如下:1 &emsp; _set_path缓存目录树中的项目名。2 &emsp; _action_import导入文件动作。3 &emsp; _action_setstart设置活动项动作。4 &emsp; _action_closepro关闭项目动作。5 &emsp; SlotItemPressed右键点击的槽函数弹出菜单。6 &emsp; _right_btn_item 缓存右键点击的item项。7 &emsp; _active_item 缓存设置的启动项。8 &emsp; _dialog_progress 导入文件时现实的进度对话框。 ProTreeThread类该类继承自QThread，因为创建项目后，导入图片文件时耗时较长，所以启动这个线程。该线程响应外界的中止消息，并根据copy文件的进度向进度对话框通知进度。类成员说明如下1 &emsp; _src_path文件源路径。2 &emsp; _dist_path文件目的路径。3 &emsp; _file_count表示已经复制的文件数4 &emsp; 拷贝生成的目录树的当前节点的父节点。5 &emsp; _root表示拷贝生成的目录树的根节点。6 &emsp; _bstop表示是否停止。7 &emsp; SigUpdateProgress表示更新进度的信号8 &emsp; SigFinishProgress表示完成的信号。 OpenTreeThread类OpenTreeThread 和ProTreeThread类似，所以不再赘述。 PicAnimationWid类动画类，当点击左侧目录树选择播放幻灯片时，PicAnimationWid类负责播放动画。主要类成员和功能如下：1 &emsp; SetPixmap函数设置图片，设置当前播放和即将播放的图片。2 &emsp; UpSelectPixmap 当点击左侧目录树item或者点击下方预览图时会触发该函数，用来更新播放的图片，进而切换播放的图片。3 &emsp; paintEvent重写了喷绘函数，实现双缓冲绘图，播放第一张图片alpha为255，第二章图片alpha为0，然后慢慢将第一张alpha变为0，第二张变为255，进而实现图片的渐隐渐显效果。4 &emsp; SlotStartOrStop 启动或停止动画的槽函数。5 &emsp; SlideNext,SlidePre向前和向后切换动画的槽函数。6 &emsp; TimeOut定时切换图片的槽函数。 PicShow类PicShow类主要是管理右侧显示区域的。包括点击按钮的渐变变化，以及切换图片的显示功能。1 &emsp; ShowPreNextBtns用来实现按钮渐渐显示效果。2 &emsp; SlotUpdatePic更新显示的图片。3 &emsp; SlotSelectItem更新选中的item。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"windows配置和编译grpc","date":"2023-05-28T05:56:35.000Z","path":"2023/05/28/asio15/","text":"grpc简介gRPC是Google开发的一种高性能、开源的远程过程调用（RPC）框架。它可以让客户端应用程序像调用本地服务一样轻松地调用远程服务，并提供了多种语言的支持，如C++、Java、Python、Go等。 gRPC使用Protocol Buffers作为数据格式，可以在不同的平台上进行应用程序之间的通信，支持多种编程语言和多种操作系统。它采用基于HTTP/2的协议，提供了高效、快速且可扩展的远程调用功能，并带有负载均衡、认证、监控等功能，方便用户管理和维护分布式系统。 gRPC可用于构建各种类型的分布式应用程序，如微服务、云原生应用程序、大规模Web应用程序、移动应用程序等场景。由于其高性能和可扩展性，越来越多的企业和组织开始采用gRPC来构建他们的应用程序和服务。 grpc下载由于国内环境，grpc下载极其困难，grpc项目在github上，源码地址为https://github.com/grpc/grpc,我们可以通过如下命令克隆grpc源码进行编译 12git clone https://github.com/grpc/grpc.git git submodule update --init 但是国内网络环境执行submodule update时会失败,所以可以用国内的代码管理工具gitee进行克隆。注意,目前在Gitee上只能找到gRPC依赖的部分”官方”镜像仓库,网友提供的镜像仓库较旧,因而只能构造v1.34.0版本.通过上述指令可以将v1.34.0版本的gRPC代码下载到grpc目录.我们选择一个稳定的分支进行克隆 1git clone -b v1.34.0 https://gitee.com/mirrors/grpc-framework.git grpc 克隆之后，我们进入grpc文件夹，修改.gitmodules内仓库地址，修改前.gitmodules内容是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[submodule &quot;third_party/zlib&quot;] path = third_party/zlib #url = https://github.com/madler/zlib url = https://gitee.com/mirrors/zlib.git # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty[submodule &quot;third_party/protobuf&quot;] path = third_party/protobuf #url = https://github.com/google/protobuf.git url = https://gitee.com/local-grpc/protobuf.git[submodule &quot;third_party/googletest&quot;] path = third_party/googletest #url = https://github.com/google/googletest.git url = https://gitee.com/local-grpc/googletest.git[submodule &quot;third_party/benchmark&quot;] path = third_party/benchmark #url = https://github.com/google/benchmark url = https://gitee.com/mirrors/google-benchmark.git[submodule &quot;third_party/boringssl-with-bazel&quot;] path = third_party/boringssl-with-bazel #url = https://github.com/google/boringssl.git url = https://gitee.com/mirrors/boringssl.git[submodule &quot;third_party/re2&quot;] path = third_party/re2 #url = https://github.com/google/re2.git url = https://gitee.com/local-grpc/re2.git[submodule &quot;third_party/cares/cares&quot;] path = third_party/cares/cares #url = https://github.com/c-ares/c-ares.git url = https://gitee.com/mirrors/c-ares.git branch = cares-1_12_0[submodule &quot;third_party/bloaty&quot;] path = third_party/bloaty #url = https://github.com/google/bloaty.git url = https://gitee.com/local-grpc/bloaty.git[submodule &quot;third_party/abseil-cpp&quot;] path = third_party/abseil-cpp #url = https://github.com/abseil/abseil-cpp.git url = https://gitee.com/mirrors/abseil-cpp.git branch = lts_2020_02_25[submodule &quot;third_party/envoy-api&quot;] path = third_party/envoy-api #url = https://github.com/envoyproxy/data-plane-api.git url = https://gitee.com/local-grpc/data-plane-api.git[submodule &quot;third_party/googleapis&quot;] path = third_party/googleapis #url = https://github.com/googleapis/googleapis.git url = https://gitee.com/mirrors/googleapis.git[submodule &quot;third_party/protoc-gen-validate&quot;] path = third_party/protoc-gen-validate #url = https://github.com/envoyproxy/protoc-gen-validate.git url = https://gitee.com/local-grpc/protoc-gen-validate.git[submodule &quot;third_party/udpa&quot;] path = third_party/udpa #url = https://github.com/cncf/udpa.git url = https://gitee.com/local-grpc/udpa.git[submodule &quot;third_party/libuv&quot;] path = third_party/libuv #url = https://github.com/libuv/libuv.git url = https://gitee.com/mirrors/libuv.git gRPC的依赖是通过git的submodules来关联的,代码下载下来之后可以看到.gitmodules文件,内部的git仓库地址都需要替换成Gitee的,例如: 1234567[submodule &quot;third_party/zlib&quot;] path = third_party/zlib url = https://github.com/madler/zlib # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty 使用了zlib,在Gitee上搜索其代码仓库为https://gitee.com/mirrors/zlib,可以使用如下指令clone: 1git clone https://gitee.com/mirrors/zlib.git 因而替换成: 12345678[submodule &quot;third_party/zlib&quot;] path = third_party/zlib #url = https://github.com/madler/zlib url = https://gitee.com/mirrors/zlib.git # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty 通过这种方法可以找到部分依赖库的最新镜像仓库,但是有一些找不到最新的,例如protobuf等库,用户local-grpc提供了gRPC依赖的全部代码仓库,可以使用这些仓库(注意代码不是同步镜像,导致gRPC只能构造相应版本),其中protobuf链接为: 1https://gitee.com/local-grpc/protobuf.git 这里将.gitmodules修改为如下内容即可: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[submodule &quot;third_party/zlib&quot;] path = third_party/zlib #url = https://github.com/madler/zlib url = https://gitee.com/mirrors/zlib.git # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty[submodule &quot;third_party/protobuf&quot;] path = third_party/protobuf #url = https://github.com/google/protobuf.git url = https://gitee.com/local-grpc/protobuf.git[submodule &quot;third_party/googletest&quot;] path = third_party/googletest #url = https://github.com/google/googletest.git url = https://gitee.com/local-grpc/googletest.git[submodule &quot;third_party/benchmark&quot;] path = third_party/benchmark #url = https://github.com/google/benchmark url = https://gitee.com/mirrors/google-benchmark.git[submodule &quot;third_party/boringssl-with-bazel&quot;] path = third_party/boringssl-with-bazel #url = https://github.com/google/boringssl.git url = https://gitee.com/mirrors/boringssl.git[submodule &quot;third_party/re2&quot;] path = third_party/re2 #url = https://github.com/google/re2.git url = https://gitee.com/local-grpc/re2.git[submodule &quot;third_party/cares/cares&quot;] path = third_party/cares/cares #url = https://github.com/c-ares/c-ares.git url = https://gitee.com/mirrors/c-ares.git branch = cares-1_12_0[submodule &quot;third_party/bloaty&quot;] path = third_party/bloaty #url = https://github.com/google/bloaty.git url = https://gitee.com/local-grpc/bloaty.git[submodule &quot;third_party/abseil-cpp&quot;] path = third_party/abseil-cpp #url = https://github.com/abseil/abseil-cpp.git url = https://gitee.com/mirrors/abseil-cpp.git branch = lts_2020_02_25[submodule &quot;third_party/envoy-api&quot;] path = third_party/envoy-api #url = https://github.com/envoyproxy/data-plane-api.git url = https://gitee.com/local-grpc/data-plane-api.git[submodule &quot;third_party/googleapis&quot;] path = third_party/googleapis #url = https://github.com/googleapis/googleapis.git url = https://gitee.com/mirrors/googleapis.git[submodule &quot;third_party/protoc-gen-validate&quot;] path = third_party/protoc-gen-validate #url = https://github.com/envoyproxy/protoc-gen-validate.git url = https://gitee.com/local-grpc/protoc-gen-validate.git[submodule &quot;third_party/udpa&quot;] path = third_party/udpa #url = https://github.com/cncf/udpa.git url = https://gitee.com/local-grpc/udpa.git[submodule &quot;third_party/libuv&quot;] path = third_party/libuv #url = https://github.com/libuv/libuv.git url = https://gitee.com/mirrors/libuv.git 使用如下指令拉取gRPC所有依赖: 12cd grpcgit submodule update --init 编译grpcCMake安装为了编译grpc，我们需要下载cmake，cmake是一个跨平台编译工具，在之前我们编译protobuf时已经下载过了，这里再次介绍一下CMake是一个跨平台的开源构建工具，可以用于自动化构建、测试和打包C++代码。与其他构建工具相比，CMake的优点之一是它的配置文件具有可读性和可维护性，而且支持多种编译器、操作系统和构建工具。 我们要在windows上生成protobuf对应的库，就需要用到cmake。官方下载地址https://cmake.org/download/， 选择Windows Source下载。由于官方下载较慢，可以去我的网盘下载https://pan.baidu.com/s/1Yg9Usdc3T-CYhyr9GiePCw?pwd=ng6x 验证码ng6x NASM编译grpc需要准备nasm,所以也要下载nasm, 下载地址为https://www.nasm.us/,点击下载指定版本，安装即可，记得安装后把安装的路径配置在环境变量里，我的装载了C盘环境变量配置如下 有部分博主说要安装go和perl，我感觉不需要，但是我的电脑里确实有开发环境，这里还是告诉大家如何安装go和Perl Go安装windows环境下下载go，地址https://studygolang.com/dl。选择我们对应系统的安装包下载即可。一路下载安装，最后go会自动写入我们的环境变量。Linux可以选择手动安装二进制包再配置环境变量。安装好后，因为go的库包默认在外网，下载很慢，所以要切换代理 1go env -w GOPROXY=https://goproxy.cn,direct # 设置代理，国内网络开启 Perl安装Perl安装可以去官网下载https://www.activestate.com/products/perl/，并按照提示一步步安装，也可以去网盘下载，直接安装，网盘地址https://pan.baidu.com/s/1i3GLKAp 编译grpc接下来我们需要用CMake编译grpc来生成我们需要的visual studio 项目 1是grpc源码目录2是grpc生成的visual studio项目目录3 是我们要生成哪些项目。 我们先点击啊config进行配置，此时弹出对话框，我的visual studio版本是2019的， 所以我选择编译生成visual studio2019的工程。接下来点击generate生成项目，大约几分钟可以生成，生成成功后我们点击open project打开工程，此时就是用visual sutido 2019打开grpc工程了。接下来我们设置编译平台为64位，选择Debug模式，这里大家尽量编译Release版，Release版压缩的更好一点。选择All项目进行全量编译，编译后就可以在Debug或Release文件夹找到对应生成的库文件和exe了。 总结本文介绍了windows环境下如何配置grpc项目和编译生成我们需要的库。如果大家还是不能顺利生成编译所需的库，可以用我的，这个源码在linux和windows都能用，源码包括第三方库都下载好了，网盘地址：https://pan.baidu.com/s/1BBaAZ8-R-GSxxcy2s7TRWA?pwd=ybno提取码：ybno","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 全栈聊天项目(6) Beast实现http post请求处理","date":"2023-05-28T05:56:35.000Z","path":"2023/05/28/cpppro6/","text":"grpc简介gRPC是Google开发的一种高性能、开源的远程过程调用（RPC）框架。它可以让客户端应用程序像调用本地服务一样轻松地调用远程服务，并提供了多种语言的支持，如C++、Java、Python、Go等。 gRPC使用Protocol Buffers作为数据格式，可以在不同的平台上进行应用程序之间的通信，支持多种编程语言和多种操作系统。它采用基于HTTP/2的协议，提供了高效、快速且可扩展的远程调用功能，并带有负载均衡、认证、监控等功能，方便用户管理和维护分布式系统。 gRPC可用于构建各种类型的分布式应用程序，如微服务、云原生应用程序、大规模Web应用程序、移动应用程序等场景。由于其高性能和可扩展性，越来越多的企业和组织开始采用gRPC来构建他们的应用程序和服务。 grpc下载由于国内环境，grpc下载极其困难，grpc项目在github上，源码地址为https://github.com/grpc/grpc,我们可以通过如下命令克隆grpc源码进行编译 12git clone https://github.com/grpc/grpc.git git submodule update --init 但是国内网络环境执行submodule update时会失败,所以可以用国内的代码管理工具gitee进行克隆。注意,目前在Gitee上只能找到gRPC依赖的部分”官方”镜像仓库,网友提供的镜像仓库较旧,因而只能构造v1.34.0版本.通过上述指令可以将v1.34.0版本的gRPC代码下载到grpc目录.我们选择一个稳定的分支进行克隆 1git clone -b v1.34.0 https://gitee.com/mirrors/grpc-framework.git grpc 克隆之后，我们进入grpc文件夹，修改.gitmodules内仓库地址，修改前.gitmodules内容是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[submodule &quot;third_party/zlib&quot;] path = third_party/zlib #url = https://github.com/madler/zlib url = https://gitee.com/mirrors/zlib.git # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty[submodule &quot;third_party/protobuf&quot;] path = third_party/protobuf #url = https://github.com/google/protobuf.git url = https://gitee.com/local-grpc/protobuf.git[submodule &quot;third_party/googletest&quot;] path = third_party/googletest #url = https://github.com/google/googletest.git url = https://gitee.com/local-grpc/googletest.git[submodule &quot;third_party/benchmark&quot;] path = third_party/benchmark #url = https://github.com/google/benchmark url = https://gitee.com/mirrors/google-benchmark.git[submodule &quot;third_party/boringssl-with-bazel&quot;] path = third_party/boringssl-with-bazel #url = https://github.com/google/boringssl.git url = https://gitee.com/mirrors/boringssl.git[submodule &quot;third_party/re2&quot;] path = third_party/re2 #url = https://github.com/google/re2.git url = https://gitee.com/local-grpc/re2.git[submodule &quot;third_party/cares/cares&quot;] path = third_party/cares/cares #url = https://github.com/c-ares/c-ares.git url = https://gitee.com/mirrors/c-ares.git branch = cares-1_12_0[submodule &quot;third_party/bloaty&quot;] path = third_party/bloaty #url = https://github.com/google/bloaty.git url = https://gitee.com/local-grpc/bloaty.git[submodule &quot;third_party/abseil-cpp&quot;] path = third_party/abseil-cpp #url = https://github.com/abseil/abseil-cpp.git url = https://gitee.com/mirrors/abseil-cpp.git branch = lts_2020_02_25[submodule &quot;third_party/envoy-api&quot;] path = third_party/envoy-api #url = https://github.com/envoyproxy/data-plane-api.git url = https://gitee.com/local-grpc/data-plane-api.git[submodule &quot;third_party/googleapis&quot;] path = third_party/googleapis #url = https://github.com/googleapis/googleapis.git url = https://gitee.com/mirrors/googleapis.git[submodule &quot;third_party/protoc-gen-validate&quot;] path = third_party/protoc-gen-validate #url = https://github.com/envoyproxy/protoc-gen-validate.git url = https://gitee.com/local-grpc/protoc-gen-validate.git[submodule &quot;third_party/udpa&quot;] path = third_party/udpa #url = https://github.com/cncf/udpa.git url = https://gitee.com/local-grpc/udpa.git[submodule &quot;third_party/libuv&quot;] path = third_party/libuv #url = https://github.com/libuv/libuv.git url = https://gitee.com/mirrors/libuv.git gRPC的依赖是通过git的submodules来关联的,代码下载下来之后可以看到.gitmodules文件,内部的git仓库地址都需要替换成Gitee的,例如: 1234567[submodule &quot;third_party/zlib&quot;] path = third_party/zlib url = https://github.com/madler/zlib # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty 使用了zlib,在Gitee上搜索其代码仓库为https://gitee.com/mirrors/zlib,可以使用如下指令clone: 1git clone https://gitee.com/mirrors/zlib.git 因而替换成: 12345678[submodule &quot;third_party/zlib&quot;] path = third_party/zlib #url = https://github.com/madler/zlib url = https://gitee.com/mirrors/zlib.git # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty 通过这种方法可以找到部分依赖库的最新镜像仓库,但是有一些找不到最新的,例如protobuf等库,用户local-grpc提供了gRPC依赖的全部代码仓库,可以使用这些仓库(注意代码不是同步镜像,导致gRPC只能构造相应版本),其中protobuf链接为: 1https://gitee.com/local-grpc/protobuf.git 这里将.gitmodules修改为如下内容即可: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[submodule &quot;third_party/zlib&quot;] path = third_party/zlib #url = https://github.com/madler/zlib url = https://gitee.com/mirrors/zlib.git # When using CMake to build, the zlib submodule ends up with a # generated file that makes Git consider the submodule dirty. This # state can be ignored for day-to-day development on gRPC. ignore = dirty[submodule &quot;third_party/protobuf&quot;] path = third_party/protobuf #url = https://github.com/google/protobuf.git url = https://gitee.com/local-grpc/protobuf.git[submodule &quot;third_party/googletest&quot;] path = third_party/googletest #url = https://github.com/google/googletest.git url = https://gitee.com/local-grpc/googletest.git[submodule &quot;third_party/benchmark&quot;] path = third_party/benchmark #url = https://github.com/google/benchmark url = https://gitee.com/mirrors/google-benchmark.git[submodule &quot;third_party/boringssl-with-bazel&quot;] path = third_party/boringssl-with-bazel #url = https://github.com/google/boringssl.git url = https://gitee.com/mirrors/boringssl.git[submodule &quot;third_party/re2&quot;] path = third_party/re2 #url = https://github.com/google/re2.git url = https://gitee.com/local-grpc/re2.git[submodule &quot;third_party/cares/cares&quot;] path = third_party/cares/cares #url = https://github.com/c-ares/c-ares.git url = https://gitee.com/mirrors/c-ares.git branch = cares-1_12_0[submodule &quot;third_party/bloaty&quot;] path = third_party/bloaty #url = https://github.com/google/bloaty.git url = https://gitee.com/local-grpc/bloaty.git[submodule &quot;third_party/abseil-cpp&quot;] path = third_party/abseil-cpp #url = https://github.com/abseil/abseil-cpp.git url = https://gitee.com/mirrors/abseil-cpp.git branch = lts_2020_02_25[submodule &quot;third_party/envoy-api&quot;] path = third_party/envoy-api #url = https://github.com/envoyproxy/data-plane-api.git url = https://gitee.com/local-grpc/data-plane-api.git[submodule &quot;third_party/googleapis&quot;] path = third_party/googleapis #url = https://github.com/googleapis/googleapis.git url = https://gitee.com/mirrors/googleapis.git[submodule &quot;third_party/protoc-gen-validate&quot;] path = third_party/protoc-gen-validate #url = https://github.com/envoyproxy/protoc-gen-validate.git url = https://gitee.com/local-grpc/protoc-gen-validate.git[submodule &quot;third_party/udpa&quot;] path = third_party/udpa #url = https://github.com/cncf/udpa.git url = https://gitee.com/local-grpc/udpa.git[submodule &quot;third_party/libuv&quot;] path = third_party/libuv #url = https://github.com/libuv/libuv.git url = https://gitee.com/mirrors/libuv.git 使用如下指令拉取gRPC所有依赖: 12cd grpcgit submodule update --init 编译grpcCMake安装为了编译grpc，我们需要下载cmake，cmake是一个跨平台编译工具，在之前我们编译protobuf时已经下载过了，这里再次介绍一下CMake是一个跨平台的开源构建工具，可以用于自动化构建、测试和打包C++代码。与其他构建工具相比，CMake的优点之一是它的配置文件具有可读性和可维护性，而且支持多种编译器、操作系统和构建工具。 我们要在windows上生成protobuf对应的库，就需要用到cmake。官方下载地址https://cmake.org/download/， 选择Windows Source下载。由于官方下载较慢，可以去我的网盘下载https://pan.baidu.com/s/1Yg9Usdc3T-CYhyr9GiePCw?pwd=ng6x 验证码ng6x NASM编译grpc需要准备nasm,所以也要下载nasm, 下载地址为https://www.nasm.us/,点击下载指定版本，安装即可，记得安装后把安装的路径配置在环境变量里，我的装载了C盘环境变量配置如下 有部分博主说要安装go和perl，我感觉不需要，但是我的电脑里确实有开发环境，这里还是告诉大家如何安装go和Perl Go安装windows环境下下载go，地址https://studygolang.com/dl。选择我们对应系统的安装包下载即可。一路下载安装，最后go会自动写入我们的环境变量。Linux可以选择手动安装二进制包再配置环境变量。安装好后，因为go的库包默认在外网，下载很慢，所以要切换代理 1go env -w GOPROXY=https://goproxy.cn,direct # 设置代理，国内网络开启 Perl安装Perl安装可以去官网下载https://www.activestate.com/products/perl/，并按照提示一步步安装，也可以去网盘下载，直接安装，网盘地址https://pan.baidu.com/s/1i3GLKAp 编译grpc接下来我们需要用CMake编译grpc来生成我们需要的visual studio 项目 1是grpc源码目录2是grpc生成的visual studio项目目录3 是我们要生成哪些项目。 我们先点击啊config进行配置，此时弹出对话框，我的visual studio版本是2019的， 所以我选择编译生成visual studio2019的工程。接下来点击generate生成项目，大约几分钟可以生成，生成成功后我们点击open project打开工程，此时就是用visual sutido 2019打开grpc工程了。接下来我们设置编译平台为64位，选择Debug模式，这里大家尽量编译Release版，Release版压缩的更好一点。选择All项目进行全量编译，编译后就可以在Debug或Release文件夹找到对应生成的库文件和exe了。 总结本文介绍了windows环境下如何配置grpc项目和编译生成我们需要的库。如果大家还是不能顺利生成编译所需的库，可以用我的，这个源码在linux和windows都能用，源码包括第三方库都下载好了，网盘地址：https://pan.baidu.com/s/1BBaAZ8-R-GSxxcy2s7TRWA?pwd=ybno提取码：ybno","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"asio处理粘包的简易方式","date":"2023-05-25T11:58:32.000Z","path":"2023/05/25/asio14/","text":"简易方式之前我们介绍了通过async_read_some函数监听读事件，并且绑定了读事件的回调函数HandleRead 12_socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, SharedSelf())); async_read_some 这个函数的特点是只要对端发数据，服务器接收到数据，即使没有收全对端发送的数据也会触发HandleRead函数，所以我们会在HandleRead回调函数里判断接收的字节数，接收的数据可能不满足头部长度，可能大于头部长度但小于消息体的长度，可能大于消息体的长度，还可能大于多个消息体的长度，所以要切包等，这些逻辑写起来很复杂，所以我们可以通过读取指定字节数，直到读完这些字节才触发回调函数，那么可以采用async_read函数，这个函数指定读取指定字节数，只有完全读完才会触发回调函数。 获取头部数据我们可以读取指定的头部长度，大小为HEAD_LENGTH字节数，只有读完HEAD_LENGTH字节才触发HandleReadHead函数 12345void CSession::Start()&#123; _recv_head_node-&gt;Clear(); boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_LENGTH), std::bind(&amp;CSession::HandleReadHead, this, std::placeholders::_1, std::placeholders::_2, SharedSelf()));&#125; 这样我们可以直接在HandleReadHead函数内处理头部信息 123456789101112131415161718192021222324252627282930313233void CSession::HandleReadHead(const boost::system::error_code&amp; error, size_t bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self) &#123; if (!error) &#123; if (bytes_transferred &lt; HEAD_LENGTH) &#123; cout &lt;&lt; &quot;read head lenth error&quot;; Close(); _server-&gt;ClearSession(_uuid); return; &#125; //头部接收完，解析头部 short data_len = 0; memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH); cout &lt;&lt; &quot;data_len is &quot; &lt;&lt; data_len &lt;&lt; endl; //此处省略字节序转换 // ... //头部长度非法 if (data_len &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; data_len &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return; &#125; _recv_msg_node= make_shared&lt;MsgNode&gt;(data_len); boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), std::bind(&amp;CSession::HandleReadMsg, this, std::placeholders::_1, std::placeholders::_2, SharedSelf())); &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); &#125;&#125; 接下来根据头部内存储的消息体长度，获取指定长度的消息体数据，所以再次调用async_read，指定读取_recv_msg_node-&gt;_total_len长度，然后触发HandleReadMsg函数 获取消息体HandleReadMsg函数内解析消息体，解析完成后打印收到的消息，接下来继续监听读事件，监听读取指定头部大小字节，触发HandleReadHead函数， 然后再在HandleReadHead内继续监听读事件，获取消息体长度数据后触发HandleReadMsg函数，从而达到循环监听的目的。 123456789101112131415161718192021void CSession::HandleReadMsg(const boost::system::error_code&amp; error, size_t bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self) &#123; if (!error) &#123; PrintRecvData(_data, bytes_transferred); std::chrono::milliseconds dura(2000); std::this_thread::sleep_for(dura); _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; Send(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len); //再次接收头部数据 _recv_head_node-&gt;Clear(); boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_LENGTH), std::bind(&amp;CSession::HandleReadHead, this, std::placeholders::_1, std::placeholders::_2, SharedSelf())); &#125; else &#123; cout &lt;&lt; &quot;handle read msg failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); &#125;&#125; 总结本文介绍了如何使用async_read函数，监听读事件获取指定字节数才触发回调函数，用这种办法处理粘包问题很简单。源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"visual studio配置jsoncpp","date":"2023-05-21T02:39:51.000Z","path":"2023/05/21/asio13/","text":"jsoncpp简介jsoncpp 是一个 C++ JSON 库，它提供了将 JSON 数据解析为 C++ 对象、将 C++ 对象序列化为 JSON 数据的功能。它支持所有主流操作系统（包括 Windows、Linux、Mac OS X 等），并且可以与常见编译器（包括 Visual Studio、GCC 等）兼容。 jsoncpp 库是以源代码的形式发布的，因此使用者需要自己构建和链接库文件。该库文件不依赖于第三方库，只需包含头文件即可使用。 jsoncpp 库的特点包括： 轻量级：JSON 解析器和序列化器都非常快速，不会占用太多的 CPU 和内存资源； 易于使用：提供简单的 API，易于理解和使用； 可靠性高：经过广泛测试，已被许多企业和开发者用于生产环境中； 开源免费：遵循 MIT 许可证发布，使用和修改均免费。 总之，jsoncpp 是一款优秀的 C++ JSON 库，它可以帮助你轻松地处理 JSON 数据，为你的项目带来便利和高效。 下载jsoncppjsoncpp是一个C++库，可以使用它来通过C++代码来生成、解析json文件。同时也可以进行各种格式的字符串转换。 jsoncpp下载地址：https://github.com/open-source-parsers/jsoncpp官方文档：http://jsoncpp.sourceforge.net/old.html 选择windows版本的下载。 如果下载速度很慢，可以去我的网盘地址下载https://pan.baidu.com/s/1Yg9Usdc3T-CYhyr9GiePCw?pwd=ng6x 验证码ng6x下载后我们解压文件夹，解压后文件夹如下图 编译jsoncpp然后进行编译，编译需要进入makefile文件夹下 找到jsoncpp.sln文件，用visual studio打开，因为我的是visual studio2019版本，所以会提示我升级。 点击确定升级，之后我们选择编译lib_json即可，当然偷懒可以选择编译整个解决方案。 然后我们配置编译属性，我想要用x64位的，所以配置编译平台为X64位，编译模式为debug模式，大家最好把release版和debug版都编译一遍。编译选择的线程模式为mtd，这个根据系统默认配置来，如果后续和其他的库冲突了，我们再改变线程模式也不迟。编译生成后，我们的json库生成在项目同级目录的x64文件夹下的debug目录下 接下来我们在D盘cppsoft新建一个文件夹libjson，然后在其内部分别建立include和lib文件夹 将jsoncpp-src-0.5.0源码文件夹下include文件夹里的内容copy到libjson下的include文件夹内。将jsoncpp-src-0.5.0源码文件夹下x64位debug文件夹下生成的库copy到libjson下的lib文件夹内。 配置jsoncpp接下来我们新建一个项目，在项目属性中配置jsoncpp项目属性中，VC++包含目录设置为 D:\\cppsoft\\libjson\\include库目录选择为 VC++库目录设置为 D:\\cppsoft\\libjson\\lib另外我们还要设置链接器-&gt;输入-&gt;附加依赖项里设置json_vc71_libmtd.lib然后我们写一段代码测试 123456789101112131415161718#include &lt;iostream&gt;#include &lt;json/json.h&gt;#include &lt;json/value.h&gt;#include &lt;json/reader.h&gt;int main()&#123; Json::Value root; root[&quot;id&quot;] = 1001; root[&quot;data&quot;] = &quot;hello world&quot;; std::string request = root.toStyledString(); std::cout &lt;&lt; &quot;request is &quot; &lt;&lt; request &lt;&lt; std::endl; Json::Value root2; Json::Reader reader; reader.parse(request, root2); std::cout &lt;&lt; &quot;msg id is &quot; &lt;&lt; root2[&quot;id&quot;] &lt;&lt; &quot; msg is &quot; &lt;&lt; root2[&quot;data&quot;] &lt;&lt; std::endl;&#125; 从这段代码中，我们先将root序列化为字符串，再将字符串反序列化为root2.输出如下 网络编程中的应用在客户端发送数据时对发送的数据进行序列化 1234567891011Json::Value root;root[&quot;id&quot;] = 1001;root[&quot;data&quot;] = &quot;hello world&quot;;std::string request = root.toStyledString();size_t request_length = request.length();char send_data[MAX_LENGTH] = &#123; 0 &#125;;//转为网络字节序int request_host_length = boost::asio::detail::socket_ops::host_to_network_short(request_length);memcpy(send_data, &amp;request_host_length, 2);memcpy(send_data + 2, request.c_str(), request_length);boost::asio::write(sock, boost::asio::buffer(send_data, request_length + 2)); 我们可以在服务器收到数据时进行json反序列化 12345Json::Reader reader;Json::Value root;reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);std::cout &lt;&lt; &quot;recevie msg id is &quot; &lt;&lt; root[&quot;id&quot;].asInt() &lt;&lt; &quot; msg data is &quot;&lt;&lt; root[&quot;data&quot;].asString() &lt;&lt; endl; 总结本文介绍了visual studio如何配置并使用protobuf，以及在服务器通信中的使用源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"visual studio配置protobuf","date":"2023-05-11T08:16:08.000Z","path":"2023/05/11/asio12/","text":"protobuf简介Protocol Buffers（简称 Protobuf）是一种轻便高效的序列化数据结构的协议，由 Google 开发。它可以用于将结构化数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域。我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。 下载protobuf安装包官方下载地址https://github.com/protocolbuffers/protobuf/releases 选择zip文件下载即可 因为官网下载速度较慢，我把下载好的protobuf存在网盘里了https://pan.baidu.com/s/1Yg9Usdc3T-CYhyr9GiePCw?pwd=ng6x 验证码ng6x 下载完后解压即可，我放在D盘cppsoft文件夹下 下载cmakeCMake是一个跨平台的开源构建工具，可以用于自动化构建、测试和打包C++代码。与其他构建工具相比，CMake的优点之一是它的配置文件具有可读性和可维护性，而且支持多种编译器、操作系统和构建工具。 使用CMake，您可以将C++项目的配置和生成分离开来，从而使其更加可重复，并且可以在不同的平台上进行构建和测试。CMake使用类似于脚本语言的语法来描述构建过程，并生成适用于各种构建系统的构建文件（例如Makefile、Visual Studio解决方案等）。 以下是CMake的一些功能： 自动生成包含目录、库和源文件列表的Makefile 支持多种编译器和操作系统 可以自动生成安装程序和打包文件 跨平台支持 CMakeLists.txt 配置文件编写简单，易于维护 总之，CMake是一个强大的构建工具，可以大大简化C++项目的构建过程，并提高可移植性和可重复性。如果您正在寻找一个跨平台的自动构建工具来构建您的C++代码，请考虑使用CMake。 我们要在windows上生成protobuf对应的库，就需要用到cmake。官方下载地址https://cmake.org/download/， 选择Windows Source下载。由于官方下载较慢，可以去我的网盘下载https://pan.baidu.com/s/1Yg9Usdc3T-CYhyr9GiePCw?pwd=ng6x 编译protobuf在protobuf中创建一个文件夹，名字叫做visualstudio，你可以叫其他的名字,如下图然后我们打开刚才下载的cmake桌面程序,点击后source code 选择protobuf源码路径下的cmake目录build binaries目录选择我们刚刚创建的visualstudio目录生成选项可以依据自己要求生成。点击config，再点击generate就可以生成了。生成后我们可以看到protobuf的visualstudio文件夹内生成了.sln文件。双击.sln文件，我的是默认用visual studio2019打开可以单独选择libprotobuf编译，也可以选择All Build编译编译时可以选择debug和release，建议每一个都编译一遍，这样就有debug和release两个版本的库了。我选择的是X64位的debug模式编译，生成的库在visualstudio目录下的Debug文件夹里。可以看到我们生成了protobuf相关的lib库和dll库，一个是静态类型的，一个是动态类型的。接下来我创建一个新的文件夹D:\\cppsoft\\protoc然后在该文件夹内创建一个bin文件夹(用来存储刚才protobuf生成的库)和include文件夹(用来存储protobuf的头文件)将libprotobufd.lib和libprotocd.lib， 以及protoc.exe拷贝到bin目录下，当然为了偷懒，可以将刚才Debug目录下的所有内容都拷贝到bin目录也可以。将protobuf文件夹下src文件夹里的google文件夹及其内容拷贝到protoc的include文件夹将编译目录的google文件夹拷贝到protoc的include文件夹到此为止，我们protobuf的库生成工作就完成了。因为我们要用到protoc命令，所以要将该命令配置到环境变量，在系统环境变量里添加一个环境变量PROTOBUF_HOME,设置它的值为D:\\cppsoft\\protoc\\bin然后将该值添加到系统的path路径即可,格式为%PROTOBUF_HOME%这样我们就可以直接使用protoc.exe了。 visual stuido配置protobuf我们新建一个控制台项目，在项目属性中，配置选择Debug，平台选择X64，选择VC++目录，在包含目录中添加 D:\\cppsoft\\protoc\\include在库目录中添加 D:\\cppsoft\\protoc\\bin 在链接器的输入选项中添加protobuf用到的lib库 12libprotobufd.liblibprotocd.lib 到此，visual studio 的protobuf配置完毕。 生成pb文件要想使用protobuf的序列化功能，需要生成pb文件，pb文件包含了我们要序列化的类信息。我们先创建一个msg.proto，该文件用来定义我们要发送的类信息 1234567syntax = &quot;proto3&quot;;message Book&#123; string name = 1; int32 pages = 2; float price = 3;&#125; 这个文件定义了一个名为Book的消息类型，包含三个字段：name、pages和price。其中每个字段都有一个数字标识符，用于标识该字段在二进制流中的位置。我们使用protoc.exe 基于msg.proto生成我们要用的C++类在proto所在文件夹执行如下命令 1protoc --cpp_out=. ./msg.proto –cpp_out= 表示指定要生成的pb文件所在的位置./msg.proto 表示msg.proto所在的位置，因为我们是在msg.proto所在文件夹中执行的protoc命令,所以是当前路径即可。执行后，会看到当前目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件。我们将这两个文件添加到项目里，然后在主函数中包含msg.pb.h，做如下测试 1234567891011121314151617#include &lt;iostream&gt;#include &quot;msg.pb.h&quot;int main()&#123; Book book; book.set_name(&quot;CPP programing&quot;); book.set_pages(100); book.set_price(200); std::string bookstr; book.SerializeToString(&amp;bookstr); std::cout &lt;&lt; &quot;serialize str is &quot; &lt;&lt; bookstr &lt;&lt; std::endl; Book book2; book2.ParseFromString(bookstr); std::cout &lt;&lt; &quot;book2 name is &quot; &lt;&lt; book2.name() &lt;&lt; &quot; price is &quot; &lt;&lt; book2.price() &lt;&lt; &quot; pages is &quot; &lt;&lt; book2.pages() &lt;&lt; std::endl; getchar();&#125; 上面的demo中将book对象先序列化为字符串，再将字符串反序列化为book2对象。这样就是visual studio 配置和使用protobuf的方法。 在网络中的应用先为服务器定义一个用来通信的proto 123456syntax = &quot;proto3&quot;;message MsgData&#123; int32 id = 1; string data = 2;&#125; id代表消息id，data代表消息内容我们用protoc生成对应的pb.h和pb.cc文件将proto,pb.cc,pb.h三个文件复制到我们之前的服务器项目里并且配置。 我们修改服务器接收数据和发送数据的逻辑当服务器收到数据后，完成切包处理后，将信息反序列化为具体要使用的结构,打印相关的信息，然后再发送给客户端 12345678910MsgData msgdata;std::string receive_data;msgdata.ParseFromString(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len));std::cout &lt;&lt; &quot;recevie msg id is &quot; &lt;&lt; msgdata.id() &lt;&lt; &quot; msg data is &quot; &lt;&lt; msgdata.data() &lt;&lt; endl;std::string return_str = &quot;server has received msg, msg data is &quot; + msgdata.data();MsgData msgreturn;msgreturn.set_id(msgdata.id());msgreturn.set_data(return_str);msgreturn.SerializeToString(&amp;return_str);Send(return_str); 同样的道理，客户端在发送的时候也利用protobuf进行消息的序列化，然后发给服务器 12345 MsgData msgdata;msgdata.set_id(1001);msgdata.set_data(&quot;hello world&quot;);std::string request;msgdata.SerializeToString(&amp;request); 总结本文介绍了visual studio如何配置并使用protobuf，以及在服务器通信中的使用源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"字节序处理和消息队列的控制","date":"2023-05-11T03:40:01.000Z","path":"2023/05/11/asio11/","text":"字节序的问题在计算机网络中，由于不同的计算机使用的 CPU 架构和字节顺序可能不同，因此在传输数据时需要对数据的字节序进行统一，以保证数据能够正常传输和解析。这就是网络字节序的作用。 具体来说，计算机内部存储数据的方式有两种：大端序（Big-Endian）和小端序（Little-Endian）。在大端序中，高位字节存储在低地址处，而低位字节存储在高地址处；在小端序中，高位字节存储在高地址处，而低位字节存储在低地址处。 在网络通信过程中，通常使用的是大端序。这是因为早期的网络硬件大多采用了 Motorola 处理器，而 Motorola 处理器使用的是大端序。此外，大多数网络协议规定了网络字节序必须为大端序。 因此，在进行网络编程时，需要将主机字节序转换为网络字节序，也就是将数据从本地字节序转换为大端序。可以使用诸如 htonl、htons、ntohl 和 ntohs 等函数来实现字节序转换操作。 综上所述，网络字节序的主要作用是统一不同计算机间的数据表示方式，以保证数据在网络中的正确传输和解析。 如何区分本机字节序如何区分本机字节序，可以通过判断低地址存储的数据是否为低字节数据，如果是则为小端，否则为大端，下面写一段代码讲述这个逻辑 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;// 判断当前系统的字节序是大端序还是小端序bool is_big_endian() &#123; int num = 1; if (*(char*)&amp;num == 1) &#123; // 当前系统为小端序 return false; &#125; else &#123; // 当前系统为大端序 return true; &#125;&#125;int main() &#123; int num = 0x12345678; char* p = (char*)&amp;num; cout &lt;&lt; &quot;原始数据：&quot; &lt;&lt; hex &lt;&lt; num &lt;&lt; endl; if (is_big_endian()) &#123; cout &lt;&lt; &quot;当前系统为大端序&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字节序为：&quot;; for (int i = 0; i &lt; sizeof(num); i++) &#123; cout &lt;&lt; hex &lt;&lt; (int)*(p + i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;当前系统为小端序&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字节序为：&quot;; for (int i = sizeof(num) - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; hex &lt;&lt; (int)*(p + i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 在上述代码中，使用了一个 is_big_endian() 函数来判断当前系统的字节序是否为大端序。该函数通过创建一个整型变量 num，并将其最低位设置为 1，然后通过指针强制转换成字符指针，判断第一个字节是否为 1 来判断当前系统的字节序。 在 main 函数中，定义了一个整型变量 num，并将其初始化为 0x12345678。接着，使用 char* 类型的指针 p 来指向 num 的地址。然后，通过判断当前系统的字节序来输出 num 的字节序。 如果当前系统为大端序，则按照原始顺序输出各个字节；如果当前系统为小端序，则需要逆序输出各个字节。 例如，如果当前系统为大端序，则输出结果为： 123原始数据：12345678当前系统为大端序字节序为：12 34 56 78 如果当前系统为小端序，则输出结果为： 123原始数据：12345678当前系统为小端序字节序为：78 56 34 12 以上是 C++ 中实现大端字节序和小端字节序的示例。画个图表示大端和小端字节序区别。 大端模式 小端模式 服务器使用网络字节序为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。在 boost::asio 库中，可以使用 boost::asio::detail::socket_ops::host_to_network_long() 和 boost::asio::detail::socket_ops::host_to_network_short() 函数将主机字节序转换为网络字节序。具体方法如下： 123456789101112131415161718#include &lt;boost/asio.hpp&gt;#include &lt;iostream&gt;int main()&#123; uint32_t host_long_value = 0x12345678; uint16_t host_short_value = 0x5678; uint32_t network_long_value = boost::asio::detail::socket_ops::host_to_network_long(host_long_value); uint16_t network_short_value = boost::asio::detail::socket_ops::host_to_network_short(host_short_value); std::cout &lt;&lt; &quot;Host long value: 0x&quot; &lt;&lt; std::hex &lt;&lt; host_long_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Network long value: 0x&quot; &lt;&lt; std::hex &lt;&lt; network_long_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Host short value: 0x&quot; &lt;&lt; std::hex &lt;&lt; host_short_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Network short value: 0x&quot; &lt;&lt; std::hex &lt;&lt; network_short_value &lt;&lt; std::endl; return 0;&#125; 上述代码中，使用了 boost::asio::detail::socket_ops::host_to_network_long() 和 boost::asio::detail::socket_ops::host_to_network_short() 函数将主机字节序转换为网络字节序。 host_to_network_long() 函数将一个 32 位无符号整数从主机字节序转换为网络字节序，返回转换后的结果。host_to_network_short() 函数将一个 16 位无符号整数从主机字节序转换为网络字节序，返回转换后的结果。 在上述代码中，分别将 32 位和 16 位的主机字节序数值转换为网络字节序，并输出转换结果。需要注意的是，在使用这些函数时，应该确保输入参数和返回结果都是无符号整数类型，否则可能会出现错误。同样的道理，我们只需要在服务器发送数据时，将数据长度转化为网络字节序，在接收数据时，将长度转为本机字节序。在服务器的HandleRead函数里，添加对data_len的转换，将网络字节转为本地字节序 12345short data_len = 0;memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);//网络字节序转化为本地字节序data_len=boost::asio::detail::socket_ops::network_to_host_short(data_len);cout &lt;&lt; &quot;data_len is &quot; &lt;&lt; data_len &lt;&lt; endl; 在服务器的发送数据时会构造消息节点，构造消息节点时，将发送长度由本地字节序转化为网络字节序 12345678MsgNode(char * msg, short max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(0)&#123; _data = new char[_total_len+1](); //转为网络字节序 int max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len); memcpy(_data, &amp;max_len_host, HEAD_LENGTH); memcpy(_data+ HEAD_LENGTH, msg, max_len); _data[_total_len] = &#x27;\\0&#x27;;&#125; 客户端也遵循同样的处理。 消息队列控制发送时我们会将发送的消息放入队列里以保证发送的时序性，每个session都有一个发送队列，因为有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。 12345678910111213141516void CSession::Send(char* msg, int max_length) &#123; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); int send_que_size = _send_que.size(); if (send_que_size &gt; MAX_SENDQUE) &#123; cout &lt;&lt; &quot;session: &quot; &lt;&lt; _uuid &lt;&lt; &quot; send que fulled, size is &quot; &lt;&lt; MAX_SENDQUE &lt;&lt; endl; return; &#125; _send_que.push(make_shared&lt;MsgNode&gt;(msg, max_length)); if (send_que_size&gt;0) &#123; return; &#125; auto&amp; msgnode = _send_que.front(); boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_total_len), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, SharedSelf()));&#125; 总结本文介绍了如何使用网络字节序以及为什么使用网络字节序作为网络传输，且为发送队列设置了阈值保证发送数据的高效性。源码链接","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"处理粘包问题","date":"2023-04-23T11:03:49.000Z","path":"2023/04/23/asio10/","text":"粘包问题今天介绍一下如何处理粘包，粘包问题是服务器收发数据常遇到的一个现象，下面我们介绍一下粘包问题是什么，当客户端发送多个数据包给服务器时，服务器底层的tcp接收缓冲区收到的数据为粘连在一起的，如下图所示 当客户端发送两个Hello World！给服务器，服务器TCP接收缓冲区接收了两次，一次是Hello World!Hello, 第二次是World！。 粘包原因因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！如下图这是最好理解的粘包问题的产生原因。还有一些其他的原因比如1 &emsp; 客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！。2 &emsp; tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法。3 &emsp; 再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连。 处理粘包处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容)，如下图为保证大家容易理解，我们先简化发送的格式，格式变为消息长度+消息内容的方式，之后再完善为tlv格式。简化后的结构如下图 完善消息节点之前我们设计过消息节点的数据结构MsgNode，这里需要完善一下. 12345678910111213141516171819202122232425262728class MsgNode&#123; friend class CSession;public: MsgNode(char * msg, short max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(0)&#123; _data = new char[_total_len+1](); memcpy(_data, &amp;max_len, HEAD_LENGTH); memcpy(_data+ HEAD_LENGTH, msg, max_len); _data[_total_len] = &#x27;\\0&#x27;; &#125; MsgNode(short max_len):_total_len(max_len),_cur_len(0) &#123; _data = new char[_total_len +1](); &#125; ~MsgNode() &#123; delete[] _data; &#125; void Clear() &#123; ::memset(_data, 0, _total_len); _cur_len = 0; &#125;private: short _cur_len; short _total_len; char* _data;&#125;; 1 &emsp; 两个参数的构造函数做了完善，之前的构造函数通过消息首地址和长度构造节点数据，现在需要在构造节点的同时把长度信息也写入节点,该构造函数主要用来发送数据时构造发送信息的节点。2 &emsp; 一个参数的构造函数为较上次新增的，主要根据消息的长度构造消息节点，该构造函数主要是接收对端数据时构造接收节点调用的。3 &emsp; 新增一个Clear函数清除消息节点的数据，主要是避免多次构造节点造成开销。 CSession类完善为能够对收到的数据切包处理，需要定义一个消息接收节点，一个bool类型的变量表示头部是否解析完成，以及将处理好的头部先缓存起来的结构。 12345//收到的消息结构std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;bool _b_head_parse;//收到的头部结构std::shared_ptr&lt;MsgNode&gt; _recv_head_node; _recv_msg_node用来存储接受的消息体信息_recv_head_node用来存储接收的头部信息_b_head_parse表示是否处理完头部信息 同时我们新增一个HEAD_LENGTH变量表示数据包头部的大小，修改原消息最大长度为1024*2 12#define MAX_LENGTH 1024*2#define HEAD_LENGTH 2 完善接收逻辑我们需要修改HandleRead函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103void CSession::HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)&#123; if (!error) &#123; //已经移动的字符数 int copy_len = 0; while (bytes_transferred&gt;0) &#123; if (!_b_head_parse) &#123; //收到的数据不足头部大小 if (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123; memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+ copy_len, bytes_transferred); _recv_head_node-&gt;_cur_len += bytes_transferred; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; //收到的数据比头部多 //头部剩余未复制的长度 int head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len; memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+copy_len, head_remain); //更新已处理的data长度和剩余未处理的长度 copy_len += head_remain; bytes_transferred -= head_remain; //获取头部数据 short data_len = 0; memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH); cout &lt;&lt; &quot;data_len is &quot; &lt;&lt; data_len &lt;&lt; endl; //头部长度非法 if (data_len &gt; MAX_LENGTH) &#123; std::cout &lt;&lt; &quot;invalid data length is &quot; &lt;&lt; data_len &lt;&lt; endl; _server-&gt;ClearSession(_uuid); return; &#125; _recv_msg_node = make_shared&lt;MsgNode&gt;(data_len); //消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里 if (bytes_transferred &lt; data_len) &#123; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred); _recv_msg_node-&gt;_cur_len += bytes_transferred; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); //头部处理完成 _b_head_parse = true; return; &#125; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len); _recv_msg_node-&gt;_cur_len += data_len; copy_len += data_len; bytes_transferred -= data_len; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //此处可以调用Send发送测试 Send(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len); //继续轮询剩余未处理数据 _b_head_parse = false; _recv_head_node-&gt;Clear(); if (bytes_transferred &lt;= 0) &#123; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; continue; &#125; //已经处理完头部，处理上次未接受完的消息数据 //接收的数据仍不足剩余未处理的 int remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len; if (bytes_transferred &lt; remain_msg) &#123; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred); _recv_msg_node-&gt;_cur_len += bytes_transferred; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg); _recv_msg_node-&gt;_cur_len += remain_msg; bytes_transferred -= remain_msg; copy_len += remain_msg; _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl; //此处可以调用Send发送测试 Send(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len); //继续轮询剩余未处理数据 _b_head_parse = false; _recv_head_node-&gt;Clear(); if (bytes_transferred &lt;= 0) &#123; ::memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self)); return; &#125; continue; &#125; &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; Close(); _server-&gt;ClearSession(_uuid); &#125;&#125; 1 &emsp; copy_len记录的是已经处理过数据的长度，因为存在一次接收多个包的情况，所以copy_len用来做已经处理的数据长度的。2 &emsp; 首先判断_b_head_parse是否为false，如果为false则说明头部未处理，先判断接收的数据是否小于头部, 如果小于头部大小则将接收到的数据放入_recv_head_node节点保存，然后继续调用读取函数监听对端发送数据。否则进入步骤3.3 &emsp; 如果收到的数据比头部多，可能是多个逻辑包，所以要做切包处理。根据之前保留在_recv_head_node的长度，计算出剩余未取出的头部长度，然后取出剩余的头部长度保存在_recv_head_node节点，然后通过memcpy方式从节点拷贝出数据写入short类型的data_len里，进而获取消息的长度。接下来继续处理包体，也就是消息体，判断接收到的数据未处理部分的长度和总共要接收的数据长度大小，如果小于总共要接受的长度，说明消息体没接收完，则将未处理部分先写入_recv_msg_node里，并且继续监听读事件。否则说明消息体接收完全，进入步骤44 &emsp; 将消息体数据接收到_recv_msg_node中，接受完全后返回给对端。当然存在多个逻辑包粘连，此时要判断bytes_transferred是否小于等于0，如果是说明只有一个逻辑包，我们处理完了，继续监听读事件，就直接返回即可。否则说明有多个数据包粘连，就继续执行上述操作。 5 &emsp; 因为存在_b_head_parse为true，也就是包头接收并处理完的情况，但是包体未接受完，再次触发HandleRead，此时要继续处理上次未接受完的消息体，大体逻辑和3，4一样。以上就是处理粘包的过程，我们绘制流程图更明了一些 客户端修改客户端的发送也要遵循先发送数据2个字节的数据长度，再发送数据消息的结构。接收时也是先接收两个字节数据获取数据长度，再根据长度接收消息。 1234567891011121314151617181920212223242526272829303132333435363738394041int main()&#123; try &#123; //创建上下文服务 boost::asio::io_context ioc; //构造endpoint tcp::endpoint remote_ep(address::from_string(&quot;127.0.0.1&quot;), 10086); tcp::socket sock(ioc); boost::system::error_code error = boost::asio::error::host_not_found; ; sock.connect(remote_ep, error); if (error) &#123; cout &lt;&lt; &quot;connect failed, code is &quot; &lt;&lt; error.value() &lt;&lt; &quot; error msg is &quot; &lt;&lt; error.message(); return 0; &#125; std::cout &lt;&lt; &quot;Enter message: &quot;; char request[MAX_LENGTH]; std::cin.getline(request, MAX_LENGTH); size_t request_length = strlen(request); char send_data[MAX_LENGTH] = &#123; 0 &#125;; memcpy(send_data, &amp;request_length, 2); memcpy(send_data + 2, request, request_length); boost::asio::write(sock, boost::asio::buffer(send_data, request_length+2)); char reply_head[HEAD_LENGTH]; size_t reply_length = boost::asio::read(sock,boost::asio::buffer(reply_head, HEAD_LENGTH)); short msglen = 0; memcpy(&amp;msglen, reply_head, HEAD_LENGTH); char msg[MAX_LENGTH] = &#123; 0 &#125;; size_t msg_length = boost::asio::read(sock,boost::asio::buffer(msg, msglen)); std::cout &lt;&lt; &quot;Reply is: &quot;; std::cout.write(msg, msglen) &lt;&lt; endl; std::cout &lt;&lt; &quot;Reply len is &quot; &lt;&lt; msglen; std::cout &lt;&lt; &quot;\\n&quot;; &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 服务器启动后，启动客户端，然后客户端发送Hello World，服务器收到后打印如下 粘包测试为了测试粘包，需要制造粘包产生的现象，可以让客户端发送的频率高一些，服务器接收的频率低一些，这样造成前后端收发数据不一致导致多个数据包在服务器tcp缓冲区滞留产生粘包现象。测试粘包之前，在服务器的CSession类里添加打印二进制数据的函数，便于查看缓冲区的数据 1234567891011void CSession::PrintRecvData(char* data, int length) &#123; stringstream ss; string result = &quot;0x&quot;; for (int i = 0; i &lt; length; i++) &#123; string hexstr; ss &lt;&lt; hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; int(data[i]) &lt;&lt; endl; ss &gt;&gt; hexstr; result += hexstr; &#125; std::cout &lt;&lt; &quot;receive raw data is : &quot; &lt;&lt; result &lt;&lt; endl;;&#125; 然后将这个函数放到HandleRead里，每次收到数据就调用这个函数打印接收到的最原始的数据，然后睡眠2秒再进行收发操作，用来延迟接收对端数据制造粘包，之后的逻辑不变 1234567void CSession::HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)&#123; if (!error) &#123; PrintRecvData(_data, bytes_transferred); std::chrono::milliseconds dura(2000); std::this_thread::sleep_for(dura); &#125;&#125; 修改客户端逻辑，实现收发分离。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main()&#123; try &#123; //创建上下文服务 boost::asio::io_context ioc; //构造endpoint tcp::endpoint remote_ep(address::from_string(&quot;127.0.0.1&quot;), 10086); tcp::socket sock(ioc); boost::system::error_code error = boost::asio::error::host_not_found; ; sock.connect(remote_ep, error); if (error) &#123; cout &lt;&lt; &quot;connect failed, code is &quot; &lt;&lt; error.value() &lt;&lt; &quot; error msg is &quot; &lt;&lt; error.message(); return 0; &#125; thread send_thread([&amp;sock] &#123; for (;;) &#123; this_thread::sleep_for(std::chrono::milliseconds(2)); const char* request = &quot;hello world!&quot;; size_t request_length = strlen(request); char send_data[MAX_LENGTH] = &#123; 0 &#125;; memcpy(send_data, &amp;request_length, 2); memcpy(send_data + 2, request, request_length); boost::asio::write(sock, boost::asio::buffer(send_data, request_length + 2)); &#125; &#125;); thread recv_thread([&amp;sock] &#123; for (;;) &#123; this_thread::sleep_for(std::chrono::milliseconds(2)); cout &lt;&lt; &quot;begin to receive...&quot; &lt;&lt; endl; char reply_head[HEAD_LENGTH]; size_t reply_length = boost::asio::read(sock, boost::asio::buffer(reply_head, HEAD_LENGTH)); short msglen = 0; memcpy(&amp;msglen, reply_head, HEAD_LENGTH); char msg[MAX_LENGTH] = &#123; 0 &#125;; size_t msg_length = boost::asio::read(sock, boost::asio::buffer(msg, msglen)); std::cout &lt;&lt; &quot;Reply is: &quot;; std::cout.write(msg, msglen) &lt;&lt; endl; std::cout &lt;&lt; &quot;Reply len is &quot; &lt;&lt; msglen; std::cout &lt;&lt; &quot;\\n&quot;; &#125; &#125;); send_thread.join(); recv_thread.join(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 再次启动服务器和客户端，看到粘包现象了，我们的服务器也能稳定切割数据包并返回正确的消息给客户端。可以看到服务器收到了大量数据，然后准确切割返回给了客户端。如下图。 总结该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题，这个留给下节处理。源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"封装发送队列","date":"2023-04-22T08:34:25.000Z","path":"2023/04/22/asio09/","text":"简介前文介绍了通过智能指针实现伪闭包的方式延长了session的生命周期，而实际使用的服务器并不是应答式，而是全双工通信方式，服务器一直监听写事件，接收对端数据，可随时发送数据给对端，今天介绍如何封装异步的发送接口，因为多次发送时，异步的发送要保证回调触发后再次发送才能确保数据是有序的，这一点我们已经在前文异步发送函数介绍的时候提到了。 Server和Session分离将Server修改为CServer并分离到CServer.h中，然后将Session修改为CSession分离到CSession.h中。CSession.h中类的声明如下，和之前的Session内容一样，就是修改了类名，放在CSession.h中 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;map&gt;#include &lt;boost/uuid/uuid_generators.hpp&gt;#include &lt;boost/uuid/uuid_io.hpp&gt;using boost::asio::ip::tcp;using namespace std;class CServer;class CSession :public std::enable_shared_from_this&lt;CSession&gt;&#123;public: CSession(boost::asio::io_context&amp; ioc, CServer* server) :_socket(ioc), _server(server) &#123; boost::uuids::uuid a_uuid = boost::uuids::random_generator()(); _uuid = boost::uuids::to_string(a_uuid); &#125; tcp::socket&amp; Socket() &#123; return _socket; &#125; ~CSession() &#123; std::cout &lt;&lt; &quot;session destruct delete this &quot; &lt;&lt; this &lt;&lt; endl; &#125; void Start(); std::string&amp; GetUuid();private: void handle_read(const boost::system::error_code&amp; error, size_t bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared); void handle_write(const boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared); tcp::socket _socket; enum &#123; max_length = 1024 &#125;; char _data[max_length]; CServer* _server; std::string _uuid;&#125;; CServer.h中声明如下，内容前文没变化，就是将Server内容写入CServer.h中 12345678910111213141516171819#include &lt;boost/asio.hpp&gt;#include &quot;CSession.h&quot;#include &lt;memory.h&gt;#include &lt;map&gt;using namespace std;using boost::asio::ip::tcp;class CServer&#123;public: CServer(boost::asio::io_context&amp; io_context, short port); void ClearSession(std::string);private: void HandleAccept(shared_ptr&lt;CSession&gt;, const boost::system::error_code &amp; error); void StartAccept(); boost::asio::io_context &amp;_io_context; short _port; tcp::acceptor _acceptor; std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;&#125;; 整体目录变为 数据节点设计我们设计一个数据节点MsgNode用来存储数据 123456789101112131415161718class MsgNode&#123; friend class CSession;public: MsgNode(char * msg, int max_len) &#123; _data = new char[max_len]; memcpy(_data, msg, max_len); &#125; ~MsgNode() &#123; delete[] _data; &#125;private: int _cur_len; int _max_len; char* _data;&#125;; 1 &emsp;_cur_len表示数据当前已处理的长度(已经发送的数据或者已经接收的数据长度)，因为一个数据包存在未发送完或者未接收完的情况。2 &emsp;_max_len表示数据的总长度。3 &emsp;_data表示数据域，已接收或者已发送的数据都放在此空间内。 封装发送接口首先在CSession类里新增一个队列存储要发送的数据，因为我们不能保证每次调用发送接口的时候上一次数据已经发送完，就要把要发送的数据放入队列中，通过回调函数不断地发送。而且我们不能保证发送的接口和回调函数的接口在一个线程，所以要增加一个锁保证发送队列安全性。同时我们新增一个发送接口Send 123void Send(char* msg, int max_length);std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;std::mutex _send_lock; 实现发送接口 1234567891011121314void CSession::Send(char* msg, int max_length) &#123; bool pending = false; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); if (_send_que.size() &gt; 0) &#123; pending = true; &#125; _send_que.push(make_shared&lt;MsgNode&gt;(msg, max_length)); if (pending) &#123; return; &#125; boost::asio::async_write(_socket, boost::asio::buffer(msg, max_length), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, shared_from_this()));&#125; 发送接口里判断发送队列是否为空，如果不为空说明有数据未发送完，需要将数据放入队列，然后返回。如果发送队列为空，则说明当前没有未发送完的数据，将要发送的数据放入队列并调用async_write函数发送数据。回调函数实现 123456789101112131415void CSession::HandleWrite(const boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared) &#123; if (!error) &#123; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); _send_que.pop(); if (!_send_que.empty()) &#123; auto &amp;msgnode = _send_que.front(); boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_max_len), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, _self_shared)); &#125; &#125; else &#123; std::cout &lt;&lt; &quot;handle write failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; _server-&gt;ClearSession(_uuid); &#125;&#125; 判断发送队列是否为空，为空则发送完，否则不断取出队列数据调用async_write发送，直到队列为空。 修改读回调因为我们要一直监听对端发送的数据，所以要在每次收到数据后继续绑定监听事件 1234567891011121314void CSession::HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)&#123; if (!error) &#123; cout &lt;&lt; &quot;read data is &quot; &lt;&lt; _data &lt;&lt; endl; //发送数据 Send(_data, bytes_transferred); memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared)); &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; _server-&gt;ClearSession(_uuid); &#125;&#125; 总结该服务器虽然实现了全双工通信，但是仍存在缺陷，比如粘包问题未处理，下一版本实现粘包处理。源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"利用C11模拟伪闭包实现连接的安全回收","date":"2023-04-10T02:38:34.000Z","path":"2023/04/10/asio08/","text":"简介之前的异步服务器为echo模式，但其存在安全隐患，就是在极端情况下客户端关闭导致触发写和读回调函数，二者都进入错误处理逻辑，进而造成二次析构的问题。下面我们介绍通过C11智能指针构造成一个伪闭包的状态延长session的生命周期。 智能指针管理Session我们可以通过智能指针的方式管理Session类，将acceptor接收的链接保存在Session类型的智能指针里。由于智能指针会在引用计数为0时自动析构，所以为了防止其被自动回收，也方便Server管理Session，因为我们后期会做一些重连踢人等业务逻辑，我们在Server类中添加成员变量，该变量为一个map类型，key为Session的uid，value为该Session的智能指针。 12345678910111213class CServer&#123;public: CServer(boost::asio::io_context&amp; io_context, short port); void ClearSession(std::string);private: void HandleAccept(shared_ptr&lt;CSession&gt;, const boost::system::error_code &amp; error); void StartAccept(); boost::asio::io_context &amp;_io_context; short _port; tcp::acceptor _acceptor; std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;&#125;; 通过Server中的_sessions这个map管理链接，可以增加Session智能指针的引用计数，只有当Session从这个map中移除后，Session才会被释放。所以在接收连接的逻辑里将Session放入map 12345678910111213141516void CServer::StartAccept() &#123; shared_ptr&lt;CSession&gt; new_session = make_shared&lt;CSession&gt;(_io_context, this); _acceptor.async_accept(new_session-&gt;GetSocket(), std::bind(&amp;CServer::HandleAccept, this, new_session, placeholders::_1));&#125;void CServer::HandleAccept(shared_ptr&lt;CSession&gt; new_session, const boost::system::error_code&amp; error)&#123; if (!error) &#123; new_session-&gt;Start(); _sessions.insert(make_pair(new_session-&gt;GetUuid(), new_session)); &#125; else &#123; cout &lt;&lt; &quot;session accept failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; &#125; StartAccept();&#125; StartAccept函数中虽然new_session是一个局部变量，但是我们通过bind操作，将new_session作为数值传递给bind函数，而bind函数返回的函数对象内部引用了该new_session所以引用计数增加1，这样保证了new_session不会被释放。在HandleAccept函数里调用session的start函数监听对端收发数据，并将session放入map中，保证session不被自动释放。此外，需要封装一个释放函数，将session从map中移除，当其引用计数为0则自动释放 123void CServer::ClearSession(std::string uuid) &#123; _sessions.erase(uuid);&#125; Session的uuid关于session的uuid可以通过boost提供的生成唯一id的函数获得，当然你也可以自己实现雪花算法。 12345CSession::CSession(boost::asio::io_context&amp; io_context, CServer* server): _socket(io_context), _server(server)&#123; boost::uuids::uuid a_uuid = boost::uuids::random_generator()(); _uuid = boost::uuids::to_string(a_uuid);&#125; 另外我们修改Session中读写回调函数关于错误的处理，当读写出错的时候清除连接 123456789101112131415161718192021222324252627282930void CSession::HandleWrite(const boost::system::error_code&amp; error) &#123; if (!error) &#123; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); _send_que.pop(); if (!_send_que.empty()) &#123; auto &amp;msgnode = _send_que.front(); boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_max_len), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1)); &#125; &#125; else &#123; std::cout &lt;&lt; &quot;handle write failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; _server-&gt;ClearSession(_uuid); &#125;&#125;void CSession::HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred)&#123; if (!error) &#123; cout &lt;&lt; &quot;read data is &quot; &lt;&lt; _data &lt;&lt; endl; //发送数据 Send(_data, bytes_transferred); memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2)); &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; _server-&gt;ClearSession(_uuid); &#125;&#125; 隐患正常情况下上述服务器运行不会出现问题，但是当我们像上次一样模拟，在服务器要发送数据前打个断点，此时关闭客户端，在服务器就会先触发写回调函数的错误处理，再触发读回调函数的错误处理，这样session就会两次从map中移除，因为map中key唯一，所以第二次map判断没有session的key就不做移除操作了。但是这么做还是会有崩溃问题，因为第一次在session写回调函数中移除session，session的引用计数就为0了，调用了session的析构函数，这样在触发session读回调函数时此时session的内存已经被回收了自然会出现崩溃的问题。解决这个问题可以利用智能指针引用计数和bind的特性，实现一个伪闭包的机制延长session的生命周期。 如何构造伪闭包思路：1 &emsp; 利用智能指针被复制或使用引用计数加一的原理保证内存不被回收2 &emsp; bind操作可以将值绑定在一个函数对象上生成新的函数对象，如果将智能指针作为参数绑定给函数对象，那么智能指针就以值的方式被新函数对象使用，那么智能指针的生命周期将和新生成的函数对象一致，从而达到延长生命的效果。我们按照上面的思路改写我们的回调函数 123void HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared);void HandleWrite(const boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared); 以HandleWrite举例,在bind时传递_self_shared指针增加其引用计数，这样_self_shared的生命周期就和async_write的第二个参数(也就是asio要求的回调函数对象)生命周期一致了。 123456789101112131415void CSession::HandleWrite(const boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared) &#123; if (!error) &#123; std::lock_guard&lt;std::mutex&gt; lock(_send_lock); _send_que.pop(); if (!_send_que.empty()) &#123; auto &amp;msgnode = _send_que.front(); boost::asio::async_write(_socket, boost::asio::buffer(msgnode-&gt;_data, msgnode-&gt;_max_len), std::bind(&amp;CSession::HandleWrite, this, std::placeholders::_1, _self_shared)); &#125; &#125; else &#123; std::cout &lt;&lt; &quot;handle write failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; _server-&gt;ClearSession(_uuid); &#125;&#125; 同样道理HandleRead内部也实现了类似的绑定 123456789101112131415void CSession::HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)&#123; if (!error) &#123; cout &lt;&lt; &quot;read data is &quot; &lt;&lt; _data &lt;&lt; endl; //发送数据 Send(_data, bytes_transferred); memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared)); &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, error is &quot; &lt;&lt; error.what() &lt;&lt; endl; _server-&gt;ClearSession(_uuid); &#125;&#125; 除此之外，我们也要在第一次绑定读写回调函数的时候传入智能指针的值,但是要注意传入的方式，不能用两个智能指针管理同一块内存，如下用法是错误的。 12345void CSession::Start()&#123; memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_ptr&lt;CSession&gt;(this)));&#125; shared_ptr(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数，所以要通过shared_from_this()函数返回智能指针，该智能指针和其他管理这块内存的智能指针共享引用计数。 12345void CSession::Start()&#123; memset(_data, 0, MAX_LENGTH); _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&amp;CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_from_this()));&#125; shared_from_this()函数并不是session的成员函数，要使用这个函数需要继承std::enable_shared_from_this 123456789101112131415161718class CSession:public std::enable_shared_from_this&lt;CSession&gt;&#123;public: CSession(boost::asio::io_context&amp; io_context, CServer* server); tcp::socket&amp; GetSocket(); std::string&amp; GetUuid(); void Start(); void Send(char* msg, int max_length);private: void HandleRead(const boost::system::error_code&amp; error, size_t bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared); void HandleWrite(const boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared); tcp::socket _socket; std::string _uuid; char _data[MAX_LENGTH]; CServer* _server; std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que; std::mutex _send_lock;&#125;; 同样的道理，我们在发送的时候也要绑定智能指针作为参数, 这里不做赘述。再次测试，链接可以安全释放，并不存在二次释放的问题。可以在析构函数内打印析构的信息，发现只析构一次 总结我们通过C11的bind和智能指针实现了类似于go，js等语言的闭包功能，保证在回调函数触发之前Session都是存活的。源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"简单的异步服务器demo","date":"2023-04-09T07:21:54.000Z","path":"2023/04/09/asio07/","text":"简介前文已经介绍了异步操作的api，今天写一个简单的异步echo服务器，以应答为主 Session类Session类主要是处理客户端消息收发的会话类，为了简单起见，我们不考虑粘包问题，也不考虑支持手动调用发送的接口，只以应答的方式发送和接收固定长度(1024字节长度)的数据。 1234567891011121314151617class Session&#123;public: Session(boost::asio::io_context&amp; ioc):_socket(ioc)&#123; &#125; tcp::socket&amp; Socket() &#123; return _socket; &#125; void Start();private: void handle_read(const boost::system::error_code &amp; error, size_t bytes_transfered); void handle_write(const boost::system::error_code&amp; error); tcp::socket _socket; enum &#123;max_length = 1024&#125;; char _data[max_length];&#125;; 1 &emsp; _data用来接收客户端传递的数据2 &emsp; _socket为单独处理客户端读写的socket。3 &emsp; handle_read和handle_write分别为读回调函数和写回调函数。接下来我们实现Session类 1234567void Session::Start()&#123; memset(_data, 0, max_length); _socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&amp;Session::handle_read, this, placeholders::_1, placeholders::_2) );&#125; 在Start方法中我们调用异步读操作，监听对端发送的消息。当对端发送数据后，触发handle_read函数 1234567891011void Session::handle_read(const boost::system::error_code&amp; error, size_t bytes_transfered) &#123; if (!error) &#123; cout &lt;&lt; &quot;server receive data is &quot; &lt;&lt; _data &lt;&lt; endl; boost::asio::async_write(_socket, boost::asio::buffer(_data, bytes_transfered), std::bind(&amp;Session::handle_write, this, placeholders::_1)); &#125; else &#123; delete this; &#125;&#125; handle_read函数内将收到的数据发送给对端，当发送完成后触发handle_write回调函数。 12345678910void Session::handle_write(const boost::system::error_code&amp; error) &#123; if (!error) &#123; memset(_data, 0, max_length); _socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&amp;Session::handle_read, this, placeholders::_1, placeholders::_2)); &#125; else &#123; delete this; &#125;&#125; handle_write函数内又一次监听了读事件，如果对端有数据发送过来则触发handle_read，我们再将收到的数据发回去。从而达到应答式服务的效果。 Server类Server类为服务器接收连接的管理类 123456789class Server &#123;public: Server(boost::asio::io_context&amp; ioc, short port);private: void start_accept(); void handle_accept(Session* new_session, const boost::system::error_code&amp; error); boost::asio::io_context&amp; _ioc; tcp::acceptor _acceptor;&#125;; start_accept将要接收连接的acceptor绑定到服务上，其内部就是将accpeptor对应的socket描述符绑定到epoll或iocp模型上，实现事件驱动。handle_accept为新连接到来后触发的回调函数。下面是具体实现 1234567891011121314151617181920Server::Server(boost::asio::io_context&amp; ioc, short port) :_ioc(ioc),_acceptor(ioc, tcp::endpoint(tcp::v4(), port)) &#123; start_accept();&#125;void Server::start_accept() &#123; Session* new_session = new Session(_ioc); _acceptor.async_accept(new_session-&gt;Socket(), std::bind(&amp;Server::handle_accept, this, new_session, placeholders::_1));&#125;void Server::handle_accept(Session* new_session, const boost::system::error_code&amp; error) &#123; if (!error) &#123; new_session-&gt;Start(); &#125; else &#123; delete new_session; &#125; start_accept();&#125; 客户端客户端的设计用之前的同步模式即可，客户端不需要异步的方式，因为客户端并不是以并发为主，当然写成异步收发更好一些。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;using namespace std;using namespace boost::asio::ip;const int MAX_LENGTH = 1024;int main()&#123; try &#123; //创建上下文服务 boost::asio::io_context ioc; //构造endpoint tcp::endpoint remote_ep(address::from_string(&quot;127.0.0.1&quot;), 10086); tcp::socket sock(ioc); boost::system::error_code error = boost::asio::error::host_not_found; ; sock.connect(remote_ep, error); if (error) &#123; cout &lt;&lt; &quot;connect failed, code is &quot; &lt;&lt; error.value() &lt;&lt; &quot; error msg is &quot; &lt;&lt; error.message(); return 0; &#125; std::cout &lt;&lt; &quot;Enter message: &quot;; char request[MAX_LENGTH]; std::cin.getline(request, MAX_LENGTH); size_t request_length = strlen(request); boost::asio::write(sock, boost::asio::buffer(request, request_length)); char reply[MAX_LENGTH]; size_t reply_length = boost::asio::read(sock, boost::asio::buffer(reply, request_length)); std::cout &lt;&lt; &quot;Reply is: &quot;; std::cout.write(reply, reply_length); std::cout &lt;&lt; &quot;\\n&quot;; &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 运行服务器之后再运行客户端，输入字符串后，就可以收到服务器应答的字符串了。 隐患该demo示例为仿照asio官网编写的，其中存在隐患，就是当服务器即将发送数据前(调用async_write前)，此刻客户端中断，服务器此时调用async_write会触发发送回调函数，判断ec为非0进而执行delete this逻辑回收session。但要注意的是客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。在读事件回调函数中判断错误码ec为非0，进而再次执行delete操作，从而造成二次析构，这是极度危险的。 总结本文介绍了异步的应答服务器设计，但是这种服务器并不会在实际生产中使用，主要有两个原因:1 &emsp; 因为该服务器的发送和接收以应答的方式交互，而并不能做到应用层想随意发送的目的，也就是未做到完全的收发分离(全双工逻辑)。2 &emsp; 该服务器未处理粘包，序列化，以及逻辑和收发线程解耦等问题。3 &emsp; 该服务器存在二次析构的风险。这些问题我们会在接下来的文章中不断完善源码链接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"asio异步读写操作及注意事项","date":"2023-04-05T08:56:30.000Z","path":"2023/04/05/asio06/","text":"简介本文介绍boost asio的异步读写操作及注意事项，为保证知识便于读者吸收，仅介绍api使用的代码片段，下一节再编写完整的客户端和服务器程序。所以我们定义一个session类，这个session类表示服务器处理客户端连接的管理类 1234567class Session &#123;public: Session(std::shared_ptr&lt;asio::ip::tcp::socket&gt; socket); void Connect(const asio::ip::tcp::endpoint&amp; ep);private: std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;&#125;; session类定义了一个socket成员变量，负责处理对端的连接读写，封装了Connect函数 123void Session::Connect(const asio::ip::tcp::endpoint &amp;ep) &#123; _socket-&gt;connect(ep);&#125; 这里只是简单意思一下，下面核心介绍异步读写api的使用 异步写操作在写操作前，我们先封装一个Node结构，用来管理要发送和接收的数据，该结构包含数据域首地址，数据的总长度，以及已经处理的长度(已读的长度或者已写的长度) 1234567891011121314151617181920212223//最大报文接收大小const int RECVSIZE = 1024;class MsgNode &#123;public : MsgNode(const char* msg, int total_len): _total_len(total_len), _cur_len(0)&#123; _msg = new char[total_len]; memcpy(_msg, msg, total_len); &#125; MsgNode(int total_len) :_total_len(total_len), _cur_len(0) &#123; _msg = new char[total_len]; &#125; ~MsgNode()&#123; delete[]_msg; &#125; //消息首地址 char* _msg; //总长度 int _total_len; //当前长度 int _cur_len;&#125;; 写了两个构造函数，两个参数的负责构造写节点，一个参数的负责构造读节点。接下来为Session添加异步写操作和负责发送写数据的节点 12345678class Session&#123;public: void WriteCallBackErr(const boost::system::error_code &amp; ec, std::size_t bytes_transferred, std::shared_ptr&lt;MsgNode&gt;); void WriteToSocketErr(const std::string&amp; buf);private: std::shared_ptr&lt;MsgNode&gt; _send_node;&#125;; WriteToSocketErr函数为我们封装的写操作，WriteCallBackErr为异步写操作回调的函数，为什么会有三个参数呢，我们可以看一下asio源码 12345678BOOST_ASIO_COMPLETION_TOKEN_FOR(void (boost::system::error_code, std::size_t)) WriteToken BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type)&gt; BOOST_ASIO_INITFN_AUTO_RESULT_TYPE_PREFIX(WriteToken, void (boost::system::error_code, std::size_t)) async_write_some(const ConstBufferSequence&amp; buffers, BOOST_ASIO_MOVE_ARG(WriteToken)token BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(executor_type)) async_write_some是异步写的函数，这个异步写函数有两个参数，第一个参数为ConstBufferSequence常引用类型的buffers，第二个参数为WriteToken类型，而WriteToken在上面定义了，是一个函数对象类型，返回值为void，参数为error_code和size_t，所以我们为了调用async_write_some函数也要传入一个符合WriteToken定义的函数，就是我们声明的WriteCallBackErr函数，前两个参数为WriteToken规定的参数，第三个参数为MsgNode的智能指针，这样通过智能指针保证我们发送的Node生命周期延长。我们看一下WriteToSocketErr函数的具体实现 12345678void Session::WriteToSocketErr(const std::string&amp; buf) &#123; _send_node = make_shared&lt;MsgNode&gt;(buf.c_str(), buf.length()); //异步发送数据，因为异步所以不会一下发送完 this-&gt;_socket-&gt;async_write_some(asio::buffer(_send_node-&gt;_msg, _send_node-&gt;_total_len), std::bind(&amp;Session::WriteCallBackErr, this, std::placeholders::_1, std::placeholders::_2, _send_node));&#125; 因为WriteCallBackErr函数为三个参数且为成员函数，而async_write_some需要的回调函数为两个参数，所以我们通过bind将三个参数转换为两个参数的普通函数。我们看看回调函数的实现 1234567891011void Session::WriteCallBackErr(const boost::system::error_code&amp; ec, std::size_t bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node) &#123; if (bytes_transferred + msg_node-&gt;_cur_len &lt; msg_node-&gt;_total_len) &#123; _send_node-&gt;_cur_len += bytes_transferred; this-&gt;_socket-&gt;async_write_some(asio::buffer(_send_node-&gt;_msg+_send_node-&gt;_cur_len, _send_node-&gt;_total_len-_send_node-&gt;_cur_len), std::bind(&amp;Session::WriteCallBackErr, this, std::placeholders::_1, std::placeholders::_2, _send_node)); &#125;&#125; 在WriteCallBackErr函数里判断如果已经发送的字节数没有达到要发送的总字节数，那么久更新节点已经发送的长度，然后计算剩余要发送的长度，如果有数据未发送完，再次调用async_write_some函数异步发送。但是这个函数并不能投入实际应用，因为async_write_some回调函数返回已发送的字节数可能并不是全部长度。比如TCP发送缓存区总大小为8字节，但是有3字节未发送(上一次未发送完)，这样剩余空间为5字节此时我们调用async_write_some发送hello world!实际发送的长度就是为5，也就是只发送了hello，剩余world!通过我们的回调继续发送。而实际开发的场景用户是不清楚底层tcp的多路复用调用情况的，用户想发送数据的时候就调用WriteToSocketErr,或者循环调用WriteToSocketErr，很可能在一次没发送完数据还未调用回调函数时再次调用WriteToSocketErr，因为boost::asio封装的时epoll和iocp等多路复用模型，当写事件就绪后就发数据，发送的数据按照async_write_some调用的顺序发送，所以回调函数内调用的async_write_some可能并没有被及时调用。比如我们如下代码 1234//用户发送数据WriteToSocketErr(&quot;Hello World!&quot;);//用户无感知下层调用情况又一次发送了数据WriteToSocketErr(&quot;Hello World!&quot;); 那么很可能第一次只发送了Hello，后面的数据没发完，第二次发送了Hello World!之后又发送了World!所以对端收到的数据很可能是”HelloHello World! World!”那怎么解决这个问题呢，我们可以通过队列保证应用层的发送顺序。我们在Session中定义一个发送队列，然后重新定义正确的异步发送函数和回调处理 123456789class Session&#123;public: void WriteCallBack(const boost::system::error_code&amp; ec, std::size_t bytes_transferred); void WriteToSocket(const std::string &amp;buf);private: std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue; std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket; bool _send_pending;&#125;; 定义了bool变量_send_pending，该变量为true表示一个节点还未发送完。_send_queue用来缓存要发送的消息节点，是一个队列。我们实现异步发送功能 12345678910111213141516171819202122232425262728293031323334353637383940414243void Session::WriteToSocket(const std::string&amp; buf)&#123; //插入发送队列 _send_queue.emplace(new MsgNode(buf.c_str(), buf.length())); //pending状态说明上一次有未发送完的数据 if (_send_pending) &#123; return; &#125; //异步发送数据，因为异步所以不会一下发送完 this-&gt;_socket-&gt;async_write_some(asio::buffer(buf), std::bind(&amp;Session::WriteCallBack, this, std::placeholders::_1, std::placeholders::_2)); _send_pending = true;&#125;void Session::WriteCallBack(const boost::system::error_code &amp; ec, std::size_t bytes_transferred)&#123; if (ec.value() != 0) &#123; std::cout &lt;&lt; &quot;Error , code is &quot; &lt;&lt; ec.value() &lt;&lt; &quot; . Message is &quot; &lt;&lt; ec.message(); return; &#125; //取出队首元素即当前未发送完数据 auto &amp; send_data = _send_queue.front(); send_data-&gt;_cur_len += bytes_transferred; //数据未发送完， 则继续发送 if (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123; this-&gt;_socket-&gt;async_write_some(asio::buffer(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len-send_data-&gt;_cur_len), std::bind(&amp;Session::WriteCallBack, this, std::placeholders::_1, std::placeholders::_2)); return; &#125; //如果发送完，则pop出队首元素 _send_queue.pop(); //如果队列为空，则说明所有数据都发送完,将pending设置为false if (_send_queue.empty()) &#123; _send_pending = false; &#125; //如果队列不是空，则继续将队首元素发送 if (!_send_queue.empty()) &#123; auto&amp; send_data = _send_queue.front(); this-&gt;_socket-&gt;async_write_some(asio::buffer(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::bind(&amp;Session::WriteCallBack, this, std::placeholders::_1, std::placeholders::_2)); &#125;&#125; async_write_some函数不能保证每次回调函数触发时发送的长度为要总长度，这样我们每次都要在回调函数判断发送数据是否完成，asio提供了一个更简单的发送函数async_send，这个函数在发送的长度未达到我们要求的长度时就不会触发回调，所以触发回调函数时要么时发送出错了要么是发送完成了,其内部的实现原理就是帮我们不断的调用async_write_some直到完成发送，所以async_send不能和async_write_some混合使用，我们基于async_send封装另外一个发送函数 123456789101112131415161718192021222324252627282930313233343536373839//不能与async_write_some混合使用void Session::WriteAllToSocket(const std::string&amp; buf) &#123; //插入发送队列 _send_queue.emplace(new MsgNode(buf.c_str(), buf.length())); //pending状态说明上一次有未发送完的数据 if (_send_pending) &#123; return; &#125; //异步发送数据，因为异步所以不会一下发送完 this-&gt;_socket-&gt;async_send(asio::buffer(buf), std::bind(&amp;Session::WriteAllCallBack, this, std::placeholders::_1, std::placeholders::_2)); _send_pending = true;&#125;void Session::WriteAllCallBack(const boost::system::error_code&amp; ec, std::size_t bytes_transferred)&#123; if (ec.value() != 0) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; ec.value() &lt;&lt; &quot;. Message: &quot; &lt;&lt; ec.message(); return; &#125; //如果发送完，则pop出队首元素 _send_queue.pop(); //如果队列为空，则说明所有数据都发送完,将pending设置为false if (_send_queue.empty()) &#123; _send_pending = false; &#125; //如果队列不是空，则继续将队首元素发送 if (!_send_queue.empty()) &#123; auto&amp; send_data = _send_queue.front(); this-&gt;_socket-&gt;async_send(asio::buffer(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::bind(&amp;Session::WriteAllCallBack, this, std::placeholders::_1, std::placeholders::_2)); &#125;&#125; 异步读操作接下来介绍异步读操作，异步读操作和异步的写操作类似同样又async_read_some和async_receive函数，前者触发的回调函数获取的读数据的长度可能会小于要求读取的总长度，后者触发的回调函数读取的数据长度等于读取的总长度。先基于async_read_some封装一个读取的函数ReadFromSocket，同样在Session类的声明中添加一些变量 123456789class Session &#123;public: void ReadFromSocket(); void ReadCallBack(const boost::system::error_code&amp; ec, std::size_t bytes_transferred);private: std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket; std::shared_ptr&lt;MsgNode&gt; _recv_node; bool _recv_pending;&#125;; _recv_node用来缓存接收的数据，_recv_pending为true表示节点正在接收数据，还未接受完。 1234567891011121314151617181920212223242526272829//不考虑粘包情况， 先用固定的字节接收void Session::ReadFromSocket() &#123; if (_recv_pending) &#123; return; &#125; //可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值 /*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE); _recv_node = _recv_nodez;*/ _recv_node = std::make_shared&lt;MsgNode&gt;(RECVSIZE); _socket-&gt;async_read_some(asio::buffer(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::bind(&amp;Session::ReadCallBack, this, std::placeholders::_1, std::placeholders::_2)); _recv_pending = true;&#125;void Session::ReadCallBack(const boost::system::error_code&amp; ec, std::size_t bytes_transferred)&#123; _recv_node-&gt;_cur_len += bytes_transferred; //没读完继续读 if (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123; _socket-&gt;async_read_some(asio::buffer(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len, _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::bind(&amp;Session::ReadCallBack, this, std::placeholders::_1, std::placeholders::_2)); return; &#125; //将数据投递到队列里交给逻辑线程处理，此处略去 //如果读完了则将标记置为false _recv_pending = false; //指针置空 _recv_node = nullptr; &#125; 我们基于async_receive再封装一个接收数据的函数 123456789101112131415161718192021void Session::ReadAllFromSocket(const std::string&amp; buf) &#123; if (_recv_pending) &#123; return; &#125; //可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值 /*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE); _recv_node = _recv_nodez;*/ _recv_node = std::make_shared&lt;MsgNode&gt;(RECVSIZE); _socket-&gt;async_receive(asio::buffer(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::bind(&amp;Session::ReadAllCallBack, this, std::placeholders::_1, std::placeholders::_2)); _recv_pending = true;&#125;void Session::ReadAllCallBack(const boost::system::error_code&amp; ec, std::size_t bytes_transferred) &#123; _recv_node-&gt;_cur_len += bytes_transferred; //将数据投递到队列里交给逻辑线程处理，此处略去 //如果读完了则将标记置为false _recv_pending = false; //指针置空 _recv_node = nullptr;&#125; 同样async_read_some和async_receive不能混合使用，否则会出现逻辑问题。 源码连接本文介绍了boost asio异步读写的操作，仅仅是代码片段和api的封装便于大家理解，下一篇利用这些异步api写一个异步的服务器展示收发效果。源码连接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"同步读写的服务器和客户端","date":"2023-04-02T03:17:55.000Z","path":"2023/04/02/asio05/","text":"简介前面我们介绍了boost::asio同步读写的api函数，现在将前面的api串联起来，做一个能跑起来的客户端和服务器。客户端和服务器采用阻塞的同步读写方式完成通信 客户端设计客户端设计基本思路是根据服务器对端的ip和端口创建一个endpoint，然后创建socket连接这个endpoint，之后就可以用同步读写的方式发送和接收数据了。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;using namespace std;using namespace boost::asio::ip;const int MAX_LENGTH = 1024;int main()&#123; try &#123; //创建上下文服务 boost::asio::io_context ioc; //构造endpoint tcp::endpoint remote_ep(address::from_string(&quot;127.0.0.1&quot;), 10086); tcp::socket sock(ioc); boost::system::error_code error = boost::asio::error::host_not_found; ; sock.connect(remote_ep, error); if (error) &#123; cout &lt;&lt; &quot;connect failed, code is &quot; &lt;&lt; error.value() &lt;&lt; &quot; error msg is &quot; &lt;&lt; error.message(); return 0; &#125; std::cout &lt;&lt; &quot;Enter message: &quot;; char request[MAX_LENGTH]; std::cin.getline(request, MAX_LENGTH); size_t request_length = strlen(request); boost::asio::write(sock, boost::asio::buffer(request, request_length)); char reply[MAX_LENGTH]; size_t reply_length = boost::asio::read(sock, boost::asio::buffer(reply, request_length)); std::cout &lt;&lt; &quot;Reply is: &quot;; std::cout.write(reply, reply_length); std::cout &lt;&lt; &quot;\\n&quot;; &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 服务器session函数创建session函数，该函数为服务器处理客户端请求，每当我们获取客户端连接后就调用该函数。在session函数里里进行echo方式的读写，所谓echo就是应答式的处理 12345678910111213141516171819202122232425262728293031323334353637void session(socket_ptr sock) &#123; try &#123; for (;;) &#123; char data[max_length]; memset(data, &#x27;\\0&#x27;, max_length); boost::system::error_code error; size_t length = sock-&gt;read_some(boost::asio::buffer(data, max_length), error); if (error == boost::asio::error::eof) &#123; std::cout &lt;&lt; &quot;connection closed by peer&quot; &lt;&lt; endl; break; &#125; else if (error) &#123; throw boost::system::system_error(error); &#125; cout &lt;&lt; &quot;receive from &quot; &lt;&lt; sock-&gt;remote_endpoint().address().to_string() &lt;&lt; endl; cout &lt;&lt; &quot;receive message is &quot; &lt;&lt; data &lt;&lt; endl; //回传信息值 boost::asio::write(*sock, boost::asio::buffer(data, length)); &#125; &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception in thread: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot; &lt;&lt; std::endl; &#125;&#125;```acceptor### server函数server函数根据服务器ip和端口创建服务器acceptor用来接收数据，用socket接收新的连接，然后为这个socket创建session。``` cppvoid server(boost::asio::io_context&amp; io_context, unsigned short port) &#123; tcp::acceptor a(io_context, tcp::endpoint(tcp::v4(), port)); for (;;) &#123; socket_ptr socket(new tcp::socket(io_context)); a.accept(*socket); auto t = std::make_shared&lt;std::thread&gt;(session, socket); thread_set.insert(t); &#125;&#125; 创建线程调用session函数可以分配独立的线程用于socket的读写，保证acceptor不会因为socket的读写而阻塞。 同步读写的优劣1 同步读写的缺陷在于读写是阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态。2 可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通过unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多。3 该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开。4 该服务器和客户端未考虑粘包处理。综上所述，是我们这个服务器和客户端存在的问题，为解决上述问题，我们在接下里的文章里做不断完善和改进，主要以异步读写改进上述方案。当然同步读写的方式也有其优点，比如客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式。使用同步读写能简化编码难度。 源码连接https://gitee.com/secondtonone1/boostasio-learn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"同步读写","date":"2023-02-13T09:29:33.000Z","path":"2023/02/13/asio04/","text":"同步写write_someboost::asio提供了几种同步写的api，write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。 1234567891011121314void wirte_to_socket(asio::ip::tcp::socket&amp; sock) &#123; std::string buf = &quot;Hello World!&quot;; std::size_t total_bytes_written = 0; //循环发送 //write_some返回每次写入的字节数 //total_bytes_written是已经发送的字节数。 //每次发送buf.length()- total_bytes_written)字节数据 while (total_bytes_written != buf.length()) &#123; total_bytes_written += sock.write_some( asio::buffer(buf.c_str()+total_bytes_written, buf.length()- total_bytes_written)); &#125;&#125; 同步写sendwrite_some使用起来比较麻烦，需要多次调用，asio提供了send函数。send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。 123456789101112131415161718192021222324252627282930int send_data_by_send()&#123; std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; try &#123; asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num); asio::io_service ios; // Step 1. Allocating and opening the socket. asio::ip::tcp::socket sock(ios, ep.protocol()); sock.connect(ep); std::string buf = &quot;Hello World!&quot;; int send_length = sock.send(asio::buffer(buf.c_str(), buf.length())); if (send_length &lt;= 0) &#123; cout &lt;&lt; &quot;send failed&quot; &lt;&lt; endl; return 0; &#125; &#125; catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125; return 0;&#125; 同步写write类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。 123456789101112131415161718192021222324252627282930int send_data_by_wirte() &#123; std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; try &#123; asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num); asio::io_service ios; // Step 1. Allocating and opening the socket. asio::ip::tcp::socket sock(ios, ep.protocol()); sock.connect(ep); std::string buf = &quot;Hello World!&quot;; int send_length = asio::write(sock, asio::buffer(buf.c_str(), buf.length())); if (send_length &lt;= 0) &#123; cout &lt;&lt; &quot;send failed&quot; &lt;&lt; endl; return 0; &#125; &#125; catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125; return 0; &#125; 同步读read_some同步读和同步写类似，提供了读取指定字节数的接口read_some 1234567891011121314151617181920212223242526272829303132333435363738394041std::string read_from_socket(asio::ip::tcp::socket&amp; sock) &#123; const unsigned char MESSAGE_SIZE = 7; char buf[MESSAGE_SIZE]; std::size_t total_bytes_read = 0; while (total_bytes_read != MESSAGE_SIZE) &#123; total_bytes_read += sock.read_some( asio::buffer(buf + total_bytes_read, MESSAGE_SIZE - total_bytes_read)); &#125; return std::string(buf, total_bytes_read);&#125;int read_data_by_read_some() &#123; std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; try &#123; asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num); asio::io_service ios; asio::ip::tcp::socket sock(ios, ep.protocol()); sock.connect(ep); read_from_socket(sock); &#125; catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125; return 0;&#125; 同步读receive可以一次性同步接收对方发送的数据 123456789101112131415161718192021222324252627282930int read_data_by_receive() &#123; std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; try &#123; asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num); asio::io_service ios; asio::ip::tcp::socket sock(ios, ep.protocol()); sock.connect(ep); const unsigned char BUFF_SIZE = 7; char buffer_receive[BUFF_SIZE]; int receive_length = sock.receive(asio::buffer(buffer_receive, BUFF_SIZE)); if (receive_length &lt;= 0) &#123; cout &lt;&lt; &quot;receive failed&quot; &lt;&lt; endl; &#125; &#125; catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125; return 0;&#125; 同步读read可以一次性同步读取对方发送的数据 123456789101112131415161718192021222324252627282930int read_data_by_read() &#123; std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; try &#123; asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num); asio::io_service ios; asio::ip::tcp::socket sock(ios, ep.protocol()); sock.connect(ep); const unsigned char BUFF_SIZE = 7; char buffer_receive[BUFF_SIZE]; int receive_length = asio::read(sock, asio::buffer(buffer_receive, BUFF_SIZE)); if (receive_length &lt;= 0) &#123; cout &lt;&lt; &quot;receive failed&quot; &lt;&lt; endl; &#125; &#125; catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125; return 0; &#125; 读取直到指定字符我们可以一直读取，直到读取指定字符结束 1234567891011121314151617std::string read_data_by_until(asio::ip::tcp::socket&amp; sock) &#123; asio::streambuf buf; // Synchronously read data from the socket until // &#x27;\\n&#x27; symbol is encountered. asio::read_until(sock, buf, &#x27;\\n&#x27;); std::string message; // Because buffer &#x27;buf&#x27; may contain some other data // after &#x27;\\n&#x27; symbol, we have to parse the buffer and // extract only symbols before the delimiter. std::istream input_stream(&amp;buf); std::getline(input_stream, message); return message; &#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"boost::asio之socket的创建和连接","date":"2023-02-09T06:12:10.000Z","path":"2023/02/09/asio03/","text":"网络编程基本流程网络编程的基本流程对于服务端是这样的服务端1）socket—-创建socket对象。 2）bind—-绑定本机ip+port。 3）listen—-监听来电，若在监听到来电，则建立起连接。 4）accept—-再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。 5）read、write—-就是收发消息了。 对于客户端是这样的客户端1）socket—-创建socket对象。 2）connect—-根据服务端ip+port，发起连接请求。 3）write、read—-建立连接后，就可发收消息了。 图示如下相关的网络编程技术可以看看我之前写的文章https://llfc.club/articlepage?id=2LXIKWJtKGblnWtHT7TplLKK6ze接下来按照上述流程，我们用boost::asio逐步介绍。 终端节点的创建所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通信.如果我们是客户端，我们可以通过对端的ip和端口构造一个endpoint，用这个endpoint和其通信。 12345678910111213141516171819202122232425262728293031int client_end_point() &#123; // Step 1. Assume that the client application has already // obtained the IP-address and the protocol port number. std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; // Used to store information about error that happens // while parsing the raw IP-address. boost::system::error_code ec; // Step 2. Using IP protocol version independent address // representation. asio::ip::address ip_address = asio::ip::address::from_string(raw_ip_address, ec); if (ec.value() != 0) &#123; // Provided IP address is invalid. Breaking execution. std::cout &lt;&lt; &quot;Failed to parse the IP address. Error code = &quot; &lt;&lt; ec.value() &lt;&lt; &quot;. Message: &quot; &lt;&lt; ec.message(); return ec.value(); &#125; // Step 3. asio::ip::tcp::endpoint ep(ip_address, port_num); // Step 4. The endpoint is ready and can be used to specify a // particular server in the network the client wants to // communicate with. return 0;&#125; 如果是服务端，则只需根据本地地址绑定就可以生成endpoint 1234567891011121314151617181920int server_end_point()&#123; // Step 1. Here we assume that the server application has //already obtained the protocol port number. unsigned short port_num = 3333; // Step 2. Create special object of asio::ip::address class // that specifies all IP-addresses available on the host. Note // that here we assume that server works over IPv6 protocol. asio::ip::address ip_address = asio::ip::address_v6::any(); // Step 3. asio::ip::tcp::endpoint ep(ip_address, port_num); // Step 4. The endpoint is created and can be used to // specify the IP addresses and a port number on which // the server application wants to listen for incoming // connections. return 0;&#125; 创建socket创建socket分为4步，创建上下文iocontext，选择协议，生成socket，打开socket。 1234567891011121314151617181920212223242526272829int create_tcp_socket() &#123; // Step 1. An instance of &#x27;io_service&#x27; class is required by // socket constructor. asio::io_context ios; // Step 2. Creating an object of &#x27;tcp&#x27; class representing // a TCP protocol with IPv4 as underlying protocol. asio::ip::tcp protocol = asio::ip::tcp::v4(); // Step 3. Instantiating an active TCP socket object. asio::ip::tcp::socket sock(ios); // Used to store information about error that happens // while opening the socket. boost::system::error_code ec; // Step 4. Opening the socket. sock.open(protocol, ec); if (ec.value() != 0) &#123; // Failed to open the socket. std::cout &lt;&lt; &quot;Failed to open the socket! Error code = &quot; &lt;&lt; ec.value() &lt;&lt; &quot;. Message: &quot; &lt;&lt; ec.message(); return ec.value(); &#125; return 0;&#125; 上述socket只是通信的socket，如果是服务端，我们还需要生成一个acceptor的socket，用来接收新的连接。 123456789101112131415161718192021222324252627282930int create_acceptor_socket() &#123; // Step 1. An instance of &#x27;io_service&#x27; class is required by // socket constructor. asio::io_context ios; // Step 2. Creating an object of &#x27;tcp&#x27; class representing // a TCP protocol with IPv6 as underlying protocol. asio::ip::tcp protocol = asio::ip::tcp::v6(); // Step 3. Instantiating an acceptor socket object. asio::ip::tcp::acceptor acceptor(ios); // Used to store information about error that happens // while opening the acceptor socket. boost::system::error_code ec; // Step 4. Opening the acceptor socket. acceptor.open(protocol, ec); if (ec.value() != 0) &#123; // Failed to open the socket. std::cout &lt;&lt; &quot;Failed to open the acceptor socket!&quot; &lt;&lt; &quot;Error code = &quot; &lt;&lt; ec.value() &lt;&lt; &quot;. Message: &quot; &lt;&lt; ec.message(); return ec.value(); &#125; return 0;&#125; 绑定acceptor对于acceptor类型的socket，服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。 12345678910111213141516171819202122232425262728293031323334int bind_acceptor_socket() &#123; // Step 1. Here we assume that the server application has // already obtained the protocol port number. unsigned short port_num = 3333; // Step 2. Creating an endpoint. asio::ip::tcp::endpoint ep(asio::ip::address_v4::any(), port_num); // Used by &#x27;acceptor&#x27; class constructor. asio::io_context ios; // Step 3. Creating and opening an acceptor socket. asio::ip::tcp::acceptor acceptor(ios, ep.protocol()); boost::system::error_code ec; // Step 4. Binding the acceptor socket. acceptor.bind(ep, ec); // Handling errors if any. if (ec.value() != 0) &#123; // Failed to bind the acceptor socket. Breaking // execution. std::cout &lt;&lt; &quot;Failed to bind the acceptor socket.&quot; &lt;&lt; &quot;Error code = &quot; &lt;&lt; ec.value() &lt;&lt; &quot;. Message: &quot; &lt;&lt; ec.message(); return ec.value(); &#125; return 0;&#125; 连接指定的端点作为客户端可以连接服务器指定的端点进行连接 123456789101112131415161718192021222324252627282930313233343536int connect_to_end() &#123; // Step 1. Assume that the client application has already // obtained the IP address and protocol port number of the // target server. std::string raw_ip_address = &quot;127.0.0.1&quot;; unsigned short port_num = 3333; try &#123; // Step 2. Creating an endpoint designating // a target server application. asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num); asio::io_context ios; // Step 3. Creating and opening a socket. asio::ip::tcp::socket sock(ios, ep.protocol()); // Step 4. Connecting a socket. sock.connect(ep); // At this point socket &#x27;sock&#x27; is connected to // the server application and can be used // to send data to or receive data from it. &#125; // Overloads of asio::ip::address::from_string() and // asio::ip::tcp::socket::connect() used here throw // exceptions in case of error condition. catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125;&#125; 服务器接收连接当有客户端连接时，服务器需要接收连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445int accept_new_connection()&#123; // The size of the queue containing the pending connection // requests. const int BACKLOG_SIZE = 30; // Step 1. Here we assume that the server application has // already obtained the protocol port number. unsigned short port_num = 3333; // Step 2. Creating a server endpoint. asio::ip::tcp::endpoint ep(asio::ip::address_v4::any(), port_num); asio::io_context ios; try &#123; // Step 3. Instantiating and opening an acceptor socket. asio::ip::tcp::acceptor acceptor(ios, ep.protocol()); // Step 4. Binding the acceptor socket to the // server endpint. acceptor.bind(ep); // Step 5. Starting to listen for incoming connection // requests. acceptor.listen(BACKLOG_SIZE); // Step 6. Creating an active socket. asio::ip::tcp::socket sock(ios); // Step 7. Processing the next connection request and // connecting the active socket to the client. acceptor.accept(sock); // At this point &#x27;sock&#x27; socket is connected to //the client application and can be used to send data to // or receive data from it. &#125; catch (system::system_error&amp; e) &#123; std::cout &lt;&lt; &quot;Error occured! Error code = &quot; &lt;&lt; e.code() &lt;&lt; &quot;. Message: &quot; &lt;&lt; e.what(); return e.code().value(); &#125;&#125; 关于buffer任何网络库都有提供buffer的数据结构，所谓buffer就是接收和发送数据时缓存数据的结构。boost::asio提供了asio::mutable_buffer 和 asio::const_buffer这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。asio::mutable_buffer用于写服务，asio::const_buffer用于读服务。但是这两个结构都没有被asio的api直接使用。对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个asio::mutable_buffer和asio::const_buffer组成的。也就是说boost::asio为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。我们可以理解为MutableBufferSequence的数据结构为std::vectorasio::mutable_buffer结构如下每隔vector存储的都是mutable_buffer的地址，每个mutable_buffer的第一个字节表示数据的长度，后面跟着数据内容。这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回asio::mutable_buffers_1 o或者asio::const_buffers_1结构的对象。如果传递给buffer()的参数是一个只读类型，则函数返回asio::const_buffers_1 类型对象。如果传递给buffer()的参数是一个可写类型，则返回asio::mutable_buffers_1 类型对象。asio::const_buffers_1和asio::mutable_buffers_1是asio::mutable_buffer和asio::const_buffer的适配器，提供了符合MutableBufferSequence和ConstBufferSequence概念的接口，所以他们可以作为boost::asio的api函数的参数使用。简单概括一下，我们可以用buffer()函数生成我们要用的缓存存储数据。比如boost的发送接口send要求的参数为ConstBufferSequence类型 12template&lt;typename ConstBufferSequence&gt;std::size_t send(const ConstBufferSequence &amp; buffers); 我们需要将”Hello Word转化为该类型” 123456void use_const_buffer() &#123; std::string buf = &quot;hello world!&quot;; asio::const_buffer asio_buf(buf.c_str(), buf.length()); std::vector&lt;asio::const_buffer&gt; buffers_sequence; buffers_sequence.push_back(asio_buf);&#125; 最终buffers_sequence就是可以传递给发送接口send的类型。但是这太复杂了，可以直接用buffer函数转化为send需要的参数类型 123void use_buffer_str() &#123; asio::const_buffers_1 output_buf = asio::buffer(&quot;hello world&quot;);&#125; output_buf可以直接传递给该send接口。我们也可以将数组转化为send接受的类型 12345void use_buffer_array()&#123; const size_t BUF_SIZE_BYTES = 20; std::unique_ptr&lt;char[] &gt; buf(new char[BUF_SIZE_BYTES]); auto input_buf = asio::buffer(static_cast&lt;void*&gt;(buf.get()), BUF_SIZE_BYTES);&#125; 对于流式操作，我们可以用streambuf，将输入输出流和streambuf绑定，可以实现流式输入和输出。 123456789101112131415161718192021void use_stream_buffer() &#123; asio::streambuf buf; std::ostream output(&amp;buf); // Writing the message to the stream-based buffer. output &lt;&lt; &quot;Message1\\nMessage2&quot;; // Now we want to read all data from a streambuf // until &#x27;\\n&#x27; delimiter. // Instantiate an input stream which uses our // stream buffer. std::istream input(&amp;buf); // We&#x27;ll read data into this string. std::string message1; std::getline(input, message1); // Now message1 string contains &#x27;Message1&#x27;.&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"visual studio配置boost库","date":"2023-02-09T03:04:37.000Z","path":"2023/02/09/asio02/","text":"boost库的安装前文介绍过boost库的安装，这里再次介绍一遍。先去官网下载boost库最新版本 https://www.boost.org/users/download/选择windows版本下载，zip和7z格式的都可以解压后文件夹下有个一个bootstrap.bat文件，双击运行会生成b2.exe然后在boost文件夹下启动cmd，执行 “.\\b2.exe toolset=gcc”编译时间和机器性能有关，执行编译过后，会在stage文件夹下生成lib文件夹，里面就是我们要用到的lib库。 visual配置boost有两种方式使用boost库，一种是配置在项目工程里，一种是配置在环境变量里，推荐配置环境变量的方式使用boost库。这里先介绍项目中配置我的boost库目录在D:\\cppsoft\\boost_1_81_0打开visualstudio 创建一个控制台工程，然后右键工程选择属性选择VC++目录—》包含目录，添加 D:\\cppsoft\\boost_1_81_0;选择VC++目录—》库目录，添加 D:\\cppsoft\\boost_1_81_0\\stage\\lib;然后我们写一段代码测试 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;boost/lexical_cast.hpp&quot;int main()&#123; using namespace std; cout &lt;&lt; &quot;Enter your weight: &quot;; float weight; cin &gt;&gt; weight; string gain = &quot;A 10% increase raises &quot;; string wt = boost::lexical_cast&lt;string&gt; (weight); gain = gain + wt + &quot; to &quot;; // string operator() weight = 1.1 * weight; gain = gain + boost::lexical_cast&lt;string&gt;(weight) + &quot;.&quot;; cout &lt;&lt; gain &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 我们运行程序可以看到运行成功了，并且弹出了窗口","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"vscode配置C++以及boost库开发环境","date":"2023-01-31T09:16:43.000Z","path":"2023/01/31/asio01/","text":"下载vscode去官网https://code.visualstudio.com/下载最新版本就可以了 下载后打开vscode，安装C++扩展目前就先配置到这里，以后的配置留给下面介绍。 下载mingw去mingw官网下载压缩包https://sourceforge.net/projects/mingw-w64/files/下载速度慢的话可以去我的网盘下载，整理了mingw和boost的安装包 链接: https://pan.baidu.com/s/1IJSyQqdf-lbuFG12FhDt2A?pwd=2dhi提取码: 2dhi 选择x86_64-win32-seh,当然选择x86_64-posix-seh也可以。一个是windows线程，一个是posix线程。下载后解压缩到指定文件夹，我的目录为 D:\\cppsoft\\mingw64配置环境变量，选择用户的环境变量path, 添加D:\\cppsoft\\mingw64\\bin，具体路径看你自己的配置测试是否配置成功，打开cmd，在里面输入g++或者gcc，如果输出no input files 则说明配置成功 配置vscode C++开发环境主要分为配置编译器信息，配置构建任务task.json以及配置调试设置lauch.json文件三个步骤。 配置编译器信息在vscode界面按住Ctrl + Shift + P 唤出配置界面在输入栏输入C/C+， 选择“Edit Configurations(UI)”进入配置配置编译器路径和IntelliSense模式,我的路径是D:/mingw64/bin/g++.exe另外要注意配置Include path,其他人的博客很少提及这点，这里着重说一下上述情况配置好include路径后，包含第三方库才不会报错，否则会有错误提示。ctrl+s保存后会生成一个.vscode文件夹，.vscode文件夹里有一个c_cpp_properties.json文件，记录了我们配置的编译器信息。json文件信息如下 123456789101112131415161718192021&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;windowsSdkVersion&quot;: &quot;10.0.22000.0&quot;, &quot;compilerPath&quot;: &quot;D:/mingw64/bin/g++.exe&quot;, &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot; &#125; ], &quot;version&quot;: 4&#125; 配置构建任务配置任务之前我们先写一个.cpp和.h文件用来测试，组织形式如下然后选中左侧目录树的cpp文件，保证我们所有的配置都是基于cpp构建的。接下来，创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用g++编译器基于源代码创建可执行文件。 按快捷键Ctrl+Shift+P调出命令面板，输入tasks，选择“Tasks:Configure Default Build Task”：可以看到vscode列举出我的电脑已经安装的所有C++编译器，这里选择再选择“C/C++: g++.exe build active file”,这是我们刚刚安装的mingw编译器点击后vscode为我们自动生成了task.json文件详细的task.json配置信息如下 12345678910111213141516171819202122232425262728&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe build active file&quot;, &quot;command&quot;: &quot;D:/mingw64/bin/g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:/mingw64/bin&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;compiler: D:/mingw64/bin/g++.exe&quot; &#125; ]&#125; 配置调试设置同样选中左侧目录树的cpp文件，保证我们所有的配置都是基于cpp构建的。这里主要是为了在.vscode文件夹中产生一个launch.json文件，用来配置调试的相关信息。点击菜单栏的Debug–&gt;Start Debugging：接下来选择C++(GDB/LLDB), 当然你选择windows的也可以。紧接着会产生一个launch.json的文件。这里有的人没有生成launch.json文件，而是直接运行成功了，可以不配置launch.json文件了。如果生成launch.json文件，则如下 1234567&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: []&#125; 如果想生成launch.json还有一个办法，就是点击Run选择Add Configuration, 就可以生成launch.json文件了。关于launch.json文件的配置可以参考官方文档，大家可以直接用我的配置如下 1234567891011121314151617181920212223242526&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //修改此项，让其弹出终端 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\cppsoft\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;task g++&quot; //修改此项 &#125; ]&#125; miDebuggerPath 改为你自己的mingw路径preLaunchTask 为任务名字，你可以自己定义一个任务名字，任务名字要和task.json中的label相匹配。我的名字为”task g++”，那么我会将task.json中的label也改为”task g++”。我的task.json文件如下 12345678910111213141516171819202122232425262728&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;task g++&quot;, &quot;command&quot;: &quot;D:/mingw64/bin/g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;$&#123;cwd&#125;//src//*.cpp&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:/mingw64/bin&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;compiler: D:/mingw64/bin/g++.exe&quot; &#125; ]&#125; 我们修改了label为”task g++” 我们修改了args中的-g选项为”${cwd}//src//*.cpp”选择test.cpp再次运行，程序通过。安装boost库先去官网下载boost库最新版本https://www.boost.org/users/download/选择windows版本下载，zip和7z格式的都可以解压后文件夹下有个一个bootstrap.bat文件，双击运行会生成b2.exe然后在boost文件夹下启动cmd，执行 “.\\b2.exe toolset=gcc”编译时间和机器性能有关，执行编译过后，会在stage文件夹下生成lib文件夹，里面就是我们要用到的lib库。接下来需要将boost文件夹下的staget文件夹下的lib文件夹下的库放到mingw的文件夹下x86_64-w64-mingw32的文件夹下的lib文件夹内。我的目录就是从”D:\\TSBrowserDownloads\\boost_1_81_0\\stage\\lib”复制到”D:\\mingw64\\x86_64-w64-mingw32\\lib”。同时也要把boost的头文件从boost文件夹下拷贝到x86_64-w64-mingw32的include文件夹下也就是从”D:\\TSBrowserDownloads\\boost_1_81_0\\boost”拷贝到D:\\mingw64\\x86_64-w64-mingw32\\include测试boost库需要对已经配置完成的boost库进行测试，我们写一个程序, 替换原来的test.cpp的main函数 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;boost/lexical_cast.hpp&quot; int main()&#123; using namespace std; cout &lt;&lt; &quot;Enter your weight: &quot;; float weight; cin &gt;&gt; weight; string gain = &quot;A 10% increase raises &quot;; string wt = boost::lexical_cast&lt;string&gt; (weight); gain = gain + wt + &quot; to &quot;; // string operator() weight = 1.1 * weight; gain = gain + boost::lexical_cast&lt;string&gt;(weight) + &quot;.&quot;; cout &lt;&lt; gain &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 我们点击调试的三角符号或者菜单里的run命令，可以看到运行成功了，并且弹出了窗口 总结我将配置好的项目demo提交到gitee了，感兴趣的可以看一看项目地址https://gitee.com/secondtonone1/testvscpp","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"QT 实现电子相册(五)--实现幻灯片的暂停和切换","date":"2023-01-31T02:26:11.000Z","path":"2023/01/31/qt26/","text":"状态切换按钮我们之前制作过按钮类为PicButton，但是这次我们要制作另外一个按钮类，主要是实现状态切换，比如当前是播放状态，那么按钮就显示出暂停的图标，点击暂停后切换为播放的图标。同时还要支持滑动，点击，正常的三种效果。PicStateBtn构造函数 123PicStateBtn::PicStateBtn(QWidget *parent ):QPushButton (parent)&#123;&#125; 添加一个函数设置播放状态和暂停状态的图标 123456789101112131415161718void PicStateBtn::SetIcons(const QString &amp;normal, const QString &amp;hover, const QString &amp;pressed, const QString &amp;normal_2, const QString &amp;hover_2, const QString &amp;pressed_2)&#123; _normal = normal; _hover = hover; _pressed = pressed; _normal_2 = normal_2; _hover_2 = hover_2; _pressed_2 = pressed_2; QPixmap tmpPixmap; tmpPixmap.load(normal); this-&gt;resize(tmpPixmap.size()); this-&gt;setIcon(tmpPixmap); this-&gt;setIconSize(tmpPixmap.size()); _cur_state = PicBtnStateNormal;&#125; normal,hover,pressed分别表示播放状态正常，悬浮，点击的效果。_normal_2，_hover_2，_pressed_2分别表示暂停状态正常，悬浮，点击的效果。_cur_state表示现在是上述六种状态的哪一种，具体定义在const.h文件里 12345678enum PicBtnState &#123; PicBtnStateNormal = 1, PicBtnStateHover = 2, PicBtnStatePress = 3, PicBtnState2Normal = 4, PicBtnState2Hover = 5, PicBtnState2Press = 6,&#125;; 对应的我们实现了六种状态的加载函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void PicStateBtn::setNormalIcon()&#123; qDebug()&lt;&lt;&quot;setNormalIcon _normal &quot; &lt;&lt; _normal &lt;&lt; endl; QPixmap tmpPixmap; tmpPixmap.load(_normal); this-&gt;setIcon(tmpPixmap); _cur_state = PicBtnStateNormal;&#125;void PicStateBtn::setHoverIcon()&#123; qDebug()&lt;&lt;&quot;setHoverIcon _hover &quot; &lt;&lt; _hover &lt;&lt; endl; QPixmap tmpPixmap; tmpPixmap.load(_hover); this-&gt;setIcon(tmpPixmap); _cur_state = PicBtnStateHover;&#125;void PicStateBtn::setPressIcon()&#123; qDebug()&lt;&lt;&quot;setPressIcon _pressed &quot; &lt;&lt; _pressed &lt;&lt; endl; QPixmap tmpPixmap; tmpPixmap.load(_pressed); this-&gt;setIcon(tmpPixmap); _cur_state = PicBtnStatePress;&#125;void PicStateBtn::setNormal2Icon()&#123; qDebug()&lt;&lt;&quot;setPressIcon _normal_2 &quot; &lt;&lt; _normal_2 &lt;&lt; endl; QPixmap tmpPixmap; tmpPixmap.load(_normal_2); this-&gt;setIcon(tmpPixmap); _cur_state = PicBtnState2Normal;&#125;void PicStateBtn::setHover2Icon()&#123; qDebug()&lt;&lt;&quot;setPressIcon _hover_2 &quot; &lt;&lt; _hover_2 &lt;&lt; endl; QPixmap tmpPixmap; tmpPixmap.load(_hover_2); this-&gt;setIcon(tmpPixmap); _cur_state = PicBtnState2Hover;&#125;void PicStateBtn::setPress2Icon()&#123; qDebug()&lt;&lt;&quot;setPressIcon _pressed_2 &quot; &lt;&lt; _pressed_2 &lt;&lt; endl; QPixmap tmpPixmap; tmpPixmap.load(_pressed_2); this-&gt;setIcon(tmpPixmap); _cur_state = PicBtnState2Press;&#125; 接下来实现鼠标滑动，点击，以及正常效果的切换，我们重写event 12345678910111213141516171819202122232425262728293031323334353637383940bool PicStateBtn::event(QEvent *event)&#123; switch (event-&gt;type()) &#123; case QEvent::Enter: if(_cur_state &lt; PicBtnState2Normal)&#123; setHoverIcon(); &#125;else&#123; setHover2Icon(); &#125; break; case QEvent::Leave: if(_cur_state &lt; PicBtnState2Normal)&#123; setNormalIcon(); &#125;else&#123; setHover2Icon(); &#125; break; case QEvent::MouseButtonPress: if(_cur_state &lt; PicBtnState2Normal)&#123; setPressIcon(); &#125;else&#123; setPress2Icon(); &#125; break; case QEvent::MouseButtonRelease: if(_cur_state &lt; PicBtnState2Normal)&#123; setHover2Icon(); &#125;else&#123; setHoverIcon(); &#125; break; default: break; &#125; return QPushButton::event(event);&#125; 上述根据现在是播放状态还是暂停状态，再根据鼠标事件设置图标。另外我们需要实现开始和暂停的切换效果，所以新增两个槽函数 123456789void PicStateBtn::SlotStart()&#123; setNormal2Icon();&#125;void PicStateBtn::SlotStop()&#123; setNormalIcon();&#125; 我们回到SlideShowDlg.ui文件，将playBtn升级为PicStateBtn。然后在SlideShowDlg的构造函数里为按钮设置图标，并且将PicAnimationWid的SigStart和SigStop信号与之连接起来 12345ui-&gt;playBtn-&gt;SetIcons(&quot;:/icon/play.png&quot;,&quot;:/icon/play_hover.png&quot;,&quot;:/icon/play_press.png&quot;, &quot;:/icon/pause.png&quot;,&quot;:/icon/pause_hover.png&quot;,&quot;:/icon/pause_press.png&quot;);//连接动画和按钮显示状态connect(ui-&gt;picAnimation,&amp;PicAnimationWid::SigStart, ui-&gt;playBtn, &amp;PicStateBtn::SlotStart);connect(ui-&gt;picAnimation,&amp;PicAnimationWid::SigStop, ui-&gt;playBtn, &amp;PicStateBtn::SlotStop); 这样动画一开始按钮就被设置为暂停图标，表示动画正在运行，点击暂停图标又会切换为运行图标，表示动画已经暂停。 关闭按钮SlideShowDlg的关闭按钮比较影响体验，我们隐藏边框上的按钮，在构造函数里添加 1this-&gt;setWindowFlags(Qt::Dialog|Qt::FramelessWindowHint); 升级SlideShowDlg的ui文件中的closeBtn为PicButton,并且在构造函数里添加加载图标的逻辑和信号连接。 1234ui-&gt;closeBtn-&gt;SetIcons(&quot;:/icon/closeshow.png&quot;,&quot;:/icon/closeshow_hover.png&quot;, &quot;:/icon/closeshow_press.png&quot;); //连接关闭按钮 connect(ui-&gt;closeBtn, &amp;QPushButton::clicked, this, &amp;SlideShowDlg::close); 这样就能响应关闭按钮的事件了。 切换跳转我们需要点击向前和向后按钮，实现动画图片的切换，这里先升级SlideShowDlg的ui文件中的slidenextBtn和slidpreBtn按钮为PicButton然后在构造函数添加加载逻辑和信号连接 1234567891011ui-&gt;slidpreBtn-&gt;SetIcons(&quot;:/icon/previous.png&quot;, &quot;:/icon/previous_hover.png&quot;, &quot;:/icon/previous_press.png&quot;);ui-&gt;slidenextBtn-&gt;SetIcons(&quot;:/icon/next.png&quot;, &quot;:/icon/next_hover.png&quot;, &quot;:/icon/next_press.png&quot;);//连接向后查看按钮connect(ui-&gt;slidenextBtn, &amp;QPushButton::clicked,this,&amp;SlideShowDlg::SlotSlideNext);//连接向前查看按钮connect(ui-&gt;slidpreBtn, &amp;QPushButton::clicked,this,&amp;SlideShowDlg::SlotSlidePre); 这两个槽函数内部调用了PicAnimationWid的SlideNext和SlidePre 123456789void SlideShowDlg::SlotSlideNext()&#123; ui-&gt;picAnimation-&gt;SlideNext();&#125;void SlideShowDlg::SlotSlidePre()&#123; ui-&gt;picAnimation-&gt;SlidePre();&#125; PicAnimationWid的两个函数分别实现图片的切换 1234567891011121314151617181920212223242526272829303132void PicAnimationWid::SlideNext()&#123; Stop(); if(!_cur_item)&#123; return; &#125; auto * cur_pro_item = dynamic_cast&lt;ProTreeItem*&gt;(_cur_item); auto * next_item = cur_pro_item-&gt;GetNextItem(); if(!next_item)&#123; return; &#125; SetPixmap(next_item); update();&#125;void PicAnimationWid::SlidePre()&#123; Stop(); if(!_cur_item)&#123; return; &#125; auto * cur_pro_item = dynamic_cast&lt;ProTreeItem*&gt;(_cur_item); auto * pre_item = cur_pro_item-&gt;GetPreItem(); if(!pre_item)&#123; return; &#125; SetPixmap(pre_item); update();&#125; 切换后动画暂停，变为显示图片的状态。为了美观，我们完善一下qss 123456789101112131415161718192021222324252627282930313233#preListWidget &#123; color:rgb(231,231,231); background-color:rgb(46,47,48); border: 0px;&#125;#preListWidget::item:hover &#123; background: rgb(38, 95, 153);&#125;#preListWidget::item:selected &#123; background: rgb(38, 95, 153);&#125;#slidpreBtn,#slidenextBtn,#playBtn &#123; border: 0px;&#125;#slideprewid &#123; margin-left:10px;&#125;#slidenextwid&#123; margin-right:10px;&#125;#preListWidget::item:selected:active&#123; border: 2px solid #FFFFFF;&#125;#preListWidget::item:selected&#123; border: 2px solid #FFFFFF;&#125; 将按钮设置为无边框，然后设置了preListWidget的边框和边距等信息。 添加音乐为了让动画播放过程中能够播放音乐，我们在mainwindow的菜单里添加音乐菜单。 123456//设置背景音乐动作 QAction * act_music = new QAction(QIcon(&quot;:/icon/music.png&quot;), tr(&quot;背景音乐&quot;),this); act_music-&gt;setShortcut(QKeySequence(Qt::CTRL + Qt::Key_M)); menu_set-&gt;addAction(act_music); //设置音乐 connect(act_music, &amp;QAction::triggered, pro_tree_widget, &amp;ProTreeWidget::SlotSetMusic); 在打开音乐的槽函数里弹出一个文件夹对话框 1234567891011121314151617181920212223242526272829303132void ProTreeWidget::SlotSetMusic(bool)&#123; qDebug() &lt;&lt; &quot;SlotSetMusic&quot; &lt;&lt;endl; QFileDialog file_dialog; file_dialog.setFileMode(QFileDialog::ExistingFiles); file_dialog.setWindowTitle(&quot;选择导入的文件夹&quot;); file_dialog.setDirectory(QDir::currentPath()); file_dialog.setViewMode(QFileDialog::Detail); file_dialog.setNameFilter(&quot;(*.mp3)&quot;); QStringList fileNames; if (file_dialog.exec())&#123; fileNames = file_dialog.selectedFiles(); &#125; if(fileNames.length() &lt;= 0)&#123; return; &#125; _playlist-&gt;clear(); for(auto filename : fileNames)&#123; qDebug() &lt;&lt; &quot;filename is &quot; &lt;&lt; filename &lt;&lt; endl; _playlist-&gt;addMedia(QUrl::fromLocalFile(filename)); &#125; if(_player-&gt;state()!=QMediaPlayer::PlayingState) &#123; _playlist-&gt;setCurrentIndex(0); &#125;&#125; 文件夹对话框返回选择的文件列表，我们将文件列表加入播放列表_playlist。然后通过判断_player的状态设置索引。_player为QMediaPlayer类型，_playlist为QMediaPlaylist类型，我们需要在pro里添加multimedia才能使用。 1QT += core gui multimedia 另外要在protreewidget头文件包含 12#include&lt;QtMultimedia/QMediaPlayer&gt;#include&lt;QtMultimedia/QMediaPlaylist&gt; 然后在SlideShowDlg的构造函数添加播放音乐和停止音乐的槽函数 123456//连接音乐启动信号 connect(ui-&gt;picAnimation, &amp;PicAnimationWid::SigStartMusic, _protree_widget, &amp;ProTreeWidget::SlotStartMusic); //连接音乐关闭信号 connect(ui-&gt;picAnimation,&amp;PicAnimationWid::SigStopMusic, _protree_widget, &amp;ProTreeWidget::SlotStopMusic); 播放音乐和停止音乐逻辑很简单 1234567891011void ProTreeWidget::SlotStartMusic()&#123; qDebug()&lt;&lt; &quot;ProTreeWidget::SlotStartMusic&quot; &lt;&lt; endl; _player-&gt;play();&#125;void ProTreeWidget::SlotStopMusic()&#123; qDebug()&lt;&lt; &quot;ProTreeWidget::SlotStopMusic&quot; &lt;&lt; endl; _player-&gt;pause();&#125; 到此为止就完成了动画播放的所有逻辑，这里是整体效果图 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 实现电子相册(四)--实现播放动画","date":"2023-01-30T02:09:53.000Z","path":"2023/01/30/qt25/","text":"简介前问提到了PicAnimationWid，PicButton，PreListWid等类，这里介绍如何实现这些类，并串联起来达到幻灯片放映的效果。 SlideShowDlg在左侧目录树右击时弹出菜单，新增幻灯片播放的选项，点击后会弹出SlideShowDlg。SlideShowDlg的构造函数如下 123456SlideShowDlg::SlideShowDlg(QWidget *parent, QTreeWidgetItem *first_item, QTreeWidgetItem *last_item): QDialog(parent), ui(new Ui::SlideShowDlg),_first_item(first_item),_last_item(last_item)&#123; ui-&gt;setupUi(this);&#125; _first_item表示播放的第一个item_last_item表示播放的最后一个item先将slideshow展示出来看看效果，所以在ProTreeWidget的构造函数里添加动作 12_action_slideshow = new QAction(QIcon(&quot;:/icon/slideshow.png&quot;), tr(&quot;轮播图播放&quot;),this);connect(_action_slideshow, &amp;QAction::triggered, this, &amp;ProTreeWidget::SlotSlideShow); 在点击槽函数里完善右键点击逻辑 12345678910111213141516171819void ProTreeWidget::SlotItemPressed(QTreeWidgetItem *pressedItem, int column)&#123; qDebug() &lt;&lt; &quot;ProTreeWidget::SlotItemPressed&quot; &lt;&lt; endl; if(QGuiApplication::mouseButtons() == Qt::RightButton) //判断是否为右键 &#123; QMenu menu(this); qDebug() &lt;&lt; &quot;menu addr is &quot; &lt;&lt; &amp;menu &lt;&lt; endl; int itemtype = (int)(pressedItem-&gt;type()); if (itemtype == TreeItemPro) &#123; _right_btn_item = pressedItem; menu.addAction(_action_import); menu.addAction(_action_setstart); menu.addAction(_action_closepro); menu.addAction(_action_slideshow); menu.exec(QCursor::pos()); //菜单弹出位置为鼠标点击位置 &#125; &#125;&#125; 实现槽函数SlotSlideShow,n内部创建一个SlideShowDlg智能指针对象，然后设置为模态对话框，并且最大化显示。 12345678910111213141516171819202122232425void ProTreeWidget::SlotSlideShow()&#123; if(!_right_btn_item)&#123; return; &#125; auto *right_pro_item = dynamic_cast&lt;ProTreeItem*&gt;(_right_btn_item); auto * last_child_item = right_pro_item-&gt;GetLastPicChild(); if(!last_child_item)&#123; return; &#125; qDebug()&lt;&lt; &quot;last child item name is &quot; &lt;&lt; last_child_item-&gt;GetPath()&lt;&lt; endl; auto * first_child_item = right_pro_item-&gt;GetFirstPicChild(); if(!first_child_item)&#123; return; &#125; qDebug()&lt;&lt; &quot;first child item name is &quot; &lt;&lt; first_child_item-&gt;GetPath()&lt;&lt; endl; _slide_show_dlg = std::make_shared&lt;SlideShowDlg&gt;(this, first_child_item, last_child_item); _slide_show_dlg-&gt;setModal(true); _slide_show_dlg-&gt;showMaximized();&#125; SlotSlideShow里根据right_pro_item获取当前项目下第一个子item和最后一个子item，这个算法并不复杂，right_pro_item为项目的root item，所以可以递归的获取root下第一个非文件夹item节点和最后一个非文件夹item节点。遍历根目录所有一级子节点，如果第一个一级子节点为文件夹则递归查找，直到找到，如果第一个一级子节点下不存在图片类型的item，那么 123456789101112131415161718192021222324252627282930ProTreeItem *ProTreeItem::GetFirstPicChild()&#123; if(this-&gt;type() == TreeItemPic)&#123; return nullptr; &#125; auto child_count = this-&gt;childCount(); if(child_count == 0)&#123; return nullptr; &#125; for(int i = 0; i &lt; child_count-1; i++)&#123; auto * first_child = this-&gt;child(i); auto * first_tree_child = dynamic_cast&lt;ProTreeItem*&gt;(first_child); auto item_type = first_tree_child-&gt;type(); if(item_type == TreeItemPic)&#123; return first_tree_child; &#125; first_child = first_tree_child-&gt;GetFirstPicChild(); if(!first_child)&#123; continue; &#125; first_tree_child = dynamic_cast&lt;ProTreeItem*&gt;(first_child); return first_tree_child; &#125; return nullptr;&#125; 获取最后一个子节点逻辑类似 123456789101112131415161718192021222324252627282930ProTreeItem *ProTreeItem::GetLastPicChild()&#123; if(this-&gt;type() == TreeItemPic)&#123; return nullptr; &#125; auto child_count = this-&gt;childCount(); if(child_count == 0)&#123; return nullptr; &#125; for(int i = child_count-1; i &gt;= 0; i--)&#123; auto* last_child = this-&gt;child(i); auto * last_tree_item = dynamic_cast&lt;ProTreeItem*&gt;(last_child); int item_type = last_tree_item-&gt;type(); if(item_type == TreeItemPic)&#123; return last_tree_item; &#125; last_child = last_tree_item-&gt;GetLastPicChild(); if(!last_child)&#123; continue; &#125; last_tree_item = dynamic_cast&lt;ProTreeItem*&gt;(last_child); return last_tree_item; &#125; return nullptr;&#125; 此时点击幻灯片播放菜单就会弹出这个对话框了，为了样式美观我们添加qss样式 1234SlideShowDlg &#123; color:rgb(231,231,231); background-color:rgb(46,47,48);&#125; PicAnimationWid接下来我们需要在SlideShowDlg的动画区域添加动画逻辑，类PicAnimationWid为图片动画展示窗口，继承于QWidget，构造函数比较简单 123456PicAnimationWid::PicAnimationWid(QWidget *parent) : QWidget(parent),_factor(0.0), _cur_item(nullptr),_b_start(false)&#123; _timer = new QTimer(this); connect(_timer, &amp;QTimer::timeout, this, &amp;PicAnimationWid::TimeOut);&#125; _factor为动画因子，控制图片渐隐效果 _b_start控制动画是否播放 _cur_item 表示当前要绘制显示的ProTreeItem对象。 启动了一个定时器，然后定时回调TimeOut函数同样的道理析构函数需要实现定时器的停止1234PicAnimationWid::~PicAnimationWid()&#123; _timer-&gt;stop(); // delete _timer;&#125; 定时器回调函数1234567891011121314151617181920212223242526void PicAnimationWid::TimeOut()&#123; if(!_cur_item)&#123; Stop(); update(); return; &#125; //qDebug()&lt;&lt;&quot;_factor is &quot; &lt;&lt; _factor &lt;&lt; endl; _factor = _factor+0.01; if(_factor &gt;= 1)&#123; _factor = 0; auto * cur_pro_item = dynamic_cast&lt;ProTreeItem*&gt;(_cur_item); auto * next_pro_item = cur_pro_item-&gt;GetNextItem(); if(!next_pro_item)&#123; Stop(); update(); return; &#125; SetPixmap(next_pro_item); update(); return; &#125; update();&#125; 该函数每次对factor增加0.01,进而控制动画，如果factor变为1说明已经完成一张图片的消失和另一张的展示，需要更新下一组两张图片用来做渐隐渐现的效果。update函数是基类的刷新函数，会触发paintEvent函数，这个函数功能之后介绍。先介绍SetPixmap函数，该函数用来加载两张图片做渐变效果。实现SetPixmap设置要绘制的图片123456789101112131415161718192021222324252627282930void PicAnimationWid::SetPixmap(QTreeWidgetItem *item)&#123; if(!item)&#123; return; &#125; auto * tree_item = dynamic_cast&lt;ProTreeItem*&gt;(item); auto path = tree_item-&gt;GetPath(); _pixmap1.load(path); _cur_item = tree_item; if(_map_items.find(path) == _map_items.end())&#123; _map_items[path]=tree_item; qDebug() &lt;&lt; &quot;SetPixmap path is &quot; &lt;&lt; path &lt;&lt; endl; emit SigUpPreList(item); &#125; emit SigSelectItem(item); auto * next_item = tree_item-&gt;GetNextItem(); if(!next_item)&#123; return; &#125; auto next_path = next_item-&gt;GetPath(); _pixmap2.load(next_path); if(_map_items.find(next_path) == _map_items.end())&#123; _map_items[next_path] = next_item; emit SigUpPreList(next_item); &#125;&#125; 因为要双缓冲绘图，所以要缓存两张图片，用_pixmap1和_pixmap2缓存。实现_pixmap1渐隐，_pixmap2渐现。SigUpPreList信号是用来通知下方预览框更新预览图，因为我们要做的是上方播放动画后，下方会更新预览图。当前正在播放的图在下方预览图有选中提示，所以SigSelectItem信号是用来通知下方预览图选中效果。接下来要实现开始函数，让动画动起来12345678void PicAnimationWid::Start()&#123; emit SigStart(); emit SigStartMusic(); _factor = 0; _timer-&gt;start(25); _b_start = true;&#125; SigStart信号用来通知右上方按钮的显示播放还是暂停状态，之后在处理信号连接问题。 _factor为动画因子 _b_start被设置为true 定时器每隔25ms更新一次 SigStartMusic信号用来更新音乐，之后再处理信号连接问题。 同样实现一个停止动画的逻辑 12345678void PicAnimationWid::Stop()&#123; emit SigStop(); emit SigStopMusic(); _timer-&gt;stop(); _factor = 0; _b_start = false;&#125; 我们接下来要实现双缓冲绘图的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void PicAnimationWid::paintEvent(QPaintEvent *event)&#123; if(_pixmap1.isNull())&#123; return; &#125; QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing, true); QRect rect = geometry(); int w = rect.width(); int h = rect.height(); _pixmap1=_pixmap1.scaled(w,h,Qt::KeepAspectRatio); int alpha = 255 * (1.0f - _factor); //qDebug()&lt;&lt;&quot;_pixmap1.size()&quot; &lt;&lt; _pixmap1.size() &lt;&lt; endl; QPixmap alphaPixmap(_pixmap1.size()); alphaPixmap.fill(Qt::transparent); QPainter p1(&amp;alphaPixmap); p1.setCompositionMode(QPainter::CompositionMode_Source); p1.drawPixmap(0, 0, _pixmap1); p1.setCompositionMode(QPainter::CompositionMode_DestinationIn); p1.fillRect(alphaPixmap.rect(), QColor(0, 0, 0, alpha)); p1.end(); int x = (w - _pixmap1.width()) / 2; int y = (h - _pixmap1.height()) / 2; painter.drawPixmap(x, y, alphaPixmap); if(_pixmap2.isNull())&#123; return; &#125; _pixmap2=_pixmap2.scaled(w,h,Qt::KeepAspectRatio); alpha = 255 * (_factor); QPixmap alphaPixmap2(_pixmap2.size()); alphaPixmap2.fill(Qt::transparent); QPainter p2(&amp;alphaPixmap2); p2.setCompositionMode(QPainter::CompositionMode_Source); p2.drawPixmap(0, 0, _pixmap2); p2.setCompositionMode(QPainter::CompositionMode_DestinationIn); p2.fillRect(alphaPixmap2.rect(), QColor(0, 0, 0, alpha)); p2.end(); x = (w - _pixmap2.width()) / 2; y = (h - _pixmap2.height()) / 2; painter.drawPixmap(x, y, alphaPixmap2);&#125; 所谓双缓冲绘图逻辑如下： 提前加载好图片的两个pixmap分别为_pixmap1和_pixmap2。然后基于现在的widget大小做等比拉伸。 创建两个pixmap用作遮盖，分别为alphaPixmap和alphaPixmap2，将他们填充为透明的颜色。 分别创建两个画刷，然后绑定alphaPixmap和alphaPixmap2，用画刷分别绘制_pixmap1和_pixmap2。 CompositionMode_DestinationIn表示遮罩的模式为显示重叠区域，CompositionMode_Source表示原图的绘制模式。 最后根据alpha值分别p2和p1的两个矩形区域设置透明度。 最后统一用一个painter分别绘制两个alphaPixmap和alphaPixmap2。 我们回到SlideShowDlg的ui文件，将动画显示区的widget升级为PicAnimationWid类即可。然后在其构造函数里添加对动画区域的调用 12ui-&gt;picAnimation-&gt;SetPixmap(_first_item);ui-&gt;picAnimation-&gt;Start(); 然后我们运行程序右键目录树的root项目选择幻灯片播放就可以看到动画效果了。 预览图类PreListWidPreListWid类是从QListWidget派生而来。我们将SlideShowDlg中的preListWidget升级为PreListWid类型。然后在ui文件中设置其高度为固定的110，因为之前我们设置其父窗口widget高度为固定的120，之后再设置其最大宽度为1677215，一个很大的数，列表不换行。属性配置如下 构造函数1234567PreListWid::PreListWid(QWidget *parent):QListWidget(parent),_global(0),_last_index(17)&#123; this-&gt;setViewMode(QListWidget::IconMode);//设置内容为图片 this-&gt;setIconSize(QSize(PREICON_SIZE, PREICON_SIZE));//设置图片的大小 this-&gt;setSpacing(5);//设置每个item之间的间隔大小 connect(this,&amp;PreListWid::itemPressed, this, &amp;PreListWid::SlotItemPressed);&#125; 构造函数里设置视图模式为图片模式 _global为计数器，统计累计加入列表的item数量，为每个item生成计数id。 _last_index为上一次选择的item的id，因为全屏模式下列表框最多显示17个item，那么初始为17。该变量主要用于控制PreListWid是否横向移动，以及移动多少像素，因为上方展示的图片在下方的预览图可能在屏幕外，所以要移动PreListWid做显示效果。 连接了PreListWid的itemPressed信号，所以当item被点击后会触发SlotItemPressed函数。 PreListItem为了实现我们自己的功能，所以PreListWid的item要自己实现，PreListItem继承于QListWidgetItem类。其基本功能包括 12345678910111213141516PreListItem::PreListItem(const QIcon &amp;icon, const QString &amp;text,const int &amp;index, QListWidget *view , int type ): QListWidgetItem (icon,&quot;&quot;,view,type),_path(text),_index(index)&#123;&#125;int PreListItem::GetIndex()&#123; return _index;&#125;QString PreListItem::GetPath()&#123; return _path;&#125; _path表示item代表的文件路径_index表示item的索引，也就是之前提到的id 动画区域和预览区域联动为使动画区域和预览区域联动，在SlideShowDlg的构造函数里添加信号和槽函数连接逻辑 123456auto * prelistWid = dynamic_cast&lt;PreListWid*&gt;(ui-&gt;preListWidget);connect(ui-&gt;picAnimation, &amp;PicAnimationWid::SigUpPreList, prelistWid,&amp;PreListWid::SlotUpPreList);connect(ui-&gt;picAnimation, &amp;PicAnimationWid::SigSelectItem, prelistWid, &amp;PreListWid::SlotUpSelect); //连接下方预览条点击与上方动画区图片显示 connect(prelistWid, &amp;PreListWid::SigUpSelectShow, ui-&gt;picAnimation, &amp;PicAnimationWid::SlotUpSelectShow); 连接了PicAnimationWid的SigUpPreList信号，可以实现上面动画播放时将图像的预览图添加到列表中的效果。 连接了PicAnimationWid的SigSelectItem信号，可以实现上面动画播放时根据图像显示预览图选中效果。 连接了PreListWid的SigUpSelectShow信号，可以实现点击下方预览图，上方显示对应的动画效果。 先实现添加逻辑 1234567891011121314151617void PreListWid::SlotUpPreList(QTreeWidgetItem *tree_item)&#123; if(!tree_item)&#123; qDebug() &lt;&lt; &quot;tree_item is empty&quot; &lt;&lt; endl; return; &#125; auto * pro_item = dynamic_cast&lt;ProTreeItem*&gt;(tree_item); auto path = pro_item-&gt;GetPath(); auto iter = _set_items.find(path); if(iter != _set_items.end())&#123; qDebug() &lt;&lt; &quot;path &quot; &lt;&lt;path&lt;&lt; &quot; exists&quot; &lt;&lt; endl; return; &#125; AddListItem(path);&#125; 根据传入的tree_item判断路径是否存在，如果存在则返回，不存在则调用AddListItem将item加入listwidget里。 12345678910111213141516171819202122232425262728void PreListWid::AddListItem(const QString &amp;path)&#123; QPixmap src_pixmap(path); src_pixmap = src_pixmap.scaled(PREICON_SIZE,PREICON_SIZE,Qt::KeepAspectRatio); QPixmap dst_pixmap(QSize(PREICON_SIZE, PREICON_SIZE)); auto src_width = src_pixmap.width(); auto src_height = src_pixmap.height(); auto dist_width = dst_pixmap.width(); auto dist_height = dst_pixmap.height(); dst_pixmap.fill(QColor(220,220,220, 50)); QPainter painter(&amp;dst_pixmap); auto x = (dist_width-src_width)/2; auto y = (dist_height-src_height)/2; painter.drawPixmap(x,y,src_pixmap); _global++; PreListItem *pItem = new PreListItem(QIcon(dst_pixmap),path,_global,this); pItem-&gt;setSizeHint(QSize(PREITEM_SIZE,PREITEM_SIZE)); this-&gt;addItem(pItem); _set_items[path] = pItem; if(_global==1)&#123; _pos_origin = this-&gt;pos(); &#125;&#125; 因为图片的大小宽高不同，做拉伸时产生的空白区域不一样，那么我们统一用宽高为PREICON_SIZE的正方形绘制然后填充默认的背景色作为dist_pixmap。 然后用一个painter绑定这个dist_pixmap，计算和原图形src_pixmap的差值，让原图形src_pixmap居中绘制在dist_pixmap上。 然后构造PreListItem对象，将路径放入集合中。 如果_global为1说明时第一张预览图，需要记录一下预览图在其父窗口的位置，这样我们可以根据屏幕最右侧的预览图和该图的位置差值移动PreListWid。 更新预览图选中效果 1234567891011121314151617181920212223242526272829void PreListWid::SlotUpSelect(QTreeWidgetItem *tree_item)&#123; if(!tree_item)&#123; qDebug() &lt;&lt; &quot;tree_item is empty&quot; &lt;&lt; endl; return; &#125; auto * pro_item = dynamic_cast&lt;ProTreeItem*&gt;(tree_item); auto path = pro_item-&gt;GetPath(); auto iter = _set_items.find(path); if(iter == _set_items.end())&#123; qDebug() &lt;&lt; &quot;path &quot; &lt;&lt;path&lt;&lt; &quot; not exists&quot; &lt;&lt; endl; return; &#125; auto * list_item = dynamic_cast&lt;PreListItem*&gt;(iter.value()); auto index = list_item-&gt;GetIndex(); if(index &gt; 17)&#123; auto pos_cur = this-&gt;pos(); this-&gt;move(pos_cur.x()-(index-_last_index)*100, pos_cur.y()); _last_index = index; &#125;else&#123; this-&gt;move(_pos_origin); _last_index = 17; &#125; this-&gt;setCurrentItem(iter.value());&#125; 判断当前播放的图像对应预览图的item的索引是否大于17，如果大于17说明该item在屏幕外，因为一个屏幕最多容纳17个item，所以要移动PreListWid。移动的方法就是当前索引减去上一次的索引差值乘以100，因为一个item的宽度为100，纵坐标不变。同时设置当前item为选中状态。 点击预览图显示对应图片PreListWid响应点击的槽函数 12345678910111213void PreListWid::SlotItemPressed(QListWidgetItem *item)&#123; if(QGuiApplication::mouseButtons() != Qt::LeftButton)&#123; return; &#125; auto * list_item = dynamic_cast&lt;PreListItem*&gt;(item); auto cur_index = list_item-&gt;GetIndex(); auto path = list_item-&gt;GetPath(); this-&gt;setCurrentItem(item); emit SigUpSelectShow(path);&#125; 点击item时发送SigUpSelectShow信号通知动画去显示选择的图片。触发PicAnimationWid的槽函数SlotUpSelectShow 1234567891011void PicAnimationWid::SlotUpSelectShow(QString path)&#123; qDebug()&lt;&lt;&quot;SlotUpSelectShow path is &quot; &lt;&lt; path &lt;&lt; endl; auto iter = _map_items.find(path); if(iter == _map_items.end())&#123; return; &#125; UpSelectPixmap(iter.value()); update();&#125; 内部调用UpSelectPixmap更新图片为选中的图片，并且调用update刷新界面。 1234567891011121314151617181920212223242526void PicAnimationWid::UpSelectPixmap(QTreeWidgetItem *item)&#123; if(!item)&#123; return; &#125; auto * tree_item = dynamic_cast&lt;ProTreeItem*&gt;(item); auto path = tree_item-&gt;GetPath(); _pixmap1.load(path); _cur_item = tree_item; if(_map_items.find(path) == _map_items.end())&#123; _map_items[path]=tree_item; qDebug() &lt;&lt; &quot;SetPixmap path is &quot; &lt;&lt; path &lt;&lt; endl; &#125; auto * next_item = tree_item-&gt;GetNextItem(); if(!next_item)&#123; return; &#125; auto next_path = next_item-&gt;GetPath(); _pixmap2.load(next_path); if(_map_items.find(next_path) == _map_items.end())&#123; _map_items[next_path] = next_item; &#125;&#125; 到此就实现了幻灯片放映和下方预览图的交互效果。播放和暂停，以及切换操作等留给下一篇。 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 实现电子相册(三)--导入功能和幻灯片ui设计","date":"2023-01-29T06:25:06.000Z","path":"2023/01/29/qt24/","text":"导入项目之前我们创建一个相册项目是通过向导设置项目名称和路径，再选择指定文件夹内容导入到我们的项目路径，并且copy文件的。这次要做的功能是直接打开一个文件夹，将文件夹内容直接展示在左侧目录树中。 连接打开信号在mainwindow构造函数里添加打开项目的信号和槽函数 1234567//打开项目动作QAction * act_open_pro = new QAction(QIcon(&quot;:/icon/openpro.png&quot;), tr(&quot;打开项目&quot;),this);act_open_pro-&gt;setShortcut(QKeySequence(Qt::CTRL + Qt::Key_O));menu_file-&gt;addAction(act_open_pro);//连接打开项目的槽函数connect(act_open_pro, &amp;QAction::triggered, this, &amp;MainWindow::SlotOpenPro);connect(this, &amp;MainWindow::SigOpenPro, pro_tree_widget, &amp;ProTreeWidget::SlotOpenPro); 当我们点击打开项目时触发SlotOpenPro函数 12345678910111213141516171819202122void MainWindow::SlotOpenPro(bool)&#123; QFileDialog file_dialog; file_dialog.setFileMode(QFileDialog::Directory); file_dialog.setWindowTitle(&quot;选择导入的文件夹&quot;); file_dialog.setDirectory(QDir::currentPath()); file_dialog.setViewMode(QFileDialog::Detail); QStringList fileNames; if (file_dialog.exec())&#123; fileNames = file_dialog.selectedFiles(); &#125; if(fileNames.length() &lt;= 0)&#123; return; &#125; QString import_path = fileNames.at(0); qDebug() &lt;&lt; &quot;import_path is &quot; &lt;&lt; import_path &lt;&lt; endl; emit SigOpenPro(import_path);&#125; 该函数打开一个文件对话框，根据选择的文件夹返回我们要打开的路径，然后将这个路径用SigOpenPro信号发送出去。会触发ProTreeWidget的SlotOpenPro函数 123456789101112131415161718192021222324252627282930void ProTreeWidget::SlotOpenPro(const QString&amp; path)&#123; if(_set_path.find(path) != _set_path.end())&#123; qDebug() &lt;&lt; &quot;file has loaded&quot; &lt;&lt; endl; return; &#125; _set_path.insert(path); int file_count = 0; QDir pro_dir(path); const QString&amp; proname = pro_dir.dirName(); _thread_open_pro = std::make_shared&lt;OpenTreeThread&gt;(path, file_count, this,nullptr); _thread_open_pro-&gt;start(); _open_progressdlg = new QProgressDialog(this); //连接更新进度框操作 connect(_thread_open_pro.get(), &amp;OpenTreeThread::SigUpdateProgress, this, &amp;ProTreeWidget::SlotUpOpenProgress); connect(_thread_open_pro.get(), &amp;OpenTreeThread::SigFinishProgress, this, &amp;ProTreeWidget::SlotFinishOpenProgress); _open_progressdlg-&gt;setWindowTitle(&quot;Please wait...&quot;); _open_progressdlg-&gt;setFixedWidth(PROGRESS_WIDTH); _open_progressdlg-&gt;setRange(0, PROGRESS_MAX); _open_progressdlg-&gt;exec();&#125; 上述逻辑中，我们创建了一个进度对话框，以及一个线程OpenTreeThread，并让他们通信，更新进度框进度以及完成情况。 设计打开逻辑线程类线程构造函数 1234567OpenTreeThread::OpenTreeThread(const QString &amp;src_path, int &amp;file_count, QTreeWidget *self, QObject *parent): QThread (parent),_bstop(false),_src_path(src_path),_file_count(file_count) ,_self(self),_root(nullptr)&#123;&#125; _bstop表示是否终止线程。_src_path表示打开的文件路径。_file_count表示文件数量。_root表示ProTreeItem类型的根节点。_self表示ProTreeWidget类型的对象。 程序启动后执行run函数 1234567891011121314void OpenTreeThread::run()&#123; OpenProTree(_src_path,_file_count,_self); if(_bstop&amp;&amp;_root)&#123; auto path = dynamic_cast&lt;ProTreeItem*&gt;(_root)-&gt;GetPath(); auto index = _self-&gt;indexOfTopLevelItem(_root); delete _self-&gt;takeTopLevelItem(index); QDir dir(path); dir.removeRecursively(); return; &#125; emit SigFinishProgress(_file_count);&#125; run函数内调用OpenProTree导入逻辑生成目录树，然后判断_bstop是否为真并且root有效，说明取消了导入操作，所以删除目录树。当执行完导入操作后发送完成信号SigFinishProgress。 123456789101112131415void OpenTreeThread::OpenProTree(const QString &amp;src_path, int &amp;file_count, QTreeWidget *self)&#123; //创建根节点 QDir src_dir(src_path); auto name = src_dir.dirName(); auto * item = new ProTreeItem(self, name, src_path, TreeItemPro); item-&gt;setData(0,Qt::DisplayRole, name); item-&gt;setData(0,Qt::DecorationRole, QIcon(&quot;:/icon/dir.png&quot;)); item-&gt;setData(0,Qt::ToolTipRole, src_path); _root = item; //读取根节点下目录和文件 RecursiveProTree(src_path,file_count,self,_root,item, nullptr);&#125; OpenProTree创建了根节点，然后调用了递归函数RecursiveProTree递归创建子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void OpenTreeThread::RecursiveProTree( const QString &amp;src_path, int &amp;file_count, QTreeWidget *self, QTreeWidgetItem *root, QTreeWidgetItem *parent,QTreeWidgetItem* preitem)&#123; QDir src_dir(src_path); //设置文件过滤器 QStringList nameFilters; src_dir.setFilter(QDir::Dirs|QDir::Files|QDir::NoDotAndDotDot);//除了目录或文件，其他的过滤掉 src_dir.setSorting(QDir::Name);//优先显示名字 QFileInfoList list = src_dir.entryInfoList(); qDebug() &lt;&lt; &quot;list.size &quot; &lt;&lt; list.size() &lt;&lt; endl; for(int i = 0; i &lt; list.size(); i++)&#123; if(_bstop)&#123; return; &#125; QFileInfo fileInfo = list.at(i); bool bIsDir = fileInfo.isDir(); if (bIsDir) &#123; if(_bstop)&#123; return; &#125; file_count++; emit SigUpdateProgress(file_count); auto * item = new ProTreeItem(_root, fileInfo.fileName(), fileInfo.absoluteFilePath(), _root,TreeItemDir); item-&gt;setData(0,Qt::DisplayRole, fileInfo.fileName()); item-&gt;setData(0,Qt::DecorationRole, QIcon(&quot;:/icon/dir.png&quot;)); item-&gt;setData(0,Qt::ToolTipRole, fileInfo.absoluteFilePath()); RecursiveProTree(fileInfo.absoluteFilePath(), file_count, self,root,item, preitem); &#125;else&#123; if(_bstop)&#123; return; &#125; const QString &amp; suffix = fileInfo.completeSuffix(); if(suffix != &quot;png&quot; &amp;&amp; suffix != &quot;jpeg&quot; &amp;&amp; suffix != &quot;jpg&quot;)&#123; qDebug() &lt;&lt; &quot;suffix is not pic &quot; &lt;&lt; suffix &lt;&lt; endl; continue; &#125; file_count++; emit SigUpdateProgress(file_count); auto * item = new ProTreeItem(parent, fileInfo.fileName(), fileInfo.absoluteFilePath(), root,TreeItemPic); item-&gt;setData(0,Qt::DisplayRole, fileInfo.fileName()); item-&gt;setData(0,Qt::DecorationRole, QIcon(&quot;:/icon/pic.png&quot;)); item-&gt;setData(0,Qt::ToolTipRole, fileInfo.absoluteFilePath()); if(preitem)&#123; auto* pre_proitem = dynamic_cast&lt;ProTreeItem*&gt;(preitem); pre_proitem-&gt;SetNextItem(item); &#125; item-&gt;SetPreItem(preitem); preitem = item; &#125; &#125; emit SigFinishProgress(file_count);&#125; 这样完成了打开一个文件夹生成项目的功能。 幻灯片SlideShowDlg类的ui设计我们创建一个名字为SlideShowDlg设计师界面类，然后在ui文件里添加两个QWidget，分别命名为preShow和slideShow。1 将SlideShowDlg设置为垂直布局，将拉伸比例设置为7比1，这样整体的布局被分为两部分，上部分为slideShow，下部分为preShow，slideShow设置为网格布局，preShow设置为垂直布局。2 在slideShow里添加两个固定宽度为80像素的widget(slidenextwid和slideprewid)，这个两个widget设置为垂直布局，分别在widget里添加button(slidenextBtn和slidepreBtn)，3 在slideShow里添加一个水平布局放在右上角，然后在该布局里添加两个按钮(closeBtn和playBtn)。4 在slideShow里添加一个widget(命名为picAnimation)设置为网格布局5 在preShow中添加一个高度固定为120的widget，让其宽度自适应，该widget设置为网格布局，在该widget内部添加一个widget命名为preListWidget，主要用来展示预览图。幻灯片界面ui如下布局信息如下因为布局信息里对widget提升了，比如PicAnimationWid，PicButton，PreListWid等，交给后一篇讲述。 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 实现电子相册(二)--双击展示图片与切换","date":"2023-01-28T08:58:55.000Z","path":"2023/01/28/qt23/","text":"双击目录树展示图片页面布局在ProTreeWidget的构造函数中添加双击信号的槽函数连接 1connect(this, &amp;ProTreeWidget::itemDoubleClicked, this, &amp;ProTreeWidget::SlotDoubleClickItem); 接下来实现双击逻辑,判断为鼠标左键，就用一个成员变量_selected_item缓存双击的item，然后发送SigUpdateSelected信号通知右侧区域刷新显示。 12345678910111213141516void ProTreeWidget::SlotDoubleClickItem(QTreeWidgetItem* doubleItem, int col)&#123; qDebug() &lt;&lt; &quot;ProTreeWidget::SlotDoubleClickItem&quot; &lt;&lt; endl; if(QGuiApplication::mouseButtons() == Qt::LeftButton) //判断是否为左键 &#123; auto * tree_doubleItem = dynamic_cast&lt;ProTreeItem*&gt;(doubleItem); if(!tree_doubleItem)&#123; return; &#125; int itemtype = (int)(tree_doubleItem-&gt;type()); if(itemtype == TreeItemPic)&#123; emit SigUpdateSelected(tree_doubleItem-&gt;GetPath()); _selected_item = doubleItem; &#125; &#125;&#125; 之前在MainWindow的构造函数里添加了ProTree，这次我们要在添加一个PicShow类，PicShow类是我们新增的Qt设计师界面类，这里介绍它的ui内容。1 在PicShow里添加一个网格布局，然后将PicShow设置为水平布局。2 然后拖动一个QWidget放到PicShow左侧，再拖动一个QWidget放到PicShow的右侧，拖动一个label放到中间。3 然后设置两个Widget的宽度都为固定的80像素。将两个widget设置为垂直布局，然后分别添加一个button。4 拖放两个水平的spacer和垂直的spacer分别放在label的上下左右，保证label居中。效果如下ui信息然后在MainWindow里添加PicShow 12345_protree = new ProTree();ui-&gt;proLayout-&gt;addWidget(_protree,0);_picshow = new PicShow();ui-&gt;picLayout-&gt;addWidget(_picshow); 同时我们为PicShow新增qss文件 1234567PicShow &#123; border-color: #9F9F9F; border-style: solid; border-width: 1px 1px 1px 1px; padding: 10px; background: rgb(64,66,68);&#125; 自定义按钮现在需要实现按钮的悬浮，点击效果，所以需要继承QPushButton，实现我们自己定义的按钮类PicButton。添加C++类PicButton，基类选择QPushButton。实现一个设置图标的函数，参数分别为正常状态，悬浮状态，以及按下状态的效果 123456789101112void PicButton::SetIcons(const QString &amp;normal, const QString &amp;hover, const QString &amp;pressed)&#123; _normal = normal; _hover = hover; _pressed = pressed; QPixmap tmpPixmap; tmpPixmap.load(normal); this-&gt;resize(tmpPixmap.size()); this-&gt;setIcon(tmpPixmap); this-&gt;setIconSize(tmpPixmap.size());&#125; 重载event函数，实现根据事件类型刷新按钮样式的逻辑 123456789101112131415161718192021bool PicButton::event(QEvent *event)&#123; switch (event-&gt;type()) &#123; case QEvent::Enter: setHoverIcon(); break; case QEvent::Leave: setNormalIcon(); break; case QEvent::MouseButtonPress: setPressIcon(); break; case QEvent::MouseButtonRelease: setHoverIcon(); break; default: break; &#125; return QPushButton::event(event);&#125; 设置按钮样式的函数很简单，都是通过QPixmap加载的。 1234567891011121314151617void PicButton::setNormalIcon()&#123; QPixmap tmpPixmap; tmpPixmap.load(_normal); this-&gt;setIcon(tmpPixmap);&#125;void PicButton::setHoverIcon()&#123; QPixmap tmpPixmap; tmpPixmap.load(_hover); this-&gt;setIcon(tmpPixmap);&#125;void PicButton::setPressIcon()&#123; QPixmap tmpPixmap; tmpPixmap.load(_pressed); this-&gt;setIcon(tmpPixmap);&#125; 所以回到picshow.ui中，将两个QPushButton升级为PicButton。这样我们在界面上将鼠标在按钮上点击和悬浮等就能看到效果了。 按钮的渐隐动画接下来我们要实现将鼠标滑动到PicShow区域才显示前进和后退按钮，滑出PicShow区域则不显示。为使按钮实现渐隐渐现的效果，所以我们通过动画实现。在PicShow的构造函数里创建两个渐隐渐现的动画,将效果绑定到两个按钮上。 12345678910111213141516171819QGraphicsOpacityEffect *opacity_pre = new QGraphicsOpacityEffect(this);opacity_pre-&gt;setOpacity(0); //设置透明度0.5,透明范围：[0,1]ui-&gt;previousBtn-&gt;setGraphicsEffect(opacity_pre);QGraphicsOpacityEffect *opacity_next = new QGraphicsOpacityEffect(this);opacity_next-&gt;setOpacity(0); //设置透明度0.5,透明范围：[0,1]//应用到需要透明变化的控件；ui-&gt;nextBtn-&gt;setGraphicsEffect(opacity_next);//使用属性动画类让控件在透明度范围内变化_animation_show_pre = new QPropertyAnimation(opacity_pre, &quot;opacity&quot;,this);_animation_show_pre-&gt;setEasingCurve(QEasingCurve::Linear);_animation_show_pre-&gt;setDuration(500); //动效时长3s_animation_show_next = new QPropertyAnimation(opacity_next, &quot;opacity&quot;,this);_animation_show_next-&gt;setEasingCurve(QEasingCurve::Linear);_animation_show_next-&gt;setDuration(500); //动效时长3s 除此之外还重写PicShow的event函数，捕获其中的enter和leave事件 123456789101112131415bool PicShow::event(QEvent *event)&#123; switch (event-&gt;type()) &#123; case QEvent::Enter: ShowPreNextBtns(true); break; case QEvent::Leave: ShowPreNextBtns(false); break; default: break; &#125; return QDialog::event(event);&#125; 根据enter还是leave设置按钮显示和隐藏。显示隐藏的函数通过bool参数控制,根据是否可见并且是否隐藏综合控制动画。 12345678910111213141516171819202122232425262728293031323334void PicShow::ShowPreNextBtns(bool b_show)&#123; if(!b_show&amp;&amp;_b_btnvisible)&#123; _animation_show_pre-&gt;stop(); _animation_show_pre-&gt;setStartValue(1); _animation_show_pre-&gt;setEndValue(0); _animation_show_pre-&gt;start(); _animation_show_next-&gt;stop(); _animation_show_next-&gt;setStartValue(1); _animation_show_next-&gt;setEndValue(0); _animation_show_next-&gt;start(); _b_btnvisible = false; return; &#125; if(_selected_path ==&quot;&quot;)&#123; return; &#125; if(b_show&amp;&amp;!_b_btnvisible)&#123; _animation_show_pre-&gt;stop(); _animation_show_pre-&gt;setStartValue(0); _animation_show_pre-&gt;setEndValue(1); _animation_show_pre-&gt;start(); _animation_show_next-&gt;stop(); _animation_show_next-&gt;setStartValue(0); _animation_show_next-&gt;setEndValue(1); _animation_show_next-&gt;start(); _b_btnvisible = true; &#125;&#125; 这样鼠标滑动和移出PicShow区域就能显示和隐藏button了。 双击左侧目录树实现图片切换为ProTreeWidget绑定双击的槽函数，并且实现双击后发送信号通知PicShow显示图片ProTreeWidget构造函数添加 1connect(this, &amp;ProTreeWidget::itemDoubleClicked, this, &amp;ProTreeWidget::SlotDoubleClickItem); 双击逻辑 12345678910111213141516void ProTreeWidget::SlotDoubleClickItem(QTreeWidgetItem* doubleItem, int col)&#123; qDebug() &lt;&lt; &quot;ProTreeWidget::SlotDoubleClickItem&quot; &lt;&lt; endl; if(QGuiApplication::mouseButtons() == Qt::LeftButton) //判断是否为左键 &#123; auto * tree_doubleItem = dynamic_cast&lt;ProTreeItem*&gt;(doubleItem); if(!tree_doubleItem)&#123; return; &#125; int itemtype = (int)(tree_doubleItem-&gt;type()); if(itemtype == TreeItemPic)&#123; emit SigUpdateSelected(tree_doubleItem-&gt;GetPath()); _selected_item = doubleItem; &#125; &#125;&#125; 在mainwindow构造函数中添加信号连接 123auto * pro_pic_show = dynamic_cast&lt;PicShow*&gt;(_picshow);connect(pro_tree_widget, &amp;ProTreeWidget::SigUpdateSelected,pro_pic_show, &amp;PicShow::SlotSelectItem); 在PicShow里实现SlotSelectItem显示选中图像 1234567891011void PicShow::SlotSelectItem(const QString&amp; path)&#123; _selected_path = path; _pix_map.load(path); auto width = this-&gt;width()-20; auto height = this-&gt;height()-20; _pix_map = _pix_map.scaled(width,height,Qt::KeepAspectRatio); ui-&gt;label-&gt;setPixmap(_pix_map);&#125; 这样就实现了点击左侧不同的目录树item显示不同的图片。 图像重绘因为每次图像形状不同，都会导致重回，这样会造成资源浪费，所以将重回事件写在MainWindow，只在MainWindow改变时重绘 1234567void MainWindow::resizeEvent(QResizeEvent *event)&#123; auto * pro_pic_show = dynamic_cast&lt;PicShow*&gt;(_picshow); pro_pic_show-&gt;ReloadPic(); QMainWindow::resizeEvent(event);&#125; picshow实现重新加载逻辑 1234567891011void PicShow::ReloadPic()&#123; if(_selected_path != &quot;&quot;)&#123; const auto &amp;width = ui-&gt;gridLayout-&gt;geometry().width(); const auto &amp;height = ui-&gt;gridLayout-&gt;geometry().height(); _pix_map.load(_selected_path); _pix_map = _pix_map.scaled(width,height,Qt::KeepAspectRatio); ui-&gt;label-&gt;setPixmap(_pix_map); &#125;&#125; qss样式补充因为目录树双击选中效果，悬浮，以及折叠等效果，我们补充一下qss.以及按钮需要设置为无边框效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PicShow &#123; border-color: #9F9F9F; border-style: solid; border-width: 1px 1px 1px 1px; padding: 10px; background: rgb(64,66,68);&#125;QWizard &#123; color:rgb(231,231,231); background-color:rgb(46,47,48);&#125;QWizard QLabel#tips &#123; color: red;&#125;QTreeView &#123; color:rgb(231,231,231); background-color:rgb(46,47,48); border: 0px;&#125;QTreeView::item:hover &#123; background: rgb(38, 95, 153);&#125;QTreeView::item:selected &#123; background: rgb(38, 95, 153);&#125;/*设置选中条目字体变粗*/#TreeProActiveItem &#123; font-weight:bold;&#125;QTreeView::branch:open:has-children:!has-siblings,QTreeView::branch:open:has-children:has-siblings&#123;image: url(:/icon/down.png);&#125;QTreeView::branch:closed:has-children:!has-siblings,QTreeView::branch:closed:has-children:has-siblings&#123;image: url(:/icon/right.png);&#125;#nextBtn,#closeBtn,#previousBtn &#123; border: 0px;&#125; 前进后退按钮切换图片在picshow的构造函数中绑定按钮点击信号 12connect(ui-&gt;nextBtn,&amp;QPushButton::clicked,this, &amp;PicShow::SigNextClicked);connect(ui-&gt;previousBtn,&amp;QPushButton::clicked,this, &amp;PicShow::SigPreClicked); 当按钮点击后左侧目录树的选中条目也进行更新，所以在MainWindow构造函数中 123connect(pro_pic_show, &amp;PicShow::SigPreClicked,pro_tree_widget,&amp;ProTreeWidget::SlotPreShow);connect(pro_pic_show, &amp;PicShow::SigNextClicked,pro_tree_widget,&amp;ProTreeWidget::SlotNextShow);connect(pro_tree_widget,&amp;ProTreeWidget::SigUpdatePic,pro_pic_show,&amp;PicShow::SlotUpdatePic); ProTreeWidget的更新逻辑, 设置选中item，并且发送更新图片信号。 123456789101112131415161718192021222324252627void ProTreeWidget::SlotPreShow()&#123; if(!_selected_item)&#123; return; &#125; auto * curItem = dynamic_cast&lt;ProTreeItem*&gt;(_selected_item)-&gt;GetPreItem(); if(!curItem)&#123; return; &#125; emit SigUpdatePic(curItem-&gt;GetPath()); _selected_item = curItem; this-&gt;setCurrentItem(curItem);&#125;void ProTreeWidget::SlotNextShow()&#123; if(!_selected_item)&#123; return; &#125; auto * curItem = dynamic_cast&lt;ProTreeItem*&gt;(_selected_item)-&gt;GetNextItem(); if(!curItem)&#123; return; &#125; emit SigUpdatePic(curItem-&gt;GetPath()); _selected_item = curItem; this-&gt;setCurrentItem(curItem);&#125; SigUpdatePic信号会被PicShow的SlotUpdatePic函数绑定,该函数实现了图片的切换展示。 123456789101112void PicShow::SlotUpdatePic(const QString &amp;_path)&#123; _selected_path = _path; if(_selected_path != &quot;&quot;)&#123; const auto &amp;width = ui-&gt;gridLayout-&gt;geometry().width(); const auto &amp;height = ui-&gt;gridLayout-&gt;geometry().height(); _pix_map.load(_selected_path); _pix_map = _pix_map.scaled(width,height,Qt::KeepAspectRatio); ui-&gt;label-&gt;setPixmap(_pix_map); &#125;&#125; 关闭和激活项目前文提到了我们要实现关闭项目的功能，在这里补充一下。ProTreeWidget的构造函数添加 1234 _action_setstart = new QAction(QIcon(&quot;:/icon/core.png&quot;), tr(&quot;设置活动项目&quot;),this);_action_closepro = new QAction(QIcon(&quot;:/icon/close.png&quot;), tr(&quot;关闭项目&quot;), this); connect(_action_closepro, &amp;QAction::triggered, this, &amp;ProTreeWidget::SlotClosePro);connect(_action_setstart, &amp;QAction::triggered, this, &amp;ProTreeWidget::SlotSetActive); 关闭项目的槽函数中现弹出一个删除对话框，这个也是我们添加的设计师界面类，不再赘述了。删除对话框的布局ui是这样的可以勾选同时删除本地文件夹项目文件，这样我们的程序也会把copy的文件删除。关闭项目逻辑如下 123456789101112131415161718192021222324252627282930void ProTreeWidget::SlotClosePro()&#123; RemoveProDialog remove_pro_dialog; auto res = remove_pro_dialog.exec(); bool b_remove = remove_pro_dialog.IsRemoved(); auto index_right_btn = this-&gt;indexOfTopLevelItem(_right_btn_item); auto * protreeitem = dynamic_cast&lt;ProTreeItem*&gt;(_right_btn_item); auto * selecteditem = dynamic_cast&lt;ProTreeItem*&gt;(_selected_item); auto delete_path = protreeitem-&gt;GetPath(); qDebug() &lt;&lt; &quot;remove project from path: &quot; &lt;&lt; delete_path; _set_path.remove(delete_path); if(b_remove)&#123; QDir delete_dir(delete_path); delete_dir.removeRecursively(); &#125; if(protreeitem == _active_item)&#123; _active_item = nullptr; &#125; if(selecteditem &amp;&amp; protreeitem == selecteditem-&gt;GetRoot())&#123; selecteditem = nullptr; emit SigClearSelected(); &#125; delete this-&gt;takeTopLevelItem(index_right_btn); _right_btn_item = nullptr;&#125; 判断当前选中的item是否在删除的项目中，如果在则发送SigClearSelected信号。如果是设置活动项目，我们只需要在槽函数里设置字体变粗即可。 1234567891011121314151617void ProTreeWidget::SlotSetActive()&#123; if(!_right_btn_item)&#123; return; &#125; QFont nullFont; nullFont.setBold(false); if(_active_item)&#123; _active_item-&gt;setFont(0,nullFont); &#125; _active_item = _right_btn_item; nullFont.setBold(true); _active_item-&gt;setFont(0,nullFont);&#125; 到目前为止我们点击按钮和item等切换图片的功能就实现了，下一篇实现幻灯片放映。 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 实现电子相册(一)--目录树和向导","date":"2023-01-18T07:17:19.000Z","path":"2023/01/18/qt22/","text":"简介基于前面介绍的QT知识，做一个电子相册，总结前文介绍的各类知识，将用到QListWidget，QTreeWidget，双缓冲绘图，信号槽，动画效果，绘图事件，鼠标事件,qss等知识，算是对之前知识的一个总结。 效果如下 MainWindow设计1 MainWindow.ui的centralWidget中添加水平布局horizontalLayout，在该布局中添加两个垂直布局proLayout和picLayout。horizontalLayout设置layoutStretch比例为1比4, 同时为MainWindow.ui添加manubar，效果是这个样子的2 在MainWindow的构造函数中添加菜单项，并为菜单项设置信号连接，截取部分代码 1234567891011121314151617181920212223//创建菜单栏QMenu * menu_file = menuBar()-&gt;addMenu(tr(&quot;文件(&amp;F)&quot;));//创建项目动作QAction * act_create_pro = new QAction(QIcon(&quot;:/icon/createpro.png&quot;), tr(&quot;创建项目&quot;),this);act_create_pro-&gt;setShortcut(QKeySequence(Qt::CTRL + Qt::Key_N));menu_file-&gt;addAction(act_create_pro);//打开项目动作QAction * act_open_pro = new QAction(QIcon(&quot;:/icon/openpro.png&quot;), tr(&quot;打开项目&quot;),this);act_open_pro-&gt;setShortcut(QKeySequence(Qt::CTRL + Qt::Key_O));menu_file-&gt;addAction(act_open_pro);//创建设置菜单QMenu * menu_set = menuBar()-&gt;addMenu(tr(&quot;设置(&amp;S)&quot;));//设置背景音乐QAction * act_music = new QAction(QIcon(&quot;:/icon/music.png&quot;), tr(&quot;背景音乐&quot;),this);act_music-&gt;setShortcut(QKeySequence(Qt::CTRL + Qt::Key_M));menu_set-&gt;addAction(act_music);//连接创建项目槽函数connect(act_create_pro, &amp;QAction::triggered, this, &amp;MainWindow::SlotCreatePro);//连接打开项目的槽函数 connect(act_open_pro, &amp;QAction::triggered, this, &amp;MainWindow::SlotOpenPro); 3 main函数设置mainwindow最大显示 12w.setWindowTitle(&quot;Album&quot;);w.showMaximized(); 4 为MainWindow和菜单栏设置qss 1234567891011121314151617181920212223242526272829/*mainwindow 样式*/MainWindow &#123; /* 背景色 */ background-color:rgb(46,47,48);&#125;/*菜单栏基本样式*/QMenuBar&#123; color:rgb(231,231,231); background-color:rgb(46,47,48);&#125;/*菜单基本样式*/QMenu&#123; color:rgb(231,231,231); background-color:rgb(55,55,55);&#125;/* 菜单栏选中条目时 */QMenuBar::item:selected &#123; background-color:rgb(80,80,80);&#125;/*菜单选中条目*/QMenu::item:selected &#123; background-color:rgb(39,96,154);&#125; 向导类Wizard1 添加设计师界面类WizardWizard类用来响应创建项目菜单被点击后弹出向导框，其继承于QWizard。2 添加两个向导页面类ConfirmPage和ProSetPage类，基类选择QWizardPage类，并在Wizard.ui里添加两个wizardpage，将这两个wizardpage升级为ProSetPage和ConfirmPage。ProSetPage类用来设置创建项目的属性，我们先点击其ui文件为其添加网格布局gridLayout,然后将ProSetPage设置为网格布局，设置gridLayout的margin为5，在gridLayout中添加控件，形成如下布局3 将两个lineEdit注册为wizard的field，保证两个lineEdit是空的时候无法点击下一步，将QLineEdit的textEdited信号和ProSetPage的completeChanged信号连接起来，这样在lineEdit编辑的时候就会发送textEdited信号，进而触发ProSetPage发送completeChanged信号。setClearButtonEnabled设置为true可以在lineEdit输入数据后显示清除按钮，直接清除已录入的字符。completeChanged信号是从proSetPage的基类QWizardPage类继承而来的。completeChanged信号发出后会触发QWizardPage类的isComplete函数。 12345678910111213141516ProSetPage::ProSetPage(QWidget *parent) : QWizardPage(parent), ui(new Ui::ProSetPage)&#123; ui-&gt;setupUi(this); registerField(&quot;proPath&quot;, ui-&gt;lineEdit_2); registerField(&quot;proName*&quot;, ui-&gt;lineEdit); connect(ui-&gt;lineEdit, &amp;QLineEdit::textEdited, this, &amp;ProSetPage::completeChanged); connect(ui-&gt;lineEdit_2, &amp;QLineEdit::textEdited, this, &amp;ProSetPage::completeChanged); QString curPath = QDir::currentPath(); ui-&gt;lineEdit_2-&gt;setText(curPath); ui-&gt;lineEdit_2-&gt;setCursorPosition( ui-&gt;lineEdit_2-&gt;text().size()); ui-&gt;lineEdit-&gt;setClearButtonEnabled(true); ui-&gt;lineEdit_2-&gt;setClearButtonEnabled(true);&#125; 为了实现特定的判断，我们重写isComplete函数。这样我们就能判断文件夹是否合理以及是否已经有项目路径了。可以根据不满足的条件设置tips提示用户。 12345678910111213141516171819202122232425262728bool ProSetPage::isComplete() const&#123; if(ui-&gt;lineEdit-&gt;text() == &quot;&quot; || ui-&gt;lineEdit_2-&gt;text() == &quot;&quot;)&#123; return false; &#125; //判断是否文件夹是否合理 QDir dir(ui-&gt;lineEdit_2-&gt;text()); if(!dir.exists()) &#123; //qDebug()&lt;&lt;&quot;file path is not exists&quot; &lt;&lt; endl; ui-&gt;tips-&gt;setText(&quot;project path is not exists&quot;); return false; &#125; //判断路径是否存在 QString absFilePath = dir.absoluteFilePath(ui-&gt;lineEdit-&gt;text());// qDebug() &lt;&lt; &quot;absFilePath is &quot; &lt;&lt; absFilePath; QDir dist_dir(absFilePath); if(dist_dir.exists())&#123; ui-&gt;tips-&gt;setText(&quot;project has exists, change path or name!&quot;); return false; &#125; ui-&gt;tips-&gt;setText(&quot;&quot;); return QWizardPage::isComplete();&#125; 4 为浏览按钮添加点击后选择文件夹操作，在prosetpage.ui文件里右键点击browse按钮，选择转到槽，QT会为我们生成槽函数 1234567891011121314151617181920212223//添加浏览按钮点击后选择文件夹的操作void ProSetPage::on_pushButton_clicked()&#123; QFileDialog file_dialog; file_dialog.setFileMode(QFileDialog::Directory); file_dialog.setWindowTitle(&quot;选择导入的文件夹&quot;); auto path = QDir::currentPath(); file_dialog.setDirectory(path); file_dialog.setViewMode(QFileDialog::Detail); QStringList fileNames; if (file_dialog.exec())&#123; fileNames = file_dialog.selectedFiles(); &#125; if(fileNames.length() &lt;= 0)&#123; return; &#125; QString import_path = fileNames.at(0); qDebug() &lt;&lt; &quot;import_path is &quot; &lt;&lt; import_path &lt;&lt; endl; ui-&gt;lineEdit_2-&gt;setText(import_path);&#125; 5 在ProSetPage页面点击下一步会跳转到下一页。ConfirmPage没什么代码，在ui文件里添加提示即可。在完成时我们可以重写QWidzard的done函数。将页面设置的项目名称和路径传递给ProTree类，ProTree类用来在MainWindow左侧显示树形目录，这个之后介绍。 1234567891011void Wizard::done(int result)&#123; if(result == QDialog::Rejected)&#123; return QWizard::done(result); &#125; QString name, path; ui-&gt;wizardPage1-&gt;GetProSettings(name, path); emit SigProSettings(name, path); QWizard::done(result);&#125; 项目目录树ProTree类1 创建Qt设计师界面类，名字为ProTree，基类选择QDialog，ProTree中添加一个垂直布局，布局内添加一个QLabel和一个QTreeWidget，最后将ProTree设置为垂直布局。2 考虑到QTreeWidget功能有限，我们需要继承QTreeWidget重新实现一个新的类ProTreeWidget，所以在项目中新增C++类ProTreeWidget继承自QTreeWidget。在构造函数中隐藏头部，并且注册要传递信息的类型 123qRegisterMetaType&lt;QVector&lt;int&gt; &gt;(&quot;QVector&lt;int&gt;&quot;);//隐藏表头this-&gt;header()-&gt;hide(); 同时将ProTree布局中的QTreeWidget提升为ProTreeWidget3 同样的道理为了便于操作定义ProTreeItem继承QTreeWidgetItem，相关的成员变量和函数省略，这里简单介绍下构造函数 123456ProTreeItem::ProTreeItem(QTreeWidget *view, const QString &amp;name, const QString &amp;path, int type):QTreeWidgetItem (view, type), _path(path),_name(name),_root(this),_pre_item(nullptr),_next_item(nullptr)&#123;&#125; view和type传递给基类，其他参数_path表示项目路径，_name表示项目名称，_root表示根节点，_pre_item表示前一个节点，_next_item表示后一个节点。还有第二个重载版本的构造函数，可以通过根节点构造新的item节点 1234567ProTreeItem::ProTreeItem(QTreeWidgetItem *parent, const QString &amp;name, const QString &amp;path, QTreeWidgetItem* root,int type):QTreeWidgetItem(parent,type), _path(path),_name(name),_root(root),_pre_item(nullptr),_next_item(nullptr)&#123;&#125; 4 ProTreeWidget添加槽函数AddProToTreeAddProToTree函数里判断路径和名字是否准确，然后创建一个item插入到treewidget里。 123456789101112131415161718192021222324252627void ProTreeWidget::AddProToTree(const QString &amp;name, const QString &amp;path)&#123; qDebug() &lt;&lt; &quot;ProTreeWidget::AddProToTree name is &quot; &lt;&lt; name &lt;&lt; &quot; path is &quot; &lt;&lt; path &lt;&lt; endl; QDir dir(path); QString file_path = dir.absoluteFilePath(name); //检测重名，判断路径和名字都一样则拒绝加入 if(_set_path.find(file_path) != _set_path.end())&#123; qDebug() &lt;&lt; &quot;file has loaded&quot; &lt;&lt; endl; return; &#125; //构造项目用的文件夹 QDir pro_dir(file_path); //如果文件夹不存在则创建 if(!pro_dir.exists())&#123; bool enable = pro_dir.mkpath(file_path); if(!enable)&#123; qDebug() &lt;&lt; &quot;pro_dir make path failed&quot; &lt;&lt; endl; return; &#125; &#125; _set_path.insert(file_path); auto * item = new ProTreeItem(this, name, file_path, TreeItemPro); item-&gt;setData(0,Qt::DisplayRole, name); item-&gt;setData(0,Qt::DecorationRole, QIcon(&quot;:/icon/dir.png&quot;)); item-&gt;setData(0,Qt::ToolTipRole, file_path);&#125; 5 在MainWindow中串联创建项目逻辑因为在MainWindow的构造函数中已经添加了SlotCreatePro和信号的连接 12//连接创建项目槽函数 connect(act_create_pro, &amp;QAction::triggered, this, &amp;MainWindow::SlotCreatePro); 所以这里实现点击创建项目后设置向导的逻辑 12345678910111213void MainWindow::SlotCreatePro(bool)&#123; qDebug() &lt;&lt; &quot;slot create pro triggered&quot; &lt;&lt; endl; Wizard wizard(this); wizard.setWindowTitle(tr(&quot;创建项目&quot;)); auto *page = wizard.page(0); page-&gt;setTitle(tr(&quot;设置项目配置&quot;)); //连接信号和槽 connect(&amp;wizard, &amp;Wizard::SigProSettings, dynamic_cast&lt;ProTree*&gt;(_protree),&amp;ProTree::AddProToTree); wizard.show(); wizard.exec(); disconnect(&amp;wizard);&#125; 我们在qss中设置ProTree样式 123456789101112131415ProTree &#123; border-color: #9F9F9F; border-style: solid; border-width: 1px 1px 1px 1px; padding-right: 10px;&#125;QLabel#label_pro &#123; color: rgb(231,231,231); border-color: #9F9F9F; border-style: dotted; border-width: 0 0 1px 0; padding-bottom: 10px; margin-bottom: 5px;&#125; 这样在wizard点击完成时触发done函数，进而发送信号触发ProTree的AddProToTree函数了，从而生成一个项目目录的item。效果如下 文件夹导入功能我们要在生成的ProTreeWidget的项目root item中点击右键，弹出菜单，然后选择导入文件夹，将文件夹中的目录和文件递归的导入我们创建的项目目录，并且在root下生成item节点。1 ProTreeWidget构造函数添加信号和槽函数连接,并且创建导入文件的动作，并为该动作连接槽函数。 123connect(this, &amp;ProTreeWidget::itemPressed, this, &amp;ProTreeWidget::SlotItemPressed);_action_import = new QAction(QIcon(&quot;:/icon/import.png&quot;),tr(&quot;导入文件&quot;), this);connect(_action_import, &amp;QAction::triggered, this, &amp;ProTreeWidget::SlotImport); itemPressed信号是从QTreeWidget基类继承而来的，在QTreeWidget中的item被点击时发出。 12345678910111213141516void ProTreeWidget::SlotItemPressed(QTreeWidgetItem *pressedItem, int column)&#123; qDebug() &lt;&lt; &quot;ProTreeWidget::SlotItemPressed&quot; &lt;&lt; endl; if(QGuiApplication::mouseButtons() == Qt::RightButton) //判断是否为右键 &#123; QMenu menu(this); qDebug() &lt;&lt; &quot;menu addr is &quot; &lt;&lt; &amp;menu &lt;&lt; endl; int itemtype = (int)(pressedItem-&gt;type()); if (itemtype == TreeItemPro) &#123; _right_btn_item = pressedItem; menu.addAction(_action_import); menu.exec(QCursor::pos()); //菜单弹出位置为鼠标点击位置 &#125; &#125;&#125; TreeItemPro是我们在const.h中定义的类型，在SlotItemPressed函数中判断是否为右键点击，如果是再根据item的类型判断是root节点，则在菜单中添加动作。接下来点击导入文件动作之后执行SlotImport函数。因为导入操作是一个耗时的操作，所以要放到单独的线程中执行，主线程启动一个进度对话框显示导入进度，同时可以控制导入的中止操作等。在导入时弹出一个文件选择对话框，设置默认路径 1234567891011121314151617181920212223242526272829void ProTreeWidget::SlotImport()&#123; QFileDialog file_dialog; file_dialog.setFileMode(QFileDialog::Directory); file_dialog.setWindowTitle(&quot;选择导入的文件夹&quot;); QString path = &quot;&quot;; if(!_right_btn_item)&#123; qDebug() &lt;&lt; &quot;_right_btn_item is empty&quot; &lt;&lt; endl; path = QDir::currentPath(); return ; &#125; path = dynamic_cast&lt;ProTreeItem*&gt;(_right_btn_item)-&gt;GetPath(); file_dialog.setDirectory(path); file_dialog.setViewMode(QFileDialog::Detail); QStringList fileNames; if (file_dialog.exec())&#123; fileNames = file_dialog.selectedFiles(); &#125; if(fileNames.length() &lt;= 0)&#123; return; &#125; QString import_path = fileNames.at(0); // qDebug() &lt;&lt; &quot;import_path is &quot; &lt;&lt; import_path &lt;&lt; endl;&#125; 文件选择对话框选择要导入的文件夹，返回路径，我们根据这个路径做copy操作，将文件夹内的文件和文件夹都copy到之前设置的项目路径里。这是个耗时的操作，那我们重新实现一个线程继承自QThread类，简单看一下构造函数2 自定义线程完成文件复制和树目录创建 12345678ProTreeThread::ProTreeThread(const QString &amp;src_path, const QString &amp;dist_path, QTreeWidgetItem *parent_item, int &amp;file_count, QTreeWidget *self, QTreeWidgetItem *root, QObject *parent) :QThread (parent),_src_path(src_path),_dist_path(dist_path), _file_count(file_count),_parent_item(parent_item),_self(self),_root(root),_bstop(false)&#123;&#125; parent传递给父类构造函数，_src_path表示打开的文件夹路径，_dist_path表示我们创建的项目路径，_file_count表示文件数，用来和进度框交互，_parent_item新创建节点的父节点，_self表示QProTreeWidget对象，_root表示新创建节点隶属于哪个根节点，便于后期做交互。_bstop表示是否停止，如果为true则线程终止。3 实现copy文件功能和目录树创建 (1) 根据文件类型(文件夹还是文件)执行不同的逻辑，如果是文件则创建item添加到父节点下。如果是文件夹类型，则递归进入创建逻辑，直到所有的文件和文件夹被遍历完成。(2) 如果_bstop被设置为true，则退出创建逻辑。(3) 统计文件数，发信号SigUpdateProgress通知进度框更新进度 浅谈一下_bstop的设计逻辑。因为QTread类提供了terminate和quit函数，这些只能从机制上保证线程退出，并不能保证逻辑的准确性，所以我并没有采用这个机制，而是通过_bstop的方式从逻辑上控制退出。至于为什么有多处判断，因为创建逻辑是递归方式，为了保证退出的效率所以在多处判断，不加锁也是为了提高程序运行的效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void ProTreeThread::CreateProTree(const QString &amp;src_path, const QString &amp;dist_path, QTreeWidgetItem *parent_item, int &amp;file_count, QTreeWidget *self, QTreeWidgetItem *root, QTreeWidgetItem* preItem)&#123; if(_bstop)&#123; return; &#125; bool needcopy = true; if(src_path == dist_path)&#123; needcopy = false; &#125; QDir import_dir(src_path); qDebug() &lt;&lt; &quot;src_path is &quot; &lt;&lt; src_path &lt;&lt; &quot;dis_path is &quot; &lt;&lt; dist_path &lt;&lt; endl; //设置文件过滤器 QStringList nameFilters; import_dir.setFilter(QDir::Dirs|QDir::Files|QDir::NoDotAndDotDot);//除了目录或文件，其他的过滤掉 import_dir.setSorting(QDir::Name);//优先显示名字 QFileInfoList list = import_dir.entryInfoList(); qDebug() &lt;&lt; &quot;list.size &quot; &lt;&lt; list.size() &lt;&lt; endl; for(int i = 0; i &lt; list.size(); i++)&#123; if(_bstop)&#123; return; &#125; QFileInfo fileInfo = list.at(i); bool bIsDir = fileInfo.isDir(); if (bIsDir) &#123; if(_bstop)&#123; return; &#125; file_count++; emit SigUpdateProgress(file_count); QDir dist_dir(dist_path); //构造子目的路径 QString sub_dist_path = dist_dir.absoluteFilePath(fileInfo.fileName()); qDebug()&lt;&lt; &quot;sub_dist_path &quot; &lt;&lt; sub_dist_path; //子目的目录 QDir sub_dist_dir(sub_dist_path); //不能存在则创建 if(!sub_dist_dir.exists())&#123; //可以创建多级目录 bool ok = sub_dist_dir.mkpath(sub_dist_path); if(!ok)&#123; qDebug()&lt;&lt; &quot;sub_dist_dir mkpath failed&quot;&lt;&lt; endl; continue; &#125; &#125; auto * item = new ProTreeItem(parent_item, fileInfo.fileName(), sub_dist_path, root,TreeItemDir); item-&gt;setData(0,Qt::DisplayRole, fileInfo.fileName()); item-&gt;setData(0,Qt::DecorationRole, QIcon(&quot;:/icon/dir.png&quot;)); item-&gt;setData(0,Qt::ToolTipRole, sub_dist_path); ; CreateProTree(fileInfo.absoluteFilePath(), sub_dist_path, item, file_count, self,root,preItem); &#125;else&#123; if(_bstop)&#123; return; &#125; const QString &amp; suffix = fileInfo.completeSuffix(); if(suffix != &quot;png&quot; &amp;&amp; suffix != &quot;jpeg&quot; &amp;&amp; suffix != &quot;jpg&quot;)&#123; qDebug() &lt;&lt; &quot;suffix is not pic &quot; &lt;&lt; suffix &lt;&lt; endl; continue; &#125; file_count++; emit SigUpdateProgress(file_count); if(!needcopy)&#123; continue; &#125; QDir dist_dir(dist_path); QString dist_file_path = dist_dir.absoluteFilePath(fileInfo.fileName()); if(!QFile::copy(fileInfo.absoluteFilePath(), dist_file_path))&#123; qDebug() &lt;&lt; &quot;file src to dist copy failed&quot; &lt;&lt; endl; continue; &#125; auto * item = new ProTreeItem(parent_item, fileInfo.fileName(), dist_file_path, root,TreeItemPic); item-&gt;setData(0,Qt::DisplayRole, fileInfo.fileName()); item-&gt;setData(0,Qt::DecorationRole, QIcon(&quot;:/icon/pic.png&quot;)); item-&gt;setData(0,Qt::ToolTipRole, dist_file_path); if(preItem)&#123; auto* pre_proitem = dynamic_cast&lt;ProTreeItem*&gt;(preItem); pre_proitem-&gt;SetNextItem(item); &#125; item-&gt;SetPreItem(preItem); preItem = item; &#125; &#125; parent_item-&gt;setExpanded(true);&#125; 4 重写线程run函数run函数就是线程启动后执行的函数，如果CreateProTree运行结束，判断_bstop是否为true，如果为true说明取消了创建操作，那么就要把根节点移除，并删除文件夹内的文件。 1234567891011121314void ProTreeThread::run()&#123; CreateProTree(_src_path,_dist_path,_parent_item,_file_count,_self,_root); if(_bstop)&#123; auto path = dynamic_cast&lt;ProTreeItem*&gt;(_root)-&gt;GetPath(); auto index = _self-&gt;indexOfTopLevelItem(_root); delete _self-&gt;takeTopLevelItem(index); QDir dir(path); dir.removeRecursively(); return; &#125; emit SigFinishProgress(_file_count);&#125; 5 完善ProTreeWidget的SlotImport函数 创建进队对话框，然后连接线程和对话框的信号和槽(1) 当对话框被取消时发出QProgressDialog::canceled信号，被ProTreeWidget::SlotCancelProgress捕获。（对话框取消，ProTreeWidget做回收操作并发送SigCancelProgress）(2) ProTreeWidget发出SigCancelProgress信号，被ProTreeThread::SlotCancelProgress捕获。（对话框取消，线程终止）(3) 连接ProTreeThread::SigFinishProgress和ProTreeWidget::SlotFinishProgress，进度框响应线程完成操作。(4) 连接ProTreeThread::SigUpdateProgress和ProTreeWidget::SlotUpdateProgress，更新进度框进度。 123456789101112131415161718192021222324252627 int file_count = 0; //创建模态对话框 _dialog_progress = new QProgressDialog(this);//耗时操作放在线程中操作 _thread_create_pro = std::make_shared&lt;ProTreeThread&gt;(std::ref(import_path), std::ref(path), _right_btn_item, std::ref(file_count), this,_right_btn_item,nullptr); //连接更新进度框操作 connect(_thread_create_pro.get(), &amp;ProTreeThread::SigUpdateProgress, this, &amp;ProTreeWidget::SlotUpdateProgress); connect(_thread_create_pro.get(), &amp;ProTreeThread::SigFinishProgress, this, &amp;ProTreeWidget::SlotFinishProgress); connect(_dialog_progress, &amp;QProgressDialog::canceled, this, &amp;ProTreeWidget::SlotCancelProgress); connect(this, &amp;ProTreeWidget::SigCancelProgress, _thread_create_pro.get(), &amp;ProTreeThread::SlotCancelProgress); _thread_create_pro-&gt;start();//连接信号和槽_dialog_progress-&gt;setWindowTitle(&quot;Please wait...&quot;);_dialog_progress-&gt;setFixedWidth(PROGRESS_WIDTH);_dialog_progress-&gt;setRange(0, PROGRESS_MAX);_dialog_progress-&gt;exec(); 相关槽函数如下 1234567891011121314151617181920212223242526272829void ProTreeWidget::SlotUpdateProgress(int count)&#123; qDebug() &lt;&lt; &quot;count is &quot; &lt;&lt; count; if(!_dialog_progress)&#123; qDebug() &lt;&lt; &quot;dialog_progress is empty!!!&quot; &lt;&lt; endl; return; &#125; if(count &gt;= PROGRESS_MAX)&#123; _dialog_progress-&gt;setValue(count%PROGRESS_MAX); &#125;else&#123; _dialog_progress-&gt;setValue(count%PROGRESS_MAX); &#125;&#125;void ProTreeWidget::SlotCancelProgress()&#123; // _thread_create_pro-&gt;terminate(); emit SigCancelProgress(); delete _dialog_progress; _dialog_progress =nullptr;&#125;void ProTreeWidget::SlotFinishProgress()&#123; _dialog_progress-&gt;setValue(PROGRESS_MAX); _dialog_progress-&gt;deleteLater();&#125; 运行导入文件效果如下为了完善共功能，在之前的ProTreeWidget构造函数里添加其他的几个动作，包括设置活动项目，关闭项目，开启轮播等，这里不再赘述。 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"自定义模型的拖动实现","date":"2022-12-23T02:51:33.000Z","path":"2022/12/23/qt21/","text":"自定义模型的拖动便捷类的拖动实现很简单，今天我们介绍自己定义的ListModel模型如何实现拖动。在之前的ListModel项目基础上，我们先对View视图实现拖动操作. 12345678//设置选择模式为单选 listView.setSelectionMode(QAbstractItemView::ExtendedSelection); //设置可拖拽 listView.setDragEnabled(true); //设置可拖放 listView.setAcceptDrops(true); //设置显示拖放位置 listView.setDropIndicatorShown(true); 对模型实现拖动在ListModel添加声明 123456//编写拖动逻辑 virtual QStringList mimeTypes() const; virtual QMimeData *mimeData(const QModelIndexList &amp;indexes) const; virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &amp;parent); virtual Qt::DropActions supportedDropActions() const; 自定义一个类型，用来表示拖动导出的类型 1234567//拖放时导出的类型QStringList StringListModel:: mimeTypes() const&#123; QStringList types; //自定义类型 types &lt;&lt; &quot;application/zack.list&quot;; return types;&#125; 将拖动的数据放入mimedata中 123456789101112131415161718QMimeData *StringListModel::mimeData(const QModelIndexList &amp;indexes) const&#123; QMimeData * mimeData = new QMimeData(); //字节数组 QByteArray encodeData; QDataStream stream(&amp;encodeData, QIODevice::WriteOnly); foreach(const QModelIndex&amp; index, indexes)&#123; if(index.isValid())&#123; QString text = data(index, Qt::DisplayRole).toString(); stream &lt;&lt; text; &#125; &#125; //将数据放入到QMimeData中 mimeData-&gt;setData(&quot;application/zack.list&quot;, encodeData); return mimeData;&#125; 将拖放的数据从mimedata中导出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool StringListModel::dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &amp;parent)&#123; //如果放入的动作是ignoreaction if(action == Qt::IgnoreAction)&#123; return true; &#125; //如果数据的格式不是指定的格式，那么返回false if(!data-&gt;hasFormat(&quot;application/zack.list&quot;))&#123; return false; &#125; //因为这里是列表， 只用一列， 所以列大于0时返回false if(column &gt; 0)&#123; return false; &#125; //设置开始插入行 int beginRow; if(row != -1)&#123; beginRow = row; &#125;else if(parent.isValid())&#123; beginRow = parent.row(); &#125;else &#123; beginRow = rowCount(QModelIndex()); &#125; //将数据从QMimeData 中读取出来， 然后插入到模型中 QByteArray encodeData = data-&gt;data(&quot;application/zack.list&quot;); //stream流 QDataStream stream(&amp;encodeData, QIODevice::ReadOnly); //统计插入的数据 QStringList newItems; //统计插入的行数 int rows = 0; while(!stream.atEnd())&#123; QString text; stream &gt;&gt; text; newItems &lt;&lt; text; ++ rows; &#125; //插入指定行数 insertRows(beginRow, rows, QModelIndex()); //批量修改行数数据 foreach(const QString&amp; text, newItems)&#123; QModelIndex idx = index(beginRow, 0, QModelIndex()); setData(idx,text); beginRow++; &#125; return true;&#125; 为了能让我们的item拖动，需要重新实现flags变量，使其支持拖放 12345678Qt::ItemFlags StringListModel::flags(const QModelIndex&amp; index) const&#123; //索引无效可以接受放入操作 if(!index.isValid()) return Qt::ItemIsEnabled | Qt::ItemIsDropEnabled; //索引有效，可以接受拖拽和放入操作 return QAbstractItemModel::flags(index) | Qt::ItemIsEditable | Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled;&#125; 然后我们设置支持的拖放动作为移动和复制 12345Qt::DropActions StringListModel::supportedDropActions() const&#123; //设置支持放入动作,允许copy和move return Qt::CopyAction | Qt::MoveAction;&#125; 拖动效果 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt 项目视图便捷类","date":"2022-12-22T01:52:36.000Z","path":"2022/12/22/qt20/","text":"Qt项目视图便捷类Qt项目视图提供了一些便捷类，包括QListWidget, QTableWidget， QTreeWidget等。我们分别介绍这几个便捷类。我们先创建一个Qt Application应用，然后在mainwindow的构造函数中创建一个listwidget 1234567891011121314151617181920auto listWidget = new QListWidget(this);QListWidgetItem * listWidgetItem = new QListWidgetItem;listWidgetItem-&gt;setText(&quot;listItem&quot;);QPixmap pixmap(50,50);pixmap.fill(Qt::blue);listWidgetItem-&gt;setIcon(pixmap);listWidgetItem-&gt;setToolTip(&quot;this is list item&quot;);listWidget-&gt;insertItem(1,listWidgetItem);QListWidgetItem * listWidgetItem2 = new QListWidgetItem;listWidgetItem2-&gt;setText(&quot;listItem2&quot;);QPixmap pixmap2(50,50);pixmap2.fill(Qt::green);listWidgetItem2-&gt;setIcon(pixmap2);listWidgetItem2-&gt;setToolTip(&quot;this is list item2&quot;);listWidget-&gt;insertItem(2,listWidgetItem2);listWidget-&gt;sortItems(Qt::DescendingOrder);listWidget-&gt;show();this-&gt;setCentralWidget(listWidget); 运行效果如下 接下来我们在mainwindow.h里添加QTableWidget和QTreeWidget成员变量 12QTreeWidget * _treeWidget;QTableWidget * _tableWidget; 然后继续在mainwindow的构造函数中创建TableWidget和TreeWidget。 1234567891011121314151617181920212223242526272829_treeWidget = new QTreeWidget();//treewidget 要设置列数_treeWidget-&gt;setColumnCount(2);QStringList headers;headers &lt;&lt; &quot;name&quot; &lt;&lt; &quot;year&quot;;_treeWidget-&gt;setHeaderLabels(headers);//添加项目//父节点是_treeWidgetQTreeWidgetItem * grade1 = new QTreeWidgetItem(_treeWidget);grade1-&gt;setText(0,&quot;Grade1&quot;);//父节点是grade1QTreeWidgetItem * student = new QTreeWidgetItem(grade1);student-&gt;setText(0,&quot;Tom&quot;);student-&gt;setText(1,&quot;1996&quot;);//父节点是grade1, 在student之后QTreeWidgetItem * student2 = new QTreeWidgetItem(grade1, student);student2-&gt;setText(0,&quot;Zack&quot;);student2-&gt;setText(1,&quot;1988&quot;);//父节点是_treeWidget, 在grade1之后QTreeWidgetItem * grade2 = new QTreeWidgetItem(_treeWidget,grade1);grade2-&gt;setText(0,&quot;Grade2&quot;);QTreeWidgetItem * student3 = new QTreeWidgetItem(grade1, student2);student3-&gt;setText(0,&quot;Will&quot;);student3-&gt;setText(1,&quot;1989&quot;);_treeWidget-&gt;show(); 我们创建了一个TreeWidget，创建TreeWidget要指明列数量，然后创建了头信息，接下来利用QTreeWidgetItem的构造函数创建了一些item，两个参数的构造函数，第一个参数是item的父节点，第二个参数是其兄弟节点。运行之后效果如下我们可以根据item的父节点是否为空判断其是否为顶层节点，然后执行删除节点操作 1234567891011121314//删除student3,先获取其父节点auto *parent_student3 = student3-&gt;parent();//获取student3在其父节点下的indexauto index_student3 = parent_student3-&gt;indexOfChild(student3);//根据index删除student3delete parent_student3-&gt;takeChild(index_student3);//删除grade2auto * parent_grade2 = grade2-&gt;parent();//grade2为顶层节点，所以其父节点必为nullassert(parent_grade2 == nullptr);//通过treewidget获取grade2的indexauto index_grade2 = _treeWidget-&gt;indexOfTopLevelItem(grade2);delete _treeWidget-&gt;takeTopLevelItem(index_grade2); 创建QTableWidget 1234567891011 //创建表格指定行号和列号_tableWidget = new QTableWidget(3,2); //创建表格项目，将其插入到表格中 QTableWidgetItem * tableWidgetItem = new QTableWidgetItem(&quot;qt&quot;); _tableWidget-&gt;setItem(1,1,tableWidgetItem); //创建表头 QTableWidgetItem * headerV = new QTableWidgetItem(&quot;first&quot;); _tableWidget-&gt;setVerticalHeaderItem(0, headerV); QTableWidgetItem * headerH = new QTableWidgetItem(&quot;ID&quot;); _tableWidget-&gt;setHorizontalHeaderItem(0, headerH); _tableWidget-&gt;show(); 运行效果 实现拖拽有时我们需要实现拖拽操作, 我们可以在之前实现的listWidget设置一些拖拽属性。 12345678910//设置list为单选模式listWidget-&gt;setSelectionMode(QAbstractItemView::SingleSelection);//启用拖动listWidget-&gt;setDragEnabled(true);//设置接受拖放listWidget-&gt;viewport()-&gt;setAcceptDrops(true);//设置显示将要放置的位置listWidget-&gt;setDropIndicatorShown(true);//设置拖放模式为移动项目，如果不设置，则为复制项目listWidget-&gt;setDragDropMode(QAbstractItemView::InternalMove); 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt MVC结构之QItemDelegate介绍","date":"2022-12-21T06:39:49.000Z","path":"2022/12/21/qt19/","text":"QItemDelegate当我们想重新实现一个代理时，可以子类化QItemDelegate。实现item编辑时特定的效果，比如在item编辑时我们设置一个QSpinBox返回。创建一个QApplication项目，然后我们新增一个类，类名叫做spinboxdelegate。 123456789101112131415class SpinBoxDelegate : public QItemDelegate&#123; Q_OBJECTpublic: explicit SpinBoxDelegate(QObject * parent=0); QWidget * createEditor(QWidget* parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override; void setEditorData(QWidget *editor, const QModelIndex &amp;index) const override; void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const override; void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override;&#125;; SpinBoxDelegate类中声明了几个函数，这些函数在QItemDelegate继承而来，通过重写实现我们自己定义的代理功能。createEditor函数是在item被双击后进入编辑状态时触发的，返回一个QWidget控件用来管理编辑。setModelData是在item被修改后触发的，将改动的内容写入model中。setEditorData是在item被双击进入编辑状态时，将model的内容写入editor中。updateEditorGeometry是刷新editor的矩形区域，因为随着item变大或者拉伸，它的区域也要随之刷新。 具体实现1 创建editor， 返回一个spinbox 1234567QWidget * SpinBoxDelegate::createEditor(QWidget* parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const&#123; QSpinBox * editor = new QSpinBox(parent); editor-&gt;setMinimum(0); editor-&gt;setMaximum(100); return editor;&#125; 2 在编辑状态时，将model的数据写入editor 12345void SpinBoxDelegate::setEditorData(QWidget *editor, const QModelIndex &amp;index) const &#123; int value = index.model()-&gt;data(index, Qt::EditRole).toInt(); QSpinBox * spinBox = static_cast&lt;QSpinBox*&gt;(editor); spinBox-&gt;setValue(value);&#125; 3 编辑完成时将editor的内容写入model 123456void SpinBoxDelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const &#123; QSpinBox * spinBox = static_cast&lt;QSpinBox*&gt;(editor); spinBox-&gt;interpretText(); int value = spinBox-&gt;value(); model-&gt;setData(index, value, Qt::EditRole);&#125; 4 刷新矩形区域 12345void SpinBoxDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const &#123; editor-&gt;setGeometry(option.rect);&#125; 接下来我们在MainWindow的构造函数里创建两个model和view，我们对其中的一个view使用我们自定义的delegate 123456789101112131415161718192021222324252627282930313233MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QStandardItemModel * model = new QStandardItemModel(7,4,this); for(int row=0; row &lt; 7; row++)&#123; for(int column = 0; column &lt; 4; column++)&#123; QStandardItem * item = new QStandardItem(QString(&quot;%1&quot;).arg(row*4+column)); model-&gt;setItem(row, column, item); &#125; &#125; QTableView* _table_view = new QTableView; _table_view-&gt;setModel(model); setCentralWidget(_table_view); this-&gt;resize(800,800); QTableView* _table_view2 = new QTableView; SpinBoxDelegate * delegate = new SpinBoxDelegate(this); QStandardItemModel * model2 = new QStandardItemModel(7,4,this); for(int row=0; row &lt; 7; row++)&#123; for(int column = 0; column &lt; 4; column++)&#123; QStandardItem * item = new QStandardItem(QString(&quot;%1&quot;).arg(row*4+column)); model2-&gt;setItem(row, column, item); &#125; &#125; _table_view2-&gt;setModel(model2); _table_view2-&gt;setItemDelegate(delegate); _table_view2-&gt;show(); _table_view2-&gt;resize(800,800);&#125; 运行程序后，双击两个view的item，可以看到效果的不同 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt MVC结构之QItemSelectionModel模型介绍","date":"2022-12-20T08:01:55.000Z","path":"2022/12/20/qt18/","text":"QItemSelectionModelQt的MVC结构支持多个View共享同一个model，包括该model的选中状态等。我们可以通过设置QItemSelectionModel，来更改View的选中效果和显示效果。我们创建一个Qt Application项目，在MainWindow的头文件中添加一个QTbaleView*类型的成员 _table_view。然后在构造函数中为这个_table_view设置model 123456789101112131415161718MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QStandardItemModel * model = new QStandardItemModel(7,4,this); for(int row=0; row &lt; 7; row++)&#123; for(int column = 0; column &lt; 4; column++)&#123; QStandardItem * item = new QStandardItem(QString(&quot;%1&quot;).arg(row*4+column)); model-&gt;setItem(row, column, item); &#125; &#125; _table_view = new QTableView; _table_view-&gt;setModel(model); setCentralWidget(_table_view); this-&gt;resize(800,800);&#125; 我们创建了一个QStandardItemModel对象，然后为其设置几个Item，最后将这个model设置到tableview中。我们可以为TableView设置选择的项目，接下来继续在构造函数中补充 1234567891011121314 //获取视图的项目选择模型 QItemSelectionModel * selection_model = _table_view-&gt;selectionModel();//定义左上角和右下角的索引 QModelIndex topLeft; QModelIndex bottomRight; //根据上面两个索引选择项目 //第1行1列 topLeft = model-&gt;index(1,1,QModelIndex()); //第5行2列 bottomRight = model-&gt;index(5,2,QModelIndex()); //设置选择区域 QItemSelection selection(topLeft, bottomRight); //将选择的区域设置给选择模型, 设置 为选中状态 selection_model-&gt;select(selection, QItemSelectionModel::Select); 我们从tableview中获取选择模型，然后从根节点下选择第1行1列作为左上索引，选择第5行2列作为右下索引。然后创建选择区域QItemSelection，最后将选择区域这只给选择模型。接下来为了我们为工具栏添加两个动作，为动作绑定两个槽函数，在MainWindow声明文件中添加两个函数的声明 123public slots: void getCurrentItemData(); void toggleSelection(); 在构造函数中将动作和槽函数绑定起来 12ui-&gt;mainToolBar-&gt;addAction(tr(&quot;当前项目&quot;), this, &amp;MainWindow::getCurrentItemData);ui-&gt;mainToolBar-&gt;addAction(tr(&quot;切换选择&quot;), this, &amp;MainWindow::toggleSelection); 实现这两个槽函数, getCurrentItemData获取当前条目的数据信息，toggleSelection实现切换选择的条目 123456789101112131415161718void MainWindow::getCurrentItemData()&#123; auto currentData = _table_view-&gt;selectionModel()-&gt;currentIndex().data().toString(); qDebug() &lt;&lt;tr(&quot;当前项目的内容&quot;) &lt;&lt; currentData;&#125;void MainWindow::toggleSelection()&#123; //找到根节点下第0行0列的item的索引 QModelIndex topLeft = _table_view-&gt;model()-&gt;index(0,0,QModelIndex()); //获取根节点下最大的行号 auto max_row = _table_view-&gt;model()-&gt;rowCount(QModelIndex()); //获取根节点下最大的列号 auto max_column = _table_view-&gt;model()-&gt;columnCount(QModelIndex()); //根据列号和行号获取最右下角的item的索引 QModelIndex bottomRight = _table_view-&gt;model()-&gt;index(max_row-1, max_column-1, QModelIndex()); //设置选择区域 QItemSelection curSelection(topLeft, bottomRight); _table_view-&gt;selectionModel()-&gt;select(curSelection, QItemSelectionModel::Toggle);&#125; 通过点击切换选择，可以实现选择区域的切换，因为我们设置选择的类型为Toggle，系统会将选中的变为取消选中，将取消选中的变为选中。切换前切换后因为默认当前的条目是第1行1列，所以getCurrentItemData会打印他的信息。每一个model都有当前条目和选择条目两个属性。 捕获选择条目的变化当我们点击鼠标选择一个条目时，当前条目就变为该条目，选择的条目也变为该条目。我们可以通过选择模型发出的selectionChanged信号，获取选择了那些条目的索引，以及取消选择了哪些条目的索引。我们可以通过currentChanged获取当前的条目索引以及变化之前的条目索引。现在MainWindow中添加两个槽函数的声明 123public slots: void updateSelection(const QItemSelection&amp; selected, const QItemSelection&amp; deselected); void changeCurrent(const QModelIndex&amp; current, const QModelIndex&amp; previous); 两个槽函数的参数和信号的参数匹配。我们实现changeCurrent，当选择模型的当前索引变化时，打印变化前后的索引行号，列号。 1234void MainWindow::changeCurrent(const QModelIndex&amp; current, const QModelIndex&amp; previous)&#123; qDebug() &lt;&lt; tr(&quot;move(%1, %2) to (%3, %4)&quot;).arg(previous.row()) .arg(previous.column()).arg(current.row()).arg(current.column());&#125; 然后我们实现选择模型的选择条目变化时更新条目的数据 1234567891011121314void MainWindow::updateSelection(const QItemSelection&amp; selected, const QItemSelection&amp; deselected)&#123; QModelIndex index; QModelIndexList list = selected.indexes(); //为现在的选择项目设置值 for(int i =0; i &lt; list.size(); i++)&#123; QString text = QString(&quot;(%1, %2)&quot;).arg(list[i].row()).arg(list[i].column()); _table_view-&gt;model()-&gt;setData(list[i], text); &#125; list = deselected.indexes(); foreach(index, list)&#123; _table_view-&gt;model()-&gt;setData(index,&quot;&quot;); &#125;&#125; 在MainWindow的构造函数中添加信号和槽函数的链接 1234//选择模型的选择条目更改后触发updateSelection函数connect(selection_model, &amp;QItemSelectionModel::selectionChanged, this, &amp;MainWindow::updateSelection);//选择模型的当前项目更改后，关联changeCurrent函数connect(selection_model, &amp;QItemSelectionModel::currentChanged, this, &amp;MainWindow::changeCurrent); 点击某个条目，其他条目的数据都变为空，这个条目被选中，内容修改为行列号 多个View共享模型MVC结构最大的好处就是可以通过多个View共享同一个model，这个model的选中状态改变时，多个View的显示效果一致。在构造函数中添加另一个QTableView 1234567QTableView * tableView2;tableView2 = new QTableView();tableView2-&gt;setWindowTitle(&quot;tableView2&quot;);tableView2-&gt;resize(400,300);tableView2-&gt;setModel(model);tableView2-&gt;setSelectionModel(selection_model);tableView2-&gt;show(); 可以看到两个View显示的选中状态是一致的 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt MVC结构之Model模型介绍","date":"2022-12-06T07:25:58.000Z","path":"2022/12/06/qt17/","text":"MVC简介MVC 就是Model-View-Control模式的简称，包括模型层(Model), 视图层(View), 控制层(Controller).Model主要负责管理数据，View主要用来显示数据，Controller主要用来操作数据，控制View联动。Qt也采用了这个模式，模型层用Model，视图层用View，控制层改名叫了代理Delegate。 QFileSystemModel我们可以举个简单的例子，用QFileSystemModel来实现文件夹内容的展示，QFileSystemModel是Qt给我们提供的处理本地文件系统的文件和目录。 1234567891011121314151617181920int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QSplitter * splitter = new QSplitter; QFileSystemModel * model = new QFileSystemModel; model-&gt;setRootPath(QDir::currentPath()); QTreeView * tree = new QTreeView(splitter); tree-&gt;setModel(model); tree-&gt;setRootIndex(model-&gt;index(QDir::currentPath())); QListView * list = new QListView(splitter); list-&gt;setModel(model); list-&gt;setRootIndex(model-&gt;index(QDir::currentPath())); splitter-&gt;setWindowTitle(&quot;Two views onto the same file system model&quot;); splitter-&gt;resize(1000,800); splitter-&gt;show(); return a.exec();&#125; 为model设置根目录,目录为当前文件夹。创建树型视图，视图加载model，并且设置视图的根索引为model的当前目录的索引。 模型介绍模型分为几种，有列表模型，表格模型，以及树模型。详细可以参考Qt的帮主文档，搜索Model/View Programming。 模型有一个最基本的类QStandardItemModel，我们基于这个模型类实现一个树形模型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int main(int argc, char *argv[])&#123; QApplication a(argc, argv); //创建标准itemmodel QStandardItemModel model; //获取模型根项，根项不可见 QStandardItem * parentItem = model.invisibleRootItem(); //创建文本显示，图标，和工具显示 QStandardItem * item0 = new QStandardItem(); item0-&gt;setText(&quot;item0&quot;); QPixmap pixmap0(50,50); pixmap0.fill(Qt::red); item0-&gt;setIcon(pixmap0); item0-&gt;setToolTip(&quot;indexA&quot;); parentItem-&gt;appendRow(item0); //将新的项设置为父节点项 parentItem = item0; QStandardItem * item1 = new QStandardItem(); item1-&gt;setText(&quot;item1&quot;); QPixmap pixmap1(50,50); pixmap1.fill(Qt::blue); item1-&gt;setIcon(pixmap1); item1-&gt;setToolTip(&quot;indexB&quot;); parentItem-&gt;appendRow(item1); QStandardItem * item2 = new QStandardItem(); item2-&gt;setData(&quot;item2&quot;,Qt::EditRole); QPixmap pixmap2(50,50); pixmap2.fill(Qt::green); item2-&gt;setData(QIcon(pixmap2), Qt::DecorationRole); item2-&gt;setData(&quot;indexC&quot;,Qt::ToolTipRole); parentItem-&gt;appendRow(item2); //取出根节点第0行0列的模型索引 QModelIndex indexA = model.index(0,0, QModelIndex()); qDebug() &lt;&lt; &quot;model indexA row count is &quot; &lt;&lt; model.rowCount(indexA); //获取indexA节点下0行0列 QModelIndex indexB = model.index(0,0,indexA); qDebug() &lt;&lt; &quot;indexB text is &quot; &lt;&lt; model.data(indexB,Qt::EditRole).toString(); qDebug() &lt;&lt; &quot;indexB icon is &quot; &lt;&lt; model.data(indexB,Qt::DecorationRole); qDebug() &lt;&lt; &quot;indexB tool tip is &quot; &lt;&lt; model.data(indexB,Qt::ToolTipRole).toString(); QTreeView view; view.setModel(&amp;model); view.show(); return a.exec();&#125; 运行后程序效果图item0节点下挂载了item1和item2两个节点。程序用两种方式为item设置图标，提示，文本。一种是setText，setIcon, setToolTip方式，另一种是setData方式。setData的方式可以参考Qt的文档，文档里列举了一些可以设置的角色。EditRole是可编辑角色，DecorationRole类似于图片显示，ToolTipRole类似于提示的角色。 特定模型除了QStandardItemModel之外，还有一些其他集成好的特殊模型，如果我们要实现树形模型就子类化QStandardItemModel。如果想实现列表模型就子类化QAbstractListModel，如果像实现表格模型就子类化QAbstractTableModel。我们子类化QAbstractListModel，实现一个列表模型。 123456789101112class StringListModel:public QAbstractListModel&#123; Q_OBJECTpublic: StringListModel(const QStringList &amp; strings, QObject* parent = 0); int rowCount(const QModelIndex&amp; parent = QModelIndex()) const; QVariant data(const QModelIndex&amp; index, int role) const; QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;private: QStringList stringList;&#125;; 这个模型类包含一个QStringList,用来管理数据 123456789101112131415161718192021222324252627282930313233343536373839StringListModel::StringListModel(const QStringList &amp; strings, QObject* parent): QAbstractListModel(parent), stringList(strings)&#123;&#125;int StringListModel::rowCount(const QModelIndex&amp; parent ) const&#123; return stringList.count();&#125;QVariant StringListModel::data(const QModelIndex&amp; index, int role) const&#123; if(!index.isValid())&#123; return QVariant(); &#125; if(index.row() &gt;= stringList.size())&#123; return QVariant(); &#125; if(role == Qt::DisplayRole)&#123; return stringList.at(index.row()); &#125;else&#123; return QVariant(); &#125;&#125;QVariant StringListModel::headerData(int section, Qt::Orientation orientation, int role ) const&#123; if(role != Qt::DisplayRole)&#123; return QVariant(); &#125; if(orientation == Qt::Horizontal)&#123; return QString(&quot;Column %1&quot;).arg(section); &#125;else&#123; return QString(&quot;Row %1&quot;).arg(section); &#125;&#125; headerData函数内根据水平还是垂直判断，显示表头。data函数内根据角色返回索引对应的数据。在main函数中可以分别用一个listview和treeview显示 12345678910111213141516int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QStringList list; list &lt;&lt;&quot;a&quot; &lt;&lt; &quot;b&quot; &lt;&lt; &quot;c&quot;; StringListModel model(list); QListView listView; listView.setModel(&amp;model); listView.show(); QTableView tableView; tableView.setModel(&amp;model); tableView.show(); return a.exec();&#125; 设置可编辑选项我们为自定义的listmodel模型添加两个函数flags()和setData()函数。flags函数用来判断模型索引对应的项目的属性，通过标记按位或的方式获取。setData用来设置模型索引对应的项，并且设置他的编辑属性。 12345Qt::ItemFlags StringListModel::flags(const QModelIndex&amp; index) const&#123; if(!index.isValid()) return Qt::ItemIsEnabled; return QAbstractItemModel::flags(index) | Qt::ItemIsEditable;&#125; 如果是无效的数据则返回ItemIsEnabled标记，否则在原来的标记基础上增加ItemIsEditable。当我们修改数据时，会触发setData函数, 该函数根据项的角色为EditRole替换原来的字符串。 123456789bool StringListModel::setData(const QModelIndex&amp; index, const QVariant &amp;value, int role )&#123; if(index.isValid() &amp;&amp; role == Qt::EditRole)&#123; stringList.replace(index.row(), value.toString()); emit dataChanged(index, index); return true; &#125; return false;&#125; 并且发送了dataChanged，这个信号第一个参数为左上角的index，第二个参数为右下角index。dataChanged通知View视图刷新数据，从而完成数据的修改。 另外Views显示数据时会根据data返回的数据显示，所以要将data函数的显示逻辑中添加Qt::EditRole。 123456789101112131415QVariant StringListModel::data(const QModelIndex&amp; index, int role) const&#123; if(!index.isValid())&#123; return QVariant(); &#125; if(index.row() &gt;= stringList.size())&#123; return QVariant(); &#125; if(role == Qt::DisplayRole || role == Qt::EditRole)&#123; return stringList.at(index.row()); &#125;else&#123; return QVariant(); &#125;&#125; 添加行与删除行添加行和删除行都需要在添加和删除之前调用begin操作，操作完之后调用end操作 123456789101112131415161718bool StringListModel::insertRows(int position, int rows, const QModelIndex &amp; index )&#123; beginInsertRows(QModelIndex(), position, position + rows -1); for(int row = 0; row &lt; rows; ++ row)&#123; stringList.insert(position, &quot;&quot;); &#125; endInsertRows(); return true;&#125;bool StringListModel::removeRows(int position, int rows, const QModelIndex &amp; index )&#123; beginRemoveRows(QModelIndex(), position, position+ rows-1); for(int row=0; row &lt; rows; ++ row)&#123; stringList.removeAt(position); &#125; endRemoveRows();&#125; 接下来可以调用一下测试 12model.insertRows(3,2);model.removeRows(0,1); 运行的效果如下 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt 定时器事件","date":"2022-12-04T06:50:19.000Z","path":"2022/12/04/qt16/","text":"定时器Qt中提供了两种方式实现定时器，第一种是通过startTimer的方式启动定时器，该函数返回定时器的id，然后我们需要为实现定时器的类重写timerEvent。我们先介绍这一种，创建Qt Application项目，项目默认的类名为Widget，继承自QWidget。 重写timerEvent我们在QWidget类里先声明三个定时器的id，并且声明我们要重写的timerEvent事件 1234567891011121314class Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget(); virtual void timerEvent(QTimerEvent *event);private: Ui::Widget *ui; int id1; int id2; int id3;&#125;; 接下来我们在构造函数中启动三个定时器 123456789Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); id1 = startTimer(1000); id2 = startTimer(1500); id3 = startTimer(2000);&#125; 在析构函数中回收三个定时器 1234567Widget::~Widget()&#123; delete ui; killTimer(id1); killTimer(id2); killTimer(id3);&#125; 然后重写timerEvent，进而实现三个定时器的功能 1234567891011121314void Widget::timerEvent(QTimerEvent *event)&#123; if(event-&gt;timerId() == id1)&#123; qDebug() &lt;&lt; &quot;id1 timer triggered&quot; ; &#125; if(event-&gt;timerId() == id2)&#123; qDebug() &lt;&lt; &quot;id2 timer triggered&quot; ; &#125; if(event-&gt;timerId() == id3)&#123; qDebug() &lt;&lt; &quot;id3 timer triggered&quot; ; &#125;&#125; 运行程序后，就可以看到三个定时器被调用，并且根据每个定时器的id输出信息。 QTimer实现定时器我们在Widget的声明中，添加一个槽函数 1234567891011121314class Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget(); virtual void timerEvent(QTimerEvent *event); void slot_update_led();private: Ui::Widget *ui; int id1; int id2; int id3;&#125;; 接下来我们在Widget的构造函数中初始化一个定时器，并且连接定时器发出的信号和槽函数，然后启动定时器 123QTimer * timer = new QTimer(this);connect(timer, &amp;QTimer::timeout, this, &amp;Widget::slot_update_led);timer-&gt;start(1000); 然后我们在ui里添加一个lcdnumber的控件，用来显示当前的时间，然后在定时器的槽函数slot_update_led中设置lcdnumber显示时间信息 123456789101112void Widget::slot_update_led()&#123; QTime time = QTime::currentTime(); QString text = time.toString(&quot;hh:mm:ss&quot;); //qDebug() &lt;&lt; &quot; current time is &quot; &lt;&lt; text; if(time.second()%2==0)&#123; text[5] = &#x27; &#x27;; text[2] = &#x27; &#x27;; &#125; ui-&gt;lcdNumber-&gt;setDigitCount(text.length()); ui-&gt;lcdNumber-&gt;display(text);&#125; 程序运行后，就可以根据定时器每个一秒获取时间信息显示在lcdNumber上了。 源码链接源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt 鼠标事件","date":"2022-11-30T05:54:52.000Z","path":"2022/11/30/qt15/","text":"鼠标事件鼠标事件包括鼠标左键点击，右键点击，双击，滚动滚轮等。我们先创建一个QApplication项目，类名字为Widget，基类选择QWidget。在widget.ui里添加一个QTextEdit, 依次实现这些功能。 鼠标按下与移动先在Widget的构造函数中,我们先给鼠标设置一个小手的样式 123456789101112Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); //创建光标对象 QCursor cursor; //修改鼠标形状 cursor.setShape(Qt::OpenHandCursor); //设置鼠标 setCursor(cursor);&#125; 我们将鼠标设置为打开的手的形象。我们在鼠标左键按下时，获取鼠标和窗口左上角的位置偏移量，并且设置光标为CloseHandCursor形象。鼠标右键按下时，设置为别的资源图标 1234567891011121314void Widget::mousePressEvent(QMouseEvent *event)&#123; //如果是鼠标左键按下 if(event-&gt;button() == Qt::LeftButton)&#123; QCursor cursor; cursor.setShape(Qt::ClosedHandCursor); QApplication::setOverrideCursor(cursor); offset = event-&gt;globalPos() - pos(); &#125;else if(event-&gt;button() == Qt::RightButton)&#123; QCursor cursor(QPixmap(&quot;:/res/mouse.png&quot;)); QApplication::setOverrideCursor(cursor); &#125;&#125; 然后我们实现释放事件，在释放鼠标时，将鼠标恢复为原来的OpenHandCursor形象 12345void Widget::mouseReleaseEvent(QMouseEvent *event)&#123; //释放事件 QApplication::restoreOverrideCursor();&#125; 双击实现窗口放大我们通过实现双击左键，让窗口最大化，如果已经最大化，则让窗口再变回正常模式。 12345678910void Widget::mouseDoubleClickEvent(QMouseEvent *event)&#123; if(event-&gt;button() == Qt::LeftButton)&#123; if(windowState() != Qt::WindowFullScreen)&#123; setWindowState(Qt::WindowFullScreen); &#125;else&#123; setWindowState(Qt::WindowNoState); &#125; &#125;&#125; 拖动鼠标移动窗口因为之前我们在鼠标左键点击后保存了窗口和鼠标的偏移量，我们可以在鼠标移动的过程中，根据偏移量和鼠标的位置，重设窗口的位置，进而实现窗口随着鼠标拖动而移动的效果。 123456789void Widget::mouseMoveEvent(QMouseEvent *event)&#123; //移动过程中判断鼠标是左键点击并且移动，那么要用buttons，返回的是鼠标状态的集合 if(event-&gt;buttons() &amp; Qt::LeftButton)&#123; //获取窗口应当移动到的位置 QPoint windowpos = event-&gt;globalPos() - offset; this-&gt;move(windowpos); &#125;&#125; 滚轮事件我们可以在Widget里添加textEdit，然后在鼠标滚轮滚动的时候，根据滚轮的方向缩放textEdit的文字. 1234567891011void Widget::wheelEvent(QWheelEvent *event)&#123; //鼠标滚动远离使用者放大textedit if(event-&gt;delta() &gt; 0)&#123; qDebug() &lt;&lt; &quot;catch wheel event delta &gt; 0&quot; &lt;&lt; endl; ui-&gt;textEdit-&gt;zoomIn(); &#125;else &#123; qDebug() &lt;&lt; &quot;catch wheel event delta &lt; 0&quot; &lt;&lt; endl; ui-&gt;textEdit-&gt;zoomOut(); &#125;&#125; 在鼠标滚轮向前滚动的时候delta大于0，是放大textEdit，向后滚动的时候delta小于0，是缩小textEdit. 总结源码连接:https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt 按键事件","date":"2022-11-29T07:20:00.000Z","path":"2022/11/29/qt14/","text":"按键事件按键事件是Qt提供的特有的事件体系，其头文件为QKeyEvent，这一篇我们通过一个demo演示按键事件，首先我们创建一个QApplication项目，创建类名为Widget，继承自QWidget，然后在ui里添加一个button。重写Widget的keyPressEvent函数 12345678910111213141516void Widget::keyPressEvent(QKeyEvent *event)&#123; //判断是ctrl+M if(event-&gt;modifiers() == Qt::ControlModifier)&#123; if(event-&gt;key() == Qt::Key_M &amp;&amp; windowState() != Qt::WindowFullScreen)&#123; setWindowState(Qt::WindowFullScreen); return; &#125; return; &#125; //如果按下的是ESC if(event-&gt;key() == Qt::Key_Escape &amp;&amp; windowState() == Qt::WindowFullScreen)&#123; setWindowState(Qt::WindowNoState); return; &#125;&#125; 在这个按键事件里，我们判断了是否按下控制键Ctrl，如果按下了控制键Ctrl并且按下M键，则进行之后的判断逻辑。如果此时窗口并不是全屏，那么就将窗口设置为全屏，否则什么都不做。如果按下的是ESC键，且此时窗口全屏，则将窗口设置为正常状态，非全屏。 控制按钮移动我们可以通过上下左右键控制按钮移动，需求如下1 当我们按住一个方向键时控制按钮朝一个方向移动2 当我们同时按住两个方向键则让其朝着两个方向的中间移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void Widget::keyPressEvent(QKeyEvent *event)&#123; bool b_upflag= false; bool b_downflag = false; bool b_leftflag = false; bool b_rightflag = false; if(event-&gt;key() == Qt::Key_Up)&#123; if(event-&gt;isAutoRepeat())&#123; auto curpos = ui-&gt;pushButton-&gt;pos(); curpos.setY(curpos.y()-5); ui-&gt;pushButton-&gt;move(curpos); return; &#125;else&#123; b_upflag = true; &#125; &#125; if(event-&gt;key() == Qt::Key_Left)&#123; if(event-&gt;isAutoRepeat())&#123; auto curpos = ui-&gt;pushButton-&gt;pos(); curpos.setX(curpos.x()-5); ui-&gt;pushButton-&gt;move(curpos); return; &#125;else&#123; b_leftflag = true; &#125; &#125; if(event-&gt;key() == Qt::Key_Down)&#123; if(event-&gt;isAutoRepeat())&#123; auto curpos = ui-&gt;pushButton-&gt;pos(); curpos.setY(curpos.y()+5); ui-&gt;pushButton-&gt;move(curpos); return; &#125;else&#123; b_downflag = true; &#125; &#125; if(event-&gt;key() == Qt::Key_Right)&#123; if(event-&gt;isAutoRepeat())&#123; auto curpos = ui-&gt;pushButton-&gt;pos(); curpos.setX(curpos.x()+5); ui-&gt;pushButton-&gt;move(curpos); return; &#125;else&#123; b_rightflag = true; &#125; &#125; auto curpos = ui-&gt;pushButton-&gt;pos(); if(b_upflag)&#123; curpos.setY(curpos.y()-5); &#125; if(b_downflag)&#123; curpos.setY(curpos.y()+5); &#125; if(b_leftflag)&#123; curpos.setX(curpos.x()-5); &#125; if(b_rightflag)&#123; curpos.setX(curpos.x()+5); &#125; ui-&gt;pushButton-&gt;move(curpos);&#125; 我们通过isAutoRepeat函数判断某一个按键是否被单一按下，如果是，则直接移动按钮的位置。否则我们根据按键的方向设置对应的标记，最后根据标记设置按钮的位置，以达到朝着两个方向的中间移动的效果。 总结源码链接：https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 事件系统","date":"2022-11-28T09:49:51.000Z","path":"2022/11/28/qt13/","text":"事件系统Qt事件系统是非常重要事件传递机制，所有消息传递流程都离不开这个机制，这里主要从重写类的事件响应函数，事件过滤器以及重写event函数三种方式做介绍。 重写事件函数这种方式最为直接，我们先创建项目,选择QApplication应用，类名选择Widget，基类选择QWidget接下来在项目中添加一个C++类命名为MyEdit项目生成后，我们为MyEdit类添加声明和实现 123456789101112class MyEdit : public QLineEdit&#123; Q_OBJECTpublic: explicit MyEdit(QWidget *parent = nullptr);protected: void keyPressEvent(QKeyEvent *);signals:public slots:&#125;; MyEdit类的声明中添加了keyPressEvent函数的声明，该函数主要用来重写按键点击事件。我们接下来实现按键点击逻辑重写 123void MyEdit::keyPressEvent(QKeyEvent * event)&#123; qDebug()&lt;&lt;&quot;MyEdit key press event&quot;;&#125; 然后我们在Widget的构造函数中初始化这个edit，并添加到Widget上 12345678Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); line_edit_ = new MyEdit(this); line_edit_-&gt;move(100,100);&#125; 运行程序后点击lineEdit, 然后按下键盘，发现输出了”MyEdit key press event”。但是lineEdit的基本输入功能失效了，此时我们在keyPressEvent中添加 QLineEdit::keyPressEvent 1234void MyEdit::keyPressEvent(QKeyEvent * event)&#123; qDebug()&lt;&lt;&quot;MyEdit key press event&quot;; QLineEdit::keyPressEvent(event);&#125; 作用就是调用完我们的输出后，调用QLineEdit原有的按键处理逻辑，保证QLineEdit可以正常使用。 让父窗口和子窗口都响应事件为了让父窗口也响应按键事件，在父窗口Widget里同样实现keyPressEvent 123void Widget::keyPressEvent(QKeyEvent * event)&#123; qDebug()&lt;&lt;&quot;Widget key press event&quot; &lt;&lt; endl;&#125; 运行程序，我们在lineEdit中输入内容，发现此时只触发MyEdit的keyPressEvent。如果想要触发Wdiget的keyPressEvent，需要在MyEdit的keyPressEvent添加event-&gt;ignore() 12345void MyEdit::keyPressEvent(QKeyEvent * event)&#123; qDebug()&lt;&lt;&quot;MyEdit key press event&quot;; QLineEdit::keyPressEvent(event); event-&gt;ignore();&#125; event-&gt;ignore的作用是当MyEdit处理完keyPressEvent事件后，将按键消息继续抛给其父节点，也就是Widget，这样Widget就能处理按键消息了。 万能的event我们也可以重新实现MyEdit的event函数，这个函数的作用是所有的消息优先经过event处理，然后才根据不同的事件调用具体的事件处理函数如keyPressEvent，所以event的调用顺序优先于keyPressEvent。 12345678bool MyEdit::event(QEvent *pevent)&#123; if(pevent-&gt;type() == QEvent::KeyPress)&#123; qDebug() &lt;&lt; tr(&quot;my edit event&quot;) &lt;&lt; endl; &#125; return QLineEdit::event(pevent);&#125; 在event里判断事件类型为KeyPress，也就是按键事件，就打印”my edit event”，然后调用QLineEdit::event，以保证其QLineEdit的原有功能。此时在LineEdit中输入内容，就会先输出”my edit event”再输出”MyEdit key press event”。 eventFilter事件过滤器要实现对某个控件事件的捕获，可以通过对其父窗口重写eventFilter函数，这个函数是过滤器，在这个过滤器里可以根据对象和事件类型进行。我们在Widget类实现 1234567891011bool Widget::eventFilter(QObject *object, QEvent *event)&#123; if(object == line_edit_)&#123; if(event-&gt;type() == QEvent::KeyPress)&#123; qDebug() &lt;&lt; &quot;widget eventfilter catch line_edit&quot; &lt;&lt; endl; return false; &#125; &#125; return QWidget::eventFilter(object, event);&#125; 在eventFilter里判断对象为line_edit_，并且事件类型为KeyPress，则打印日志，并且返回false，返回false意思是将该消息继续传递，这个按键消息会传递给MyEdit的event函数，然后是MyEdit的keyPressEvent函数。仅仅实现eventFilter是不够的，我们需要在Widget的构造函数中加载这个过滤器。 1line_edit_-&gt;installEventFilter(this); 这样再次运行程序，在lineEdit中按下键盘，会看到程序输出如下 1234widget eventfilter catch line_edit my edit event MyEdit key press eventWidget key press event 可见消息捕获的顺序是 Widget::eventfilter -&gt; MyEdit::event-&gt; MyEdit::keyPressEvent -&gt; MyWidget::keyPressEvent 为多个控件添加eventFilter我们可以在父窗口为其多个子节点控件添加eventFilter。我们在Widget中添加两个控件QTextEdit和QSpinBox, 然后再重新实现Widget的eventFilter 1234567891011121314151617181920212223242526272829303132bool Widget::eventFilter(QObject *watched, QEvent *event)&#123; if(watched == ui-&gt;textEdit)&#123; if(event-&gt;type() == QEvent::Wheel)&#123; QWheelEvent* wheelEvent = static_cast&lt;QWheelEvent*&gt;(event); if(wheelEvent-&gt;delta() &gt; 0)&#123; qDebug() &lt;&lt; &quot;catch wheel event delta &gt; 0&quot; &lt;&lt; endl; ui-&gt;textEdit-&gt;zoomIn(); &#125;else &#123; qDebug() &lt;&lt; &quot;catch wheel event delta &lt; 0&quot; &lt;&lt; endl; ui-&gt;textEdit-&gt;zoomOut(); &#125; return true; &#125; return false; &#125; if(watched == ui-&gt;spinBox)&#123; if(event-&gt;type() == QEvent::KeyPress)&#123; QKeyEvent * keyEvent = static_cast&lt;QKeyEvent*&gt;(event); if(keyEvent-&gt;key() == Qt::Key_Space)&#123; ui-&gt;spinBox-&gt;setValue(0); return true; &#125; return false; &#125; return false; &#125; return QWidget::eventFilter(watched, event);&#125; eventFilter 中根据不同的对象实现了不同的事件捕获，对于textEdit捕获了滚轮事件对于spinbox，捕获了空格按键。 然后在Widget的构造函数中为两个控件安装过滤器 12ui-&gt;textEdit-&gt;installEventFilter(this);ui-&gt;spinBox-&gt;installEventFilter(this); 运行程序就可以在滚轮滚动时缩放textEdit，按下空格键就可以使spinbox清零。 总结源码链接：https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 拖拽事件","date":"2022-11-28T03:27:16.000Z","path":"2022/11/28/qt12/","text":"简介拖拽事件是我们在设计软件时常用的事件，比如我们把要上传的文件拖拽到指定区域实现自动上传，或者拖动到指定文件夹等。这里主要介绍如何实现拖动事件，包括事件的进入dragEnterEvent, 事件的放弃dropEvent等。我们要实现一个拖动demo，将文件拖动到主窗口区域，然后在主窗口的textEdit控件中显示文件的内容。 主窗口构造创建项目名字为dragevent,然后选择创建QApplication项目，我们的类名叫做MainWindow,基类选择QMainWindow。我们需要在主窗口的ui文件中添加QTextEdit控件，点击Forms下的mainwindow.ui,将QTextEdit拖动到主窗口界面上。 然后我们需要在主窗口构造函数中添加如下代码 12setAcceptDrops(true);ui-&gt;textEdit-&gt;setAcceptDrops(false); 设置主窗口可以接收拖动的放下事件。禁用textEdit的放下事件。 重写拖拽进入事件我们需要在MainWindow类里重写dragEnterEvent事件函数,该函数主要是重写拖动进入某个控件后要执行的逻辑，所以我们在MainWindow类里重写 1234567891011void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; //判断是否包含url if(event-&gt;mimeData()-&gt;hasUrls())&#123; //接收动作 event-&gt;acceptProposedAction(); &#125;else&#123; //放弃事件 event-&gt;ignore(); &#125;&#125; 当我们执行拖动操作的时候，Qt会将拖动的内容转变为url写入event的mimeData中。所以这里通过mimeData的hasUrls函数判断是否又url。如果有则调用acceptProposedAction接收这个动作。否则就忽略这个动作，忽略表示不处理拖拽事件了。 重写松开按钮事件当鼠标松开时，需要将拖拽的文件内容写入textEdit来显示。重写dropEvent实现在MainWindow界面上松开鼠标时内容的读取逻辑。先从event的mimeData中获取QMimeData类型的数据，然后判断是否有url。如果有则取出所有urls，因为默认这里实现的逻辑是拖动单个文件，如果是多个文件可以通过遍历urlList的方式一个一个处理拖动的内容，这里只处理一个。为防止乱码，采用了utf-8的方式进行解码。通过文本流QTextStream将文件内容显示到textEdit中。 123456789101112131415161718192021222324252627void MainWindow::dropEvent(QDropEvent * event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); //判断是否包含url if(mimeData-&gt;hasUrls())&#123; QList&lt;QUrl&gt; urlList = mimeData-&gt;urls(); //将第一个匹配为本地文件路径 QString filename = urlList[0].toLocalFile(); if(!filename.isEmpty())&#123; QTextCodec *codec=QTextCodec::codecForName(&quot;UTF-8&quot;); QFile file(filename); //打开文件失败 if(!file.open(QIODevice::ReadOnly))&#123; return; &#125; QTextCodec::setCodecForLocale(codec); //打开成功 QTextStream in(&amp;file); //qDebug()&lt;&lt; &quot;in readall is &quot; &lt;&lt; in.readAll() &lt;&lt; endl; ui-&gt;textEdit-&gt;setText(in.readAll()); &#125; &#125;else&#123; event-&gt;ignore(); &#125;&#125; 通过测试拖动一个文件到MainWindow中，textEdit显示了该文件的内容如下： 源码资源源码链接https://gitee.com/secondtonone1/qt-learning-notes.git","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"MarkDown在线编辑器","date":"2022-11-10T09:56:36.000Z","path":"2022/11/10/sln02/","text":"项目简介要求实现一个在线markdown编辑器，支持markdown文件的在线编辑，修改，重新加载，转化为html格式等。 Pandao MarkDown编辑器Pandao MarkDown是基于BootStrap和jquery实现的MarkDown编辑器，已经支持MarkDown在线编辑功能，我们要做的是做一个demo把Pando MarkDown的功能调用起来，形成一整套的发布，编辑，修改等流程。Pandao MarkDown 的官网https://pandao.github.io/editor.md/Pandao MarkDown 的项目地址https://github.com/pandao/editor.md 发布页面实现发布页面publish.html，这个页面不做过多粘贴，只截取一小部分作示例，详细的文件在这里https://cdn.llfc.club/publish.html 123456789101112131415161718&lt;link rel=&quot;stylesheet&quot; href=&quot;editormd/css/editormd.css&quot; /&gt;&lt;div id=&quot;test-editor&quot;&gt; &lt;textarea style=&quot;display:none;&quot;&gt;### 关于 Editor.md**Editor.md** 是一款开源的、可嵌入的 Markdown 在线编辑器（组件），基于 CodeMirror、jQuery 和 Marked 构建。 &lt;/textarea&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;editormd/editormd.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; var editor = editormd(&quot;test-editor&quot;, &#123; // width : &quot;100%&quot;, // height : &quot;100%&quot;, path : &quot;editormd/lib/&quot; &#125;); &#125;);&lt;/script&gt; 为id为test-editor的div生成了markdown编辑器，我们可以看一下效果 markdown转化为html将markdown转化为html，需要使用markdownToHTML函数，这个函数需要传入一个节点用来接收转化生成的html。在publish.html中再添加一个按钮用来发布文章，和一个id为”test-markdown-view”的div用来接收生成的html 12345678910111213141516&lt;div class=&quot;container-fluid&quot; id=&quot;article-publish&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col publish-btn-parent&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;publish-post-btn&quot;&gt;发布文章&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;return-index-btn&quot;&gt;返回列表&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;div id=&quot;test-markdown-view&quot; class=&quot;&quot;&gt; &lt;!-- Server-side output Markdown text --&gt; &lt;textarea style=&quot;display:none;&quot;&gt;### Hello world!&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 接下来实现markdown转化为html的逻辑 12345678910111213141516171819202122232425262728293031323334353637//获取md内容转化为htmlvar testView = editormd.markdownToHTML(&quot;test-markdown-view&quot;, &#123; markdown: $(&quot;textarea.editormd-markdown-textarea&quot;).text(),&#125;);//组装json发送给服务器let post_data = &#123; &quot;md-content&quot;: $(&quot;textarea.editormd-markdown-textarea&quot;).text(), &quot;html-content&quot;: $(&quot;#test-markdown-view&quot;).prop(&quot;outerHTML&quot;), &quot;title&quot;: title,&#125;$.ajax(&#123; type: &quot;post&quot;, contentType: &quot;application/json;charset=utf-8&quot;, data: JSON.stringify(post_data), url: &quot;/publish-article&quot;, dataType: &quot;json&quot;, async: false, success: function (data) &#123; if (data.errorcode != 0) &#123; alert(`request error , code is $&#123;data.errorcode&#125;`) return; &#125; window.location.href = &#x27;/&#x27; &#125;, error: function (XMLHttpRequest, textStatus, errorThrown) &#123; // 状态码 console.log(XMLHttpRequest.status); // 状态 console.log(XMLHttpRequest.readyState); // 错误信息 console.log(textStatus); &#125;&#125;); 将md转化为html放在了id为”test-markdown-view”的div下，然后组装post_data，将markdown和html内容都发送给了服务器，服务器存储起来，方便下次修改时读取。 显示文章因为服务器已经存储了html和markdown内容，接下来显示文章只需要读取html就可以了先实现一个获取文章内容的函数 123456789101112131415161718192021222324252627282930313233343536//请求单个文章的详情function GetArticleDetail(article_id) &#123; let post_data = &#123; &#x27;article_id&#x27;: article_id &#125; $.ajax( &#123; type: &quot;post&quot;, contentType: &quot;application/json;charset=utf-8&quot;, data: JSON.stringify(post_data), url: &quot;/article-detail&quot;, dataType: &quot;json&quot;, async: false, success: function (data) &#123; if (data.errorcode != 0) &#123; alert(`request error , code is $&#123;data.errorcode&#125;`) return; &#125; console.log(&quot;get article deatail is &quot;, data) //编译模板的里的内容 var template = Handlebars.compile($(&#x27;#template-article-info&#x27;).html()); //把后台获取到的数据student渲染到页面 $(&#x27;#article-info-div&#x27;).html(template(data[&#x27;article-detail&#x27;])); $(&#x27;#article-title-div&gt;h1&#x27;).html(data[&#x27;article-detail&#x27;].title); $(&#x27;.article-div&#x27;).html(data[&#x27;article-detail&#x27;][&#x27;html-content&#x27;]) &#125;, error: function (XMLHttpRequest, textStatus, errorThrown) &#123; // 状态码 console.log(XMLHttpRequest.status); // 状态 console.log(XMLHttpRequest.readyState); // 错误信息 console.log(textStatus); &#125; &#125; )&#125; 在函数GetArticleDetail里我们将服务器传过来的数据通过模板编译显示在html里，并且获取了”html-content”放在$(‘.article-div’)节点下。服务器的逻辑就不赘述了，可以见文章底部的源码链接。文章页面article.html简要列举一段 1234567891011121314151617181920212223242526&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot; id=&quot;article-info-div&quot;&gt; &lt;script type=&quot;text/x-handlebars-template&quot; id=&quot;template-article-info&quot;&gt; &lt;div class=&quot;row &quot;&gt; &lt;div class=&quot;col article-div&quot; id=&#123;&#123;artid&#125;&#125; data-created=&#123;&#123;created&#125;&#125; data-title=&#123;&#123;title&#125;&#125;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/handlebars.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; var pathnames = window.location.pathname.split(&#x27;/&#x27;) if (pathnames.length &lt; 3) &#123; console.log(&quot;invalid url&quot;) return; &#125; var article_id = pathnames[2] GetArticleDetail(article_id) &#125;);&lt;/script&gt; 所以实现过后文章页面的效果大体是这个样子 再次编辑对于已经发布的文章，有时候需要再次编辑，这个时候可以通过前端向服务器发送请求获取存储的markdown，编辑markdown之后生成新的html，再次发送给服务器，以达到更新文章的目的.简单列举一下edit.html的内容 123456789101112131415161718192021222324252627&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;test-editor&quot; class=&quot;col&quot;&gt; &lt;textarea style=&quot;display:none;&quot;&gt;### Editor.md **Editor.md**: The open source embeddable online markdown editor, based on CodeMirror &amp; jQuery &amp; Marked. &lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;container-fluid&quot; id=&quot;article-publish&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col publish-btn-parent&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;publish-edit-btn&quot;&gt;更新文章&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;return-index-btn&quot;&gt;返回列表&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;div id=&quot;test-markdown-view&quot; class=&quot;&quot;&gt; &lt;!-- Server-side output Markdown text --&gt; &lt;textarea style=&quot;display:none;&quot;&gt;### Hello world!&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 和public.html类似，edit.html也包含更新按钮以及id为“test-editor”的div，该div用来存储markdown内容。id为”test-markdown-view”的div用来存储markdown转化的html内容。我们在页面里生成editor编辑器，并且从服务器获取markdown内容写入id为”test-editor”的div里 1234567891011121314151617181920212223242526272829303132&lt;script&gt; $(function () &#123; var editor = editormd(&quot;test-editor&quot;, &#123; height: &#x27;800px&#x27;, syncScrolling: &quot;single&quot;, emoji: true, //启动本地图片上传功能 imageUpload: true, watch: true, imageFormats: [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;, &quot;zip&quot;, &quot;rar&quot;], path: &quot;./editormd/lib/&quot;, imageUploadURL: &quot;./upload.php&quot;, //文件提交请求路径 saveHTMLToTextarea: true, //注意3：这个配置，方便post提交表单 previewTheme: &quot;dark&quot;,//预览主题样式 默认白色 dark为黑色 &#125;); &#125;)&lt;/script&gt;&lt;script&gt; $(function () &#123; var pathnames = window.location.pathname.split(&#x27;/&#x27;) if (pathnames.length &lt; 3) &#123; console.log(&quot;invalid url&quot;) return; &#125; var article_id = pathnames[2] GetArticleEdit(article_id) // console.log(&#x27;window.location.pathname is &#x27;, window.location.pathname.split(&#x27;/&#x27;)) &#125;);&lt;/script&gt; GetArticleEdit 这个函数用来从服务器获取markdown数据拼接到div上 123456789101112131415161718192021222324252627282930313233//请求单个文章编辑页面内容function GetArticleEdit(article_id) &#123; let post_data = &#123; &#x27;article_id&#x27;: article_id &#125; $.ajax( &#123; type: &quot;post&quot;, contentType: &quot;application/json;charset=utf-8&quot;, data: JSON.stringify(post_data), url: &quot;/article-detail&quot;, dataType: &quot;json&quot;, async: false, success: function (data) &#123; if (data.errorcode != 0) &#123; alert(`request error , code is $&#123;data.errorcode&#125;`) return; &#125; console.log(&quot;get article deatail is &quot;, data) $(&quot;textarea.editormd-markdown-textarea&quot;).text(data[&#x27;article-detail&#x27;][&#x27;md-content&#x27;]) $(&quot;#title-input&quot;).val(data[&#x27;article-detail&#x27;][&#x27;title&#x27;]) $(&quot;#title-input&quot;).attr(&#x27;data-artid&#x27;, data[&#x27;article-detail&#x27;][&#x27;artid&#x27;]) &#125;, error: function (XMLHttpRequest, textStatus, errorThrown) &#123; // 状态码 console.log(XMLHttpRequest.status); // 状态 console.log(XMLHttpRequest.readyState); // 错误信息 console.log(textStatus); &#125; &#125; )&#125; 所以通过这些逻辑我们实现了编辑功能，进入编辑页面后自动将服务器存储的markdown内容加载到页面上，编辑页面基本是这个样子这样就实现了在线编辑，重新发布的功能。 总结整体来看，通过我们的重组和架构可以实现markdown文档的在线编辑和发布。感兴趣的可以看看我的源码,源码地址如下https://gitee.com/secondtonone1/pandaomd-pro原文链接https://llfc.club/articlepage?id=2HNduA4HWE8iMt06GH4uUi2cWLy","categories":[{"name":"问题汇总","slug":"Solution","permalink":"http://www.limerence2017.com/categories/Solution/"}],"tags":[{"name":"问题汇总","slug":"问题汇总","permalink":"http://www.limerence2017.com/tags/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"}]},{"title":"python创建虚拟环境","date":"2022-10-13T05:46:43.000Z","path":"2022/10/13/sln01/","text":"简介实际开发中，我们为了防止python安装的包污染用户环境，比如你是root用户，利用pip安装后的包会放在root的python安装录中，很可能会影响root用户的其他操作。我们用root用户使用pip安装软件包后，linux环境会报警告”Running pip as the ‘root’ user can result in broken permissions and conflicting behaviour”. 解决的方法很简答，安装虚拟环境即可。 安装虚拟环境 更新pip工具123python3 -m pip install --user --upgrade pippython3 -m pip --version 安装虚拟环境如果你的版本是python 3.3以上，则不需要安装虚拟环境相应的库，自带了venv这个库，用这个库来搭建虚拟环境就可以了。如果是python2或者python 3.3以下的版本，需要手动安装虚拟环境virtualenv。1python3 -m pip install --user virtualenv 3以上版本自带的venv库来搭建虚拟环境。1python3 -m venv env 如果是python2或者python3.3以下版本用下边这个命令生成虚拟环境1python3 -m virtualenv env 本文接下来主要介绍用python3.3以上的版本。在当前目录下生成了env文件夹，文件夹里有python相关的基本环境。如果想在某个路径生成可以将env替换为具体路径，比如/data/env，这样生成的虚拟环境目录就在/data/env里。激活虚拟环境生成虚拟环境后，需要激活这个环境，这样所有的安装包就会安装在env里。激活虚拟环境说白了就是将虚拟环境写入你系统的环境变量1source env/bin/activate 你可以查看当前python是哪一个1which python 也可以执行1python -V 查看当前env虚拟环境中python的版本。取消环境可以通过1deactivate 上述命令取消虚拟环境，将退出虚拟环境，回到主机自己的python环境。docker环境安装虚拟环境我们可以通过dockerfile build 一个python程序的镜像。而众所周知，python程序肯定要安装必要的库，如果一个一个pip install会导致容器层级过多，所以我们一把将所用的库写入requirements.txt中，至于怎么写可以看我的其他文章。在容器中用root用户pip安装python库同样会提示”Running pip as the ‘root’ user can result in broken permissions and conflicting behaviour”。我们知道了虚拟环境搭建的原理，所以在dockerfile里定义一个变量表示虚拟环境的路径，然后将这个路径写入path变量即可。123ENV VIRTUAL_ENV=/opt/venvRUN python -m venv $VIRTUAL_ENVENV PATH=&quot;$VIRTUAL_ENV/bin:$PATH&quot; 下面是我的一个程序用到的Dockerfile，大家可以感受下写法12345678FROM python:3.8ENV VIRTUAL_ENV=/opt/venvRUN python -m venv $VIRTUAL_ENVENV PATH=&quot;$VIRTUAL_ENV/bin:$PATH&quot;COPY crawler/ /data/srcWORKDIR /data/srcRUN pip install --upgrade pip &amp;&amp; pip install -r requirements.txtCMD [&quot;python&quot;, &quot;main.py&quot;] 总结这里介绍了python虚拟环境的安装，并且也提供了Docker环境如何安装python虚拟环境。相关参考连接https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/ https://stackoverflow.com/questions/48561981/activate-python-virtualenv-in-dockerfile","categories":[{"name":"问题汇总","slug":"Solution","permalink":"http://www.limerence2017.com/categories/Solution/"}],"tags":[{"name":"问题汇总","slug":"问题汇总","permalink":"http://www.limerence2017.com/tags/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"}]},{"title":"Qt 文本高亮","date":"2022-10-07T09:45:36.000Z","path":"2022/10/07/qt11/","text":"文本高亮对于textedit里录入的部分单词我们可以实现高亮，实现高亮主要依赖于QSyntaxHighlighter。我们先创建一个Qt Application类，类名MainWindow, 然后新增一个C++类，类名为MySyntaxHighlighter。 123456789101112131415#ifndef MYSYNTAXHIGHLIGHTER_H#define MYSYNTAXHIGHLIGHTER_H#include &lt;QSyntaxHighlighter&gt;#include &lt;QTextDocument&gt;class MySyntaxHighlighter:public QSyntaxHighlighter&#123; Q_OBJECTpublic: explicit MySyntaxHighlighter(QTextDocument* parent = 0); //重写实现高亮protected: void highlightBlock(const QString&amp; text);&#125;;#endif // MYSYNTAXHIGHLIGHTER_H 这个类声明了highlightBlock函数，这是一个虚函数继承自QSyntaxHighlighter。每次我们录入文字时，会自动调用这个函数。下面实现MySyntaxHighlighter类 123456789101112131415161718192021222324252627#include &quot;mysyntaxhighlighter.h&quot;#include &lt;QFont&gt;MySyntaxHighlighter::MySyntaxHighlighter(QTextDocument* parent):QSyntaxHighlighter (parent)&#123;&#125;void MySyntaxHighlighter::highlightBlock(const QString &amp;text)&#123; QTextCharFormat myFormat; myFormat.setFont(QFont(&quot;微软雅黑&quot;)); myFormat.setFontWeight(QFont::Bold); myFormat.setForeground(Qt::green); //匹配char QString pattern = &quot;\\\\bchar\\\\b&quot;; //创建正则表达式 QRegExp express(pattern); //从索引0的位置开始匹配 int index = text.indexOf(express); while (index&gt;0) &#123; int matchLen = express.matchedLength(); //对匹配的字符串设置高亮 setFormat(index, matchLen, myFormat); index = text.indexOf(express, index+matchLen); &#125;&#125; 在highlightBlock函数中，我们实现了一个高亮的文字模式，当录入的字符串包含char时，char会被高亮。我们在mainwindow.ui中添加一个textedit，然后在mainwindow的构造函数中添加我们刚才编写的高亮模块。 1234567MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); m_ligher = new MySyntaxHighlighter(ui-&gt;textEdit-&gt;document());&#125; 程序运行后，在编辑器中输入hello char，会看到char高亮了 实现代码编辑器Qt 的案例中有提供过文本高亮和显示行号的demo，我把它整理起来了。我们先声明codeeditor类，以及行号显示的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#ifndef CODEEDITOR_H#define CODEEDITOR_H#include &lt;QPlainTextEdit&gt;QT_BEGIN_NAMESPACEclass QPaintEvent;class QResizeEvent;class QSize;class QWidget;QT_END_NAMESPACEclass LineNumberArea;class CodeEditor : public QPlainTextEdit&#123; Q_OBJECTpublic: CodeEditor(QWidget *parent = nullptr); void lineNumberAreaPaintEvent(QPaintEvent *event); int lineNumberAreaWidth();protected: void resizeEvent(QResizeEvent *event) override;private slots: void updateLineNumberAreaWidth(int newBlockCount); void highlightCurrentLine(); void updateLineNumberArea(const QRect &amp;rect, int dy);private: QWidget *lineNumberArea;&#125;;class LineNumberArea : public QWidget&#123;public: LineNumberArea(CodeEditor *editor) : QWidget(editor), codeEditor(editor) &#123;&#125; QSize sizeHint() const override &#123; return QSize(codeEditor-&gt;lineNumberAreaWidth(), 0); &#125;protected: void paintEvent(QPaintEvent *event) override &#123; codeEditor-&gt;lineNumberAreaPaintEvent(event); &#125;private: CodeEditor *codeEditor;&#125;;#endif 具体代码类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;codeeditor.h&quot;#include &lt;QPainter&gt;#include &lt;QTextBlock&gt;CodeEditor::CodeEditor(QWidget *parent) : QPlainTextEdit(parent)&#123; lineNumberArea = new LineNumberArea(this); connect(this, &amp;CodeEditor::blockCountChanged, this, &amp;CodeEditor::updateLineNumberAreaWidth); connect(this, &amp;CodeEditor::updateRequest, this, &amp;CodeEditor::updateLineNumberArea); connect(this, &amp;CodeEditor::cursorPositionChanged, this, &amp;CodeEditor::highlightCurrentLine); updateLineNumberAreaWidth(0); highlightCurrentLine();&#125;int CodeEditor::lineNumberAreaWidth()&#123; int digits = 1; int max = qMax(1, blockCount()); while (max &gt;= 10) &#123; max /= 10; ++digits; &#125; int space = 3 + fontMetrics().horizontalAdvance(QLatin1Char(&#x27;9&#x27;)) * digits; return space;&#125;void CodeEditor::updateLineNumberAreaWidth(int /* newBlockCount */)&#123; setViewportMargins(lineNumberAreaWidth(), 0, 0, 0);&#125;void CodeEditor::updateLineNumberArea(const QRect &amp;rect, int dy)&#123; if (dy) lineNumberArea-&gt;scroll(0, dy); else lineNumberArea-&gt;update(0, rect.y(), lineNumberArea-&gt;width(), rect.height()); if (rect.contains(viewport()-&gt;rect())) updateLineNumberAreaWidth(0);&#125;void CodeEditor::resizeEvent(QResizeEvent *e)&#123; QPlainTextEdit::resizeEvent(e); QRect cr = contentsRect(); lineNumberArea-&gt;setGeometry(QRect(cr.left(), cr.top(), lineNumberAreaWidth(), cr.height()));&#125;void CodeEditor::highlightCurrentLine()&#123; QList&lt;QTextEdit::ExtraSelection&gt; extraSelections; if (!isReadOnly()) &#123; QTextEdit::ExtraSelection selection; QColor lineColor = QColor(Qt::yellow).lighter(160); selection.format.setBackground(lineColor); selection.format.setProperty(QTextFormat::FullWidthSelection, true); selection.cursor = textCursor(); selection.cursor.clearSelection(); extraSelections.append(selection); &#125; setExtraSelections(extraSelections);&#125;void CodeEditor::lineNumberAreaPaintEvent(QPaintEvent *event)&#123; QPainter painter(lineNumberArea); painter.fillRect(event-&gt;rect(), Qt::lightGray); QTextBlock block = firstVisibleBlock(); int blockNumber = block.blockNumber(); int top = qRound(blockBoundingGeometry(block).translated(contentOffset()).top()); int bottom = top + qRound(blockBoundingRect(block).height()); while (block.isValid() &amp;&amp; top &lt;= event-&gt;rect().bottom()) &#123; if (block.isVisible() &amp;&amp; bottom &gt;= event-&gt;rect().top()) &#123; QString number = QString::number(blockNumber + 1); painter.setPen(Qt::black); painter.drawText(0, top, lineNumberArea-&gt;width(), fontMetrics().height(), Qt::AlignHCenter, number); &#125; block = block.next(); top = bottom; bottom = top + qRound(blockBoundingRect(block).height()); ++blockNumber; &#125;&#125; 上面实现了代码编辑器的行号和当前行黄色高亮显示。接下来实现高亮显示类 12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef HIGHLIGHTER_H#define HIGHLIGHTER_H#include &lt;QSyntaxHighlighter&gt;#include &lt;QTextCharFormat&gt;#include &lt;QRegularExpression&gt;QT_BEGIN_NAMESPACEclass QTextDocument;QT_END_NAMESPACE//! [0]class Highlighter : public QSyntaxHighlighter&#123; Q_OBJECTpublic: Highlighter(QTextDocument *parent = 0);protected: void highlightBlock(const QString &amp;text) override;private: struct HighlightingRule &#123; QRegularExpression pattern; QTextCharFormat format; &#125;; QVector&lt;HighlightingRule&gt; highlightingRules; QRegularExpression commentStartExpression; QRegularExpression commentEndExpression; QTextCharFormat keywordFormat; QTextCharFormat classFormat; QTextCharFormat singleLineCommentFormat; QTextCharFormat multiLineCommentFormat; QTextCharFormat quotationFormat; QTextCharFormat functionFormat;&#125;;//! [0]#endif // HIGHLIGHTER_H 具体实现细节如下，先定义高亮的正则规则，然后在highlightBlock函数里根据规则点亮不同的单词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &quot;highlighter.h&quot;//! [0]Highlighter::Highlighter(QTextDocument *parent) : QSyntaxHighlighter(parent)&#123; HighlightingRule rule; keywordFormat.setForeground(Qt::darkBlue); keywordFormat.setFontWeight(QFont::Bold); const QString keywordPatterns[] = &#123; QStringLiteral(&quot;\\\\bchar\\\\b&quot;), QStringLiteral(&quot;\\\\bclass\\\\b&quot;), QStringLiteral(&quot;\\\\bconst\\\\b&quot;), QStringLiteral(&quot;\\\\bdouble\\\\b&quot;), QStringLiteral(&quot;\\\\benum\\\\b&quot;), QStringLiteral(&quot;\\\\bexplicit\\\\b&quot;), QStringLiteral(&quot;\\\\bfriend\\\\b&quot;), QStringLiteral(&quot;\\\\binline\\\\b&quot;), QStringLiteral(&quot;\\\\bint\\\\b&quot;), QStringLiteral(&quot;\\\\blong\\\\b&quot;), QStringLiteral(&quot;\\\\bnamespace\\\\b&quot;), QStringLiteral(&quot;\\\\boperator\\\\b&quot;), QStringLiteral(&quot;\\\\bprivate\\\\b&quot;), QStringLiteral(&quot;\\\\bprotected\\\\b&quot;), QStringLiteral(&quot;\\\\bpublic\\\\b&quot;), QStringLiteral(&quot;\\\\bshort\\\\b&quot;), QStringLiteral(&quot;\\\\bsignals\\\\b&quot;), QStringLiteral(&quot;\\\\bsigned\\\\b&quot;), QStringLiteral(&quot;\\\\bslots\\\\b&quot;), QStringLiteral(&quot;\\\\bstatic\\\\b&quot;), QStringLiteral(&quot;\\\\bstruct\\\\b&quot;), QStringLiteral(&quot;\\\\btemplate\\\\b&quot;), QStringLiteral(&quot;\\\\btypedef\\\\b&quot;), QStringLiteral(&quot;\\\\btypename\\\\b&quot;), QStringLiteral(&quot;\\\\bunion\\\\b&quot;), QStringLiteral(&quot;\\\\bunsigned\\\\b&quot;), QStringLiteral(&quot;\\\\bvirtual\\\\b&quot;), QStringLiteral(&quot;\\\\bvoid\\\\b&quot;), QStringLiteral(&quot;\\\\bvolatile\\\\b&quot;), QStringLiteral(&quot;\\\\bbool\\\\b&quot;) &#125;; for (const QString &amp;pattern : keywordPatterns) &#123; rule.pattern = QRegularExpression(pattern); rule.format = keywordFormat; highlightingRules.append(rule);//! [0] //! [1] &#125;//! [1]//! [2] classFormat.setFontWeight(QFont::Bold); classFormat.setForeground(Qt::darkMagenta); rule.pattern = QRegularExpression(QStringLiteral(&quot;\\\\bQ[A-Za-z]+\\\\b&quot;)); rule.format = classFormat; highlightingRules.append(rule);//! [2]//! [3] singleLineCommentFormat.setForeground(Qt::red); rule.pattern = QRegularExpression(QStringLiteral(&quot;//[^\\n]*&quot;)); rule.format = singleLineCommentFormat; highlightingRules.append(rule); multiLineCommentFormat.setForeground(Qt::red);//! [3]//! [4] quotationFormat.setForeground(Qt::darkGreen); rule.pattern = QRegularExpression(QStringLiteral(&quot;\\&quot;.*\\&quot;&quot;)); rule.format = quotationFormat; highlightingRules.append(rule);//! [4]//! [5] functionFormat.setFontItalic(true); functionFormat.setForeground(Qt::blue); rule.pattern = QRegularExpression(QStringLiteral(&quot;\\\\b[A-Za-z0-9_]+(?=\\\\()&quot;)); rule.format = functionFormat; highlightingRules.append(rule);//! [5]//! [6] commentStartExpression = QRegularExpression(QStringLiteral(&quot; /\\\\*&quot;)); commentEndExpression = QRegularExpression(QStringLiteral(&quot;\\\\*/&quot;));&#125;//! [6]//! [7]void Highlighter::highlightBlock(const QString &amp;text)&#123; for (const HighlightingRule &amp;rule : qAsConst(highlightingRules)) &#123; QRegularExpressionMatchIterator matchIterator = rule.pattern.globalMatch(text); while (matchIterator.hasNext()) &#123; QRegularExpressionMatch match = matchIterator.next(); setFormat(match.capturedStart(), match.capturedLength(), rule.format); &#125; &#125;//! [7] //! [8] setCurrentBlockState(0);//! [8]//! [9] int startIndex = 0; if (previousBlockState() != 1) startIndex = text.indexOf(commentStartExpression);//! [9] //! [10] while (startIndex &gt;= 0) &#123;//! [10] //! [11] QRegularExpressionMatch match = commentEndExpression.match(text, startIndex); int endIndex = match.capturedStart(); int commentLength = 0; if (endIndex == -1) &#123; setCurrentBlockState(1); commentLength = text.length() - startIndex; &#125; else &#123; commentLength = endIndex - startIndex + match.capturedLength(); &#125; setFormat(startIndex, commentLength, multiLineCommentFormat); startIndex = text.indexOf(commentStartExpression, startIndex + commentLength); &#125;&#125;//! [11] 接下来在MainWindow里添加editor 12345678910111213141516void MainWindow::setupEditor()&#123; QFont font; font.setFamily(&quot;Courier&quot;); font.setFixedPitch(true); font.setPointSize(10); editor = new CodeEditor(); editor-&gt;setFont(font); highlighter = new Highlighter(editor-&gt;document()); QFile file(&quot;mainwindow.h&quot;); if (file.open(QFile::ReadOnly | QFile::Text)) editor-&gt;setPlainText(file.readAll());&#125; 运行程序后,输入部分代码显示如下具体细节大家可以参考代码理解即可。 总结源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt QTextEdit知识","date":"2022-10-06T13:38:10.000Z","path":"2022/10/06/qt10/","text":"简介QTextEdit是文本编辑器，支持富文本功能。接下来我们创建一个Qt Application 应用，然后在ui中添加一个QTextEdit插件。运行程序后，可以在QTextEdit中输入任何文字也包括富文本。 文本块我们在MainWindow的ui文件中添加了textedit插件，然后在MainWindow的构造函数中写代码，修改文本框样式 123456789101112MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QTextDocument *doc= ui-&gt;textEdit-&gt;document(); QTextFrame* root_frame = doc-&gt;rootFrame(); QTextFrameFormat format; format.setBorderBrush(Qt::blue); format.setBorder(3); root_frame-&gt;setFrameFormat(format);&#125; 通过textEdit的document函数返回文本块，再通过rootFrame获取根框架，设置这个框架的边框样式为蓝色，边框为3.运行程序后可以看到主窗口的textedit会显示一个蓝色边框的输入框，那就是根节点。我们可以插入两个纯文本 1234567891011121314MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QTextDocument *doc= ui-&gt;textEdit-&gt;document(); QTextFrame* root_frame = doc-&gt;rootFrame(); QTextFrameFormat format; format.setBorderBrush(Qt::blue); format.setBorder(3); root_frame-&gt;setFrameFormat(format); ui-&gt;textEdit-&gt;insertPlainText(&quot;hello world!\\n&quot;); ui-&gt;textEdit-&gt;insertPlainText(&quot;Hello Qt\\n&quot;);&#125; 运行程序会看到插入的纯文本在根文本块里。我们可以再设置一个文本样式，然后插入到光标所在的位置，这样会生成一个新的文本框架，然后插入两行文字，这样会生成两个文本块 12345678910QTextFrameFormat frameFormat;frameFormat.setBackground(Qt::lightGray);frameFormat.setMargin(10);frameFormat.setPadding(5);frameFormat.setBorder(2);frameFormat.setBorderStyle(QTextFrameFormat::BorderStyle_Dashed);QTextCursor cursor = ui-&gt;textEdit-&gt;textCursor();cursor.insertFrame(frameFormat);ui-&gt;textEdit-&gt;insertPlainText(&quot;inner text!\\n&quot;);ui-&gt;textEdit-&gt;insertPlainText(&quot;Hello inner Text!\\n&quot;); 效果就是这样 遍历文本块我们可以遍历文本块和框架节点。先在构造函数中添加一个菜单，用来打印Frame和TextBlock 123QAction * action_frame = new QAction(&quot;Frame&quot;,this);connect(action_frame, &amp;QAction::triggered,this, &amp;MainWindow::showTextFrame);ui-&gt;mainToolBar-&gt;addAction(action_frame); 然后实现showTextFrame 123456789101112131415void MainWindow::showTextFrame()&#123; auto doc = ui-&gt;textEdit-&gt;document(); auto rootFrame = doc-&gt;rootFrame(); for(auto iter = rootFrame-&gt;begin(); iter != rootFrame-&gt;end(); iter++)&#123; auto cur_frame = iter.currentFrame(); auto cur_block = iter.currentBlock(); if(cur_frame)&#123; qDebug() &lt;&lt; &quot;cur node is frame &quot; ; &#125; else if(cur_block.isValid())&#123; qDebug() &lt;&lt; &quot;cur node is text block ,text is &quot; &lt;&lt; cur_block.text(); &#125; &#125;&#125; 程序输出 12345cur node is text block ,text is &quot;hello world!&quot;cur node is text block ,text is &quot;Hello Qt&quot;cur node is text block ,text is &quot;&quot;cur node is frame cur node is text block ,text is &quot;&quot; 如果只想打印文本块，我们可以用这种方式, 现在MainWindow的构造函数中添加一个显示文本的菜单项 123QAction* action_textBlock = new QAction(tr(&quot;文本块&quot;),this);connect(action_textBlock, &amp;QAction::triggered, this, &amp;MainWindow::showTextBlock);ui-&gt;mainToolBar-&gt;addAction(action_textBlock); 显示文本块的逻辑如下 12345678910void MainWindow::showTextBlock()&#123; QTextDocument* document = ui-&gt;textEdit-&gt;document(); QTextBlock block = document-&gt;firstBlock(); for(int i = 0; i &lt; document-&gt;blockCount(); i++)&#123; qDebug() &lt;&lt; tr(&quot;文本块%1, 文本块首行行号%2, 长度%3, 内容%4&quot;).arg(i).arg(block.firstLineNumber()).arg(block.length()) &lt;&lt; block.text(); block = block.next(); &#125;&#125; 运行程序后点击文本块菜单，会输出如下 1234567&quot;文本块0, 文本块首行行号0, 长度13, 内容%4&quot; &quot;hello world!&quot;&quot;文本块1, 文本块首行行号1, 长度9, 内容%4&quot; &quot;Hello Qt&quot;&quot;文本块2, 文本块首行行号2, 长度1, 内容%4&quot; &quot;&quot;&quot;文本块3, 文本块首行行号3, 长度12, 内容%4&quot; &quot;inner text!&quot;&quot;文本块4, 文本块首行行号4, 长度18, 内容%4&quot; &quot;Hello inner Text!&quot;&quot;文本块5, 文本块首行行号5, 长度1, 内容%4&quot; &quot;&quot;&quot;文本块6, 文本块首行行号6, 长度1, 内容%4&quot; &quot;&quot; 设置文本块样式之前我们设置的都是文本框架的样式，这次我们设置文本块的样式.在构造函数中添加字体菜单，用来设置文本块的字体样式 1234QAction* action_font = new QAction(tr(&quot;字体&quot;), this);action_font-&gt;setCheckable(true);connect(action_font, &amp;QAction::toggled, this, &amp;MainWindow::setTextFont);ui-&gt;mainToolBar-&gt;addAction(action_font); setTextFont槽函数实现如下 12345678910111213141516171819202122232425262728void MainWindow::setTextFont(bool checked)&#123; if(checked)&#123; QTextCursor cursor = ui-&gt;textEdit-&gt;textCursor(); QTextBlockFormat blockFormat; blockFormat.setAlignment(Qt::AlignCenter); cursor.insertBlock(blockFormat); QTextCharFormat charFormat; charFormat.setBackground(Qt::lightGray); charFormat.setForeground(Qt::blue); charFormat.setFont(QFont(tr(&quot;宋体&quot;),12,QFont::Bold,true)); charFormat.setFontUnderline(true); cursor.setCharFormat(charFormat); cursor.insertText(tr(&quot;插入字体&quot;)); &#125;else&#123; QTextCursor cursor = ui-&gt;textEdit-&gt;textCursor(); QTextBlockFormat blockFormat; blockFormat.setAlignment(Qt::AlignLeft); cursor.insertBlock(blockFormat); QTextCharFormat charFormat;// charFormat.setBackground(Qt::white);// charFormat.setForeground(Qt::black);// charFormat.setFont(QFont(tr(&quot;微软雅黑&quot;),12,QFont::Normal, false));// charFormat.setFontUnderline(false); cursor.setCharFormat(charFormat); cursor.insertText(tr(&quot;微软雅黑字体&quot;)); &#125;&#125; 如果选中字体菜单，则设置插入新的文本块，文本块格式为宋体，加粗字样。如果取消选中，则插入新的文本块，设置为微软雅黑字体。运行程序后, 选中字体菜单，然后再点击字体菜单取消选中，会插入不同字体的文本块，显示如下 插入表格列表图片QTextEdit也支持插入表格，列表，图片等资源。在MainWindow的构造函数里增加列表，图片，表格的信号和槽函数连接逻辑 123456789QAction* action_textTable = new QAction(tr(&quot;表格&quot;), this);QAction* action_textList = new QAction(tr(&quot;列表&quot;), this);QAction* action_textImage = new QAction(tr(&quot;图片&quot;), this);connect(action_textTable, &amp;QAction::triggered,this, &amp;MainWindow::insertTable);ui-&gt;mainToolBar-&gt;addAction(action_textTable);connect(action_textList, &amp;QAction::triggered,this, &amp;MainWindow::insertList);ui-&gt;mainToolBar-&gt;addAction(action_textList);connect(action_textImage, &amp;QAction::triggered,this, &amp;MainWindow::insertImage);ui-&gt;mainToolBar-&gt;addAction(action_textImage); 然后实现这几个槽函数 1234567891011121314151617181920void MainWindow::insertTable()&#123; QTextCursor cursor = ui-&gt;textEdit-&gt;textCursor(); QTextTableFormat format; format.setCellSpacing(2); format.setCellPadding(10); cursor.insertTable(2,2,format);&#125;void MainWindow::insertList()&#123; QTextListFormat format; format.setStyle(QTextListFormat::ListDecimal); ui-&gt;textEdit-&gt;textCursor().insertList(format);&#125;void MainWindow::insertImage()&#123; QTextImageFormat format; format.setName(&quot;:/img/head.jpg&quot;); ui-&gt;textEdit-&gt;textCursor().insertImage(format);&#125; 运行程序后，点击这几个菜单，会依次插入表格，列表，图片等。 实现查找功能在构造函数里添加查找信号和槽函数的连接 12345678910111213QAction* action_textFind = new QAction(tr(&quot;查找&quot;), this);connect(action_textFind, &amp;QAction::triggered, this, &amp;MainWindow::textFind);ui-&gt;mainToolBar-&gt;addAction(action_textFind);findDialog = new QDialog(this);lineEdit = new QLineEdit(findDialog);QPushButton * btn = new QPushButton(findDialog);btn-&gt;setText(tr(&quot;查找下一个&quot;));connect(btn, &amp;QPushButton::clicked, this, &amp;MainWindow::findNext);QVBoxLayout* layout = new QVBoxLayout();layout-&gt;addWidget(lineEdit);layout-&gt;addWidget(btn);findDialog-&gt;setLayout(layout); 在构造函数里连接了查找菜单和槽函数textFind。然后创建了一个对话框，对话框上有一个lineedit，以及查找按钮，每次点击这个按钮就执行查找下一个的功能。运行后显示如下 总结源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 主窗口","date":"2022-10-06T08:31:17.000Z","path":"2022/10/06/qt09/","text":"简介任何界面应用都有一个主窗口，今天我们谈谈主窗口相关知识。一个主窗口包括菜单栏，工具栏，状态栏，以及中心区域等部分。我们先从菜单栏说起 菜单栏我们创建一个主窗口应用程序, 在ui文件里的菜单栏里有“在这里输入”的一个菜单，我们双击它输入“文件(&amp;F)”, 这样通过点击alt + F 就可以弹出文件菜单。点击文件菜单，同样会弹出“在这里输入”，我们双击它编辑输入“新建文件(&amp;N)”，可以在右侧的属性栏里为其添加一个图标，同样，我们再添加一个“显示Dock(&amp;D)”的菜单。我们再从左侧的控件Containers里拖动Dock Widget到中心区域，在dock widget中添加一个按钮，一个fontComboBox，一个QTextEdit。DockWidget添加的控件并不会影响主窗口的centralwidget, 我们在centralwidget中添加一个QMdiArea控件。我们可以选择Action Editor中的两个action，分别为其添加槽函数，右击actionnew_N选择转到槽，然后选择trigger信号，Qt会自动生成槽函数代码同样的道理为显示dock菜单添加槽函数，然后分别实现两个槽函数 1234567891011121314void MainWindow::on_actionnew_N_triggered()&#123; qDebug() &lt;&lt; &quot;新建文件...&quot; &lt;&lt; endl; QTextEdit * textEdit = new QTextEdit(this); auto childWindow = ui-&gt;mdiArea-&gt;addSubWindow(textEdit); childWindow-&gt;setWindowTitle(tr(&quot;文本编辑子窗口&quot;)); childWindow-&gt;show();&#125;void MainWindow::on_actionshowdock_triggered()&#123; qDebug() &lt;&lt; &quot;显示dock widget&quot; &lt;&lt; endl; ui-&gt;dockWidget_2-&gt;show();&#125; 因为QMdiArea是一个多窗口控件，这样我们每次点击新建菜单就会在窗口的中心部件中创建一个子窗口，多次点击会生成多个子窗口。点击显示dock菜单就会显示dockwidget。 我们可以在代码中添加菜单并创建菜单点击后的回调函数 1234567891011MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QMenu* editMenu = ui-&gt;menubar-&gt;addMenu(tr(&quot;编辑(&amp;E)&quot;)); editMenu-&gt;addSeparator(); QAction * action_Open = editMenu-&gt;addAction(QIcon(&quot;:/img/head.jpg&quot;), tr(&quot;打开文件(&amp;O)&quot;)); action_Open-&gt;setShortcut(QKeySequence(&quot;Ctrl+O&quot;)); connect(action_Open,&amp;QAction::triggered, this, &amp;MainWindow::on_action_open_triggered);&#125; 通过代码我们创建了一个编辑菜单，编辑菜单下有打开文件的动作，设置Ctrl+O为快捷键，并为该动作创建槽函数，然后连结这个槽函数。 1234void MainWindow::on_action_open_triggered()&#123; qDebug() &lt;&lt; &quot;打开文件...&quot; &lt;&lt; endl;&#125; 所以每次点击打开文件后输出上面的日志。除了可以为菜单栏添加动作外，还可以添加动作组 123456789101112//建立动作组QActionGroup * group = new QActionGroup(this);QAction * action_L = group-&gt;addAction(tr(&quot;左对(&amp;L)&quot;));action_L-&gt;setCheckable(true);QAction * action_R = group-&gt;addAction(tr(&quot;右对(&amp;R)&quot;));action_R-&gt;setCheckable(true);QAction * action_C = group-&gt;addAction(tr(&quot;居中(&amp;C)&quot;));action_C-&gt;setCheckable(true);editMenu-&gt;addSeparator();editMenu-&gt;addAction(action_L);editMenu-&gt;addAction(action_R);editMenu-&gt;addAction(action_C); 我们也可以自定义动作类，我们接下来自定义一个动作类，动作类包含一个label和lineEdit。自定义的动作类叫MyAction，声明如下 12345678910111213141516171819202122232425262728#ifndef MYACTION_H#define MYACTION_H#include &lt;QWidgetAction&gt;#include &lt;QLineEdit&gt;#include &lt;QObject&gt;class MyAction : public QWidgetAction&#123; Q_OBJECTsignals: void getText(const QString&amp; string);public: explicit MyAction(QObject * parent = 0); virtual ~MyAction();protected: virtual QWidget *createWidget(QWidget *parent);private slots: void sentText();private: //声明行编辑器对象 QLineEdit* lineEdit;&#125;;#endif // MYACTION_H createWidget 为一个虚函数，继承自QWidgetAction， 将Action加入菜单或者工具栏就会调用createWidget函数。接下来我们实现这个类 1234567891011121314151617181920212223242526272829#include &quot;myaction.h&quot;#include &lt;QSplitter&gt;#include &lt;QLabel&gt;MyAction::MyAction(QObject * parent):QWidgetAction(parent)&#123; // 创建行编辑器 lineEdit = new QLineEdit; // 将行编辑器的按下回车键信号和发送文本槽关联 connect(lineEdit, &amp;QLineEdit::returnPressed, this, &amp;MyAction::sentText);&#125;QWidget* MyAction::createWidget(QWidget * parent)&#123; if(parent-&gt;inherits(&quot;QMenu&quot;)|| parent-&gt;inherits(&quot;QToolBar&quot;))&#123; QSplitter * spliter = new QSplitter(parent); QLabel * label = new QLabel; label-&gt;setText(tr(&quot;插入文本:&quot;)); spliter-&gt;addWidget(label); spliter-&gt;addWidget(lineEdit); return spliter; &#125; return 0;&#125;void MyAction::sentText()&#123; emit getText(lineEdit-&gt;text()); lineEdit-&gt;clear();&#125; 构造函数里创建了一个LineEdit，然后绑定了LineEdit的返回信号，在sentText槽函数里发送了getText信号，然后清除了lineEdit里的内容。createWidget里判断了父节点如果是QMenu或者QToolBar，就创建一个spliter，然后将label和lineedit都加入spliter。在mainwindow的构造函数中创建MyAction，并且加入菜单里。然后将MyAction的getText的信号和MainWindow的setText函数绑定在一起。 123MyAction * action = new MyAction(this);editMenu-&gt;addAction(action);connect(action, &amp;MyAction::getText, this, &amp;MainWindow::setText); MainWindow的槽函数实现如下 123void MainWindow::setText(const QString &amp;string)&#123; ui-&gt;textEdit-&gt;setText(string);&#125; 这样当我们点击编辑菜单弹出我们自己实现的MyAction动作，在输入框里输入文字按下回车后文字就会显示到dockwidget的textedit中。 工具栏工具栏相比菜单栏更容易操作，更加直观，添加方式和菜单的方式类似，可以添加label，按钮，以及spinbox等。可以通过ui添加，也可以通过代码添加，下面用代码添加工具栏菜单。 123456789101112//工具栏添加元素QToolButton * toolBtn = new QToolButton(this);toolBtn-&gt;setText(tr(&quot;颜色&quot;));QMenu* colorMenu = new QMenu(this);colorMenu-&gt;addAction(tr(&quot;红色&quot;));colorMenu-&gt;addAction(tr(&quot;绿色&quot;));toolBtn-&gt;setMenu(colorMenu);toolBtn-&gt;setPopupMode(QToolButton::MenuButtonPopup);ui-&gt;toolBar-&gt;addWidget(toolBtn);QSpinBox* spinBox = new QSpinBox(this);ui-&gt;toolBar-&gt;addSeparator();ui-&gt;toolBar-&gt;addWidget(spinBox); 状态栏状态栏在窗口的下方，一般在右下方，左下方的为临时的，右下方的为永久的。 123456789void MainWindow::init_status_bar()&#123; //显示临时消息 ui-&gt;statusbar-&gt;showMessage(tr(&quot;欢迎使用多文档编辑器&quot;),2000); //创建标签 QLabel* permanent = new QLabel(this); permanent-&gt;setFrameStyle(QFrame::Box | QFrame::Sunken); permanent-&gt;setText(&quot;llfc.club&quot;); ui-&gt;statusbar-&gt;addPermanentWidget(permanent);&#125; 总结源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT 布局","date":"2022-10-06T07:36:33.000Z","path":"2022/10/06/qt08/","text":"简介Qt 中的布局有三种方式，水平布局，垂直布局，栅格布局。 通过ui设置布局我们先创建一个窗口应用程序，程序名叫layout，基类选择QMainWindow。但我们不使用这个mainwindow，我们创建一个Qt应用程序类Login，Qt会为我们自动生成login.ui文件。我们进入ui文件编辑，添加一个label，提示改为用户: ， 在后边添加一个lineedit控件，按住ctrl鼠标依次点击这两个控件选中后，再点击工具栏的水平布局按钮就可以看到用户label和输入框处于同一水平线了。但是输入框会被拉长，而且label和输入框占满了整个水平空间。这时我们可以通过拖动左侧控件列表中的Horizonal Spacer，将其放入用户标签的左侧，再拖动一个Horizonal Spacer将其放在输入框的右侧，就可以看到用户标签和输入框被挤在中间了，并且两侧留有空间了。Spacer可以设置几种模式，包括fixed，expanding, maximum, minimum等模式。依次类推，我们在添加密码标签和输入框，以及登录和注册按钮，通过ui界面的控件调整布局。 通过代码设置布局上面我们通过ui设置了布局，接下来我们通过代码设置布局，设置注册界面的布局注册类的声明如下 12345678910111213141516171819202122232425262728#ifndef REGISTER_H#define REGISTER_H#include &lt;QDialog&gt;#include &lt;memory&gt;using namespace std;class Login;namespace Ui &#123;class Register;&#125;class Register : public QDialog&#123; Q_OBJECTpublic: explicit Register(QWidget *parent = nullptr); ~Register(); void set_login(const weak_ptr&lt;Login&gt; &amp;_login);private: Ui::Register *ui; weak_ptr&lt;Login&gt; _login; QPushButton* _reg_btn;public slots: void ShowLogin();&#125;;#endif // REGISTER_H 因为要实现登录和注册界面之间的切换，所以Register类包含了Login类的弱指针，Register类的具体实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;register.h&quot;#include &quot;ui_register.h&quot;#include &lt;QHBoxLayout&gt;#include &lt;QVBoxLayout&gt;#include &lt;QLabel&gt;#include &lt;QLineEdit&gt;#include &lt;QPushButton&gt;#include &lt;QSpacerItem&gt;Register::Register(QWidget *parent) : QDialog(parent), ui(new Ui::Register)&#123; ui-&gt;setupUi(this); this-&gt;setMaximumSize(QSize(300,350)); this-&gt;setMinimumSize(QSize(300,350)); auto vbox_layout = new QVBoxLayout(); auto verticalSpacer1 = new QSpacerItem(40,20, QSizePolicy::Minimum, QSizePolicy::Expanding); vbox_layout-&gt;addItem(verticalSpacer1); QSpacerItem *name_item1 = new QSpacerItem(40,20, QSizePolicy::Fixed, QSizePolicy::Minimum); QLabel * name_label = new QLabel(); name_label-&gt;setText(&quot;邮箱:&quot;); QLineEdit * name_edit = new QLineEdit(); auto name_layout = new QHBoxLayout(); name_layout-&gt;addItem(name_item1); name_layout-&gt;addWidget(name_label); name_layout-&gt;addWidget(name_edit); QSpacerItem *name_item2 = new QSpacerItem(40,20, QSizePolicy::Fixed, QSizePolicy::Minimum); name_layout-&gt;addItem(name_item2); vbox_layout-&gt;addLayout(name_layout); QLabel * pwd_label = new QLabel(); pwd_label-&gt;setText(&quot;密码:&quot;); QLineEdit * pwd_edit = new QLineEdit(); auto verticalSpacer2 = new QSpacerItem(40,20, QSizePolicy::Maximum, QSizePolicy::Maximum); vbox_layout-&gt;addItem(verticalSpacer2); auto pwd_layout = new QHBoxLayout(); QSpacerItem *pwd_item2 = new QSpacerItem(40,20, QSizePolicy::Fixed, QSizePolicy::Minimum); QSpacerItem *pwd_item1 = new QSpacerItem(40,20, QSizePolicy::Fixed, QSizePolicy::Minimum); pwd_layout-&gt;addItem(pwd_item1); pwd_layout-&gt;addWidget(pwd_label); pwd_layout-&gt;addWidget(pwd_edit); pwd_layout-&gt;addItem(pwd_item2); vbox_layout-&gt;addLayout(pwd_layout); auto verticalSpacer3 = new QSpacerItem(40,30, QSizePolicy::Fixed, QSizePolicy::Maximum); vbox_layout-&gt;addItem(verticalSpacer3); QSpacerItem* reg_btn_item1 = new QSpacerItem(150,20, QSizePolicy::Fixed, QSizePolicy::Minimum); _reg_btn = new QPushButton(); _reg_btn-&gt;setText(&quot;注册&quot;); auto regbtn_layout = new QHBoxLayout(); regbtn_layout-&gt;addItem(reg_btn_item1); regbtn_layout-&gt;addWidget(_reg_btn,5); QSpacerItem* reg_btn_item2 = new QSpacerItem(40,20, QSizePolicy::Fixed, QSizePolicy::Minimum); regbtn_layout-&gt;addItem(reg_btn_item2); vbox_layout-&gt;addLayout(regbtn_layout); auto verticalSpacer4 = new QSpacerItem(40,20, QSizePolicy::Fixed, QSizePolicy::Expanding); vbox_layout-&gt;addItem(verticalSpacer4); this-&gt;setLayout(vbox_layout);&#125;Register::~Register()&#123; delete ui;&#125;void Register::set_login(const weak_ptr&lt;Login&gt; &amp;login)&#123; _login = login;&#125;void Register::ShowLogin()&#123;&#125; Register的构造函数中用代码的方式创建了一个垂直布局，垂直布局中增加了两个spacer，分别是verticalSpacer1和verticalSpacer4，以及三个水平布局pwd_layout，name_layout以及regbtn_layout，然后分别用代码的方式在三个布局中添加spacer和控件。Login类的声明如下 1234567891011121314151617181920212223242526272829#ifndef LOGIN_H#define LOGIN_H#include &lt;QDialog&gt;#include &lt;memory&gt;class Register;using namespace std;namespace Ui &#123;class Login;&#125;class Login : public QDialog, public std::enable_shared_from_this&lt;Login&gt;&#123; Q_OBJECTpublic: explicit Login(QWidget *parent = nullptr); ~Login(); void initSignals();private slots: void on_regBtn_clicked();private: Ui::Login *ui; std::shared_ptr&lt;Register&gt; _register;&#125;;#endif // LOGIN_H Login实现如下下 1234567891011121314151617181920212223242526272829#include &quot;ui_login.h&quot;#include &lt;QBitmap&gt;#include &lt;QPainter&gt;#include &quot;register.h&quot;Login::Login(QWidget *parent) : QDialog(parent), ui(new Ui::Login)&#123; ui-&gt;setupUi(this);&#125;void Login::initSignals()&#123; _register = make_shared&lt;Register&gt;(); //从本类转化为共享的智能指针给register类 _register-&gt;set_login(shared_from_this());&#125;Login::~Login()&#123; delete ui;&#125;void Login::on_regBtn_clicked()&#123; this-&gt;close(); _register-&gt;show();&#125; main函数的实现如下 12345678910111213#include &quot;login.h&quot;#include &lt;QApplication&gt;#include &lt;memory&gt;using namespace std;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); std::shared_ptr&lt;Login&gt; w = make_shared&lt;Login&gt;(); w-&gt;initSignals(); w-&gt;show(); return a.exec();&#125; 点击运行按钮，程序运行起来就可以从登录界面切换到注册界面了 总结源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"QT QLineEdit介绍","date":"2022-09-12T07:33:28.000Z","path":"2022/09/12/qt07/","text":"简介QLineEdit属于输入插件，用来实现单行录入。支持几种录入模式。 Normal表示正常录入,录入的信息会显示在QLineEdit上。 Password表示密码录入的方式，录入的信息不显示QLineEdit，只是通过黑色圆点显示。 NoEcho 表示不显示录入信息，类似于Linux输入密码时，显示的是一片空白。 PasswordEchoOnEdit 表示在输入的一刹那可以看到字符，但是立刻变为不可见的黑色圆点显示。 实战我们创建一个QApplication项目，名字叫editline。项目主界面取名MainWindow类，继承于QMainWindow。Qt为我们自动生成ui文件。然后在ui界面里添加四个QLineEdit和Label 我将ip的QLineEdit名字改为ipedit,设置ipedit的输入方式为Normal，这样可以在输入时看到输入的字符。我们可以给ipedit设置mask规定输入的字符只能为0~9的数字 123ui-&gt;ipedit-&gt;setEchoMode(QLineEdit::Normal);QString ip_mask = &quot;000.000.000.000;_&quot;;ui-&gt;ipedit-&gt;setInputMask(ip_mask); 具体的mask规则可以参考Qt官方文档，这里列举一下常见的mask规则利用上面的规则我们可以编写一些常用的mask接下来我们设置mac地址的mask和录入模式,mac地址的edit被命名为macedit 123ui-&gt;macedit-&gt;setEchoMode(QLineEdit::Normal);QString mac_mask = &quot;HH:HH:HH:HH;_&quot;;wui-&gt;macedit-&gt;setInputMask(mac_mask); 通过设置mask，规定mac的输入内容只能为AF以及09的字符。 其实除了通过mask限制edit录入的内容外，还可以通过正则表达式限制,比如我们设置邮箱edit的录入内容 12345ui-&gt;emailedit-&gt;setEchoMode(QLineEdit::Normal);//设置正则表达式过滤 secondtonone23@163.comQRegExp regx(&quot;[a-zA-Z0-9_-]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+&quot;);QValidator *validator = new QRegExpValidator(regx, ui-&gt;emailedit );ui-&gt;emailedit-&gt;setValidator(validator); 我们通过正则表达式限定了有限的规则为 “字符串和数子组合 + @ + 字符串和数子组合 + . + 字符串和数子组合”。具体的正则表达式可以去Qt文档查看，也可以看看下边这个图接下来我们可以设置密码输入框的输入模式为Password，保证录入时不显示密码 1ui-&gt;passwdedit-&gt;setEchoMode(QLineEdit::Password); 总结源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"几种标准对话框","date":"2022-09-03T10:38:40.000Z","path":"2022/09/03/qt06/","text":"几种标准对话框本文介绍几种标准对话框，都是Qt封装好的，我们先创建一个界面，添加几个按钮，然后分别在几个按钮的回调函数里添加创建不同对话框的逻辑 颜色对话框颜色对话框用来选择颜色，创建后会显示各种颜色和透明度信息 1234567891011void MainWindow::on_pushButton_clicked()&#123;// QColorDialog colorDlg(Qt::blue, this);// colorDlg.setOption(QColorDialog::ShowAlphaChannel);// colorDlg.exec();// QColor color = colorDlg.currentColor();// qDebug() &lt;&lt; &quot;color is &quot; &lt;&lt; color; QColor color = QColorDialog::getColor(Qt::blue, this,tr(&quot;选择颜色&quot;), QColorDialog::ShowAlphaChannel ); qDebug() &lt;&lt; &quot;color is &quot; &lt;&lt; color;&#125; 注释中也是创建颜色对话框的一种方式，两种方式都可以。 文本对话框创建一个选择文件的对话框，选择后，可以根据返回值打印选择的文件的路径信息 123456789void MainWindow::on_pushButton_2_clicked()&#123; QString path = QDir::currentPath(); QString title = tr(&quot;文件对话框&quot;); QString filter = tr(&quot;文本文件(*.txt);;图片文件(*.jpg *.gif *.png);;所有文件(*.*)&quot;); QString aFileName=QFileDialog::getOpenFileName(this,title,path,filter); qDebug() &lt;&lt; aFileName &lt;&lt; endl;&#125; 输入对话框输入对话框分几种，包括文本输入对话框，整数输入对话框，浮点数输入对话框，条目输入对话框。先看看文本输入对话框 12345678void MainWindow::on_pushButton_3_clicked()&#123; bool ok = false; auto text = QInputDialog::getText(this, tr(&quot;文字输入对话框&quot;), tr(&quot;请输入用户的姓名&quot;), QLineEdit::Normal, tr(&quot;admin&quot;), &amp;ok); if(ok)&#123; qDebug() &lt;&lt; text &lt;&lt; endl; &#125;&#125; 整形输入对话框 12345678void MainWindow::on_pushButton_4_clicked()&#123; bool ok = false; auto intdata = QInputDialog::getInt(this,tr(&quot;数字输入对话框&quot;),tr(&quot;请输入数字&quot;),200,-200,400,10,&amp;ok); if(ok)&#123; qDebug() &lt;&lt; intdata &lt;&lt; endl; &#125;&#125; 浮点输入对话框 12345678void MainWindow::on_pushButton_5_clicked()&#123; bool ok = false; auto floatdata = QInputDialog::getDouble(this,tr(&quot;浮点数输入对话框&quot;),tr(&quot;输入浮点数&quot;),0.1,-1,1,2,&amp;ok); if(ok)&#123; qDebug() &lt;&lt; floatdata &lt;&lt; endl; &#125;&#125; 条目输入对话框 12345678910void MainWindow::on_pushButton_6_clicked()&#123; QStringList items; items &lt;&lt; tr(&quot;条目1&quot;) &lt;&lt; tr(&quot;条目2&quot;); bool ok = false; auto itemData = QInputDialog::getItem(this,tr(&quot;条目输入对话框&quot;),tr(&quot;输入或选择条目&quot;),items,0,true, &amp;ok); if(ok)&#123; qDebug() &lt;&lt; &quot;item is &quot; &lt;&lt; itemData &lt;&lt; endl; &#125;&#125; 提示对话框 12345678910111213141516171819202122void MainWindow::on_pushButton_7_clicked()&#123; auto ret = QMessageBox::question(this,tr(&quot;提问对话框&quot;),tr(&quot;你是单身吗&quot;),QMessageBox::Yes, QMessageBox::No); if(ret == QMessageBox::Yes || ret == QMessageBox::No)&#123; qDebug() &lt;&lt; &quot;ret is &quot; &lt;&lt; ret &lt;&lt; endl; &#125; auto ret2 = QMessageBox::information(this,tr(&quot;通知对话框&quot;),tr(&quot;你好单身狗&quot;),QMessageBox::Ok); if(ret2 == QMessageBox::Ok)&#123; qDebug() &lt;&lt; &quot;ret2 is &quot; &lt;&lt; ret2 &lt;&lt; endl; &#125; auto ret3 = QMessageBox::warning(this,tr(&quot;警告对话框&quot;),tr(&quot;你最好找个地方发泄一下&quot;),QMessageBox::Ok); if(ret3 == QMessageBox::Ok)&#123; qDebug() &lt;&lt; &quot;ret3 is &quot; &lt;&lt; ret3 &lt;&lt; endl; &#125; auto ret4 = QMessageBox::critical(this,tr(&quot;关键提示对话框&quot;), tr(&quot;我梦寐以求是真爱和自由&quot;),QMessageBox::Ok); if(ret4 == QMessageBox::Ok)&#123; qDebug() &lt;&lt; &quot;ret4 is &quot; &lt;&lt; ret4 &lt;&lt; endl; &#125;&#125; 进度对话框当我们复制或进行文件传输时，会显示一个进度条的对话框，我们可以使用QProcessDialog来操作。 1234567891011121314151617void MainWindow::on_pushButton_8_clicked()&#123; // 进度提示框一闪而逝，不是逻辑问题，是5000量级太小了 QProgressDialog progressDialog(tr(&quot;正在复制&quot;),tr(&quot;取消复制&quot;),0,5000,this); progressDialog.setWindowTitle(tr(&quot;文件复制进度对话框&quot;)); progressDialog.setWindowModality(Qt::ApplicationModal); progressDialog.show(); for(int i = 0; i &lt; 5000; i++)&#123; progressDialog.setValue(i); QApplication::processEvents(); if(progressDialog.wasCanceled())&#123; break; &#125; &#125; progressDialog.setValue(5000);&#125; 因为循环很快完成，所以进度条一闪而逝，那么我们可以通过定时器的方式定时更新进度，这样就可以更清楚的看到进度条对话框更新情况了 123456789101112void MainWindow::on_pushButton_8_clicked()&#123; //改用定时器 _progressDialog = new QProgressDialog(tr(&quot;正在复制&quot;),tr(&quot;取消复制&quot;),0,5000,this); _progressDialog-&gt;setWindowTitle(tr(&quot;文件复制进度对话框&quot;)); _progressDialog-&gt;setWindowModality(Qt::ApplicationModal); _timer = new QTimer(this); connect(_timer, &amp;QTimer::timeout, this, &amp;MainWindow::on_updateProgressDialog); connect(_progressDialog, &amp;QProgressDialog::canceled, this, &amp;MainWindow::on_cancelProgressDialog); _timer-&gt;start(2); qDebug(&quot;复制结束&quot;);&#125; 上面代码连接了定时器的timeout信号和主窗口的on_updateProgressDialog函数, 该函数的主要作用就是定时更新进度条，逻辑如下 123456789101112131415void MainWindow::on_updateProgressDialog()&#123; _count++; if(_count &gt; 5000)&#123; _timer-&gt;stop(); delete _timer; _timer = nullptr; delete _progressDialog; _progressDialog = nullptr; _count = 0; return; &#125; _progressDialog-&gt;setValue(_count);&#125; 另外我们需要在进度条满了的时候发消息通知主窗口关闭 123456789void MainWindow::on_cancelProgressDialog()&#123; _timer-&gt;stop(); delete _timer; _timer = nullptr; delete _progressDialog; _progressDialog = nullptr; _count = 0; return;&#125;yi 这样进度条满了之后我们就可以回收定时器资源了。 向导对话框当我们想引导用户操作时可以采用向导对话框，比如安装软件时就会根据向导对话框一步一步操作，我们也实现一个向导对话框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void MainWindow::on_pushButton_10_clicked()&#123; QWizard wizard(this); wizard.setWindowTitle(tr(&quot;全城热恋&quot;)); QWizardPage* page1 = new QWizardPage(); page1-&gt;setTitle(tr(&quot;婚恋介绍引导程序&quot;)); auto label1 = new QLabel(); label1-&gt;setText(tr(&quot;该程序帮助您找到人生伴侣&quot;)); QVBoxLayout *layout = new QVBoxLayout(); layout-&gt;addWidget(label1); page1-&gt;setLayout(layout); wizard.addPage(page1); QWizardPage* page2 = new QWizardPage(); page2-&gt;setTitle(&quot;选择心动类型&quot;); QButtonGroup *group = new QButtonGroup(page2); QRadioButton * btn1 = new QRadioButton(); btn1-&gt;setText(&quot;白富美&quot;); group-&gt;addButton(btn1); QRadioButton * btn2 = new QRadioButton(); btn2-&gt;setText(&quot;萝莉&quot;); group-&gt;addButton(btn2); QRadioButton * btn3 = new QRadioButton(); btn3-&gt;setText(&quot;御姐&quot;); group-&gt;addButton(btn3); QRadioButton * btn4 = new QRadioButton(); btn4-&gt;setText(&quot;小家碧玉&quot;); group-&gt;addButton(btn4); QRadioButton * btn5 = new QRadioButton(); btn5-&gt;setText(&quot;女汉子&quot;); group-&gt;addButton(btn5); QRadioButton * btn6 = new QRadioButton(); btn6-&gt;setText(&quot;成年人不做选择，全选!&quot;); group-&gt;addButton(btn6); QVBoxLayout *vboxLayout2 = new QVBoxLayout(); for(int i = 0; i &lt; group-&gt;buttons().size(); i++)&#123; vboxLayout2-&gt;addWidget(group-&gt;buttons()[i]); &#125; page2-&gt;setLayout(vboxLayout2); wizard.addPage(page2); QWizardPage* page3 = new QWizardPage(); page3-&gt;setTitle(tr(&quot;你的缘分即将到来&quot;)); auto label3 = new QLabel(); label3-&gt;setText(tr(&quot;感谢您的参与，接下来的一个月会遇到对的人&quot;)); QVBoxLayout *layout3 = new QVBoxLayout(); layout3-&gt;addWidget(label3); page3-&gt;setLayout(layout3); wizard.addPage(page3); wizard.show(); wizard.exec();&#125; 总结视频链接https://www.bilibili.com/video/BV1Vd4y1g7vP/?spm_id_from=333.999.0.0&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"模态对话框消息传递","date":"2022-09-03T05:04:53.000Z","path":"2022/09/03/qt05/","text":"模态对话框接受和拒绝消息我们创建一个模态对话框，调用exec函数后可以根据其返回值进行不同的处理，exec的返回值有两种，Qt的官方文档记录的为 12QDialog::AcceptedQDialog::Rejected Accepted 表示接受消息， Rejected表示拒绝消息。还是按照之前的操作，选择新建QT Application项目，然后创建类名为MainWindow, 基类选择QDialog, 点击创建生成Qt项目。然后我们添加设计师界面类，类名MyDialog, 基类选择QDialog。然后在这个mydialog.ui中添加两个按钮，一个是进入主界面，一个是退出程序。在设计师界面点击Edit Signal/Slots 信号槽的按钮，进入信号槽编辑界面, 鼠标按住退出程序按钮不松开拖动，将另一端连接到MyDialog对话框，QPushbutton这边信号选择clicked()， MyDialog信号选择reject，这样就将两个信号连接起来了，我们点击退出程序按钮，会触发MyDialog发送reject信号，因为MyDialog调用exec后等待信号返回，此时收到reject信号，exec就会返回Rjected值。同样道理，MyDialog发送accetp()信号后, exec返回值为Accepted。我们点击Edit Widget 按钮， 然后右键点击键入主界面按钮，点击进入槽，在Qt 为我们生成的槽函数里添加accetp()信号发送逻辑 1234void MyDialog::on_pushButton_clicked()&#123; accept();&#125; 我们在main函数里调用对话框，然后根据返回值为Accepted，调用主窗口显示，否则直接退出 123456789101112int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; MyDialog dialog; if(dialog.exec() == QDialog::Accepted)&#123; w.show(); return a.exec(); &#125;else&#123; return 0; &#125;&#125; 运行后，我们点击进入主界面按钮，界面跳转至主界面，点击退出按钮程序退出。 主界面和登录界面切换现在我们要实现主界面和登录界面的互相切换，我们刚才创建的对话框界面MyDialog界面是登录界面，主界面是MainWindow类。我们在mainwindow.ui添加两个按钮，返回登录按钮和退出程序按钮, 再添加一个label表示这是主界面.然后点击Edit Signal/Slot 进入信号编辑界面，点击退出程序按钮不松开拖动到尾部连接MainWindow的主界面上，选择退出程序的clicked()信号，MainWindow选择reject信号,将两个信号连接起来。然后右击登录按钮转到槽，在槽函数里添加这个逻辑 12345678910void MainWindow::on_pushButton_clicked()&#123; close(); MyDialog mydialog; if(mydialog.exec() == QDialog::Accepted )&#123; this-&gt;show(); &#125;else&#123; return; &#125;&#125; 点击返回登陆按钮就会close主窗口，但是并不是真的关闭，只是将主窗口隐藏，Qt回收机制是所有窗口都关闭后才回收。再次运行程序，点击进入主界面按钮就可以进入主界面，点击返回登录按钮就可以返回登录界面，可以实现两个界面的切换了。 总结视频链接https://www.bilibili.com/video/BV1nY4y1K7cD/?spm_id_from=333.999.0.0&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt 信号和槽","date":"2022-08-25T10:15:39.000Z","path":"2022/08/25/qt04/","text":"信号和槽当我们需要一个界面通知另一个界面时，可以采用信号和槽机制。通过链接信号和槽，当一个界面发送信号时，链接该信号的槽会被响应，从而达到消息传递的目的。所以我们先创建一个Qapplication Widgets 应用。Creator会为我们生成mainwindow类和其界面。我们在界面添加一个按钮，按钮的名字叫showChildButton, 按钮显示的文字改为“显示子界面”。同时为该界面添加一个label，显示的文字修改为“这是主界面” 现在实现点击按钮，在控制台打印一条日志 “show child dialog “我们先在MainWindow的构造函数中添加信号和槽的链接逻辑 1connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), this, SLOT(showChildDialog())); 然后我们为MainWindow添加showChildDialog槽函数，槽函数需要用slots声明，我们这里在mainwindow.h里用public slots的方式声明槽函数。 12public slots: void showChildDialog(); 接下来去mainwindow.cpp中完成该函数的实现，可以在头文件中右键该函数，在弹出菜单里选择Refactor, 再选择在mainwindow.cpp中添加实现。也可以将鼠标光标放置在这个函数上，按alt+enter，弹出菜单选择在mainwindow.cpp中添加实现。这两种方式都是快捷添加，也可以直接去mainwindow.cpp里实现。 1234void MainWindow::showChildDialog()&#123; qDebug() &lt;&lt; &quot;show child dialog &quot; &lt;&lt; endl;&#125; 运行项目后点击按钮，就可以看到控制台弹出show child dialog日志。 不同的连接方式我们上边用来连接信号和槽的方式是qt4提供的方式，用SIGNAL和SLOT将信号和槽转化为字符串。但是这种方式会存在一定问题，Qt要求槽函数的参数不能超过信号定义的参数，比如我们用到的信号clicked(bool)参数就是bool，我们定义的槽函数showChildDialog()是不带参数的，可以连接成功，如果我们在连接的时候将showChildDialog的参数写为3个，也可以连接成功 12//qt4 风格的Slot和Signal 只是宏转换，字符串定义不能检测编译错误connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), this, SLOT(showChildDialog(1,2,3))); 但是点击会没有反应，说明qt4 这种连接信号和槽的方式不做编译检查，只是将信号和槽函数转译成字符串。所以我推荐使用qt5以上版本的连接方式 12 //推荐qt5 风格connect(ui-&gt;showChildButton, &amp;QPushButton::clicked, this, &amp;MainWindow::showChildDialog); 这种方式也可以实现信号和槽函数的连接。 实现界面的切换我们现在实现这样一个demo，程序启动后弹出主界面，点击主界面的按钮弹出子窗口，隐藏主界面，点击子窗口界面的按钮，隐藏子界面，显示主窗口。所以我们右击项目弹出菜单选择创建Qt设计师界面类，选择Dialog without Buttons, 名字选择ChildDialog 我们进入子界面的ui设计界面，添加一个label 描述为这是子界面，添加一个PushButton，文字修改为显示主窗口，并且将按钮的名字修改为showMainWindow Qt会为我们创建一个界面类名字叫ChildDialog，我们可以将其作为MainWindow类的成员 123456789101112131415class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;public slots: void showChildDialog();private: ChildDialog *_child_dialog;&#125;; 然后重新改写槽函数，使点击按钮后弹出对话框 123456void MainWindow::showChildDialog()&#123; qDebug() &lt;&lt; &quot;show child dialog &quot; &lt;&lt; endl; auto _child_dialog = new ChildDialog(this); _child_dialog-&gt;show();&#125; 再次运行程序点击显示子界面的按钮，就会弹出子界面了。关闭子界面，再次点击主窗口的显示子窗口按钮，子窗口又显示出来。这么做有一个问题就是可能会重复创建子窗口，但是Qt的对象树机制会保证父窗口回收时才回收子窗口，所以关闭子窗口只是隐藏了。那么随着点击，久而久之窗口会越来越多。我们想到的一个避免重复创建的办法就是在MainWindow的构造函数里创建好子界面，在槽函数中只控制子界面的显示即可。但同时要注意在MainWindow的析构函数里回收子界面类对象。 1234567891011121314151617181920212223MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); _child_dialog = new ChildDialog(this); connect(ui-&gt;showChildButton, &amp;QPushButton::clicked, this, &amp;MainWindow::showChildDialog);&#125;MainWindow::~MainWindow()&#123; delete ui; if(_child_dialog)&#123; delete _child_dialog; _child_dialog = nullptr; &#125;&#125;void MainWindow::showChildDialog()&#123; qDebug() &lt;&lt; &quot;show child dialog &quot; &lt;&lt; endl; _child_dialog-&gt;show();&#125; 这样我们频繁点击显示子界面按钮就不会重复创建窗口了。那接下来实现点击主界面的按钮，显示子界面，并隐藏主窗口。实现点击子界面的按钮，显示主窗口，并隐藏子界面。先实现点击子界面按钮显示主窗口，我们可以在ChildDialog类修改下构造函数，使其接受一个QWidget指针，这个指针指向父窗口也就是MainWindow.我们新增成员_parent用来存储MainWindow。新增槽函数showMainWindow用来显示主窗口。 1234567891011121314class ChildDialog : public QDialog&#123; Q_OBJECTpublic: explicit ChildDialog(QWidget *parent = nullptr); ~ChildDialog();private: Ui::ChildDialog *ui; QWidget *_parent;public slots: void showMainWindow();&#125;; 在ChildDialog的实现文件里连接槽函数，并且实现子界面隐藏，主界面显示 1234567891011121314ChildDialog::ChildDialog(QWidget *parent) : QDialog(parent), ui(new Ui::ChildDialog),_parent(parent)&#123; ui-&gt;setupUi(this); connect(ui-&gt;showMainWindow, &amp;QPushButton::clicked, this, &amp;ChildDialog::showMainWindow);&#125;void ChildDialog::showMainWindow()&#123; qDebug() &lt;&lt; &quot;show main window&quot; &lt;&lt; endl; _parent-&gt;show(); this-&gt;hide();&#125; 修改主界面的槽函数,让主界面隐藏，子界面显示 123456void MainWindow::showChildDialog()&#123; qDebug() &lt;&lt; &quot;show child dialog &quot; &lt;&lt; endl; _child_dialog-&gt;show(); this-&gt;hide();&#125; 运行程序后，点击按钮就可以实现界面的切换。这么做有一个不好的地方就是在ChildDialog类里保存了MainWindow的指针，如果我们ChildDialog类里要实现和多个其他界面的交互，就需要保存多个指针，这样代码的耦合性太大了。所以我们引入信号和槽机制，当我们点击子界面按钮时发送一个信号给主界面，这样主界面收到该信号后就显示主界面隐藏子界面。那我们先为ChildDialog类声明一个信号，用来通知主界面显示 123456789101112131415class ChildDialog : public QDialog&#123; Q_OBJECTsignals: void showMainSig();public: explicit ChildDialog(QWidget *parent = nullptr); ~ChildDialog();private: Ui::ChildDialog *ui; QWidget *_parent;public slots: void showMainWindow();&#125;; showMainSig是一个信号，用来通知主界面，所以主界面MainWindow类要连接这个信号，我们先在主界面类中声明这个函数 12345678910111213141516class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;public slots: void showChildDialog(); void showMainDialog();private: ChildDialog *_child_dialog;&#125;; showMainDialog 是新增的槽函数，用来连接ChildDialog的showMainSig信号。我们修改ChildDialog的showMainWindow函数 1234567void ChildDialog::showMainWindow()&#123; qDebug() &lt;&lt; &quot;show main window&quot; &lt;&lt; endl; this-&gt;hide(); //可以再次发送信号通知主窗口显示 emit showMainSig();&#125; 然后在MainWindow连接这个信号 12345678910111213141516171819MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); _child_dialog = new ChildDialog(this); //推荐qt5 风格 connect(ui-&gt;showChildButton, &amp;QPushButton::clicked, this, &amp;MainWindow::showChildDialog); connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog);&#125;void MainWindow::showChildDialog()&#123; qDebug() &lt;&lt; &quot;show child dialog &quot; &lt;&lt; endl; _child_dialog-&gt;show(); this-&gt;hide();&#125; 再次运行程序，点击按钮实现了界面的切换。 连接信号上面的程序还可以进一步优化，因为Qt提供了信号连接信号的方式，也就是说我们可以把子界面的按钮点击信号和showMainSig信号连接起来。 1234567ChildDialog::ChildDialog(QWidget *parent) : QDialog(parent), ui(new Ui::ChildDialog),_parent(parent)&#123; ui-&gt;setupUi(this); connect(ui-&gt;showMainWindow, &amp;QPushButton::clicked, this, &amp;ChildDialog::showMainSig);&#125; 将clicked和showMainSig两个信号连接起来，也可以实现消息的传递，让代码更简洁了。 总结视频链接视频教程源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"对话框","date":"2022-08-23T02:09:16.000Z","path":"2022/08/23/qt03/","text":"非模态对话框我们依旧创建一个Qt Widgets Application 项目，然后自动生成文件和项目。 12345678910MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog w(); w.show();&#125; 我们在MainWindow的构造函数里创建了QDialog类型的变量w。然后调用w的show函数展示该对话框。运行程序后会看到对话框w一闪而逝，然后创建了主窗口。一闪而逝的而原因是w在MainWindow的构造函数里，构造函数结束w就被释放了。所以窗口就会一闪而逝。即便是如下设置w的父窗口为mainwindow也无济于事 12345678910MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog w(this); w.show();&#125; 因为无论w的父窗口是谁，都会随着MainWindow构造函数的结束而释放。那么好用的办法就是通过new创建对话框，这样对话框的空间在堆上，就不会随着构造函数结束而被释放了。 12345678MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); auto w = new QDialog(this); w-&gt;show();&#125; 用new创建QDialog 对象w，并且指明了this(MainWindow)为其父窗口，这样在父窗口关闭或者释放后，其子窗口也会释放。这个原理在之后会讲给大家，QT提供了对象树的机制，保证了父类被释放后子类都会被回收。所以这也是我们指明w的父窗口为MainWindow的意思，如果不指明就需要手动回收w。不回收就会造成内存泄漏。 再次运行就可以看到会弹出两个界面，一个是主窗口，一个是对话框了。上面的方式创建的都是非模态对话框，所谓非模态对话框就是无论是否操作这个对话框都可以操作其他窗口。也就是说在非模态窗口弹出后并不阻塞其他窗口的消息传递。 模态对话框模态对话框就是当该对话框弹出后会阻塞其他窗口的响应事件，必须先关闭该对话框，其他窗口才会继续响应事件。我们改造MainWindow的构造函数，在里边创建一个模态对话框 123456789MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); auto w = new QDialog(this); w-&gt;setModal(true); w-&gt;show();&#125; 点击运行，弹出一个对话框和主窗口，点击主窗口没有任何反应，点击对话框关闭后才能点击主窗口，所以w就是一个模态对话框。另外一个创建模态对话框的方式是这样的 12345678MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog w(this); w.exec();&#125; 这种方式创建的对话框也是模态的，并且不会一闪而逝，主要原因是exec这个函数会阻塞其他界面响应事件。所以直到我们关闭这个对话框后，exec才返回，这样MainWindow的构造函数才继续往下执行。 窗口置顶有时我们需要将对话框置顶，不论其是不是模态对话框我们都可以这么做 123456789MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); auto s = new QDialog(this); s-&gt;setWindowFlag(Qt::WindowStaysOnTopHint); s-&gt;show();&#125; WindowStaysOnTopHint 表示窗口保持在最上边。类似的属性还有很多可以参考qt文档。 总结目前总结了对话框的几种使用方法，模态和非模态，这并不复杂。视频链接视频教程源码链接https://gitee.com/secondtonone1/qt-learning-notes","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"创建项目和编译","date":"2022-08-21T03:23:29.000Z","path":"2022/08/21/qt02/","text":"新建Qt Widgets应用我们启动qt creator 创建项目，选择Qt Widgets应用 接下来选择项目目录，项目名字就叫helloworld 构建系统选择qmake 我们创建一个名字为HelloDialog的类，继承于QDialog 构建套件选择你们安装的就行了，我这里选择了msvc2019，如果不知道选哪个就全选，系统自己会默认一个。 接下来一步步完成就可以了，creator会为我们生成代码,在项目目录会多出如下的目录 我们运行程序后会弹出界面 同时文件夹里会生成ui文件的类,保存在ui_hellodialog.h文件里 这个类是用来管理qt desinger 的ui 里的控件的，是自动生成的 我们看一下项目结构 helloworld.pro是qt 的qmake最终要执行编译时使用的文件，相当于我们用cmake编译时要使用makefile文件一样。 我们点击pro查看以下 123456789101112131415161718192021222324QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsCONFIG += c++17# You can make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ main.cpp \\ hellodialog.cppHEADERS += \\ hellodialog.hFORMS += \\ hellodialog.ui# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target 第1行 表示使用qt的core和gui库，如果以后我们想用其他的库，可以往这里添加。 第3行 表示如果qt的版本大于4，则引入widgets库，因为qt4之前的版本widgets库是不需要引用的，qt4之后需要引用。 11行主要是告诉编译器要编译的源文件 15行告诉编译器要编译的源文件 18行FORMS 描述了要用到哪些ui文件。 接下来我们为刚才的应用添加一个icon，先准备一个head.ico文件，如果没有可以去https://www.bitbug.net/制作一个，然后我们将head.ico放到项目目录里 然后修改pro文件，新增 RC_ICONS = head.ico 代码 1234567891011SOURCES += \\ main.cpp \\ hellodialog.cppHEADERS += \\ hellodialog.hFORMS += \\ hellodialog.uiRC_ICONS = head.ico 然后我们编译生成界面，就可以看到图标了 接下来我们双击项目目录的hellodialog.ui 会进入Qt Designer界面，然后我们添加一个label，label里写上 “Hello World! Hello Qt!” 再次运行程序就会弹出新的界面，里面有我们添加的label。 由于新增了label，那么ui文件就会变化，ui文件变化，之前编译生成的ui_hellodialog.h文件也会自动更新我们查看以下这个文件 123456789101112131415161718192021222324252627282930313233343536373839#ifndef UI_HELLODIALOG_H#define UI_HELLODIALOG_H#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QDialog&gt;QT_BEGIN_NAMESPACEclass Ui_HelloDialog&#123;public: void setupUi(QDialog *HelloDialog) &#123; if (HelloDialog-&gt;objectName().isEmpty()) HelloDialog-&gt;setObjectName(QString::fromUtf8(&quot;HelloDialog&quot;)); HelloDialog-&gt;resize(800, 600); retranslateUi(HelloDialog); QMetaObject::connectSlotsByName(HelloDialog); &#125; // setupUi void retranslateUi(QDialog *HelloDialog) &#123; HelloDialog-&gt;setWindowTitle(QCoreApplication::translate(&quot;HelloDialog&quot;, &quot;HelloDialog&quot;, nullptr)); &#125; // retranslateUi&#125;;namespace Ui &#123; class HelloDialog: public Ui_HelloDialog &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_HELLODIALOG_H 定义了一个Ui_HelloDialog类，成员函数setupUi用来指定将ui加载到哪个类对象上。retranslateUi主要是重新翻译一下界面上的文字等信息。Ui_HelloDialog被定义在Ui作用域里。 那这个类Ui_HelloDialog是怎么加载到程序中的呢？当我们创建对话框程序时，系统自动生成了hellodialog.cpp文件，在HelloDialog的构造函数里创建了Ui_HelloDialog类型对象，并调用setupUi加载了界面。 1234567891011121314#include &quot;hellodialog.h&quot;#include &quot;ui_hellodialog.h&quot;HelloDialog::HelloDialog(QWidget *parent) : QDialog(parent), ui(new Ui::HelloDialog)&#123; ui-&gt;setupUi(this);&#125;HelloDialog::~HelloDialog()&#123; delete ui;&#125; 以上就是整个界面初始化和创建的过程，接下来我们试着单独创建ui文件和cpp文件，加载界面。 创建空项目先创建一个空项目，然后我们手动添加代码完成和之前程序自动帮我们生成的代码类似的功能。先创建一个空项目 操作步骤和之前类似，项目名字就helloworld，编译套件选择自己安装的，点击finish就完成了。此时项目目录只有一个pro文件。 接下来我右键单击项目，选择添加C++ 源文件 文件名就叫main.cpp 项目里添加main.cpp后，需要在pro里添加widgets说明 1greaterThan(QT_MAJOR_VERSION,4): Qt+=widgets 主要原因是qt4以上版本，Qt不包含widgets库，需要引入。另外为了保证我们能使用qt的核心库如QApplication等，我们也要添加gui和core库,这样一个简单的pro文件是这样的 1234567QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsSOURCES += \\ main.cpp 然后我们往main.cpp中添加逻辑 123456789101112#include &lt;QApplication&gt;#include &lt;QDialog&gt;#include &lt;QLabel&gt;int main(int argc, char* argv[])&#123; QApplication a(argc, argv); QDialog w; QLabel label(&amp;w); label.setText(&quot;Hello World! Hello Qt!&quot;); w.show(); return a.exec();&#125; 上述逻辑就是创建了一个对话框w，然后将label设置在w上。然后再调用w显示出来。然后点击绿色三角运行，可以看到生成界面了界面有点小，我们可以重设dialog的大小，以及label的位置 12345678910int main(int argc, char* argv[])&#123; QApplication a(argc, argv); QDialog w; QLabel label(&amp;w); label.setText(&quot;Hello World! Hello Qt!&quot;); w.resize(400,300); label.move(120,120); w.show(); return a.exec();&#125; 再次运行生成界面就正常了 以上就是通过纯手动的方式添加文件并修改pro完成界面的加载，实际生产中我们多采用creator自动帮我们创建文件和界面的方式。 使用ui文件我们同样可以创建空项目，并在空项目中引入ui文件，加载界面。我们在当前项目基础上，添加ui文件选择Qt的form文件然后选择dialog without buttons接下来给这个ui命名为hellodialog.ui, 点击完成后进入designer界面，我们在界面上添加一个label，写上”Hello World！ Hello Qt!” 在qt designer里修改label的geometry大小和位置修改dialog名字为HelloDialog然后我们ctrl s 保存该ui先运行一下程序，因为之前main函数加载ui还是我们之前的方式写的，所以会弹出界面。我们改一下main函数 1234567891011121314151617#include &lt;QApplication&gt;#include &lt;QDialog&gt;#include &lt;QLabel&gt;#include &quot;ui_hellodialog.h&quot;int main(int argc, char* argv[])&#123; QApplication a(argc, argv); QDialog w;// QLabel label(&amp;w);// label.setText(&quot;Hello World! Hello Qt!&quot;);// w.resize(400,300);// label.move(120,120); Ui::HelloDialog ui; ui.setupUi(&amp;w); w.show(); return a.exec();&#125; 通过调用ui的setupUi将界面设置给对话框w，然后调用w的show函数。再次运行程序可以显示界面了。 使用自定义的C++类在上面的项目里我们新增C++类，右键项目目录选择Add New，然后选择C++类我们将这个类命名为HelloDialog，Base选择custom，然后写入QDialog点击下一步直到完成此时编译会出问题，因为我们要在生成的hellodialog.h文件里包含Qdialog头文件和ui头文件，并且声明ui成员变量 12345678910111213141516#ifndef HELLODIALOG_H#define HELLODIALOG_H#include &lt;QWidget&gt;#include &lt;QDialog&gt;#include &quot;ui_hellodialog.h&quot;class HelloDialog : public QDialog&#123;public: HelloDialog(); ~HelloDialog();private: Ui::HelloDialog *_ui;&#125;;#endif // HELLODIALOG_H 然后在hellodialog.cpp里加载我们的ui文件 12345678910#include &quot;hellodialog.h&quot;#include &quot;ui_hellodialog.h&quot;HelloDialog::HelloDialog():_ui(new Ui::HelloDialog())&#123; _ui-&gt;setupUi(this);&#125;HelloDialog::~HelloDialog()&#123; delete _ui;&#125; 修改main.cpp，调用HelloDialog创建界面 12345678910#include &lt;QApplication&gt;#include &lt;QDialog&gt;#include &lt;QLabel&gt;#include &quot;hellodialog.h&quot;int main(int argc, char* argv[])&#123; QApplication a(argc, argv); HelloDialog dialog; dialog.show(); return a.exec();&#125; 再次运行就加载了我们的界面。 使用QtDesigner类其实我们添加一个带界面的类不需要上面那么麻烦，分别创建类和界面，然后再写代码加载，这种方式是正确的但是并不高效，Qt给我们提供了设计师界面类，我们可以直接通过为项目创建一个设计师界面类，自动就会实现类文件和界面的关联。我们在现有的项目目录右键点击添加New Item，添加设计师界面类接下来依旧选择 Dialog without buttons只是我们将界面类的名字改为HelloDialog2完成后会弹出ui界面，我们在界面添加label，同样写上”Hello World ! Hello Qt!”我们可以看到qt自动为我们的类生成了代码并加载了ui文件 1234567891011121314#include &quot;hellodialog2.h&quot;#include &quot;ui_hellodialog2.h&quot;HelloDialog2::HelloDialog2(QWidget *parent) : QDialog(parent), ui(new Ui::HelloDialog2)&#123; ui-&gt;setupUi(this);&#125;HelloDialog2::~HelloDialog2()&#123; delete ui;&#125; 接下来我们只要在main.cpp里添加代码完成新界面的加载即可。 12345678910#include &lt;QApplication&gt;#include &lt;QDialog&gt;#include &lt;QLabel&gt;#include &quot;hellodialog2.h&quot;int main(int argc, char* argv[])&#123; QApplication a(argc, argv); HelloDialog2 dialog; dialog.show(); return a.exec();&#125; 点击运行同样可以显示我们设计好的界面。我们实际开发中基本就是以这种方式添加界面类的，方便快捷。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"Qt环境搭建","date":"2022-08-18T12:53:48.000Z","path":"2022/08/18/qt01/","text":"安装QtCreator进入Qt官网https://www.qt.io/zh-cn/，点击下载按钮 然后选择试用Qt，这里下载的是免费版本，也就是社区版本，如果点击购买则下载专业版。 点击下载后需要填写个人信息，填好邮箱和手机 还需要填写用途，并选择偏好 qt服务器收到消息后会让你填写确认码 填好后页面会跳转到下载链接界面，可以选择离线下载，也可以选择在线下载，在离线下载界面还可以选择过去的版本，我选择在线安装。 点击在线安装会下载下载器，点击下载器然后开始安装，安装过程中要填写账号和密码，没有就注册一个。 选择个人安装，不用于商业用途，这样我们下载的就是社区版本 选择要安装的组件和目录 选择组件可以全选，我在默认的基础上勾选了5.15的组件，用默认的就够了 初次使用QtCreator我们可以选择新建项目，看看效果 因为我们要创建一个桌面应用，所以选择QtWidgets Application 填写项目名和项目路径 选择编译组件，如果不确定可以全选，Qt会默认选择一个 Qt会为我们创建主窗口，我们可以为这个主窗口定义类名 点击确定后界面就会跳转为我们生成好项目 我们点击绿色的三角号就是运行项目，如果你的三角号是灰色的，你需要点击上面的Debug选择编译套件，选择一个你能用的就好。第一次编译时间会长一点，编译好就会弹出我们生成的界面了。 到此Qt的安装环境就配好了。 visual studio 配置Qt开发环境有时候我们习惯了Visual Studio的开发习惯，也可以用Visual Studio配置Qt开发环境。可以去visual studio官网https://visualstudio.microsoft.com/zh-hans/ 如果点击下载Visual Studio，则直接下载的是最新版本的Visual Studio 如果想要下载过去的版本，可以点击下载标签 这里有过去版本的列表，我下载的是2019版本 下载时需要登录，可以用github或者手机 下载一定要选择community，community是社区办，如果选择专业版和企业版需要秘钥，是付费的。 我们用vs打开之前Qt创建的项目目录 为了让vs可以打开qt项目，需要安装qt插件， 点击扩展-&gt;管理扩展， 输入Qt，然后下载安装 安装好后重启vs， 然后点击扩展，选择Qt Vs Tools 然后选择Qt Versions 里点击Add 然后添加Qt的qmake路径 然后我们用vs打开qt项目 然后打开之前创建的qt项目 此时vs可能会报错，如下所示 此时需要关闭vs，我们进到刚才qt项目文件夹里，发现已经生成vcxproj文件, 双击该文件，然后选择用vs打开即可。 此时vs已经能成功加载项目了 点击绿色三角，vs可以编译qt项目并生成如下界面 vs配置ui打开方式我们希望vs环境下点击qt的ui文件，会调用qt desiner编辑ui文件，可以右键ui文件进行配置 选择打开方式 选择Qt Designer，然后点击Add按钮 配置Qt Designer 的安装路径 配置好后，选择Qt Designer2017 作为默认值 这样我们点击ui文件，就默认弹出Qt Designer编辑UI了 总结到此我们就将qt环境配置好了","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.limerence2017.com/tags/Qt/"}]},{"title":"C++虚函数表和类成员内存分布","date":"2022-07-31T08:09:33.000Z","path":"2022/07/31/cpp42/","text":"不可定义为虚函数的函数类的静态函数和构造函数不可以定义为虚函数:静态函数的目的是通过类名+函数名访问类的static变量，或者通过对象调用staic函数实现对static成员变量的读写，要求内存中只有一份数据。而虚函数在子类中重写，并且通过多态机制实现动态调用，在内存中需要保存不同的重写版本。 构造函数的作用是构造对象，而虚函数的调用是在对象已经构造完成，并且通过调用时动态绑定。动态绑定是因为每个类对象内部都有一个指针，指向虚函数表的首地址。而且虚函数，类的成员函数，static成员函数都不是存储在类对象中，而是在内存中只保留一份。 将析构函数定义为虚函数的作用类的构造函数不能定义为虚函数，析构函数可以定义为虚函数，这样当我们delete一个指向子类对象的基类指针时可以达到调用子类析构函数的作用，从而动态释放内存。如下我们先定义一个基类和子类 1234567891011121314151617181920212223242526272829class VirtualTableA&#123;public: virtual ~VirtualTableA() &#123; cout &lt;&lt; &quot;Desturct Virtual Table A&quot; &lt;&lt; endl; &#125; virtual void print() &#123; cout &lt;&lt; &quot;print virtual table A&quot; &lt;&lt; endl; &#125;&#125;;class VirtualTableB : public VirtualTableA&#123;public: virtual ~VirtualTableB() &#123; cout &lt;&lt; &quot;Desturct Virtual Table B&quot; &lt;&lt; endl; &#125; virtual void print();&#125;;void VirtualTableB::print()&#123; cout &lt;&lt; &quot;this is virtual table B&quot; &lt;&lt; endl;&#125; 我们写一个函数做测试 123456789101112void destructVirtualTable()&#123; VirtualTableA *pa = new VirtualTableB(); useTable(pa); delete pa;&#125;void useTable(VirtualTableA *pa)&#123; //实现动态调用 pa-&gt;print();&#125; 程序输出 123this is virtual table BDesturct Virtual Table BDesturct Virtual Table A 在上面的例子中我们先在destructVirtualTable函数中new了一个VirtualTableB类型对象，并用基类VirtualTableA的指针指向了这个对象。然后将基类指针对象pa传递给useTable函数，这样会根据多态原理调用VirtualTableB的print函数，然后再执行delete pa操作。此时如果pa的析构函数不写成虚函数，那么就只会调用VirtualTableA的析构函数，不会调用子类VirtualTableB的析构函数，导致内存泄露。而我们将析构函数写成虚析构之后，可以看到先调用了子类VirtualTableB的析构函数，再调用了基类VirtualTableA的析构函数，达到了释放子类空间的目的。有人会问？将析构函数不写为虚函数，直接delete子类对象VirtualTableB，调用子类的析构函数不可以吗？比如，如下的调用 12VirtualTableB *pb = new VirtualTableB();delete pa; 上述调用没有问题，无论析构函数是否为虚析构都可以成功释放子类空间。但是项目编程中常常会编写一些通用接口，比如上面的useTable函数，它只接受VirtualTableA类型的指针，所以我们常常会用基类指针接受子类对象来通过多态的方式调用子类函数，为了方便delete基类指针也要释放子类空间，就要将析构函数设置为虚函数。 虚函数表原理为了介绍虚函数表原理，我们先实现一个基类和子类 1234567891011121314151617181920class Baseclass&#123;public: Baseclass() : a(1024) &#123;&#125; virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int a;&#125;;// 0 1 2 3 4 5 6 7(虚函数表空间) 8 9 10 11 12 13 14 15(存储的是a)class DeriveClass : public Baseclass&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl; &#125; virtual void g2() &#123; cout &lt;&lt; &quot;Derive::g2&quot; &lt;&lt; endl; &#125; virtual void h3() &#123; cout &lt;&lt; &quot;Derive::h3&quot; &lt;&lt; endl; &#125;&#125;; 一个类对象其内存分布的基本结构为虚函数表地址+非静态成员变量，类的成员函数不占用类对象的空间，他们分布在一片属于类的共有区域。类的静态成员函数喝成员变量不占用类对象的空间，他们分配在静态区。虚函数表的地址存储在类对象的起始位置。所以我们利用这个原理，通过寻址的方式访问虚函数表里的函数 123456789101112131415161718192021222324void useVitualTable()&#123; Baseclass b; b.a = 1024; cout &lt;&lt; &quot;sizeof b is &quot; &lt;&lt; sizeof(b) &lt;&lt; endl; int *p = (int *)(&amp;b); cout &lt;&lt; &quot;pointer address of vitural table &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;address of b is &quot; &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; &quot;address of a is &quot; &lt;&lt; p + 2 &lt;&lt; endl; cout &lt;&lt; &quot;address of p+1 is &quot; &lt;&lt; p +1 &lt;&lt; endl; cout &lt;&lt; &quot;value of a is &quot; &lt;&lt; *(p + 2) &lt;&lt; endl; cout &lt;&lt; &quot;address of vitural table&quot; &lt;&lt; (int *)(*p) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof int is &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof p is &quot; &lt;&lt; sizeof(p) &lt;&lt; &quot; sizeof(int*) is &quot; &lt;&lt; sizeof(int *) &lt;&lt; endl; Func pFun = (Func)(*(int *)(*p)); pFun(); pFun = (Func) * ((int *)(*p) + 2); pFun(); pFun = (Func)(*((int *)(*p) + 4)); pFun();&#125; 上面的程序输出 123456789101112sizeof b is 16pointer address of vitural table 0xb6fdd0address of b is 0xb6fdd0address of a is 0xb6fdd8address of p+1 is 0xb6fdd4value of a is 1024address of vitural table0x46d890sizeof int is 4sizeof p is 8 sizeof(int*) is 8Base::fBase::gBase::h 可以看到b的大小为16字节，因为我的机器是64位的，所以指针类型都占用8字节，int 占用4字节，但是要遵循补齐原则，结构体的大小要为最大成员大小的整数倍，所以要补齐4字节，那么8+4+4 = 16 字节，关于类对象对齐和补齐原则稍后再详述。b的内存分布如下图 这个根据不同的机器所占的字节数不一样，在32位机器上int为4字节，虚函数表地址为4字节，4+4 = 8字节，这个再之后再说明对齐和补齐的原则。 &amp;b表示取b的地址，因为虚函数表地址存储在b的起始地址，所以&amp;b也是虚函数表的地址的地址，我们通过int* 强转是方便存储b的地址，因为64位机器指针都是8字节，32位机器指针是4字节。p为虚函数表的地址的地址，p+1具体移动了4个字节，因为p+1移动多少个字节取决于p所指向的数据类型int,int为4字节，所以p+1在p的地址移动四个字节，p+2在p的地址移动8个字节。 p只想虚函数表的地址，换句话说p存储的是虚函数表的地址，虚函数表地址占用8字节，p+2就是从p向后移动8字节，这样刚好找到a的地址。那么*(p+2)就是取a的数值。int*(*p)就是取虚函数表的地址，转为int*是方便读写。 我们将b的内存分布以及虚函数表结构画出来上图中可以看到虚函数表中存储的是虚函数的地址，所以通过不断位移虚函数表的指针就可以达到指向不同虚函数的目的。 12Func pFun = (Func)(*(int *)(*p));pFun(); *(int *)(*p)就是取出虚函数表首地址指向的虚函数，再通过Func转化为函数类型，然后调用pFun即可调用虚函数f。所以想调用第二个虚函数g，将(int*)(*p) 加2 位移8个字节即可 12pFun = (Func) * ((int *)(*p) + 2);pFun(); 同样的道理调用h就不赘述了。 继承关系中虚函数表结构DeriveClass继承了BaseTest类，子类如果重写了虚函数，则子类的虚函数表中存储的虚函数为子类重写的，否则为基类的。我们画一下DeriveClass的虚函数表结构因为函数f被DeriveClass重写，所以DeriveClass的虚函数表存储的是自己重写的f。而虚函数g和h没有被DeriveClass重写，所以DeriveClass虚函数表存储的是基类的g和h。另外DeriveClass虚函数表里也存储了自己特有的虚函数g2和h3.下面我们还是利用寻址的方式调用虚函数 123456789101112131415161718void deriveTable()&#123; DeriveClass d; int *p = (int *)(&amp;d); int *virtual_tableb = (int *)(*p); Func pFun = (Func)(*(virtual_tableb)); pFun(); pFun = (Func)(*(virtual_tableb + 2)); pFun(); pFun = (Func)(*(virtual_tableb + 4)); pFun(); pFun = (Func)(*(virtual_tableb + 6)); pFun(); pFun = (Func)(*(virtual_tableb + 8)); pFun();&#125; 程序输出 12345Derive::fBase::gBase::hDerive::g2Derive::h3 可见DeriveClass虚函数表里存储的f是DeriveClass的f。(int *)(*p)表述取出p所指向的内存空间的内容，p指向的正好是虚函数表的地址，所以*p就是虚函数表的地址。因为我们不知道虚函数表的具体类型，所以转为int*类型，因为指针在64位机器上都是8字节，可以保证空间大小正确。接下来就是寻址和函数调用的过程，这里不再赘述。 多重继承的虚函数表上面的例子我们知道，如果类有虚函数，那么编译器会为该类的实例分配8字节存储虚函数表的地址。所有继承该类的子类也会拥有8字节的空间存储自己的虚函数表地址。多重继承的情况就是类对象空间里存储多张虚函数表地址。子类继承于两个基类，并且基类都有虚函数，那么子类就有两张虚函数表。 多态调用原理当我们通过基类指针存储子类对象时，调用虚函数，会调用子类的实现版本，这叫做多态。通过前面的实验和图示，我们已经知道如果子类重写了基类的虚函数，那么他自己的虚函数表里存储的就是自己实现的版本。通过基类指针存储子类对象时，基类指针实际指向的是子类的空间，寻址也是找到子类的虚函数表，从虚函数表中找到子类实现的虚函数，然后调用子类版本，从而达到多态效果。 对齐和补齐规则在考察一个类对象所占空间时，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。对象大小= vptr(虚函数表指针，可能不止一个) + 所有非静态数据成员大小 + Aligin字节大小（依赖于不同的编译器对齐和补齐） 对齐：类(结构体)对象每个成员分配内存的起始地址为其所占空间的整数倍。补齐：类(结构体)对象所占用的总大小为其内部最大成员所占空间的整数倍。下面我们先定义几个类 12345678910111213141516171819202122232425262728293031323334353637namespace AligneTest&#123; class A &#123; &#125;; class B &#123; char ch; void func() &#123; &#125; &#125;; class C &#123; char ch1; //占用1字节 char ch2; //占用1字节 virtual void func() &#123; &#125; &#125;; class D &#123; int in; virtual void func() &#123; &#125; &#125;; class E &#123; char m; int in; &#125;;&#125; 然后通过代码测试他们的大小 12345678910111213extern void aligneTest()&#123; AligneTest::A a; AligneTest::B b; AligneTest::C c; AligneTest::D d; AligneTest::E e; cout &lt;&lt; &quot;sizeof(a): &quot; &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(b): &quot; &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(c): &quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(d): &quot; &lt;&lt; sizeof(d) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(e): &quot; &lt;&lt; sizeof(e) &lt;&lt; endl;&#125; 程序输出 12345sizeof(a): 1sizeof(b): 1sizeof(c): 16sizeof(d): 16sizeof(e): 8 我们分别对每个类的大小做解释a 是A的对象，A是一个空类，编译器为了区分不同的空类，所以为每个空类对象分配1字节的空间保存其信息，用来区别不同类对象。b 是B的对象，因为B中定义了一个char成员变量和func函数，func函数不占用空间，所以b的大小为char的大小，也就是1字节。c 是C的对象，因为C中包含虚函数，所以C的对象c中会分配8字节用来存储虚函数表，虚函数表放在c内存的首地址，然后是ch1，以及ch2。假设c的起始地址为0，那么0~7字节存储虚函数表地址，第8个字节是1的整数倍，所以不同对齐，第8个字节存储ch1。第9个字节是1的整数倍，所以第9个字节存储ch2。那么c的大小为8 + 2 = 10, 因为补齐规则要求c的大小为最大成员大小的整数倍，最大成员为虚函数表地址8字节，所以要补齐6个字节，10+6 = 16，所以c的大小为16字节。其内存分配如下图d 是D的对象，因为D中包含虚函数，所以D的对象d中会分配8字节空间存储虚函数表地址，比如0~7字节存储虚函数表地址，接下来第8个字节，因为int为4字节，8是4的整数倍，所以不需要对齐，第8~11字节存储in，这样d的大小变为8+4= 12, 因为根据补齐规则需要补齐4字节，总共大小为16字节刚好是最大成员大小8字节的整数倍。所以d为16字节其内存分配图如下 e 是E的对象，e会为m分配1字节空间，为in分配4字节空间，假设地址0存储m，接下来地址1存储in。因为对齐规则要求类(结构体)对象每个成员分配内存的起始地址为其所占空间的整数倍，1不是4的整数倍，所以要对齐。对齐的规则就是地址后移找到起始地址为4的整数倍，所以要移动3个字节，在地址为4的位置存储in。那么e所占的空间就是 1(m占用) + 3(对齐规则) + 4(in占用) = 8 字节。如下图所示 为什么要有对齐和补齐这个要从计算机CPU存取指令说起，上图为32位机器内存模型，CPU通过地址总线和数据总线寻址读写数据。如果是64位机器，就是8列。通过对齐和补齐规则，可以一次读取内存中的数据，不需要切割和重组，是典型的用空间换取时间的策略。比如有如下类 1234class Test&#123; int m; int b;&#125; 我们用Test生成了两个对象t1和t2，他们在内存中存储如下，无色的表示t1的内存存储，彩色的表示t2。在不采用对齐和补齐策略的情况下在采用对齐和补齐策略的情况下可见不采用对齐和补齐策略，节省空间，但是要取三次能取完数据，取出后还要切割和拼接，最后才能使用。采用对齐和补齐策略，牺牲了空间换取时间，读取四次，但是不需要切割直接可以使用。对于64位机器，采用对齐和补齐策略，只需读取两次，每次取出的都是Test对象，效率非常高。 资源链接本文模拟实现了vector的功能。视频链接https://www.bilibili.com/video/BV1JT411j7HP/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 一个例子说明类继承知识点","date":"2022-07-28T14:19:54.000Z","path":"2022/07/28/cpp41/","text":"基类实现我们先实现一个基类 12345678910111213141516171819202122class BaseTest&#123;private: virtual void display() &#123; cout &lt;&lt; &quot;Base display&quot; &lt;&lt; endl; &#125; void say() &#123; cout &lt;&lt; &quot;Base say()&quot; &lt;&lt; endl; &#125;public: virtual void func() &#123; cout &lt;&lt; &quot;Base func()&quot; &lt;&lt; endl; &#125; void exec() &#123; display(); say(); &#125; void f1(string a) &#123; cout &lt;&lt; &quot;Base f1(string)&quot; &lt;&lt; endl; &#125; void f1(int a) &#123; cout &lt;&lt; &quot;Base f1(int)&quot; &lt;&lt; endl; &#125; void exec2() &#123; display(); say(); &#125;&#125;; BaseTest类中我们实现了一个虚函数display和 func。BaseTest类内部重载了f1函数，实现了两个版本，一个参数为string一个参数为int。同一个类中的多个同名函数叫做重载。实现了普通函数say，exec以及exec2函数。exec和exec2函数内部调用了display和say函数。 子类实现子类DeriveA继承了基类 12345678910111213141516171819class DeriveA : public BaseTest&#123;public: void display() &#123; cout &lt;&lt; &quot;DeriveA display()&quot; &lt;&lt; endl; &#125; void f1(int a, int b) &#123; cout &lt;&lt; &quot;DeriveA f1(int,int)&quot; &lt;&lt; endl; &#125; void say() &#123; cout &lt;&lt; &quot;DeriveA say()&quot; &lt;&lt; endl; &#125; virtual void func() &#123; cout &lt;&lt; &quot;DeriveA func()&quot; &lt;&lt; endl; &#125; void use_base_f1(int a, int b) &#123; BaseTest::f1(2); BaseTest::f1(&quot;test&quot;); cout &lt;&lt; &quot;DeriveA f1(int, int)&quot; &lt;&lt; endl; &#125; void exec2() &#123; display(); say(); &#125;&#125;; 子类DeriveA 子类重新实现了display和func函数，子类重新实现父类的虚函数，叫做重写。同样子类重新实现了f1和say函数，由于父类有f1和say，所以子类重新实现覆盖了父类的函数，这种普通函数被子类重写导致父类的函数被隐藏了，叫做覆盖。 函数调用接下来我们通过函数调用，看一下覆盖，重载和重写的区别 123456789101112131415161718192021222324252627282930313233343536373839void derive_base_test1()&#123; DeriveA a; BaseTest *b = &amp;a; shared_ptr&lt;BaseTest&gt; c = make_shared&lt;BaseTest&gt;(); //输出DeriveA func() b-&gt;func(); //输出DeriveA func() a.func(); //输出Base f1(string) b-&gt;f1(&quot;abc&quot;); //输出Base f1(int) b-&gt;f1(3); //输出DeriveA f1(int,int) a.f1(3, 5); a.use_base_f1(2, 4); cout &lt;&lt; &quot;========================&quot; &lt;&lt; endl; //输出DeriveA display() //输出Base say() b-&gt;exec(); //输出DeriveA display() //输出Base say() a.exec(); //输出Base display //输出Base say() c-&gt;exec(); cout &lt;&lt; &quot;======================== \\n&quot; &lt;&lt; endl; //输出 DeriveA display() //输出 Base say() b-&gt;exec2(); //输出 DeriveA display() //输出 DeriveA say() a.exec2(); //输出 Base display //输出 Base say() c-&gt;exec2();&#125; 代码里我们生成了一个DeriveA的实例a, 并将该实例返回给基类BaseTest的指针b，所以：1 b-&gt;func();会根据多态的效果调用子类DeriveA的func函数2 a.func() 因为a是一个对象，所以调用子类DeriveA的func函数3 b-&gt;f1(“abc”) 调用基类BaseTest的f1，因为f1是一个普通函数4 a.f1(3, 5) 调用DeriveA的f1，因为a是一个普通对象。5 当我们想在子类里调用基类的f1函数，可以通过基类作用域加函数名的方式，比如例子中的a.use_base_f1就在函数内部通过BaseTest::f1调用了基类函数f16 b-&gt;exec，首先b是一个指针且exec为普通函数只在基类实现了，所以调用基类的exec，但是exec内部调用了虚函数display，此时触发多态机制调用DeriveA的display函数，因为b是一个指向子类DeriveA对象的基类BaseTest指针，exec内部调用了普通函数display，因为display不是虚函数，所以调用BaseTest的display函数7 a.exec(); a是一个DeriveA对象，DeriveA自己没有实现exec函数，所以调用基类BaseTest的exec函数，exec内部调用display虚函数时由于DeriveA重写了display函数，所以调用DeriveA的display函数，exec内部调用say函数时由于say是普通函数，所以此时调用的是BaseTest的say函数。8 c-&gt;exec(); 因为c为BaseTest类型，所以调用的就是BaseTest的exec，内部执行的也是BaseTest的display和say。9 b-&gt;exec2(); 因为b是一个子类BaseTest的指针，所以调用BaseTest的exec2函数，exec2内部调用display时触发多态机制调用DeriveA的display，调用say时因为say是普通函数，所以调用BaseTest的say函数。10 a.exec2(); 因为a是DeriveA类对象，且DeriveA实现了exec2，所以a调用DeriveA的exec2，这样exec2内部调用的都是DeriveA的say和display11 c-&gt;exec2(); c为BaseTest类对象，所以调用BaseTest类的exec2以及display和say函数。 总结考察一个函数是被子类还是基类调用时应该分以下几种情况1 该函数是虚函数并且被子类重写，如果是基类指针指向子类对象，调用该函数则引发多态机制，调用子类的虚函数2 如果该函数时虚函数并且没有被重写，那么无论调用的对象是基类指针还是子类对象，还是基类对象，还是子类指针都是调用基类的这个虚函数3 如果该函数不是虚函数，如果该函数被子类覆盖(子类重新定义了同名函数)，那么调用规则就是子类调用子类的该函数，基类调用该基类的函数。4 如果该函数不是虚函数，并且子类没有定义同名函数(没有覆盖基类同名函数)，那么无论是子类还是基类的指针或者对象，统一调用的是基类的函数。5 如果第4点里基类的函数(没有被子类覆盖)，但是内部调用了基类的虚函数，并且该虚函数被子类重写，这时内部这个虚函数调用规则就要看调用对象的实际类型，符合1的调用标准，多态就走子类，不是多态就走基类(此时符合2标准)6 如果第3点里基类的函数(被子类覆盖)，但是内部调用了基类的虚函数，并且该虚函数被子类重写，这时内部这个虚函数调用规则就要看调用对象的实际类型，符合1的调用标准，多态就走子类，不是多态就走基类(此时符合2标准) 资源链接本文模拟实现了vector的功能。视频链接https://www.bilibili.com/video/BV19S4y1J7kV/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"模板特例化","date":"2022-07-24T07:07:17.000Z","path":"2022/07/24/cpp40/","text":"特例化介绍模板特例化主要是用于在模板特定情况下的一些特殊定义，用来完善模板在特定情况的调用我们先实现一个函数模板 12345678910template &lt;typename T&gt;int compare(const T &amp;v1, const T &amp;v2)&#123; cout &lt;&lt; &quot;use compare T&amp;&quot; &lt;&lt; endl; if (v1 &lt; v2) return -1; if (v2 &lt; v1) return 1; return 0;&#125; 接下来我们实现一个带字面值常量的特例化版本 1234567//带字面常量的比较函数template &lt;size_t N, size_t M&gt;int compare(const char (&amp;a1)[N], const char (&amp;a2)[M])&#123; cout &lt;&lt; &quot;use const char (&amp;)[N]&quot; &lt;&lt; endl; strcmp(a1, a2);&#125; 我们实现一个testcompare函数测试普通版和特例话版本的函数调用 123456789void testcompare()&#123; const char *p1 = &quot;h1&quot;; const char *p2 = &quot;mom&quot;; //调用特例化版本 compare(p1, p2); //调用第二个版本 compare(&quot;hi&quot;, &quot;mom&quot;);&#125; 当调用特例化版本时，N会被设定为”h1”的长度，M会被设定为”mom”长度。但是我们发现使用通用模板类型的函数compare在被叫指针p1和p2时不是很理想，可以单独实现针对p1和p2指针特定版的模板函数 1234567891011template &lt;&gt;int compare(const char* &amp;v1, const char* &amp;v2)&#123; cout &lt;&lt; &quot;use compare char * &quot; &lt;&lt; endl; if (strlen(v1) &lt; strlen(v2)) return -1; else if (strlen(v2) &lt; strlen(v1)) return 1; else return strcmp(v1, v2);&#125; 对于char * 版本我们实现了自己的比较规则，如果长度长的那个就是大值，相等则依次比较字符串中的每个字符。 类模板类模板的使用和函数模板类似，我们先声明两个模板类，然后为模板类声明一个比较函数重载运算符 12345678template &lt;typename&gt;class BlobPtr;template &lt;typename&gt;class Blob;template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;); 我们实现Blob&lt;T&gt;模板类 1234567891011121314151617181920212223242526272829303132333435363738394041//定义模板类型的blobtemplate &lt;typename T&gt;class Blob&#123;public: typedef T value_type; typedef typename std::vector&lt;T&gt;::size_type size_type; // T类型的BlobPtr是T类型的Blob的友元类 friend class BlobPtr&lt;T&gt;; //重载==运算符 friend bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;); //构造函数 Blob() &#123; data = make_shared&lt;std::vector&lt;T&gt;&gt;(); &#125; Blob(std::initializer_list&lt;T&gt; il) &#123; data = make_shared&lt;std::vector&lt;T&gt;&gt;(il); &#125; template &lt;typename It&gt; Blob(It b, It e); // Blob 中元素数目 size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; //添加和删除元素 void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125; //移动版本的push_back void push_back(const T &amp;&amp;t) &#123; data-&gt;push_back(std::move(t)); &#125; //删除元素 void pop_back(); //元素访问 T &amp;back(); T &amp;operator[](size_type i);private: std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data; //校验数据是否有效 void check(size_type i, const std::string &amp;msg) const;&#125;; 接下来实现Blob模板类的几个成员函数 1234567891011121314151617181920212223242526272829template &lt;typename T&gt;void Blob&lt;T&gt;::check(size_type i, const std::string &amp;msg) const&#123; if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);&#125;template &lt;typename T&gt;void Blob&lt;T&gt;::pop_back()&#123; if (data-&gt;empty()) &#123; return; &#125; data-&gt;pop_back();&#125;template &lt;typename T&gt;T &amp;Blob&lt;T&gt;::back()&#123; return data-&gt;back();&#125;template &lt;typename T&gt;T &amp;Blob&lt;T&gt;::operator[](size_type i)&#123; check(i, &quot;index out of range&quot;); return (*data)[i];&#125; 实现了pop_back, back, check等操作，以及下标索引等函数，接下来实现比较运算符重载 12345678910111213141516171819202122232425template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt; &amp;b1, const Blob&lt;T&gt; &amp;b2)&#123; if (b1.size() &gt; b2.size()) &#123; return true; &#125; if (b1.siz() &lt; b2.size()) &#123; return false; &#125; for (unsigned int i = 0; i &lt; b1.size(); i++) &#123; if (b1.data[i] == b2.data[i]) &#123; continue; &#125; return b1.data[i] &gt; b2.data[i]; &#125; return true;&#125; 此时我们还没有实现迭代器版本的构造函数，与类模板的普通成员函数不同，成员函数有自己的模板，所以要写两个模板名 12345678910//与模板类的普通成员不同，成员模板是函数模板//模板类的T类型template &lt;typename T&gt;//成员函数模板It类型template &lt;typename It&gt;Blob&lt;T&gt;::Blob(It b, It e)&#123; //通过迭代器构造 data = std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e);&#125; 这样我们就可以通不同类型的vector初始化Blob的构造函数了 12345678910111213void use_tempmemfunc()&#123; int ia[] = &#123;0, 1, 2, 3, 4&#125;; vector&lt;long&gt; vi = &#123;7, 6, 5, 4&#125;; list&lt;const char *&gt; w = &#123;&quot;now&quot;, &quot;zack&quot;, &quot;lov u&quot;&#125;; // Blob&lt;T&gt; T被实例化为int， //函数模板It被实例化为 int * Blob&lt;int&gt; a1(begin(ia), end(ia)); // It为vi的迭代器类型vector&lt;long&gt;::iterator T为long类型 Blob&lt;long&gt; a2(vi.begin(), vi.end()); //实例化Blob&lt;string&gt;以及list&lt;const char *&gt;::iterator参数 Blob&lt;string&gt; a3(w.begin(), w.end());&#125; 接下来我们实现BlobPtr这个模板类 12345678910111213141516171819template &lt;typename T&gt;class BlobPtr&#123;public: BlobPtr() : curr(0) &#123;&#125; BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) &#123;&#125; //递增和递减 BlobPtr &amp;operator++(); //前置运算符 // BlobPtr &amp;operator--(); //前置运算符-- BlobPtr &amp;operator++(int);private: std::shared_ptr&lt;std::vector&lt;T&gt;&gt; check(std::size_t, const std::string &amp;) const; std::size_t curr; //数组中的当前位置 //保存一个weak_ptr， 表示底层vector可能被销毁 std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;&#125;; BlobPtr实现了根据Blob构造自己的成员wptr以及curr，因为wptr是一个弱指针，所以只做弱关联。接下来我们实现前置++和后置++ 1234567891011121314template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++()&#123; this-&gt;curr++; return *this;&#125;template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++(int)&#123; BlobPtr &amp;rt = *this; this-&gt;curr++; return rt;&#125; 前置++很容易理解，后置++理解较为困难，这里做一下说明，后置++的函数里先用一个BlobPtr引用类型的临时变量rt存储了*this，因为this不会被释放，所以rt就是*this的引用，所引用的内容不会释放，这样外界接受到rt后同样是引用的*this。这样即使rt被回收了也没关系，因为外部已经捕获到*this的引用了。然后对curr++操作，这就是我们看到的先返回*this的引用，后++。模板类没有实现拷贝赋值时，默认用拷贝构造完成构造初始化 1234567891011121314151617181920212223242526272829303132void use_classtemp()&#123; Blob&lt;int&gt; ia; Blob&lt;int&gt; ia2 = &#123;0, 1, 2, 3, 5&#125;; Blob&lt;string&gt; ia3 = &#123;&quot;hello &quot;, &quot;zack&quot;, &quot;nice&quot;&#125;; for (size_t i = 0; i &lt; ia2.size(); i++) &#123; ia2[i] = i * i; &#125; for (size_t i = 0; i &lt; ia2.size(); i++) &#123; cout &lt;&lt; ia2[i] &lt;&lt; endl; &#125; for (size_t i = 0; i &lt; ia3.size(); i++) &#123; string_upper(ia3[i]); &#125; for (size_t i = 0; i &lt; ia3.size(); i++) &#123; cout &lt;&lt; ia3[i] &lt;&lt; endl; &#125; const auto &amp;data = ia3.back(); cout &lt;&lt; data &lt;&lt; endl; ia3.pop_back(); const auto &amp;data2 = ia3.back(); cout &lt;&lt; data2 &lt;&lt; endl;&#125; 模板的友元模板类也支持友元类的访问，以下列举了几种情况 1234567891011121314151617181920212223242526272829303132333435363738template &lt;typename T&gt;class Pal&#123;&#125;;template &lt;typename T&gt;class Pal2&#123;&#125;;class C&#123; // Pal&lt;C&gt;是C类的友元 friend class Pal&lt;C&gt;; //所有类型的Pal2的类都是C的友元 template &lt;typename T&gt; friend class Pal2;&#125;;// c2本身是一个模板类template &lt;typename T&gt;class C2&#123; //和C2同类型的Pal是C2的所有实例友元 friend class Pal&lt;T&gt;; // Pal2的所有实例都是C2的所有实例友元 template &lt;typename X&gt; friend class Pal2; // Pal3是一个普通类，他是C2的所有实例的友元 friend class Pal3;&#125;;template &lt;typename Type&gt;class Bar&#123; //将访问权限授予用来实例化Bar的类型 friend Type;&#125;; 类模板的别名类模板的别名定义有以下几种方式 123456789101112131415//定义模板类别名typedef long long INT64;//我们可以为实例好的模板类定义别名typedef Bar&lt;int&gt; mytype;// C11 可以为模板类定义别名template &lt;typename T&gt;using twin = pair&lt;T, T&gt;;// authors 是一个pair&lt;string, string&gt;twin&lt;string&gt; authors;// infos 是一个pair&lt;int, int&gt;类型twin&lt;int&gt; infos;template &lt;typename T&gt;using partNo = pair&lt;T, unsigned&gt;;// books是pair&lt;string, unsigned&gt;类型partNo&lt;string&gt; books; 类模板的静态成员类模板的静态成员要在非内联文件中初始化，也就是说在类模板声明的.h文件初始化。 12345678910111213//类模板的static成员template &lt;typename T&gt;class Foo&#123;public: static std::size_t count() &#123; return ctr; &#125;private: static std::size_t ctr;&#125;;template &lt;typename T&gt;size_t Foo&lt;T&gt;::ctr = 0; 告知编译器模板的子类型对于string::size_type , size_type是一个类型默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点： 我们用下面的例子显示指名模板名作用域下的是类型不是名字 123456789// 用typename 告知编译器T::value_type是一个类型template &lt;typename T&gt;typename T::value_type top(const T &amp;c)&#123; if (!c.empty()) return c.back(); else return typename T::value_type();&#125; 巧用模板类完成析构有时候我们可以利用模板类型实现()的重载，这样通过仿函数传递给智能指针的第二个参数，可以帮助智能指针回收内存 12345678910111213141516//函数对象，给指定类型的指针执行析构class DebugDelete&#123;public: DebugDelete(std::ostream &amp;s = std::cerr) : os(s) &#123;&#125; //我们定义一个仿函数，参数是T*类型 template &lt;typename T&gt; void operator()(T *p) const &#123; os &lt;&lt; &quot;deleting unique_str&quot; &lt;&lt; std::endl; delete p; &#125;private: std::ostream &amp;os;&#125;; DebugDelete实现了仿函数，接下来写一个函数调用这个仿函数 12345678910111213141516void use_debugdel()&#123; double *p = new double; DebugDelete d; //调用DebugDelete的仿函数,delete p d(p); //析构多种类型 int *np = new int; //构造DebugDelete对象后调用仿函数析构np DebugDelete()(np); //作为删除器析构智能指针 // p 被delete时会执行DebugDelete的仿函数进行析构 unique_ptr&lt;int, DebugDelete&gt; p3(new int, DebugDelete()); // 用DebugDelete 的仿函数析构string的指针 unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());&#125; 模板类型推断有时候对于模板函数返回的类型表示起来很复杂时，可以通过auto 配合尾置类型推断返回数据类型比如我们我们想返回迭代器指向类型的引用 12345678//推断返回类型，通过尾置返回允许我们在参数列表之后的声明返回类型template &lt;typename It&gt;auto fcnrf(It beg, It end) -&gt; decltype(*beg)&#123; //处理序列 //返回迭代器beg指向的元素的引用 return *beg;&#125; 通过decltype(*beg)返回迭代器beg指向的元素的引用类型。如果想要返回指向元素的副本类型，不是引用类型可以通过remove_reference去引用 123456789101112// remove_reference 是一个模板// remove_reference&lt;decltype(*beg)&gt;::type// type的类型就是beg指向元素的类型// remove_reference&lt;int&amp;&gt;::type type就是int// remove_reference&lt;string&amp;&gt;::type type就是stringtemplate &lt;typename It&gt;auto fcncp(It beg, It end) -&gt; remove_reference&lt;decltype(*beg)&gt;&#123; //返回迭代器beg指向元素的copy return *beg;&#125; 模板的左值和右值函数模板同样存在左值和右值 1234567891011//接受左值引用的模板函数template &lt;typename T&gt;void f1(T &amp;t)&#123;&#125;//接受右值引用的模板函数template &lt;typename T&gt;void f2(T &amp;&amp;t)&#123;&#125; f2(42) T就被推断为intint i = 100; f2(i) T就被推断为int&amp; 参数类型就变为int&amp; &amp;&amp;当模板函数的参数是一个T类型的右值引用1 传递给该参数的实参是一个右值时，T就是该右值类型2 传递给该参数的实参是一个左值时，T就是该左值引用类型 折叠规则X&amp;&amp; 、X&amp;&amp;&amp; 都会被折叠为X&amp;X&amp;&amp; &amp;&amp; 会被折叠为X&amp;&amp; 所以我们可以推断move的实现原理，其参数一定是T&amp;&amp;类型，因为其能接受左值和右值两种类型。其返回值一定是实参类型的右值引用类型。 12345template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp;my_move(T &amp;&amp;t)&#123; return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125; 为什么要有原样转发stl::forward是用来做原样转发的，将原有类型保持原样传递给其他函数，这种机制尤为重要。因为如果不进行原样转发，传递的参数变为左值，传递给一个接受右值引用的函数会出现编译报错。比如我们实现一个flip函数，既能接受左值又能接受右值，并且在函数内部修改这个值会同步到外部实参的效果，那他的实现一定是通过模板类型T&amp;&amp;实现的，通过折叠达到适配左值和右值的目的 1234void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123; f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125; flip 函数内部调用了函数f, 将t1和t2的类型原样转发。 123456789101112131415161718192021void gtemp(int &amp;&amp;i, int &amp;j)&#123; cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125;void use_ftemp()&#123; int j = 100; int i = 99; // flip(gtemp, j, 42) 会报错 // 因为42作为右值纯递给flip，t2会被折叠为int类型, // j作为左值传递给flip, T1会绑定为int&amp;，通过折叠t1变为int&amp;类型 // 如果不进行原样转发，t2传递给gtemp第一个参数时，t2虽然是右值引用类型的变量 // 但是t2作为左值传递给了gtemp第一个参数，编译器会报错，int&amp;&amp;无法绑定int类型 // 所以无论右值引用类型还是左值引用类型的变量当成参数传递给其他函数时，这个变量就是一个左值。 // 通过原样转发就保证了这个值在传递给其他函数时不改变其左值引用类型或者右值引用类型 // 这样即使编译报错也是实参层面传递出了错误。 flip(gtemp, i, 42); cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125; 总结本文模拟实现了vector的功能。视频链接https://www.bilibili.com/video/BV15t4y1W7ZL/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"模拟实现vector","date":"2022-06-21T13:18:14.000Z","path":"2022/06/21/cpp39/","text":"模拟vector我们可以通过模板实现类似vector的类。我们实现一个StrVecTemp类，其内部通过allocator开辟空间，存储的类型用T来表示，T是模板类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template &lt;typename T&gt;class StrVecTemp&#123;public: StrVecTemp() : elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125; //拷贝构造函数 StrVecTemp(const StrVecTemp &amp;); //拷贝赋值运算符 StrVecTemp &amp;operator=(const StrVecTemp &amp;); //移动构造函数 StrVecTemp(StrVecTemp &amp;&amp;src) noexcept : elements(src.elements), first_free(src.first_free), cap(src.cap) &#123; //将源数据置空 src.elements = src.first_free = src.cap = nullptr; &#125; template &lt;class... Args&gt; void emplace_back(Args &amp;&amp;...args); //析构函数 ~StrVecTemp(); //拷贝元素 void push_back(const T &amp;); //抛出元素 void pop_back(T &amp;s); //返回元素个数 size_t size() const &#123; return first_free - elements; &#125; //返回capacity返回容量 size_t capacity() const &#123; return cap - elements; &#125; //返回首元素的指针 T *begin() const &#123; return elements; &#125; //返回第一个空闲元素指针 T *end() const &#123; return first_free; &#125;private: //判断容量不足靠皮新空间 void chk_n_alloc() &#123; if (size() == capacity()) &#123; reallocate(); &#125; &#125; //重新开辟空间 void reallocate(); // copy指定范围的元素到新的内存中 std::pair&lt;T *, T *&gt; alloc_n_copy(const T *, const T *); //释放空间 void free(); //数组首元素的指针 T *elements; //指向数组第一个空闲元素的指针 T *first_free; //指向数组尾后位置的指针 T *cap; //初始化alloc用来分配空间 static std::allocator&lt;T&gt; alloc;&#125;;template &lt;typename T&gt;std::allocator&lt;T&gt; StrVecTemp&lt;T&gt;::alloc; alloc在使用前要在类外初始化，因为是模板类，所以放在.h中初始化即可。接下来我们要实现根据迭代器开始和结束的区间copy旧元素到新的空间里 123456789//实现区间copytemplate &lt;typename T&gt;std::pair&lt;T *, T *&gt; StrVecTemp&lt;T&gt;::alloc_n_copy(const T *b, const T *e)&#123; auto newdata = alloc.allocate(e - b); //用旧的数据初始化新的空间 auto first_free = uninitialized_copy(b, e, newdata); return &#123;newdata, first_free&#125;;&#125; 实现copy构造 12345678910//实现拷贝构造函数template &lt;class T&gt;StrVecTemp&lt;T&gt;::StrVecTemp(const StrVecTemp &amp;strVec)&#123; auto rsp = alloc_n_copy(strVec.begin(), strVec.end()); //利用pair类型更新elements, cap, first_free elements = rsp.first; first_free = rsp.second; cap = rsp.second;&#125; 实现copy赋值 1234567891011121314//拷贝赋值运算符template &lt;class T&gt;StrVecTemp&lt;T&gt; &amp;StrVecTemp&lt;T&gt;::operator=(const StrVecTemp &amp;strVec)&#123; if (this == &amp;strVec) &#123; return *this; &#125; //如果不是自赋值，就将形参copy给自己 auto rsp = alloc_n_copy(strVec.begin(), strVec.end()); elements = rsp.first; first_free = rsp.second; cap = rsp.second;&#125; 析构函数要先销毁数据再回收内存 1234567891011121314151617181920212223//析构函数template &lt;class T&gt;StrVecTemp&lt;T&gt;::~StrVecTemp()&#123; //判断elements是否为空 if (elements == nullptr) &#123; return; &#125; //缓存第一个有效元素的地址 auto dest = elements; //循环析构 for (size_t i = 0; i &lt; size(); i++) &#123; //析构每一个元素 alloc.destroy(dest++); &#125; //再回收内存 alloc.deallocate(elements, cap - elements); elements = nullptr; cap = nullptr; first_free = nullptr;&#125; 重新开辟空间 123456789101112131415161718192021222324252627282930313233template &lt;class T&gt;void StrVecTemp&lt;T&gt;::reallocate()&#123; T *newdata = nullptr; //数组为空的情况 if (elements == nullptr || cap == nullptr || first_free == nullptr) &#123; newdata = alloc.allocate(1); elements = newdata; first_free = newdata; // cap指向数组尾元素的下一个位置 cap = newdata + 1; return; &#125; //原数据不为空，则扩充size两倍大小 newdata = alloc.allocate(size() * 2); //新内存空闲位置 auto dest = newdata; //就内存的有效位置 auto src = elements; //通过移动操作将旧数据放到新内存中 for (size_t i = 0; i != size(); ++i) &#123; alloc.construct(dest++, std::move(*src++)); &#125; //移动完旧数据后一定要删除 free(); //更新数据位置 elements = newdata; first_free = dest; cap = newdata + size() * 2;&#125; 上面的函数用到了free函数，我们自己实现一个free 12345678910111213141516171819202122template &lt;typename T&gt;void StrVecTemp&lt;T&gt;::free()&#123; //先判断elements是否为空 if (elements == nullptr) &#123; return; &#125; auto dest = elements; //遍历析构每一个对象 for (size_t i = 0; i &lt; size(); i++) &#123; // destroy 会析构每一个元素 alloc.destroy(dest++); &#125; //再整体回收内存 alloc.deallocate(elements, cap - elements); elements = nullptr; cap = nullptr; first_free = nullptr;&#125; 压入元素和弹出元素 123456789101112131415161718192021222324252627282930//拷贝元素template &lt;class T&gt;void StrVecTemp&lt;T&gt;::push_back(const T &amp;t)&#123; chk_n_alloc(); alloc.construct(first_free++, t);&#125;//抛出元素template &lt;class T&gt;void StrVecTemp&lt;T&gt;::pop_back(T &amp;s)&#123; //先判断是否为空 if (first_free == nullptr) &#123; return; &#125; //判断size为1 if (size() == 1) &#123; s = *elements; alloc.destroy(elements); first_free = nullptr; elements = nullptr; return; &#125; s = *(--first_free); alloc.destroy(first_free);&#125; 接下来要实现emplace_back，因为emplace_back支持多种构造函数的参数，所以要用模板参数列表的方式定义该函数。模板参数列表和形参列表都要用参数包的方式 1234567template &lt;class T&gt;template &lt;class... Args&gt;void StrVecTemp&lt;T&gt;::emplace_back(Args &amp;&amp;...args)&#123; chk_n_alloc(); alloc.construct(first_free++, forward&lt;Args&gt;(args)...);&#125; Args是模板参数包，args是参数列表。因为construct的参数可能为右值引用，所以要用forward将原参数列表类型原样转发。 123456// forward既扩展了模板参数包Args，又扩展了函数参数包args// std::forward&lt;Args&gt;(args)... 等价于std::forward&lt;Ti&gt;(ti)//比如传递给emplace_back(10,&#x27;c&#x27;);//相当于调用 alloc.construct(first_free++, forward&lt;int&gt;(10), forward&lt;char&gt;(&#x27;c&#x27;))//调用的就是插入cccccccccc 总结本文模拟实现了vector的功能。视频链接https://www.bilibili.com/video/BV1Et4y1p73a/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"模板类型的原样转发和可变参数","date":"2022-06-16T09:11:28.000Z","path":"2022/06/16/cpp38/","text":"原样转发的意义前文我们实现了一个my_move函数，用来模拟stl的move操作，实现去引用的功能。其内部的原理就是通过remove_reference实现去引用操作。有时我们也需要保留原类型的左值或者右值属性，进行原样转发，此时就要用forward实现转发功能。我们先定义一个模板函数 12345template &lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2)&#123; f(t2, t1);&#125; flip1内部调用了函数f我们写一个函数测试 123456789101112void ftemp(int v1, int &amp;v2)&#123; cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;&#125;void use_ftemp()&#123; int j = 100; int i = 99; flip1(ftemp, j, 42); cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125; 通过打印发现i和j的值没有变化，因为ftemp的v2参数虽然是引用，但是是flip1的形参t1的引用t1只是形参，修改t1并不能影响外边的实参j。想要达到修改实参的目的，需要将flip1的参数修改为引用，我们先实现修改后的版本flip2 12345template &lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123; f(t2, t1);&#125; 我们定义了一个flip2函数，t1和t2分别是右值引用类型。接下来用一个测试函数进行测试 1234int j = 100;int i = 99;flip2(ftemp, j, 42);cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl; 这次我们发现j被修改了，因为flip2的t1参数类型为T1的右值引用，当把实参j赋值给flip2时，T1变为int&amp;,t1的类型就是int&amp; &amp;&amp;，通过折叠t1变为int&amp;类型。这样t1就和实参j绑定了，在flip2内部修改t1，就达到了修改j的目的。但是flip2同样存在一个问题，如果flip2的第一个参数f，如果f是一个接受右值引用参数的函数，会出现编译错误。为说明这一点，我们实现一个接纳模板参数右值引用类型的函数 1234void gtemp(int &amp;&amp;i, int &amp;j)&#123; cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125; 此时如果我们将gtemp作为参数传递给flip2会报错 123456789101112131415161718int j = 100;int i = 99;// flip2(gtemp, j, 42) 会报错// 因为42作为右值纯递给flip2，t2会被折叠为int&amp;类型// t2传递给gtemp第一个参数时，int&amp;&amp;无法绑定int&amp;类型//flip2(gtemp, i, 42);cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;```t当我们将42传递给flip2第二个参数时，T2被实例化为int类型，t2就变为int &amp;&amp; 类型，通过折叠t2变为int&amp;类型。t2作为参数传递给gtemp的第一个参数时会报错，cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27;因为t2是一个左值，右值无法绑定该左值。上面的错误可以简化为``` cppint i = 100;int&amp;&amp; m = 200;int&amp;&amp; k = m; 上面代码仍然会报错，无法将k这个右值引用绑定到m这个左值上。解决的办法很简单 123int i = 100;int&amp;&amp; m = 200;int&amp;&amp; k = int(m); 通过int强制类型转换，这是一个表达式得出的就是右值。当然也可以通过如下方式 123int i = 100;int&amp;&amp; m = 200;int&amp;&amp; k = std::move(m); 总之就是通过表达式将m转化为右值即可。所以大家要清楚的是及时m是一个int&amp;&amp;类型，但是它本身是一个左值。综上所述，上面问题的解决的办法就是实现一个flip函数，内部实现对T2，T1类型的原样转发。 12345template &lt;typename F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123; f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125; 通过forward将t2类型转化为和T2类型一样的类型，也就是int的右值类型，接下来的调用就不会出问题了 1234567void use_ftemp()&#123; int j = 100; int i = 99; flip(gtemp, i, 42); cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125; 模板的可变参数模板同样支持可变参数 12345678910111213//可变参数的函数模板template &lt;typename T&gt;ostream &amp;print(ostream &amp;os, const T &amp;t)&#123; return os &lt;&lt; t; //输出最后一个元素&#125;template &lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args &amp;...rest)&#123; os &lt;&lt; t &lt;&lt; &quot;, &quot;; return print(os, rest...);&#125; Args是可变的模板参数包， 然后再用Args定义rest变量，这是一个可变参数列表。我们的模板函数print内部调用stl的print函数，通过对rest…实现展开操作。调用过程可按如下的方式 123456void use_printtemp()&#123; int i = 100; string s = &quot;hello zack!!!&quot;; print(cout, i, s, 42);&#125; 第一次调用print实际是调用的可变参数的print，之后才调用没有可变参数的print函数。 总结本文介绍了模板类型的原样转发，以及多模板参数列表的使用。视频链接https://www.bilibili.com/video/BV1ES4y187Yc/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 模板类的友元和折叠规则","date":"2022-06-15T09:41:05.000Z","path":"2022/06/15/cpp37/","text":"为模板类声明友元类有时我们需要A类访问模板类B的私有成员，但是不想其他类访问，就要在模板类B里为A类声明友元。比如我们想要实现一个BlobPtr类，让BlobPtr类成为Blob类的友元，这样BlobPtr类就可以访问Blob类了。对于Blob类的声明和定义在前文已经阐述https://llfc.club/articlepage?id=28Vv7hro3VVMPDepLTlLRLqYJhJ。我们省略Blob类的详细声明,只为它添加友元类BlobPtr类，并且为他添加友元函数operator== 12345678910class Blob&#123;public: typedef T value_type; typedef typename std::vector&lt;T&gt;::size_type size_type; // T类型的BlobPtr是T类型的Blob的友元类 friend class BlobPtr&lt;T&gt;; //重载==运算符 friend bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);&#125;; 实现友元类BlobPtr接下来我们实现友元类BlobPtr,先对其进行声明 12345678910111213141516171819template &lt;typename T&gt;class BlobPtr&#123;public: BlobPtr() : curr(0) &#123;&#125; BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) &#123;&#125; //递增和递减 BlobPtr &amp;operator++(); //前置运算符 // BlobPtr &amp;operator--(); //前置运算符-- BlobPtr &amp;operator++(int);private: std::shared_ptr&lt;std::vector&lt;T&gt;&gt; check(std::size_t, const std::string &amp;) const; std::size_t curr; //数组中的当前位置 //保存一个weak_ptr， 表示底层vector可能被销毁 std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;&#125;; 在实现其定义,这里只举例实现一部分函数，其余的读者自己实现即可。 1234567891011121314template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++()&#123; this-&gt;curr++; return *this;&#125;template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++(int)&#123; BlobPtr &amp;rt = *this; this-&gt;curr++; return rt;&#125; 对于友元函数operator == 的定义可以按照如下实现 12345678910111213141516171819202122232425template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt; &amp;b1, const Blob&lt;T&gt; &amp;b2)&#123; if (b1.size() &gt; b2.size()) &#123; return true; &#125; if (b1.siz() &lt; b2.size()) &#123; return false; &#125; for (unsigned int i = 0; i &lt; b1.size(); i++) &#123; if (b1.data[i] == b2.data[i]) &#123; continue; &#125; return b1.data[i] &gt; b2.data[i]; &#125; return true;&#125; 模板类的友元还有一些特殊的用法，如下，读者可以自己体会 12345678910111213141516171819202122232425262728293031template &lt;typename T&gt;class Pal&#123;&#125;;template &lt;typename T&gt;class Pal2&#123;&#125;;class C&#123; // Pal&lt;C&gt;是C类的友元 friend class Pal&lt;C&gt;; //所有类型的Pal2的类都是C的友元 template &lt;typename T&gt; friend class Pal2;&#125;;// c2本身是一个模板类template &lt;typename T&gt;class C2&#123; //和C2同类型的Pal是C2的所有实例友元 friend class Pal&lt;T&gt;; // Pal2的所有实例都是C2的所有实例友元 template &lt;typename X&gt; friend class Pal2; // Pal3是一个普通类，他是C2的所有实例的友元 friend class Pal3;&#125;; 定义模板类别名我们可以通过typedef和using等方式为一个模板类定义别名 12345678910111213141516171819202122template &lt;typename Type&gt;class Bar&#123; //将访问权限授予用来实例化Bar的类型 friend Type;&#125;;//定义模板类别名typedef long long INT64;//我们可以为实例好的模板类定义别名typedef Bar&lt;int&gt; mytype;// C11 可以为模板类定义别名template &lt;typename T&gt;using twin = pair&lt;T, T&gt;;// authors 是一个pair&lt;string, string&gt;twin&lt;string&gt; authors;// infos 是一个pair&lt;int, int&gt;类型twin&lt;int&gt; infos;template &lt;typename T&gt;using partNo = pair&lt;T, unsigned&gt;;// books是pair&lt;string, unsigned&gt;类型partNo&lt;string&gt; books; 类模板的静态成员对于类模板的静态成员，其初始化要放在声明的.h文件中。 1234567891011121314//类模板的static成员template &lt;typename T&gt;class Foo&#123;public: static std::size_t count() &#123; return ctr; &#125;private: static std::size_t ctr;&#125;;//初始化放在和声明所在的同一个.h文件中template &lt;typename T&gt;size_t Foo&lt;T&gt;::ctr = 0; 模板类的作用域访问默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点： 123456789// 用typename 告知编译器T::value_type是一个类型template &lt;typename T&gt;typename T::value_type top(const T &amp;c)&#123; if (!c.empty()) return c.back(); else return typename T::value_type();&#125; 我们定义了一个名为top的模板函数，通过T::value_type声明其返回类型，但是C++默认作用域下value_type是一个成员，所以为了说明value_type是一个类型就需要用typename关键字做声明。 通用的函数对象我们可以通过模板类实现通用的仿函数，也就是实现通用的函数对象，我们先实现一个DebugDelete类，用来删除各种类型的指针对象 12345678910111213141516//函数对象，给指定类型的指针执行析构class DebugDelete&#123;public: DebugDelete(std::ostream &amp;s = std::cerr) : os(s) &#123;&#125; //我们定义一个仿函数，参数是T*类型 template &lt;typename T&gt; void operator()(T *p) const &#123; os &lt;&lt; &quot;deleting unique_str&quot; &lt;&lt; std::endl; delete p; &#125;private: std::ostream &amp;os;&#125;; DebugDelete构造函数接纳一个输出流，用来在operator()调用时输出删除信息接下来我们实现一个测试函数，用来说明DebugDelete的用法 12345678910111213141516void use_debugdel()&#123; double *p = new double; DebugDelete d; //调用DebugDelete的仿函数,delete p d(p); //析构多种类型 int *np = new int; //构造DebugDelete对象后调用仿函数析构np DebugDelete()(np); //作为删除器析构智能指针 // p 被delete时会执行DebugDelete的仿函数进行析构 unique_ptr&lt;int, DebugDelete&gt; p3(new int, DebugDelete()); // 用DebugDelete 的仿函数析构string的指针 unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());&#125; 可以看出DebugDelete可以用来给智能指针作删除器用。 尾置类型的推断C11新标准中提出了尾置类型推断 12// func接受了一个int类型的实参，返回了一个指针，该指针指向一个含有10个整数的数组auto func(int i) -&gt; int (*)[10]; 利用这个特性，我们可以用在模板函数中，同样实现一个尾置类型推断函数 12345678//推断返回类型，通过尾置返回允许我们在参数列表之后的声明返回类型template &lt;typename It&gt;auto fcnrf(It beg, It end) -&gt; decltype(*beg)&#123; //处理序列 //返回迭代器beg指向的元素的引用 return *beg;&#125; fcnrf的返回类型时It指向元素的解引用(*beg)类型，通过decltype类型推断给出返回的类型。我们也可以实现一个返回值类型的函数，去掉引用类型。 123456789101112// remove_reference 是一个模板// remove_reference&lt;decltype(*beg)&gt;::type// type的类型就是beg指向元素的类型// remove_reference&lt;int&amp;&gt;::type type就是int// remove_reference&lt;string&amp;&gt;::type type就是stringtemplate &lt;typename It&gt;auto fcncp(It beg, It end) -&gt; remove_reference&lt;decltype(*beg)&gt;&#123; //返回迭代器beg指向元素的copy return *beg;&#125; 引用折叠规则我们可以用模板定义一个左值引用 12345//接受左值引用的模板函数template &lt;typename T&gt;void f1(T &amp;t)&#123;&#125; 当我们用模板类型定义一个右值引用时，传递给该类型的实参类型，会根据C++标准进行折叠。我们先声明一个右值引用的模板函数 12345//接受右值引用的模板函数template &lt;typename T&gt;void f2(T &amp;&amp;t)&#123;&#125; 如果我们调用f2(42), T就被推断为intint i = 100; f2(i) T就被推断为int&amp; 进行参数展开参数就变为int&amp; &amp;&amp;折叠后就变为int &amp;所以我们可以做如下归纳：当模板函数的实参是一个T类型的右值引用1 传递给该参数的实参是一个右值时， T就是该右值类型2 传递给该参数的实参是一个左值时， T就是该左值引用类型。 //折叠规则//X&amp;&amp; ,X&amp;&amp;&amp; 都会被折叠为X&amp;//X&amp;&amp; &amp;&amp; 会被折叠为X&amp;&amp;所以根据这个规律，我们可以实现一个类似于stl的move操作 1234template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp; my_move(T&amp;&amp; t)&#123; return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125; 如果我们在函数中作如下调用 1234567891011121314151617181920212223void use_tempmove()&#123; int i = 100; my_move(i); //推断规则 /* 1 T被推断为int &amp; 2 remove_reference&lt;int &amp;&gt;的type成员是int 3 my_move 的返回类型是int&amp;&amp; 4 推断t类型为int&amp; &amp;&amp; 通过折叠规则t为int&amp;类型 5 最后这个表达式变为 int &amp;&amp; my_move(int &amp;t) */ auto rb = my_move(43); //推断规则 /* 1 T被推断为int 2 remove_reference&lt;int&gt;的type成员是int 3 my_move 的返回类型为int&amp;&amp; 4 my_move 的参数t类型为int &amp;&amp; 5 最后这个表达式变为 int &amp;&amp; my_move(int &amp;&amp; t) */&#125; 总结这篇文章介绍了模板参数类型的折叠规则和友元类的声明和使用。视频链接https://www.bilibili.com/video/BV1cF41177hK?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9源码链接 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 函数模板和类模板","date":"2022-04-30T03:13:01.000Z","path":"2022/04/30/cpp36/","text":"函数模板当我们想要定义一个可以支持泛型的函数时，就要采用函数模板的方式了。所谓泛型就是可以支持多种类型的操作，比如我们定义一个compare操作，他可以根据传递给他的参数类型动态调用对应的函数版本，实现多种类型的比较。 123456789template &lt;typename T&gt;int compare(const T &amp;v1, const T &amp;v2)&#123; if (v1 &lt; v2) return -1; if (v2 &lt; v1) return 1; return 0;&#125; 比较函数是一个模板函数，它支持T类型的对象比较，模板函数定义的规则是用template 声明模板的类型为T，然后用T做参数即可。调用的规则传递实参就可以了，前提是实参的类型要支持比较大小，如果是类的类型我们可以重载比较运算符。 1234567int res = compare(3, 4); cout &lt;&lt; &quot;compare(3,4) res is &quot; &lt;&lt; res &lt;&lt; endl; vector&lt;int&gt; v1 = &#123;1, 3, 5&#125;; vector&lt;int&gt; v2 = &#123;2, 4&#125;; res = compare(v1, v2); cout &lt;&lt; &quot;compare(v1, v2) res is &quot; &lt;&lt; res &lt;&lt; endl; 我们分别传递了int类型和vector类型的参数作为compare比较的参数。模板函数也支持多个类型，我们可以再定义一个支持多个参数类型的模板函数 123456template &lt;typename T, typename U&gt;int printData(const T &amp;t, const U &amp;u)&#123; cout &lt;&lt; &quot;t is &quot; &lt;&lt; t &lt;&lt; endl; cout &lt;&lt; &quot;u is &quot; &lt;&lt; u &lt;&lt; endl;&#125; 调用规则和上边类似，传递两个不同类型即可 1printData(3.4, &quot;hello world&quot;); 模板函数也支持非参数类型，用已知类型定义变量 12345template &lt;unsigned N, unsigned M&gt;int compareArray(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123; return strcmp(p1, p2);&#125; compareArray的模板里用了已知类型unsigned定义了两个变量N和M。调用的时候N和M会自动根据实参获取值 12345res = compareArray(&quot;hello zack&quot;, &quot;nice to meet u&quot;); cout &lt;&lt; &quot;compareArray(&quot; &lt;&lt; &quot;hello zack &quot; &lt;&lt; &quot;, nice to meet u&quot; &lt;&lt; &quot;) res is &quot; &lt;&lt; res &lt;&lt; endl; M和N就是传递的两个数组的长度。 类模板我们实现一个模板类，使其支持类似vector的操作，包括push_back， empty， back, 以及pop_back，取索引[]操作等。 123456789101112131415161718192021222324252627282930313233343536373839404142//定义模板类型的blobtemplate &lt;typename T&gt;class Blob&#123;public: typedef T value_type; typedef typename std::vector&lt;T&gt;::size_type size_type; //构造函数 Blob() &#123; data = make_shared&lt;std::vector&lt;T&gt;&gt;(); &#125; Blob(std::initializer_list&lt;T&gt; il) &#123; data = make_shared&lt;std::vector&lt;T&gt;&gt;(il); // for (const T &amp;m : il) // &#123; // data-&gt;push_back(m); // &#125; &#125; template &lt;typename It&gt; Blob(It b, It e); // Blob 中元素数目 size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; //添加和删除元素 void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125; //移动版本的push_back void push_back(const T &amp;&amp;t) &#123; data-&gt;push_back(std::move(t)); &#125; //删除元素 void pop_back(); //元素访问 T &amp;back(); T &amp;operator[](size_type i);private: std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data; //校验数据是否有效 void check(size_type i, const std::string &amp;msg) const;&#125;; 我们在类外实现check， pop_back, back, 以及[]操作。 1234567891011121314151617181920212223242526272829template &lt;typename T&gt;void Blob&lt;T&gt;::check(size_type i, const std::string &amp;msg) const&#123; if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);&#125;template &lt;typename T&gt;void Blob&lt;T&gt;::pop_back()&#123; if (data-&gt;empty()) &#123; return; &#125; data-&gt;pop_back();&#125;template &lt;typename T&gt;T &amp;Blob&lt;T&gt;::back()&#123; return data-&gt;back();&#125;template &lt;typename T&gt;T &amp;Blob&lt;T&gt;::operator[](size_type i)&#123; check(i, &quot;index out of range&quot;); return (*data)[i];&#125; 每一个类的成员函数在类外实现时都要声明template。类模板的使用如下 1234567891011121314151617181920212223242526272829303132void use_classtemp()&#123; Blob&lt;int&gt; ia; Blob&lt;int&gt; ia2 = &#123;0, 1, 2, 3, 5&#125;; Blob&lt;string&gt; ia3 = &#123;&quot;hello &quot;, &quot;zack&quot;, &quot;nice&quot;&#125;; for (size_t i = 0; i &lt; ia2.size(); i++) &#123; ia2[i] = i * i; &#125; for (size_t i = 0; i &lt; ia2.size(); i++) &#123; cout &lt;&lt; ia2[i] &lt;&lt; endl; &#125; for (size_t i = 0; i &lt; ia3.size(); i++) &#123; string_upper(ia3[i]); &#125; for (size_t i = 0; i &lt; ia3.size(); i++) &#123; cout &lt;&lt; ia3[i] &lt;&lt; endl; &#125; const auto &amp;data = ia3.back(); cout &lt;&lt; data &lt;&lt; endl; ia3.pop_back(); const auto &amp;data2 = ia3.back(); cout &lt;&lt; data2 &lt;&lt; endl;&#125; 我们也可以对类的成员函数做模板的定义 123456789//模板类的T类型template &lt;typename T&gt;//成员函数模板It类型template &lt;typename It&gt;Blob&lt;T&gt;::Blob(It b, It e)&#123; //通过迭代器构造 data = std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e);&#125; 我们可以写一个函数测试上面的模板成员函数 12345678910111213void use_tempmemfunc()&#123; int ia[] = &#123;0, 1, 2, 3, 4&#125;; vector&lt;long&gt; vi = &#123;7, 6, 5, 4&#125;; list&lt;const char *&gt; w = &#123;&quot;now&quot;, &quot;zack&quot;, &quot;lov u&quot;&#125;; // Blob&lt;T&gt; T被实例化为int， //函数模板It被实例化为 int * Blob&lt;int&gt; a1(begin(ia), end(ia)); // It为vi的迭代器类型vector&lt;long&gt;::iterator T为long类型 Blob&lt;long&gt; a2(vi.begin(), vi.end()); //实例化Blob&lt;string&gt;以及list&lt;const char *&gt;::iterator参数 Blob&lt;string&gt; a3(w.begin(), w.end());&#125; 通过迭代器构造Blob类，实现多种类型的绑定。 总结源码链接 https://gitee.com/secondtonone1/cpplearn视频链接 https://www.bilibili.com/video/BV1yY4y187SC?spm_id_from=333.999.0.0","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 类的继承封装和多态","date":"2022-04-28T12:55:54.000Z","path":"2022/04/28/cpp35/","text":"C++ 特性C++ 三大特性，封装继承多态。我们先实现一个Quote作为基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Quote&#123;public: Quote() = default; Quote(const std::string &amp;book, double sales_price) &#123; price = sales_price; bookNo = book; &#125; std::string isbn() const &#123; return bookNo; &#125; virtual double net_price(std::size_t n) const &#123; cout &lt;&lt; &quot;this is Quote net_price&quot; &lt;&lt; endl; return n * price; &#125; static void PrintHello() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#125; Quote(const Quote &amp;quote) : bookNo(quote.bookNo), price(quote.price) &#123;&#125; void printMem() &#123; cout &lt;&lt; &quot;price is &quot; &lt;&lt; price &lt;&lt; &quot; bookNo is &quot; &lt;&lt; bookNo &lt;&lt; endl; &#125; virtual ~Quote() &#123; cout &lt;&lt; &quot;this is Quote destruct&quot; &lt;&lt; endl; &#125; // final 阻止其他继承Quote的类重写f3函数 virtual void f3() final &#123;&#125;private: std::string bookNo;protected: double price = 0.0;&#125;; net_price是一个虚函数，实现了基类的计算规则。同时我们实现了一个虚函数f3，但是f3末尾用final标识了，表示继承Quote的子类不能重写f3函数。我们实现子类 123456789101112131415161718class BulkQuote : public Quote&#123;public: BulkQuote() = default; BulkQuote(const std::string &amp;book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) &#123; &#125; // override 是C11提供的继承关系检测工具，检测函数类型是否匹配，是否为虚函数等。 double net_price(std::size_t) const override; // void f3() &#123;&#125;private: //打折后最多买多少 std::size_t min_qty = 0; //折扣额度 double discount = 0.0;&#125;; 子类无法重写f3所以注释了。子类BulkQuote重写了net_price,该函数后边用了overide关键字,C11规定写了override关键字的函数必须符合基类的规则，包括函数参数类型相同，返回值相同，函数名一致等。基类Quote有一个静态函数PrintHello，子类继承Quote也将PrintHello继承过来。可以通过如下方式调用 12345void use_base_static()&#123; Quote::PrintHello(); BulkQuote::PrintHello();&#125; 可以将子类赋值给基类或者将子类对象传给基类的构造函数，这么做的结果是基类构造时只拷贝子类的基类部分。 12345678910void use_derive_to_base()&#123; BulkQuote bulkquote(string(&quot;Live&quot;), 1.2, 100, 0.8); //子类传给基类构造函数，或者子类赋值给基类 //就会调用基类构造函数，只构造基类部分。 Quote quote(bulkquote); quote.printMem(); quote = bulkquote; quote.printMem();&#125; 当我们将一个子类对象传递给一个基类引用，或者将一个子类对象的指针传递给一个基类指针，通过基类的指针或引用调用虚函数，会动态调用子类对象的虚函数版本，这种特性叫做多态。我们先实现一个全局函数 1234void print_total(ostream &amp;os, const Quote &amp;quote, std::size_t n)&#123; os &lt;&lt; quote.net_price(n) &lt;&lt; endl;&#125; 多态特性会让编译器根据动态类型绑定虚函数调用的版本，所谓动态类型就是运行时才确定的类型。 1234567void use_derive_param()&#123; BulkQuote bulkquote(string(&quot;Live&quot;), 1.2, 100, 0.8); Quote quote(string(&quot;Quote&quot;), 1.2); print_total(cout, quote, 100); print_total(cout, bulkquote, 100);&#125; 上面的程序会根据传给print_total具体的实参类型调用各自的虚函数net_price。 纯虚类如果一个类只包含纯虚函数，不包含成员变量，则该类为纯虚类。所谓纯虚函数就是只有声明，函数体为=0的形式。 12345678//纯虚类class VirtualBase&#123;public: VirtualBase() = default; virtual void mem() = 0; virtual void test() = 0;&#125;; 纯虚类类似于Go语言的interface，当我们继承纯虚类后一定要重写其所有的纯虚函数。 1234567class DeriveFromBase : public VirtualBase&#123; virtual void mem() &#123; &#125; virtual void test() &#123;&#125;&#125;; 封装性子类只可以访问基类的protected和public成员，不能访问private成员。子类的友元函数可以访问子类的私有变量，公有变量以及受保护的变量，当时不能访问基类的私有变量和protected变量。 1234567891011121314151617// protectedclass ProBase&#123;public: ProBase() = default; ProBase(int n) : prot_mem(n) &#123;&#125; void mem_func() &#123; cout &lt;&lt; &quot;this is ProBase mem_func&quot; &lt;&lt; endl; &#125;protected: int prot_mem;private: int priv_mem;&#125;; ProBase包括一个私有变量priv_mem和一个受保护变量prot_mem。我们定义子类继承它 12345678910111213141516171819202122232425262728293031323334class Sneaky : public ProBase&#123;public: Sneaky() = default; Sneaky(int n) : ProBase(1024), prot_mem(n) &#123;&#125; //子类可以使用基类的public和protected成员 void UsePro() &#123; cout &lt;&lt; prot_mem &lt;&lt; endl; &#125; //子类无法使用基类的private成员。 // void UsePriv() // &#123; // cout &lt;&lt; priv_mem &lt;&lt; endl; // &#125; friend void clobber(Sneaky &amp;); friend void clobber(ProBase &amp;); void GetMem() &#123; cout &lt;&lt; &quot;this is ProBase prot_mem: &quot; &lt;&lt; ProBase::prot_mem &lt;&lt; endl; cout &lt;&lt; &quot;this is Sneaky prot_mem: &quot; &lt;&lt; prot_mem &lt;&lt; endl; &#125; void mem_func(int n) &#123; cout &lt;&lt; &quot;this is Sneaky mem_func&quot; &lt;&lt; endl; &#125;private: int self_mem; int prot_mem;&#125;; 通过继承Sneaky拥有了基类ProBase的私有变量priv_mem和受保护变量prot_mem。又定义了自己的私有变量self_mem和prot_mem。可以看到即使在Sneaky的类声明中UsePriv这个函数里也无权访问基类的私有变量priv_mem。我们在如下函数测试 123456789101112131415void use_probase()&#123; Sneaky sk(11); // sk.prot_mem; sk.GetMem(); //调用子类的mem_func(int n) sk.mem_func(100); ProBase pb; //调用基类的mem_func() pb.mem_func(); //基类的mem_func()被覆盖了 //sk.mem_func(); //想使用基类的mem_func()需要添加基类作用域 sk.ProBase::mem_func();&#125; 在类的声明之外，通过对象的方式无法直接使用sk的私有变量prot_mem。因为子类实现了mem_func(int n)版本，所以把基类的mem_func(void)覆盖了，想调用基类版本的mem_func()需要通过sk.ProBase::mem_func()显示调用基类版本。接下来我们实现Sneaky的两个友元函数 12345678910void clobber(Sneaky &amp;s)&#123; s.prot_mem = 100; s.self_mem = 1000;&#125;//子类友元无法访问基类受保护成员void clobber(ProBase &amp;b)&#123; // b.prot_mem = 10;&#125; 子类的友元函数无法访问基类的私有成员和保护成员。 重写和隐藏子类继承基类，重新实现基类的虚函数就叫做重写，重写要求必须和基类的虚函数完全匹配，包括参数类型返回值等。对于基类的非虚函数，子类实现了同名的函数，只要名字相同，即使参数不同，也可以覆盖基类函数，叫做隐藏。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class VBase&#123;public: virtual int fcn() &#123; cout &lt;&lt; &quot;this is VBase fcn()&quot; &lt;&lt; endl; &#125;&#125;;class VD1 : public VBase&#123;public: // VD1自己定义的fcn(int)，因为和基类VBase的fcn参数不同 //但是VD1也继承了VBase fcn()这个版本 //隐藏了基类的fcn() int fcn(int) &#123; cout &lt;&lt; &quot;this is VD1 fcn(int)&quot; &lt;&lt; endl; &#125; // VD1自己新定义的虚函数 virtual void f2() &#123; cout &lt;&lt; &quot;this is VD1 f2()&quot; &lt;&lt; endl; &#125;&#125;;class VD2 : public VD1&#123;public: //隐藏了VD1版本的fcn(int),因为VD1中fcn(int)不是虚函数 int fcn(int) &#123; cout &lt;&lt; &quot;this is VD2 fcn(int)&quot; &lt;&lt; endl; &#125; //重写,因为VD1从VBase中继承了虚函数fcn() int fcn() &#123; cout &lt;&lt; &quot;this is VD2 fcn()&quot; &lt;&lt; endl; &#125; //重写了VD1的虚函数 void f2() &#123; cout &lt;&lt; &quot;this is VD2 f2()&quot; &lt;&lt; endl; &#125;&#125;; 如下函数展示了覆盖和重写等情况时调用规则 1234567891011121314151617181920void use_hiddenbase()&#123; VD1 vd1; //调用基类VBase版本 vd1.VBase::fcn(); //调用VD1版本 vd1.fcn(100); VD2 vd2; VBase *pvb = &amp;vd1; //会调用基类的VBase::fcn() pvb-&gt;fcn(); VBase *pvb2 = &amp;vd2; //多态调用VD2::fcn() pvb2-&gt;fcn(); VD1 *pvd1 = &amp;vd2; //调用VD2版本的f2() pvd1-&gt;f2();&#125; 类的继承和多态总结1 派生类向基类转换只在指针或引用时才生效2 不存在默认的基类向子类转换，但是如果确认转换安全可以通过static_cast来转换。3 类不想被继承，可以在类名后添加final关键字4 如果子类无权访问基类构造函数，则无法实现子类对象向基类对象的转换。5 子类对象可以向基类对象转换，默认只将子类对象中基类的成员赋值给基类对象。6 多态就是将子类对象的指针赋值给基类对象的指针，通过调用基类的虚函数，实现动态绑定， 运行时调用了子类的虚函数。 7 final 声明的虚函数会阻止继承该类的类重写该函数8 override 要求编译器检测重写的函数是否符合规则，是否为虚函数，是否为类型相同。9 继承纯虚类，一定要实现它的所有纯虚方法，否则该类无法使用。10 子类可以使用基类的public和protected成员，子类无法使用基类的private成员11 proteced 和private成员不可被对象的方式访问。12 子类的友元函数可以访问子类的私有变量和受保护变量，但是不能访问基类的受保护变量。13 子类的友元函数可以访问子类自己定义的私有变量，但是不能访问从基类继承而来的私有变量。14 子类和基类有相同名字的成员或者非虚函数非静态的成员函数，在使用的时候默认使用子类的， 如果想使用基类的需要加上基类名字的作用域。15 如果子类实现的函数和基类的虚函数同名，但是参数类型不同，就不是重写而是隐藏，重写要求子类的函数和 基类的虚函数类型，名称完全一致。16 针对一个普通的非虚函数的成员函数，子类实现了一个同名的函数，就是覆盖，会隐藏基类的同名函数17 重载是对于一个类来讲，实现了多个同名函数，他们的参数不同。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ lambda和function","date":"2022-04-11T13:42:28.000Z","path":"2022/04/11/cpp34/","text":"lambda表达式lambda表达式又称为匿名表达式，是C11提出的新语法。[]存储lambda表达式要捕获的值，()内的参数为形参，可供外部调用传值。lambda表达式可以直接调用 123456// 1 匿名调用 [](string name) &#123; cout &lt;&lt; &quot;this is anonymous&quot; &lt;&lt; endl; cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl; &#125;(&quot;zack&quot;); 上述代码定义了一个匿名函数后直接调用。我们可以通过auto初始化一个变量存储lambda表达式 12345678// 2 通过auto赋值 auto fname = [](string name) &#123; cout &lt;&lt; &quot;this is auto &quot; &lt;&lt; endl; cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl; &#125;; fname(&quot;Rolin&quot;); 通过auto定义fname，然后存储了lambda表达式，之后调用fname即可。也可以通过函数指针的方式接受lambda表达式 123456789typedef void (*P_NameFunc)(string name);// 3 函数指针P_NameFunc fname2 = [](string name)&#123; cout &lt;&lt; &quot;this is P_NameFunc &quot; &lt;&lt; endl; cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;&#125;;fname2(&quot;Vivo&quot;); P_NameFunc定义了fname2函数指针接受了lambda表达式。也可以通过function对象接受lambda表达式，function类是C11新增的语法。 123456789// 4 function function&lt;void(string)&gt; funcName; funcName = [](string name) &#123; cout &lt;&lt; &quot;this is function &quot; &lt;&lt; endl; cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl; &#125;; funcName(&quot;Uncle Wang&quot;); 用一个function对象接受了lambda表达式，同样可以调用该function对象funcName达到调用lambda的效果。 谈谈lambda的捕获1 值捕获 123456789int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;//值捕获[age, name](string name_)&#123; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl;&#125;(&quot;Novia&quot;); 上述lambda表达式捕获了age和name，是以值的方式来捕获的。所以无法在lambda表达式内部修改age和name的值，如果修改age和name，编译器会报错，提示无法修改const常量，因为age和name是以值的方式被捕获的。2 引用捕获 12345678910int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;[&amp;age, &amp;name](string name_)&#123; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; name = &quot;Xiao Li&quot;; age = 18;&#125;(&quot;Novia&quot;); []里age和name前边添加了&amp;，此时age和name是以引用方式捕获的。所以可以在lambda表达式中修改age和name的值。C++的lambda表达式虽然可以捕获局部变量的引用，达到类似闭包的效果，但不是真的闭包，golang和python等语言通过闭包捕获局部变量后可以增加局部变量的声明周期，C++无法做到这一点，所以下面的调用会出现崩溃。 1234567891011121314151617181920212223242526272829vector&lt;function&lt;void(string)&gt;&gt; vec_Funcs;void use_lambda2()&#123; int age = 33; string name = &quot;zack&quot;; int score = 100; string job = &quot;softengineer&quot;; vec_Funcs.push_back([age, name](string name_) &#123; cout &lt;&lt; &quot;this is value catch &quot; &lt;&lt; endl; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; &#125;); //危险，不要捕获局部变量的引用 vec_Funcs.push_back([&amp;age, &amp;name](string name_) &#123; cout &lt;&lt; &quot;this is referenc catch&quot; &lt;&lt; endl; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; &#125;);&#125;void use_lambda3()&#123; for (auto f : vec_Funcs) &#123; f(&quot;zack&quot;); &#125;&#125;int main()&#123; use_lambda2(); use_lambda3();&#125; use_lambda2中将lambda表达式存储在function类型的vector里，当use_lambda2结束后，里边的局部变量都被释放了，而vector中的lambda表达式还存储着局部变量的引用，在调用use_lambda3时调用lambda表达式，此时访问局部变量已经被释放了，所以导致程序崩溃。3 全部用值捕获，name用引用捕获 123456789int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;[=, &amp;name]()&#123; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; score is &quot; &lt;&lt; score &lt;&lt; &quot; job is &quot; &lt;&lt; job &lt;&lt; endl; name = &quot;Cui Hua&quot;;&#125;(); 通过=表示所有变量都以值的方式捕获，如果希望某个变量以引用方式捕获则单独在这个变量前加&amp;。4 全部用引用捕获，只有name用值捕获 12345678int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;[&amp;, name]()&#123; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; score is &quot; &lt;&lt; score &lt;&lt; &quot; job is &quot; &lt;&lt; job &lt;&lt; endl;&#125;(); 通过&amp;方式表示所有变量都已引用方式捕获，如果希望某个变量以值方式捕获则单独在这个变量前加=。 万能的function我们可以用function存储形参和返回值相同的一类函数指针，可调用对象，lambda表达式等。 12345678910111213141516void use_function()&#123; list&lt;function&lt;void(string)&gt;&gt; list_Funcs; //存储函数对象 list_Funcs.push_back(FuncObj()); //存储lambda表达式 list_Funcs.push_back([](string str) &#123; cout &lt;&lt; &quot;this is lambda call &quot; &lt;&lt; str &lt;&lt; endl; &#125;); //存储全局函数 list_Funcs.push_back(globalFun); for (const auto &amp;f : list_Funcs) &#123; f(&quot;hello zack&quot;); &#125;&#125; bind操作C11同样提供了bind操作，将原函数的几个参数通过bind绑定传值，返回一个新的可调用对象。 1234567891011//绑定全局函数auto newfun1 = bind(globalFun2, placeholders::_1, placeholders::_2, 98, &quot;worker&quot;);//相当于调用globalFun2(&quot;Lily&quot;,22, 98,&quot;worker&quot;);newfun1(&quot;Lily&quot;, 22);//多传参数没有用，相当于调用globalFun2(&quot;Lucy&quot;,28, 98,&quot;worker&quot;);newfun1(&quot;Lucy&quot;, 28, 100, &quot;doctor&quot;);auto newfun2 = bind(globalFun2, &quot;zack&quot;, placeholders::_1, 100, placeholders::_2);//相当于调用globalFun2(&quot;zack&quot;,33,100,&quot;engineer&quot;);newfun2(33, &quot;engineer&quot;);auto newfun3 = bind(globalFun2, &quot;zack&quot;, placeholders::_2, 100, placeholders::_1);newfun3(&quot;coder&quot;, 33); placeholders表示占位符，_1表示新生成函数的第一个参数, _2表示新生成函数的第二个参数，将这些参数传递给原函数达到占位的效果，原函数的其余参数通过bind绑定固定值。接下来定义类 1234567891011class BindTestClass&#123;public: BindTestClass(int num_, string name_) : num(num_), name(name_) &#123;&#125; static void StaticFun(const string &amp;str, int age); void MemberFun(const string &amp;job, int score);public: int num; string name;&#125;; 实现静态函数和成员函数 1234567891011121314void BindTestClass::StaticFun(const string &amp;str, int age)&#123; cout &lt;&lt; &quot;this is static function&quot; &lt;&lt; endl; cout &lt;&lt; &quot;name is &quot; &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; endl;&#125;void BindTestClass::MemberFun(const string &amp;job, int score)&#123; cout &lt;&lt; &quot;this is member function&quot; &lt;&lt; endl; cout &lt;&lt; &quot;name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;age is &quot; &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;job is &quot; &lt;&lt; job &lt;&lt; endl; cout &lt;&lt; &quot;score is &quot; &lt;&lt; score &lt;&lt; endl;&#125; 我们通过bind绑定静态成员函数 1234//绑定类的静态成员函数,加不加&amp;都可以// auto staticbind = bind(BindTestClass::StaticFun, placeholders::_1, 33);auto staticbind = bind(&amp;BindTestClass::StaticFun, placeholders::_1, 33);staticbind(&quot;zack&quot;); 新生成的staticbind函数可以直接传递一个参数zack就完成了调用。接下来用bind绑定成员函数 1234567891011BindTestClass bindTestClass(33, &quot;zack&quot;);// 绑定类的成员函数,一定要传递对象给bind的第二个参数，可以是类对象，也可以是类对象的指针// 如果要修改类成员，必须传递类对象的指针auto memberbind = bind(BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);memberbind(&quot;coder&quot;, 100);auto memberbind2 = bind(BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);memberbind2(&quot;coder&quot;, 100, &amp;bindTestClass);//绑定类成员时，对象必须取地址auto numbind = bind(&amp;BindTestClass::num, placeholders::_1);std::cout &lt;&lt; numbind(bindTestClass) &lt;&lt; endl; 当然也可以直接用function对象接受bind返回的结果 123456789101112131415161718// function接受bind返回的函数function&lt;void(int, string)&gt; funcbind = bind(globalFun2, &quot;zack&quot;, placeholders::_1, 100, placeholders::_2);funcbind(33, &quot;engineer&quot;);// function接受bind 成员函数function&lt;void(string, int)&gt; funcbind2 = bind(BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);funcbind2(&quot;docker&quot;, 100);function&lt;void(string, int, BindTestClass *)&gt; funcbind3 = bind(BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);funcbind3(&quot;driver&quot;, 100, &amp;bindTestClass);// function 直接接受成员函数,function的模板列表里第一个参数是类对象引用function&lt;void(BindTestClass &amp;, const string &amp;, int)&gt; functomem = BindTestClass::MemberFun;functomem(bindTestClass, &quot;functomem&quot;, 88);// function 绑定类的静态成员函数function&lt;void(const string &amp;)&gt; funbindstatic = bind(&amp;BindTestClass::StaticFun, placeholders::_1, 33);funbindstatic(&quot;Rolis&quot;); lambda和bind的使用就介绍到这里源码链接：https://gitee.com/secondtonone1/cpplearn视频链接: https://www.bilibili.com/video/BV15S4y1Y7no","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 运算符重载","date":"2022-04-10T06:52:06.000Z","path":"2022/04/10/cpp33/","text":"本文介绍了C++ 运算符重载的用法，以我们构造的string类为例子，说明重载的用法。 构造我们自己的string类声明如下 1234567891011121314151617181920class mystring_&#123;public: mystring_(/* args */); mystring_(const mystring_ &amp;mstr); mystring_(const char *m_str); mystring_(const string); ~mystring_(); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const mystring_ &amp;mystr1); mystring_ &amp;operator=(const mystring_ &amp;mystr); mystring_ &amp;operator=(string str); mystring_ &amp;operator=(const char *cstr); friend mystring_ operator+(const mystring_ &amp;str1, const mystring_ &amp;str2); char operator[](unsigned int index); friend class mystringOpr_;private: char *m_str;&#125;; 在string类里重载了输出运算符&lt;&lt;，赋值运算符=, 加法运算符+, 取下标运算符[], 又声明了友元类mystringOpr。 12345class mystringOpr_&#123;public: bool operator()(const mystring_ &amp;, const mystring_ &amp;);&#125;; 该类重载了()运算符，这样mystringOpr的实例对象就是可调用对象了，可以当作仿函数使用。 mystring_类的具体实现我们先实现构造函数和析构函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758mystring_::mystring_(/* args */) : m_str(&quot;&quot;)&#123;&#125;mystring_::mystring_(const mystring_ &amp;mystr)&#123; if (&amp;mystr == this) &#123; return; &#125; if (mystr.m_str == nullptr) &#123; m_str = nullptr; return; &#125; size_t len = strlen(mystr.m_str); m_str = new char[len + 1]; strcpy(m_str, mystr.m_str); m_str[len] = &#x27;\\0&#x27;;&#125;mystring_::mystring_(const char *mstr)&#123; cout &lt;&lt; &quot;use mystring_ construct , param is const char *&quot; &lt;&lt; endl; size_t len = strlen(mstr); m_str = new char[len + 1]; strcpy(m_str, mstr); m_str[len] = &#x27;\\0&#x27;;&#125;mystring_::mystring_(const string str)&#123; cout &lt;&lt; &quot;use mystring_ construct string str&quot; &lt;&lt; endl; size_t len = str.length(); m_str = new char[len + 1]; strncpy(m_str, str.c_str(), len); m_str[len] = &#x27;\\0&#x27;;&#125;mystring_::~mystring_()&#123; if (m_str == &quot;&quot; || m_str == nullptr) &#123; cout &lt;&lt; &quot;begin destruct , str is null or empty&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;begin destruct &quot; &lt;&lt; m_str &lt;&lt; endl; &#125; if (m_str == nullptr || m_str == &quot;&quot;) &#123; return; &#125; delete[] m_str; m_str = nullptr;&#125; 实现了形参不同的拷贝构造函数，包括const string类型，const char*类型，const mystring_ &amp;类型，以及默认的无参构造函数。接下来重载+运算符 12345678910mystring_ operator+(const mystring_ &amp;str1, const mystring_ &amp;str2)&#123; size_t len = strlen(str1.m_str) + strlen(str2.m_str) + 1; mystring_ strtotal; strtotal.m_str = new char[len + 1]; memset(strtotal.m_str, 0, len); memcpy(strtotal.m_str, str1.m_str, strlen(str1.m_str)); strcat(strtotal.m_str, str2.m_str); return strtotal;&#125; 重载=运算符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556mystring_ &amp;mystring_::operator=(const mystring_ &amp;mystr)&#123; if (&amp;mystr == this) &#123; return *this; &#125; if (this-&gt;m_str != nullptr) &#123; delete[] m_str; this-&gt;m_str = nullptr; &#125; if (mystr.m_str == nullptr) &#123; m_str = nullptr; &#125; size_t len = strlen(mystr.m_str); m_str = new char[len + 1]; strcpy(m_str, mystr.m_str); m_str[len] = &#x27;\\0&#x27;; return *this;&#125;mystring_ &amp;mystring_::operator=(string str)&#123; cout &lt;&lt; &quot;use operator = string str&quot; &lt;&lt; endl; if (this-&gt;m_str != nullptr) &#123; delete[] m_str; this-&gt;m_str = nullptr; &#125; size_t len = str.length(); m_str = new char[len + 1]; strncpy(m_str, str.c_str(), len); m_str[len] = &#x27;\\0&#x27;; return *this;&#125;mystring_ &amp;mystring_::operator=(const char *cstr)&#123; cout &lt;&lt; &quot;use operator = const char*&quot; &lt;&lt; endl; if (this-&gt;m_str != nullptr) &#123; delete[] m_str; this-&gt;m_str = nullptr; &#125; size_t len = strlen(cstr); m_str = new char[len + 1]; strncpy(m_str, cstr, len); m_str[len] = &#x27;\\0&#x27;; return *this;&#125; 重载输出运算符 12345678910ostream &amp;operator&lt;&lt;(ostream &amp;os, const mystring_ &amp;mystr1)&#123; if (mystr1.m_str == nullptr) &#123; os &lt;&lt; &quot;mystring_ data is null&quot; &lt;&lt; endl; return os; &#125; os &lt;&lt; &quot;mystring_ data is &quot; &lt;&lt; mystr1.m_str &lt;&lt; endl; return os;&#125; 重载取下表运算符[] 123456789char mystring_::operator[](unsigned int index)&#123; if (index &gt;= strlen(m_str)) &#123; throw &quot;index out of range!!!&quot;; &#125; return m_str[index];&#125; 我们写一个函数测试重载效果 123456789101112131415161718void use_mystr_1()&#123; auto mystr1 = mystring_(&quot;hello zack&quot;); auto mystr2(mystr1); auto mystr3 = mystring_(); cout &lt;&lt; mystr1 &lt;&lt; mystr2 &lt;&lt; mystr3 &lt;&lt; endl; mystring_ mystr4 = &quot;, i love u&quot;; auto mystr5 = mystr1 + mystr4; cout &lt;&lt; &quot;mystr4 is &quot; &lt;&lt; mystr4 &lt;&lt; endl; cout &lt;&lt; &quot;mystr5 is &quot; &lt;&lt; mystr5 &lt;&lt; endl; mystring_ mystr6 = &quot;&quot;; auto mystr7 = mystr5 + mystr6; cout &lt;&lt; &quot;mystr7 is &quot; &lt;&lt; mystr7 &lt;&lt; endl; auto ch = mystr1[4]; cout &lt;&lt; &quot;index is 4, char is &quot; &lt;&lt; ch &lt;&lt; endl;&#125; 测试结果如下 1234567891011121314use mystring_ construct , param is const char *mystring_ data is hello zackmystring_ data is hello zackmystring_ data isuse mystring_ construct , param is const char *mystr4 is mystring_ data is , i love umystr5 is mystring_ data is hello zack, i love uuse mystring_ construct , param is const char *mystr7 is mystring_ data is hello zack, i love uindex is 4, char is o 可以看出调用不同的构造函数会打印不同的日志，重载+运算符实现了字符串的拼接，重载赋值实现了拷贝。 通过仿函数mystringOpr_实现排序我们先实现仿函数，这样就可以对我们mystring_类对象排序了 1234567891011121314151617bool mystringOpr_::operator()(const mystring_ &amp;str1, const mystring_ &amp;str2)&#123; if (strlen(str1.m_str) &gt; strlen(str2.m_str)) &#123; return true; &#125; if (strlen(str1.m_str) &lt; strlen(str2.m_str)) &#123; return false; &#125; for (unsigned int i = 0; i &lt; strlen(str1.m_str); i++) &#123; return str1.m_str[i] &gt; str2.m_str[i]; &#125;&#125; 我们调用sort实现mystring_排序,在原来的基础上补充排序代码 12345678910111213141516171819202122232425262728293031void use_mystr_1()&#123; auto mystr1 = mystring_(&quot;hello zack&quot;); auto mystr2(mystr1); auto mystr3 = mystring_(); cout &lt;&lt; mystr1 &lt;&lt; mystr2 &lt;&lt; mystr3 &lt;&lt; endl; mystring_ mystr4 = &quot;, i love u&quot;; auto mystr5 = mystr1 + mystr4; cout &lt;&lt; &quot;mystr4 is &quot; &lt;&lt; mystr4 &lt;&lt; endl; cout &lt;&lt; &quot;mystr5 is &quot; &lt;&lt; mystr5 &lt;&lt; endl; mystring_ mystr6 = &quot;&quot;; auto mystr7 = mystr5 + mystr6; cout &lt;&lt; &quot;mystr7 is &quot; &lt;&lt; mystr7 &lt;&lt; endl; auto ch = mystr1[4]; cout &lt;&lt; &quot;index is 4, char is &quot; &lt;&lt; ch &lt;&lt; endl; std::vector&lt;mystring_&gt; vec_mystring_; vec_mystring_.push_back(mystr1); vec_mystring_.push_back(mystr2); vec_mystring_.push_back(mystr3); vec_mystring_.push_back(mystr4); vec_mystring_.push_back(mystr5); vec_mystring_.push_back(mystr6); vec_mystring_.push_back(mystr7); sort(vec_mystring_.begin(), vec_mystring_.end(), mystringOpr_()); cout &lt;&lt; &quot;====================after sort ...&quot; &lt;&lt; endl; for_each(vec_mystring_.begin(), vec_mystring_.end(), [](const mystring_ &amp;str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125;);&#125; 上述代码通过sort排序vector里的mystring_对象，并用lambda表达式输出，可以看到输出 12345678910111213141516171819202122232425262728use mystring_ construct , param is const char *mystring_ data is hello zackmystring_ data is hello zackmystring_ data isuse mystring_ construct , param is const char *mystr4 is mystring_ data is , i love umystr5 is mystring_ data is hello zack, i love uuse mystring_ construct , param is const char *mystr7 is mystring_ data is hello zack, i love uindex is 4, char is o====================after sort ...mystring_ data is hello zack, i love umystring_ data is hello zack, i love umystring_ data is hello zackmystring_ data is hello zackmystring_ data is , i love umystring_ data ismystring_ data is 我们通过仿函数和sort实现了mystring_从大到小的排序。 总结源码链接：https://gitee.com/secondtonone1/cpplearn视频链接: https://www.bilibili.com/video/BV1zu411e7DW/","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++单例模式的几种实现","date":"2022-03-20T07:40:09.000Z","path":"2022/03/20/cpp32/","text":"本文介绍C++单例模式的集中实现方式，以及利弊 局部静态变量方式123456789101112131415161718//通过静态成员变量实现单例//懒汉式class Single2&#123;private: Single2() &#123; &#125; Single2(const Single2 &amp;) = delete; Single2 &amp;operator=(const Single2 &amp;) = delete;public: static Single2 &amp;GetInst() &#123; static Single2 single; return single; &#125;&#125;; 上述代码通过局部静态成员single实现单例类，原理就是函数的局部静态变量生命周期随着进程结束而结束。上述代码通过懒汉式的方式实现。调用如下 123456void test_single2()&#123; //多线程情况下可能存在问题 cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl; cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl;&#125; 程序输出如下 12sp1 is 0x1304b10sp2 is 0x1304b10 确实生成了唯一实例，上述单例模式存在隐患，对于多线程方式生成的实例可能时多个。 静态成员变量指针方式可以定义一个类的静态成员变量，用来控制实现单例 1234567891011121314151617181920212223//饿汉式class Single2Hungry&#123;private: Single2Hungry() &#123; &#125; Single2Hungry(const Single2Hungry &amp;) = delete; Single2Hungry &amp;operator=(const Single2Hungry &amp;) = delete;public: static Single2Hungry *GetInst() &#123; if (single == nullptr) &#123; single = new Single2Hungry(); &#125; return single; &#125;private: static Single2Hungry *single;&#125;; 这么做的一个好处是我们可以通过饿汉式的方式避免线程安全问题 123456789101112131415161718192021//饿汉式初始化Single2Hungry *Single2Hungry::single = Single2Hungry::GetInst();void thread_func_s2(int i)&#123; cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;inst is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;&#125;void test_single2hungry()&#123; cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl; cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl; for (int i = 0; i &lt; 3; i++) &#123; thread tid(thread_func_s2, i); tid.join(); &#125;&#125;int main()&#123; test_single2hungry()&#125; 程序输出如下 12345678s1 addr is 0x1e4b00s2 addr is 0x1e4b00this is thread 0inst is 0x1e4b00this is thread 1inst is 0x1e4b00this is thread 2inst is 0x1e4b00 可见无论单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。饿汉式是在程序启动时就进行单例的初始化，这种方式也可以通过懒汉式调用，无论饿汉式还是懒汉式都存在一个问题，就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。我们定义一个单例类并用懒汉式方式调用 1234567891011121314151617181920212223242526272829303132333435//懒汉式指针//即使创建指针类型也存在问题class SinglePointer&#123;private: SinglePointer() &#123; &#125; SinglePointer(const SinglePointer &amp;) = delete; SinglePointer &amp;operator=(const SinglePointer &amp;) = delete;public: static SinglePointer *GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; single = new SinglePointer(); s_mutex.unlock(); return single; &#125;private: static SinglePointer *single; static mutex s_mutex;&#125;; 在cpp文件里初始化静态成员,并定义一个测试函数 12345678910111213141516171819202122232425//懒汉式//在类的cpp文件定义static变量SinglePointer *SinglePointer::single = nullptr;std::mutex SinglePointer::s_mutex;void thread_func_lazy(int i)&#123; cout &lt;&lt; &quot;this is lazy thread &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;inst is &quot; &lt;&lt; SinglePointer::GetInst() &lt;&lt; endl;&#125;void test_singlelazy()&#123; for (int i = 0; i &lt; 3; i++) &#123; thread tid(thread_func_lazy, i); tid.join(); &#125; //何时释放new的对象？造成内存泄漏&#125;int main()&#123; test_singlelazy();&#125; 函数输出如下 123456this is lazy thread 0inst is 0xbc1700this is lazy thread 1inst is 0xbc1700this is lazy thread 2inst is 0xbc1700 此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。 智能指针方式可以利用智能指针自动回收内存的机制设计单例类 12345678910111213141516171819202122232425262728293031323334353637383940//利用智能指针解决释放问题class SingleAuto&#123;private: SingleAuto() &#123; &#125; SingleAuto(const SingleAuto &amp;) = delete; SingleAuto &amp;operator=(const SingleAuto &amp;) = delete;public: ~SingleAuto() &#123; cout &lt;&lt; &quot;single auto delete success &quot; &lt;&lt; endl; &#125; static std::shared_ptr&lt;SingleAuto&gt; GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; single = std::shared_ptr&lt;SingleAuto&gt;(new SingleAuto); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAuto&gt; single; static mutex s_mutex;&#125;; SingleAuto的GetInst返回std::shared_ptr类型的变量single。因为single是静态成员变量，所以会在进程结束时被回收。智能指针被回收时会调用内置指针类型的析构函数，从而完成内存的回收。在主函数调用如下测试函数 123456789101112131415// 智能指针方式std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = nullptr;mutex SingleAuto::s_mutex;void test_singleauto()&#123; auto sp1 = SingleAuto::GetInst(); auto sp2 = SingleAuto::GetInst(); cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; endl; cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; endl; //此时存在隐患，可以手动删除裸指针，造成崩溃 // delete sp1.get();&#125;int main()&#123; test_singleauto();&#125; 程序输出如下 12sp1 is 0x1174f30sp2 is 0x1174f30 智能指针方式不存在内存泄漏，但是有一个隐患就是单例类的析构函数时public的，如果被人手动调用会存在崩溃问题，比如将上边test_singleauto中的注释打开，程序会崩溃。 辅助类智能指针单例模式智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// safe deletor//防止外界delete//声明辅助类//该类定义仿函数调用SingleAutoSafe析构函数//不可以提前声明SafeDeletor，编译时会提示incomplete type// class SafeDeletor;//所以要提前定义辅助类class SingleAutoSafe;class SafeDeletor&#123;public: void operator()(SingleAutoSafe *sf) &#123; cout &lt;&lt; &quot;this is safe deleter operator()&quot; &lt;&lt; endl; delete sf; &#125;&#125;;class SingleAutoSafe&#123;private: SingleAutoSafe() &#123;&#125; ~SingleAutoSafe() &#123; cout &lt;&lt; &quot;this is single auto safe deletor&quot; &lt;&lt; endl; &#125; SingleAutoSafe(const SingleAutoSafe &amp;) = delete; SingleAutoSafe &amp;operator=(const SingleAutoSafe &amp;) = delete; //定义友元类，通过友元类调用该类析构函数 friend class SafeDeletor;public: static std::shared_ptr&lt;SingleAutoSafe&gt; GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; //额外指定删除器 single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDeletor()); //也可以指定删除函数 // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAutoSafe&gt; single; static mutex s_mutex;&#125;; SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。 1234567891011121314151617//智能指针初始化为nullptrstd::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::single = nullptr;mutex SingleAutoSafe::s_mutex;void test_singleautosafe()&#123; auto sp1 = SingleAutoSafe::GetInst(); auto sp2 = SingleAutoSafe::GetInst(); cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; endl; cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; endl; //此时无法访问析构函数，非常安全 // delete sp1.get();&#125;int main()&#123; test_singleautosafe();&#125; 程序输出如下 12sp1 is 0x1264f30sp2 is 0x1264f30 通过辅助类调用单例类的析构函数保证了内存释放的安全性和唯一性。这种方式时生产中常用的。如果将test_singleautosafe函数的注释打开，手动delete sp1.get()编译阶段就会报错，达到了代码安全的目的。因为析构被设置为私有函数了。 通用的单例模板类我们可以通过声明单例的模板类，然后继承这个单例模板类的所有类就是单例类了。达到泛型编程提高效率的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445template &lt;typename T&gt;class Single_T&#123;protected: Single_T() = default; Single_T(const Single_T&lt;T&gt; &amp;st) = delete; Single_T &amp;operator=(const Single_T&lt;T&gt; &amp;st) = delete; ~Single_T() &#123; cout &lt;&lt; &quot;this is auto safe template destruct&quot; &lt;&lt; endl; &#125;public: static std::shared_ptr&lt;T&gt; GetInst() &#123; if (single != nullptr) &#123; return single; &#125; s_mutex.lock(); if (single != nullptr) &#123; s_mutex.unlock(); return single; &#125; //额外指定删除器 single = std::shared_ptr&lt;T&gt;(new T, SafeDeletor_T&lt;T&gt;()); //也可以指定删除函数 // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc); s_mutex.unlock(); return single; &#125;private: static std::shared_ptr&lt;T&gt; single; static mutex s_mutex;&#125;;//模板类的static成员要放在h文件里初始化template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = nullptr;template &lt;typename T&gt;mutex Single_T&lt;T&gt;::s_mutex; 我们定义一个网络的单例类，继承上述模板类即可，并将构造和析构设置为私有，同时设置友元保证自己的析构和构造可以被友元类调用. 1234567891011//通过继承方式实现网络模块单例class SingleNet : public Single_T&lt;SingleNet&gt;&#123;private: SingleNet() = default; SingleNet(const SingleNet &amp;) = delete; SingleNet &amp;operator=(const SingleNet &amp;) = delete; ~SingleNet() = default; friend class SafeDeletor_T&lt;SingleNet&gt;; friend class Single_T&lt;SingleNet&gt;;&#125;; 在主函数中调用如下 1234567void test_singlenet()&#123; auto sp1 = SingleNet::GetInst(); auto sp2 = SingleNet::GetInst(); cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; endl; cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; endl;&#125; 程序输出如下 12sp1 is 0x1164f30sp2 is 0x1164f30 总结本文介绍了一些面试常见问题源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"二分查找升序序列","date":"2022-03-02T10:09:37.000Z","path":"2022/03/02/algorithms04/","text":"问题描述有一个连续的int数组，数组中的数据升序排序，数组中的数据不唯一，有重复数据，要求在数组中查找指定值为target的数据，返回target最小的下标，如果找到返回其最小的下标，如果没有找到，返回-1， 要求用 用二分查找的方式解决上述问题， 要求时间复杂度为Olog(n),空间复杂度为O(1) 举例 数组nums = [0,1,1,3,3,4]， 查找target为1的数据最小的下标则返回1。如果查找target为100，则返回-1 解决思路用二分查找解决上述问题，用一个数组中间的数据和target比较，如果中间值比target小，则说明target在中间值右侧。如果中间值比target大，则说明target在中间值左侧。如果中间值和target相等，则找到该target的位置，但是由于target不唯一，所以要向左移动，找到target最小的下标。 编码将上边的逻辑实现如下 12345678910111213141516171819202122232425262728293031323334int binary_search(int nums[], int begin, int end, int target)&#123; //只要有一个越界就是没找到 if (begin &lt; 0 || begin &gt; end || end &lt; 0) &#123; return -1; &#125; //找到中间值比较 int mid = (begin + end) / 2; // cout &lt;&lt; &quot;mid is &quot; &lt;&lt; mid &lt;&lt; endl; //要找到的target在右半部分 if (target &gt; nums[mid]) &#123; return binary_search(nums, mid + 1, end, target); &#125; //要找到的target在左半部分 if (target &lt; nums[mid]) &#123; return binary_search(nums, begin, mid - 1, target); &#125; // cout &lt;&lt; &quot;nums[mid] is &quot; &lt;&lt; nums[mid] &lt;&lt; endl; //如果找到target相等的元素，需要向左移动找到最小索引 for (int i = mid; i &gt; begin; i--) &#123; if (target == nums[mid]) &#123; continue; &#125; // cout &lt;&lt; &quot;i is &quot; &lt;&lt; endl; return i + 1; &#125;&#125; 在main函数中调用如下 1234567int nums[] = &#123;0, 1, 1, 3, 3, 4&#125;;int find = binary_search(nums, 0, sizeof(nums) / sizeof(int) - 1, 3);cout &lt;&lt; &quot;find is &quot; &lt;&lt; find &lt;&lt; endl;int find2 = binary_search(nums, 0, sizeof(nums) / sizeof(int) - 1, 4);cout &lt;&lt; &quot;find is &quot; &lt;&lt; find2 &lt;&lt; endl;int find3 = binary_search(nums, 0, sizeof(nums) / sizeof(int) - 1, 0);cout &lt;&lt; &quot;find is &quot; &lt;&lt; find3 &lt;&lt; endl; 程序输出如下 123find is 3find is 5find is 0 总结本文实现了用二分查找的方式找到给定的target值源码链接https://gitee.com/secondtonone1/algorithms更多算法实现点击下方链接https://llfc.club/category?catid=22zkaaQaS2wMZRygv3qQVpRKpXI","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"C++ 面试常问问题(一)","date":"2022-03-02T08:50:16.000Z","path":"2022/03/02/cpp31/","text":"这篇文章讲解C++ 面试常问的几个问题。本文通过demo讲解初始化列表，继承，字符串等常问问题。看下边这个例子 初始化列表12345678910111213141516171819202122232425262728293031323334353637383940//基类class Base&#123;public: Base() : m_nbase(0), m_nbase2(m_nbase + 100) &#123;&#125; Base(int n) : m_nbase(n), m_nbase2(m_nbase + 100) &#123; cout &lt;&lt; &quot;this is Base construct &quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;this is Base destruct &quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;this is Base printData &quot; &lt;&lt; endl; cout &lt;&lt; &quot;data is &quot; &lt;&lt; m_nbase &lt;&lt; endl; // cout &lt;&lt; &quot;base2 data is &quot; &lt;&lt; m_nbase2 &lt;&lt; endl; &#125; void printData2() &#123; cout &lt;&lt; &quot;base2 data is &quot; &lt;&lt; m_nbase2 &lt;&lt; endl; &#125; int SizeOf(char p[]) &#123; return sizeof(p); &#125; int SizeOf2(char *p) &#123; return sizeof(p); &#125;private: int m_nbase; int m_nbase2;&#125;; 实现了一个类Base，类的构造函数采用了初始化列表，初始化列表按顺序初始化初始类成员。接下来在main函数里调用如下 123Base b1(1);b1.printData();b1.printData2(); 1 问Base的初始化列表是否会报错？回答：不会有问题，因为初始化列表按顺序初始化类成员。所以会分别输出m_nbase的值为1, m_nbase2的值为101 继承问题继承问题常问到的是基类和子类的关系，继承先构造基类再构造子类。析构时先析构子类，再析构基类。我们实现一个Derive类继承自Base 12345678910111213141516171819class Derive : public Base&#123;public: Derive(int n) : Base(n), m_nderive(n) &#123; cout &lt;&lt; &quot;this is Derive construct &quot; &lt;&lt; endl; &#125; ~Derive() &#123; cout &lt;&lt; &quot;this is Derive destruct &quot; &lt;&lt; endl; &#125; void printData() &#123; cout &lt;&lt; &quot;this is Derive printData&quot; &lt;&lt; endl; &#125;private: int m_nderive;&#125;; Derive类继承了Base类，接下来我们在主函数中调用如下 123Derive d1(2);d1.printData();cout &lt;&lt; &quot; .................&quot; &lt;&lt; endl; 1 问 上面程序输出什么答 输出如下 12345this is Base construct this is Derive construct this is Derive printDatathis is Derive destruct this is Base destruct 因为构造时，先构造基类再构造子类，析构时先析构子类再析构基类如果在主函数中调用如下 123Base *b1 = new Derive(2);b1-&gt;printData();delete b1; 2 问上面程序输出什么？答输出如下 1234this is Base construct this is Derive construct this is Derive printDatathis is Base destruct 因为构造时同样先构造基类，再构造子类。由于创建子类对象返回基类指针，调用虚函数printData会触发多态机制，调用了子类的printData。析构时由于析构函数不是虚函数，所以不会调用子类的析构函数！！！所以只会输出Base的析构函数。3 问如何解决多态情况下子类无法析构问题？答 将基类和子类的析构函数都设置为虚析构函数即可，少一个都不行！！！修改如下 1234567891011121314151617181920212223242526272829303132333435363738394041class Base&#123;public: Base() : m_nbase(0), m_nbase2(m_nbase + 100) &#123;&#125; Base(int n) : m_nbase(n), m_nbase2(m_nbase + 100) &#123; cout &lt;&lt; &quot;this is Base construct &quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;this is Base destruct &quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;this is Base printData &quot; &lt;&lt; endl; cout &lt;&lt; &quot;data is &quot; &lt;&lt; m_nbase &lt;&lt; endl; // cout &lt;&lt; &quot;base2 data is &quot; &lt;&lt; m_nbase2 &lt;&lt; endl; &#125; //....省略&#125;;class Derive : public Base&#123;public: Derive(int n) : Base(n), m_nderive(n) &#123; cout &lt;&lt; &quot;this is Derive construct &quot; &lt;&lt; endl; &#125; virtual ~Derive() &#123; cout &lt;&lt; &quot;this is Derive destruct &quot; &lt;&lt; endl; &#125; void printData() &#123; cout &lt;&lt; &quot;this is Derive printData&quot; &lt;&lt; endl; &#125;private: int m_nderive;&#125;; 此时再调用 123Base *b1 = new Derive(2);b1-&gt;printData();delete b1; 程序输出 12345this is Base construct this is Derive construct this is Derive printDatathis is Derive destruct this is Base destruct 字符串sizeof字符串的sizeof也是常问的问题 12345678char carry[100] = &quot;Hello World&quot;;cout &lt;&lt; &quot;sizeof(carry) &quot; &lt;&lt; sizeof(carry) &lt;&lt; endl;char *pstr = &quot;Hello World&quot;;cout &lt;&lt; &quot;sizeof(pstr) &quot; &lt;&lt; sizeof(pstr) &lt;&lt; endl;cout &lt;&lt; &quot;sizeof(*pstr) &quot; &lt;&lt; sizeof(*pstr) &lt;&lt; endl;Base b1;cout &lt;&lt; &quot;b1.SizeOf(carry) &quot; &lt;&lt; b1.SizeOf(carry) &lt;&lt; endl;cout &lt;&lt; &quot;b1.SizeOf2(carry) &quot; &lt;&lt; b1.SizeOf2(carry) &lt;&lt; endl; 1 问上边程序输出什么答 输出如下 12345sizeof(carry) 100sizeof(pstr) 4sizeof(*pstr) 1b1.SizeOf(carry) 4b1.SizeOf2(carry) 4 carry是个数组，所以sizeof(carry)是数组的大小为100pstr是个char指针，所以sizeof(pstr)是指针大小为4字节，当然在64位机器为8我的机器上输出的是8，这个根据机器不同而不同，记住是指针大小就行。pstr指向字符串首地址，也是第一个字符的地址,*pstr为第一个字符sizeof(*pstr)为一个字符的大小，所以为1b1.SizeOf以及b1.SizeOf2内部调用的都是sizeof()一个char指针，所以都为4，我的机器上输出为8 bool，float和0比较bool和0比较 1234567bool bval = true;if(!bval)&#123; //... //bval为0的逻辑&#125;else&#123; //...&#125; float和0比较 12345678910111213141516171819float f1 = 0.1;if (f1 &lt;= FLT_EPSILON &amp;&amp; f1 &gt;= -FLT_EPSILON)&#123; cout &lt;&lt; &quot;this is float 0&quot; &lt;&lt; endl;&#125;else&#123; cout &lt;&lt; &quot;this is not float 0&quot; &lt;&lt; endl;&#125;double d1 = 0.0;if (d1 &lt;= DBL_EPSILON &amp;&amp; d1 &gt;= -DBL_EPSILON)&#123; cout &lt;&lt; &quot;this is double 0&quot; &lt;&lt; endl;&#125;else&#123; cout &lt;&lt; &quot;this is not double 0&quot; &lt;&lt; endl;&#125; 总结本文介绍了一些面试常见问题源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"hexoblog 搭建遇到的问题","date":"2022-03-01T04:21:33.000Z","path":"2022/03/01/hexoblogs2/","text":"需要js版本js版本过高会导致调用hexo g 命令时出现问题。建议使用node.js 12以下版本，我用的是v12.18.3历史版本下载可以参考如下链接https://nodejs.org/en/download/releases/如果想要管理多个版本的node，可以通过nvm管理，nvm下载和安装可以自行百度。 external_link 错误我们可能会遇到如下问题，当我们执行hexo g 时 hexo版本更新报错：INFO Validating config WARN Deprecated config detected: “external_link“ with a Boolean解决方案是将原有的 12external_link: enable: true|false 修改为 1234external_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#x27;&#x27; 执行hexo clean ，然后再次hexo g 生成文章。 遇到乱码hexo s 运行后打开网页显示如下乱码 1&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125; 则需要单独安装 hexo 的渲染包 1npm i hexo-renderer-swig 因为hexo5.0之后render包不进入hexo主干代码里，需要单独安装。安装好后执行hexo clean, 然后执行hexo g 生成代码，再次运行hexo s打开网页查看可以正常显示。 hexo 发布问题如果hexo d 遇到如下问题 1Error: Host key verification failed. 此时需要在本机生成ssh key，将ssh key 配置到github或者gitee的ssh管理里，如果博客是挂在github上就将key写入github的ssh。如果博客是挂在gitee上就将key写入gitee的ssh管理里。详见我的另一篇文章https://www.limerence2017.com/2017/08/24/hexoblogs/ 将hexo 和github 关联起来还是编辑根目录下_config.yml文件 12345678deploy: type: git repo: git@github.com:secondtonone1/secondtonone1.github.io.git #这里的网址填你自己的 branch: master``` 保存后需要提前安装一个扩展：``` cmdnpm install hexo-deployer-git --save 安装该扩展主要是为了支持hexo d 命令。 接下来就是将Hexo部署到我们的Github仓库上:命令行输入 hexo d 会自动将当前的博文生成html并且发布到github进行托管，在浏览器输入 secondtonone1.github.io (secondtonone1用户名替换为你自己的)即可浏览自己的博客了。这样就完成了github和hexo的关联部署。值得改进的地方是，每次调用hexo d 上传到github，都会提示输入github的用户名和密码，非常不方便可以通过SSH keys的设置，达到不输入密码直接发布的目的。 SSH keys的配置在Git 命令行输入如下命令： 1$ ssh-keygen -t rsa -C &quot;secondtonone1@163.com&quot; &#x73;&#x65;&#x63;&#111;&#x6e;&#x64;&#x74;&#111;&#x6e;&#111;&#110;&#x65;&#49;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d; 替换为你的github邮件地址Git显示： 123$ ssh-keygen -t rsa -C &quot;secondtonone1@163.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车&gt; 系统会要求你输入密码，这里设置的密码主要是在你提交Git时弹出密码认证，不想输入直接回车 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 配置ssh和github仓库找到id_rsa.pub 并复制文件内容id_rsa.pub文件一般位于电脑用户配置文件夹下的一个.ssh文件下C:Users你的用户名.ssh登录Github并添加密钥进入github首页在右上角选择settings设置。 测试通过git bash链接到Git链接Git 1$ ssh -T git@github.com 提示如下： 1234567yesThe authenticity of host &#x27;github.com (207.65.227.44)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:42:18:60:1d:7b:13:d2:b5:c4:20:7e:56:86:d8:71:f3Are you sure you want to continue connecting (yes/no)?以下为成功链接到GitHi XXXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 以后每次提交博文到github就不需要输入密码了，很方便。配置好后清除之前的记录，重新生成并提交，可以登录自己的github仓库地址(&#115;&#101;&#99;&#x6f;&#x6e;&#x64;&#x74;&#111;&#x6e;&#111;&#110;&#101;&#49;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;)查看博文了 123hexo cleanhexo ghexo d","categories":[{"name":"资源共享","slug":"share","permalink":"http://www.limerence2017.com/categories/share/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.limerence2017.com/tags/hexo/"}]},{"title":"C++ 右值引用与移动构造函数","date":"2022-02-10T09:12:07.000Z","path":"2022/02/10/cpp30/","text":"右值与右值引用不能修改的值就是右值，右值一般为临时变量。常见的右值有字面常量值，返回右值的表达式。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;来获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。 12345678910111213141516void right_references()&#123; int i = 42; //r 为i的引用，左值引用 int &amp;r = i; //rr 不可以引用左值i， //因为其是右值引用 //int &amp;&amp;rr = i; //表达式是一个右值 //不能用左值引用 //int &amp;r2 = i*42; //可以将const引用绑定到右值上 const int &amp;r3 = i * 42; //将rr2绑定到乘法结果上 int &amp;&amp;rr2 = i * 42;&#125; 上述代码右值引用只能捕获右值，左值引用只能捕获左值。const 引用可以捕获右值。左值更长久，右值是短暂的。 12345678void right_references()&#123; //右值引用捕获字面常量值 int &amp;&amp;rr1 = 42; //右值引用不能捕获左值 //因为rr1为左值，下面操作非法 //int &amp;&amp;rr2 = rr1;&#125; 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 move操作可以通过move操作将一个左值转化为右值引用。 1234567void right_references()&#123; //右值引用捕获字面常量值 int &amp;&amp;rr1 = 42; //通过move将左值转化为右值引用 int &amp;&amp;rr3 = std::move(rr1);&#125; move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。 移动构造函数在一些场景，我们不仅需要使用拷贝构造函数，还需要移动构造函数，移动构造函数减少拷贝带来的开销。类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。完善之前我们实现的strvec类，实现一个移动构造函数 1234567//移动构造函数//声明noexcept就是不抛出异常StrVec(StrVec &amp;&amp;src) noexcept : elements(src.elements), first_free(src.first_free), cap(src.cap)&#123; //将src的成员设置为空 src.elements = src.first_free = src.cap = nullptr;&#125; 与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。移动构造函数通常不会被标准库调用，因为移动构造函数可能抛出异常，导致移动过程中数据出现问题。比如vector，我们调用push_back时，通常vector会利用拷贝构造函数完成数据的移动而不是利用移动构造函数。这么做是为了保证移动的过程中出现异常后，清除新空间的数据，保留旧数据。说白了就是怕vector调用push_back添加元素时扩容，将旧数据移动到新空间时崩溃造成旧数据丢失。除非我们通过noexcept关键字通知标准库我们这个类的移动构造函数不会抛出异常，这样vector才会优先采用移动构造函数。移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。如果没定义析构函数，则编译器不会为该类定义合成的移动构造函数，因为使用移动构造函数的前提时编译器知道怎么回收对象。当一个类既有移动构造函数又有拷贝构造函数的时候，编译器会根据条件选择最合适的。完善之前的strvec类，实现移动赋值运算符 123456789101112131415161718//移动赋值运算符StrVec &amp;StrVec::operator=(StrVec &amp;&amp;src)&#123; cout &lt;&lt; &quot;this is move operator = &quot; &lt;&lt; endl; if (this != &amp;src) &#123; //释放自己的空间操作 this-&gt;free(); //接管源对象资源 this-&gt;elements = src.elements; this-&gt;first_free = src.first_free; this-&gt;cap = src.cap; //将源对象成员赋值为空 src.elements = src.first_free = src.cap = nullptr; &#125; return *this;&#125; 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。建议定义拷贝构造函数，拷贝赋值运算符以及析构函数后，在定义移动构造和移动赋值，交给编译器自动调用合理的赋值和构造函数。之前实现过消息和文件夹的两个类，现在为Message类增加移动构造函数和移动赋值函数，在此之前先实现工具函数帮助我们将Message类的文件夹信息移动给另一个Message类对象 12345678910111213141516171819202122232425262728293031323334353637383940 //将m的Folders交接给本类对象 //并且实现Folders和本类对象的关联 //接触Folders和m的关联void Message::move_Folders(Message *m)&#123; //将m的Folders交接给本对象 this-&gt;folders = m-&gt;folders; //将本对象和folders关联 for (auto f : folders) &#123; //解除folders和m的关联 f-&gt;remMsg(*m); //添加本对象和folders的关联 f-&gt;addMsg(*this); &#125; //清除m的folders m-&gt;folders.clear();&#125;//利用move_Folders函数实现移动构造函数Message::Message(Message &amp;&amp;m) : contents(std::move(m.contents))&#123; move_Folders(&amp;m);&#125;Message &amp;Message::operator=(Message &amp;&amp;m)&#123; if (this != &amp;m) &#123; remove_from_Folders(); contents = std::move(m.contents); move_Folders(&amp;m); &#125; return *this;&#125;void Message::printMsg()&#123; cout &lt;&lt; &quot;contents is &quot; &lt;&lt; contents &lt;&lt; endl;ss&#125; 接下来在主函数中调用如下函数。 12345678auto msg4 = new Message(&quot;msg4&quot;);msg4-&gt;printMsg();auto msg3 = new Message(&quot;msg3&quot;);msg3-&gt;printMsg();*msg4 = std::move(*msg3);msg4-&gt;printMsg();delete msg4;delete msg3; 可以看到在调用move之后msg4输出的内容变为msg3，我们的移动操作是成功的。 总结本文通过移动操作移动赋值实现了移动构造函数，以及其注意事项。源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 动态内存管理示例","date":"2022-02-09T02:45:54.000Z","path":"2022/02/09/cpp29/","text":"动态内存管理之前我们讲述过动态内存的开辟，可以通过new, malloc，以及alloc等方式，本文通过介绍alloc方式，构造一个StrVec类，这个类的功能类似于一个vector，实现字符串的管理，其中包含push一个字符串，动态扩容，析构，回收内存等操作。 StrVec类实现细节StrVec类实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class StrVec&#123;public: //无参构造函数 StrVec() : elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125; //拷贝构造函数 StrVec(const StrVec &amp;); //拷贝赋值运算符 StrVec &amp;operator=(const StrVec &amp;); //析构函数 ~StrVec(); //拷贝元素 void push_back(const std::string &amp;); //返回元素个数 size_t size() const &#123; return first_free - elements; &#125; //返回总容量 size_t capacity() const &#123; return cap - elements; &#125; //返回首元素地址 std::string *begin() const &#123; return elements; &#125; //返回第一个空闲元素地址 //也是最后一个有效元素的下一个位置 std::string *end() const &#123; return first_free; &#125;private: //判断容量不足开辟新空间 void chk_n_alloc() &#123; if (size() == capacity()) reallocate(); &#125; //重新开辟空间 void reallocate(); // copy指定范围的元素到新的内存中 std::pair&lt;std::string *, std::string *&gt; alloc_n_copy( const std::string *, const std::string *); //释放空间 void free(); //数组首元素的指针 std::string *elements; //指向数组第一个空闲元素的指针 std::string *first_free; //指向数组尾后位置的指针 std::string *cap; //构造string类型allocator静态成员 static std::allocator&lt;std::string&gt; alloc;&#125;; 1 elements成员，该成员指向StrVec内部数组空间的第一个元素2 first_free成员指向第一个空闲元素，也就是有效元素的下一个元素，该元素开辟空间但未构造。3 cap 指向最后一个元素的下一个位置。4 alloc为静态成员，主要负责string类型数组的开辟工作。5 无参构造函数将三个指针初始化为空，并且默认够早了alloc。6 alloc_n_copy私有函数的功能是将一段区域的数据copy到新的空间，并且返回新开辟的空间地址以及第一个空闲元素的地址(第一个未构造元素的地址)。7 chk_n_alloc私有函数检测数组大小是否达到容量，如果达到则调用reallocate重新开辟空间。8 reallocate重新开辟空间9 capacity返回总容量10 size返回元素个数11 push_back 将元素放入开辟的类似于数组的连续空间中。12 begin返回首元素地址13 end返回第一个空闲元素地址,也是最后一个有效元素的下一个位置无论我们实现push操作还是拷贝构造操作，都要实现realloc，当空间不足时要开辟空间将旧数据移动到新的数据 1234567891011121314151617181920212223242526272829303132333435//重新开辟空间void StrVec::reallocate()&#123; string *newdata = nullptr; //数组为空的情况 if (elements == nullptr || cap == nullptr || first_free == nullptr) &#123; newdata = alloc.allocate(1); // elements和first_free都指向首元素 elements = newdata; first_free = newdata; // cap指向数组尾元素的下一个位置。 cap = newdata + 1; return; &#125; //不为空则扩充两倍空间 newdata = alloc.allocate(size() * 2); //新内存空闲位置 auto dest = newdata; //旧内存有效位置 auto src = elements; //通过移动操作将旧数据放到新内存中 for (size_t i = 0; i != size(); ++i) &#123; alloc.construct(dest++, std::move(*src++)); &#125; //移动后旧内存数据无效，一定要删除 free(); //更新数据位置 elements = newdata; //更新第一个空闲位置 first_free = dest; //更新容量 cap = elements + size() * 2;&#125; reallocate函数内部判断是否为刚初始化指针却没开辟空间的空数组，如果是则开辟1个大小的空间。否则则开辟原有空间的两倍，将旧数据移动到新空间，采用了std::move操作，这么做减少拷贝造成的性能开销。move之后原数据就无效了，所以要调用私有函数free()进行释放。我们实现该free操作 12345678910111213141516171819//释放操作void StrVec::free()&#123; //判断elements是否为空 if (elements == nullptr) &#123; return; &#125; auto dest = elements; //要先遍历析构每一个对象 for (size_t i = 0; i &lt; size(); i++) &#123; // destroy会调用每一个元素的析构函数 alloc.destroy(dest++); &#125; //再整体回收内存 alloc.deallocate(elements, cap - elements);&#125; 先通过遍历destroy销毁内存，从而调用string的析构函数，最后在deallocate回收内存。 123456789// copy指定范围的元素到新的内存中,返回新元素的地址和第一个空闲元素地址的pairstd::pair&lt;std::string *, std::string *&gt; StrVec::alloc_n_copy( const std::string *b, const std::string *e)&#123; auto newdata = alloc.allocate(e - b); //将原数据用来初始化新空间 auto first_free = uninitialized_copy(b, e, newdata); return &#123;newdata, first_free&#125;;&#125; 这样利用alloc_n_copy，我们就可以实现拷贝构造和拷贝赋值了 12345678910//拷贝构造函数StrVec::StrVec(const StrVec &amp;strtmp)&#123; //将形参数据拷贝给自己 auto rsp = alloc_n_copy(strtmp.begin(), strtmp.end()); //更新elements, cap，first_free elements = rsp.first; first_free = rsp.second; cap = rsp.second;&#125; 但是拷贝赋值要注意一点，就是自赋值的情况，所以我们提前判断是否为自赋值，如不是则进行和拷贝构造相同的操作 123456789101112131415//拷贝赋值运算符StrVec &amp;StrVec::operator=(const StrVec &amp;strtmp)&#123; //防止自赋值 if (this == &amp;strtmp) &#123; return *this; &#125; //将形参数据拷贝给自己 auto rsp = alloc_n_copy(strtmp.begin(), strtmp.end()); //更新elements, cap，first_free elements = rsp.first; first_free = rsp.second; cap = rsp.second;&#125; 我们可以利用free实现析构函数 12345//析构StrVec::~StrVec()&#123; free();&#125; 接下来我们实现push_back，将指定字符串添加到数组空间,以及抛出元素 12345678910111213141516171819202122232425262728//添加元素void StrVec::push_back(const std::string &amp;s)&#123; chk_n_alloc(); alloc.construct(first_free++, s);&#125;//抛出元素void StrVec::pop_back(std::string &amp;s)&#123; if (first_free == nullptr) &#123; return; &#125; if (size() == 1) &#123; s = *elements; alloc.destroy(elements); first_free = nullptr; elements = nullptr; return; &#125; s = *(--first_free); alloc.destroy(first_free);&#125; 接下来实现测试函数，测试上述操作 12345678910void test_strvec()&#123; auto str1 = StrVec(); str1.push_back(&quot;hello zack&quot;); StrVec str2(str1); str2.push_back(&quot;hello rolin&quot;); StrVec str3 = str1; string strtmp; str3.pop_back(strtmp);&#125; 在主函数调用上面test_strvec，运行稳定。 总结本文通过allocator实现了一个类似于vector的类，管理string变量。演示了拷贝构造，拷贝赋值要注意的事项，同时演示了如何手动开辟内存并管理内存空间。源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++类的拷贝控制demo","date":"2022-02-07T02:18:25.000Z","path":"2022/02/07/cpp28/","text":"拷贝控制有时候我们需要两个类对象互相关联，当其中一个对象修改后也要关联修改另一个，用这个例子说明拷贝控制的案例。我们有两个类，Message类表示信息类，Folder类表示文件夹类，Message类里有成员folders表示其所属于哪些文件夹。Folder类有成员messages表示其包含哪些messages，所以Folder和Message之间是互相包含，多对多的关系。同时我们要考虑Message类的拷贝，赋值，销毁等操作，如何同步处理其关联的Folder类。 其关系图是这样的 12345678910111213141516171819202122232425262728class Message&#123; friend class Folder;public: // folder被隐式初始化为空集合 explicit Message(const std::string &amp;str = &quot;&quot;) : contents(str) &#123;&#125; // 拷贝控制成员，用来管理指向本Message的指针 Message(const Message &amp;); // 拷贝赋值运算符 Message &amp;operator=(const Message &amp;); //析构函数 ~Message(); //将Message保存在指定Folder中 void save(Folder &amp;); //从Folder中删除Message void remove(Folder &amp;);private: // 消息内容 std::string contents; // 消息所属文件夹 std::set&lt;Folder *&gt; folders; //将本Message添加到参数msg的folder中 void add_to_Folders(const Message &amp;msg); //从folders中的每个Folder删除本Message void remove_from_Folders();&#125;; Message类定义了构造函数，默认将本Message所属的Folder集合设置为空。同时提供了save和remove操作，将本Message保存给指定Folder以及从指定Folder中删除。两个私有函数在很多地方通用，所以提出来作为私有函数。同样我们声明Folder类 1234567891011121314151617181920212223class Folder&#123; friend class Message;public: explicit Folder(const std::string &amp;nm = &quot;&quot;) : name(nm) &#123;&#125; //拷贝控制成员 Folder(const Folder &amp;); //拷贝赋值运算符 Folder &amp;operator=(const Folder &amp;); //析构函数 ~Folder(); //保存指定的msg void addMsg(Message &amp;); //移除指定的msg void remMsg(Message &amp;);private: //文件夹名字 std::string name; //包含的消息列表 std::unordered_map&lt;std::string, Message *&gt; msgs;&#125;; 接下来我们实现Message类的添加和删除操作 123456789101112131415//将Message保存在指定Folder中void Message::save(Folder &amp;f)&#123; //将文件夹f添加到msg的folders里 this-&gt;folders.insert(&amp;f); //将本msg添加到folder中 f.addMsg(*this);&#125;//从Folder中删除Messagevoid Message::remove(Folder &amp;f)&#123; //将文件夹从msg的folders里删除 this-&gt;folders.erase(&amp;f); f.remMsg(*this);&#125; 接下来我们实现folder的addMsg和remMsg操作 12345678910//保存指定的msgvoid Folder::addMsg(Message &amp;msg)&#123; this-&gt;msgs.insert(make_pair(msg.contents, &amp;msg));&#125;//移除指定的msgvoid Folder::remMsg(Message &amp;msg)&#123; this-&gt;msgs.erase(msg.contents);&#125; 上述代码完成了msg插入folder后两个类之间的关联逻辑，当msg之间拷贝构造时需要完成folder的拷贝 12345678910111213141516//将本Message添加到参数msg的folder中void Message::add_to_Folders(const Message &amp;msg)&#123; for (auto f : msg.folders) &#123; f-&gt;addMsg(*this); &#125;&#125;//拷贝构造函数将m的folders拷贝给自己Message::Message(const Message &amp;m)&#123; contents = m.contents; folders = m.folders; add_to_Folders(m);&#125; 拷贝构造函数就是将参数message的成员拷贝给新生成的对象，然后通过add_to_Folders函数将本消息添加到m的folders中。接下来实现析构函数，message析构时将folders遍历移除本message 1234567891011121314//从folders中的每个Folder删除本Messagevoid Message::remove_from_Folders()&#123; for (auto f : folders) &#123; f-&gt;remMsg(*this); &#125;&#125;//析构函数Message::~Message()&#123; remove_from_Folders();&#125; 拷贝构造函数需要两个操作，将自身的folders中删除本msg，然后将=右侧的message的folders赋值给本msg，并且将本message添加到folders中。其实是融合了析构和拷贝构造的两个操作。 123456789// 拷贝赋值运算符Message &amp;Message::operator=(const Message &amp;msg)&#123; remove_from_Folders(); contents = msg.contents; folders = msg.folders; add_to_Folders(msg); return *this;&#125; 在有些时候会用到swap操作，比如sort排序等，我们也实现一个Message版本的swap 1234567891011121314void swap(Message &amp;lhs, Message &amp;rhs)&#123; //将lhs从关联的folders中移除 lhs.remove_from_Folders(); //将rhs从关联的folders中移除 rhs.remove_from_Folders(); //交换两个成员 swap(lhs.contents, rhs.contents); swap(lhs.folders, rhs.folders); //重新将lhs添加到关联的folders中 lhs.add_to_Folders(lhs); //重新将rhs添加到关联的folders中 rhs.add_to_Folders(rhs);&#125; 同样的道理，为实现folders的拷贝构造我单独实现一个私有函数add_msgs，将其 1234567891011121314151617// 将f中的msgs添加到本folder中void Folder::add_msgs(const Folder &amp;f)&#123; //将f的msgs添加到本folder for (auto mp : f.msgs) &#123; //将消息保存在本folder mp.second-&gt;save(*this); &#125;&#125;Folder::Folder(const Folder &amp;f)&#123; this-&gt;msgs = f.msgs; this-&gt;name = f.name; add_msgs(f);&#125; 实现folders的析构函数,同样我也实现了一个私有函数remove_msgs 12345678910111213141516//删除folder中的所有msgsvoid Folder::remove_msgs()&#123; for (auto msgit = this-&gt;msgs.begin(); msgit != this-&gt;msgs.end();) &#123; msgit-&gt;second-&gt;folders.erase(this); msgit = this-&gt;msgs.erase(msgit); &#125;&#125;//析构函数Folder::~Folder()&#123; remove_msgs(); msgs.clear();&#125; 同样道理拷贝赋值运算符的重载逻辑是拷贝构造和析构的综合 1234567891011//拷贝赋值运算符Folder &amp;Folder::operator=(const Folder &amp;f)&#123; // 先从本folder的msg解除和本folder的关联 remove_msgs(); //再将f的参数赋值给本folder this-&gt;name = f.name; this-&gt;msgs = f.msgs; //将msgs添加到本folder add_msgs(f);&#125; 同样我们实现Folder的swap函数 12345678910111213void swap(Folder &amp;lf, Folder &amp;rf)&#123; //先解除lf的msg和其的联系 lf.remove_msgs(); //再解除rf的msg和其的联系 rf.remove_msgs(); //交换数据结构 swap(lf.msgs, rf.msgs); swap(lf.name, rf.name); //最后各自绑定msg和其folder的联系 lf.add_msgs(lf); rf.add_msgs(rf);&#125; 接下来我们写一个函数测试上述赋值，析构，构造是否存在问题 1234567891011121314151617void test_msgfolder()&#123; auto f1 = new Folder(&quot;folder1&quot;); auto msg1 = new Message(&quot;msg1&quot;); msg1-&gt;save(*f1); auto f2 = new Folder(&quot;folder2&quot;); auto msg2 = new Message(&quot;msg2&quot;); msg2-&gt;save(*f2); auto f3 = new Folder(*f1); *f3 = *f2; swap(f1, f2); delete (f1); delete (msg1); delete (f2); delete (msg2); delete (f3);&#125; 上面的测试函数，创建了三个Folder对象和两个Message对象，调用了对象的拷贝构造，拷贝赋值以及析构等操作，在主函数中调用测试函数，程序运行稳定。 总结本文主要通过Folder和Message的示例，演示了拷贝构造和拷贝赋值的控制逻辑，在两个类互相引用的情况下如何保证代码高效稳定运行。源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"swap操作","date":"2022-01-28T03:12:04.000Z","path":"2022/01/28/cpp27/","text":"swap操作我们常用的交换两个数据的操作是这样 123456void swap_int(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; 主函数调用是这样的 1234int a = 100, b = 200;swap_int(a, b);cout &lt;&lt; &quot;a is &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b is &quot; &lt;&lt; b &lt;&lt; endl; 程序输出 12a is 200b is 100 可见a和b交换了，stl为我们提供了swap函数，可以交换两个对象的数据。但大部分情况还是需要我们实现自己的swap函数，比如交换两个HasPtr对象 123456789101112131415161718192021222324class HasPtr&#123;public: HasPtr() = default; HasPtr(const string &amp;str); ~HasPtr(); HasPtr(const HasPtr &amp;hp); HasPtr &amp;operator=(const HasPtr &amp;hp); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const HasPtr &amp;); friend void swap(HasPtr &amp;, HasPtr &amp;);private: string *m_str; int m_index; static int _curnum;&#125;;void swap(HasPtr &amp;hptr1, HasPtr &amp;hptr2)&#123; using std::swap; swap(hptr1.m_index, hptr2.m_index); swap(hptr1.m_str, hptr2.m_str);&#125; 我们在类的声明里添加了swap友元函数。然后利用了stl的swap函数完成了类内部成员的交换。交换后两个类的m_str指针指向交换了。有了我们自己实现的swap函数，就可以简化之前的赋值运算符了。但是我们要注释掉原来版本实现的operator = ，实现新版本的 12345678HasPtr &amp;HasPtr::operator=(HasPtr hptr)&#123; // hptr是一个局部变量 //交换后hptr.m_str指向this.m_str原来指向的内存 swap(*this, hptr); // return返回*this后，hptr自动被回收 return *this;&#125; 新版本的operator=参数为HasPtr类型，而不是引用类型，这样hptr是赋值运算符右侧变量的副本，而函数内部通过swap交换this和hptr的数据和成员，最后返回*this。随着函数返回，那么形参也就会自动销毁了，这么做的好处是代码简洁，并且不用考虑自赋值的情况。 总结本文介绍了swap操作，合理利用swap，并为类实现swap操作，可以简化我们的操作。当我们要实现sort等排序操作，内部会用到交换逻辑，如果想实现定制化的swap就需要为类实现swap函数。https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"拷贝控制和资源管理","date":"2022-01-27T03:07:00.000Z","path":"2022/01/27/cpp26/","text":"拷贝控制前文我们介绍了HasPtr类的拷贝控制，实现了行为像值的类，所谓行为像值的类就是我们所说的深拷贝，将一个类对象拷贝给另一个类对象时，其所有的成员都作为副本在新的类对象创建一遍，如果是指针类型的成员，则将指针指向的空间的数据复制一份给新对象，这样两个对象所有的成员都不关联，实现了深拷贝，不会受彼此影响。比如之前的HasPtr的拷贝构造 12345678910111213HasPtr::HasPtr(const HasPtr &amp;hp)&#123; cout &lt;&lt; &quot;this is copy construtor&quot; &lt;&lt; endl; if (&amp;hp != this) &#123; this-&gt;m_str = new string(string(*hp.m_str)); int seconds = time((time_t *)NULL); _curnum++; this-&gt;m_index = _curnum; &#125; return;&#125; 下面我们介绍另一只拷贝控制，行为类似于指针的类，所谓行为类似于指针的类就是在类对象进行拷贝构造时，如果有指针成员，则浅拷贝，将指针的值赋值给新的对象，这两个对象共享同一个指针成员的指针。我们同样实现另一个类SharePtr类，其内部有一个指针成员ps，现在我们实现这样的需求，多个SharePtr之间拷贝构造或者赋值，将ps做浅拷贝，也就是直接赋值给新对象，当所有SharePtr对象销毁后，才销毁成员ps。简单来讲，SharePtr的声明如下 123456789101112131415class SharePtr&#123;public: //构造函数根据字符串值构造一个字符串指针，并且初始化引用计数为1 SharePtr(const std::string str = &quot;&quot;) : pstr(new string(str)), usecount(new size_t(1)) &#123;&#125; SharePtr(const SharePtr &amp;sptr); SharePtr &amp;operator=(const SharePtr &amp;sptr);private: //共享的字符串指针 string *pstr; //引用计数 size_t *usecount;&#125;; usecount用来管理引用计数，表示多少个SharePtr类对象共享字符串指针。pstr字符串指针，在SharePtr对象拷贝构造和赋值等操作时，将pstr赋值给新对象，实现浅拷贝。接下来我们实现拷贝构造和拷贝赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344SharePtr &amp;SharePtr::operator=(const SharePtr &amp;sptr)&#123; //如果是自赋值则跳过 if (&amp;sptr == this) &#123; return *this; &#125; //减少自己原来的引用计数 (*this-&gt;usecount)--; //判断引用计数是否为0 if (*(this-&gt;usecount) == 0) &#123; //回收原来指向的内存 delete (this-&gt;pstr); //回收引用计数内存 delete (this-&gt;usecount); &#125; //其他类对象拷贝给自己 this-&gt;pstr = sptr.pstr; //对方引用计数增加 (*sptr.usecount)++; //拷贝对方的引用计数给自己 this-&gt;usecount = sptr.usecount; return *this;&#125;SharePtr::SharePtr(const SharePtr &amp;sptr)&#123; //如果是自赋值则跳过 if (&amp;sptr == this) &#123; return; &#125; //其他类对象拷贝给自己 this-&gt;pstr = sptr.pstr; //引用计数增加 (*sptr.usecount)++; //拷贝对方的引用计数给自己 this-&gt;usecount = sptr.usecount;&#125; 实现了拷贝构造和拷贝赋值，首先都要判断是否是自拷贝或者自赋值，如果不是自拷贝，那就将对方的引用计数增加1并且赋值给自己。对于赋值运算，先将自己原来指向的引用计数-1，如果引用计数为0则回收原来开辟的内存。然后将被拷贝的对象引用计数+1,然后赋值给自己。对于析构函数，先减少引用计数，如果引用计数为0则回收内存 1234567891011121314SharePtr::~SharePtr()&#123; //引用计数-1 (*this-&gt;usecount)--; //引用计数为0，销毁内存 if (*(this-&gt;usecount) == 0) &#123; cout &lt;&lt; &quot;use count is 0 dealloc&quot; &lt;&lt; endl; delete usecount; delete pstr; return; &#125;&#125; 接下来我们实现一个打印引用计数的函数，一个测试函数 12345678910111213141516171819202122232425//获取引用计数size_t SharePtr::getUseCount()&#123; return *(this-&gt;usecount);&#125;void test_share()&#123; SharePtr sptr1(&quot;hello zack&quot;); SharePtr sptr2(sptr1); cout &lt;&lt; &quot;sptr1 use count is &quot; &lt;&lt; sptr1.getUseCount() &lt;&lt; endl; cout &lt;&lt; &quot;sptr2 use count is &quot; &lt;&lt; sptr2.getUseCount() &lt;&lt; endl; SharePtr sptr3(&quot;hello world&quot;); cout &lt;&lt; &quot;sptr3 use count is &quot; &lt;&lt; sptr3.getUseCount() &lt;&lt; endl; sptr2 = sptr3; cout &lt;&lt; &quot;sptr1 use count is &quot; &lt;&lt; sptr1.getUseCount() &lt;&lt; endl; cout &lt;&lt; &quot;sptr2 use count is &quot; &lt;&lt; sptr2.getUseCount() &lt;&lt; endl; cout &lt;&lt; &quot;sptr3 use count is &quot; &lt;&lt; sptr3.getUseCount() &lt;&lt; endl;&#125; 在主函数中调用test_share结果输出如下 12345678sptr1 use count is 2sptr2 use count is 2sptr3 use count is 1sptr1 use count is 1sptr2 use count is 2sptr3 use count is 2use count is 0 deallocuse count is 0 dealloc 因为我们只开辟了两份对象，sptr1和sptr3,所以最后会回收两个对象。sptr2是拷贝构造生成的，共享了sptr1的数据。可以看到拷贝赋值减少了=左边的引用计数，增加了=右边的引用计数。拷贝构造增加了引用计数，两个对象都共享一套数据。 总结这个例子实现了类指针行为的类SharePtr，其行为很像智能指针，只不过智能指针通过模板实现了泛型而已。所以通过这个例子我们可以理解智能指针的工作原理和内部实现了。源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 拷贝构造 赋值 和析构","date":"2022-01-24T06:20:56.000Z","path":"2022/01/24/cpp25/","text":"拷贝构造函数一个类可以不定义拷贝构造函数，系统会默认提供一个拷贝构造函数，叫做合成拷贝构造函数。与默认构造函数不同的是，即使我们定义了其他构造函数，系统也会为我们生成合成拷贝构造函数。合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。为了方便举例，我们手动实现一个mystring类 12345678910111213class mystring_&#123;private: /* data */public: mystring_(/* args */); mystring_(const mystring_ &amp;mstr); mystring_(char *m_str); ~mystring_();private: char *m_str;&#125;; 我们为mystring_类声明了一个无参构造函数，一个拷贝构造函数，一个有参构造函数以及一个析构函数。我们实现这几个构造函数 1234567891011121314151617181920212223mystring_::mystring_(/* args */) : m_str(nullptr)&#123;&#125;mystring_::mystring_(const mystring_ &amp;mystr)&#123; if (&amp;mystr == this) &#123; return; &#125; size_t len = strlen(mystr.m_str); m_str = new char(len + 1); strcpy(m_str, mystr.m_str); m_str[len] = &#x27;\\0&#x27;;&#125;mystring_::mystring_(char *mstr)&#123; size_t len = strlen(mstr); m_str = new char(len + 1); strcpy(m_str, mstr); m_str[len] = &#x27;\\0&#x27;;&#125; 定义了无参构造函数，无参构造函数里只将m_str赋值为空指针.拷贝构造函数的参数是接受一个const mstring_ 类型的引用，内部判断是否是自己，防止循环拷贝。不是自己则将对方数据拷贝给自己。有参构造函数接受一个char* 参数，利用字符串构造mystring_ 类。我们实现一个函数测试一下构造函数是否生效 123456789101112131415extern void use_mystr();class mystring_&#123;private: /* data */public: mystring_(/* args */); mystring_(const mystring_ &amp;mstr); mystring_(char *m_str); ~mystring_(); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, mystring_ &amp;mystr1);private: char *m_str;&#125;; 我们完善了mystring_类的声明，新增了友元函数并重载&lt;&lt;运算符，输出mystring_类对象的内容。增加了全局函数use_mystr()用来测试。 123456789101112131415161718ostream &amp;operator&lt;&lt;(ostream &amp;os, mystring_ &amp;mystr1)&#123; if (mystr1.m_str == nullptr) &#123; os &lt;&lt; &quot;mystring_ data is null&quot; &lt;&lt; endl; return os; &#125; os &lt;&lt; &quot;mystring_ data is &quot; &lt;&lt; mystr1.m_str &lt;&lt; endl; return os;&#125;void use_mystr()&#123; auto mystr1 = mystring_(&quot;hello zack&quot;); auto mystr2(mystr1); auto mystr3 = mystring_(); cout &lt;&lt; mystr1 &lt;&lt; mystr2 &lt;&lt; mystr3 &lt;&lt; endl;&#125; 上述代码输出 123mystring_ data is hello zackmystring_ data is hello zackmystring_ data is null 我们先用有参构造函数构造了mystr1，然后用拷贝构造函数构造了mystr2，最后用无参构造函数构造了mystr3。 拷贝初始化当我们显示调用拷贝构造函数时会选择最合适的拷贝构造函数完成初始化，如上例中的mystr2(mystr1),我们称这种方式为直接初始化，调用拷贝构造函数完成直接初始化。还有另一种情况，就是拷贝初始化，隐式调用了拷贝构造函数。 1234567891011121314void use_mystr()&#123; //直接初始化 mystring_ mystr1(&quot;hello zack&quot;); //直接初始化 auto mystr2(mystr1); //拷贝初始化 auto mystr3 = mystr2; //拷贝初始化 mystring_ mystr4 = &quot;hello world!&quot;; //拷贝初始化 auto mystr5 = mystring_(&quot;hello everyone&quot;); cout &lt;&lt; mystr1 &lt;&lt; mystr2 &lt;&lt; mystr3 &lt;&lt; mystr4 &lt;&lt; mystr5 &lt;&lt; endl;&#125; 程序输出如下 12345mystring_ data is hello zackmystring_ data is hello zackmystring_ data is hello zackmystring_ data is hello world!mystring_ data is hello everyone 用构造函数显示指明参数构造生成的对象就是直接初始化，用赋值运算符隐式调用构造函数生成对象这种方式叫做拷贝初始化。 拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生· 将一个对象作为实参传递给一个非引用类型的形参· 从一个返回类型为非引用类型的函数返回一个对象· 用花括号列表初始化一个数组中的元素或一个聚合类中的成员. 某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。 重载赋值运算符有时我们需要重载赋值运算符达到将一个对象赋值给另一个对象的目的。如果我们不重载赋值运算符，编译器会为我们生成一个合成拷贝赋值运算符，类似默认构造函数，系统默认提供的赋值操作，但是系统默认提供的赋值操作是浅拷贝，要实现数组，指针等数据的深拷贝，需要我们手动重载实现赋值运算符。重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。 123456789101112131415class mystring_&#123;private: /* data */public: mystring_(/* args */); mystring_(const mystring_ &amp;mstr); mystring_(char *m_str); ~mystring_(); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, mystring_ &amp;mystr1); mystring_ &amp;operator=(const mystring_ &amp;mystr);private: char *m_str;&#125;; 我们再次完善类的声明，增加了operator=重载函数，该函数接受一个同类型的const mystring_ 引用对象，返回一个mystring_引用。 123456789101112mystring_ &amp;mystring_::operator=(const mystring_ &amp;mystr)&#123; if (&amp;mystr == this) &#123; return *this; &#125; size_t len = strlen(mystr.m_str); m_str = new char(len + 1); strcpy(m_str, mystr.m_str); m_str[len] = &#x27;\\0&#x27;;&#125; 同样需要判断是否为自赋值，防止进入自己赋值自己的死循环影响效率。如果不是自赋值，那就开辟空间，将m_str指向的数据拷贝过来，实现深拷贝。 析构函数析构函数用来指明类对象销毁时需要进行的回收操作。析构函数是隐式调用的，如果我们不实现析构函数，系统也会为我们实现默认的析构函数。如果一个类中有一个指针类型的成员，系统提供的默认的析构函数隐式销毁该类对象时并不会回收指针所指的空间。比如我们上面的mystring_类包含m_str成员，如果我们不实现析构函数则m_str指向的空间不会被回收。我们实现mystring_的析构函数 12345678910mystring_::~mystring_()&#123; if (m_str == nullptr) &#123; return; &#125; delete (m_str); m_str = nullptr;&#125; 如果我们定义了析构函数，那么理论上也需要实现拷贝构造和拷贝赋值操作。举个例子 123456789class HasPtr&#123;public: HasPtr(const string &amp;str); ~HasPtr();private: string *m_str;&#125;; 上面给出了HasPtr的声明，包含一个有参构造函数和一个析构函数，接下来给出实现 12345678910HasPtr::HasPtr(const string &amp;str) : m_str(new string(str)) &#123;&#125;HasPtr::~HasPtr()&#123; if (m_str != nullptr) &#123; delete m_str; m_str = nullptr; &#125;&#125; HasPtr必须要实现拷贝构造和拷贝赋值，否则会存在安全问题，看下面的例子 1234567891011HasPtr f(HasPtr hp)&#123; HasPtr copyptr = hp; return copyptr;&#125;void use_mystr()&#123; HasPtr ptr(&quot;hello zack!&quot;); f(ptr);&#125; 在主函数调用use_mystr,会引发崩溃。因为函数f的形参hp在调用结束后会被析构，而f内部将hp赋值给copystr是浅拷贝，当f调用结束copystr也会调用析构函数，这样就会double free导致崩溃。解决得办法就是为HasPtr实现拷贝赋值和拷贝构造，进行成员的深拷贝。 12345678910111213141516171819HasPtr::HasPtr(const HasPtr &amp;hp)&#123; if (&amp;hp != this) &#123; this-&gt;m_str = new string(string(*hp.m_str)); &#125; return;&#125;HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)&#123; if (&amp;hp != this) &#123; this-&gt;m_str = new string(string(*hp.m_str)); &#125; return *this;&#125; 如果我们实现了拷贝构造函数，一般来说也要实现赋值运算符。比如上面的例子HasPtr新增一个int成员index，表示唯一标识。我们通过拷贝构造构建新对象时，要单独生成唯一的index。我们先完善HasPtr声明 1234567891011121314class HasPtr&#123;public: HasPtr(const string &amp;str); ~HasPtr(); HasPtr(const HasPtr &amp;hp); HasPtr &amp;operator=(const HasPtr &amp;hp); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const HasPtr &amp;);private: string *m_str; int m_index; static int _curnum;&#125;; 我们新增了两个变量，一个m_index成员标识唯一索引，一个_curnum静态成员，用来自增生成唯一数字。我们在cpp文件中初始化类的成员变量_curnum 1int HasPtr::_curnum = 0; 然后修改几个构造函数 123456789101112131415161718HasPtr::HasPtr(const string &amp;str) : m_str(new string(str)), m_index(++_curnum)&#123; cout &lt;&lt; &quot;this is param constructor&quot; &lt;&lt; endl;&#125;HasPtr::HasPtr(const HasPtr &amp;hp)&#123; cout &lt;&lt; &quot;this is copy construtor&quot; &lt;&lt; endl; if (&amp;hp != this) &#123; this-&gt;m_str = new string(string(*hp.m_str)); int seconds = time((time_t *)NULL); _curnum++; this-&gt;m_index = _curnum; &#125; return;&#125; 然后我们在重载赋值运算符的函数里增加输出信息,再重载一个输出运算符 12345678910111213141516HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)&#123; cout &lt;&lt; &quot;this is operator = &quot; &lt;&lt; endl; if (&amp;hp != this) &#123; this-&gt;m_str = new string(string(*hp.m_str)); &#125; return *this;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;os, const HasPtr &amp;hp)&#123; os &lt;&lt; &quot;index is &quot; &lt;&lt; hp.m_index &lt;&lt; &quot; , data is &quot; &lt;&lt; *(hp.m_str) &lt;&lt; endl; return os;&#125; 在主函数中调用如下函数 123456789void use_mystr()&#123; HasPtr hasptr1(&quot;hello zack&quot;); HasPtr hasptr2(hasptr1); HasPtr hasptr3 = hasptr2; HasPtr hasptr4(&quot;hello world&quot;); hasptr4 = hasptr3; cout &lt;&lt; hasptr1 &lt;&lt; hasptr2 &lt;&lt; hasptr3 &lt;&lt; hasptr4 &lt;&lt; endl;&#125; 输出为 123456789101112this is param constructorindex is 1 , data is hello zackthis is copy construtorindex is 2 , data is hello zackthis is copy construtorindex is 3 , data is hello zackthis is param constructorthis is operator =index is 4 , data is hello zack hasptr1用的是有参构造函数，输出index为1hasptr2用的是拷贝构造函数, 输出index为2hasptr3用的是拷贝构造函数，输出index为3hasptr4用的是有参构造函数，赋值运算符。输出index为4，但是我们期望hasptr4的index为hasptr3的index值。所以要重新实现赋值运算符，这也是我要强调的，一旦我们实现了拷贝构造，就要实现重载赋值运算，避免逻辑错误。 1234567891011HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)&#123; cout &lt;&lt; &quot;this is operator = &quot; &lt;&lt; endl; if (&amp;hp != this) &#123; this-&gt;m_str = new string(string(*hp.m_str)); this-&gt;m_index = hp.m_index; &#125; return *this;&#125; 再次打印就可以看到hasptr4的index为3了，因为通过赋值运算符我们将hasptr3的index赋值给hasptr4的index了。我们可以通过default指定实现合成版本的构造函数 123456789101112131415class HasPtr&#123;public: HasPtr() = default; HasPtr(const string &amp;str); ~HasPtr(); HasPtr(const HasPtr &amp;hp); HasPtr &amp;operator=(const HasPtr &amp;hp); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const HasPtr &amp;);private: string *m_str; int m_index; static int _curnum;&#125;; delete关键字有时我们需要阻止拷贝，比如我们实现单例模式，阻止拷贝最好的方式就是使用delete关键字将拷贝构造函数和赋值运算符定义为删除函数。我们先实现单例模式，类的声明写在singleton_.h中，如下 123456789101112131415161718192021222324252627282930class Singleton_&#123;public: Singleton_(const Singleton_ &amp;) = delete; Singleton_ &amp;operator=(const Singleton_ &amp;) = delete; static shared_ptr&lt;Singleton_&gt; &amp;getinstance() &#123; //如果非空直接返回不加锁节省效率 if (_inst != nullptr) &#123; return _inst; &#125; //最好做一个二次判断 _mutex.lock(); if (_inst != nullptr) &#123; _mutex.unlock(); return _inst; &#125; _inst = shared_ptr&lt;Singleton_&gt;(new Singleton_()); _mutex.unlock(); return _inst; &#125;private: Singleton_() &#123;&#125; static shared_ptr&lt;Singleton_&gt; _inst; static mutex _mutex;&#125;; 我们将Singleton_的拷贝构造函数和赋值操作声明为delete，这样就防止了拷贝和赋值操作。我们将Singleton_的构造函数声明为私有，这样就可以避免外部显示调用构造函数。要想创建Singleton_的对象必须调用getinstance函数，该函数内部先判断_inst是否为空指针，如果不是空指针则直接返回_inst即可。这么做减少了加锁的开销。如果_inst为空，则加锁并进入构建_inst的逻辑，在构建之前又判断了一下_inst是否为空，不为空则直接返回。这么做主要是稳妥一点，防止在lock之前有其他线程已经创建了_inst，因为在第一次判断_inst是否为空和_mutex.lock()之间还是有一定时间空隙的。我们构建_inst的方式是显示调用new Singleton_()来初始化智能指针，而不是 1_inst = make_shared&lt;Singleton_&gt;(); 因为make_shared会间接调用Singleton_的构造函数，而Singleton_构造函数是私有的，所以会报错。所以显示调用new Singleton_()初始化智能指针，因为是在类的成员函数getinstance里调用，所以可以访问私有构造函数。在类的声明里_inst和_mutex是类的静态变量，类的静态变量初始化是放在cpp文件中的，不然会出现重复定义的错误。我们在singleton_.cpp文件中初始化这两个变量 12shared_ptr&lt;Singleton_&gt; Singleton_::_inst = nullptr;mutex Singleton_::_mutex; 我们先测试单线程情况下单例是否正常 12345678void test_single()&#123; shared_ptr&lt;Singleton_&gt; inst1 = Singleton_::getinstance(); cout &lt;&lt; &quot;inst1 get ptr is &quot; &lt;&lt; inst1.get() &lt;&lt; endl; shared_ptr&lt;Singleton_&gt; inst2 = Singleton_::getinstance(); cout &lt;&lt; &quot;inst2 get ptr is &quot; &lt;&lt; inst2.get() &lt;&lt; endl;&#125; 程序输出 12inst1 get ptr is 0xfa4150inst2 get ptr is 0xfa4150 再测试下多线程的情况下 12345678910111213141516void thread_func(int i)&#123; cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; i &lt;&lt; endl; shared_ptr&lt;Singleton_&gt; inst = Singleton_::getinstance(); cout &lt;&lt; &quot;inst ptr is &quot; &lt;&lt; inst.get() &lt;&lt; endl;&#125;void test_thread_single()&#123; for (int i = 0; i &lt; 3; i++) &#123; thread tid(thread_func, i + 1); tid.join(); &#125; cout &lt;&lt; &quot;main thread exit &quot; &lt;&lt; endl;&#125; 程序输出 1234567this is thread 1inst ptr is 0x10c4dc0this is thread 2inst ptr is 0x10c4dc0this is thread 3inst ptr is 0x10c4dc0main thread exit tid.join是让线程阻塞执行结束后再进行下一轮逻辑，所以会陆续输出线程id和指针地址。我们能看到无论多线程还是单线程，打印的inst的地址都是相同的，可见单例实现正确。以后我们可以用模板实现一个更广范围的单例模式，这个例子只是为了说明将一些构造函数声明为delete的作用。但是请记住，析构函数不能声明为delete，如果析构函数被删除，就无法销毁此类型的对象了。对于类中包含const成员，引用成员的类，系统不会为其生成默认的拷贝构造和默认的拷贝赋值。 总结本文介绍了拷贝构造函数，构造函数以及析构函数等用法，介绍了使用default和delete来管理构造函数等方式，最后利用C11智能指针实现了单例类源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"文本查询程序","date":"2022-01-21T06:30:17.000Z","path":"2022/01/21/cpp24/","text":"简介本篇利用之前介绍的智能指针，关联容器，顺序容器等知识，做一个文本查询程序。该程序读取文本中的内容，然后根据输入的单词，判断该单词出现多少次，出现在哪些行，每行的句子是什么。比如我们输入elment，输出如下 123456element occurs 112 times(line 36) A set element contains only a key;(line 158) operator creates a new element(line 160) Regardless of whether the element(line 168) When we fetch an element from a map,we(line 214) If the element is not found,find returns 需求分析1 我们需要实现一个TextQuery类，将文件的内容按照一行一行放入vector中，vector每个元素就是这一行的内容。2 将每一行的内容按照单词分割，构造一个map，单词作为key，行号放入set，set作为value 。这样可以根据单词找到行号的set。3 根据输入单词查找其出现的次数和行号，将结果作为一个类QueryResult返回。所以当我们实现完成后其调用逻辑类似如下 123456789101112131415void runQueries(ifstream &amp;infile)&#123; //根据输入文件构建一个TextQuery对象 TextQuery tq(infile); //根据输入的单词返回查询结果 while (true) &#123; cout &lt;&lt; &quot;enter word to look for, or q to quit&quot; &lt;&lt; endl; //输入单词查询结果，或者输入q退出循环,或者遇到终止退出。 string s; if (!(cin &gt;&gt; s) || s == &quot;q&quot;) break; print(cout, tq.query(s)) &lt;&lt; endl; &#125;&#125; 实现TextQuery类12345678910111213class QueryResult;class TextQuery&#123;public: using line_no = std::vector&lt;string&gt;::size_type; TextQuery(ifstream &amp;ifile); TextQuery() = default; QueryResult query(const string &amp;str) const;private: shared_ptr&lt;vector&lt;string&gt;&gt; file; map&lt;string, shared_ptr&lt;set&lt;line_no&gt;&gt;&gt; wm;&#125;; TextQuery声明了基于ifstream的构造函数和一个默认构造函数,同时定义了query查询函数，将查询的结果写入QueryResult类对象。file是一个智能指针，指向一个vector，vector保存了读取文件后每行的内容。wm是一个map，key为文件中出现的单词，value是一个智能指针，指向该单词出现的行号set。接下来我们声明QueryResult类 123456789101112131415class QueryResult&#123;public: friend std::ostream &amp;print(std::ostream &amp;os, const QueryResult &amp;qr); QueryResult(std::string s, shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; p, shared_ptr&lt;vector&lt;string&gt;&gt; f) : sought(s), lines(p), file(f) &#123;&#125;private: //查询的单词 std::string sought; //出现的行号 shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; lines; //输入的文件 shared_ptr&lt;vector&lt;string&gt;&gt; file;&#125;; QueryResult构造函数接受三个参数，分别是查询的单词，单词出现的行号set的指针，以及我们读取文件保存内容的vector的指针。我们现实TextQuery的构造函数 123456789101112131415161718192021222324252627TextQuery::TextQuery(ifstream &amp;infile) : file(make_shared&lt;vector&lt;string&gt;&gt;())&#123; string text; //按行读取文件内容写入text while (getline(infile, text)) &#123; //将一行的内容写入vector file中 file-&gt;push_back(text); //统计行号，vector的大小-1就是行号 int n = file-&gt;size() - 1; //将字符串构造为string流 istringstream line(text); string word; //将字符串中的单词依次写入word while (line &gt;&gt; word) &#123; auto &amp;lineset = wm[word]; //如果单词不在wm中，返回的就是空指针 if (!lineset) &#123; //重新构造一个set，让智能指针绑定他 lineset.reset(new set&lt;line_no&gt;()); &#125; lineset-&gt;insert(n); &#125; &#125;&#125; 构造函数读取文件，将内容写入file中，file是一个vector指针，保存了文件中每行的内容。然后分割每行字符串，将单词和其出现的行号写入wm中。wm是一个map，key就是统计的单词，value就是set的指针，set保存了该单词出现的行号序列。接下来我们实现query查询函数 12345678910111213QueryResult TextQuery::query(const string &amp;str) const&#123; //根据单词去map中查找 auto findval = wm.find(str); //构造一个指向空的set的指针 static auto nodata = make_shared&lt;set&lt;line_no&gt;&gt;(); if (findval == wm.end()) &#123; return QueryResult(str, nodata, file); &#125; return QueryResult(str, findval-&gt;second, file);&#125; 查询函数返回QueryResult对象，根据查找结果，如果找到就返回对应的行号列表等信息，否则就返回一个空行号列表。最后我们实现print函数，打印查询结果 1234567891011std::ostream &amp;print(std::ostream &amp;os, const QueryResult &amp;qr)&#123; //依次输出单词，出现次数 os &lt;&lt; qr.sought &lt;&lt; &quot; occurs &quot; &lt;&lt; qr.lines-&gt;size() &lt;&lt; &quot; times&quot; &lt;&lt; endl; //打印出现的每一行 for (auto num : *(qr.lines)) &#123; os &lt;&lt; &quot;\\t line( &quot; &lt;&lt; num + 1 &lt;&lt; &quot; ) &quot; &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; endl; &#125; return os;&#125; 测试我们新建一个文本text_query.txt，内容如下 1234hello zack !!zack , no matter where are ui am here waiting for you good luck zack 然后我们在主函数中调用之前写好的runQueries函数 12std::ifstream file(&quot;./config/text_query.txt&quot;);runQueries(file); 程序运行后会提示我们输入单词，我们输入zack，会看到输出信息如下 12345678enter word to look for, or q to quitzackzack occurs 3 times line( 1 ) hello zack !! line( 2 ) zack , no matter where are u line( 4 ) good luck zackenter word to look for, or q to quit 总结这一篇demo主要是复习之前学习的智能指针和容器的知识，通过综合运用，实现了一个文本查询功能的程序。接下来的内容更精彩。源码链接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 动态数组","date":"2022-01-20T02:51:31.000Z","path":"2022/01/20/cpp23/","text":"C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。 new和数组为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针： 123456789101112131415int get_size_new()&#123; return 42;&#125;void new_array()&#123; int *p_array = new int[get_size_new()](); for (int i = 0; i &lt; get_size_new(); i++) &#123; cout &lt;&lt; *(p_array + i) &lt;&lt; &quot; &quot;; &#125; delete[] p_array; cout &lt;&lt; endl;&#125; 在main函数中调用new_array会输出42个0,因为new 分配的数组初始值都为0。为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对.方括号中的大小必须是整型，但不必是常量。也可以用一个表示数组类型的类型别名，来分配一个数组，这样，new表达式中就不需要方括号了： 12345678void new_array()&#123; //定义数组类型 typedef int array_type[10]; //动态开辟数组空间 int *p_array = new (array_type); delete[] p_array;&#125; 虽然我们通常称new T[]分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。new返回的是一个元素类型的指针。由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。要记住我们所说的动态数组并不是数组类型，这是很重要的。可以通过{}初始化动态数组 1234567void new_array()&#123; //通过&#123;&#125;初始化动态数组 int *p_array = new int[10]&#123;1, 2, 3, 4&#125;; //释放动态数组 delete[] p_array;&#125; 如果{}初始化列表小于数组长度，则默认补充空值，int补充0，string补充空字符串。动态分配一个大小为0的数组是合法的 123456789101112void new_array()&#123; int n = 0; //开辟一个大小为0的数组 int *p_array = new int[n]; for (int *p = p_array; p != n + p_array; p++) &#123; cout &lt;&lt; *p &lt;&lt; &quot; &quot;; &#125; delete[] p_array;&#125; 当n为0时，开辟了一个长度为0的动态数组，因为循环条件p != n+p_array，所以不会进入循环。当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。 智能指针和动态数组标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号： 1234567void unique_array()&#123; //开辟一个20个整形的动态数组，用unique_ptr管理它。 auto unarray = unique_ptr&lt;int[]&gt;(new int[20]); //释放这个动态数组 unarray.release();&#125; 类型说明符中的方括号&lt;int[]&gt;指出up指向一个int数组而不是一个int。由于unarray指向一个数组，当unarray销毁它管理的指针时，会自动使用delete[]。当一个unique_ptr指向一个数组时，我们可以使用下标运算符来访问数组中的元素： 1234567891011121314void unique_array()&#123; //开辟一个20个整形的动态数组，用unique_ptr管理它。 auto unarray = unique_ptr&lt;int[]&gt;(new int[20]); //可以通过下标访问数组元素 for (size_t i = 0; i &lt; 10; i++) &#123; unarray[i] = 1024; &#125; //释放这个动态数组 unarray.release();&#125; shared_ptr也可以管理动态数组，这一点在C++ primer 第5版里没有提及，但是我自己测试好用 1234567891011void shared_array()&#123; // 开辟一个5个整形的动态数组，用shared_ptr管理它 auto sharray = shared_ptr&lt;int[]&gt;(new int[5]&#123;1, 2, 3, 4, 5&#125;); for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; sharray[i] &lt;&lt; &quot; &quot;; &#125; sharray.reset(); cout &lt;&lt; endl;&#125; C++ primer 第5版推荐的用法如下 123456void use_shared_array()&#123; shared_ptr&lt;int&gt; sharray = shared_ptr&lt;int&gt;(new int[5], [](int *p) &#123; delete[] p; &#125;); sharray.reset();&#125; 上例中，shared_ptr管理一个动态数组并提供了删除器。 allocator类当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。 类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置： 123456789void use_allocator()&#123; allocator&lt;string&gt; alloc; // allocator分配5个string类型对象的空间 // 这些空间未构造 auto const p = alloc.allocate(5); //销毁开辟的空间 alloc.deallocate(p, 5);&#125; 上述代码用allocator构造alloc对象，说明开辟的空间是为string对象准备的，然后调用allocate开辟空间，但是这些空间不能直接使用，需要调用构造函数才能使用，我们用allocator类的construct来构造对象。 1234567891011121314151617181920212223void use_allocator()&#123; allocator&lt;string&gt; alloc; // allocator分配5个string类型对象的空间 // 这些空间未构造 auto p = alloc.allocate(5); auto q = p; string str = &quot;c&quot;; for (; q != p + 5; q++) &#123; //构造字符串，每次字符串增加c字符 alloc.construct(q, str); str += &quot;c&quot;; &#125; // //打印构造的字符串列表 for (q = p; q != p + 5; q++) &#123; cout &lt;&lt; *q &lt;&lt; endl; &#125; //销毁开辟的空间 alloc.deallocate(p, 5);&#125; 循环中通过construct为每个q指向的空间构造string对象，对象的内容就是str的内容，str会随着循环每次增加c，所以上面的代码输出如下 12345ccccccccccccccc 另外stl也提供了一些拷贝和填充内存的算法 123456789101112void use_allocator()&#123; vector&lt;int&gt; ivec = &#123;1, 2, 3, 4, 5&#125;; allocator&lt;int&gt; alloc; //开辟2倍ivec大小的空间 auto p = alloc.allocate(ivec.size() * 2); //将ivec的内容copy至alloc开辟的空间里 //返回q指向剩余未构造的内存空间的起始地址 auto q = uninitialized_copy(ivec.begin(), ivec.end(), p); //将剩余元素初始化为42 uninitialized_fill_n(q, ivec.size(), 42);&#125; 通过uninitialized_copy将ivec元素拷贝到p指向的空间，同样完成了构造。uninitialized_fill_n将剩余ivec大小未构造的空间全部初始化为42。 总结本文介绍了动态数组开辟的方法，利用new关键字可以开辟动态数组，利用delete[]可以回收数组。也实现了通过shared_ptr和unique_ptr等智能指针管理动态数组的方案。最后通过列举allocator的一些方法，展示了如何实现开辟空间和构造对象分离的方式动态构造对象。源码连接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"智能指针 unique_ptr","date":"2022-01-19T02:05:23.000Z","path":"2022/01/19/cpp22/","text":"unique_ptrunique_ptr和shared_ptr不同，unique_ptr不允许所指向的内容被其他指针共享，所以unique_ptr是不允许拷贝构造和赋值的。 1234567891011void use_uniqueptr()&#123; //指向double类型的unique指针 unique_ptr&lt;double&gt; udptr; //一个指向int类型的unique指针 unique_ptr&lt;int&gt; uiptr(new int(42)); // unique不支持copy // unique_ptr&lt;int&gt; uiptr2(uiptr); // unique不支持赋值 // unique_ptr&lt;int&gt; uiptr3 = uiptr;&#125; 虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique： 123456789101112void use_uniqueptr()&#123; //定义一个upstr unique_ptr&lt;string&gt; upstr(new string(&quot;hello zack&quot;)); // upstr.release()返回其内置指针，并将upstr置空 // 用upstr返回的内置指针初始化了upstr2 unique_ptr&lt;string&gt; upstr2(upstr.release()); unique_ptr&lt;string&gt; upstr3(new string(&quot;hello world&quot;)); //将upstr3的内置指针转移给upstr2 // upstr2放弃原来的内置指针，指向upstr3返回的内置指针。 upstr2.reset(upstr3.release());&#125; unique_ptr有一个成员方法就是release，release可以返回unique_ptr的内置指针，并将unique_ptr置为空。上述代码将upstr的内置指针转移给upstr2了。同样的道理，通过reset操作, upstr2将upstr3的内置指针绑定了。release()操作提供了返回unique_ptr的内置指针的方法，但要注意release过后unique_ptr被置空，那返回的内置指针要么手动释放，要么交给其他的智能指针管理。 12345678910void use_uniqueptr()&#123; //定义一个upstr unique_ptr&lt;string&gt; upstr(new string(&quot;hello zack&quot;)); //获取upstr的内置指针 string *inerp = upstr.release(); //因为此时upstr已经通过release交出内置指针使用权 //所以要手动释放内置指针的内存 delete inerp;&#125; 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr： 1234567891011unique_ptr&lt;int&gt; clone_unique(int a)&#123; return unique_ptr&lt;int&gt;(new int(a));&#125;void use_uniqueptr()&#123; int a = 1024; unique_ptr&lt;int&gt; mp = clone_unique(a); cout &lt;&lt; *mp &lt;&lt; endl;&#125; 删除器类似shared_ptr，我们可以为unique_ptr指定删除器，但与之不同的是，为unique_ptr指定删除器时要在尖括号里指定删除器类型 123//p 指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象//它会调用一个名为fcn的delT类型对象 unique_ptr&lt;objT, delT&gt; p(new objT, fcn); 作为一个更具体的例子，我们这样演示,先定义一个unique_deleter 12345void unique_deleter(int *p)&#123; cout &lt;&lt; &quot;this is unique deleter&quot; &lt;&lt; endl; cout &lt;&lt; &quot;inner pointer data is &quot; &lt;&lt; *p &lt;&lt; endl;&#125; 再基于删除器定义一个unique_ptr 1234void use_uniqueptr()&#123; unique_ptr&lt;int, decltype(unique_deleter) *&gt; mp(new int(1024), unique_deleter);&#125; 我们在主函数调用use_uniqueptr会输出如下 12this is unique deleterinner pointer data is 1024 在本例中我们使用了decltype来指明函数指针类型。由于decltype返回一个函数类型，所以我们必须添加一个＊来指出我们正在使用该类型的一个指针。 weak_ptrweak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点。weak_ptr同样包括reset()，use_count()等方法。与shared_ptr不同的是，weak_ptr提供expired()方法，该方法在use_count为0时返回true, 否则返回false。所以可以通过expired方法去判断weak_ptr的内置指针是否被释放。weak_ptr通过lock()方法返回一个shared_ptr，shared_ptr内置指针指向的空间和weak_ptr内置指针指向相同。由于weak_ptr的弱共享特点，其内置指针可能被回收，所以当expired为true时， lock()返回一个空的shared_ptr，否则返回一个shared_ptr，该shared_ptr的内置指针与weak_ptr的内置指针指向相同。我们通过如下几个例子阐述weak_ptr的特性1 不增加shared_ptr的引用计数 123456789void use_weakptr()&#123; //构造shared_ptr auto psint = make_shared&lt;int&gt;(1024); //用shared_ptr构造weak_ptr weak_ptr&lt;int&gt; pwint(psint); //打印shared_ptr的引用计数 cout &lt;&lt; &quot;shared_ptr use count is &quot; &lt;&lt; psint.use_count() &lt;&lt; endl;&#125; 上述代码输出shared_ptr use count is 1因为weak_ptr不占用引用计数。2 通过expired判断内置指针是否被释放 123456789101112131415161718weak_ptr&lt;int&gt; clone_weakptr(int num)&#123; shared_ptr&lt;int&gt; psint(new int(num)); return weak_ptr&lt;int&gt;(psint);&#125;void use_weakptr()&#123; auto wptr = clone_weakptr(1024); if (wptr.expired()) &#123; cout &lt;&lt; &quot;wptr inner pointer has been deleted&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;wptr inner pointer data is &quot; &lt;&lt; *(wptr.lock()) &lt;&lt; endl; &#125;&#125; 在主函数中调用use_weakptr将会输出”wptr inner pointer has been deleted”。因为clone_weakptr返回的weak_ptr引用了局部变量psint，psint随着函数clone_weakptr结束而释放，所以wptr.expired()返回true3 通过lock生成shared_ptr 12345678910void use_weakptr()&#123; shared_ptr&lt;int&gt; psint(new int(1022)); //也可以通过赋值，将shared_ptr赋值给weak_ptr weak_ptr&lt;int&gt; pwint = psint; //通过weak_ptr生成shared_ptr shared_ptr&lt;int&gt; psint2 = pwint.lock(); cout &lt;&lt; &quot;psint use count is &quot; &lt;&lt; psint.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;psint2 use count is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl;&#125; 可以看到通过赋值初始化pwint，pwint.lock()返回另一个shared_ptr，这样两个shared_ptr引用计数相同，都为2.源码连接https://gitee.com/secondtonone1/cpplearn想系统学习更多C++知识,可点击下方链接。C++基础","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"智能指针shared_ptr","date":"2022-01-17T07:40:22.000Z","path":"2022/01/17/cpp21/","text":"指针C++提供了对指针操作的方法，当我们用new开辟指定类型的空间后，就生成了一个指针。 1234567void use_pointer()&#123; //开辟整形指针，指向一个值为5的元素 int *pint = new int(5); //开辟指向字符串的指针 string *pstr = new string(&quot;hello zack&quot;);&#125; 通过new + 类型构造的方式可以生成指针对象，但是开辟的指针对象所占用的空间在堆空间上。需要手动回收。可以通过delete 指针对象的方式回收 12345678910111213141516171819void use_pointer()&#123; //开辟整形指针，指向一个值为5的元素 int *pint = new int(5); //开辟指向字符串的指针 string *pstr = new string(&quot;hello zack&quot;); //释放pint指向的空间 if (pint != nullptr) &#123; delete pint; pint = nullptr; &#125; //释放指针指向的空间。 if (pstr != nullptr) &#123; delete pstr; pstr = nullptr; &#125;&#125; 通过delete 指针对象回收其指向的堆空间。为了防止double free，所以将释放后的对象分别置为nullptr。指针存在很多隐患:1 当一个函数返回局部变量的指针时，外部使用该指针可能会造成崩溃或逻辑错误。因为局部变量随着函数的右}释放了。2 如果多个指针指向同一个堆空间，其中一个释放了堆空间，使用其他的指针时会造成崩溃。3 对一个指针多次delete，会造成double free问题。4 两个类对象A和B，分别包含对方类型的指针成员，互相引用时如何释放是个问题。 所以C++提出了智能指针的用法，可以解决上述隐患。shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。 12345678910111213//我们定义一个指向整形5得指针auto psint2 = make_shared&lt;int&gt;(5);//判断智能指针是否为空if (psint2 != nullptr)&#123; cout &lt;&lt; &quot;psint2 is &quot; &lt;&lt; *psint2 &lt;&lt; endl;&#125;auto psstr2 = make_shared&lt;string&gt;(&quot;hello zack&quot;);if (psstr2 != nullptr &amp;&amp; !psstr2-&gt;empty())&#123; cout &lt;&lt; &quot;psstr2 is &quot; &lt;&lt; *psstr2 &lt;&lt; endl;&#125; 对于智能指针得使用和普通的内置指针没什么区别，通过判断指针是否为nullptr可以判断是否为空指针。通过-&gt;可以取指针内部得成员方法或者成员变量。make_shared函数将参数为对象类型的构造函数的参数，将此参数传递给模板中得对象类型的构造函数，从而构造出对象类型得智能指针，节省了对象在函数传递得开销。当我们需要获取内置类型时，可以通过智能指针的方法get()返回其底层的内置指针。 12int *pint = psint2.get();cout &lt;&lt; &quot;*pint is &quot; &lt;&lt; *pint &lt;&lt; endl; 不要手动回收智能指针get返回的内置指针，要交给智能指针自己回收即可，否则会造成double free或者 使用智能指针产生崩溃等问题。也不要用get()返回得内置指针初始化另一个智能指针，因为两个智能指针引用一个内置指针会出现问题，比如一个释放了另一个不知道就会导致崩溃等问题。shared_ptr会根据引用计数管理内置指针，当引用计数为0时就自动删除内置指针。当将一个智能指针p赋值给另一个智能指针q时，p引用计数就-1，q引用计数就+1 123456789101112131415161718void use_sharedptr()&#123; //我们定义一个指向整形5得指针 auto psint2 = make_shared&lt;int&gt;(5); auto psstr2 = make_shared&lt;string&gt;(&quot;hello zack&quot;); //将psint2赋值给psint3,他们底层的内置指针相同 // psint3和psint2引用计数相同，引用计数+1，都为2 shared_ptr&lt;int&gt; psint3 = psint2; //打印引用计数 cout &lt;&lt; &quot;psint2 usecount is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;psint3 usecount is &quot; &lt;&lt; psint3.use_count() &lt;&lt; endl; // psint3引用计数为1 psint3 = make_shared&lt;int&gt;(1024); // psint2引用计数-1，变为1 //打印引用计数 cout &lt;&lt; &quot;psint2 usecount is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;psint3 usecount is &quot; &lt;&lt; psint3.use_count() &lt;&lt; endl;&#125; 程序输出 1234psint2 usecount is 2psint3 usecount is 2psint2 usecount is 1psint3 usecount is 1 可以利用shared_ptr实现数据共享，我们定义一个StrBlob类，这个类仅又一个成员shared_ptr成员，用来管理vector,记录有多少个StrBlob类对象使用vector，当所有的StrBlob销毁时，vector自动回收。 12345678910111213141516171819202122232425262728293031class StrBlob&#123;public: //定义类型 typedef std::vector&lt;string&gt;::size_type size_type; StrBlob(); //通过初始化列表构造 StrBlob(const initializer_list&lt;string&gt; &amp;li); //返回vector大小 size_type size() const &#123; return data-&gt;size(); &#125; //判断vector是否为空 bool empty() &#123; return data-&gt;empty(); &#125; //向vector写入元素 void push_back(const string &amp;s) &#123; data-&gt;push_back(s); &#125; //从vector弹出元素 void pop_back(); //访问头元素 std::string &amp;front(); //访问尾元素 std::string &amp;back();private: shared_ptr&lt;vector&lt;string&gt;&gt; data;&#125;; 因为StrBlob未重载赋值运算符，也没有实现拷贝构造函数，所以StrBlob对象之间的赋值就是浅copy，因而内部成员data会随着StrBlob对象的赋值修改引用计数，默认情况下，当我们拷贝、赋值或销毁一个StrBlob对象时，它的shared_ptr成员会被拷贝、赋值或销毁。当然我们也可以实现拷贝构造和赋值操作，让大家更好的理解智能指针随着类对象赋值等操作达到共享的效果。运算符重载之后介绍，为了让程序更完善，这里给出拷贝构造和运算符重载的完整类声明。 12345678910111213141516171819202122232425262728293031323334353637class StrBlob&#123;public: //定义类型 typedef std::vector&lt;string&gt;::size_type size_type; StrBlob(); //通过初始化列表构造 StrBlob(const initializer_list&lt;string&gt; &amp;li); //拷贝构造函数 StrBlob(const StrBlob &amp;sb); StrBlob &amp;operator=(const StrBlob &amp;sb); //返回vector大小 size_type size() const &#123; return data-&gt;size(); &#125; //判断vector是否为空 bool empty() &#123; return data-&gt;empty(); &#125; //向vector写入元素 void push_back(const string &amp;s) &#123; data-&gt;push_back(s); &#125; //从vector弹出元素 void pop_back(); //访问头元素 std::string &amp;front(); //访问尾元素 std::string &amp;back();private: shared_ptr&lt;vector&lt;string&gt;&gt; data; //检测i是否越界 void check(size_type i, const string &amp;msg) const;&#125;; 接下来实现三个构造函数 1234567891011121314StrBlob::StrBlob()&#123; data = make_shared&lt;vector&lt;string&gt;&gt;();&#125;StrBlob::StrBlob(const StrBlob &amp;sb)&#123; data = sb.data;&#125;StrBlob::StrBlob(const initializer_list&lt;string&gt; &amp;li)&#123; data = make_shared&lt;vector&lt;string&gt;&gt;(li);&#125; 默认构造函数初始化data指向了一个空的vector，拷贝构造函数将sb的data赋值给自己，初始化列表方式的构造函数是用初始化列表构造data。接下来实现赋值运算符的重载 123456789StrBlob &amp;StrBlob::operator=(const StrBlob &amp;sb)&#123; if (&amp;sb != this) &#123; this-&gt;data = sb.data; &#125; return *this;&#125; 将sb的data赋值给this-&gt;data，这样this-&gt;data和sb.data引用计数相同。我们实现检查越界的函数 12345678//检测i是否越界void StrBlob::check(size_type i, const string &amp;msg) const&#123; if (i &gt;= data-&gt;size()) &#123; throw out_of_range(msg); &#125;&#125; 接下来实现front 1234567891011121314string &amp;StrBlob::front()&#123; //不要返回局部变量的引用 // if (data-&gt;size() &lt;= 0) // &#123; // return string(&quot;&quot;); // &#125; // 1 可以用一个局部变量返回异常情况 if (data-&gt;size() &lt;= 0) &#123; return badvalue; &#125; return data-&gt;front();&#125; 要考虑队列为空的情况，此时返回空字符串。但是如果我们直接构造一个空字符串返回，这样就返回了局部变量的引用，局部变量会随着函数结束而释放，造成安全隐患。所以我们可以返回类的成员变量badvalue，作为队列为空的标记。当然如果不能容忍队列为空的情况，可以通过抛出异常来处理，那我们用这种方式改写front 12345string &amp;StrBlob::front()&#123; check(0, &quot;front on empty StrBlob&quot;); return data-&gt;front();&#125; 同样我们实现back()和pop_back() 1234567891011string &amp;StrBlob::back()&#123; check(0, &quot;back on empty StrBlog&quot;); return data-&gt;back();&#125;void StrBlob::pop_back()&#123; check(0, &quot;back on pop_back StrBlog&quot;); data-&gt;pop_back();&#125; 这样我们通过定义StrBlob类，达到共享vector的方式。多个StrBlob操作的是一个vector向量。我们新增一个打印shared_ptr引用计数的方法 1234void StrBlob::printCount()&#123; cout &lt;&lt; &quot;shared_ptr use count is &quot; &lt;&lt; data.use_count() &lt;&lt; endl;&#125; 下面测试以下 123456789101112131415161718192021222324void test_StrBlob()&#123; StrBlob strblob1(&#123;&quot;hello&quot;, &quot;zack&quot;, &quot;good luck&quot;&#125;); StrBlob strblob2; try &#123; auto str2front = strblob2.front(); &#125; catch (std::out_of_range &amp;exc) &#123; cout &lt;&lt; exc.what() &lt;&lt; endl; &#125; catch (...) &#123; cout &lt;&lt; &quot;unknown exception&quot; &lt;&lt; endl; &#125; strblob2 = strblob1; auto str1front = strblob1.front(); cout &lt;&lt; &quot;strblob1 front is &quot; &lt;&lt; str1front &lt;&lt; endl; strblob2.printCount(); strblob1.printCount();&#125; 程序输出 1234front on empty StrBlobstrblob1 front is helloshared_ptr use count is 2shared_ptr use count is 2 因为strblob2的队列为空，所以会抛出异常，当执行strblob2 = strblob1之后，strblob2和strblob1的data的引用计数相同都为2。 shared_ptr和new结合之前的方式都是通过make_shared&lt;类型&gt;(构造函数列表参数)的方式构造的shared_ptr，也可以通过new 生成的内置指针初始化生成shared_ptr。 12auto psint = shared_ptr&lt;int&gt;(new int(5));auto psstr = shared_ptr&lt;string&gt;(new string(&quot;hello zack&quot;)); 接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针： 1234//错误，不能用内置指针隐式初始化shared_ptr// shared_ptr&lt;int&gt; psint2 = new int(5);//正确，显示初始化shared_ptr&lt;string&gt; psstr2(new string(&quot;good luck&quot;)); 除了智能指针之间的赋值，可以通过一个智能指针构造另一个 12345shared_ptr&lt;string&gt; psstr2(new string(&quot;good luck&quot;));//可以通过一个shared_ptr 构造另一个shared_ptrshared_ptr&lt;string&gt; psstr3(psstr2);cout &lt;&lt; &quot;psstr2 use count is &quot; &lt;&lt; psstr2.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;psstr3 use count is &quot; &lt;&lt; psstr3.use_count() &lt;&lt; endl; 程序输出 12psstr2 use count is 2psstr3 use count is 2 通过一个指针构造另一个智能指针，两个指针共享底层内置指针，所以引用计数为2.在构造智能指针的同时，可以指定自定义的删除方法替代shared_ptr自己的delete操作 12//可以设置新的删除函数替代deleteshared_ptr&lt;string&gt; psstr4(new string(&quot;good luck for zack&quot;), delfunc); 我们为psstr4指定了delfunc删除函数，这样当psstr4被释放时就会执行delfunc函数，而不是delete操作。 12345678910void delfunc(string *p)&#123; if (p != nullptr) &#123; delete (p); p = nullptr; &#125; cout &lt;&lt; &quot;self delete&quot; &lt;&lt; endl;&#125; 我们实现了自己的delfunc函数作为删除器，回收了内置指针，并且打印了删除信息。这样当psstr4执行析构时，会打印”self delete”。推荐使用make_shared的方式构造智能指针。如果通过内置指针初始化生成智能指针，那一定要记住不要手动回收内置指针。当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。以下代码存在问题 12345678910111213void process(shared_ptr&lt;int&gt; psint)&#123; cout &lt;&lt; &quot;psint data is &quot; &lt;&lt; *psint &lt;&lt; endl;&#125;int main()&#123; int *p = new int(5); process(shared_ptr&lt;int&gt;(p)); //危险，p已经被释放，会造成崩溃或者逻辑错误 cout &lt;&lt; &quot;p data is &quot; &lt;&lt; *p &lt;&lt; endl; return 0;&#125; 程序输出 12psint data is 5p data is 10569024 因为p构造为shared_ptr，那么它的回收就交给了shared_ptr，而shared_ptr是process的形参，形参在process运行结束会释放，那么p也被回收，之后再访问p会产生逻辑错误，所以打印了一个非法内存的数值。 智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。 123456789101112131415void bad_use_sharedptr()&#123; shared_ptr&lt;int&gt; p(new int(5)); //通过p获取内置指针q //注意q此时被p绑定，不要手动delete q int *q = p.get(); &#123; //两个独立的shared_ptr m和p都绑定q auto m = shared_ptr&lt;int&gt;(q); &#125; //上述&#125;结束则m被回收，其绑定的q也被回收 //此时使用q是非法操作，崩溃或者逻辑错误 cout &lt;&lt; &quot;q data is &quot; &lt;&lt; *q &lt;&lt; endl;&#125; 上述代码虽然没有手动delete q但是，两个独立的shared_ptr m和p都绑定了q，导致其中一个m被回收时q的内存也回收所以之后访问*q会出现崩溃或者数据异常。注意，以下代码和上面是不同的，m和p此时共享q,并且引用计数是共享同步的。 123456789101112131415void good_use_sharedptr()&#123; shared_ptr&lt;int&gt; p(new int(5)); //通过p获取内置指针q //注意q此时被p绑定，不要手动delete q int *q = p.get(); &#123; // m和p的引用计数都为2 shared_ptr&lt;int&gt; m(p); &#125; //上述&#125;结束则m被回收，其绑定的q也被回收 //此时使用q是非法操作，崩溃或者逻辑错误 cout &lt;&lt; &quot;q data is &quot; &lt;&lt; *q &lt;&lt; endl;&#125; 所以总结以下：get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。 resetreset的功能是为shared_ptr重新开辟一块新的内存，让shared_ptr绑定这块内存 123shared_ptr&lt;int&gt; p(new int(5));// p重新绑定新的内置指针p.reset(new int(6)); 上述代码为p重新绑定了新的内存空间。reset常用的情况是判断智能指针是否独占内存，如果引用计数为1，也就是自己独占内存就去修改，否则就为智能指针绑定一块新的内存进行修改，防止多个智能指针共享一块内存，一个智能指针修改内存导致其他智能指针受影响。 123456789//如果引用计数为1，unique返回trueif (!p.unique())&#123; //还有其他人引用，所以我们为p指向新的内存 p.reset(new int(6));&#125;// p目前是唯一用户*p = 1024; 使用智能指针的另一个好处，就是当程序一场崩溃时，智能指针也能保证内存空间被回收 1234567void execption_shared()&#123; shared_ptr&lt;string&gt; p(new string(&quot;hello zack&quot;)); //此处导致异常 int m = 5 / 0; //即使崩溃也会保证p被回收&#125; 即使运行到 m = 5 / 0处，程序崩溃，智能指针p也会被回收。有时候我们传递个智能指针的指针不是new分配的，那就需要我们自己给他传递一个删除器 12345678910void delfuncint(int *p)&#123; cout &lt;&lt; *p &lt;&lt; &quot; in del func&quot; &lt;&lt; endl;&#125;void delfunc_shared()&#123; int p = 6; shared_ptr&lt;int&gt; psh(&amp;p, delfuncint);&#125; 如果不传递delfuncint，会造成p被智能指针delete，因为p是栈空间的变量，用delete会导致崩溃。 总结智能指针陷阱智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：· 不使用相同的内置指针值初始化（或reset）多个智能指针。· 不delete get（）返回的指针。· 不使用get（）初始化或reset另一个智能指针。· 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。· 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。 源码连接https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"求最长回文串的长度","date":"2022-01-12T03:11:31.000Z","path":"2022/01/12/algorithms03/","text":"最长回文串字符串abcbada最长的回文串为abcba,最长回文串保证首尾字符相同，并且去除首尾后的子串也是回文串,如bcb。根据这个规律，ab就不是回文串因为首尾不同。abcbada也不是回文串，因为即使首尾相同，其子串bcbad不是回文串，所以abcbada也不是回文串。 动态规划可以通过动态规划解决字符串的最大回文串的长度问题，其根本思路是依次列举出长度为1~n的回文串，最后返回最大长度n即可。动态规划的思路在于找出推导公式:1 首尾元素不同，则不是回文串。2 首尾元素相同，且去除首尾元素后得子串仍是回文串，则该串为回文串。假设一个字符串str，我们将上述公式写成伪代码 121 str[begin] != str[end] 则str不是回文串2 str[begin] == str[end]， 且str[begin+1:end-1]是回文串,则str是回文串。 我们用二维数组dp[i][j]表示下标从i到j的字符串是否为回文串，如果是回文串则dp[i][j] == 1,否则dp[i][j] == 0所以一个回文串应该满足如下条件 1dp[i+1][j-1] ==1 &amp;&amp; str[i] == str[j] 长度为1时，从i到i的字符串默认为回文串，dp[i][i] = 1长度为2时，从i到i+1的字符串，判断str[i]==str[i+1] –&gt; dp[i][i+1]=1长度为3时，从i到i+2的字符串, 判断str[i] == str[i+2] &amp;&amp; dp[i+1][i+1] ==1 -&gt; dp[i][i+2] = 1长度为4时，从i到i+3的字符串，判断str[i] == str[i+3] &amp;&amp; dp[i+1][i+2] ==1 -&gt; dp[i][i+3] = 1…..推导出dp的规律后开始写代码，将所有可能dp计算出来即可 1234567891011121314151617181920212223242526272829303132333435363738394041int max_palindrome(string str, string &amp;palindstr)&#123; //初始化二维vector vector&lt;vector&lt;int&gt;&gt; dp(str.length(), vector&lt;int&gt;(str.length(), 0)); int maxpalind = 0; //先进行一次遍历统计长度为2和长度为1的dp //为以后递推长度为n的dp做准备 for (size_t i = 0; i &lt; str.length(); i++) &#123; dp[i][i] = 1; if (i + 1 &gt;= str.length()) &#123; break; &#125; if (str[i] == str[i + 1]) &#123; dp[i][i + 1] = 1; maxpalind = 2; &#125; &#125; //&quot;abcdcba&quot; //外层循环控制长度 for (int len = 3; len &lt;= str.length(); len++) &#123; //内层循环控制起始位置 for (int i = 0; i + len - 1 &lt; str.length(); i++) &#123; //首尾相同并且去掉首尾后子串仍是回文串 if (str[i] == str[i + len - 1] &amp;&amp; dp[i + 1][i + len - 2] == 1) &#123; //更新最大长度 maxpalind = len; //更新dp标记，标记i~i+len-1为回文串 dp[i][i + len - 1] = 1; palindstr = str.substr(i, i + len - 1); &#125; &#125; &#125; return maxpalind;&#125; 依次从长度3计算到字符串长度，最后更新的maxpalind为最大长度，回文串可能不止一个，这里返回最后一个。在main函数中测试 12345678int main()&#123; cout &lt;&lt; &quot;Dynamic programming ....&quot; &lt;&lt; endl; string str = &quot;abcdcb&quot;; string temp = &quot;&quot;; cout &lt;&lt; &quot;str is &quot; &lt;&lt; str &lt;&lt; endl; int maxlen = max_palindrome(str, temp); cout &lt;&lt; &quot;max palindrome is &quot; &lt;&lt; temp &lt;&lt; &quot; size is &quot; &lt;&lt; maxlen &lt;&lt; endl;&#125; 程序输出 123Dynamic programming ....str is abcdcbmax palindrome is bcdcb size is 5 中心扩展法用中心扩展法同样可以解决字符串回文问题，选在每个元素，将其设置为中心，如果满足回文串，则依次向左向右扩充，直到到达边界或者不满足回文串条件为止。如下图依次从索引为0的节点为中心，直到索引为4的节点，当以某个节点为中心时，判断他的左边节点和右边节点是否相等，如果相等则左节点向左，右节点向右，直到遇到左右节点不相等或者左右节点为边界节点结束。举例：当我们找到索引为2的节点c，判断他的左节点为b，右节点也为b，则左节点左移此时指向a，右节点右移指向a，此时左右节点已到达边界，就找到了最大的回文串abcba。上述思路有一个问题就是面对如下情况，找到的最大回文串是不正确的。按照上述办法无法找到最大回文串，而此回文串是存在的为abccba, 问题出在偶数节点对称的情况下，我们以索引为2的节点为中心，左节点为b，右节点为c无法找到回文串。解决的方案是将索引2设为左节点，索引3设为右节点就可以找到回文串。所以扩展的方案修改为上述两种算法的并集1 以单节点为中心，判断左右节点对称2 以双节点为中心，判断左右节点对称先实现根据左右节点相等，则左节点左移，右节点右移的逻辑 1234567891011int cal_maxlen(string str, int left, int right)&#123; while (left &gt;= 0 &amp;&amp; right &lt; str.length() &amp;&amp; str[left] == str[right]) &#123; left--; right++; &#125; //因为边界以及左右值不等情况下，此时要-1 // 假设字符串为abcbd 此时left 为0，right 为4=&gt; 4-0-1=3 return right - left - 1;&#125; 上述代码根据左右节点差值-1计算出回文串长度。接下来实现以节点为中心遍历展开的逻辑 123456789101112131415161718192021222324252627int center_expend(string str, string &amp;palindstr)&#123; int maxpalind = 0; //从0开始遍历，直到字符串结尾 for (int i = 0; i &lt; str.length() - 1; i++) &#123; //以单节点为中心扩展 auto len2 = cal_maxlen(str, i, i); //以双节点为中心扩展 auto len1 = cal_maxlen(str, i, i + 1); auto maxlen = 0; len2 &gt; len1 ? maxlen = len2 : maxlen = len1; if (maxlen &gt; maxpalind) &#123; maxpalind = maxlen; //此处计算左右节点的位置 //根据总长度maxlen折半找到起始位置 // 假设字符串为abccba, i为2，maxlen为6 //如果字符串为abcba,i为2，maxlen为5，下面规则同样适用 auto start = i - (maxlen - 1) / 2; auto end = i + maxlen / 2; palindstr = str.substr(start, end+1); &#125; &#125; return maxpalind;&#125; 接下来在主函数中做测试 12345678int main()&#123; cout &lt;&lt; &quot;Center expend ....&quot; &lt;&lt; endl; string str2 = &quot;abcddcbams&quot;; string temp2 = &quot;&quot;; int maxlen2 = center_expend(str2, temp2); cout &lt;&lt; &quot;str2 is &quot; &lt;&lt; str2 &lt;&lt; endl; cout &lt;&lt; &quot;max palindrome is &quot; &lt;&lt; temp2 &lt;&lt; &quot; size is &quot; &lt;&lt; maxlen2 &lt;&lt; endl;&#125; 程序输出 123Center expend ....str2 is abcddcbamsmax palindrome is abcddcba size is 8 总结解决字符串回文的算法还有马拉车算法，就是优先通过遍历在每个字符前后插入’#’，再执行中心扩展算法达到o(n)复杂度。这里不做赘述，个人认为善于通过动态规划和中心扩展算法解决回文问题即可。","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"关联容器","date":"2022-01-11T08:20:06.000Z","path":"2022/01/11/cpp20/","text":"之前我们介绍过顺序容器，list, vector, queue等，这一篇介绍关联容器, C++关联容器主要有两大类，map和set。 mapmap主要是用来管理key,value类型的结构的。 1234567891011121314void use_map()&#123; map&lt;string, size_t&gt; word_count; string word; while (cin &gt;&gt; word) &#123; word_count[word]++; &#125; for (const auto &amp;val : word_count) &#123; cout &lt;&lt; &quot;word is &quot; &lt;&lt; val.first &lt;&lt; &quot; counts are &quot; &lt;&lt; val.second &lt;&lt; endl; &#125;&#125; 用map管理输入的单词，当单词第一次出现时对应的value为0，再执行++操作变为1， 多次出现多次累加。 setset和map不同，set用来存储key，重复的key只会存储一份。我们用set和map配合，统计不在set中出现的单词的出现次数 123456789101112131415161718void use_set()&#123; map&lt;string, size_t&gt; word_count; set&lt;string&gt; excludes = &#123;&quot;zack&quot;, &quot;joyce&quot;, &quot;mongo&quot;&#125;; string word; while (cin &gt;&gt; word) &#123; if (excludes.find(word) == excludes.end()) &#123; word_count[word]++; &#125; &#125; for (const auto &amp;val : word_count) &#123; cout &lt;&lt; &quot;word is &quot; &lt;&lt; val.first &lt;&lt; &quot; counts are &quot; &lt;&lt; val.second &lt;&lt; endl; &#125;&#125; multiset与multimap一个map或者set中的key是唯一的，multiset和multimap的key不是唯一的，也就是说同一个key可以对应多个value。 1234567891011121314151617181920void use_multiset()&#123; vector&lt;int&gt; ivec; for (int i = 0; i &lt; 10; i++) &#123; ivec.push_back(i); //数据重复插入一次 ivec.push_back(i); &#125; set&lt;int&gt; iset(ivec.begin(), ivec.end()); multiset&lt;int&gt; imulset(ivec.begin(), ivec.end()); for_each(iset.begin(), iset.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; for_each(imulset.begin(), imulset.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;&#125; 上面的例子用ivec初始化iset和imulset，因为imulset允许key相同，所以imulset大小为20，iset大小为10。 关键字key为复合类型对于关联容器,如果key为自定义的复合类型，需要为该类重载比较运算符或者定义比较函数.类重载运算符我们放到之后的章节介绍，这里介绍定义比较函数的方式。先定义一个我们自己的图书信息类 123456789101112131415class BookData&#123;public: BookData() = default; BookData(string nm, string au, string is) : name(nm), author(au), isbn(is) &#123;&#125; string name; string author; string isbn;&#125;;//定义比较函数bool compareIsbn(const BookData &amp;b1, const BookData &amp;b2)&#123; return b1.isbn &lt; b2.isbn;&#125; 接下来我们定义一个multiset,其key为BookData类型 1multiset&lt;BookData, decltype(compareIsbn) *&gt; bookmap(compareIsbn); 定义了一个bookmap，类型为multiset，尖括号内部一个是key值，为BookData，另一个是比较函数指针，通过decltype自动推导函数指针类型。构造函数要传递函数对象给bookmap。这种方式并不常用，谨在此做演示，以后学习类重载运算符才是常用作法。 pair类型pair的标准库类型，它定义在头文件utility中。一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。pair主要用来map的插入操作。 123456789101112131415void use_pair()&#123; //可以定义多种类型的pair pair&lt;string, string&gt; str_pair; pair&lt;string, vector&lt;int&gt;&gt; vec_pair; // pair的初始化 //用&#123;&#125;初始化 pair&lt;string, string&gt; author = &#123;&quot;zack&quot;, &quot;fair&quot;&#125;; //用make_pair初始化 auto mkpair = make_pair(&quot;zack&quot;, 1); //用pair模板生成pair对象 auto pairinit = pair&lt;string, size_t&gt;(&quot;zack&quot;, 1024); //用map的value_type auto vtypepair = map&lt;string, size_t&gt;::value_type(&quot;zack&quot;, 1023);&#125; 上述代码介绍了几种pair的初始化方式，记住一种即可。 关联容器的迭代器当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值 123456789101112131415void map_iter()&#123; map&lt;string, size_t&gt; word_count; word_count[&quot;zack&quot;] = 1024; auto mapit = word_count.begin(); //*mapit是指向一个&lt;const string, size_t&gt;pair对象的引用 //打印第一个元素的key值 cout &lt;&lt; mapit-&gt;first &lt;&lt; endl; //打印第一个元素的value值 cout &lt;&lt; mapit-&gt;second &lt;&lt; endl; //不允许修改key值，因为key值为const不允许修改 // mapit-&gt;first = &quot;rolin&quot;; //可以修改value值 mapit-&gt;second = 222;&#125; 必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变key的值。set的迭代器是const的，因为set仅有一个key值，而key是不允许更改的，所以set获取到迭代器后无法修改其值。 12345678910void set_iter()&#123; set&lt;int&gt; iset = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 11&#125;; for (auto it = iset.begin(); it != iset.end(); it++) &#123; //解引用获得key，key无法修改 //(*it)++; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125; 关联容器也支持遍历操作，如map的遍历 1234567891011void map_iteration()&#123; map&lt;string, size_t&gt; word_count; word_count[&quot;zack&quot;] = 1; word_count[&quot;vivo&quot;] = 2; word_count[&quot;fair&quot;] = 3; for (auto it = word_count.begin(); it != word_count.end(); it++) &#123; cout &lt;&lt; &quot;key is &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; ,value is &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125;&#125; 容器操作添加元素可以使用insert函数可以通过insert向关联容器中插入一定范围的元素 12345678910111213void insert_set()&#123; set&lt;int&gt; iset; vector&lt;int&gt; ivec = &#123;1, 3, 5, 7, 9, 1, 3, 5, 7, 9&#125;; iset.insert(ivec.begin(), ivec.end()); // iset内容为1, 3, 5, 7, 9 for_each(iset.begin(), iset.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); iset.insert(&#123;2, 4, 6, 8, 10, 2, 4, 6, 8, 10&#125;); // iset内容为1,2,3,4,5,6,7,8,9,10 for_each(iset.begin(), iset.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);&#125; 上述代码中iset插入重复的元素会自动过滤，保证set中有且仅有不重复的key。如下向map中添加元素 123456789101112void insert_map()&#123; map&lt;string, size_t&gt; word_count; //通过make_pair插入 word_count.insert(make_pair(&quot;zack&quot;, 1024)); //通过&#123;&#125;插入 word_count.insert(&#123;&quot;rolin&quot;, 1234&#125;); //通过pair构造出入 word_count.insert(pair&lt;string, size_t&gt;(&quot;lucas&quot;, 112)); //通过map::value_type插入 word_count.insert(map&lt;string, size_t&gt;::value_type(&quot;Lily&quot;, 2333));&#125; insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器set和map等，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。 12345678910111213void insert_map()&#123; map&lt;string, size_t&gt; word_count; //通过make_pair插入 word_count.insert(make_pair(&quot;zack&quot;, 1024)); auto res = word_count.insert(make_pair(&quot;zack&quot;, 2234)); // insert返回一个pair，pair的first是指向给定key的迭代器 // pair的second返回的是bool值，如果给定的key已经存在，bool值为false if (!res.second) &#123; cout &lt;&lt; res.first-&gt;first &lt;&lt; &quot; has been inserted into map&quot; &lt;&lt; endl; &#125;&#125; 可以看到key为zack被插入两次，所以第二次res的second为false，res的第一个元素为key为zack的元素的迭代器，然后我们再次取迭代器的first，就是key值zack。删除元素 12345678910111213void insert_map()&#123; map&lt;string, size_t&gt; word_count; auto delres = word_count.erase(&quot;zack&quot;); if (delres) &#123; cout &lt;&lt; &quot;del zack success, res is &quot; &lt;&lt; delres &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;zack is not in map&quot; &lt;&lt; endl; &#125;&#125; 对于保存不重复关键字的容器，erase的返回值总是0或1。若返回值为0，则表明想要删除的元素并不在容器中.对允许重复关键字的容器，删除元素的数量可能大于1对于map的下标操作一定要小心，当不存在key时，通过下标访问key会将key和初始的空value自动插入到map中。我们可以通过find操作替代下标操作，这样保证不存在的key不会写入map 12345678910111213void find_map()&#123; map&lt;string, size_t&gt; word_count; auto findit = word_count.find(&quot;zack&quot;); if (findit != word_count.end()) &#123; cout &lt;&lt; &quot;find key is &quot; &lt;&lt; findit-&gt;first &lt;&lt; &quot;value is &quot; &lt;&lt; findit-&gt;second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;key zack not found&quot; &lt;&lt; endl; &#125;&#125; 对于multimap查找元素也可以通过find 1234567891011121314151617181920void find_map()&#123; // authors为multimap允许key重复 multimap&lt;string, string&gt; authors; authors.insert(make_pair(&quot;zack&quot;, &quot;i see i know&quot;)); authors.insert(make_pair(&quot;zack&quot;, &quot;who am i&quot;)); //对于map遍历，lambda表达式要用pair做参数 for_each(authors.begin(), authors.end(), [](pair&lt;string, string&gt; a) &#123; cout &lt;&lt; a.first &lt;&lt; &quot; &quot; &lt;&lt; a.second &lt;&lt; endl; &#125;); //返回包含zack的元素个数 auto count = authors.count(string(&quot;zack&quot;)); //查找第一个zack出现的迭代器 auto auit = authors.find(string(&quot;zack&quot;)); while (count &gt; 0) &#123; cout &lt;&lt; auit-&gt;second &lt;&lt; endl; auit++; count--; &#125;&#125; authors为multimap，map以及multimap的for_each函数要传递的lambda表达式参数为pair。 对于key为zack的元素有两个，count返回key为zack的元素个数2，authors.find(string(“zack”))返回key为zack的第一个元素的迭代器位置。然后根据count控制迭代器移动依次打印就可以了。 也可以通过lower_bound和upper_bound打印一个key出现的多个元素。lower_bound返回大于等于key值的第一个元素的迭代器，upper_bound返回大于key的迭代器，通过左闭右开的区间去遍历打印元素就可以了 1234567891011121314void find_map()&#123; // authors为multimap允许key重复 multimap&lt;string, string&gt; authors; authors.insert(make_pair(&quot;zack&quot;, &quot;i see i know&quot;)); authors.insert(make_pair(&quot;zack&quot;, &quot;who am i&quot;)); for (auto lowit = authors.lower_bound(&quot;zack&quot;); lowit != authors.upper_bound(&quot;zack&quot;); lowit++) &#123; cout &lt;&lt; &quot;key is &quot; &lt;&lt; lowit-&gt;first &lt;&lt; &quot; val is &quot; &lt;&lt; lowit-&gt;second &lt;&lt; endl; &#125;&#125; 还有一种方法遍历multiset中查找的指定key，通过通过equal_range函数。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。 1234567891011121314void find_map()&#123; // authors为multimap允许key重复 multimap&lt;string, string&gt; authors; authors.insert(make_pair(&quot;zack&quot;, &quot;i see i know&quot;)); authors.insert(make_pair(&quot;zack&quot;, &quot;who am i&quot;)); auto equal_range = authors.equal_range(&quot;zack&quot;); for (; equal_range.first != equal_range.second; equal_range.first++) &#123; cout &lt;&lt; &quot;key is &quot; &lt;&lt; equal_range.first-&gt;first &lt;&lt; &quot; val is &quot; &lt;&lt; equal_range.first-&gt;second &lt;&lt; endl; &#125;&#125; 无序容器新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。最常用的无序容器是unordered_map可以用unordered_map重写最初的单词计数程序 1234567891011121314void use_unorderd_map()&#123; unordered_map&lt;string, size_t&gt; word_count; string word; while (cin &gt;&gt; word) &#123; word_count[word]++; &#125; for (const auto &amp;word : word_count) &#123; cout &lt;&lt; &quot;key is &quot; &lt;&lt; word.first &lt;&lt; &quot; value is &quot; &lt;&lt; word.second &lt;&lt; endl; &#125;&#125; 可以看到打印的key是无序的。 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 源码连接https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"迭代器分类","date":"2022-01-11T02:29:49.000Z","path":"2022/01/11/cpp19/","text":"除了容器自定义的迭代器之外，标准库还提供了其他几种迭代器，包括插入迭代器，流迭代器，反向迭代器，移动迭代器。 插入迭代器迭代器被绑定到一个容器上，可用来向容器插入元素。插入迭代器包括back_inserter, front_inserter, inserter三种。back_inserter绑定到容器后，对该迭代器赋值，就执行了类似于push_back的操作，前提是该容器要支持push_back。front_inserter绑定到容器后，对该迭代器赋值，就执行了类似于push_front的操作，前提是该容器支持push_front。inserter创建一个使用insert的迭代器，此函数接受第二个参数必须是一个指向给定容器的迭代器，元素被插入到给定迭代器所表示的元素之前。 1234567891011121314151617181920void use_inserter()&#123; list&lt;int&gt; list1 = &#123;1, 2, 3, 4&#125;; list&lt;int&gt; list2, list3, list4; copy(list1.begin(), list1.end(), front_inserter(list2)); copy(list1.begin(), list1.end(), back_inserter(list3)); copy(list1.begin(), list1.end(), inserter(list4, list4.begin())); for_each(list2.begin(), list2.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; for_each(list3.begin(), list3.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; for_each(list4.begin(), list4.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;&#125; 程序输出 1234 3 2 11 2 3 41 2 3 4 iostream迭代器istream_iterator 读取输入流，ostream_iterator 向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。我们先看看输入流的操作: 123456789101112131415void use_istreamiter()&#123; //输入流迭代器 istream_iterator&lt;int&gt; in_int(cin); //迭代器终止标记 istream_iterator&lt;int&gt; in_eof; vector&lt;int&gt; in_vec; while (in_int != in_eof) &#123; in_vec.push_back(*in_int++); &#125; for_each(in_vec.begin(), in_vec.end(), [](const int &amp;i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;&#125; 上述代码创建了输入流迭代器in_int，绑定了cin。同时生成了一个输入流的结尾迭代器in_eof，in_eof未绑定任何输入流，所以是输入流的终止。通过循环将输入流数据写入in_vec中。再看看输出流的操作: 12345678910void use_ostreamiter()&#123; vector&lt;int&gt; in_vec = &#123;1, 3, 4, 2, 5, 6, 7, 9&#125;; ostream_iterator&lt;int&gt; out_in(cout, &quot; &quot;); for (auto data : in_vec) &#123; *out_in++ = data; &#125; cout &lt;&lt; endl;&#125; 输出流迭代器out_in和cout绑定，并且为每一个输出的元素设置了空格间隔。通过向*out_in赋值达到向cout写入数据的目的，同时out_in++保证了迭代器的后移。 反向迭代器反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（–it）会移动到下一个元素cbegin和cend表示正向迭代器，crbegin和crend表示反向迭代器,如下图我们通过反向迭代器逆序打印原容器中的数据 123456789void use_reverseiter()&#123; vector&lt;int&gt; in_vec = &#123;1, 3, 4, 2, 5, 6, 7, 9&#125;; for (auto rit = in_vec.crbegin(); rit != in_vec.crend(); rit++) &#123; cout &lt;&lt; *rit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 程序输出9 7 6 5 2 4 3 1我们知道sort默认规则是从小到大，如果我们想实现从大到小，可以利用反向迭代器完成 1sort(vec.rbegin(), vec.rend()); 反向迭代器遍历是从后往前，这一点也会造成一些不必要的问题 123string line = &quot;FIRST,MIDDLE,LAST&quot;;auto rcomma = find(line.crbegin(), line.crend(), &#x27;,&#x27;);cout &lt;&lt; string(line.crbegin(), rcomma) &lt;&lt; endl; 上述代码会找到最后一个逗号，获取crbegin和rcomma之间的数据实际是TSAL,也就是说反向迭代器遍历是反向的。标准库提供了一个将反向迭代器转化为正向迭代器的方法base() 12//通过base将反向迭代器转化为正向的cout &lt;&lt; string(rcomma.base(), line.cend()) &lt;&lt; endl; 程序输出LAST大家可以看一下正向迭代器和反向迭代器的关系图","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"泛型算法定制操作","date":"2022-01-10T02:03:12.000Z","path":"2022/01/10/cpp18/","text":"向算法传递函数默认情况下，泛型算法还实现了另外一个版本，就是接受一个额外的参数。比如sort函数，接受第三个参数，第三个参数是一个谓词。谓词就是一个可调用的表达式，其返回值结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。我们可以暂且将谓词理解为函数 我们利用谓词，修改sort的排序规则 1234bool isShort(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125; 上述代码将规则修改为按长度有小到大排序接下来我们实现一个函数调用sort并传递参数isShort 123456789void use_predicate()&#123; vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;; sort(words.begin(), words.end(), isShort); for (auto it = words.begin(); it != words.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 上面的函数输出 12345zazackwhathellono matter lambda表达式lambda表达式提供了类似函数的功能，可以理解为一个匿名函数，通过传递参数和捕获外部变量的引用，值等方式完成一些逻辑处理。一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式 1[capture list](parameter list) -&gt; return type &#123;function body&#125; capture list表示捕获列表，如果lambda表达式定义在函数内部，可以通过capture list 捕获该函数的局部变量的引用或者值。return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。我们可以忽略返回类型，lambda可以根据返回值自己推导返回类型。 12auto f = []() &#123; return 42; &#125;; 此例中，我们定义了一个可调用对象f，它不接受参数，返回42。lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符： 1cout &lt;&lt; &quot; f is &quot; &lt;&lt; f() &lt;&lt; endl; 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。我们将isShorter函数定义为lambda表达式 12[](const string &amp;s1, const string &amp;s2) -&gt; bool &#123; return s1.size() &lt; s2.size(); &#125;; 我们可以通过调用stable_sort进行排序，长度相同的单词维持原序列. 123vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;; stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool &#123; return s1.size() &lt; s2.size(); &#125;); 我们打印words 1234for (auto it = words.begin(); it != words.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; 输出如下 12345zazackwhathellono matter 我们用lambda表达式的捕获功能，实现一个函数，查找长度大于指定数值的单词个数。我们先实现一个将单词排序并去除重复单词的函数 12345678910void erase_dup(vector&lt;string&gt; &amp;words)&#123; //先将words中的词语排序 sort(words.begin(), words.end()); // unique会移动元素，将不重复的元素放在前边，重复的放在后边 // unique返回不重复的最后一个元素的位置 const auto uniqueiter = unique(words.begin(), words.end()); //调用erase将重复的元素删除 words.erase(uniqueiter, words.end());&#125; 接下来我们实现biggers函数，返回大于指定长度sz的单词的个数 12345678910111213int use_bigger(int sz)&#123; vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;; //先排序去除重复单词 erase_dup(words); //再稳定排序，按照长度有小到大 stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool &#123; return s1.size() &lt; s2.size(); &#125;); auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s) &#123; return s.size() &gt; sz; &#125;); return words.end() - findit;&#125; 我们测试下 123cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(3) &lt;&lt; endl;cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(5) &lt;&lt; endl;cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(10) &lt;&lt; endl; 程序输出如下 123count is 4count is 1count is 0 可以看出长度大于3的单词有4个，长度大于5的有1个，长度大于10的有0个。我们通过lambda表达式[sz]的方式捕获了use_bigger的形参sz。如果我们要将长度大于sz的单词全部打印出来,可以采用foreach函数，该函数接受三个参数，前两个是迭代器表示遍历的范围，第三个是一个表达式，表示对每个元素的操作。我们完善use_bigger函数 123456789101112131415int use_bigger(int sz)&#123; vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;; //先排序去除重复单词 erase_dup(words); //再稳定排序，按照长度有小到大 stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool &#123; return s1.size() &lt; s2.size(); &#125;); auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s) &#123; return s.size() &gt; sz; &#125;); for_each(findit, words.end(), [](const string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; return words.end() - findit;&#125; lambda捕获类型lambda捕获分为值捕获和引用捕获。lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。 123456789void lambda_catch()&#123; int val = 10; auto fn = [val] &#123; return val; &#125;; val = 200; auto fv = fn(); cout &lt;&lt; &quot;fv is &quot; &lt;&lt; fv &lt;&lt; endl;&#125; 上述代码fv会输出10，因为fn捕获的是val的值，在lambda表达式创建时就捕获了val，此时val值为10.如果采用引用方式捕获 123456789void lambda_catch_r()&#123; int val = 10; auto fn = [&amp;val] &#123; return val; &#125;; val = 200; auto fv = fn(); cout &lt;&lt; &quot;fv is &quot; &lt;&lt; fv &lt;&lt; endl;&#125; 此时输出fv is 200， 因为fn捕获的是val的引用。我们可以从一个函数返回lambda，此lambda不能包含引用捕获。因为如果lambda包含了函数局部变量的引用，当次局部变量被释放后，lambda调用会出现崩溃问题。 捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值捕获方式。在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值。在lambda从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。也就是说，在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行时，该对象的值可能已经完全不同了。一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。 隐式捕获为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。比如我们修改use_bigger函数，参数增加一个ostream和char的分隔符，在use_bigger内部利用for_each调用 1234567891011121314151617181920int use_bigger2(ostream &amp;os, char c, int sz)&#123; vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;; //先排序去除重复单词 erase_dup(words); //再稳定排序，按照长度有小到大 stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool &#123; return s1.size() &lt; s2.size(); &#125;); auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s) &#123; return s.size() &gt; sz; &#125;); // os 按照引用方式捕获，其余变量c 通过= 值方式隐士捕获。 for_each(findit, words.end(), [=, &amp;os](const string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;); // c 按照值的方式捕获，其余按照引用方式捕获。 for_each(findit, words.end(), [&amp;, c](const string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;); cout &lt;&lt; endl; return words.end() - findit;&#125; 上述代码两个for_each通过不同的隐式方式捕获局部变量。 mutable改变值默认情况下，值捕获的变量，lambda不会改变其值。lambda可以声明mutable，这样可以修改捕获的变量值。 1234567891011121314151617void mutalble_lam()&#123; int val = 100; auto fn = [val]() mutable &#123; return ++val; &#125;; cout &lt;&lt; &quot;val is &quot; &lt;&lt; val &lt;&lt; endl; cout &lt;&lt; &quot;fn val is &quot; &lt;&lt; fn() &lt;&lt; endl; val = 200; cout &lt;&lt; &quot;val is &quot; &lt;&lt; val &lt;&lt; endl; cout &lt;&lt; &quot;fn val is &quot; &lt;&lt; fn() &lt;&lt; endl;&#125; 程序输出 1234val is 100fn val is 101val is 200fn val is 102 fn捕获val的值，因为fn是mutable所以可以修改val，但不会影响外界的val。 lambda返回类型我们要做一个返回序列中数值的绝对值的函数 12345678void rt_lambda()&#123; vector&lt;int&gt; nums = &#123;-1, 2, 3, -5, 6, 7, -9&#125;; transform(nums.begin(), nums.end(), nums.begin(), [](int a) &#123; return a &lt; 0 ? -a : a; &#125;); for_each(nums.begin(), nums.end(), [](int a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;);&#125; 通过transform将nums中的数值全部变为其绝对值。transform前两个参数表示输入序列，第三个参数表示写入的目的序列，如果目的序列迭代器和输入序列开始的迭代器相同，则表示transform序列全部元素。lambda表达式并没有写返回值类型，但是是一个三目运算符的表达式，所以lambda可以推断返回类型。如果将lambda表达式写成如下会报错。 1[](int a)&#123; if(a&lt;0) return -a; else return a; &#125; 此时我们修改上面的lambda表达式，明确写出返回类型为int 12transform(nums.begin(), nums.end(), nums.begin(), [](int a) -&gt; int &#123; if (a &lt; 0) return -a; else return a; &#125;); bind绑定参数bind的形式为 1auto newCallable = bind(callable, arg_list); newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。 arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。我们先实现一个判断字符串长度的函数 123456789bool check_size(const string &amp;str, int sz)&#123; if (str.size() &gt; sz) &#123; return true; &#125; return false;&#125; check_size如果字符串str的长度大于sz就返回true，否则就返回false。接下来用bind操作生成一个新的函数，只接受一个sz参数。使用bind函数要包含头文件functional，也需要使用using namespace std::placeholders 12345678910111213141516void calsize_count()&#123; string str = &quot;hello&quot;; //将check_size第一个参数绑定给bind_check auto bind_check = bind(check_size, _1, 6); //相当于调用check_size(str,6) bool bck = bind_check(str); if (bck) &#123; cout &lt;&lt; &quot;check res is true&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;check res is false&quot; &lt;&lt; endl; &#125;&#125; 通过bind将check_size第一个参数绑定给bind_check，第二个参数为6所以调用bind_check(str)相当于调用check_size(str,6)。我们可以用bind方式实现find_if的查找，因为find_if接受的谓词只能有一个参数，所以通过bind将check_size生成为单参数函数。 12345678910111213141516int use_bigger3(ostream &amp;os, char c, int sz)&#123; vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;; //先排序去除重复单词 erase_dup(words); //再稳定排序，按照长度有小到大 stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool &#123; return s1.size() &lt; s2.size(); &#125;); auto findit = find_if(words.begin(), words.end(), bind(check_size, _1, sz)); // c 按照值的方式捕获，其余按照引用方式捕获。 for_each(findit, words.end(), [&amp;, c](const string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;); cout &lt;&lt; endl; return words.end() - findit;&#125; 通过bind生成新的函数传递给find_if就可以使用了。bind极大地方便了泛型编程的可扩展性。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"递归反转单链表","date":"2022-01-07T08:16:28.000Z","path":"2022/01/07/algorithms02/","text":"递归反转本文介绍递归反转单链表，和之前的循环遍历反转单链表方式略有不同，递归的方式要写出推到递归公式。并且在递归的同时修改指针的指向。先定义Node节点 12345678class Node&#123;public: Node(int dt, Node *nt = nullptr) : data(dt), next(nt) &#123;&#125; Node() = default; int data; Node *next;&#125;; Node节点构成的链表如下图 基本思路是实现recursive_reverse函数 1234567891011Node* recursive_reverse(Node* p)&#123; //判断p为空或者是单节点直接返回 if(p == nullptr || p-&gt;next==nullptr)&#123; return ; &#125; //递归查找，直到返回队尾元素作为头节点 //否则继续递归处理下一个节点 auto nextnode = recursive_reverse(p-&gt;next); return nextnode;&#125; 上述代码最终会将链表的尾节点返回。但是我们没有完成链表的逆转，需要改变链表节点Node的next指针。假设有两个节点node1节点为p节点p-&gt;next指向的就是node2节点p-&gt;next-&gt;next指向的就是末尾的空指针。所以当有两个节点的时候我们可以如下操作完成p和p-&gt;next两个节点指向的修改，也就是node1和node2两个节点的修改。我们将p-&gt;next-&gt;next = p-&gt;next 就是将node2的next指向了node1.我们将p-&gt;next = nullptr 就是将node1-&gt;next指向了空地址。所以node1此时变为尾节点。而之前的递归保证了最后返回的是node2节点，此时node2节点就作为头节点，从而完成了逆转。图解为下图这是两个节点的情况，如果是三个节点呢，那就依次类推，依次完成node3-&gt;next指向node2，node2-&gt;next指向node1，node1-&gt;next指向空地址。所以n&gt;=2的情况都是和两个节点类似的，那么我们补全recursive_reverse函数 123456789101112131415Node *recursive_reverse(Node *p)&#123; //如果链表为空或者为单节点，直接返回 if (p == nullptr || p-&gt;next == nullptr) &#123; return p; &#125; //否则继续递归处理下一个节点 auto nextnode = recursive_reverse(p-&gt;next); //改变p的下一个节点next指向，链表逆转 p-&gt;next-&gt;next = p; //改变p的next指向 p-&gt;next = nullptr; return nextnode;&#125; 接下来我们实现一个创建链表的函数用来测试 123456789Node *createList()&#123; auto node1 = new Node(1); auto node2 = new Node(2); auto node3 = new Node(3); node1-&gt;next = node2; node2-&gt;next = node3; return node1;&#125; 然后实现销毁链表回收内存的函数 123456789void delocateList(Node *p)&#123; while (p != nullptr) &#123; auto temp = p; p = p-&gt;next; delete temp; &#125;&#125; 然后实现打印节点的函数 12345678910void printList(Node *p)&#123; while (p != nullptr) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; -&gt; &quot;; p = p-&gt;next; &#125; cout &lt;&lt; &quot; nullptr &quot; &lt;&lt; endl;&#125; 最后我们在main函数中测试 12345auto list = createList();printList(list);list = recursive_reverse(list);printList(list);delocateList(list); 程序输出如下 121 -&gt; 2 -&gt; 3 -&gt; nullptr3 -&gt; 2 -&gt; 1 -&gt; nullptr 可以看到链表被逆转了。源码链接https://gitee.com/secondtonone1/algorithms我的公众号，谢谢关注","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"泛型算法","date":"2022-01-06T09:10:44.000Z","path":"2022/01/06/cpp17/","text":"泛型算法泛型算法是STL库里面定义的一些算法,这些算法可以用一个接口操作各种数据类型,因此成为泛型算法。大多算法定义在头文件algorithm和numeric中。意思就是可以用一个接口操作各种类型的算法就是泛型算法。 泛型算法分为两类，一类是只读算法，一类是修改原有容器的算法。只读算法包括find(查找),accumulate(累加)等。修改算法包括replace(替换),fill(填充)等。 accumulate1234567vector&lt;int&gt; nvec = &#123;1, 2, 3, 4, 5, 6, 7&#125;;//调用accumulate累加，sum的初始值为0，累加结果写入sumauto sum = accumulate(nvec.begin(), nvec.end(), 0);cout &lt;&lt; &quot;sum is &quot; &lt;&lt; sum &lt;&lt; endl;list&lt;string&gt; strlist = &#123;&quot;hello&quot;, &quot;zack&quot;, &quot;good&quot;, &quot;idea&quot;&#125;;string stradd = accumulate(strlist.begin(), strlist.end(), string(&quot;&quot;));cout &lt;&lt; &quot;str add result is &quot; &lt;&lt; stradd &lt;&lt; endl; accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来.程序输出 12sum is 28str add result is hellozackgoodidea equal泛型算法中有操作两个序列的算法，比如equal就是比较两个序列中元素是否有相等的值，如果第一个序列中每个元素与第二个序列中的元素都相等，则返回true，否则返回false。 123456789bool bequa = equal(strlist.begin(), strlist.end(), strlist2.begin()); if (bequa) &#123; cout &lt;&lt; &quot;strlist is equal to strlist2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;strlist is not equal to strlist2&quot; &lt;&lt; endl; &#125; 上述代码比较了strlist和strlist2，切记strlist2的长度要大于等于strlist，否则程序会出现问题。那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。 fill可以通过fill算法修改容器的值,算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。 12345vector&lt;int&gt; nvec2 = &#123;1, 2, 3, 4&#125;;//将nvec2中所有元素设置为0fill(nvec2.begin(), nvec2.end(), 0);//将nvec2中前半部分设置为10fill(nvec2.begin(), nvec2.begin() + nvec2.size() / 2, 10); 类似的还有fill_n函数，该函数接受一个单迭代器，一个计数值和一个值。 12vector&lt;int&gt; vec;fill_n(vec.begin(), vec.size(), 0); 如下调用fill会导致程序崩溃，因为vec3大小为0，而fill要向vec3写入10个0，会造成越界崩溃。 1234//空向量vector&lt;int&gt; vec3;// 灾难，修改vec3中的10个不存在元素fill_n(vec3.begin(),10,0); back_inserterfill_n如果传递的个数大于容器的大小会造成崩溃，为了防止类似的问题，stl引入了back_inserter。back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中： 1234567891011//空vectorvector&lt;int&gt; nvec4;// back_inserter绑定nvec4并返回迭代器auto iter = back_inserter(nvec4);//对迭代器的赋值就是对nvec插入元素*iter = 2;*iter = 4;for (auto it = nvec4.begin(); it != nvec4.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125; 程序依次打印输出2, 4我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如： 123456//空vectorvector&lt;int&gt; nvec5;// back_inserter绑定nvec5并返回迭代器auto iter5 = back_inserter(nvec5);//添加10个元素写入nvec5fill_n(iter5, 10, 0); copy拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。 12345int a1[] = &#123;0, 1, 2, 3, 4, 5, 6&#125;;constexpr int nszie = sizeof(a1) / sizeof(int);int a2[nszie];//将a1内容copy到a2中copy(begin(a1), end(a1), a2); replace我们可以通过replace替换原容器中的某个值为设定的新值 123vector&lt;int&gt; nvec6 = &#123;1, 2, 3, 4&#125;;//将nvec6中所有元素为3的设置为32replace(nvec6.begin(), nvec6.end(), 3, 32); 如果保留原容器数据，可以通过back_inserter绑定一个新的容器，然后用replace_copy完成拷贝和替换操作 123456//原始数据列表list&lt;int&gt; ilist = &#123;0, 1, 2, 3, 4, 5&#125;;//空向量vector&lt;int&gt; rcpvec;//将ilist中的数据copy到rcpvec里，但是将其中的0替换为42replace_copy(ilist.begin(), ilist.end(), back_inserter(rcpvec), 0, 42); unique和sort我们实现一个功能，将vector中的单词排序并且去除其中重复的单词。我们可以用sort函数先将vector中的单词排序，然后用unique去除重复的单词，unique返回不重复的最后一个元素的迭代器，unique保证容器中前n个元素是不重复的，n+1个开始就是重复的，所以我们用erase再删除n+1个元素以后的内容就可以了。 12345678vector&lt;string&gt; words = &#123;&quot;good&quot;, &quot;idea&quot;, &quot;zack&quot;, &quot;lucy&quot;, &quot;good&quot;, &quot;idea&quot;&#125;;//先将words中的词语排序sort(words.begin(), words.end());// unique会移动元素，将不重复的元素放在前边，重复的放在后边// unique返回不重复的最后一个元素的位置const auto uniqueiter = unique(words.begin(), words.end());//调用erase将重复的元素删除words.erase(uniqueiter, words.end()); 打印输出words可以看到words变为{good , idea , lucy , zack}","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"容器","date":"2022-01-04T06:56:09.000Z","path":"2022/01/04/cpp16/","text":"常用容器C++ 常用的stl容器包括:1 vector 可变大小的数组，支持随机访问。在尾部之外位置插入或删除元素很慢。2 deque 双端队列，支持快速随机访问，在头尾位置插入删除速度很快。3 list 双向链表，支持双向访问，任何位置插入和删除都很快4 forward_list 单向链表，只支持单向访问，在列表任何位置插入和删除都很快5 array 固定大小数组，支持快速随机访问，不能添加和删除元素。6 string 与vector相似，专门用于处理字符串。 基本用法stl容器可以存储任意类型的数据，因为容器是通过模板实现的，下面列举了容器的一些用法 123456// sales_data对象的list list&lt;Sales_data&gt; sales_list; // 保存double数据的deque deque&lt;double&gt; dd; // vector里存储了vector&lt;string&gt; vector&lt;vector&lt;string&gt;&gt; strvec_vec; 容器嵌套时尽量将&gt;&gt;分开，保留一个空格，有些陈旧的编译器会将&gt;&gt;当作输入流。 迭代器迭代器可以理解为访问容器的通用工具，通过容器名.begin()返回指向第一个元素的迭代器，通过容器名.end()返回指向最后一个元素的下一个元素的迭代器。 12345//通过begin和end访问容器元素 for (auto begin = dd.begin(); begin != dd.end(); begin++) &#123; cout &lt;&lt; *begin &lt;&lt; endl; &#125; begin和end形成了一个左闭右开的空间，所以要用begin != end 判断迭代器是否走到最后一个元素的下一个元素,因为最后一个元素的下一个位置是不合法的，所以是左闭右开空间。迭代器的类型可以通过容器类型获取 1234// vector&lt;string&gt;容器的迭代器vector&lt;string&gt;::iterator strit;// deque&lt;double&gt;容器的迭代器deque&lt;double&gt;::iterator ddit; 容器初始化每个容器类型都定义了一个默认构造函数,如上面代码我们定义的deque dd,list sales_list等都执行了容器默认的构造函数。将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者（array除外）拷贝由一个迭代器对指定的元素范围。 1234//将一个容器copy给另一个相同类型的容器list&lt;string&gt; persons2(persons);//通过迭代器实现copylist&lt;string&gt; persons3(persons.begin(), persons.end()); 利用assign可以将一个容器内的数据赋值给另一个 1persons2.assign(persons.begin(), persons.end()); 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素： 12//用指定数目和初始值persons2.assign(5, &quot;zack&quot;); swap可以交换两个容器的内容 1234//交换两个容器vector&lt;string&gt; svec1(10);vector&lt;string&gt; svec2(24);swap(svec1, svec2); 调用swap后，svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。 添加元素push_back操作向容器末尾添加指定元素，出了array和forward_list不支持push_back，其余顺序容器都支持。 123// push_back添加尾元素vector&lt;string&gt; svec3;svec3.push_back(&quot;good idea!&quot;); 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。push_front向容器头部插入元素,注意支持push_front的容器仅有deque, list, forwardlist等。 123456// push_front添加头部元素 list&lt;int&gt; nlist; for (int i = 0; i &lt; 100; i++) &#123; nlist.push_front(i); &#125; push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员.每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，所以insert函数将元素插入到迭代器所指定的位置之前 12345678// insert 插入 vector&lt;string&gt; strinvec; // vector不支持push_front，可以通过insert实现 // 在vector头部插入元素会很慢，以为vector要移动所有元素 strinvec.insert(strinvec.begin(), &quot;zack&quot;); list&lt;string&gt; strlist; //相当于push_back strlist.insert(strlist.end(), &quot;zack&quot;); insert有很多重载版本，也可以插入指定范围内的元素。 1234567//批量插入strlist.insert(strlist.end(), 10, &quot;ai&quot;);vector&lt;string&gt; names = &#123;&quot;zack&quot;, &quot;rolin&quot;, &quot;bob&quot;, &quot;pior&quot;&#125;;//通过迭代器插入strlist.insert(strlist.begin(), names.end() - 2, names.end());//通过参数列表插入strlist.insert(strlist.end(), &#123;&quot;vivo&quot;, &quot;hua&quot;, &quot;nokia&quot;&#125;); 如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。insert的返回值为返回新插入元素的位置，insert是将元素插入到迭代器指向元素之前的位置，插入成功后并返回这个位置，所以insert返回的是指向插入之后新元素的位置。 emplace操作emplace也是插入操作，但是emplace接受的一个类的构造函数，这样和insert相比，减少了对类对象的构造开销 1234// sales_data对象的list list&lt;Sales_data&gt; sales_list; //传递Sales_data的构造函数 sales_list.emplace_back(string(&quot;love easy&quot;), 200, 1.8); 访问元素可以通过front和back获取队首元素和队尾元素 123 auto first = sales_list.front();auto last = sales_list.back();auto strfirst = svec3.front(); 线性容器支持下标访问，比如vector,string等 123auto strfirst = svec3.front();auto strfirst2 = svec3.at(0);auto strfrist3 = svec3[0]; 删除元素list, deque支持pop_back()弹出和最后一个元素,以及pop_front弹出第一个元素。forward_list不支持pop_back和push_back， vector和string 不支持pop_front和push_front. 12345vector&lt;string&gt; strinvec;strinvec.pop_back();forward_list&lt;string&gt; forlist;forlist.push_front(&quot;hello&quot;);forlist.pop_front(); 也可以通过迭代器删除指定位置的元素 123456//删除头部元素strinvec.erase(strinvec.begin());//范围删除，删除从头部到尾部的元素strinvec.erase(strinvec.begin(), strinvec.end());//删除所有strinvec.clear(); 删除和插入会导致容器迭代器失效，所以要更新删除后的迭代器确保程序稳定 12345678910111213for (auto iter = numlist.begin(); iter != numlist.end();) &#123; if (*iter % 2) &#123; //删除后返回下一个迭代器 iter = numlist.erase(iter); &#125; else &#123; //没删除则移动迭代器 iter++; &#125; &#125; forward_list的删除和插入对于forward_list 提供了特殊的删除操作,erase_after 和特殊的插入操作insert_after。以下通过一次遍历实现删除forward_list中的偶数 1234567891011121314151617181920forward_list&lt;int&gt; numlist2 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; // numlist2的首前元素，第一个元素之前的位置，不能解引用，因为该位置没有元素。 auto prev = numlist2.before_begin(); //第一个元素 auto curr = numlist2.begin(); while (curr != numlist2.end()) &#123; if (*curr % 2) &#123; //返回删除元素的下一个元素 curr = numlist2.erase_after(prev); &#125; else &#123; // prev更更新为curr prev = curr; // curr向后移动 curr++; &#125; &#125; 删除操作和插入操作会导致迭代器失效，所以要时刻更新迭代器的值保证程序运行稳定。 容器大小我们可以通过resize改变容器size大小，通过reverse改变容器capacity容量。capacity是容量，容器预先开辟一块空间，capacity比size大，所以当插入元素导致容器size增加时不用每次都开辟空间。当size大于等于capacity时，会扩充capacity。 12345678910111213141516171819vector&lt;string&gt; strvec2 = &#123;&quot;zack&quot;, &quot;lucy&quot;, &quot;vivo&quot;, &quot;rolin&quot;&#125;;cout &lt;&lt; &quot;strvec2.size is &quot; &lt;&lt; strvec2.size() &lt;&lt; endl;cout &lt;&lt; &quot;strvec2.capacity is &quot; &lt;&lt; strvec2.capacity() &lt;&lt; endl;//插入一个元素，导致size变化//当size&gt;=capacity是，capacity也会增加strvec2.push_back(&quot;lirus&quot;);cout &lt;&lt; &quot;strvec2.size is &quot; &lt;&lt; strvec2.size() &lt;&lt; endl;cout &lt;&lt; &quot;strvec2.capacity is &quot; &lt;&lt; strvec2.capacity() &lt;&lt; endl;//修改大小strvec2.resize(20);//修改容量strvec2.reserve(23);for (auto it = strvec2.begin(); it != strvec2.end(); it++)&#123; cout &lt;&lt; &quot;data is &quot; &lt;&lt; *it &lt;&lt; endl;&#125;cout &lt;&lt; &quot;strvec2.size is &quot; &lt;&lt; strvec2.size() &lt;&lt; endl;cout &lt;&lt; &quot;strvec2.capacity is &quot; &lt;&lt; strvec2.capacity() &lt;&lt; endl; 程序输出 1234567891011121314151617181920212223242526strvec2.size is 4strvec2.capacity is 4strvec2.size is 5strvec2.capacity is 8data is zackdata is lucydata is vivodata is rolindata is lirusdata isdata isdata isdata isdata isdata isdata isdata isdata isdata isdata isdata isdata isdata isdata isstrvec2.size is 20strvec2.capacity is 23 可以看出当size &gt;= capacity时,重新开辟capacity.resize扩充size后，容器会填充空数据，反之resize缩小size后会删除容器尾部多余数据。 容器适配器stl标准库还定义了三个顺序容器适配器, stack，queue和priority_queue。stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。 123456//基于vector构建stackstack&lt;string, vector&lt;string&gt;&gt; strstack;//基于vector构造priority_queuepriority_queue&lt;string, vector&lt;string&gt;&gt; strpque;//基于list构造一个queuequeue&lt;list&lt;string&gt;&gt; strqueue; 以下示例演示stack的使用 123456789101112131415//构造一个stack&lt;int&gt; intStack;for (int i = 0; i &lt; 10; i++)&#123; intStack.push(i);&#125;// stack不为空while (!intStack.empty())&#123; //访问栈顶元素但是不取出 auto data = intStack.top(); cout &lt;&lt; data &lt;&lt; endl; //栈顶元素出栈 intStack.pop();&#125; 程序输出9,8,7,6,5,4,3,2,1,0同样stack也支持emplace操作，节省构造函数传值的开销。队列适配器queue和栈适配器stack都是基于双端队列deque实现,而priority_queue基于vector实现。获取队首元素用front(),弹出队首元素用pop()。 123456789101112131415//队列queue&lt;int&gt; numque;for (int i = 0; i &lt; 10; i++)&#123; numque.push(i);&#125;while (!numque.empty())&#123; //访问队列首元素 auto &amp;first = numque.front(); cout &lt;&lt; first &lt;&lt; &quot; &quot;; //弹出队首元素 numque.pop();&#125; 程序输出0,1,2,3,4,5,6,7,8,9","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"双链表实现LRU算法","date":"2021-12-29T09:50:00.000Z","path":"2021/12/29/algorithms/","text":"链表所谓链表就是一个节点指向另一个节点的数据结构，像一条链子把每个节点连接起来。如果一个节点既指向了后面的节点，也指向了前面的节点，这些节点就构成了双向链表。我们先定义这个节点结构 123456789class NodeLRU&#123;public: NodeLRU(int v) : val(v), prev(nullptr), next(nullptr) &#123;&#125; int val; NodeLRU *prev; NodeLRU *next;&#125;; val为节点的数据域表示节点存储的数值prev为节点的前一个节点next为节点的后一个节点然后我们把这些节点串连起来，定义一个链表的结构 一个双向链表的结构图 现在我们实现LRU算法:1 插入一个节点数据域为val，如果链表中有和val匹配的节点，则将该节点移动到链表头,如果没有该节点则直接插入头部。2 在执行1操作时，如果链表长度已经达到最大，则删除尾节点，在头部插入。 接下来我们实现LRU类，通过插入节点实现LRU算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class LRU&#123;public: LRU(int sz) : max_size(sz), cur_size(0), head(nullptr), tail(nullptr) &#123;&#125; LRU() = default; void insert(int val) &#123; if (max_size == 0) &#123; return; &#125; if (head == tail &amp;&amp; head == nullptr) &#123; auto node = new NodeLRU(val); head = node; tail = node; cur_size++; return; &#125; auto node_find = find(val); if (node_find == nullptr) &#123; //节点数量达到上限 if (cur_size &gt;= max_size) &#123; //删除尾节点 auto deltail = tail; if (tail-&gt;prev != nullptr) &#123; tail-&gt;prev-&gt;next = nullptr; &#125; tail = tail-&gt;prev; delete (deltail); cur_size--; &#125; //插入头部节点 auto node = new NodeLRU(val); node-&gt;next = head; head-&gt;prev = node; head = node; cur_size++; return; &#125; //头部节点就不处理 if (node_find == head) &#123; return; &#125; //如果是尾部节点 if (node_find == tail) &#123; node_find-&gt;prev-&gt;next = nullptr; tail = node_find-&gt;prev; &#125; else &#123; //先将node_find节点前后节点连接起来 node_find-&gt;prev-&gt;next = node_find-&gt;next; node_find-&gt;next-&gt;prev = node_find-&gt;prev; &#125; //在将node_find节点插入头部 node_find-&gt;prev = nullptr; node_find-&gt;next = head; head = node_find; &#125; NodeLRU *find(int sz) &#123; auto node = head; while (node != nullptr) &#123; if (node-&gt;val == sz) &#123; return node; &#125; node = node-&gt;next; &#125; return nullptr; &#125; void print() &#123; for (auto node = head; node != nullptr; node = node-&gt;next) &#123; cout &lt;&lt; node-&gt;val &lt;&lt; &quot; -&gt; &quot;; &#125; cout &lt;&lt; &quot;null&quot; &lt;&lt; endl; &#125; ~LRU() &#123; for (auto node = head; node != nullptr;) &#123; auto nodedel = node; node = node-&gt;next; delete (nodedel); &#125; head = nullptr; tail = nullptr; &#125;private: NodeLRU *head; NodeLRU *tail; int max_size; int cur_size;&#125;; max_size 表示链表最大长度，cur_size表示链表当前长度，head表示链表的头结点，tail表示链表的尾节点。 接下来我们测试LRU类 123456789auto lru = LRU(3);lru.insert(4);lru.insert(3);lru.insert(2);lru.print();lru.insert(100);lru.print();lru.insert(10);lru.print(); 程序输出 1232 -&gt; 3 -&gt; 4 -&gt; null100 -&gt; 2 -&gt; 3 -&gt; null10 -&gt; 100 -&gt; 2 -&gt; null 源码链接https://gitee.com/secondtonone1/algorithms我的公众号，谢谢关注","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"C++ IO流","date":"2021-12-29T09:49:19.000Z","path":"2021/12/29/cpp15/","text":"流的状态C++流包括istream, ostream，基于istream继承实现了istringstream和ifstream，基于ostream继承实现了ostringstream和ofstream。由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。IO库定义了4个iostate类型的constexpr值，表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检测或设置多个标志位。 badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。在发生可恢复错误后，failbit被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。如果到达文件结束位置，eofbit和failbit都会被置位。goodbit的值为0，表示流未发生错误。如果badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败。 流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员：它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。clear不接受参数的版本清除（复位）所有错误标志位。执行clear()后，调用good会返回true。 123456//保留当前cin状态auto old_state = cin.rdstate();//使cin有效cin.clear();//将cin置为原有状态cin.setstate(old_state); 管理输出缓冲如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。 1234//所有输出操作都立即刷新缓冲区cout &lt;&lt; unitbuf;//恢复到正常模式cout &lt;&lt; nounitbuf; 关联输入和输出流tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie（&amp;o）将流x关联到输出流o。 我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream： 12345678910//将cin和cout绑定在一起cin.tie(&amp;cout);// old_tie指向当前关联到cin的流(如果有的话)// cin不再与其他流关联ostream *old_tie = cin.tie(nullptr);//将cin和cerr关联//读取cin会刷新cerrcin.tie(&amp;cerr);//重建cin和cout的关联cin.tie(old_tie); 在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了tie。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。 fstream对文件操作可以使用fstream，fstream分为ofstream和ifstream，ofstream是向文件里写，ifstream是从文件里读 1234//输入流关联opfile路径的文件ifstream(opfile);//输出流未关联任何文件ofstream(); 之前我们的Sale_data类是从istream读数据，现在改为从文件读数据 fstream包含成员函数open和close如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来：一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件：文件模式当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定app模式： stringstreamistringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream既可从string读数据也可向string写数据。定义一个PersonInfo的公有类我们的程序会读取数据文件，并创建一个PersonInfo的vector。vector中每个元素对应文件中的一条记录。我们在一个循环中处理输入数据，每个循环步读取一条记录，提取出一个人名和若干电话号码：这里我们用getline从标准输入读取整条记录。如果getline调用成功，那么line中将保存着从输入文件而来的一条记录。在while中，我们定义了一个局部PersonInfo对象，来保存当前记录中的数据。我们可以使用ostream管理要输出的字符串在此程序中，我们假定已有两个函数，valid和format，分别完成电话号码验证和改变格式的功能。程序最有趣的部分是对字符串流formatted和badNums的使用。我们使用标准的输出运算符（&lt;&lt;）向这些对象写入数据，但这些“写入”操作实际上转换为string操作，分别向formatted和badNums中的string对象添加字符。源码链接https://gitee.com/secondtonone1/cpplearn我的公众号，谢谢关注","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"静态成员","date":"2021-12-29T07:35:44.000Z","path":"2021/12/29/cpp14/","text":"声明静态成员我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。 举个例子，我们定义一个类，用它表示银行的账户记录 123456789101112131415161718192021class Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; interestRate是类Account的静态成员变量，被所有对象共享。静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员对象需要在类的非内联文件中被定义，所谓非内联文件就是类的cpp文件。 123456789101112double Account::interestRate;void Account::rate(double ds)&#123; interestRate = ds;&#125;double Account::initRate()&#123; interestRate = 0.1; return interestRate;&#125; 和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句,所以我在类外定义了initRate函数，在类外前面没有static关键字。 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态成员特性静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。举个例子，静态数据成员可以是不完全类型静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参 源码链接https://gitee.com/secondtonone1/cpplearn我的公众号，谢谢关注","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"构造函数","date":"2021-12-28T07:40:09.000Z","path":"2021/12/28/cpp13/","text":"类成员初始化类成员的初始化可以通过构造函数的参数列表初始化，也可以在构造函数中赋值完成初始化 123456Sales_data::Sales_data(const Sales_data &amp;sa)&#123; this-&gt;bookNo = sa.bookNo; this-&gt;revenue = sa.revenue; this-&gt;units_sold = sa.units_sold;&#125; 上面就是通过赋值完成了bookNo, revenue, units_sold等成员的初始化。但不是所有成员都可以通过构造函数内赋值完成初始化，比如const, 引用类型的成员变量，这种类型需要用构造函数初始化列表初始化。 12345678910class ConstRef&#123;public: ConstRef(int ii) : ci(ii), ri(ii) &#123; i = ii; &#125;;private: int i; const int ci; int &amp;ri;&#125;; 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。 委托构造函数委托构造函数就是将自己的构造需求委托给另一个构造函数，达到构造对象的目的。我们可以优化一下之前实现的Sales_data构造函数，先实现一个全参数版本的构造函数，在让其他构造函数委托该构造函数完成构造我们重新定义一个新的类Sales_new 123456789101112131415161718192021class Sales_new&#123;public: Sales_new(const std::string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125; Sales_new() : Sales_new(&quot;&quot;, 0, 0.0) &#123;&#125; // copy构造，根据Sales_new类型对象构造一个新对象 Sales_new(const Sales_new &amp;sa) : Sales_new(sa.bookNo, sa.units_sold, sa.revenue) &#123;&#125; Sales_new(std::istream &amp;is) : Sales_new() &#123; read(is, *this); &#125; friend std::istream &amp;read(std::istream &amp;, Sales_new &amp;);private: //图书编号 std::string bookNo; //销量 unsigned units_sold = 0; //收入 double revenue = 0.0;&#125;; 上述代码只实现了一个全参数版本的构造函数，其余的构造函数都是间接调用这个构造函数完成的。 默认构造函数重要性默认情况下系统会为每个类生成默认构造函数，但我们实现参数版构造函数后，系统提供的默认构造函数就会被隐藏，需要我们手动实现默认构造函数。以下说明了不实现默认构造函数的问题： 隐式类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数. 12Sales_data sa;auto sb = sa.combine(string(&quot;good luck&quot;)); Sales_data类的combine函数参数为const Sales_data&amp;类型 1Sales_data &amp;combine(const Sales_data &amp;); 调用combine函数时，编译器自动执行了隐式类型转换，实现了string对象构造一个临时的Sales_data对象。在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit抑制构造函数定义的隐式转换：关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复：我们可以通过static_cast显示转换，避免错误。 聚合类聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：· 所有成员都是public的。· 没有定义任何构造函数。· 没有类内初始值。· 没有基类，也没有virtual函数以下是聚合类 12345struct Data&#123; int ival; string s;&#125;; 可以用初始化{}初始化聚合类 1Data val2 = &#123;0, &quot;zack&quot;&#125;; 初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。 constexpr构造函数数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类： · 数据成员都必须是字面值类型。· 类必须至少含有一个constexpr构造函数。· 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。· 类必须使用析构函数的默认定义，该成员负责销毁类的对象 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。constexpr构造函数就必须既符合构造函数的要求不能有返回语句，所以要用参数列表的方式初始化类。constexpr构造函数体一般来说应该是空的。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"类的作用域","date":"2021-12-28T02:14:25.000Z","path":"2021/12/28/cpp12/","text":"访问成员每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问 123456Screen::pos row = 3;Screen::pos col = 4;Screen screen(row, col, &#x27;c&#x27;);screen.get();Screen *psc = &amp;screen;psc-&gt;get(); 类的外部定义成员函数时必须同时提供类名和函数名。在类的内部定义的成员函数不需要提供类名，成员函数内部调用类定义的变量和类型，无需提供类名。举个例子 1234567void Window_mgr::clear(ScreenIndex i)&#123; // s是一个Screen的引用，指向我们想清空的屏幕 Screen &amp;s = screens[i]; //清空屏幕 s.contents = string(s.height * s.width, &#x27; &#x27;);&#125; 这是我们之前实现的clear, ScreenIndex为类内定义的类型，所以无需加Window_mgr::反之，如果我们在类外定义一个新的函数addScreen函数，其返回值为ScreenIndex类型，就需要添加Window_mgr:: 123456789101112class Window_mgr&#123;public: //窗口中每个屏幕的编号 using ScreenIndex = std::vector&lt;Screen&gt;::size_type; //按照编号将指定的Screen重置为空白 void clear(ScreenIndex); ScreenIndex addScreen(const Screen &amp;);private: std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125;; 这里要注意所有用到ScreenIndex类型的函数，一定要在 using ScreenIndex 类型声明的下边，否则编译器会报错，因为编译器检测函数声明类型是按顺序的。接下来如果在类外实现addScreen，就要为ScreenIndex添加Window_mgr类名 12345Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &amp;s)&#123; screens.push_back(s); return screens.size() - 1;&#125; 变量查找和作用域类的定义分两步处理：· 首先，编译成员的声明。· 直到类全部可见后才编译函数体。编译器处理完类中的全部声明后才会处理成员函数的定义。所以我们可以在类中定义的函数使用类的任何成员变量而不会报错 123456//读取光标处字符 char get() const &#123; //隐式内联 return contents[cursor]; &#125; 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。比如 123456789typedef double Money;class Account&#123;public: Money balance() &#123; return bal; &#125;private: Money bal;&#125;; 当编译器看到balance函数的声明语句时，它将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。在这个例子中，编译器会找到Money的typedef语句，该类型被用作balance函数的返回类型以及数据成员bal的类型. 成员函数中变量查找规则成员函数中使用的名字按照如下方式解析：· 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。· 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。· 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。如果全局作用域定义了一个变量名和成员函数内使用的变量名一样，则优先查找类中是否有同名的成员名,如果有使用的就是类的成员变量。如果成员函数的形参名和成员变量名相同，则会覆盖同名的成员变量，可以使用this指代成员变量避免错误 1234void setbalance(Money bal) &#123; this-&gt;bal = bal; &#125; 源码链接https://gitee.com/secondtonone1/cpplearn我的公众号，谢谢关注","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"类的访问控制","date":"2021-12-27T02:09:56.000Z","path":"2021/12/27/cpp11/","text":"私有和公有一个类里有方法和成员变量，public关键字标识后，public下的方法和变量都变为公有函数。private关键字标识后，private关键字下的方法和成员变量都变为私有。默认情况下，如果不声明public，class中所有的方法和成员都是私有的。如果不声明private, struct中所有的方法和成员都是公有的。 友元上一篇，我们将print，read等非Sales_data类的全局函数声明为Sales_data类的友元函数，所以print，read可以访问Sales_data类的私有成员。我们再次回忆一下Sales_data类。 123456789101112131415161718192021222324252627282930class Sales_data&#123;public: //通过default实现默认构造 // Sales_data() = default; //显示实现默认构造 Sales_data() : bookNo(&quot;&quot;), units_sold(0), revenue(0.0) &#123;&#125; // copy构造，根据Sales_data类型对象构造一个新对象 Sales_data(const Sales_data &amp;sa); Sales_data(const std::string &amp;s) : bookNo(s) &#123;&#125; Sales_data(const std::string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125; Sales_data(std::istream &amp;is); //返回图书号 std::string isbn() const &#123; return bookNo; &#125; //获取平均单价 double avg_price() const; //将一个Sales_data对象合并到当前类对象 Sales_data &amp;combine(const Sales_data &amp;); friend std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;); friend std::istream &amp;read(std::istream &amp;, Sales_data &amp;);private: //图书编号 std::string bookNo; //销量 unsigned units_sold = 0; //收入 double revenue = 0.0;&#125;; 封装有两个重要的优点：· 确保用户代码不会无意间破坏封装对象的状态。· 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 友元的声明友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。所以我在Sales_data类的头文件里声明了这些函数 1234// Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern std::istream &amp;read(std::istream &amp;, Sales_data &amp;); 隐藏类型定义我们可以在类中定义一种新的类型，这种类型对于外部是隐藏内部实现的，外部不知道该类型是什么。 12345678910class Screen&#123;public: typedef std::string::size_type pos;private: pos cursor = 0; pos height = 0, width = 0; std::string contents;&#125;; 用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在7.4.1节（第254页）解释。因此，类型成员通常出现在类开始的地方。 inline成员函数所谓内联函数就是在编译时展开，减少运行时开销的一种手段，可以通过inline关键字声明，也可以在类的cpp文件里定义函数时前面指明inline，当然一个类的成员函数在类的头文件实现了，那它也是内联函数，我们完善Screen类，用以上三种方式实现内联函数 1234567891011121314151617181920212223242526class Screen&#123;public: typedef std::string::size_type pos; //因为Screen有另一个构造函数 //所以要实现一个默认构造函数 Screen() = default; // cursor被初始化为0 Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) &#123;&#125; //读取光标处字符 char get() const &#123; //隐式内联 return contents[cursor]; &#125; //显示内联 inline char get(pos ht, pos wd) const; //能在之后被设为内联 Screen &amp;move(pos r, pos c);private: pos cursor = 0; pos height = 0, width = 0; std::string contents;&#125;; 我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。 重载成员函数类的成员函数同样支持重载。只要函数名相同，参数列表不同即可。 mutable属性如果一个成员变量被指明mutable属性，则无论对象是否为const，无论成员函数是否为const，该成员变量都可以被修改。我们给Screen定义一个mutable成员变量access_ctr，以及一个const成员函数some_member，并在该函数中修改access_ctr变量。 1234567891011121314151617181920212223242526272829class Screen&#123;public: typedef std::string::size_type pos; //因为Screen有另一个构造函数 //所以要实现一个默认构造函数 Screen() = default; // cursor被初始化为0 Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) &#123;&#125; //读取光标处字符 char get() const &#123; //隐式内联 return contents[cursor]; &#125; //显示内联 inline char get(pos ht, pos wd) const; //能在之后被设为内联 Screen &amp;move(pos r, pos c); void some_member() const;private: pos cursor = 0; pos height = 0, width = 0; std::string contents; //即使在一个const对象里access_ctr也可被修改 mutable size_t access_ctr;&#125;; 实现some_member的一个成员变量 1234void Screen::some_member() const&#123; //在const函数中也可以修改access_ctr ++access_ctr;&#125; 链式调用当我们通过成员函数内部返回*this，也就是类对象本身，则可以继续链式调用其内部的成员函数，比如我们通过重载实现两个set函数 1234567891011Screen &amp;Screen::set(char c)&#123; contents[cursor] = c; return *this;&#125;Screen &amp;Screen::set(pos r, pos col, char ch)&#123; //给定位置设置新值 contents[r * width + col] = ch; return *this;&#125; 链式调用 1234Screen::pos row = 3;Screen::pos col = 4;Screen screen(3, 4, &#x27;c&#x27;);screen.move(2, 3).set(&#x27;#&#x27;); 从const成员返回的*this是常量指针,如果我们实现一个display的const函数， 1234567const Screen &amp;Screen::display(ostream &amp;os) const&#123; os &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl; return *this;&#125; 如果按照如下链式调用编译器将报错,因为display返回const Screen&amp; 类型 1screen.display(cout).move(2, 3).set(&#x27;#&#x27;); 所以我们可以通过重载实现链式调用，实现一个返回const Screen &amp;类型的display函数和一个Screen &amp;类型的display函数,这两个display函数内部调用do_display函数，因为const函数只能调用const函数，所以我们先实现display函数，他是一个const函数 12345void Screen::do_display(ostream &amp;os) const&#123; os &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl;&#125; 再实现两个重载的display函数 1234567891011const Screen &amp;Screen::display(ostream &amp;os) const&#123; do_display(os); return *this;&#125;Screen &amp;Screen::display(ostream &amp;os)&#123; do_display(os); return *this;&#125; 这样编译器就会根据类型动态选择display的版本 1234Screen screen(3, 4, &#x27;c&#x27;);screen.display(cout).move(2, 3).set(&#x27;#&#x27;);const Screen cscreen(2, 1, &#x27; &#x27;);cscreen.display(cout); 类类型和声明1234567891011class First&#123; int memi; int getMem();&#125;;struct Second&#123; int memi; int getMem();&#125;; 如上我们定义了两个类型，下面的赋值会报错，因为类内的成员虽然一致，但是不同的类就是不同的类型 123First obj1;//编译报错，obj1和obj2不是一个类型 Second obj2 = obj1; 我们可以不定义类，先进行类的声明 1class Bags; 这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Bags是一种类类型。对于类型Bags来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Bags是一个类类型，但是不清楚它到底包含哪些成员。 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 直到类被定义之后数据成员才能被声明成这种类类型。我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针： 123456class Link_screen&#123; Screen window; Link_screen *next; Link_screen *prev;&#125;; 友元类和成员函数可以将一个类A声明为另一个类B的友元，则A类对象可以访问B类对象的私有成员。 1234567class Screen&#123;public: // Window_mgr可以访问Screen类的私有部分 friend class Window_mgr; //Screen类的其他部分......&#125;; Window_mgr类可以访问Screen类的私有成员，通过class前向声明了Window_mgr类。接下来我们定义Window_mgr类 12345678910111213141516171819class Window_mgr&#123;public: //窗口中每个屏幕的编号 using ScreenIndex = std::vector&lt;Screen&gt;::size_type; //按照编号将指定的Screen重置为空白 void clear(ScreenIndex);private: std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125;;void Window_mgr::clear(ScreenIndex i)&#123; // s是一个Screen的引用，指向我们想清空的屏幕 Screen &amp;s = screens[i]; //清空屏幕 s.contents = string(s.height * s.width, &#x27; &#x27;);&#125; 也可以让成员函数作为友元 1234567class Screen&#123;public: // Window_mgr可以访问Screen类的私有部分 friend void Window_mgr::clear(ScreenIndex); //Screen类的其他部分......&#125;; · 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。· 接下来定义Screen，包括对于clear的友元声明。· 最后定义clear，此时它才可以使用Screen的成员。 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中 源码链接https://gitee.com/secondtonone1/cpplearn我的公众号，谢谢关注","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"类基础","date":"2021-12-24T01:53:46.000Z","path":"2021/12/24/cpp10/","text":"类类就是对一类对象的抽象，比如鹦鹉，麻雀都是鸟，鸟就是类，而鹦鹉，麻雀等就是对象。我们期待实现一个Sales_data类，用来管理图书录入系统，通过录入Sales_data对象信息，达到统计销量和收入的目的。源码链接https://gitee.com/secondtonone1/cpplearn。如果我们实现Sales_data类，外部调用是这样的 123456789101112131415161718192021222324252627282930313233343536void dealSales()&#123; //保存当前求和结果的变量 Sales_data total; //读入第一笔交易 if (read(cin, total)) &#123; //保存下一条交易数据的变量 Sales_data trans; //读入下一条交易数据 while (read(cin, trans)) &#123; //判断isbn if (total.isbn() == trans.isbn()) &#123; //更新变量total的值 total.combine(trans); &#125; else &#123; //输出结果 print(cout, total) &lt;&lt; endl; // isbn号不一样，说明是新类型的书 // 处理新类型的书 total = trans; &#125; &#125; //输出最后一条交易 print(cout, total) &lt;&lt; endl; &#125; else &#123; //没有输出任何信息 cerr &lt;&lt; &quot;No data?!&quot; &lt;&lt; endl; &#125;&#125; Sales_data的接口应该包含以下操作：· 一个isbn成员函数，用于返回对象的ISBN编号· 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上· 一个名为add的函数，执行两个Sales_data对象的加法· 一个read函数，将数据从istream读入到Sales_data对象中· 一个print函数，将Sales_data对象的值输出到ostream我们定义Sales_data类如下 1234567891011121314151617181920212223242526272829303132#ifndef __CLASS_H__#define __CLASS_H__class Sales_data&#123;public: //通过default实现默认构造 // Sales_data() = default; //显示实现默认构造 Sales_data() : bookNo(&quot;&quot;), units_sold(0), revenue(0.0) &#123;&#125; // copy构造，根据Sales_data类型对象构造一个新对象 Sales_data(const Sales_data &amp;sa); //返回图书号 std::string isbn() const &#123; return bookNo; &#125; //获取平均单价 double avg_price() const; //将一个Sales_data对象合并到当前类对象 Sales_data &amp;combine(const Sales_data &amp;);private: //图书编号 std::string bookNo; //销量 unsigned units_sold = 0; //收入 double revenue = 0.0;&#125;;// Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern std::istream &amp;read(std::istream &amp;, Sales_data &amp;);extern void dealSales();#endif 接下来我们逐个部分介绍 成员函数isbn就是Sales_data类的成员函数，该函数返回类对象的bookNo，因为成员函数内部有一个隐藏的this指针形参, this指向了Sales_data对象，所以返回的是this-&gt;bookNo，this具体指向哪个Sales_data对象要看是谁调用的isbn，比如a.isbn()，那么this就指向&amp;a。对于普通成员函数，this的类型为Sales_data * const，因为编译器不允许我们在成员函数内部修改this的值。默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但它仍然需要遵循初始化规则。对于const成员函数，如isbn，this为const Sales_data * const类型，不允许通过*this修改其指向的对象。this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。所以常量对象，以及常量对象的引用或指针都只能调用常量成员函数。 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。所以isbn可以访问bookNo不会报错。当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员的名字必须包含它所属的类名。 1234567double Sales_data::avg_price() const&#123; if (units_sold) return revenue / units_sold; else return 0;&#125; 定义返回this对象的combine函数 1234567Sales_data &amp;Sales_data::combine(const Sales_data &amp;sa)&#123; this-&gt;units_sold += sa.units_sold; this-&gt;revenue += sa.revenue; //返回调用该函数的对象 return *this;&#125; 该函数一个值得关注的部分是它的返回类型和返回语句。一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回。 类相关非成员函数我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。 12345678910111213std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os;&#125;std::istream &amp;read(std::istream &amp;is, Sales_data &amp;item)&#123; double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; return is;&#125; 此时编译会报错，因为非成员函数访问了类对象的私有成员,我们通过private属性将Sales_data的成员对象定义为私有，所以非成员函数无法访问，所以可以在类的声明中声明友元函数 12friend std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);friend std::istream &amp;read(std::istream &amp;, Sales_data &amp;); 这样print和read声明为Sales_item类的友元函数，就代表其能访问Sales_item类的私有成员了。接下来我们同样定义add函数. 123456Sales_data add(const Sales_data &amp;sa1, const Sales_data &amp;sa2)&#123; Sales_data total = sa1; total.combine(sa2); return total;&#125; 因为combine是public成员函数，所以add不用声明为Sales_item类的友元函数.我们定义了一个新的Sales_data对象并将其命名为total。total将用于存放两笔交易的和，我们用sa1的副本来初始化total。默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。在拷贝工作完成之后，total的bookNo、units_sold和revenue将和sa1一致。接下来我们调用combine函数，将sa2的units_sold和revenue添加给total。最后，函数返回sum的副本。值得注意的是Sales_data total = sa1;调用了Sales_data类的copy构造函数，所以我们要实现Sales_data类的copy构造函数 123456Sales_data::Sales_data(const Sales_data &amp;sa)&#123; this-&gt;bookNo = sa.bookNo; this-&gt;revenue = sa.revenue; this-&gt;units_sold = sa.units_sold;&#125; 构造函数构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。不同于其他成员函数，构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。默认构造函数无须任何实参。默认构造函数在很多方面都有其特殊性。其中之一是，如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：· 如果存在类内的初始值，用它来初始化成员。· 否则，默认初始化该成员。 我的理解：如果我们定义了一个类，不写任何构造函数，那么系统会提供默认的构造函数，这时我们定义一个类对象会优先用类内的初始值初始化成员,比如我们注释掉Sales_data的两个构造函数，那么revenue成员会被初始化为0.0, units_sold会被初始化为0，因为类内有他们的初始值，而对于bookNo没有初始值，则执行默认的空值也就是空字符串赋值给bookNo。 某些类不能依赖于合成的默认构造函数对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的。如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。 在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。 对于有参数的构造函数，我们可以通过构造函数初始值列表进行初始化，构造函数初始值列表（constructor initialize list），它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。我们再为Sales_data添加几个带参数的构造函数 123Sales_data(const std::string &amp;s) : bookNo(s) &#123;&#125;Sales_data(const std::string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125; 我们再实现一个构造函数，其参数为ostream类型 1234Sales_data::Sales_data(std::istream &amp;is)&#123; read(is, *this);&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"函数","date":"2021-12-22T02:06:38.000Z","path":"2021/12/22/cpp09/","text":"函数一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内，如下就是一个函数的定义 123void funca()&#123; cout &lt;&lt; &quot;hello world!!!&quot; &lt;&lt; endl;&#125; 局部变量在C++语言中，名字有作用域，对象有生命周期（lifetime）。理解这两个概念非常重要。· 名字的作用域是程序文本的一部分，名字在其中可见。· 对象的生命周期是程序执行过程中该对象存在的一段时间。如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。 自动对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。函数形参和函数内部定义的普通变量都是自动对象。 局部静态对象某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。 1234567891011size_t count_calls()&#123; //调用结束后，这个值仍然有效 static size_t ctr = 0; return ++ctr;&#125;for (size_t i = 0; i != 10; ++i)&#123; cout &lt;&lt; count_calls() &lt;&lt; endl;&#125; 这段程序将输出从1到10（包括10在内）的数字。在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。局部静态变量赋初值只在第一次执行时赋初值的操作，以后再执行都不会进行赋初值的操作。而且生命周期随着程序结束才结束。 参数传递值传递函数的形参如果是非引用类型则是值传递,函数内部修改形参不会影响到外部实参的值 12345678void nochange(int a)&#123; a--; cout &lt;&lt; a &lt;&lt; endl;&#125; int m = 6; nochange(m); cout &lt;&lt; m &lt;&lt; endl; 程序输出5和6，在函数内部输出的是5，在函数外部输出的是6，可见值传递不会改变实参的值，如果要改变实参的值可以通过引用或者指针操作。 指针形参指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值 12345678void change(int *p)&#123; (*p)--; cout &lt;&lt; *p &lt;&lt; endl;&#125;int m = 6;change(&amp;m);cout &lt;&lt; m &lt;&lt; endl; 输出5，5p指向了m的地址，所以*p取到的是m的空间数据，这样就达到修改m的效果。 传引用参数函数参数为引用类型可以达到通过函数内部修改外部实参的效果，也可以减少传递参数造成的copy开销，拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 12345678void change(int &amp;ra)&#123; ra--; cout &lt;&lt; ra &lt;&lt; endl;&#125;int m = 6;change(m);cout &lt;&lt; m &lt;&lt; endl; 输出两个5，参数为引用类型，可以通过函数内部修改外部实参的值。我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用 1234bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125; 使用引用形参返回额外信息一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。 1234567891011121314151617181920string ::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)&#123; //第一次出现的位置(如果有的话) auto ret = s.size(); //设置表示出现次数的形参的值 occurs = 0; for (decltype(ret) i = 0; i != s.size(); ++i) &#123; if (s[i] == c) &#123; if (ret == s.size()) //记录c第一次出现的位置 ret = i; //出现的次数+1 ++occurs; &#125; &#125; return ret;&#125; 参数为数组当函数的参数为数组时，一般都显示传递一个数组的大小参数 123456789// const int ia[]等价于const int * ia// size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print_array(const int ia[], size_t size)&#123; for (size_t i = 0; i != size; ++i) &#123; cout &lt;&lt; ia[i] &lt;&lt; endl; &#125;&#125; 主函数可以这样调用 12int j[] = &#123;0, 1&#125;; print_array(j, end(j) - begin(j)); 数组引用形参12345678// arr是数组的引用，维度是类型的一部分void print_arrayref(int (&amp;arr)[10])&#123; for (auto elem : arr) &#123; cout &lt;&lt; elem &lt;&lt; endl; &#125;&#125; initializer_list形参如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组 12345678void error_msg(initializer_list&lt;string&gt; il)&#123; for (auto beg = il.begin(); beg != il.end(); beg++) &#123; cout &lt;&lt; *beg &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 返回值函数可以是void类型不返回数据，也可以是有返回值类型，但是不要返回局部变量的指针或者引用。如前所述，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。也可以返回引用类型，这样返回值就可以作为左值使用 12345678char &amp;get_val(string &amp;str, string::size_type ix)&#123; return str[ix];&#125; string s(&quot;a value&quot;); cout &lt;&lt; s &lt;&lt; endl; //输出a value //将s的第一个字母修改为A get_val(s, 0) = &#x27;A&#x27;; 返回值为数组的指针或引用因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。 123456// arrT是一个类型别名，他表示的类型含有10个整数数组typedef int arrT[10];// arrT的等价声明using arrT2 = int[10];// func返回一个指向含有10个整数的数组的指针arrT *func(int); 声明一个返回数组指针的函数如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示： 1Type (*function(parameter_list))[dimension] 举个具体点的例子，下面这个func函数的声明没有使用类型别名： 1int (*func(int i))[10]; · func（int i）表示调用func函数时需要一个int类型的实参。· （＊func（int i））意味着我们可以对函数调用的结果执行解引用操作。· （＊func（int i））[10]表示解引用func的调用将得到一个大小是10的数组。· int （＊func（int i））[10]表示数组中的元素是int类型。 尾置类型在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto： 123// func接受一个int类型的实参，返回值为一个指针//该指针指向含有10个整数的数组auto func(int i) -&gt; int (*)[10]; 使用decltype如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个： 12345678int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;//返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even;&#125; 函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。 123void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size); 利用const_cast实现两个返回最小字符串的函数 12345678910const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125;string &amp;shorterString(string &amp;s1, string &amp;s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2)); return const_cast&lt;string &amp;&gt;(r);&#125; 默认实参我们可以对函数形参设置默认值，如果不传实参，则用形参默认值 12typedef string::size_type sz;void screen(sz ht = 24, sz wh = 80, char back = &#x27; &#x27;); 我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。使用时可以 123456//函数形参分别为100,200,&#x27;a&#x27;screen(100,200,&#x27;a&#x27;);//函数形参分别为100,200,&#x27; &#x27;screen(100,200);//函数形参分别为24,80,&#x27; &#x27;screen(); 内联函数内联函数可避免函数调用的开销将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开constexpr函数（constexpr function）是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句： 12constexpr int new_sz() &#123; return 42; &#125;constexpr int foo = new_sz(); 执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。我们允许constexpr函数的返回值并非一个常量： 1constexpr size_t scale(size_t cnt) &#123; return new_sz() * cnt; &#125; 当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然： 123456//正确，scale(2)返回的是常量int arr[scale(2)];//i不是常量，scale返回的不是常量int i = 2;//编译器报错int arr2[scale(i)]; 函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 12// pf指向一个函数,该函数的参数是两个const string 的引用，返回bool类型bool (*pf)(const string &amp;, const string &amp;); 从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。＊pf两端的括号必不可少。如果不写这对括号，则pf2是一个返回值为bool指针的函数： 12//声明一个名为pf2的函数返回值类型为bool*bool *pf2(const string &amp;, const string &amp;); 虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名 1234// F是函数类型，不是指针using F = int(int *, int);// PF是指针类型using PF = int (*)(int *, int); f1,f2,f3都是返回函数指针的函数 123F *f1(int);PF f2(int);int (*f3(int))(int *, int); 对于f3的声明，按照由内向外的顺序阅读这条声明语句：我们看到f3有形参列表，所以f3是个函数；f3前面有*，所以f3返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。我们可以使用尾置声明 1234auto f4(int) -&gt; int (*)(int *, int);string::size_type sumLength(const string &amp;, const string &amp;);//根据形参取值，getFcn函数返回值为指向sumLength的指针decltype(sumLength) *getFcn(const string &amp;); 以下几种调用都是正常的 123456789using PF = int (*)(int *, int*);using F = int(int *, int *);PF test1 = &amp;test;PF test2 = test;F* test3 = test;test1(nullptr, nullptr);test2(nullptr, nullptr);(*test2)(nullptr, nullptr);test3(nullptr, nullptr);","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"多维数组","date":"2021-12-20T03:09:34.000Z","path":"2021/12/20/cpp08/","text":"数组的数组严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小： 12345678void multi_array()&#123; //大小为3的数组，每个元素是含有4个整数的数组 int ia[3][4]; //大小为10的数组,他的每个元素都是大小为20的数组 //这些数组的元素是含有30个整数的数组 int arr[10][20][30] = &#123;0&#125;;&#125; 多维数组初始化允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来： 1234567891011121314void multi_init()&#123; //三个元素，每个元素大小都是4的数组 int ia[3][4] = &#123; &#123;0, 1, 2, 3&#125;, &#123;4, 5, 6, 7&#125;, &#123;8, 9, 10, 11&#125;&#125;; //可以用一个花括号初始化二维数组 int ib[3][4] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;; //显示初始化每行的首元素 int ic[3][4] = &#123;&#123;0&#125;, &#123;4&#125;, &#123;8&#125;&#125;; //显示初始化第一行,其他元素被初始化为0 int id[3][4] = &#123;0, 3, 4, 6&#125;;&#125; 下标访问可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。 12345678910int arr[3][3][3] = &#123; 0, 1, 2, &#125;; //用arr的首元素为ia最后一行的最后一个元素赋值 int ia[3][4] = &#123;0&#125;; ia[2][3] = arr[0][0][0]; // row是一个ia第二个元素数组的引用，包含四个元素 int(&amp;row)[4] = ia[1]; 程序中经常会用到两层嵌套的for循环来处理多维数组的元素 123456789101112 int ia[rowCnt][colCnt]=&#123;0&#125;;//遍历 constexpr size_t rowCnt = 3, colCnt = 4; for (size_t i = 0; i != rowCnt; ++i) &#123; //对于行内的每一列 for (size_t j = 0; j != colCnt; ++j) &#123; //将元素的位置索引作为他的值 ia[i][j] = i * colCnt + j; &#125; &#125; 可以使用范围 for语句处理多维数组,由于在C++11新标准中新增了范围for语句，所以前一个程序可以简化为如下形式： 12345678size_t cnt = 0; for (auto &amp;row : ia) &#123; for (auto &amp;col : row) &#123; col = cnt++; &#125; &#125; 因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环 1234567for (auto &amp;row : ia) &#123; for (auto col : row) &#123; cout &lt;&lt; col &lt;&lt; endl; &#125; &#125; 这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针,假设不用引用类型，则循环如下述形式： 1234567 for (auto row : ia)&#123; for (auto col : row) &#123; cout &lt;&lt; col &lt;&lt; endl; &#125;&#125; 程序将无法通过编译。这是因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊，显然内层的循环就不合法了，编译器将试图在一个int＊内遍历，这显然和程序的初衷相去甚远。要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 指针和多维数组当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针： 123456789void multi_pointer()&#123; //大小为3的数组，每个元素是含有4个整数的数组 int ia[3][4]; // p指向含有4个整数的数组 int(*p)[4] = ia; // p指向ia的尾元素 p = &amp;ia[2];&#125; 我们首先明确（＊p）意味着p是一个指针。接着观察右边发现，指针p所指的是一个维度为4的数组；再观察左边知道，数组中的元素是整数。因此，p就是指向含有4个整数的数组的指针。在上述声明中，圆括号必不可少： 1234//整数指针的数组 int *ib[4]; //指向含有4个整数的数组 int(*ib)[4]; 随着C++11新标准的提出，通过使用auto或者decltype,就能尽可能地避免在数组前面加上一个指针类型了： 12345678910// p指向一个含有4个整数的数组 for (auto p = ia; p != ia + 3; ++p) &#123; // q指向4个整数数组的首元素，也就是说q指向一个整数 for (auto q = *p; q != *p + 4; q++) &#123; cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; 外层的for循环首先声明一个指针p并令其指向ia的第一个内层数组，然后依次迭代直到ia的全部3行都处理完为止。其中递增运算++p负责将指针p移动到ia的下一行。内层的for循环负责输出内层数组所包含的值。它首先令指针q指向p当前所在行的第一个元素。＊p是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指向该数组首元素的指针。内层for循环不断迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层for循环的终止条件，再一次解引用p得到指向内层数组首元素的指针，给它加上4就得到了终止条件。当然，使用标准库函数begin和end也能实现同样的功能，而且看起来更简洁一些： 123456789101112// p指向ia的第一个数组 for (auto p = begin(ia); p != end(ia); p++) &#123; // q指向内层数组的首元素 for (auto q = begin(*p); q != end(*p); q++) &#123; //输出q所指的整数 cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; 循环终止条件由end函数负责判断。虽然我们也能推断出p的类型是指向含有4个整数的数组的指针，q的类型是指向整数的指针，但是使用auto关键字我们就不必再烦心这些类型到底是什么了。 类型别名简化多维数组的指针可以通过typedef和using等关键字定义类型 12345678// C11新标准定义类型别名// int_array 是一个包含四个元素的整形数组类型using int_array = int[4];//等价的typedef声明// int_array_same 是一个包含四个元素的整形数组类型typedef int int_array_same[4];//如果不会用typedef定义数组类型，可以先定义一个数组变量int int_array_inst[4]; 如果不会用typedef定义数组类型，可以先定义一个数组变量 1int int_array_inst[4]; 然后加上typedef即可 1typedef int int_array_inst[4]; 此时int_array_inst就是一个大小为4的整形数组类型。通过类型定义，我们重新实现遍历 12345678910int ia[3][4];//输出ia中每个元素的值，每个内层数组各占一行for (int_array *p = ia; p != ia + 3; p++)&#123; for (int *q = *p; q != *p + 4; q++) &#123; cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"数组","date":"2021-12-16T08:18:58.000Z","path":"2021/12/16/cpp07/","text":"数组数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。 数组初始化初始化数组要指定大小，如果不指定维度系统会根据初始化列表自动设置数组大小，但是不要将数组数组的大小小于列表长度，否则编译器会报错。 123456789101112131415161718192021222324252627282930void arrary_init()&#123; //不是常量表达式 unsigned cnt = 42; //常量表达式 constexpr unsigned sz = 42; //常量表达式 const unsigned usz = 42; //包含10个整数 int arr[10]; //含有42个整形指针的数组 int *parr[sz]; //含有42个string的数组 string strvec[usz]; //含有42个int的数组 string invec[get_size()]; // 编译报错,因为cnt不是常量表达式 // string bad[cnt]; const unsigned msz = 3; //含有3个元素的数组，元素值分别为0,1,2 int ia1[msz] = &#123;0, 1, 2&#125;; //维度是3的数组 int a2[] = &#123;0, 1, 2&#125;; //等价于a3[] = &#123;0,1,2,0,0&#125; int a3[5] = &#123;0, 1, 2&#125;; //等价于a4[] = &#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125; string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; //错误，初始值过多 // string a5[2] = &#123;0, 1, 2&#125;;&#125; 错误操作不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： 123456//含有3个整数的数组 int a[] = &#123;0,1,2&#125;; //不允许用一个数组初始化另一个数组 int a2[] = a; //不能把一个数组直接赋值给另一个数组 a2 = a; 复杂声明和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了： 123456789101112void dif_array()&#123; // ptrs是含有10个整形指针的数组 int *ptrs[10]; //不存在引用的数组 // int &amp;refs[10] = /*?*/; int arr[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // 数组的引用 arrRef是arr的引用 int(&amp;arrRef)[10] = arr; // Parray指向一个含有10个整数的数组 int(*Parray)[10] = &amp;arr;&#125; 数组访问和vector一样，数组也支持下标访问和遍历访问 123456789101112131415161718192021void visit_array()&#123; //以10分为一个分数段统计成绩，0~9，10~19...，90~99,100 // 11 个分数段，全部初始化为0 unsigned scores[11] = &#123;&#125;; unsigned grade; while (cin &gt;&gt; grade) &#123; if (grade &lt;= 100) &#123; ++scores[grade / 10]; &#125; &#125; //通过for range 遍历打印 for (auto i : scores) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针： 1234//数组的元素是string元素 string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; // p指向nums的第一个元素 string *p = &amp;nums[0]; 在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组： 123456// ia是一个含有10个整数的数组int ia[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// ia2是一个整数型指针，指向ia第一个元素auto ia2(ia);//错误：ia2是一个指针，不能用int值给指针赋值// ia2 = 42; 尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式： 12ia2是int*类型auto ia2(&amp;ia[0]); 必须指出的是，当使用decltype关键字时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组： 1234567// ia3是一个含有10个整数的数组 decltype(ia) ia3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int *pint = nullptr; //错误，不能用整形指针给数组赋值 // ia3 = pint; //正确，可以对数组的元素赋值 ia3[4] = 1024; 指针也是迭代器就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针；不过获取尾后指针就要用到数组的另外一个特殊性质了。 123int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int *p = arr; // p指向arr的第一个元素++p; // p指向arr[1] 我们可以设法获取数组尾元素之后的那个并不存在的元素的地址： 1int *e = &amp;arr[10]; //指向arr尾元素的下一个位置的指针 这里显然使用下标运算符索引了一个不存在的元素，arr有10个元素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。所以我们利用指针的末尾元素可以实现另一种方式的遍历 12for (int *b = arr; b != e; ++b) cout &lt;&lt; *b &lt;&lt; endl; 数组也支持sizeof操作sizeof计算的是数组所占用的空间,除以sizeof(int)，得到的就是数组的长度，所以数组的遍历可以这样 1234for (int i = 0; i &lt; sizeof(arr) / sizeof(int); i++)&#123; cout &lt;&lt; arr[i] &lt;&lt; endl;&#125; 标准库函数begin尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数： 123456789// beg指向arr第一个元素 int *beg = begin(arr); // last指向arr最后一个元素的下一个位置 int *last = end(arr); while (beg != last) &#123; cout &lt;&lt; *beg &lt;&lt; endl; beg++; &#125; 通过begin和end函数获取数组第一个元素地址和最后一个元素的下一个位置，然后实现遍历，非常安全 指针运算指向数组元素的指针包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置： 12345int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;//等价于int *p = &amp;arr[0]int *ip = arr;//等价于ip2指向arr的第四个元素int *ip2 = ip + 4; 另外一种计算数组元素个数的方式 123456 int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// beg指向arr第一个元素 int *beg = begin(arr); // last指向arr最后一个元素的下一个位置 int *last = end(arr); int length = last - beg; C风格字符串C风格字符串被C++包含在cstring头文件里,包括strcmp字符串比较，strcpy字符串copy，strcat字符串连接比较字符串 12345678910const char cal1[] = &quot;A string example&quot;;const char cal2[] = &quot;A different string&quot;;if (strcmp(cal1, cal2) &lt; 0)&#123; cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;&#125;else&#123; cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;&#125; 字符串连接字符串的连接用到了memset清空操作，以及strcpy, strcat等操作，大家看看就好不用深入理解，这是C语言的方式 12345678910111213141516171819202122232425262728293031void c_string()&#123; const char cal1[] = &quot;A string example&quot;; const char cal2[] = &quot;A different string&quot;; if (strcmp(cal1, cal2) &lt; 0) &#123; cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl; &#125; const int total_len = strlen(cal1) + strlen(cal2) + 1; //开辟total_len字节的空间 char *total_str = new char(total_len); //将空间清空为0 memset(total_str, 0, total_len); //将cal1 copy 到 total_str strcpy(total_str, cal1); //将total_str和cal2连接 strcat(total_str, cal2); //输出total_str 的值 cout &lt;&lt; &quot;total_str is &quot; &lt;&lt; total_str &lt;&lt; endl; //最后释放内存 if (total_str != nullptr) &#123; delete total_str; total_str = nullptr; &#125;&#125; 习惯使用C语言的同学可以通过c_str()函数将string转化为const char*类型的字符串 12string strcpp = &quot;CPP&quot;;const char *strc = strcpp.c_str(); 使用数组初始化vector对象vector除了可以通过初始化列表，指定初始值和大小等方式外，还可以通过数组和vector初始化通过vector初始化 123456vector&lt;int&gt; v1 = &#123;1, 3, 5, 7, 9&#125;;vector&lt;int&gt; v2(v1);for (auto v : v2)&#123; cout &lt;&lt; v &lt;&lt; endl;&#125; 通过数组初始化 12345678910void vector_init2()&#123; int a[] = &#123;2, 4, 6, 8, 10&#125;; vector&lt;int&gt; v3(begin(a), end(a)); for (auto v : v3) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125;&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"迭代器","date":"2021-12-16T03:18:50.000Z","path":"2021/12/16/cpp06/","text":"迭代器当我们要遍历容器如vector,map等复杂结构时，可以通过迭代器进行遍历，依次取出容器中的值。通过容器类的begin()和end()函数获取指向第一个元素位置的迭代器和指向最后一个元素下一个位置的迭代器。迭代器初步使用 123456789void iterator_func()&#123; string s(&quot;some string&quot;); if (s.begin() != s.end()) &#123; auto it = s.begin(); *it = toupper(*it); &#125;&#125; 上面代码修改了字符串第一个字母为大写。只有当字符串为空时s.begin()==s.end() 迭代器运算迭代器支持加减运算，支持比较运算 123456789*iter 返回iter所指对象得引用iter-&gt;mem 解引用返回iter所指对象得mem成员++iter 迭代器位置后移，指向下一个元素--iter 迭代器位置前移，指向上一个元素iter1 == iter2 判断iter1和iter2是否相等iter1 != iter2 判断iter1和iter2不相等iter = iter + n 迭代器iter向后偏移n个元素iter = iter -n 迭代器iter 向前偏移n个元素iter1 &gt;= iter2 迭代器iter1指向的元素是否在iter2之后 迭代器遍历通过迭代器修改第一个单词为大写，遇到空格或者字符串末尾结束 1234567string s(&quot;some string&quot;);for (auto iter = s.begin(); iter != s.end() &amp;&amp; !isspace(*iter); iter++)&#123; *iter = toupper(*iter);&#125;cout &lt;&lt; &quot;str is &quot; &lt;&lt; s &lt;&lt; endl; 通过iter++依次访问s中得每个字符，*iter返回的是每个字符的引用 泛型编程关键概念：泛型编程原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非&lt;进行判断有点儿奇怪，。C++程序员习惯性地使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用的到底是哪种容器类型。 迭代器类型那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。 123456789101112131415161718// it能读写vector&lt;int&gt;的元素 vector&lt;int&gt;::iterator it; // it2能读写string对象中的字符 vector&lt;string&gt;::iterator it2; // it3 只能读元素,不能写元素 vector&lt;int&gt;::const_iterator it3; // it4 只能读字符，不能写字符 vector&lt;string&gt;::const_iterator it4; vector&lt;int&gt; v; const vector&lt;int&gt; cv; // vit1的类型是vector&lt;int&gt;::iterator auto vit1 = v.begin(); // vit2的类型是vector&lt;int&gt;::const_iterator auto vit2 = cv.begin(); //通过cbegin和cend可以获取常量迭代器 // cvit 类型为vector&lt;int&gt;::const_iterator auto cvit = v.cbegin(); 解引用迭代器解引用要注意将*和迭代器括起来，因为*的优先级比.低，假设iter是vector&lt;string&gt;::iterator类型判断迭代器所指向的字符串是否为空应该用(*iter).empty()如果用*iter.empty()会被编译器理解为对迭代器先进行empty()函数运算再解引用，会报错，因为迭代器没有empty()操作为了方便可以通过-&gt;解引用取出元素的成员或者成员函数，如下我们通过遍历，直到遇到空字符串就退出遍历 12345678vector&lt;string&gt; text = &#123;&quot;zack&quot;, &quot;vivo&quot;, &quot;&quot;, &quot;lisus&quot;&#125;;for (auto it = text.begin(); it != text.end() &amp;&amp; !it-&gt;empty(); ++it)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125; 迭代器失效在通过迭代器遍历vector,string ,map等容器时，如果遍历的循环中添加元素或者删除元素会导致迭代器失效，因为添加元素或者删除元素会影响迭代器的值，可以通过如下方式在遍历的同时删除元素 12345678910auto itdel = text.begin();while (itdel != text.end())&#123; if (itdel-&gt;empty()) &#123; itdel = text.erase(itdel); continue; &#125; itdel++;&#125; text.erase(itdel)返回的时下一个元素的迭代器，所以直接跳出本次循环继续遍历即可。 二分查找迭代器可以做加减操作，所以我们用迭代器实现一个二分查找, orderv是一个vector,里面的数字是有序的，我们查找9 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; orderv = &#123;1, 2, 3, 5, 6, 8, 9, 10&#125;;bool bfind = false;auto findit = orderv.begin();auto beginit = orderv.begin();auto endit = orderv.end();while (beginit != endit)&#123; auto midit = beginit + (endit - beginit) / 2; if (*midit == 9) &#123; findit = midit; bfind = true; break; &#125; if (*midit &gt; 9) &#123; endit = midit - 1; &#125; if (*midit &lt; 9) &#123; beginit = midit + 1; &#125;&#125;if (bfind)&#123; cout &lt;&lt; &quot;find success, iter val is &quot; &lt;&lt; *findit &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"vector类","date":"2021-12-15T07:51:06.000Z","path":"2021/12/15/cpp05/","text":"简介本文介绍vector的使用方法，vector是一种高效访问和修改的容器，支持遍历，索引访问。 初始化1 用花括号进行列表初始化2 可以用()指定初始值和个数初始化 123456789101112131415void vector_init()&#123; //列表初始化 vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; //错误用法 // vector&lt;string&gt; v2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); //初始化vector大小为10，每个元素为-1 vector&lt;int&gt; ivec(10, -1); // 10个string类型的元素,每个都是hi vector&lt;string&gt; svec(10, &quot;hi!&quot;); // 10个元素，每个都初始化为0 vector&lt;int&gt; ivec2(10); // 10个元素，每个都初始化为空string vector&lt;string&gt; svec2(10);&#125; 添加元素123456//利用push_back将元素添加到vector末尾vector&lt;int&gt; v2;for (int i = 0; i != 100; ++i)&#123; v2.push_back(i);&#125; 遍历访问1234567891011 // 求vector 每个元素平方值vector&lt;int&gt; v3&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;for (auto &amp;i : v3)&#123; i *= i;&#125;for (auto i : v3)&#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl; 下标访问123456789101112//索引访问// 11个分数段，全部初始化为0vector&lt;unsigned&gt; scores(11, 0);unsigned grade;//读取成绩while (cin &gt;&gt; grade)&#123; //只处理有效成绩，小于等于100的成绩 if (grade &lt;= 100) //对应的分数段+1，修改索引对应的元素值 ++scores[grade / 10];&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"string类","date":"2021-12-13T08:35:43.000Z","path":"2021/12/13/cpp04/","text":"简介今天介绍string类的使用 初始化和定义123456789//默认初始化,s1是一个空字符串string s1;//赋值初始化,s2是s1的副本string s2 = s1;//直接初始化 字面值初始化string s3 = &quot;hiya&quot;;//直接初始化 构造函数初始化string s4(10, &#x27;c&#x27;);string s5(&quot;hello zack&quot;); string操作12345678910111213141516171819202122232425262728293031323334353637383940414243void opstr_func()&#123; //定义空字符串 string s; //从输入流写入s cin &gt;&gt; s; //将s写入输出流 cout &lt;&lt; s &lt;&lt; endl; //循环读取，直到遇到换行符或者非法输入 string world; while (cin &gt;&gt; world) cout &lt;&lt; world &lt;&lt; endl; //读取一整行 string linestr; while (getline(cin, linestr)) &#123; cout &lt;&lt; linestr &lt;&lt; endl; &#125; //每次读入一整行，遇到空行跳过 while (getline(cin, linestr)) &#123; if (!linestr.empty()) &#123; cout &lt;&lt; linestr &lt;&lt; endl; //打印字符串长度 cout &lt;&lt; linestr.size() &lt;&lt; endl; // size()返回string::size_type类型的数据 string::size_type size = linestr.size(); &#125; &#125; // 比较 string str1 = &quot;Hello&quot;; string str2 = &quot;Hello W&quot;; string str3 = &quot;Za&quot;; //依次比较每个字符，字符大的字符串就大 auto b2 = str3 &gt; str1; cout &lt;&lt; b2 &lt;&lt; endl; //前面字符相同，长度长的字符串大 auto b = str2 &gt; str1; cout &lt;&lt; b &lt;&lt; endl;&#125; string 类重载了 比较运算符，也重载了+运算符等,所以string支持+运算 123456// string类对象相加string s1 = &quot;Hello&quot;, s2 = &quot;Zack&quot;;string s3 = s1 + &quot;,&quot; + s2 + &#x27;\\n&#x27;;cout &lt;&lt; s3 &lt;&lt; endl;//加号两侧至少有一个是string类型，否则报错// string s4 = &quot;Hello&quot; + &quot;Zack&quot;; 对C语言的兼容建议：使用C++版本的C标准库头文件C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。 C11用法如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for（rangefor）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是： 12for(declaration:expression) statement 其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分。举一个简单的例子，我们可以使用范围for语句把string对象中的字符每行一个输出出来： 123456string str(&quot;hello zack&quot;); //遍历输出str中的每个字符for (auto c : str)&#123; cout &lt;&lt; c &lt;&lt; endl;&#125; 统计字符串中标点符号的数量 1234567891011string s(&quot;Hello World!!!&quot;);decltype(s.size()) punct_cnt = 0;//统计s中标点符号的数量for (auto c : s)&#123; if (ispunct(c)) punct_cnt++;&#125;cout &lt;&lt; punct_cnt &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt; endl; 将字符串变为大写 12345678//将字符串变为大写string s3(&quot;Hello Vivo&quot;);for (auto &amp;c : s3)&#123; //通过引用string中的字符，然后修改字符 c = toupper(c);&#125;cout &lt;&lt; s &lt;&lt; endl; 将第一个单词变为大写 1234567//通过下标索引修改字符串//把第一个单词变为大写string sind(&quot;some string&quot;);for (decltype(sind.size()) index = 0; index != sind.size() &amp;&amp; isspace(sind[index]); ++index)&#123; sind[index] = toupper(sind[index]);&#125;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"输入输出流和变量","date":"2021-12-10T09:18:31.000Z","path":"2021/12/10/cpp03/","text":"简介本节介绍C++输入输出流和基本的变量 iostreamC++提供了标准的输入和输出流功能,要包含iostream头文件，就可以使用cin和cout了cin表示输入，cout表示输出，下面是使用案例 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void cin_func()&#123; string input; cout &lt;&lt; &quot;input your words &quot; &lt;&lt; endl; cin &gt;&gt; input; cout &lt;&lt; &quot;your input is &quot; &lt;&lt; endl; cout &lt;&lt; input &lt;&lt; endl;&#125; 程序输出 1234input your wordszackyour input iszack &gt;&gt; 会获取输入写入缓存,并返回cin对象，&lt;&lt;会从缓存中读取数据写入cout并返回cout,最后endl会将cout缓存中的数据输出到终端。 变量12345678910111213141516171819void var_func()&#123; //整形，4字节 int a = 100; //ll整形, 8字节 long long lla = 1000; //长整型， 4 字节 long la = 1024; //短整型,2 字节 short sa = 200; //带符号字符型, //字符型使用时最好指示带符号还是不带符号 //因为在不同的机器上不指明char符号可能会有问题 signed char sc = &#x27;a&#x27;; //无符号字符型 unsigned char uc = &#x27;m&#x27;; //bool类型 bool bt = true;&#125; 类型转换当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 12345bool b = 42; //b为trueint i = b; //i 为1i = 3.14; //i 为3double pi = i; //pi为3.0unsigned char c = -1; // 变量的声明和定义用extern在头文件声明，在cpp中定义，可以保证变量不会被重复包含 12//只声明aextern int a; 如果extern后边做了赋值操作，则不是声明而是定义 1extern int a= 100; 不带extern 直接类型+ 变量名就是定义 123//如下都是定义int age = 100;int num ; 引用引用就是变量的别名，通过修改引用达到修改变量的值的目的 12345int j = 20;// i 是j的引用int &amp;i = j;j = 200;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; 指针指针值指针的值（即地址）应属下列4种状态之一：1.指向一个对象。2.指向紧邻对象所占空间的下一个位置。3.空指针，意味着指针没有指向任何对象。4.无效指针，也就是上述情况之外的其他值。 通过对指针的值做解引用(*)，拿到其指向的值，再修改这个值，达到修改指向对象数据的目的 1234567void piont_func()&#123; int age = 18; int *page = &amp;age; *page += 2; cout &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; page &lt;&lt; endl;&#125; 指向指针的引用12345678910111213void poinref_func()&#123; int i = 42; // p是一个指针 int *p; // r 是一个对p的引用 int *&amp;r = p; // 令r指向了一个指针p //给r赋值为&amp;i,就是p指向了i r = &amp;i; //解引用r得到i,也就是p指向的对象，将i的值修改为0 *r = 0;&#125; 常量12345678910111213141516171819202122232425262728293031void const_func()&#123; // 常量定义一定要初始化赋值，否则编译报错 const int bufSize = 512; //修改bufSize的值会报错 //编译器提示表达式必须是可修改的左值 // bufSize = 222; //运行时初始化 const int i = get_size(); //编译时初始化 const int j = 43; //如果定义const变量不初始化也会报错 // const int k; //利用一个常量初始化另一个常量 const int cj = j; // const引用,引用及其对应的对象都是const const int &amp;r1 = cj; //不可以修改r1的值 // r1 = 42; //不可以用非常量引用指向一个常量对象 // int &amp;r2 = ci; int iv = 42; //允许将const int&amp;绑定到一个普通int对象上 const int &amp;r1 = iv; //正确, r2是一个常量引用 const int &amp;r2 = 42; //正确, r3是一个常量引用 const int &amp;r3 = r1 * 2; //错误, r4 是一个普通非常量的引用 // int &amp;r4 = r1 * 2;&#125; 指向常量的指针指向常量的指针不可以通过指针修改指向内容的数据 1234567891011121314void pconst_func()&#123; //指向常量的指针 const double pi = 3.14; //不可以用普通指针指向常量 // double *ptr = &amp;pi; //用常量指针指向常量 const double *cptr = &amp;pi; //不能给*cptr赋值因为cptr指向的是常量 // *cptr = 42; //指向常量的指针指向非常量 double dval = 3.14; cptr = &amp;dval;&#125; 常量指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值 123456789101112//常量指针//常量指针的值初始化后就不允许修改int errNumb = 0;// curErr将一直指向errNumbint *const curErr = &amp;errNumb;//不允许修改curErr的指向int rightNumb = 1;//编译报错，提示=左侧必须为可修改的左值// curErr = &amp;rightNumb;const double pi = 3.14159;// pip是一个指向常量对象的常量指针const double *const pip = &amp;pi; 顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-levelconst）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const constexper变量在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿 C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化： 123456789void constexpr_func()&#123; // 20是一个常量表达式 constexpr int mf = 20; // mf + 1是一个常量表达式 constexpr int limit = mf + 1; // size是一个constexpr函数 constexpr int sizen = size();&#125; 尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 指针和constexpr在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。 1234567void pointer_constexpr()&#123; // p是一个指向整形常量的指针,p可以修改，但是*P不可修改 const int *p = nullptr; // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改 constexpr int *q = nullptr;&#125; p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量： 12345678910111213141516171819int j = 0;// i 的类型是整型常量constexpr int i = 42;void pointer_constexpr()&#123; // p是一个指向整形常量的指针,p可以修改，但是*P不可修改 const int *p = nullptr; // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改 constexpr int *q = nullptr; // np是一个指向整数的常量指针，其中为空 constexpr int *np = nullptr; // i和j必须定义在函数体之外，否则报错，提示p访问运行时存储 //因为constexpr要求表达式为常量，在编译时展开 // p是常量指针，指向整形常量i constexpr const int *p2 = &amp;i; // p1是常量指针，指向整数j constexpr int *p1 = &amp;j;&#125; 类型别名类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。有两种方法可用于定义类型别名。传统的方法是使用关键字typedef：1 typedef 12345678910void typedef_func()&#123; // wages是double的同义词 typedef double wages; // base是double的同义词， p 是double*的同义词 typedef wages base, *p; // C11用法 using newd = double; newd dd = 3.14;&#125; 新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名, using newd = double就是通过using定义newd类型和double是相同的。 如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char＊的别名 12345678910111213141516void typedef_func()&#123; typedef char *pstring; // pstring是一个指向char的常量指针 const pstring cstr = 0; // ps 是一个指针，其对象是指向char的常量指针 const pstring *ps; char b = &#x27;H&#x27;; //不可修改 // cstr = &amp;b; ps = &amp;cstr; const pstring cstr2 = &amp;b; ps = &amp;cstr2; //不可修改*ps的值 // *ps = cstr;&#125; auto 推导编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值.使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样. 123456789101112131415161718192021void auto_func()&#123; int a = 100; int b = 1024; // c被推导为int类型 auto c = a + b; auto i = 0, *p = &amp;i; //一条声明语句只能有一个基本数据类型 //不同类型编译器会报错 // auto sz = 0, pi = 3.14; const int ma = 1; // auto会忽略顶层const //可以通过const明确指出，此时f为const int类型 const auto f = ma; // auto配合引用类型 auto &amp;g = a; // 不能为非常量引用绑定字面值 // auto &amp;h = 42; //指明const 引用绑定字面值 const auto &amp;j = 42;&#125; auto一般会忽略掉顶层const（参见2.4.3节，第57页），同时底层const则会保留下来要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型： 12345678// k是int类型，l是int的引用// auto 忽略了顶层constauto k = ci, &amp;l = i;// m是int常量的引用，p是指向int常量的指针// auto保留了底层constauto &amp;m = ci, *p = &amp;ci;// 错误 i的类型是int， ci的类型是 const int// auto &amp;n = i, *p2 = &amp;ci; decltype类型指示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值： 1decltype(size()) sum; 编译器并不实际调用函数size，而是使用当调用发生时size的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如size被调用的话将会返回的那个类型。decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）： 1234567891011void decltype_func()&#123; decltype(size()) sum; const int ci = 0, &amp;cj = ci; // x的类型是const int decltype(ci) x = 0; // y的类型是 const int&amp; , y绑定到变量x decltype(cj) y = x; //错误，z是一个引用，必须初始化 // decltype(cj) z;&#125; 因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型. 1234567int i = 42, *p = &amp;i, &amp;r = i;// b1 是一个int类型的引用decltype(r) b1 = i;// r+0 通过decltype返回int类型decltype(r + 0) b2;//错误，必须初始化,c是int&amp;类型// decltype(*p) c;","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"vscode搭建windows C++开发环境","date":"2021-12-10T07:33:02.000Z","path":"2021/12/10/cpp02/","text":"简介本文介绍如何在windows环境下，通过vscode搭建C++的开发环境需要准备如下文件1 vscode 软件2 安装vscode开发插件3 MinGW 安装vscode下载地址选择Download for windows 就可以了 安装vscode插件安装好vscode后打开，选择左侧应用扩展或者按住Ctrl + shift + x 唤出扩展应用界面，输入C++，选择C++插件安装 安装MinGW下载地址：https://sourceforge.net/projects/mingw-w64/files/如果下载速度慢，可以去网盘下载链接: https://pan.baidu.com/s/1rAJNlB-iqC950lf-6tImGg提取码: h1zm 下载的文件：进入网站后不要点击 “Download Lasted Version”，往下滑，找到最新版的 “x86_64-posix-seh”。安装MinGW：下载后是一个7z的压缩包，解压后移动到你想安装的位置即可。我的安装位置是：D:\\cppsoft\\mingw64 配置环境变量把安装目录D:\\cppsoft\\mingw64 配置在用户的环境变量path里即可选择用户环境变量path点击后添加D:\\cppsoft\\mingw64点确定保存后开启cmd输入g++,如提示no input files 则说明Mingw64 安装成功,如果提示’g++’ 不是内部或外部命令，也不是可运行的程序或批处理文件则说明安装失败 配置vscode我的项目结构是这样的，inc文件夹下为.h文件 src文件夹下为.cpp文件选中main.cpp文件，单击左侧三角形，会进入调试界面添加配置环境，选择C ++ windows 就会自动生成launch.json文件我们修改launch.json文件 如下 1234567891011121314151617181920212223242526&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //修改此项，让其弹出终端 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\cppsoft\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;task g++&quot; //修改此项 &#125; ]&#125; 我将 miDebuggerPath 配置为 “D:\\cppsoft\\mingw64\\bin\\gdb.exe”你们配置为自己的mingw路径就好我将 preLaunchTask 设置为 “task g++” 这个名字可以随便取也可以用默认的此时再次点击三角形或者F5运行会提示没有task文件，vscode会自动生成task.json文件编辑task.json文件，配置如下 123456789101112131415161718192021222324&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;task g++&quot;, //修改此项 &quot;command&quot;: &quot;D:\\\\cppsoft\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, // &quot;$&#123;file&#125;&quot;, &quot;$&#123;cwd&#125;//src//*.cpp&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\cppsoft\\\\mingw64\\\\bin&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &quot;build&quot; &#125; ]&#125; 我在args中添加了src文件目录，这样就可以编译多个cpp文件同时设置label为”task g++”,这个和lauch.json中preLaunchTask 对应options 设置cwd为自己的mingw路径再次运行，可以看到弹出对话框显示程序执行结果如果还是有配置不明白的地方，可以看 https://gitee.com/secondtonone1/cpplearn","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"defer和panic","date":"2021-12-08T06:56:05.000Z","path":"2021/12/08/golang42/","text":"简介今天谈谈go的两个特性，defer和panic, defer在函数return 时，将返回值压入栈，然后执行defer函数，最后返回。panic是手动触发崩溃的一种策略，可以在panic本层的函数实现defer函数，在defer里通过recover捕获该层崩溃，如果本层崩溃未被捕获，则交由上一层捕获。 defer机制和使用一个函数定义了多个defer函数，defer的调用顺序和栈一样，先进后出，最先调用的是最后写的defer。函数将返回值入栈，然后执行析构，在析构之前要执行defer的操作。defer使用的注意事项 defer常用来释放变量我们实现一个文件copy函数，将src路径下的文件copy到dst路径下 1234567891011121314func CopyFile(dst, src string) (written int64, err error)&#123; srcF, err := os.Open(src) if err != nil&#123; return &#125; defer srcF.Close() dstF, err := os.Create(dst) if err != nil&#123; return &#125; defer dstF.Close() return io.Copy(dstF, srcF)&#125; 注意，如果Open失败或者Create失败，千万不要调用src.Close，因为src为nil。 defer被声明时，其参数是实时解析和捕获1234567func DeferParam() &#123; i := 0 defer func(m int) &#123; log.Println(m) &#125;(i) i++&#125; 程序输出0，因为defer声明时捕获i的值为0，传入函数后输出也是0，不管以后i变成什么值。如果defer是无参函数，内部引用了外部变量，就不同了，会记录i的引用 12345678func DeferNoParam() &#123; i := 0 defer func() &#123; log.Println(i) &#125;() i++&#125; 最后i变为什么值，defer就输出什么值。此时输出值为1 defer调用顺序为栈式调用1234567func DeferOrder() &#123; for i := 0; i &lt; 5; i++ &#123; defer func(m int) &#123; log.Println(m) &#125;(i) &#125;&#125; 输出结果为4，3，2，1，0 defer可以捕获函数返回值因为defer可以捕获函数内变量，所以可以捕获函数的返回值 12345678func DeferReturn() (res int) &#123; defer func() &#123; res++ log.Println(res) &#125;() return 0&#125; defer输出为1，因为defer捕获到返回值为0，+1就输出1 defer链式调用defer 只能执行一个函数，defer是栈式调用，后入先出规则。当defer执行链式操作时，前边的表达式都会优先求值，只有最后一个表达式入栈延迟执行。 12345678910111213141516type Slice []intfunc NewSlice() *Slice &#123; slice := make(Slice, 0) return &amp;slice&#125;func (s *Slice) AddSlice(val int) *Slice &#123; *s = append(*s, val) log.Println(val) return s&#125;s := NewSlice()defer s.AddSlice(1).AddSlice(3)s.AddSlice(2) s.AddSlice(1)优先被计算，然后是s.AddSlice(2)，最后是AddSlice(3)，输出值为123 panic我们在开发阶段可以在关键错误处使用panic触发程序崩溃，也可以在重要的逻辑不允许有异常是做逻辑判断，不符合逻辑的调用panic异常崩溃。我们先实现两个函数 1234567891011121314151617func Funlv1() &#123; defer func() &#123; log.Println(&quot;Funlv1 exit ...&quot;) &#125;() log.Println(&quot;Funlv1 begin&quot;) panic(&quot;sorry, Funlv1 panic&quot;) log.Println(&quot;Funlv1 end&quot;)&#125;func Funlv2() &#123; defer func() &#123; log.Println(&quot;Funlv2 exit ...&quot;) &#125;() log.Println(&quot;Funlv2 begin&quot;) Funlv1() log.Println(&quot;Funlv2 end&quot;)&#125; 在main函数中调用 1Funlv2() 程序输出 1234567891011121314Funlv2 beginFunlv1 beginFunlv1 exit ...Funlv2 exit ...panic: sorry, Funlv1 panicgoroutine 1 [running]:main.Funlv1() D:/github/go-interview-questions/defer/defer.go:103 +0xa6main.Funlv2() D:/github/go-interview-questions/defer/defer.go:112 +0x8fmain.main() D:/github/go-interview-questions/defer/defer.go:127 +0x27exit status 2 没有输出Funlv2 end 和 Funlv1 end, 因为Panic之后的逻辑不会执行，Funlv1内部panic后，不会输出Funlv1 end， 这个崩溃抛给上层Funlv2，也没有捕获，导致Funlv2也不会输出Funlv2 end，所以无论是否panic，defer函数都会执行。我们要做的是通过recover捕获panic错误，看下改进的代码 1234567891011121314151617181920212223func Funlv1Safe() &#123; defer func() &#123; if err := recover(); err != nil &#123; log.Println(&quot;Funlv1 catch panic , err is &quot;, err) &#125; log.Println(&quot;Funlv1 exit ...&quot;) &#125;() log.Println(&quot;Funlv1 begin&quot;) panic(&quot;sorry, Funlv1 panic&quot;) log.Println(&quot;Funlv1 end&quot;)&#125;func Funlv2Safe() &#123; defer func() &#123; if err := recover(); err != nil &#123; log.Println(&quot;Funlv2 catch panic , err is &quot;, err) &#125; log.Println(&quot;Funlv2 exit ...&quot;) &#125;() log.Println(&quot;Funlv2 begin&quot;) Funlv1Safe() log.Println(&quot;Funlv2 end&quot;)&#125; 在main函数中调用 1Funlv2Safe() 输出 123456Funlv2 beginFunlv1 beginFunlv1 catch panic , err is sorry, Funlv1 panicFunlv1 exit ...Funlv2 endFunlv2 exit ... 由于Funlv1调用panic所以不会输出Funlv1 end 但是Funlv1的defer函数通过recover捕获了panic，所以Funlv2可以正常执行并结束。如果我们注释掉Funlv1的defer函数中的recover，就会由Funlv2来捕获panic注意如果是捕获本层panic，一定要将defer写在panic之上，否则无法捕获，recover也要写在defer函数或者上层函数中。 panic要等待defer结束后才会向上传递，如果defer捕获了panic就不传递了 123456func defer_call() &#123; defer func() &#123; fmt.Println(&quot;打印前&quot;) &#125;() defer func() &#123; fmt.Println(&quot;打印中&quot;) &#125;() defer func() &#123; fmt.Println(&quot;打印后&quot;) &#125;() panic(&quot;触发异常&quot;)&#125; 所以上述代码调用输出为打印后，打印中，打印前，最后panic触发异常 总结1 panic执行后，后续语句不再执行，会执行defer函数，如有多个defer就遵循栈式调用2 如果某个goroutine没有捕获panic，则整个进程崩溃，不仅仅是该goroutine崩溃3 panic被本层recover后，会影响到本层函数panic之后的语句执行，不影响当前goroutine的执行。4 recover必须写在defer语句或者上层函数才可生效5 recover的作用是保证捕获异常后程序可以继续稳定运行。","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang面试题汇总(二)","date":"2021-12-06T09:28:45.000Z","path":"2021/12/06/golang41/","text":"简介总结一些笔试题源码地址https://gitee.com/secondtonone1/go-interview-questions 面试题1 以下定义包内全局变量，正确的是1234A. var str stringB. str := &quot;&quot;C. str = &quot;&quot;D. var str = &quot;&quot; 答案是AD，定义全局变量要有var 声明，可以写类型也可以不写，系统自动推导，:=实际上是两个表达式不能定义包内全局变量，会报错。 2 指针访问通过指针变量 p 访问其成员变量 name 1p.name 或者(*p).name 我们能常用p.name即可 3 接口一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理，接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口，类实现接口时，不需要导入接口所在的包，因为go的interface体系降低了接口实现的耦合性。 4 协程协程和线程都可以实现程序的并发执行，协程比线程更轻量级，协程和线程一样会存在死锁问题，协程可以通过channel进行通信 5 init函数一个包中可以包含多个init函数，程序编译时，先导入包的init函数，再执行本包内的init函数，main包中也可以有init函数，init函数不可以被其他函数调用，init函数的执行顺序是按照导入的顺序执行的。 6 for循环go的for循环支持continue和break来控制循环，也提供了更高级的break，可以跳出到指定位置。for循环不支持以逗号为间隔的多个复制语句，必须使用平行赋值的方式来初始化多个变量。 7 变参函数12345678func add(args ...int) int &#123; sum := 0 for _, arg := range args &#123; sum += arg &#125; return sum&#125; 对于add调用可以采取如下方式 12add(1, 2, 3)add([]int&#123;1, 3, 5&#125;...) 8 强制类型转换go的强制类型转换比较简单 12345type MyStr stringvar temp string = &quot;Hello world!&quot;var newStr MyStrnewStr = MyStr(temp)log.Println(&quot;newStr is &quot;, newStr) 9 const变量const变量的定义，可以不写类型，交由系统自动推导。 12345const pai float64 = 3.1415926const ( name = &quot;zack&quot; age = 33) 但是不可以将变量赋值给常量 1const newerr = errors.New(&quot;new error&quot;) 10 bool变量go的bool变量不支持和int做强制转换，也不支持将int类型赋值给bool变量，以下操作为错误的,编译会报错 12b := bool(1)b = 1 11 switch语句switch语句可以包含多个case，每个表达式可以是常量，整数，字符串等等，也可以是channel读取等。不同于C++，case中要明确添加fallthrough才能继续执行紧跟的下一个case 12 golang的thisgolang中没有隐藏的this指针，方法施加的对象显示传递，没有被隐藏，可以叫this，that等等什么都可以。方法施加的对象不需要非得是指针，也不用非得叫this 13 golang的引用类型golang的引用类型包括map，slice，chan，interface，凡是底层有指针实现的都是引用类型。 14 golang的指针golang的指针，可以通过&amp;取指针的地址，可以通过*取指针指向的数据 15 main函数main函数不能有参数，不能有返回值，必须在main包，可以通过flag包来获取和解析命令行参数 16 关于nilnil表示空，常用来给指针赋值，所以当用nil给某个指针赋值时一定要指明类型 12var x1 interface&#123;&#125; = nilvar x2 error = nil 17 切片初始化123s := make([]int, 0)s = make([]int, 5, 10)s = []int&#123;1, 2, 3, 4, 5&#125; 18 从切片删除元素实现一个从slice中删除指定索引元素的函数 12345678func RemoveFromSlice(datasrc []int, index int) []int &#123; if index &gt; len(datasrc)-1 || index &lt; 0 &#123; log.Println(&quot;index invalid&quot;) return nil &#125; return append(datasrc[:index], datasrc[index+1:]...)&#125; 这么做可以删除指定索引的元素，但是也存在隐患因为append会修改data的数据，举个例子 123456 datasrc := []int&#123;6, 1, 0, 5, 2, 9&#125;data := RemoveFromSlice(datasrc, 0)log.Println(&quot;data is &quot;, data)log.Println(&quot;datasrc is &quot;, datasrc)data = RemoveFromSlice(datasrc, 3)log.Println(&quot;data is &quot;, data) 程序输出 1234data is [1 0 5 2 9]datasrc is [1 0 5 2 9 9]len data is 6data is [1 0 5 9 9] 可以看到删除功能都是正常的，但是经过第一次删除后datasrc被改变了，主要原因是RemoveFromSlice内部调用了append，append会修改参数datasrc的数据，append将datasrc数据由[6,1,0,5,2,9]经过第一次截取后做了拼接，此时append并未返回新的数据地址，因为不存在扩容，所以最后一个元素没变，还是9，所以datasrc数据为[1,0,5,2,9,9],这时再删除索引为3的元素2，data的值就是[1,0,5,9,9],这也是切片的双刃剑，我们用切片做参数一定要考虑修改后是否对外界有影响如果想获取删除后的slice，并且不影响原slice，可以修改RemoveFromSlice函数如下 12345678910func RemoveFromSliceCopy(datasrc []int, index int) []int &#123; datatmp := make([]int, len(datasrc)) copy(datatmp, datasrc) if index &gt; len(datatmp)-1 || index &lt; 0 &#123; log.Println(&quot;index invalid&quot;) return nil &#125; return append(datatmp[:index], datatmp[index+1:]...)&#125; 再来测试下 123456 datasrc = []int&#123;6, 1, 0, 5, 2, 9&#125;data = RemoveFromSliceCopy(datasrc, 0)log.Println(&quot;data is &quot;, data)log.Println(&quot;datasrc is &quot;, datasrc)data = RemoveFromSlice(datasrc, 3)log.Println(&quot;data is &quot;, data) 输出结果为 123data is [1 0 5 2 9]datasrc is [6 1 0 5 2 9]data is [6 1 0 2 9] 通过copy操作实现slice深copy，这样修改copy副本就不会影响源slice了。 19 方法和接口如果Add函数的调用代码为 1234567func main() &#123;var a Integer = 1var b Integer = 2var i interface&#123;&#125; = &amp;asum := i.(*Integer).Add(b)fmt.Println(sum)&#125; i可以转化为Integer指针并调用Integer方法，则Integer实现了Add方法，当然Integer*实现Add方法也可以。如下两种方式都可以 123456789type Integer intfunc (a Integer) Add(b Integer) Integer &#123; return a + b&#125;func (a *Integer) Add(b Integer) Integer &#123; return *a + b&#125; 所以实现一个结构体或其指针的方法后，无论该类型的变量还是指针都可以调用其方法，但是实现结构体指针的方法有一个好处就是可以修改其内部变量。接口约束，我们能用接口A定义了一个方法B后，凡是实现该方法B的结构体或指针，都可以给A赋值，A作为函数参数，接受实现其方法的结构体对象即可，如果结构体对象未实现该方法，则作为实参传递会报错。看个例子 1234567891011121314151617181920212223242526package main import ( &quot;fmt&quot;) type Bird interface &#123; Fly() string&#125; type Plane struct &#123; Name string&#125; func (plane *Plane) Fly() string &#123; fmt.Println(&quot;plane fly&quot;) return &quot;plane fly&quot;&#125; func main() &#123; plane := Plane&#123;Name: &quot;plane&quot;&#125; plane.Fly() plane_p := &amp;Plane&#123;Name: &quot;plane_p&quot;&#125; plane_p.Fly()&#125; 这个例子可以正常输出Fly的打印结果，因为*Plane实现了Fly方法。如果我们写一个函数，参数为Bird，内部做类型转换判断 123456func CheckFly(bird Bird) &#123; plane_p, b := bird.(*Plane) if b &#123; fmt.Println(&quot;plane pointer convert success, is &quot;, plane_p) &#125;&#125; 如果我们调用 12CheckFly(&amp;plane)CheckFly(plane_p) 会正常输出 12plane pointer convert success, is &amp;&#123;plane&#125;plane pointer convert success, is &amp;&#123;plane_p&#125; 如果调用 1CheckFly(plane) 会编译报错，因为Plane类没有实现Fly方法，不能传递给Bird接口，这就达到了接口约束的目的。同样修改CheckFly,新增Plane的转换也会报错 1234567891011func CheckFly(bird Bird) &#123; plane_p, b := bird.(*Plane) if b &#123; fmt.Println(&quot;plane pointer convert success, is &quot;, plane_p) &#125; plane, b := bird.(Plane) if b &#123; fmt.Println(&quot;plane conver success, is &quot;, plane) &#125;&#125; 上述代码编译报错的原因是Plane没有实现Fly方法。当然如果我们将Fly方法的调用者改为Plane，就不会报错了 1234func (plane Plane) Fly() string &#123; fmt.Println(&quot;plane fly&quot;) return &quot;plane fly&quot;&#125; 实现了Plane类的Fly方法，就隐式实现了指针的Fly方法。所以接口可以转换类类型和类指针类型，编译器不会报错。关于接口使用和注意事项的文章https://llfc.club/category?catid=20RbopkFO8nsJafpgCwwxXoCWAs#!aid/21JhR9PJ3GNWCvTB9OjIHTzKb8C 只要两个接口拥有相同的方法列表，即使次序不同，那么他们就是等价的，可以互相赋值。如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A，接口查询是否成功，需要在运行阶段才能确定，接口赋值可行在编译阶段就可确定 20 vendorvendor目录被添加到除了GOPATH和GOROOT之外的依赖目录查找的解决方案. go查找依赖包路径的解决方案如下 1 在当前包下的vendor目录 2 向上级目录查找，直到找到src下的vendor目录 3 在GOPATH下面查找依赖包 4 在GOROOT下查找依赖包基本思路是将引用的外部包源代码放在当前工程的vendor目录下，go会优先从vendor目录查找依赖包，有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH/src下都可以通过编译 21 channel特性1 给一个 nil channel发送数据，造成永远阻塞2 从一个 nil channel接收数据，造成永久阻塞3 向一个已经关闭的channel写数据，会造成panic4 从一个已经关闭的channel读数据，如果缓冲区有数据，先读出数据，缓冲区为空，会读出空值5 无缓冲的channel是同步的，有缓冲的channel是异步的6 一个只用于读取int数据的单向channel var ch &lt;- chan int7 一个只用于写int数据的单项channel var ch chan &lt;- int 22 单元测试go test 可以测试指定代码，该代码文件为*_test.go,文件内的函数如下 1func TestXXX( t *testing.T ) 写一个测试代码helloworld_test.go 1234567package testinstimport &quot;testing&quot;func TestHelloWorld(t *testing.T) &#123; t.Log(&quot;hello world&quot;) t.Log(&quot;test hello world end&quot;)&#125; 然后可以通过go test helloworld_test.go 或者go test -v helloworld_test.go查看输出 123456=== RUN TestHelloWorld helloworld_test.go:6: hello world helloworld_test.go:7: test hello world end--- PASS: TestHelloWorld (0.00s)PASSok command-line-arguments 0.259s 我们新增一个TestAnother函数 123func TestAnother(t *testing.T) &#123; t.Log(&quot;another test&quot;)&#125; 可以通过go test -v -run TestAnother helloworld_test.go 指定测试这个函数 12345=== RUN TestAnother helloworld_test.go:11: another test--- PASS: TestAnother (0.00s)PASSok command-line-arguments 0.277s 也可以Benchmark_开头写函数，用来做性能测试 1234567func Benchmark(b *testing.B) &#123; b.Log(&quot;bench mark test&quot;) sum := 0 for i := 0; i &lt; 200; i++ &#123; sum += i &#125;&#125; 执行 go test -v -bench=. hellowrold_test.go-bench=.表示测试helloworld_test.go文件下所有基准测试。此外还可以指定benchtime，benchmem等参数 1234567891011121314151617181920=== RUN TestHelloWorld helloworld_test.go:6: hello world helloworld_test.go:7: test hello world end--- PASS: TestHelloWorld (0.00s)=== RUN TestAnother helloworld_test.go:11: another test--- PASS: TestAnother (0.00s)goos: windowsgoarch: amd64cpu: Intel(R) Core(TM) i7-7500U CPU @ 2.70GHzBenchmark helloworld_test.go:15: bench mark test helloworld_test.go:15: bench mark test helloworld_test.go:15: bench mark test helloworld_test.go:15: bench mark test helloworld_test.go:15: bench mark test helloworld_test.go:15: bench mark testBenchmark-4 1000000000PASSok command-line-arguments 0.268s 23 闭包捕获range变量如果用闭包捕获for循环的变量会有什么问题呢 12345678910111213func range1() &#123; strings := []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;zack&quot;&#125; for _, str := range strings &#123; go func() &#123; log.Println(&quot;in func str is &quot;, str) &#125;() &#125;&#125;func main() &#123; range1() time.Sleep(time.Second)&#125; 这段代码会输出 zack zack zack原因在于str为for循环的变量，通过闭包延长了str的生命周期，闭包捕获的是str的本身引用。当三次循环过后str的值变为zack，所以会输出三个zack，我们可以在关键部位打印str的地址和值，验证一下 12345678910111213141516func range2() &#123; strings := []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;zack&quot;&#125; for _, str := range strings &#123; log.Println(&quot;str is &quot;, str) log.Println(&quot;str addr is &quot;, &amp;str) go func() &#123; log.Println(&quot;in func str is &quot;, str) log.Println(&quot;in func str addr is &quot;, &amp;str) &#125;() &#125;&#125;func main() &#123; range2() time.Sleep(time.Second)&#125; 程序输出 123456789101112str is hellostr addr is 0xc000042240str is worldstr addr is 0xc000042240str is zackstr addr is 0xc000042240in func str is zackin func str addr is 0xc000042240in func str is zackin func str addr is 0xc000042240in func str is worldin func str addr is 0xc000042240 可以看到每次for循环打印的str值是变化的，但是str地址没变，因为str就是一个变量，而go func()是在三次循环过后才调用，这就导致了输出str的值都为zack。所以我们能只要控制协程及时调用，就能保证str输出不同值。 1234567891011121314151617func range3() &#123; strings := []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;zack&quot;&#125; for _, str := range strings &#123; log.Println(&quot;str is &quot;, str) log.Println(&quot;str addr is &quot;, &amp;str) go func() &#123; log.Println(&quot;in func str is &quot;, str) log.Println(&quot;in func str addr is &quot;, &amp;str) &#125;() time.Sleep(time.Second) &#125;&#125;func main() &#123; range3() time.Sleep(time.Second)&#125; 输出 123456789101112str is hellostr addr is 0xc000042240in func str is helloin func str addr is 0xc000042240str is worldstr addr is 0xc000042240in func str is worldin func str addr is 0xc000042240str is zackstr addr is 0xc000042240in func str is zackin func str addr is 0xc000042240 通过sleep，保证了每次循环及时调用go func()这样，输出的str和每次遍历的记过一样。所以从这个例子我们知道，不要用协程或者闭包捕获for循环的变量，因为for循环的变量值会不断变化，而协程很难在准确的时机获取其值，造成逻辑错误。 24 defer链式调用defer 只能执行一个函数，defer是栈式调用，后入先出规则。当defer执行链式操作时，前边的表达式都会优先求值，只有最后一个表达式入栈延迟执行。 12345678910111213141516type Slice []intfunc NewSlice() *Slice &#123; slice := make(Slice, 0) return &amp;slice&#125;func (s *Slice) AddSlice(val int) *Slice &#123; *s = append(*s, val) log.Println(val) return s&#125;s := NewSlice()defer s.AddSlice(1).AddSlice(3)s.AddSlice(2) s.AddSlice(1)优先被计算，然后是s.AddSlice(2)，最后是AddSlice(3)，输出值为123 25 字符串字符串取索引获取的是字节的asc码值，通过切片截取获取的是字串 123 str := &quot;Hello&quot;log.Println(str[0]) log.Println(str[0:1]) 上述代码分别打印出72和H，如果对str[0]赋值，会编译报错 1str[0] = &#x27;M&#x27; 编译报错 1cannot assign to str[0] (strings are immutable) 26 recover和deferdefer 函数中可以使用recover捕获异常，recover要写在defer中，panic可以由本层或者上一层捕获。具体原理和注意事项请参考defer注意事项 27 range注意事项前面的例子说过defer 或者函数捕获 range 变量是捕获的引用，会导致问题，这个例子同样会出现问题，因为map存储的val为stu的指针 12345678910111213141516func pase_student() &#123; m := make(map[string]*student) stus := []student&#123; &#123;Name: &quot;zhou&quot;, Age: 24&#125;, &#123;Name: &quot;li&quot;, Age: 23&#125;, &#123;Name: &quot;wang&quot;, Age: 22&#125;, &#125; for _, stu := range stus &#123; m[stu.Name] = &amp;stu &#125; for key, val := range m &#123; log.Println(&quot;name is &quot;, key) log.Println(&quot;age is &quot;, val) &#125;&#125; 程序输出 123456name is zhouage is &amp;&#123;wang 22&#125;name is liage is &amp;&#123;wang 22&#125;name is wang&amp;&#123;wang 22&#125; 因为遍历结束后stu变为{wang 22}，所以map的val为&amp;{wang 22}，只需要用map存储stu的值就不会出现问题了 12345678910111213141516func pase_student2() &#123; m := make(map[string]student) stus := []student&#123; &#123;Name: &quot;zhou&quot;, Age: 24&#125;, &#123;Name: &quot;li&quot;, Age: 23&#125;, &#123;Name: &quot;wang&quot;, Age: 22&#125;, &#125; for _, stu := range stus &#123; m[stu.Name] = stu &#125; for key, val := range m &#123; log.Println(&quot;name is &quot;, key) log.Println(&quot;age is &quot;, val) &#125;&#125; 28协程随机性和闭包123456789101112131415161718func clouser() &#123; runtime.GOMAXPROCS(1) wg := sync.WaitGroup&#123;&#125; wg.Add(20) for i := 0; i &lt; 10; i++ &#123; go func() &#123; fmt.Println(&quot;A: &quot;, i) wg.Done() &#125;() &#125; for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; fmt.Println(&quot;B: &quot;, i) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 上述程序输出 1234567891011121314151617181920B: 9A: 10A: 10A: 10A: 10A: 10A: 10A: 10A: 10A: 10A: 10B: 0B: 1B: 2B: 3B: 4B: 5B: 6B: 7B: 8 因为多个协程执行是随机的，所以输出A和B也是随机的，B的输出值是0~9, A的输出值为10，因为第一个循环，func捕获的是i的引用。 29 组合和继承1234567891011121314151617type People struct&#123;&#125;func (p *People) ShowA() &#123; fmt.Println(&quot;showA&quot;) p.ShowB()&#125;func (p *People) ShowB() &#123; fmt.Println(&quot;showB&quot;)&#125;type Teacher struct &#123; People&#125;func (t *Teacher) ShowB() &#123; fmt.Println(&quot;teachershowB&quot;)&#125; main函数调用 123456func main() &#123; t := Teacher&#123;&#125; t.ShowA() t.ShowB() t.People.ShowB()&#125; 输出 1234showAshowBteachershowBshowB 因为匿名组合实现了继承，所以Teacher类有了People的方法ShowA，所以t.ShowA调用的是People类的ShowA 30 select随机性12345678910111213func maypanic() &#123; runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan &lt;- 1 string_chan &lt;- &quot;hello&quot; select &#123; case value := &lt;-int_chan: fmt.Println(value) case value := &lt;-string_chan: panic(value) &#125;&#125; 由于select由随机性，所以上述代码有可能会panic 31 defer 调用顺序和链式求值123456789func calc(index string, a, b int) int &#123; ret := a + b fmt.Println(index, a, b, ret) return ret&#125; a := 1 b := 2 defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b)) defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b)) 上述代码输出如下 123410 1 2 320 1 2 32 1 3 41 1 3 4 具体原理可参考defer原理 32 make初始化长度12345func makeslice() &#123; s := make([]int, 5) s = append(s, 1, 2, 3) fmt.Println(s)&#125; 程序输出 1[0 0 0 0 0 1 2 3] 因为make初始化slice时指定长度为5，就会默认为slice初始化5个0 33 lock锁1234567891011func (ua *UserAges) Add(name string, age int) &#123; ua.Lock() defer ua.Unlock() ua.ages[name] = age&#125;func (ua *UserAges) Get(name string) int &#123; if age, ok := ua.ages[name]; ok &#123; return age &#125; return -1&#125; 上述这段代码并不会引发死锁，但是会因为读操作未加锁导致读出来的数据不准确。 34 chan阻塞12345678910111213func Iter(set *sync.Map) &lt;-chan interface&#123;&#125; &#123; ch := make(chan interface&#123;&#125;) go func() &#123; set.Range(func(k, v interface&#123;&#125;) bool &#123; fmt.Println(&quot;key is &quot;, k) fmt.Println(&quot;value is &quot;, v) ch &lt;- v return true &#125;) close(ch) &#125;() return ch&#125; 上述代码会有什么问题呢？我们看看调用 12345678func main() &#123; safe_map := sync.Map&#123;&#125; safe_map.Store(&quot;zack&quot;, 1024) safe_map.Store(&quot;bob&quot;, 2048) safe_map.Store(&quot;vivo&quot;, 9096) ch := Iter(&amp;safe_map) &lt;-ch&#125; 程序输出 1234key is zackvalue is 1024key is bobvalue is 2048 没有vivo的输出，主要原因是ch是无缓冲的，造成了协程写阻塞，而主协程退出后，子协程因为占有ch而无法被回收，造成资源泄露 35 接口内部实现123456789101112131415161718192021222324252627282930313233343536373839404142434445type People interface &#123; Show()&#125;type Student struct&#123;&#125;func (stu *Student) Show() &#123;&#125;func live() People &#123; var stu *Student return stu&#125;func Self() *Student &#123; var stu *Student return stu&#125;type Empty interface &#123;&#125;func empty() Empty &#123; var stu *Student return stu&#125;func main()&#123; if live() == nil &#123; fmt.Println(&quot;AAAAAAA&quot;) &#125; else &#123; fmt.Println(&quot;BBBBBBB&quot;) &#125; if Self() == nil &#123; fmt.Println(&quot;AAAAAAA&quot;) &#125; else &#123; fmt.Println(&quot;BBBBBBB&quot;) &#125; if empty() == nil &#123; fmt.Println(&quot;AAAAAAA&quot;) &#125; else &#123; fmt.Println(&quot;BBBBBBB&quot;) &#125;&#125; 上述代码输出 123BBBBBBBAAAAAAABBBBBBB *Student对象stu为空指针，赋值给接口，接口不是nil，因为接口要保存type，data，以及方法集等信息。接口具体结构请参考接口结构 36 switch type1234567891011121314151617package mainfunc GetValue() int &#123; return 1&#125;func main() &#123; i := GetValue() switch i.(type) &#123; case int: println(&quot;int&quot;) case string: println(&quot;string&quot;) case interface&#123;&#125;: println(&quot;interface&quot;) default: println(&quot;unknown&quot;) &#125;&#125; 上述代码编译失败，会提示i不是interface类型 37 函数返回值参数123func funcMui(x,y int)(sum int,error)&#123; return x+y,nil&#125; 上述代码会编译失败，因为返回值要么全带参数，要么全不带 38 defer和返回值参数1234567891011121314151617181920212223242526func DeferFunc1(i int) (t int) &#123; t = i defer func() &#123; t += 3 &#125;() return t&#125;func DeferFunc2(i int) int &#123; t := i defer func() &#123; t += 3 &#125;() return t&#125;func DeferFunc3(i int) (t int) &#123; defer func() &#123; t += i &#125;() return 2&#125;func main() &#123; println(DeferFunc1(1)) println(DeferFunc2(1)) println(DeferFunc3(1))&#125; 程序输出 4, 1, 3。 defer的可以捕获返回值，并通过计算修改返回值。 39 结构体比较结构体比较时1 如果两个结构体内部成员类型不同，则不能比较2 如果两个结构体内部成员类型相同，但是顺序不同，则不能比较3 如果两个结构体内不含有无法比较类型，则无法比较4 如果两个结构体类型，顺序相同，且不含有无法比较类型(slice, map),则可以进行比较 1234567891011sn1 := struct &#123; age int name string&#125;&#123;age: 11, name: &quot;qq&quot;&#125;sn2 := struct &#123; age int name string&#125;&#123;age: 11, name: &quot;qq&quot;&#125;if sn1 == sn2 &#123; fmt.Println(&quot;sn1== sn2&quot;)&#125; 上面的代码会输出sn1 == sn2如果新增sn3，与sn1比较 12345678910111213sn1 := struct &#123; age int name string&#125;&#123;age: 11, name: &quot;qq&quot;&#125;sn3 := struct &#123; name string age int&#125;&#123;age: 11, name: &quot;qq&quot;&#125; //顺序不同无法比较if sn1 == sn3 &#123; fmt.Println(&quot;sn1== sn3&quot;)&#125; 则编译器汇编报错，提示miss matched struct，因为两个结构体类型相同但是成员的顺序不同，也无法比较我们新增sn4，让两个结构体的内容不同 12345678910111213sn3 := struct &#123; name string age int&#125;&#123;age: 11, name: &quot;qq&quot;&#125;sn4 := struct &#123; sex int age int&#125;&#123;sex: 1, age: 23&#125; //类型不同无法比较if sn4 == sn3 &#123; fmt.Println(&quot;sn4== sn3&quot;)&#125; 编译器也会编译报错，提示两个结构体成员类型不同，无法比较如果我们在结构体内部包含map类型 123456789101112sm1 := struct &#123; age int m map[string]string&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;sm2 := struct &#123; age int m map[string]string&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;//sm1 和 sm2 无法比较， 因为结构体内有无法比较的类型if sm1 == sm2 &#123; fmt.Println(&quot;sm1== sm2&quot;)&#125; 编译器仍然会报错，提示编译错误，无法比较两个结构体，因为有无法比较的类型map 12345678910111213sps1 := struct &#123; age int jobs []string&#125;&#123;age: 11, jobs: nil&#125; sps2 := struct &#123; age int jobs []string&#125;&#123;age: 11, jobs: nil&#125; if sps1 == sps2 &#123; fmt.Println(&quot;sps1 == sps2&quot;)&#125; 上述代码编译器仍然会报错，因为结构体内包含无法比较的类型slice对于chan，指针，以及interface这些类型都可以比较， 如下代码都可以实现比较 12345678910111213141516171819202122232425262728293031323334353637383940414243spch1 := struct &#123; age int ch chan int&#125;&#123;age: 11, ch: nil&#125; spch2 := struct &#123; age int ch chan int&#125;&#123;age: 11, ch: nil&#125; if spch1 == spch2 &#123; fmt.Println(&quot;spch1 == spch2&quot;)&#125; spi1 := struct &#123; age int it interface&#123;&#125;&#125;&#123;age: 11, it: nil&#125; spi2 := struct &#123; age int it interface&#123;&#125;&#125;&#123;age: 11, it: nil&#125; if spi1 == spi2 &#123; fmt.Println(&quot;spi1 == spi2&quot;)&#125;a := 1b := 2sp1 := struct &#123; age int data *int&#125;&#123;age: 11, data: &amp;a&#125;sp2 := struct &#123; age int data *int&#125;&#123;age: 11, data: &amp;b&#125; if sp1 == sp2 &#123; fmt.Println(&quot;sp1== sp2&quot;)&#125; 40 iotaiota是一个特殊常量，可以认为是一个可以被编译器修改的常量。iota 在const关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数加1，因此iota可作为const 语句块中的行索引。 12345678910111213141516171819const ( a = iota b c d e = &quot;Hello World&quot; f g = iota)func main() &#123; fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) fmt.Println(e) fmt.Println(f) fmt.Println(g)&#125; 程序输出 12345670123Hello WorldHello World6 41 alias12345678func main() &#123; type MyInt1 int type MyInt2 = int var i int = 9 var i1 MyInt1 = i var i2 MyInt2 = i fmt.Println(i1, i2)&#125; 上述代码会报错，不能将i赋值给i1，因为i1为MyInt1类型。可以将i赋值给i2，因为alias声明MyInt2类型为int类型的别名。 42 struct alias123456789101112131415161718type User struct &#123;&#125;type MyUser1 Usertype MyUser2 = Userfunc (i MyUser1) m1() &#123; fmt.Println(&quot;MyUser1.m1&quot;)&#125;func (i User) m2() &#123; fmt.Println(&quot;User.m2&quot;)&#125;func main()&#123; var iu1 MyUser1 var iu2 MyUser2 iu1.m1() iu2.m2()&#125; 输出 12MyUser1.m1User.m2 43 方法重名1234567891011121314151617type T1 struct &#123;&#125;func (t T1) m1() &#123; fmt.Println(&quot;T1.m1&quot;)&#125;type T2 = T1type MyStruct struct &#123; T1 T2&#125;func main() &#123; my:=MyStruct&#123;&#125; my.m1()&#125; 上述代码会编译报错 ambiguous selector my.m1，无论type alias还是type define 都有可能存在类组合后的方法重名情况，那么外部调用就要指明方法所属类名，改为如下调用就没有问题了。 12my.T1.m1()my.T2.m1() 44 变量作用域123456789101112131415161718var ErrDidNotWork = errors.New(&quot;did not work&quot;)func DoTheThing(reallyDoIt bool) (err error) &#123; if reallyDoIt &#123; result, err := tryTheThing() if err != nil || result != &quot;it worked&quot; &#123; err = ErrDidNotWork &#125; &#125; return err&#125;func tryTheThing() (string, error) &#123; return &quot;&quot;, ErrDidNotWork&#125;func main() &#123; fmt.Println(DoTheThing(true)) fmt.Println(DoTheThing(false))&#125; 程序输出 12nilnil 因为err = ErrDidNotWork, 这个err为作用域内部的err，而返回的是外层err 45 闭包延迟求值1234567891011121314func test() []func() &#123; var funs []func() for i := 0; i &lt; 2; i++ &#123; funs = append(funs, func() &#123; println(&amp;i, i) &#125;) &#125; return funs&#125;funs := test()for _, f := range funs &#123; f()&#125; 闭包捕获了i的最后值为2，所以结果为 120xc00000c0a8 20xc00000c0a8 2 如果想要打印不同的地址和变量值，可以用一个临时变量x存储i的值，闭包捕获x延长x的生命周期就可以了 123456789101112131415func test2() []func() &#123; var funs []func() for i := 0; i &lt; 2; i++ &#123; x := i funs = append(funs, func() &#123; println(&amp;x, x) &#125;) &#125; return funs&#125;funs = test2() for _, f := range funs &#123; f()&#125; 46 闭包引用相同变量123456789101112func test3(x int) (func(), func()) &#123; return func() &#123; println(x) x += 10 &#125;, func() &#123; println(x) &#125;&#125;a, b := test3(100)a()b() 程序输出100， 110 47 多个panic12345678910111213141516func panic1() &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(&quot;fatal&quot;) &#125; &#125;() defer func() &#123; panic(&quot;deferpanic&quot;) &#125;() panic(&quot;panic&quot;)&#125;func main()&#123; panic1()&#125; 当程序有多个panic，只有最后一个panic可以被捕获并恢复，程序第一次panic后会执行defer逻辑，defer又触发panic，所以程序输出deferpanic 48 协程控制目前有一个加载类接口 123type LoaderInter interface&#123; Load()&#125; 要求实现一个类Loader，1 包含Load方法，Load方法可以模拟实现一些超时或者阻塞操作。2 另外实现一个Check函数，其参数为LoadInter类型,返回值为error类型，要求内部调用Load方法，3 如果Load超时则Check函数返回超时错误，否则Check函数返回nil，超时时间设置为5s4 用代码实现该需求，请勿修改接口和函数参数以及返回值Check方法形式如下 1234func Check(li LoaderInter) error &#123; //... return nil&#125; 下面用代码实现上述需求 123456789101112131415161718192021222324252627282930313233343536type LoaderInter interface &#123; Load()&#125;func Check(li LoaderInter) error &#123; ch := make(chan struct&#123;&#125;) go func() &#123; li.Load() ch &lt;- struct&#123;&#125;&#123;&#125; &#125;() select &#123; case &lt;-ch: return nil case &lt;-time.After(time.Second * 5): return errors.New(&quot;load time out error&quot;) &#125;&#125;type Loader struct &#123;&#125;func (ld Loader) Load() &#123; fmt.Println(&quot;Loader begin load data....&quot;) &lt;-time.After(time.Second * 10) fmt.Println(&quot;Loader load data success...&quot;)&#125;func main() &#123; ld := &amp;Loader&#123;&#125; err := Check(ld) if err != nil &#123; fmt.Println(&quot;err is &quot;, err) &#125; time.Sleep(time.Second * 11)&#125; 程序输出 123Loader begin load data....err is load time out errorLoader load data success... 49 协程同步目前有一个加载类接口 123type LoaderInter interface&#123; Load()&#125; 同时有一个ProducerInter接口, 返回LoaderInter，如果返回nil表明ProducerInter已经生产完毕 123type ProducerInter interface &#123; Produce() LoaderInter&#125; 现要求实现一个Create函数,函数参数如下 123func Create(producer ProducerInter) &#123; //...&#125; 要求1 循环调用Produce函数产生多个LoaderInter，直到返回nil表明无需生产2 每个LoaderInter调用自己的Load操作，Load操作为耗时或者阻塞io操作3 保证最多同时并发运行五个LoadInter的Load操作 现在实现上述需求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type Loader struct &#123;&#125;func (ld Loader) Load() &#123; fmt.Println(&quot;Loader begin load data....&quot;) &lt;-time.After(time.Second * 10) fmt.Println(&quot;Loader load data success...&quot;)&#125;type ProducerInter interface &#123; Produce() LoaderInter&#125;type Producer struct &#123; max int //最大产量&#125;func (p *Producer) Produce() LoaderInter &#123; if p.max &lt;= 0 &#123; return nil &#125; ld := &amp;Loader&#123;&#125; p.max-- return ld&#125;func Create(producer ProducerInter) &#123; maxch := make(chan struct&#123;&#125;, 5) for &#123; select &#123; case maxch &lt;- struct&#123;&#125;&#123;&#125;: ld := producer.Produce() if ld == nil &#123; fmt.Println(&quot;producer end ,max ....&quot;) return &#125; go func() &#123; ld.Load() &lt;-maxch &#125;() &#125; &#125;&#125; 在main函数中调用 1234func main() &#123; p := Producer&#123;max: 10&#125; Create(&amp;p)&#125; 我们初始化Producer最多产出10个loader，程序输出如下 1234567891011121314151617Loader begin load data....Loader begin load data....Loader begin load data....Loader begin load data....Loader begin load data....Loader load data success...Loader begin load data....Loader load data success...Loader begin load data....Loader load data success...Loader begin load data....Loader load data success...Loader begin load data....Loader load data success...Loader begin load data....Loader load data success...producer end ,max ....","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang面试题汇总(一)","date":"2021-12-03T08:26:44.000Z","path":"2021/12/03/golang40/","text":"简介陆续总结一些面试常常会问到的问题，对知识体系做一个梳理源码地址https://gitee.com/secondtonone1/go-interview-questions 面试题1 简述go协程调度原理go协程调度模型图https://llfc.club/articlepage?id=21XXEPY1IoqquP7phaftDjf9Rt4简述原理:go的协程是通过MPG模型调用的，M为内核态线程,G为用户态协程,P为处理器,系统会通过调度器从全局队列找到G分配给空闲的M，P会选择一个M来运行，M和G的数量不等，P会有一个本地队列表示M未处理的G,M本身有一个正在处理的G，M每次处理完一个G就从本地队列里取一个G，并且更新P的schedtick字段，如果本地队列没有G，则从全局队列一次性取走G/P个数的G，如果全局队列里也没有，就从其他的P的本地队列取走一半。go1.2之前goroutine是轮询式调度，之后改为抢占式，弱抢占式。弱抢占式:如果某个P的schedtick一直没有递增，说明这个P一直在执行一个G任务，如果超过一定时间就会为G增加标记，并且该G执行非内联函数时中断自己并把自己加到队尾。 2 struct能否比较结构体比较时1 如果两个结构体内部成员类型不同，则不能比较2 如果两个结构体内部成员类型相同，但是顺序不同，则不能比较3 如果两个结构体内不含有无法比较类型，则无法比较4 如果两个结构体类型，顺序相同，且不含有无法比较类型(slice, map, ) 3 defer关键字一个函数定义了多个defer函数，defer的调用顺序和栈一样，先进后出，最先调用的是最后写的defer。函数将返回值入栈，然后执行析构，在析构之前要执行defer的操作。defer使用的注意事项 3.1 defer常用来释放变量我们实现一个文件copy函数，将src路径下的文件copy到dst路径下 1234567891011121314func CopyFile(dst, src string) (written int64, err error)&#123; srcF, err := os.Open(src) if err != nil&#123; return &#125; defer srcF.Close() dstF, err := os.Create(dst) if err != nil&#123; return &#125; defer dstF.Close() return io.Copy(dstF, srcF)&#125; 注意，如果Open失败或者Create失败，千万不要调用src.Close，因为src为nil。 3.2 defer被声明时，其参数是实时解析和捕获1234567func DeferParam() &#123; i := 0 defer func(m int) &#123; log.Println(m) &#125;(i) i++&#125; 程序输出0，因为defer声明时捕获i的值为0，传入函数后输出也是0，不管以后i变成什么值。如果defer是无参函数，内部引用了外部变量，就不同了，会记录i的引用 12345678func DeferNoParam() &#123; i := 0 defer func() &#123; log.Println(i) &#125;() i++&#125; 最后i变为什么值，defer就输出什么值。此时输出值为1 3.3 defer调用顺序为栈式调用1234567func DeferOrder() &#123; for i := 0; i &lt; 5; i++ &#123; defer func(m int) &#123; log.Println(m) &#125;(i) &#125;&#125; 输出结果为4，3，2，1，0 3.4 defer可以捕获函数返回值因为defer可以捕获函数内变量，所以可以捕获函数的返回值 12345678func DeferReturn() (res int) &#123; defer func() &#123; res++ log.Println(res) &#125;() return 0&#125; defer输出为1，因为defer捕获到返回值为0，+1就输出1 4 select有什么作用select是用来控制并发访问的技术，当有多个逻辑要监控时，可以写入select的不同的case，同时也能捕获外界通知，也可以控制协程退出和并发等。select的case表达式必须为一个channel类型，所有case都会被求值，自上而下，从左而又。如果有多个case满足条件，则随机选择一个执行，如果所有case都不满足条件，且实现了defautl逻辑，则走入default逻辑。如果没有实现default逻辑，则阻塞等待，知道某个case条件满足为止。break可以跳出select执行，所以要注意配合for循环的select，如果想要跳出循环，请使用return或者break+标签的方式跳转到某个位置。我们实现一个逻辑，不断的从channel中读取数据1 要求监听外界退出的通知，收到通知后退出并返回2 要求从channel中读取数据，超过5s未读出则打印超时,然后继续等待读取,这期间有退出信号要及时退出3 保证channel中有数据则优先读取 1234567891011121314151617181920212223func NoneBlockRead(ctx context.Context, chread chan interface&#123;&#125;, wt *sync.WaitGroup) &#123; for &#123; select &#123; case &lt;-ctx.Done(): wt.Done() log.Println(&quot;receive main exit signal&quot;) return case data := &lt;-chread: log.Println(&quot;receive &quot;, data) default: select &#123; case &lt;-time.After(time.Second * 5): log.Println(&quot;time out&quot;) case data := &lt;-chread: log.Println(&quot;receive &quot;, data) case &lt;-ctx.Done(): log.Println(&quot;receive main exit signal&quot;) wt.Done() return &#125; &#125; &#125;&#125; NoneBlockRead优先捕获主线程的ctx的退出信号和chread读取数据，如果上述条件都不满足，则进入default逻辑启动定时器检测超时，并监控退出信号和chread的数据读取。我们实现主函数 12345678910111213func main()&#123; var wg = &amp;sync.WaitGroup&#123;&#125; chread := make(chan interface&#123;&#125;) wg.Add(1) ctx, _ := context.WithTimeout(context.TODO(), time.Second*10) go NoneBlockRead(ctx, chread, wg) select &#123; case &lt;-time.After(time.Second * 7): chread &lt;- 1 &#125; wg.Wait()&#125; 主函数中设置定时器7秒后才像chread写入数据，所以NoneBlockRead会先打印超时，然后读出数据，接着等待3秒后自动退出，因为ctx十秒会触发cancel逻辑。程序输出 1232021/12/06 11:28:03 time out2021/12/06 11:28:05 receive 12021/12/06 11:28:08 receive main exit signal 5 context的作用context在多个goroutine中运行是安全的，用于信息传递，协程管理等。我们再实现一个从channel读取数据的函数 12345678910111213func NoneBlockRead2(ctx context.Context, chread chan interface&#123;&#125;, wt *sync.WaitGroup) &#123; defer func() &#123; wt.Done() &#125;() select &#123; case &lt;-ctx.Done(): log.Println(&quot;receive main exit signal&quot;) return case data := &lt;-chread: log.Println(&quot;receive data is &quot;, data) return &#125;&#125; 这个函数就是通过传递一个ctx达到控制协程的目的 12345678func main()&#123; var wg = &amp;sync.WaitGroup&#123;&#125; chread := make(chan interface&#123;&#125;) wg.Add(1) ctx2, _ := context.WithTimeout(context.TODO(), time.Second*3) go NoneBlockRead2(ctx2, chread, wg) wg.Wait()&#125; 6 主协程如何等待其余协程退出有很多种方式，为每个协程传递一个channel，当每个协程退出时向该channel写入数据或者关闭该channel，主协程读取channel捕获退出信号。或者采用waitgroup也可以。 1234567891011func main()&#123; var wg = &amp;sync.WaitGroup&#123;&#125; for i := 0; i &lt; 5; i++ &#123; wg.Add(1) go func() &#123; wg.Done() &#125;() &#125; wg.Wait()&#125; 或者 123456789101112func main()&#123; waitch := make(chan int, 5) for i := 0; i &lt; 5; i++ &#123; go func() &#123; waitch &lt;- 1 &#125;() &#125; for i := 0; i &lt; 5; i++ &#123; &lt;-waitch &#125;&#125; 7 slice的扩容原理slice底层的结构为一个结构体，包含data数据域和实际的长度len，以及容量cap,每次append都要判断当前长度是否达到len，如果达到就将cap扩充为len的2倍，然后移动数据到新的内存空间，所以append会返回新的slice，内部包含了数组的地址，使用slice要用make初始化 1a := make([]int, 1,2) 开辟一个slice，长度len为1，cap为2 8 go的map是有序的吗？go的map底层是hash table，也就是hmap类型，对key值进行hash运算，将低八位用来确定value存在那个bucket中，高八位与bucket的tophash进行比较，确定key是否存在。出现hash碰撞后，会将bucket的overflow指向一个新的bucket，形成一个单向链表map排序可以通过取出key值构造slice再排序 12345678910111213141516data_m := make(map[int]int)data_m[1] = 111data_m[2] = 222data_m[3] = 333keys := make([]int, 0, len(data_m))for k := range data_m &#123; keys = append(keys, k)&#125;sort.Slice(keys, func(i, j int) bool &#123; return keys[i] &lt; keys[j]&#125;)for _, val := range keys &#123; log.Println(data_m[val])&#125; 9 实现set利用map，建立value为ture，key为对应键值即可。要实现安全的set，可以用sync.map 123456789 data_set := make(map[int]bool)data_set[1] = truedata_set[2] = trueif val, ok := data_set[3]; !ok &#123; log.Println(&quot;key not exist&quot;) return&#125; else &#123; log.Println(&quot;val is &quot;, val)&#125; 如何实现生产者消费者用sync.map存储topic，主线程用waitGroup等待退出，生产者和消费者之间分别用两个chan通信，详见https://llfc.club/category?catid=20RbopkFO8nsJafpgCwwxXoCWAs#!aid/21Xe63IHvSfz8AEOulnUP4wrHZs 10 GC原理go采用三色标记法回收内存，程序开始创建的对象全部为白色，gc扫描后将可到达的对象标记为灰色，再从灰色对象中找到其引用的其他对象，将其标记为灰色，将自身标记为黑色，重复上述步骤，直到找不到灰色对象为止。最后对所有白色对象清除。gc采用标记清除(mark and sweep)算法的STW(STOP THE WORLD)的操作，标记阶段runtime把所有线程全部冻结掉，所有线程全部冻结意味着用户逻辑也是暂停的，这样所有对象都不会被修改，在清除阶段用户逻辑和清除操作时可并行的，因为白色对象意味着用户不再使用。go引入写屏障机制，在写操作之间和之后内存的修改被系统感知，然后重新标记，这时也会有短暂的stw，所以新生成的对象一律都是灰色的。如果一个黑色对象引用了曾经标记的白色对象，则写屏蔽机制被触发，向gc发送信号，gc重新扫描，将其着色为灰色。 11 go的堆栈原理栈: 由操作系统自动分配和释放，存放在函数的参数值，局部变量的值等。堆: 程序员自己分配并释放，如果不释放，可能由os回收，也可能不会(C++需要手动释放)，go对于堆空间的回收有垃圾回收算法，不一定是成为孤儿对象就立即回收，所以堆的回收较栈缓慢，栈则是从存储空间开辟，调用完立即释放。go 的内存分配遵循内存分配逃逸原则，所谓逃逸分析(escape analysis)是指由编译器决定内存分配的位置，不需要程序员指定。在函数中申请一个对象，如果分配在栈中，则函数结束自动回收，如果分配在堆中，则gc回收，以下场景会造成内存逃逸1 申请并开辟指针对象，指针对象在堆空间2 闭包，内部函数引用了外部函数的变量，则变量变为堆开辟3 栈空间不足，在堆上开辟逃逸分析减低gc压力，go开发不见得使用指针就是更高效，指针为四字节作为数据传递可以减少开销，但是回收要由gc管理，所以在传递频繁的场景尽量使用指针。","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"博客系统后台开发(三)完善项目并容器化","date":"2021-12-03T06:09:20.000Z","path":"2021/12/03/golang39/","text":"本节目标上一节完成了模板渲染，业余时间我增加了几个页面，大家可以根据分支去查看每天做的工作，这一节增加配置文件的读取，完成redis缓存的添加，一些信息优先访问redis缓存，另外增加日志库打印日志，最后完成项目的容器化 redis缓存之前的文章讲述过redis的增删改查，这里也和之前redis操作类似，增加文章的查询效率。初始化redis连接池 12345678910111213141516171819func InitRedis() &#123; rediscli = redis.NewClient(&amp;redis.Options&#123; Addr: config.TotalCfgData.Redis.Host, Password: config.TotalCfgData.Redis.Passwd, DB: config.TotalCfgData.Redis.DB, PoolSize: config.TotalCfgData.Redis.PoolSize, MinIdleConns: config.TotalCfgData.Redis.IdleCons, &#125;) _, err := rediscli.Ping().Result() if err != nil &#123; log.Println(&quot;ping failed, error is &quot;, err) return &#125; clearch = make(chan struct&#123;&#125;, 1000) exitch = make(chan struct&#123;&#125;) log.Println(&quot;redis init success!!!&quot;)&#125; 比如我们将session保存在redis中 12345func AddAdminSession(sessionId string, sessionData string) error &#123; _, err := rediscli.HSet(ADMIN_SESSION, sessionId, sessionData).Result() rediscli.Expire(ADMIN_SESSION, time.Hour*24*30) return err&#125; 依此类推，增加了很多redis读写模块，不一一赘述了。 配置文件读取服务器用到的配置文件我写在config/config.toml中 12345678910111213141516171819202122232425[mongo] host = &quot;81.68.86.123:27017&quot; user = &quot;admin&quot; passwd = &quot;12345678&quot; maxpoolsize = 10 contimeout = &quot;5000&quot; maxconidle = &quot;5000&quot; database = &quot;blog&quot;[cookie] host = &quot;81.68.86.123&quot; #本地启动请设置host为本地 #host = &quot;localhost&quot; alive = 86400[location] timezone = &quot;Asia/Shanghai&quot;[redis] host = &quot;81.68.86.123:6379&quot; idlecons = 16 poolsize = 1024 idletimeout = 300 passwd = &quot;123456&quot; db = 0 然后实现了config.go用来读取配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package configimport ( &quot;log&quot; &quot;flag&quot; &quot;github.com/BurntSushi/toml&quot;)type MongoCfg struct &#123; User string `toml: &quot;user&quot;` Passwd string `toml: &quot;passwd&quot;` Host string `toml: &quot;host&quot;` MaxPoolSize int16 `toml: &quot;maxpoolsize&quot;` MaxConIdle string `toml:&quot;maxconidle&quot;` ConTimeOut string `toml: &quot;contimeout&quot;` Database string `toml: &quot;database&quot;`&#125;type CookieCfg struct &#123; Host string `toml: &quot;host&quot;` Alive int `toml: &quot;alive&quot;`&#125;type RedisCfg struct &#123; Host string `toml: &quot;host&quot;` PoolSize int `toml: &quot;poolsize&quot;` IdleCons int `toml: &quot;idlecons&quot;` IdleTimeout int `toml: &quot;idletimeout&quot;` Passwd string `toml: &quot;passwd&quot;` DB int `toml: &quot;db&quot;`&#125;type TotalCfg struct &#123; Mongo MongoCfg `toml: &quot;mongo&quot;` Cookie CookieCfg `toml: &quot;cookie&quot;` Location_ Location `toml:&quot;location&quot;` Redis RedisCfg `toml:&quot;redis&quot;`&#125;type Location struct &#123; TimeZone string `toml:&quot;timezone&quot;`&#125;var TotalCfgData TotalCfgfunc init() &#123; cfgpath := flag.String(&quot;config&quot;, &quot;./config/config.toml&quot;, &quot;-config ./config/config.toml&quot;) flag.Parse() if _, err := toml.DecodeFile(*cfgpath, &amp;TotalCfgData); err != nil &#123; log.Println(&quot;decode file failed , error is &quot;, err) panic(&quot;decode file failed&quot;) &#125;&#125; 上述代码根据toml标签读取配置文件将对应字段写入结构体对象中，就完成了读取。 增加日志库对于日志库的选择，我选择了uber提供的zap库，同时配合lumberjack完成日志切割 12345678910111213141516171819202122232425262728293031323334353637383940package loggerimport ( &quot;github.com/natefinch/lumberjack&quot; &quot;go.uber.org/zap&quot; &quot;go.uber.org/zap/zapcore&quot;)var Sugar *zap.SugaredLogger = nilfunc getLogWriter() zapcore.WriteSyncer &#123; lumberJackLogger := &amp;lumberjack.Logger&#123; Filename: &quot;./log/blog.log&quot;, MaxSize: 10, MaxBackups: 5, MaxAge: 30, Compress: false, &#125; return zapcore.AddSync(lumberJackLogger)&#125;func init() &#123; // 编码器配置 config := zap.NewProductionEncoderConfig() // 指定时间编码器 config.EncodeTime = zapcore.ISO8601TimeEncoder // 日志级别用大写 config.EncodeLevel = zapcore.CapitalLevelEncoder // 编码器 encoder := zapcore.NewConsoleEncoder(config) writeSyncer := getLogWriter() // 创建Logger core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger := zap.New(core, zap.AddCaller()) Sugar = logger.Sugar() // 打印日志 Sugar.Info(&quot;logger init success&quot;)&#125; 设置日志文件最大10M，最多备份五个文件，最长时间为30天，同时可以支持打印行号等功能。 容器化先实现dockerfile，然后生成镜像 123456789101112131415161718192021222324252627282930FROM golang:1.16# 为我们的镜像设置必要的环境变量ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 \\ GOPROXY=&quot;https://goproxy.cn,direct&quot;ENV TZ=Asia/Shanghai# 创建代码目录WORKDIR /src# copy代码放入代码目录COPY . .# 将代码编译为二进制可执行文件RUN go build -o main .# 创建运行运行环境WORKDIR /bin#将二进制文件从 /src 移动到/binRUN cp /src/main .# 将项目所需配置和static资源copy至该目录RUN cp -r /src/config .RUN cp -r /src/public .RUN cp -r /src/views .# 暴露端口对外服务EXPOSE 8080# 启动容器运行命令CMD [&quot;/bin/main&quot;] 设置ENV准备了golang的运行环境，时区设置为上海，工作目录为/src，然后将源码由宿主机拷贝进入镜像编译并运行在项目的根目录，执行如下命令生成镜像 1docker build -t blog . 启动容器即可 1docker run --name blogds -p 8088:8088 -v /data/blog/log:/bin/log --restart=always -d blog 总结到目前为止，我们完成了博客系统后台的开发，仅用三篇文章无法全部说明其中细节，只是列举了后台系统经历的几个阶段，具体代码可以去github看看，谢谢大家赏星。源码地址：https://github.com/secondtonone1/bstgo-blog","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"博客系统后台开发(二)添加渲染","date":"2021-12-02T09:39:59.000Z","path":"2021/12/02/golang38/","text":"本节目标上一节我们添加了主页的路由和主页html模板，本节返回一个带参数渲染的模板，并从数据库中load数据添加到html中渲染返回，以及设置中间件，当有请求访问admin后台时判断其是否含有登录cookie，如果没有登录则返回登录页面源码地址：https://github.com/secondtonone1/bstgo-blog 添加中间件gin支持丰富的中间件功能，我们先实现一个跨域访问的功能和检测登录cookie的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869func Cors() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; method := c.Request.Method c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,AccessToken,X-CSRF-Token, Authorization, Token&quot;) c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE,UPDATE&quot;) //服务器支持的所有跨域请求的方 c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) //放行所有OPTIONS方法 if method == &quot;OPTIONS&quot; &#123; c.AbortWithStatus(http.StatusNoContent) &#125; // 处理请求 c.Next() &#125;&#125;func GroupRouterAdminMiddle(c *gin.Context) &#123; log.Println(&quot;=====================admin group router middle&quot;) //判断cookie中是否有session_id sessionId, err := c.Cookie(model.CookieSession) if err != nil &#123; //没有sessionId则返回登录页面 log.Println(&quot;no cookie sessionId ,return login&quot;) c.HTML(http.StatusOK, &quot;admin/login.html&quot;, nil) c.Abort() return &#125; sessionData, err := mongocli.GetSessionById(sessionId) if err != nil &#123; log.Println(&quot;get sessionid &quot;, sessionId, &quot;failed, return login&quot;) c.HTML(http.StatusOK, &quot;admin/login.html&quot;, nil) c.Abort() return &#125; log.Println(&quot;session data is : &quot;, sessionData) c.Next()&#125;func CheckLogin(c *gin.Context) &#123; log.Println(&quot;check login midware&quot;) //判断cookie中是否有session_id sessionId, err := c.Cookie(model.CookieSession) if err != nil &#123; //没有sessionId则返回登录页面 log.Println(&quot;no cookie sessionId ,return login&quot;) baseRsp := model.BaseRsp&#123;&#125; baseRsp.Code = model.ERR_NO_LOGIN baseRsp.Msg = model.MSG_NO_LOGIN c.JSON(http.StatusOK, baseRsp) c.Abort() return &#125; sessionData, err := mongocli.GetSessionById(sessionId) if err != nil &#123; log.Println(&quot;get sessionid &quot;, sessionId, &quot;failed, return login&quot;) baseRsp := model.BaseRsp&#123;&#125; baseRsp.Code = model.ERR_NO_LOGIN baseRsp.Msg = model.MSG_NO_LOGIN c.JSON(http.StatusOK, baseRsp) c.Abort() return &#125; log.Println(&quot;session data is : &quot;, sessionData) c.Next()&#125; CheckLogin和GroupRouterAdminMiddle都是用来检测登录信息的中间件，只是一个返回json一个返回html模板Cors是支持跨域访问然后修改之前的main函数，支持中间件 12345678910111213141516171819202122232425262728293031323334353637func main() &#123; mongocli.MongoInit() router := gin.Default() router.Use(Cors()) //默认跨域 //加载模板文件 router.LoadHTMLGlob(&quot;views/**/*&quot;) //设置资源共享目录 router.StaticFS(&quot;/static&quot;, http.Dir(&quot;./public&quot;)) //用户浏览首页 router.GET(&quot;/home&quot;, home.Home) //用户浏览你分类 router.GET(&quot;/category&quot;, home.Category) //用户浏览单个文章 router.GET(&quot;/articlepage&quot;, home.ArticlePage) //admin登录页面 router.GET(&quot;/admin/login&quot;, admin.Login) //admin 登录提交 router.POST(&quot;/admin/loginsub&quot;, admin.LoginSub) // 创建管理路由组 adminGroup := router.Group(&quot;/admin&quot;) adminGroup.Use(GroupRouterAdminMiddle) &#123; //管理首页 adminGroup.GET(&quot;/&quot;, admin.Admin) //管理分类 adminGroup.POST(&quot;/category&quot;, admin.Category) &#125; // 文章编辑发布 router.POST(&quot;admin/pubarticle&quot;, CheckLogin, admin.ArticlePub) router.Run(&quot;:8080&quot;) mongocli.MongoRelease()&#125; main函数里调用了mongo的初始化函数，以及结束时调用了mongo的release函数router.Use(Cors())对所有路由支持跨域访问adminGroup.Use(GroupRouterAdminMiddle)对/admin访问的分组做登录校验，返回htmlCheckLogin对admin/pubarticle的路由做登录校验，返回json结果 让页面显示后台内容之前我们返回的html页面是静态的，现在我们通过gin的模板渲染功能动态返回页面，页面的内容是后台mongo查询的数据。我们在请求文章页面逻辑中返回页面的渲染结构articleR 12345678910111213141516171819202122232425262728293031323334func ArticlePage(c *gin.Context) &#123; id := c.Query(&quot;id&quot;) log.Println(&quot;id is &quot;, id) if id == &quot;&quot; &#123; c.HTML(http.StatusOK, &quot;home/errorpage.html&quot;, &quot;invalid page request , id is null, after 2 seconds return to home&quot;) return &#125; article, err := mongocli.GetArticleId(id) if err != nil &#123; c.HTML(http.StatusOK, &quot;home/errorpage.html&quot;, &quot;get article failed, after 2 seconds return to home&quot;) return &#125; articleR := &amp;model.ArticlePageR&#123;&#125; articleR.Author = article.Author articleR.Cat = article.Cat articleR.Content = template.HTML(article.Content) createtm := time.Unix(article.CreateAt, 0) articleR.CreateAt = createtm.Format(&quot;2006-01-02 15:04:05&quot;) lasttm := time.Unix(article.LastEdit, 0) articleR.LastEdit = lasttm.Format(&quot;2006-01-02 15:04:05&quot;) articleR.Id = article.Id articleR.Index = article.Index articleR.LoveNum = article.LoveNum articleR.ScanNum = article.ScanNum articleR.Subcat = article.Subcat articleR.Subtitle = article.Subtitle articleR.Title = article.Title c.HTML(http.StatusOK, &quot;home/articlepage.html&quot;, articleR)&#125; 通过mongo中获取文章结构，传入html模板渲染并返回。文章结构定义在model模块 123456789101112131415//文章结构type Article struct &#123; Id string `bson:&quot;id&quot;` Cat string `bson: &quot;cat&quot;` Title string `bson: &quot;title&quot;` Content string `bson: &quot;content&quot;` Subcat string `bson: &quot;subcat&quot;` Subtitle string `bson: &quot;subtitle&quot;` ScanNum int `bson:&quot;scannum&quot;` LoveNum int `bson:&quot;lovenum` CreateAt int64 `bson:&quot;createdAt&quot;` LastEdit int64 `bson:&quot;lastedit&quot;` Author string `bson:&quot;author&quot;` Index int `bson:&quot;index&quot;`&#125; mongo的增删改查之前的文章有讲解过，这里不介绍了。 测试结果执行命令 1go run ./main.go 然后在控制台输入localhost:8080/articlepage?id=21M9WdW62KbVXXrlPfZhPOCFP31可以看到如下效果访问后台页面localhost:8080/admin当没有登录cookie时，会返回登录界面","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"博客系统后台开发(一)服务结构","date":"2021-12-02T07:32:02.000Z","path":"2021/12/02/golang37/","text":"简介基于gin框架搭建一个博客系统后台，返回html，json等数据与前端交互，包括登录模块，session维持，redis读写缓存，mongo读写等多种技术综合应用，意在打造一个高可用的稳定性博客后台。目前后台已经稳定运行，演示地址http://81.68.86.146:8080/, 源码地址：https://github.com/secondtonone1/bstgo-blog 项目结构config: 文件夹放的是配置文件以及配置管理模块demopic: demo图片，没什么用dockerconfig: docker用到的配置文件log: 日志文件logger: 日志模块model: 数据库模型和redis模型mongo: mongo模块redis: redis模块public: 前端用到的js,lib等资源router: 路由模块 本节目标本节意在实现gin框架基本调用，启动gin服务，编写基础的路由和模板回传 主函数启动gin框架在主函数中启动了gin server服务然后添加views目录为go得模板路径，设置/static为资源路径，关联得是public文件夹下得静态资源。然后添加了几个路由 123456789101112131415161718192021222324package mainimport ( &quot;bstgo-blog/router/home&quot; &quot;net/http&quot; &quot;bstgo-blog/router/admin&quot; &quot;github.com/gin-gonic/gin&quot;)func main() &#123; router := gin.Default() router.LoadHTMLGlob(&quot;views/**/*&quot;) router.StaticFS(&quot;/static&quot;, http.Dir(&quot;./public&quot;)) router.GET(&quot;/home&quot;, home.Home) router.GET(&quot;/category&quot;, home.Category) router.GET(&quot;/admin&quot;, admin.Admin) router.POST(&quot;/admin/category&quot;, admin.Category) router.POST(&quot;/admin/sort&quot;, admin.Sort) router.POST(&quot;/admin/sortsave&quot;, admin.SortSave) router.POST(&quot;/admin/index&quot;, admin.IndexList) router.Run(&quot;:8080&quot;)&#125; admin和home路由因为要实现前台展示和后台管理，admin是后台管理得模块，home是客户展示模块admin模块目前包括两个文件admin.go和category.go admin.go文件定义了Admin函数返回管理页面admin/index.html 1234567891011package adminimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func Admin(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;admin/index.html&quot;, nil)&#125; 同理，category.go文件定义了几个函数 1234567891011121314151617181920212223package adminimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func Category(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;admin/articlecateg.html&quot;, nil)&#125;func Sort(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;admin/articlesort.html&quot;, nil)&#125;func SortSave(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;admin/articlecateg.html&quot;, nil)&#125;func IndexList(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;admin/indexlist.html&quot;, nil)&#125; html模板我们将views目录下建立两个文件夹admin和home分别存储管理后台和前台显示的html模板文件admin下的模板文件具体html内容就不粘贴了，去github下载源码即可https://github.com/secondtonone1/bstgo-blog/tree/day01 测试访问执行命令 1go run ./main.go 然后在控制台输入localhost:8080/home可以看到如下效果","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"对io.readfull的理解","date":"2021-11-30T03:33:00.000Z","path":"2021/11/30/golang36/","text":"问题描述有些人提出了io.readfull可能导致读取数据溢出的问题，有人说如果ReadAtLeast函数中，n&gt;min时，就会直接返回n，而readfull传进去的min是len(buf),所以最终可能返回的n&gt;len(buf)？ 问题解答ReadFull调用的时ReadAtLeast 123func ReadFull(r Reader, buf []byte) (n int, err error) &#123; return ReadAtLeast(r, buf, len(buf))&#125; 那ReadFull返回的结果就是len(buf) 不会出现n&gt;len(buf)情况因为ReadAtLeast源码返回三种情况 12345678910111213141516func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) &#123; if len(buf) &lt; min &#123; return 0, ErrShortBuffer &#125; for n &lt; min &amp;&amp; err == nil &#123; var nn int nn, err = r.Read(buf[n:]) n += nn &#125; if n &gt;= min &#123; err = nil &#125; else if n &gt; 0 &amp;&amp; err == EOF &#123; err = ErrUnexpectedEOF &#125; return&#125; 1 数据读取的缓冲区buf小于min，这样直接返回buffer太短的错误，这是合理的。你要读取min长度，但是你传递的缓存buf又不够大，api就直接报错。2 数据读取的缓冲区buff大于0小于min，这种情况是由于意外中断了读取，所以返回ErrUnexpectedEOF错误。3 正常情况下返回的n就是大于等于min，并且error为nil。比如我们这样调用 1234//开辟100个字节的bufbuf := make([]byte,100)//con为网络连接描述符， 从con中最少读取10个字节io.ReadAtLeast(con, buf, 10) 上述代码读取到buf的数据是可能大于10个字节的，比如在con的tcp读缓冲区数据大于10个字节的时候如果改为 1234//开辟10个字节的bufbuf := make([]byte,10)//con为网络连接描述符， 从con中最少读取10个字节io.ReadAtLeast(con, buf, 10) 那么ReadAtLeast读取的数据就是10个字节，不会大于10个字节。因为ReadAtLeast内部循环调用Read函数达到n&gt;=min，而Read传递的参数为buf[n:]，所以即使因为tcp缓冲区数据不足多次Read也不会导致多读，因为Read(buf)只会读取&gt;=0并且&lt;=len(buf)长度的数据，在循环中不断地的控制buf[n:]保证了最多只会读取len(buf)长度。但是ReadFull没问题，因为ReadFull本意就是调用ReadAtLeast，读取buf长度，也只会读取buf长度的数据。所以核心问题不是ReadFull的问题，是使用者对该API的不理解，只要保证ReadAtLeast(con, buf, min) 中buf的大小等于min就不会有问题，ReadAtLeast在不出错的情况下只会返回min个字节不会出现溢出情况，对于网络粘包也不会出现bug对于这个问题，我之前也思考良久，并加以实践和测试，在公司编写了基于tcp的网络服务器，采用的就是ReadFull函数，用于对讲业务，单节点7000并发连接测试粘包未出现bug。我的代码段是这样的 12345678910111213141516171819202122232425262728293031323334353637//处理TCP粘包func (pi *ProtocolImpl) ReadPacket(conn net.Conn) (interface&#123;&#125;, error) &#123; buff := make([]byte, 4) _, err := io.ReadAtLeast(conn, buff[:4], 4) if err != nil &#123; //fmt.Println(&quot;read at least error &quot;, err.Error()) return nil, common.ErrReadAtLeast &#125; var msgpacket *MsgPacket = new(MsgPacket) value, err := pi.ParaseHead(msgpacket, buff[:4]) msgpacket, ok := value.(*MsgPacket) if !ok &#123; fmt.Println(&quot;it&#x27;s not msgpacket type&quot;) return nil, common.ErrTypeAssertain &#125; if components.MaxMsgId &lt; msgpacket.Head.Id &#123; return nil, errors.New(&quot;msg id is too big&quot;) &#125; if components.MaxMsgLen &lt; msgpacket.Head.Len &#123; return nil, common.ErrMsgLenLarge &#125; if uint16(len(msgpacket.Body.Data)) &lt; msgpacket.Head.Len &#123; msgpacket.Body.Data = make([]byte, msgpacket.Head.Len) &#125; if _, err = io.ReadFull(conn, msgpacket.Body.Data[:msgpacket.Head.Len]); err != nil &#123; //fmt.Println(&quot;err is &quot;, err.Error()) return nil, common.ErrReadAtLeast &#125; return msgpacket, nil&#125; 先用ReadAtLeast读取头部四字节，然后解包分析，进而得到包体的长度，然后用ReadFull从con中读取包体长度的数据。感兴趣可以看一下我的源码https://github.com/secondtonone1/wentmin","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang使用redis","date":"2021-11-30T02:00:58.000Z","path":"2021/11/30/golang35/","text":"简介redis是高并发场景下常用的缓存型数据库，支持持久化，常用来缓存访问频率较高的数据，本文通过几个例子列举go如何使用redis，go 操作redis的库很多，我们选择常用的go-redis来操作就可以了，当然官方也提供了redis操作的库。这几个例子出自个人博客系统的源码。源码地址https://github.com/secondtonone1/bstgo-blog 连接redis我们创建一个redis连接池，设置最大空闲连接数，池内总共连接数，以及redis连接密码，地址，选择的分区等 123456789101112131415func InitRedis() &#123; rediscli = redis.NewClient(&amp;redis.Options&#123; Addr: config.TotalCfgData.Redis.Host, Password: config.TotalCfgData.Redis.Passwd, DB: config.TotalCfgData.Redis.DB, PoolSize: config.TotalCfgData.Redis.PoolSize, MinIdleConns: config.TotalCfgData.Redis.IdleCons, &#125;) _, err := rediscli.Ping().Result() if err != nil &#123; log.Println(&quot;ping failed, error is &quot;, err) return &#125; log.Println(&quot;redis init success!!!&quot;)&#125; 根据key设置valueredis是基于key-value存储的，这个例子我们为STRING_ToTAL_VISIT_NUM_KEY设置值为num，过期时间为0表示永不过期 12345678func SetVisitNum(num int64) (string, error) &#123; val, err := rediscli.Set(STRING_ToTAL_VISIT_NUM_KEY, num, 0).Result() if err != nil &#123; return &quot;&quot;, err &#125; return val, nil&#125; 根据key获取值这个例子获取key为STRING_ToTAL_VISIT_NUM_KEY的value值 12345678910111213func GetVisitNum() (string, error) &#123; val, err := rediscli.Get(STRING_ToTAL_VISIT_NUM_KEY).Result() if err == redis.Nil &#123; return &quot;key not exists in redis&quot;, err &#125; if err != nil &#123; return &quot;&quot;, err &#125; return val, nil&#125; 根据key删除值1rediscli.Del(STRING_ToTAL_VISIT_NUM_KEY).Result() HGet获取hash表中指定字段HGet操作可以获取hash表中指定字段的值，下个例子通过获取HOME_SESSION的key找到hash表，进而找到sessioId字段的值 12345678func GetHomeSession(sessionId string) (string, error) &#123; sessionData, err := rediscli.HGet(HOME_SESSION, sessionId).Result() if err != nil &#123; return &quot;&quot;, err &#125; return sessionData, err&#125; HSet添加值HSet设置hash表中指定字段的值，下个例子设置了Key为HOME_SESSION的hash表，将sessionId字段的值设置为sessionData 123456func AddHomeSession(sessionId string, sessionData string) error &#123; _, err := rediscli.HSet(HOME_SESSION, sessionId, sessionData).Result() rediscli.Expire(HOME_SESSION, time.Hour*24) return err&#125; 设置值的同时设置了key为HOME_SESSION的hash表中所有值的过期时间为24小时，如果要设置过期时间，每次设置值后都要重设过期时间，如不设置就会变成永久存在内存中 HDel删除值HDel删除hash表中指定的字段，如下例子删除了key为HOME_SESSION的hash表中字段为sessionId的值 1234func DelHomeSession(sessionId string) error &#123; _, err := rediscli.HDel(HOME_SESSION, sessionId).Result() return err&#125; 增加操作可以通过Incr命令为某个key的value自增加一，如下这个例子为key为STRING_ToTAL_VISIT_NUM_KEY的value值加一 12345678func AddVisitNum() (int64, error) &#123; visit, err := rediscli.Incr(STRING_ToTAL_VISIT_NUM_KEY).Result() if err != nil &#123; return 0, err &#125; return visit, nil&#125; 类似的操作还有Decr，DecrBy等 获取hash表中所有key和valueHGetAll可以获取指定hash表中所有的key和value，如下例子获取了key为HSET_LV1_MENU_KEY的hash表中所有的key，value 123456789101112131415161718func GetLv1Menus() ([]*model.CatMenu, error) &#123; menulist := []*model.CatMenu&#123;&#125; menus, err := rediscli.HGetAll(HSET_LV1_MENU_KEY).Result() if err != nil &#123; return menulist, err &#125; for _, val := range menus &#123; menu := &amp;model.CatMenu&#123;&#125; err := json.Unmarshal([]byte(val), menu) if err != nil &#123; log.Println(&quot;json unmarshal failed, err is &quot;, err) continue &#125; menulist = append(menulist, menu) &#125; return menulist, nil&#125; redis中key为HSET_LV1_MENU_KEY的hash表存储的是所有一级目录的key和value，通过HGetAll获取后进行遍历和反序列化获取具体的目录结构。以上就是redis常用的操作，通过go操作redis达到缓存高并发访问数据的目的。","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang使用mongo","date":"2021-11-29T08:16:21.000Z","path":"2021/11/29/gomongo/","text":"简介mongodb是著名的非关系型数据库，常用来存储大量关联性不大的数据。golang操作mongo数据库可选的库很多，目前主流的使用为”go.mongodb.org/mongo-driver/mongo”，本文通过代码demo的方式介绍go如何操作mongo，实现增删改查，以及多条更新，分组查询，分页查询等复杂查询，代码demo选自个人博客系统的源码。源码地址https://github.com/secondtonone1/bstgo-blog 初始化连接和断开连接初始化连接,包含必要的mongo-driver库即可 123456789101112131415161718192021222324252627282930313233343536373839404142import( &quot;go.mongodb.org/mongo-driver/mongo&quot; &quot;go.mongodb.org/mongo-driver/mongo/options&quot; &quot;go.mongodb.org/mongo-driver/mongo/readpref&quot;)var MongoClient *mongo.Client = nilvar MongoDb *mongo.Database = nilfunc MongoInit() (e error) &#123; ctx, _ := context.WithTimeout(context.Background(), 10*time.Second) // 连接uri uri := &quot;mongodb://&quot; + config.TotalCfgData.Mongo.User + &quot;:&quot; + config.TotalCfgData.Mongo.Passwd + &quot;@&quot; + config.TotalCfgData.Mongo.Host + &quot;/?authSource=admin&quot; log.Println(&quot;uri is &quot;, uri) // 构建mongo连接可选属性配置 opt := new(options.ClientOptions) // 设置最大连接的数量 opt = opt.SetMaxPoolSize(uint64(config.TotalCfgData.Mongo.MaxPoolSize)) // 设置连接超时时间 5000 毫秒 du, _ := time.ParseDuration(config.TotalCfgData.Mongo.ConTimeOut) opt = opt.SetConnectTimeout(du) // 设置连接的空闲时间 毫秒 mt, _ := time.ParseDuration(config.TotalCfgData.Mongo.MaxConIdle) opt = opt.SetMaxConnIdleTime(mt) // 开启驱动 MongoClient, e = mongo.Connect(ctx, options.Client().ApplyURI(uri), opt) if e != nil &#123; log.Println(&quot;err is &quot;, e) return &#125; // 注意，在这一步才开始正式连接mongo e = MongoClient.Ping(ctx, readpref.Primary()) if e != nil &#123; log.Println(&quot;err is &quot;, e) &#125; log.Println(&quot;mongo init success!!!&quot;) //连接数据库 MongoDb = MongoClient.Database(config.TotalCfgData.Mongo.Database) return&#125; 当服务器关闭时要回收mongo的资源，这里简单关闭即可 123func MongoRelease() &#123; MongoClient.Disconnect(context.TODO())&#125; 文章表结构在go文件中定义ArticleInfo类 123456789101112131415//文章信息type ArticleInfo struct &#123; Id string `bson:&quot;id&quot; json:&quot;infoid&quot;` Cat string `bson: &quot;cat&quot; json: &quot;cat&quot;` Title string `bson: &quot;title&quot; json: &quot;title&quot;` Subcat string `bson: &quot;subcat&quot; json: &quot;subcat&quot;` Subtitle string `bson: &quot;subtitle&quot; json: &quot;subtitle&quot;` ScanNum int `bson:&quot;scannum&quot; json:&quot;scannum&quot;` LoveNum int `bson:&quot;lovenum json:&quot;lovenum` CreateAt int64 `bson:&quot;createdAt&quot; json:&quot;createdAt&quot;` LastEdit int64 `bson:&quot;lastedit&quot; json:&quot;lastedit&quot;` Author string `bson:&quot;author&quot; json:&quot;author&quot;` Index int `bson:&quot;index&quot; json:&quot;index&quot;`&#125; 字段的tag中一定要写bson标识，用来通知mongo以该bson指定的名字存储该字段,json可以不写，我这里写json是为了数据传输接下来看一下mongo数据库表中的文章信息结构表 12345678910111213141516&#123; &quot;id&quot;: &quot;20RgXj2UbtwIYbhQIScpEyoeera&quot;, &quot;cat&quot;: &quot;Go&quot;, &quot;title&quot;: &quot;Linux环境搭建和编码&quot;, &quot;subcat&quot;: &quot;安装和使用&quot;, &quot;subtitle&quot;: &quot;Linux环境搭建&quot;, &quot;scannum&quot;: 1246, &quot;lovenum json:&quot;: 594, &quot;createdAt&quot;: &#123; &quot;$numberLong&quot;: &quot;1636012855&quot; &#125;, &quot;lastedit&quot;: 1636594645, &quot;author&quot;: &quot;恋恋风辰&quot;, &quot;index&quot;: 1, &quot;lovenum&quot;: 2&#125; 数据库表中的数据字段和go程序定义的结构体bson命名的字段是相符合。 查找一条数据我们根据文章id获取文章信息，代码如下 123456789101112131415//通过文章获取文章概要信息func GetArticleInfo(id string) (*model.ArticleInfo, error) &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() filter := bson.M&#123;&quot;id&quot;: id&#125; //log.Println(&quot;filter is &quot;, filter) info := &amp;model.ArticleInfo&#123;&#125; err := MongoDb.Collection(&quot;articles&quot;).FindOne(ctx, filter).Decode(info) if err != nil &#123; log.Println(&quot;get article failed, error is &quot;, err) return nil, err &#125; return info, nil&#125; 查找多条数据查询未分组的文章列表，这里用到了Find函数，返回的是一个cursor，通过不断的cursor.Next获取每条记录。而且Find设置了查询选项，用了or或查询，这个或查询的条件就是cat为default或者subcat为default，同时对查询结果设置了排序 1234567891011121314151617181920212223242526272829303132333435363738//获取未分类的文章func GetDefaultArts() ([]*model.ArticleInfo, error) &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() catfilter := bson.M&#123;&#125; catfilter[&quot;cat&quot;] = &quot;default&quot; subfilter := bson.M&#123;&#125; subfilter[&quot;subcat&quot;] = &quot;default&quot; filterarry := []bson.M&#123;catfilter, subfilter&#125; //或查询 orfilter := bson.M&#123;&#125; orfilter[&quot;$or&quot;] = filterarry //log.Println(&quot;filter is &quot;, filter) sort := bson.D&#123;&#123;&quot;lastedit&quot;, -1&#125;&#125; findOptions := options.Find().SetSort(sort) articles := []*model.ArticleInfo&#123;&#125; cursor, err := MongoDb.Collection(&quot;articles&quot;).Find(ctx, orfilter, findOptions) if err != nil &#123; return articles, err &#125; defer cursor.Close(context.TODO()) for cursor.Next(context.TODO()) &#123; article := &amp;model.ArticleInfo&#123;&#125; if err := cursor.Decode(article); err != nil &#123; continue &#125; articles = append(articles, article) &#125; return articles, nil&#125; 插入一条数据这里直接调用insertone传入我们定义的结构体，mongo-driver会自动根据bson命名写入mongo 123456func SaveArtInfo(article *model.ArticleInfo) error &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() _, err := MongoDb.Collection(&quot;articles&quot;).InsertOne(ctx, article) return err&#125; 更新一条数据根据文章id更新浏览量 12345678910111213//更新文章浏览量func AddArticleScan(id string) error &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() filter := bson.M&#123;&quot;id&quot;: id&#125; value := bson.M&#123;&quot;$inc&quot;: bson.M&#123;&quot;scannum&quot;: 1&#125;&#125; _, err := MongoDb.Collection(&quot;articles&quot;).UpdateOne(ctx, filter, value) if err != nil &#123; return err &#125; return nil&#125; 更新时设置filter为更新的条件，value为更新的字段值，这里实现的是浏览量自增运算，如果要实现覆盖式更新也很简单 12345678910111213141516171819202122//更新文章func UpdateArticle(req *model.UpdateArticleReq) error &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() filter := bson.M&#123;&quot;id&quot;: req.Id&#125; value := bson.M&#123;&#125; value[&quot;title&quot;] = req.Title value[&quot;subtitle&quot;] = req.SubTitle value[&quot;cat&quot;] = req.Cat value[&quot;subcat&quot;] = req.SubCat value[&quot;lastedit&quot;] = req.LastEdit value[&quot;author&quot;] = req.Author //value[&quot;content&quot;] = req.Content upvalue := bson.M&#123;&quot;$set&quot;: value&#125; _, err := MongoDb.Collection(&quot;articles&quot;).UpdateOne(ctx, filter, upvalue) if err != nil &#123; return err &#125; return nil&#125;更新指定id的文章，更新字段值包括title，subtitle，cat，subcat等，此时用$set选项可以实现覆盖式更新 更新多条批量更新满足条件的多条记录，比如更新一个序列的文章列表，将其分类和子分类都更新为指定字段 12345678910111213141516//批量更新默认文章的分类func UpDefaultArtsCtg(cat string, subcat string, arts []string) error &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() //根据不同的条件，更新相同的值 filter := bson.M&#123;&quot;id&quot;: bson.M&#123;&quot;$in&quot;: arts&#125;&#125; //将该子分类的文章的子分类设置为新的分类 artupval := bson.M&#123;&quot;subcat&quot;: subcat, &quot;cat&quot;: cat&#125; artupcmd := bson.M&#123;&quot;$set&quot;: artupval&#125; _, err := MongoDb.Collection(&quot;articles&quot;).UpdateMany(ctx, filter, artupcmd) if err != nil &#123; return err &#125; return nil&#125; 上述代码将arts数组中的文章列表，统一更新了分类为cat，子分类为subcat如果需要将多条记录，更新成多个不同的值怎么处理呢？这里要用到bulkwrite 123456789101112131415161718192021//批量更新文章列表序列func UpdateArticleSort(sortArt *model.ArticleSortReq) error &#123; if len(sortArt.ArticleList) == 0 &#123; log.Println(&quot;sort article list is empty&quot;) return nil &#125; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() models := []mongo.WriteModel&#123;&#125; for _, article := range sortArt.ArticleList &#123; filter := bson.M&#123;&quot;id&quot;: article.Id, &quot;title&quot;: article.Title&#125; updatecmd := bson.D&#123;&#123;&quot;$set&quot;, bson.D&#123;&#123;&quot;index&quot;, article.Index&#125;&#125;&#125;&#125; model := mongo.NewUpdateOneModel().SetFilter(filter).SetUpdate(updatecmd).SetUpsert(false) models = append(models, model) &#125; //log.Println(&quot;models are &quot;, models) opts := options.BulkWrite().SetOrdered(false) _, err := MongoDb.Collection(&quot;articles&quot;).BulkWrite(ctx, models, opts) return err&#125; 上述代码将文章列表的多个文章的index更新为不同的值，index代表文章的排序索引，将不同文章的index值更新为不同的index，达到的效果就是id为1的文章index索引更新为index1，id为2的文章index更新为index2 分页查询可以对查询选项设置排序，并且设置每次获取多少条记录从而达到分页查询的效果。比如将skipTmp设置为5,10,15，将limitTmp设置为5就是每页获取五条记录，将sort设置为按照lastedit排序，就达到了根据最后编辑日期排序，并分页查询，获取每页五条数据的功能。 12345678910111213141516171819202122232425262728293031323334353637//获取文章列表func GetArticlesByPage(page int) ([]*model.ArticleInfo, error) &#123; articles := []*model.ArticleInfo&#123;&#125; if page &lt; 1 &#123; return articles, nil &#125; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() sort := bson.D&#123;&#123;&quot;lastedit&quot;, -1&#125;&#125; findOptions := options.Find().SetSort(sort) //从第1页获取，每次获取5条 skipTmp := int64((page - 1) * 5) limitTmp := int64(5) findOptions.Skip = &amp;skipTmp findOptions.Limit = &amp;limitTmp filter := bson.D&#123;&#125; cursor, err := MongoDb.Collection(&quot;articles&quot;).Find(ctx, filter, findOptions) if err != nil &#123; return articles, err &#125; defer cursor.Close(context.TODO()) for cursor.Next(context.TODO()) &#123; article := &amp;model.ArticleInfo&#123;&#125; if err := cursor.Decode(article); err != nil &#123; continue &#125; articles = append(articles, article) &#125; return articles, nil&#125; 获取文档总记录数量有时我们需要获取一个文档的所有记录数，比如分页查询后也要返回总的页数，这其实就是需要查询出总的条数计算返回总页数即可。 1234567891011121314//获取文章总数func ArticleTotalCount() (int, error) &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() filter := bson.D&#123;&#125; count, err := MongoDb.Collection(&quot;articles&quot;).CountDocuments(ctx, filter) if err != nil &#123; return 0, err &#125; return int(count), nil&#125; CountDocuments返回的是文档总的记录条数 模糊查询我们可以根据年月日以及分类查询，返回文章列表，当然还可以通过输入keywords关键字进行模糊查询。这里做一个较为复杂的查询，查询条件为某年某月某日创建的文章，分类为cat，并根据keywords模糊查询，如果文章内容或标题中有符合keywords的，返回该文章列表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//搜索文章func SearchArticle(condition *model.SearchArticleReq) ([]*model.ArticleInfo, int, error) &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() filter := bson.M&#123;&#125; if condition.Year != &quot;&quot; &amp;&amp; condition.Year != &quot;不限&quot; &#123; var stamp int64 = 0 valStr := condition.Year if condition.Month != &quot;&quot; &amp;&amp; condition.Month != &quot;不限&quot; &#123; tempStr := &quot;2006-01月&quot; valStr = valStr + &quot;-&quot; + condition.Month localTime, err := time.ParseInLocation(tempStr, valStr, time.Local) if err != nil &#123; log.Println(&quot;time parse failed, err is &quot;, err) &#125; else &#123; stamp = localTime.Unix() log.Println(&quot;query time stamp is &quot;, stamp) &#125; &#125; else &#123; localTime, err := time.ParseInLocation(&quot;2006&quot;, valStr, time.Local) if err != nil &#123; log.Println(&quot;time parse failed, err is &quot;, err) &#125; else &#123; stamp = localTime.Unix() log.Println(&quot;query time stamp is &quot;, stamp) &#125; &#125; filter[&quot;createdAt&quot;] = bson.M&#123;&quot;$gte&quot;: stamp&#125; &#125; if condition.Cat != &quot;&quot; &amp;&amp; condition.Cat != &quot;不限&quot; &#123; filter[&quot;cat&quot;] = condition.Cat &#125; if condition.Keywords != &quot;&quot; &amp;&amp; condition.Keywords != &quot;不限&quot; &#123; filter[&quot;$or&quot;] = []bson.M&#123; bson.M&#123; &quot;content&quot;: bson.M&#123;&quot;$regex&quot;: condition.Keywords, &quot;$options&quot;: &quot;$i&quot;&#125;, &#125;, bson.M&#123; &quot;title&quot;: bson.M&#123;&quot;$regex&quot;: condition.Keywords, &quot;$options&quot;: &quot;$i&quot;&#125;, &#125;, &#125; &#125; //log.Println(&quot;filter is &quot;, filter) sort := bson.D&#123;&#123;&quot;lastedit&quot;, -1&#125;&#125; findOptions := options.Find().SetSort(sort) //从第1页获取，每次获取5条 skipTmp := int64((condition.Page - 1) * 5) limitTmp := int64(5) findOptions.Skip = &amp;skipTmp findOptions.Limit = &amp;limitTmp articles := []*model.ArticleInfo&#123;&#125; cursor, err := MongoDb.Collection(&quot;articles&quot;).Find(ctx, filter, findOptions) if err != nil &#123; return articles, 0, err &#125; defer cursor.Close(context.TODO()) for cursor.Next(context.TODO()) &#123; article := &amp;model.ArticleInfo&#123;&#125; if err := cursor.Decode(article); err != nil &#123; continue &#125; articles = append(articles, article) &#125; count, err := MongoDb.Collection(&quot;articles&quot;).CountDocuments(ctx, filter) if err != nil &#123; return articles, 0, err &#125; return articles, int(count), nil&#125; 分组查询我们常遇到这种情况，查询每个班级成绩最好的学生，或者查询每个类别销量最好的产品品牌等，这里我也用到了分组查询，根据不同分类返回每个分类下最大index值，这样做主要是统计每个分类下文章最大索引。 123456789101112131415161718192021222324252627282930313233343536//获取子分类下最大indexfunc GetSubCatMaxIndex(subcat string) (int, error) &#123; ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() pipeline := bson.A&#123; bson.M&#123; &quot;$match&quot;: bson.M&#123;&quot;subcat&quot;: subcat&#125;, &#125;, bson.M&#123; &quot;$group&quot;: bson.M&#123; &quot;_id&quot;: bson.M&#123;&quot;subcat_&quot;: &quot;$subcat&quot;&#125;, &quot;maxIndex&quot;: bson.M&#123;&quot;$max&quot;: &quot;$index&quot;&#125;&#125;, &#125;, &#125; cursor, err := MongoDb.Collection(&quot;articles&quot;).Aggregate(ctx, pipeline) if err != nil &#123; log.Println(&quot;aggrete failed, error is &quot;, err) return 0, err &#125; maxIndex := 0 for cursor.Next(context.Background()) &#123; doc := cursor.Current maxindex_, err := doc.LookupErr(&quot;maxIndex&quot;) if err != nil &#123; log.Println(&quot;LookupErr failed, error is &quot;, err) return maxIndex, err &#125; log.Println(&quot;maxindex_ is &quot;, maxindex_) maxIndex = int(maxindex_.Int32()) log.Println(&quot;maxindex is &quot;, maxIndex) &#125; log.Println(&quot;get max index is &quot;, maxIndex) return maxIndex, nil&#125; 通过match匹配subcat，然后根据匹配结果进行分组，分组的区分的条件为subcat，分组条件的字段要用_id(只能用这个名字)表示，然后用maxIndex(可以自己命名)表示获取分组的最大索引。当然我们还可以做一些分组运算的其他操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//分组查询func findGroup() &#123; client := mongodb.DB.Mongo collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() //复杂查询，先匹配后分组 pipeline := bson.A&#123; bson.M&#123; &quot;$match&quot;: bson.M&#123;&quot;birthMonth&quot;: 3&#125;, &#125;, bson.M&#123;&quot;$group&quot;: bson.M&#123; &quot;_id&quot;: bson.M&#123;&quot;birthMonthUid&quot;: &quot;$birthMonth&quot;&#125;, &quot;totalCount&quot;: bson.M&#123;&quot;$sum&quot;: 1&#125;, &quot;nameG&quot;: bson.M&#123;&quot;$min&quot;: &quot;$name&quot;&#125;, &quot;ageG&quot;: bson.M&#123;&quot;$min&quot;: &quot;$age&quot;&#125;, &#125;, &#125;, //bson.M&#123;&quot;$sort&quot;: bson.M&#123;&quot;time&quot;: 1&#125;&#125;, &#125; fmt.Println(&quot;pipeline is &quot;, pipeline) cursor, err := collection.Aggregate(ctx, pipeline) fmt.Println(&quot;findGroup cursor is &quot;, cursor) if err != nil &#123; fmt.Printf(&quot;dao.findGroup collection.Aggregate() error=[%s]\\n&quot;, err) return &#125; for cursor.Next(context.Background()) &#123; doc := cursor.Current totalCount, err_2 := doc.LookupErr(&quot;totalCount&quot;) if err_2 != nil &#123; fmt.Printf(&quot;dao.findGroup totalCount err_2=[%s]\\n&quot;, err_2) return &#125; nameData, err_4 := doc.LookupErr(&quot;nameG&quot;) if err_4 != nil &#123; fmt.Printf(&quot;dao.findGroup insertDateG err_4=[%s]\\n&quot;, err_4) return &#125; ageData, err_5 := doc.LookupErr(&quot;ageG&quot;) if err_5 != nil &#123; fmt.Printf(&quot;dao.findGroup ageG err_5=[%s]\\n&quot;, err_5) continue &#125; fmt.Println(&quot;totalCount is &quot;, totalCount) fmt.Println(&quot;nameData is &quot;, nameData) fmt.Println(&quot;ageData is &quot;, ageData) &#125;&#125; 先用birthday做查询，匹配三月份出生的人，然后根据月份进行分组，totalCount用来计算分组下人的总数，nameG表示最小名字等。 文档内查询有时候mongo的文档中的记录形式为一条记录，该记录有多个字段，某个字段为一个数组列表，查询记录中数组列表某个值满足条件，返回该记录。我有这样一个文档，表示文章的目录菜单 123456789101112131415161718&#123; &quot;_id&quot;:&#123;&quot;$oid&quot;:&quot;61138b43094825c520604e56&quot;&#125;, &quot;catmenus&quot;:[ &#123; &quot;catid&quot;:&quot;1wZexxzy9FsQOtdfKSro5EM6Zzv&quot;, &quot;name&quot;:&quot;C++&quot;, &quot;subcatmenus&quot;: [ &#123;&quot;subcatid&quot;:&quot;1wZf3EsGe5UdNxXTcH71iEfxgpb&quot;,&quot;name&quot;:&quot;变量&quot;&#125;, &#123;&quot;subcatid&quot;:&quot;1wZfFxSHDw5gdOF0g39lb72n8r9&quot;,&quot;name&quot;:&quot;aa&quot;&#125;, &#123;&quot;subcatid&quot;:&quot;1wZldzHUziSZyTXvfhO9FNfRWnD&quot;,&quot;name&quot;:&quot;&quot;&#125;] &#125;, &#123; &quot;catid&quot;:&quot;1wZezd7c961MNGZ0s0U8aUef4hq&quot;, &quot;name&quot;:&quot;Go&quot;, &quot;subcatmenus&quot;:[ &#123;&quot;subcatid&quot;:&quot;1wZfHzBeJmDOtNt3XdMysAQ1bhh&quot;,&quot;name&quot;:&quot;aaa&quot;&#125; ] &#125; ] &#125; 当想查询文档内catid为1wZezd7c961MNGZ0s0U8aUef4hq的片段，并且更新其subcatmenus字段为新的数组db.menu.find({“catmenus.catid”:”1wZezd7c961MNGZ0s0U8aUef4hq”})是可以查询到该记录的，但是这种查询只限于单个条件，如果有多个条件如下db.menu.find({“catmenus.catid”:”1wZezd7c961MNGZ0s0U8aUef4hq”,”catmenus.name”:”Go”})如果有多条记录分别满足条件，查询的就有可能是多条，而不是交集，mongo返回满足以上条件任意一条即可。为了要实现交集选择器，则需要用elemMatchdb.menu.find({“catmenus”: {“$elemMatch”:{“catid”:”1wZezd7c961MNGZ0s0U8aUef4hq”, “name”:”Go”}}})转化为go代码实现查询 123456789101112131415161718192021func UpdateSortMenu(submenu *model.SortMenuReq) error &#123; ctx, _ := context.WithTimeout(context.Background(), 5*time.Second) //指定连接集合 col := MongoDb.Collection(&quot;menu&quot;) //设定更新filter //filter := bson.D&#123;&#123;&quot;catmenus.catid&quot;, submenu.ParentId&#125;&#125; filter := bson.D&#123;&#123;&quot;catmenus&quot;, bson.D&#123;&#123;&quot;$elemMatch&quot;, bson.D&#123;&#123;&quot;catid&quot;, submenu.ParentId&#125;&#125;, &#125;&#125;, &#125;&#125; update := bson.D&#123;&#123;&quot;$set&quot;, bson.D&#123; &#123;&quot;catmenus.$.subcatmenus&quot;, submenu.Menu&#125;, &#125;&#125;&#125; _, err := col.UpdateOne(ctx, filter, update) return err&#125; 目前收录了几种常见的go操作mongo的方法，都是基于mongo原生支持的操作实现的。","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"js继承的六种方案","date":"2021-01-05T03:49:01.000Z","path":"2021/01/05/js03/","text":"今天谈谈js中六种继承方式,在介绍继承方式前我们先熟悉几个常用的函数因为for循环默认会将实例的私有属性和它所属原型上扩展的属性和方法都可以遍历到但是可以通过propertyIsEnumerable检测只打印私有的 123456789for (var key in obj)&#123; if(obj.propertyIsEnumerable(key))&#123; console.log(obj[key]) &#125; if(obj.hasOwnPropery(key))&#123; console.log(key) &#125;&#125; 上述代码会打印obj的私有属性和方法。下面开始第一个继承，原型继承 原型继承12345678910111213141516171819function Fn()&#123;&#125;var obj=&#123; constructor = Fn, name: &quot;zack&quot;, age:7, getX:function()&#123; &#125;&#125;Fn.prototype= objvar f = new Fn()console.log(f.name)var obj3 = Object.create(obj)console.log(obj3.name) 通过修改Fn.prototype指向obj，以后new Fn生成的实例都具有obj的属性我们也可以通过Object.create(obj)创建一个新的对象，这个对象的原型为obj，所以新对象也继承了obj的私有属性和公有属性将原型继承简化下 123456789101112 function Base()&#123; getX:function()&#123; &#125;&#125; function Derive()&#123; &#125; Derive.prototype= new Base() var nNode = new Derive() 原型继承是我们js中最常用的一种继承方式子类Base想要继承父类Derive中的所有属性和方法(私有+公有)只需要让Derive.prototype=new Base; 即可原型继承的特点，他是把父类中私有的+公有的都继承到了子类原型上(子类公有的)核心：原型继承并不是把父类中的属性和方法克隆一份一模一样的给Derive而是让Derive和Base之间增加了原型链的连接，以后Derive的实例nNode想要使用Base中的getX方法需要一级级向上查找来使用 call继承call继承，就是把父类私有的属性和方法克隆一份一模一样的给子类私有属性 1234567891011121314function A()&#123; this.x = 100&#125;A.prototype.getX=function()&#123; console.log(this.x)&#125;function B()&#123; A.call(this)&#125;var n = new Bconsole.log(n.x) call函数修改了调用者A的this为B，所以执行A.call(this),其实是执行A的构造函数，将this换为B，B的x赋值为100。call继承保证了把父类私有的属性和方法克隆一份一模一样的给子类私有属性 冒充对象继承12345678910111213141516function A()&#123; this.x = 100&#125;A.prototype.getX=function()&#123; console.log(this.x)&#125;function B()&#123; var temp = new A for (var key in temp)&#123; this[key] = temp[key] &#125; temp = null&#125;var n = new Bconsole.log(n.x) 冒充对象继承: 把父类私有的+公有的克隆一份一模一样的给子类私有的 混合继承模式:原型继承+call继承12345678910111213141516function A()&#123; this.x = 100&#125;A.prototype.getX = function()&#123; console.log(this.x)&#125;function B()&#123; A.call(this)&#125;B.prototype = new A B.prototype.constructor = Bvar n = new Bn.getX() 混合继承，基础原理就是通过call继承将基类的私有属性和方法继承过来，然后通过原型继承，将基类的私有和公有属性方法等全部继承过来。这样会造成私有属性的重复，不过也是很不错的一种继承方式。 寄生继承12345678910111213141516function A()&#123; this.x = 100&#125;A.prototype.getX=function()&#123; console.log(this.x)&#125;function B()&#123; A.call(this)&#125;B.prototype = Object.create(A.prototype)B.prototype.constructor = Bvar n = new Bn.getX() 通过call继承将A类的私有属性赋值给B，然后通过Object.create(A.prototype)将A的原型公有属性赋值给B。我们可以自己实现一个类似于Object.create(pro)的函数 12345678910111213141516171819202122232425function CreateObj(obj)&#123; function NewObj()&#123; &#125; NewObj.prototype = obj return new NewObj()&#125;unction A()&#123; this.x = 100&#125;A.prototype.getX=function()&#123; console.log(this.x)&#125;function B()&#123; A.call(this)&#125;B.prototype = CreateObj(A.prototype)B.prototype.constructor = Bvar n = new Bn.getX() 中间件继承法如果我们想对一个类数组arguments，但不是数组进行数组操作，比如排序, shift, pop, join等。需要调用call方法将arguments,替代数组 123456789function avgFn()&#123; Array.prototype.sort.call(arguments, function(a,b)&#123; return a-b &#125;) Array.prototype.pop.call(arguments) Array.prototype.shift.call(arguments) return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2)&#125; 为了让arguments直接使用数组得方法,可以修改其__proto__方法 1234567891011function avgFn()&#123; arguments.__proto__ = Array.prototype arguments.sort(function (a, b)&#123; return a -b &#125;) arguments.pop() arguments.shift() return eval(arguments.join(&quot;+&quot;))/arguments.length &#125; console.log(avgFn(10,20,30,10,30,40)) 感谢关注感谢关注我的公众号","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.limerence2017.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.limerence2017.com/tags/JavaScript/"}]},{"title":"js原型链看这篇就够了","date":"2020-12-01T11:59:05.000Z","path":"2020/12/01/js02/","text":"面向对象把描述同一个事物(同一个对象)的属性和方法放在同一个内存空间下不同事物之间的属性即使属性名相同，相互也不会冲突这种方式为js的面向对象 123456789101112131415161718var person1 = &#123; name:&quot;zack&quot;, age:32&#125;var person2 = &#123; name:&quot;vi&quot;, age:32&#125;var jsPerson1=&#123; name:&quot;zack&quot;, age:32, writeJs:function()&#123; console.log(&quot;my name is &quot; + this.name + &quot;, i can write js &quot;) &#125;&#125;jsPerson1.writeJs() 工厂模式把实现同一个事情的相同代码放在同一个函数中 123456789101112function createJSPerson(name, age)&#123; var obj=&#123;&#125; obj.name = name obj.age =age obj.writeJs = function()&#123; console.log(&quot;my name is &quot;+ this.name + &quot; , i can write js&quot;) &#125; return obj&#125;p1 = createJSPerson(&quot;zack&quot;, 32)p1.writeJs() 通过函数createJSPerson批量产生类实例 构造函数模式构造函数的目的就是创建一个自定义类，并且创建这个类的实例构造函数模式和工厂模式的区别1 执行的时候 普通函数执行 -&gt;createJsPerson() 构造函数模式 -&gt;new createJsPerson() new 执行后 createJsPerson就是一个类 1234567891011function CreateJsPerson(name, age) &#123; var obj=&#123;&#125; obj.name = name obj.age = age obj.writeJs = function()&#123; console.log(&quot;my name is &quot;+ this.name + &quot; , i can wirte js&quot;) &#125; return obj&#125;p2 = new CreateJsPerson(&quot;zack&quot;, 32)p2.writeJs() 类是函数类型， 他通过new执行变成了一个类，但他本身也是一个普通函数实例都是对象类型2 在函数代码执行的时候相同：都形成私有作用域，然后经历形参赋值-&gt;预解释-&gt;代码从上到下执行(类和普通函数一样)不同:在代码执行之前，不用自己在手动创建对象了，浏览器会默认创建一个对象数据类型的值 这个对象其实就是我们当前类的一个实例 接下来，代码从上到下执行，以当前实例为执行主体(this代表的就是当前实例)分别把属性名和属性值 赋值给当前实例 1234567function PersonClass(name, age)&#123; this.name = name; this.age = age; this.writeJs = function()&#123; console.log(&quot;my name is &quot; + this.name + &quot;, i can write js&quot;) &#125; &#125; 在构造函数模式中，类中(函数体中)出现的this.xxx = xxx 中的this是当前类的一个实例 1234var p1 = new PersonClass(&quot;zack&quot;, 32)p1.writeJs()var p2 = new PersonClass(&quot;vico&quot;, 32)p2.writeJs() 3 p1和p2都是createjsperson这个类的实例，都拥有writeJs这个方法，但是不同实例之间的方法是不一样的 在类中给实例增加的属性(this.xxx=xxx)属于当前实例的私有属性，实例和实例之间是单独的个体 私有属性之间是不相等的 123456console.log(p1.writeJs === p2.writeJs)res = PersonClass(&quot;rolin&quot;,31)//未返回对象，所以res为undefinedconsole.log(res)//函数模式this为window，所以this.name = &quot;rolin&quot;，window属性name为rolinconsole.log(window.name) 类中的this1234567function Fn()&#123; var num = 10; this.x = 100; this.getX = function()&#123; console.log(this.x) &#125; &#125; 1 构造函数模式中new Fn()执行， 如果Fn不需要传递参数，那么小括号可以省略2 this的问题:在类中出现的this.xxx=xxx出现的this都是当前类的实例，而某一个属性值如果是方法该方法中的this要看执行时前面是否有”.”才能知道this是谁 123456var f1 = new Fn;//-&gt;方法中的this是f1 -&gt;100f1.getX();var ss = f1.getX;//-&gt;方法中的this是window -&gt;undefined ss(); 3 类有普通函数的一面，当函数执行的时候，var num 其实只是当前形成的私有作用域中私有变量而已 它和我们的f1这个实例没有任何关系 12//undefinedconsole.log(f1.num) 4 在构造函数模式中，浏览器会默认把我们的实例返回(返回的是一个对象数据类型的值)如果我们自己手动写了return返回，返回的是一个基本数据类型的值，当前实例是不变的，例如return 100返回的是一个引用类型的值，当前的实例会被自己返回的值给替换掉 例如 return {name:”zack”}5 检测某一个实例是否属于这个类 123456789console.log(f1 instanceof Fn)//因为所有的实例都是对象数据类型的，//而每个对象数据类型都是Object这个内置类型的一个实例//所以f1也是他的一个实例console.log(f1 instanceof Object)//对于检测数据类型来说，typeof有自己的局限性，//不能细分object下的对象，数组，正则...var a=[];console.log(a instanceof Array) 6 f1和f2都是Fn这个类的一个实例，都拥有x和getx两个属性 但是这两个属性是各自的私有属性 1234567891011121314var f2 = new Fn;console.log(f1.getX === f2.getX)//in:检测某一个属性是否属于这个对象(attr in object)//不管是私有属性还是公有属性，只要存在，用in来检测都是true//hasOwnProperty:用来检测某一个属性是否为这个对象的&quot;私有属性&quot;//这个方法只能检测私有属性console.log(&quot;getX&quot; in f1)console.log(f1.hasOwnProperty(&quot;getX&quot;));//检测某一个属性是否为该对象的&quot;公有属性&quot; hasPubPropertyfunction hasPubProperty(obj, attr) &#123; return attr in obj &amp;&amp; !(obj.hasOwnProperty(attr))&#125;console.log(hasPubProperty(f1,&quot;getX&quot;)) 批量设置属性构造函数有一个问题就是变量的方法不是公有的，每个变量保存了一份自己的方法。这样不符合面向对象的设计其实每个类都有一个prototype属性，它指向一片系统开辟的空间，所有类实例共享这篇空间。而每个实例都有一个_proto_属性，也指向这个空间，这个空间同样存储了一个类对象，类对象有一个属性contructor表示代表他的构造类，该类对象还有一个_proto_属性也指向了一个系统开辟的空间，该空间存储的类实例对象为Object类型的。这个类对象的constructor属性值为Object所以Object类的prototype也指向了这个Object类实例。 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt;function Fn()&#123; this.x = 100 this.sum = function()&#123; console.log(this.x) &#125;&#125;var pro = Fn.prototype//把原来原型指向的地址赋值给pro，现在他们操作的是同一个内存空间pro.getX = function()&#123; console.log(this.x)&#125;pro.sum = function()&#123; console.log(this.x)&#125;var f1 = new Fn;var f2 = new Fn;&lt;/script&gt; 将上述类关系画成图形如下Fn类的prototype指向了系统开辟的空间，该空间存储了一个实例，(我们假设命名其为A)其constructor属性为Fn，并且包括getX和sum公有方法。每一个类对象都有一个_proto_属性，f1和和f2的_proto_也指向了A。因为A是类的实例，所以A也有_proto_属性，其属性指向另一个对象B，这个B也有一个constructor属性为Object，B的_proto_和Object的prototype指向的都是B自己。所以每一个对象实例都可以根据_proto_找到Object类型的实例。每一个类的都可以根据prototype找到Object类型的实例。这就是原型链 重构原型链对象我们可以自己开辟一块新的内存，存储我们公有的属性和方法，把浏览器原来的内存替换掉 12345678910111213function Fn()&#123; this.x=100&#125;Fn.prototype=&#123; constructor:Fn, a:function()&#123;&#125;, b:function()&#123;&#125;&#125;var f = new Fn()f.a()f.b()console.log(f.constructor) 只有浏览器天生给Fn.prototype开辟的堆内存里才有constructor，我们自己开辟的堆内存中没有这个属性，所以要手动添加。我们可以通过修改堆内存对象的属性，达到添加方法的目的 123456789101112131415Array.prototype.mysort=function()&#123; for (var i = 0; i &lt; this.length; i ++)&#123; for(var j=i+1; j &lt; this.length; j++)&#123; if(this[i] &gt; this[j])&#123; var temp = this[i] this[i] = this[j] this[j] = temp &#125; &#125; &#125;&#125;var ary = [1,2,2,1,2,3,4,2,1,3]ary.mysort()console.log(ary) 原型模式的this在原型模式中，this常用的有两种情况在类中this.xxx=xxx; this代表的就是当前实例在某一个方法中的this，this需要看执行的时候方法前”.”是谁，this就是谁 需要先确定this指向是谁 把this替换成对应的代码 按照原型链查找机制，一步步查找结果12345678910111213141516171819202122232425function Fn()&#123; this.x=100 this.y=200 this.getY= function()&#123; console.log(this.y) &#125;&#125;Fn.prototype=&#123; constructor:Fn, y:300, getX:function()&#123; console.log(this.x) &#125;, getY:function()&#123; console.log(this.y) &#125;&#125;var f = new Fnf.getX() //f.x -&gt; 100f.getY() //f.y -&gt; 200f.__proto__.getX()//undefinedFn.prototype.getX()//undefinedf.__proto__.getY() //300 12345f.getX()中this为f，所以f.x为100f.getY()中this为f, 所以f.y为200f.__proto__.getX() 因为f.__proto__中没有x，所以为undefinedFn.prototype.getX() 因为Fn.prototype和f.__proto__指向的堆内存是一个，所以也为undefinedf.__proto__.getY() 因为f.__proto__中有y，所以输出为300 我们实现一个数组去重的方法 12345678910111213141516171819Array.prototype.myUnique = function() &#123; var obj=&#123;&#125; for (var i = 0; i &lt; this.length; i ++)&#123; var cur = this[i] if(obj[cur] == cur)&#123; this[i] = this[this.length-1] i-- this.length-- continue &#125; obj[cur] = cur &#125; obj = null return this&#125;var ary=[12,12,23,44,56,44]ary.myUnique()console.log(ary) 我们实现了去重方法，并在方法内返回this，这么做的好处就是可以继续调用array的其他方法，也就是大家所说的链式调用比如我们可以继续调用sort方法 1ary.myUnique().sort(function(a,b)&#123;return a-b&#125;) 总结1234567891011121314151617构造函数模式找到了类和实例的概念，并且实例和实例之间是独立开的构造函数的原型模式解决了方法或者属性公有的问题，把实例之间相同的属性和方法提取成公有的属性和方法1 每一个函数数据类型(普通函数，类)都有一个天生自带的属性:prototype(原型)并且这个属性是一个对象数据类型的值2 并且在prototype上浏览器给他加了一个属性constructor(构造函数)属性值是当前函数本身3 每一个对象数据类型(普通对象，实例，prototye)也天生自带一个属性： __proto__ , 属性值是当前实例所属类的原型(prototype)原型链查找方式通过对象名.属性名 的方式获取属性值的时候，首先在对象的私有属性上查找，如果私有属性中没这个属性则获取的是私有属性值如果私有的没有，则通过__proto__找到所属类的原型(类的原型上定义的属性和方法都是当前实例公有的属性和方法)，原型上存在的话，获取的是公有的属性值如果原型上也没有，则继续通过原型上的__proto__向上查找，一直找到Object.prototype为止... 感谢关注感谢关注我的公众号","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.limerence2017.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.limerence2017.com/tags/JavaScript/"}]},{"title":"JavaScript预解释原理，看这篇就够了","date":"2020-11-12T12:24:42.000Z","path":"2020/11/12/js01/","text":"预解释原理和代码分析JavaScript预解释，也就是变量提升，将var定义的变量提前声明到代码最上层，不再赘述其定义，直接上代码。当浏览器开始解析js代码的时候，首先看当前运行环境(作用域)内带var和function，带var的变量会提前声明(预解释)但是不会赋值，带function的会提前声明并赋值。带var变量提前声明的时候并不会被赋值，但是有一个默认的nudefined值。当代码执行过后才会赋值。堆栈内存：代码运行的环境在栈内存，基本数据类型都存在栈内存里, 引用类型(对象和function)在堆里。 1234567891011121314151617console.log(num);console.log(obj);console.log(a);console.log(sum);var num = 12;console.log(num);var obj = &#123;&#x27;name&#x27;:&#x27;tianxi&#x27;, age:30&#125;; //对象类型console.log(obj);console.log(haha);var a=function()&#123;&#125;;function sum(num1, num2)&#123; function haha()&#123; &#125;; var total = 0; total = num1 + num2;&#125; 上述代码输出 12345678910undefinedundefinedundefined[Function: sum]12&#123; name: &#x27;tianxi&#x27;, age: 30 &#125;E:\\jswork\\js-learn\\01-预解释\\预解释1.js:17console.log(haha); ^ReferenceError: haha is not defined 上述代码在运行至console.log(haha);时会崩溃。因为预解释(变量提升)将num,obj,以及a的声明都提升到代码最上层，所以打印num,obj,a都是undefined预解释只关注等号左边的变量，并不关心右边是什么值,所以打印a也是undefinedsum是函数，预解释会提前声明sum，并为sum赋值，比如将sum赋值为0xfffcc2d，而0xfffcc2d地址内存储的就是sum函数体的内容。所以打印sum会输出”Function sum”而第二次打印num会输出12，因为此时num被赋值了打印obj会输出obj内容，sum函数内部定义的函数haha以及变量total等只有在sum运行时才会做预解释，如果sum不运行，则haha等不会被预解释，所以打印haha会出现 “haha is not defined”的异常。 全局作用域的细节在全局作用域下，加var和不加var的区别1 是否被提前声明2 不加var那么就是一个赋值过程，相当于给window添加了一个属性并且赋值当函数在运行的时候就会产生一个私有的作用域，并且这个作用域内的变量也是私有变量。并且这个私有变量在外访问不到，我们把这种函数运行的时候产生的私有作用域里的私有变量不受外界干扰的这种机制叫做闭包 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&lt;script&gt;console.log(total);var total = 0;function fn(num1, num2)&#123; console.log(total); var total = num1 + num2; console.log(total);&#125;fn(100,200);console.log(total);&lt;/script&gt; 程序输出 1234undefinedundefined3000 全局变量total会预解释，所以第一个total输出undefined接着fn预解释并定义，然后执行fn(100,200)执行fn时，num1,num2被视为私有变量，total也被是为私有变量，在fn私有作用域预解释所以第二个total输出为undefined，第三个total输出为300最后一个total因为是全局变量，所以输出是0 私有作用域和作用域链函数的运行： 1 如果有形参是形参赋值 2 预解释 3 代码逐行执行 ..区别私有变量还是全局变量：函数运行的时候，函数体内如有带var就是私有变量，如果是形参也可以理解是一个私有变量。代码在执行的时候，首先查找当前运行环境内(作用域，栈)的私有变量，如果有直接用，如果没有去上一级作用域去查找，如果有就拿来用，如果没有一直查找到顶级的window全局作用域，如果没有就报错”not defined”,我们把这种查找机制叫做作用域链 123456789console.log(total);var total = 0;function fn(num1, num2) &#123; console.log(total); total = num1 + num2; console.log(total);&#125;fn(100,200);console.log(total); 程序输出 1234undefined0300300 //全局total会预解释提前声明，fn会预解释，提前声明fn并为fn赋值地址，//因为打印第一个total，所以为undefined//接着执行fn，因fn内部total不是私有变量，根据作用域链继续向上查找，找到window全局作用域，//进而找到全局total，所以第二个total输出为0，第三个为300，而最后一个total输出也为300全局作用域如果不加var对一个变量赋值，相当于给window添加一个属性 1234var num = 12;console.log(num); //12console.log(num2); //Uncaught ReferenceError: num2 is not definednum2 = 12; 因为num2未加var定义，所以无法预解释，输出num2会异常 1234var num = 12;console.log(num);num2 = 12;console.log(num2); 两个输出都是12,因为num2未加var，所以相当于给window增加了一个num2的属性名，属性值为12var num = 12相当于定义了一个全局变量num,而且也相当于给window增加了一个属性名num,属性值为12所以当输出num时系统会优先查找num全局变量，输出num2因为没有全局变量num2，所以会输出window的属性名，window.num2 123456function fn() &#123; console.log(total); total = 100;&#125;fn();console.log(total); 上述代码会报错，因为fn内部输出total会根据作用域链向上查找，没有全局变量total,全局window中没有total这个属性，所以会异常，程序运行到fn就异常终止了。 12345function fn() &#123; total = 100;&#125;fn();console.log(total); 上述代码会输出100因为fn内部对total赋值会向上查找，直到window作用域，也没有找到全局变量total所以就相当于给window添加了一个total的属性，属性值为12，所以输出100 预解释的几个坑1234if (!(&quot;num&quot; in window)) &#123; var num = 12;&#125;console.log(num) 1 预解释不管条件是否成立，都会把var的变量提前声明所以”num” in window 返回ture，！就是false，那么num不会赋值，所以输出undefined 1234fn();var fn = function()&#123; console.log(&quot;ok&quot;);&#125;; 2 匿名函数之函数表达式，把函数定义的部分当作值赋值给一个变量或者元素的一个事件预解释的时候只预解释”=”左边的，右边的是值，不参与预解释window下的预解释：var fn上述代码在执行fn();时会报异常，”fn is not a function”因为fn预解释只做声明，未作赋值。 12345fn();function fn()&#123; console.log(&quot;ok&quot;);&#125;fn(); 因为这种方式预解释会将fn声明并赋值为对空间的地址，地址里存储的时函数体内容。所以当执行fn时都会输出ok3 自执行函数定义的那个function在全局作用域下不进行预解释，当代码执行到这个位置的时候定义和执行一起完成了,自执行函数:定义和执行在一起完成了 123~function()&#123; var num = 1200;&#125;(); 12345678function fn()&#123; console.log(num); //undefined return function()&#123; &#125;; var num = 100;&#125;fn(); 4 函数体中return下边的代码虽然不执行了，但是需要进行预解释return后面跟着都是返回值，所以不进行预解释，也就是fn内部返回的function()不进行预解释所以上述代码输出undefined5 要注意变量名冲突 1234var fn=13;function fn() &#123; console.log(&quot;ok&quot;);&#125; 在js中,如果变量的名字和函数的名字重复了，也算冲突在预解释的时候如果名字已经声明过，不需要重新声明，但是需要重新赋值 1234567fn();function fn()&#123; console.log(1);&#125;;fn();var fn=10;fn();function fn()&#123;console.log(2);&#125;;fn(); 上述代码会输出两个2，第三次会报异常因为fn为函数，预解释，提前声明并赋值内存地址，fn=xxxxfff111因为预解释不会对同一个变量重复声明，所以var fn=10不会声明function fn(){console.log(2);};也不会声明，但是会将fn重新赋值 fn=xxxxd209所以会连续输出两次2，fn=10，fn()会被视为10(),这样就会报错fn is not a function 1234567891011121314var num = 12;function fn() &#123; var num = 120; return function()&#123; console.log(num); &#125;;&#125;var f = fn();f();~function()&#123; var num = 1200; f();&#125;(); 上述代码输出 12120120 因为执行f时num不是私有变量，会继续向上查找，找到fn的私有作用域num=120，所以输出两个120 如何查找当前作用域的上一级作用域？看当前函数是在哪个作用域下定义的，那么他的上级作用域就是谁和函数在哪里执行的没有任何关系 对象数据类型和函数数据类型在定义的时候都会开辟一个堆内存，堆内存有一个引用地址。这个地址赋值给外部变量，那么这块内存引用计数增加，就不会释放了。可以让外部变量赋值为null，那么堆内存的引用计数就减少，当引用计数为0，则内存就会释放了。，全局作用域只有当页面关闭的时候才会销毁私有作用域(只有函数执行会产生私有作用域)一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域代码执行完成后，当前作用域都会主动释放和销毁。特殊情况:当前私有作用域中的部分内容被作用域以外的东西占用了，那么当前的这个作用域就不能销毁了a 函数执行返回了一个引用数据类型的值，并且在函数的外边被一个其他的东西给接受了，//这种情况下一般形成的私有作用域都会销毁 1234567function fn()&#123; var num = 100; return function()&#123; &#125;&#125;var f = fn(); 此时fn执行形成的私有作用域不能销毁，因为function(){}的堆内存被f占用了，所以fn无法回收自己的私有作用域b 在一个私有作用域中给DOM元素的事件绑定方法，一般情况下私有作用域都不销毁 123456var oDiv = document.getElementById(&quot;div1&quot;);~function()&#123; oDiv.onclick = function()&#123; &#125;&#125;(); 当前自执行函数形成的私有作用域也不会销毁c 下述情况不立即销毁，fn返回的函数没被其他变量占用，但是需要执行一才会释放。 1234567function fn() &#123; var num = 100; return function()&#123; &#125;&#125;fn()(); 首先执行fn，返回一个小函数对应的内存地址，然后让返回的小函数再执行 1234567891011function fn()&#123; var i = 10; return function(n)&#123; console.log(n+(++i)); &#125;&#125;var f = fn();f(10)f(20);fn()(10);fn()(20); 函数输出如下 123421322131 因为fn将返回的函数地址赋值给f，所以fn私有作用域不会被回收，那么i的信息就会被记录第一次++i ,i变为11，所以f(10)为21，接下来f(20),因为fn私有作用域没有被回收，++ii变为12，那么f(20)就是32，而fn()(10)这种方式调用fn每次都会回收私有作用域所以i每次都是11，那么f()(10)就是21,f()(20)就是31类似的问题还有这个 12345678910function fn(i) &#123; return function(n) &#123; console.log(n + i++); &#125;&#125;var f = fn(13);f(12);f(14);fn(15)(12);fn(16)(13); 程序输出 123425282729 fn内部调用function(n)因为i会根据作用域链向上查找，找到fn的形参i，所以此时i为13，f(12)为25f(14)因为fn不会释放作用域，所有i为14,此时f(14)为28fn(15)(12)每次运行都会产生新的作用域，调用结束后释放，所以为27fn(16)(13)结果为29 如何判断thisjs中this代表的是当前行为执行的主体;js中context代表的是当前行为执行的环境this是谁和函数在哪定义的和在哪执行的都没有关系1 函数执行, 首先看函数名前是否有”.”,如果有”.”前面是谁this就是谁如果没有”.”,this就是window 1234567891011121314151617181920function fn() &#123; console.log(this);&#125;var obj=&#123; fn: fn&#125;;fn() //this为windowobj.fn(); //this为objfunction sum()&#123; fn(); //this为window&#125;sum();var oo= &#123; sum: function()&#123; //this为oo fn(); //this 为window &#125;&#125;;oo.sum(); 2 自执行函数中的this永远是window3 给元素的某一个事件绑定方法，当事件触发时候，执行对应的方法，方法中的this就是当前元素 1234567function fn() &#123; console.log(this);&#125;document.getElementById(&quot;div1&quot;).onclick = fn; //fn中this为元素document.getElementById(&quot;div1&quot;).onclick = function()&#123; fn(); //fn中的this为window&#125;; fn赋值给div元素的onclick，每次点击后fn打印的this都是当前元素而将匿名函数赋值给onclick，每次点击后fn打印的this都是window 综合运用实战接下来我们综合运用实战下，以下例题 12345678910111213141516171819var num = 20;var obj = &#123; num:30, fn:(function (num)&#123; this.num *= 3; num += 15; var num = 45; return function()&#123; this.num *= 4; num += 20; console.log(num); &#125; &#125;)(num)&#125;;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 给fn赋值的自执行函数function的形参num传递的值为全局变量num，num为20，而不是30只有明确指明obj.num才是传递obj的num执行自执行函数num为20，this.num中this为window所以this.num*=3所以全局num变为60,私有作用域num为20，所以var num预解释不做声明num+=15,num变为35，接下来num赋值为45，最后返回匿名函数function()此时调用fn(),this.num为全局num,this.num*=4，全局变量变为240，num+=20，num会根据追踪链追踪至上层的num此时num为45，所以num+=20后变为65，先输出65obj.fn()中的this为obj，obj此时num为30，所以this.num*=4，obj的num变为120，num+=20会向上查找，找到自执行函数因为匿名函数被外界引用所以无法释放，进而自执行函数num无法释放，num之前为65，num+=20，num变为85输出window.num为240，obj.num为120 感谢关注感谢关注我的公众号","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.limerence2017.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.limerence2017.com/tags/JavaScript/"}]},{"title":"k8s知识补充和汇总","date":"2020-11-06T02:50:58.000Z","path":"2020/11/06/docker21/","text":"今天补充下k8s命令和基础，查缺补漏。 kubectl命令kubectl 是k8s操作的基本命令 1234567891011121314151617kubectl get nodes 获取集群运行的节点信息kubectl config get-contexts 获取集群上下文信息kubectl get pods 获取集群的pod信息kubectl get svc 获取服务信息kubectl get namespace 获取namespace信息可以通过-n 指定namespacekubectl get svc -n kube-system也可以查看当前的上下文信息kubectl config current-context可以设置上下文kubectl config set-context kubeadm使用某个上下文kubectl config use-context kubeadm查看节点信息kubectl describe node 节点id查看node扩充信息kubectl get node -o wide 节点和标签可以通过Kubectl get 指定节点得名字获得指定节点得信息 1kubectl get node master-node 我们查看节点详细信息可以指明类型 12kubectl get node -o yamlkubectl get node -o json 查看节点及其labels 1kubectl get node --show-labels 会显示所有节点，及其所有labels 1234NAME STATUS ROLES AGE VERSION LABELSzackhost Ready master 5d18h v1.15.4 beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=zackhbernetes.io/master= 我们可以给指定的节点打标签 1kubectl label node zackhost env=test 查看label 1kubectl get node --show-labels 可以看到env=test的label了 12NAME STATUS ROLES AGE VERSION LABELSzackhost Ready master 5d19h v1.15.4 beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,env=test, kubernetes.io/arch=amd64,kubernetes.io/hostname=zackhost,kubernetes.io/os=linux,node-role.kubernetes.io/master= 删除label 1kubectl label node zackhost env- 删除时将对应的key值env后边写上-就是删除key值为env的label给节点设置角色worker 1kubectl label node k8s-node1 node-role.kubernetes.io/worker= pod总结pod是一个或者一组应用容器，他们分享资源(volume等)pod内容器分享相同的命名空间，如ip地址等Pod是k8s最小的调度单位Pod的定义 1234567891011121314apiVersion: v1kind: Podmetadata: name: nginx-busyboxspec: containers: - name: nginx image: nginx ports: - containerPort: 80 - name: busybox image: busybox command: [&quot;/bin/sh&quot;] args: [&quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] 然后我们基于上面的nginx_busybox.yml文件创建pod 1kubectl create -f nginx_busybox.yml 显示 1pod &quot;nginx-busybox&quot; created 然后我们查看pod列表 1kubectl get pods 会显示pod列表 12NAME READY STATUS RESTARTS AGEnginx-busybox 2/2 Running 0 76s 我们通过describe查看一个pod的详细信息 1kubectl describe pod nginx-busybox 也可以 1kubectl get pods nginx-busybox -o wide 我们可以通过pod进入到容器内部 1kubectl exec nginx-busybox -it sh 会默认进入第一个容器中 12Defaulting container name to nginx.Use &#x27;kubectl describe pod/nginx-busybox -n default&#x27; to see all of the containers in this pod. 我们可以根据yml文件中指定的pod，删除该pod 1kubectl delete -f nginx_busybox.yml 如果我们想操作pod中某个容器，可以通过-C选项指定容器名字 1234kubectl exec nginx-busybox -c nginx datekubectl exec nginx-busybox -c busybox datekubectl exec nginx-busybox -c busybox hostnamekubectl exec nginx-busybox -c nginx hostname Namespace 隔离环境多个团队使用k8s需要通过namespace进行环境隔离查看机器上的namespace 1kubectl get namespaces 显示如下 123456NAME STATUS AGEdefault Active 5d21hkube-node-lease Active 5d21hkube-public Active 5d21hkube-system Active 5d21hkubernetes-dashboard Active 5d20h 查看kube-system命名空间下的pod 1kubectl get pods --namespace kube-system 我们创建一个demo的namespace 1kubectl create namespace demo 然后我们实现一个pod的yaml文件 1234567891011apiVersion: v1kind: Podmetadata: name: nginx namespace: demospec: containers: - name: nginx image: nginx ports: - containerPort: 80 我们指明了pod的namespace为demo，接下来创建这个pod 1kubectl create -f nginx_demo.yml 我们可以通过指定demo命名空间查看pod 1kubectl get pods --namespace demo 可以看到demo命名空间下存在我们刚创建的pod 12NAME READY STATUS RESTARTS AGEnginx 1/1 Running 0 14s 也可以列举出所有命名空间的pod 1kubectl get pod --all-namespaces 可以看到列举出了所有命名空间下的pod 1234NAMESPACE NAME READY STATUS RESTARTS demo nginx 1/1 Running 0 kube-system coredns-bccdc95cf-mp6hs 1/1 Running 0 kubernetes-dashboard kubernetes-dashboard-6bb65fcc49-dznpl 1/1 Running 0 context上下文获取所有contexts 1kubectl config get-contexts 显示context列表如下 12CURRENT NAME CLUSTER AUTHINFO NAMESPACE* kubernetes-admin@kubernetes kubernetes kubernetes-admin 我们可以设置一个context 1kubectl config set-context demo --user=kubernetes-admin --cluster=kubernetes --namespace=demo 创建后我们查看下 1kubectl config get-contexts 显示如下 123CURRENT NAME CLUSTER AUTHINFO NAMESPACE demo kubernetes kubernetes-admin demo* kubernetes-admin@kubernetes kubernetes kubernetes-admin user和cluster是怎么确定的呢？我们可以通过 1kubectl config view 可以看到user和cluster信息删除context之前，最好先切换到其他context 12kubectl config use-context kubernetes-admin@kuberneteskubectl config delete-context demo 删除namespace 1kubectl delete namespace demo deployment和controllercontroller位于master节点，负责任务调度和节点启动停止等控制。deployment是描述了一个期望的状态，而controller会根据实际状态和期望状态做对比，会改变实际状态满足期望状态。比如我们通过scheduler将pod放在第一个node上了，而第一个node宕机了。pod内的环境就会消失，任务也会终止。所以我们尽可能的使用deployment，deployment会根据实际情况调整任务分配到其他节点。而controller就是会尝试在其他节点重新创建pod。我们先实现一个nginx_deployment.yml文件 123456789101112131415161718192021apiVersion: apps/v1 kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: app: nginx replicas: 2 # tells deployment to run 2 pods matching the template template: # create pods using pod definition in this template metadata: # unlike pod-nginx.yaml, the name is not included in the meta data as a unique name is # generated from the deployment name labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 上述deployment文件定义了deployment名字为nginx-deployment，选择器选择匹配的pod的label为app:nginx，replicas：2告诉deployment启动2个pods，template定义了pod的内容，pod的标签为app:nginx，pod内部定义了容器的名字为nginx，容器的镜像选择nginx:1.7.9，暴露的端口号为80我们启动这个deployment 1kubectl create -f nginx_deployment.yml 查看deployment 1kubectl get deployment 我们可以根据label查看具体的pod 1kubectl get pods -l app=nginx 显示如下 123NAME READY STATUS RESTARTS AGEnginx-deployment-5754944d6c-br7nh 1/1 Running 0 19mnginx-deployment-5754944d6c-jfhxz 1/1 Running 0 19m 接下来我们校验下deployment如何通过controller控制pod数量的，比如我们删除其中的一个pod 1kubectl delete pod nginx-deployment-5754944d6c-br7nh 然后我们立即查看现在pod的信息 1kubectl get pods -l app=nginx 输出如下 1234NAME READY STATUS RESTARTS AGEnginx-deployment-5754944d6c-br7nh 0/1 Terminating 0 60snginx-deployment-5754944d6c-cb79g 1/1 Running 0 3snginx-deployment-5754944d6c-jfhxz 1/1 Running 0 23m 看到nginx-deployment-5754944d6c-br7nh的pod正在终止过了几秒我们再次查看 1kubectl get pods -l app=nginx 可以看到目前稳定运行的两个pod 123NAME READY STATUS RESTARTS AGEnginx-deployment-5754944d6c-cb79g 1/1 Running 0 2m29snginx-deployment-5754944d6c-jfhxz 1/1 Running 0 25m 我们可以更新deployment中容器的镜像版本，在更新前我们看下版本 1kubectl get deployment nginx-deployment -o wide 显示版本为nginx:1.7.9 12NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORnginx-deployment 2/2 2 2 28m nginx nginx:1.7.9 app=nginx 我们再实现一个deployment,他的nginx版本为nginx:1.8 12345678910111213141516171819apiVersion: apps/v1 kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: app: nginx replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.8 ports: - containerPort: 80 我们更新deployment，需要使用apply命令 1kubectl apply -f nginx_deployment_update.yml 更新后我们查看deployment 1kubectl get deployment nginx-deployment -o wide 显示版本变为nginx:1.8 12NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORnginx-deployment 2/2 1 2 35m nginx nginx:1.8 app=nginx 我们也可以扩充pod数量，我们在实现一个nginx_deployment_scale.yml文件 12345678910111213141516171819apiVersion: apps/v1 kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: app: nginx replicas: 4 # Update the replicas from 2 to 4 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.8 ports: - containerPort: 80 同样，我们执行更新命令 1kubectl apply -f nginx_deployment_scale.yml 查看deployment信息 1kubectl get deployment -o wide 显示版本 12NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORnginx-deployment 4/4 4 4 41m nginx nginx:1.8 app=nginx 获取pod信息 1kubectl get pod -l app=nginx -o wide 显示四个pod正在运行 12345NAME READY STATUS RESTARTS AGE IP NODE nginx-deployment-6f655f5d99-4ktlw 1/1 Running 0 8m53s 10.24.0.38 zackhost nginx-deployment-6f655f5d99-4mjqn 1/1 Running 0 3m39s 10.24.0.40 zackhost nginx-deployment-6f655f5d99-tcmb2 1/1 Running 0 9m19s 10.24.0.37 zackhost nginx-deployment-6f655f5d99-vvfrr 1/1 Running 0 3m39s 10.24.0.39 zackhost 除了可以采用上述yml文件apply方式更新deployment，还可以在线编辑deployment 1kubectl edit deployment nginx-deployment 会看到打开了一个vim，vim内容就是deployment的yml文件也可以通过这个vim修改deployment信息，比如我们将replicas设置为3，然后ESC, :wq保存退出。然后我们查看deployment信息 12NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORnginx-deployment 3/3 3 3 62m nginx nginx:1.8 app=nginx 也可以通过scale命令扩充pod数量 1kubectl scale --current-replicas=3 --replicas=4 deployment/nginx-deployment 更新image版本，也可以通过yml文件apply，也可以edit方式，也可以用如下命令 1kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1 ReplicaSet应用replicaset负责处理deployment的scale操作我们将之前生成的deployment全部删除，然后实现一个新的nginx_deployment.yml 123456789101112131415161718192021apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: app: nginx replicas: 2 # tells deployment to run 2 pods matching the template template: # create pods using pod definition in this template metadata: # unlike pod-nginx.yaml, the name is not included in the meta data as a unique name is # generated from the deployment name labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 生成deployment 1kubectl apply -f nginx_deployment.yml 查看生成得deployment 1kubectl get deployment -o wide 显示如下 12NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORnginx-deployment-test 4/4 4 4 3m2s nginx nginx:1.7.9 app=nginx 我们可以查看replicaset信息 1kubectl get replicaset 显示如下 12NAME DESIRED CURRENT READY AGEnginx-deployment-test-5754944d6c 4 4 4 5m46s 我们用scale命令将nginx的pod从四个变为六个 1kubectl scale --current-replicas=4 --replicas=6 deployment/nginx-deployment-test 接下来我们通过一下几个命令都能查看更新后的pod和deployment信息 12kubectl get pods -l app=nginxkubectl get deployment -o wide 我们可以通过describe获取deployment的描述信息 1kubectl describe deployment nginx-deployment-test 会输出scale信息 12345Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 16m deployment-controller Scaled up replica set nginx-deployment-test-5754944d6c to 4 Normal ScalingReplicaSet 6m45s deployment-controller Scaled up replica set nginx-deployment-test-5754944d6c to 6 如果我们更新容器镜像 1kubectl set image deployment/nginx-deployment-test nginx=nginx:1.9.1 这时我们查看描述信息 1kubectl describe deployment nginx-deployment-test 可以看到更新政策为25%用来更新，25%用来提供服务的模式,而且会开辟副本做更新，最后统一合并。 12345678910111213141516RollingUpdateStrategy: 25% max unavailable, 25% max surgeEvents: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 36m deployment-controller Scaled up replica set nginx-deployment-test-5754944d6c to 4 Normal ScalingReplicaSet 26m deployment-controller Scaled up replica set nginx-deployment-test-5754944d6c to 6 Normal ScalingReplicaSet 2m55s deployment-controller Scaled up replica set nginx-deployment-test-7448597cd5 to 2 Normal ScalingReplicaSet 2m55s deployment-controller Scaled down replica set nginx-deployment-test-5754944d6c to 5 Normal ScalingReplicaSet 2m55s deployment-controller Scaled up replica set nginx-deployment-test-7448597cd5 to 3 Normal ScalingReplicaSet 2m52s deployment-controller Scaled down replica set nginx-deployment-test-5754944d6c to 4 Normal ScalingReplicaSet 2m52s deployment-controller Scaled up replica set nginx-deployment-test-7448597cd5 to 4 Normal ScalingReplicaSet 2m52s deployment-controller Scaled down replica set nginx-deployment-test-5754944d6c to 3 Normal ScalingReplicaSet 2m52s deployment-controller Scaled up replica set nginx-deployment-test-7448597cd5 to 5 Normal ScalingReplicaSet 2m52s deployment-controller Scaled down replica set nginx-deployment-test-5754944d6c to 2 Normal ScalingReplicaSet 2m52s deployment-controller Scaled up replica set nginx-deployment-test-7448597cd5 to 6 Normal ScalingReplicaSet 2m48s (x2 over 2m50s) deployment-controller (combined from similar events): Scaled down replica set nginx-deployment-test-5754944d6c to 0 我们可以通过如下命令查看更新版本的历史信息 1kubectl rollout history deployment nginx-deployment-test 显示历史信息 1234deployment.extensions/nginx-deployment-test REVISION CHANGE-CAUSE1 &lt;none&gt;2 &lt;none&gt; 可以看到有两次版本信息,可以指明指定版本信息 1kubectl rollout history deployment nginx-deployment-test --revision 1 显示的是版本1的信息 123456789101112deployment.extensions/nginx-deployment-test with revision #1Pod Template: Labels: app=nginx pod-template-hash=5754944d6c Containers: nginx: Image: nginx:1.7.9 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt; 我们输入–revision 2可以看到版本2的信息 1kubectl rollout history deployment nginx-deployment-test --revision 2 版本2采用的镜像是1.9.1 123456789101112deployment.extensions/nginx-deployment-test with revision #2Pod Template: Labels: app=nginx pod-template-hash=7448597cd5 Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt; 我们可以回滚到指定版本 1kubectl rollout undo deployment nginx-deployment-test 我们查看下deployment的信息 1234kubectl get deployment nginx-deployment-test -o wide显示如下NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORnginx-deployment-test 6/6 6 6 52m nginx nginx:1.7.9 app=nginx 这时我们看下回滚历史 123456kubectl rollout history deployment nginx-deployment-test显示如下deployment.extensions/nginx-deployment-test REVISION CHANGE-CAUSE2 &lt;none&gt;3 &lt;none&gt; 默认只能保存两个版本。我们可以通过指定版本号回退到指定版本 12kubectl rollout undo deployment nginx-deployment-test --to-revision 2deployment.extensions/nginx-deployment-test rolled back 总结目前k8s的补充就到此为止，包括了kubectl命令，deployment的使用，pod，namespace，label等概念和操作。以后会不断完善。感谢关注公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"k8s service和网络","date":"2020-11-04T03:55:12.000Z","path":"2020/11/04/docker20/","text":"k8s的servicek8s创建service，然后外部可以访问service从而实现访问pod和容器。service 主要有三种类型，一种叫ClusterIP， 一种叫NodePort类型，一种叫外部的LoadBalancerClusterIP只能是cluster集群内部访问，NodePort可以支持外部访问。kubectl expose 可以导出一个service我们查看下pod信息 1kubectl get pods -o wide -n default 显示如下 123NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESbusybox 1/1 Running 0 14m 10.24.0.27 zackhost &lt;none&gt; &lt;none&gt;nginx 1/1 Running 0 109m 10.24.0.20 zackhost &lt;none&gt; &lt;none&gt; 然后我们导出busybox和nginx服务 1kubectl expose pods nginx 然后我们可以通过命令查看service 1kubectl get svc 会显示如下 123NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 25hnginx ClusterIP 10.99.158.252 &lt;none&gt; 80/TCP 4m56s 可以看到service的clusterIP我们在k8s任何一个节点都可以访问这个地址 1curl 10.99.158.252:80 会输出nginx的页面信息另外，当我们使用kubectl命令时可以设置自动补全功能 1source &lt;(kubectl completion bash) 设置后kubectl get 然后按下tab就可以自动补全了。 利用deployment启动python网站服务先实现该pod文件 1234567891011121314151617181920212223apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: service-testspec: replicas: 2 selector: matchLabels: app: service_test_pod template: metadata: labels: app: service_test_pod spec: containers: - name: simple-http image: python:2.7 imagePullPolicy: IfNotPresent command: [&quot;/bin/bash&quot;] args: [&quot;-c&quot;, &quot;echo \\&quot;&lt;p&gt;Hello from $(hostname)&lt;/p&gt;\\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;] ports: - name: http containerPort: 8080 用命令启动deployment 1kubectl create -f deployment_python_http.yml 将deployment导出为service 1kubectl expose deployment service-test 然后我们查看service信息 1kubectl get svc 显示结果 12NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice-test ClusterIP 10.108.183.252 &lt;none&gt; 8080/TCP 8s 我的k8s是单节点的，如果有其他节点，可以在任意节点执行curl命令指定地址和端口 1curl 10.108.183.252:8080 显示 1&lt;p&gt;Hello from service-test-85b6644b4d-6khz8&lt;/p&gt; deployment支持热更新 1kubectl edit deployment service-test 之后会显示deployment的yml信息，修改后保存，之后service-test就自动热更新了。无需重启服务。 NodePort 网络我们先实现一个nginx_pod.yml文件，定义Pod 12345678910111213apiVersion: v1kind: Podmetadata: name: nginx-pod labels: app: nginxspec: containers: - name: nginx-container image: nginx ports: - name: nginx-port containerPort: 80 定义了一个名字为nginx-pod的pod，labels的key为app，value为nginx。然后定义了容器的名字为nginx-container，镜像为nginx， 端口为80我们启动这个pod 1kubectl create -f nginx_pod.yml 然后查看pod 1kubectl get pods -o wide 接下来将pod导出service,选择类型NodePort 1kubectl expose pods nginx-pod --type=NodePort 查看service信息 1kubectl get svc 可以看到nginx-pod这个服务的类型为NodePort 123NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 2d2hnginx-pod NodePort 10.104.141.197 &lt;none&gt; 80:31427/TCP 4m27s 我们通过任意一个节点的ip加上端口号31427即可访问nginx-pod的服务。查看节点信息 1kubectl get node -o wide 可以看到节点信息 12NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIMEzackhost Ready master 2d3h v1.15.4 172.17.0.9 &lt;none&gt; Ubuntu 18.04.5 LTS 4.15.0-88-generic docker://19.3.6 172.17.0.9为内网IP，我通过外网ip和端口31427就可以访问。 通过yml文件创建svc我们先将之前创建的nginx的service删除 1kubectl delete svc 然后我们实现一个nginx的service的yml文件 12345678910111213apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: ports: - port: 32333 nodePort: 32334 targetPort: nginx-port protocol: TCP selector: app: nginx type: NodePort targetPort指定的端口名字为nginx-port， selector指定选择哪个pod，type指定service的类型nodePort和port分别是service的端口和映射的端口启动service 1kubectl create -f service_nginx.yml 启动服务后，可以通过节点地址和端口访问该nginx服务。 1kubectl get svc 显示服务启动成功 123NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 2d3hnginx-service NodePort 10.100.241.247 &lt;none&gt; 32333:32334/TCP 65s 接着访问指定网址和端口就能查看nginx服务了。 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"deployment介绍和使用","date":"2020-11-02T01:16:51.000Z","path":"2020/11/02/docker19/","text":"什么是deploymentdeployment是对pods和ReplicaSet的定义，定义了pods和ReplicaSet的定义和实现方式等。如下为deployment的定义 123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.12.2 ports: - containerPort: 80 metadata 指明了服务名为nginx-deployment, 标签为nginx,spec指定了pod的副本为3个，每个pod容器镜像为ngix:1.12.2, 容器端暴漏的端口为80接下来我们启动deployment 1kubectl create -f deployment_nginx.yml 会显示：”nginx-deployment deployment has been created”我们执行 1kubectl get deployment 查看deployment状态 12NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE nginx-deployment 3 3 3 3 9s 可以看到deployment启动了三个pod，并且三个pod都是可用的。 1kubectl get rs 可以看到ReplicaSet的状态为启动了3个pod，都是就绪状态接下来可以查看下pod 1kubectl get pods 显示deployment详细信息 1kubectl get deployment -o wide 我们也可以更新deployment的image 1kubectl set image deployment nginx-deployment nginx=nginx:1.1.13 我们可以回滚deployment版本 1kubectl rollout undo deployment nginx-deployment 查看deployment的历史信息 1kubectl rollout history deployment nginx-deployment 将deployment服务暴露出去 1kubectl expose deployment nginx-deployment --type=NodePort 终端会提示服务已经暴露出去 1service nginx-deployment exposed 我们接下来查看下service信息 1kubectl get svc 会显示服务映射的端口和地址 安装kubeadm基于ubuntu配置k8s环境 1hostnamectl set-hostname k8s-master 设置好后可以查看下我们的配置 1tail /etc/hosts 查看防火墙状态 1sudo apt-get install ufw 关闭临时分区 1swapoff -a 更新https 1apt-get update &amp;&amp; apt-get install -y apt-transport-https 获取gpg 1curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - 新增源 1add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot; 更新apt 1apt-get update 查看1.15最新版本 1apt-cache madison kubelet kubectl kubeadm |grep &#x27;1.15.4-00&#x27; //查看1.15的最新版本 安装指定版本的工具 1apt install -y kubelet=1.15.4-00 kubectl=1.15.4-00 kubeadm=1.15.4-00 //安装指定的版本 kubelet禁用swap 12345tee /etc/default/kubelet &lt;&lt;-&#x27;EOF&#x27;KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;EOFsystemctl daemon-reload &amp;&amp; systemctl restart kubelet 初始化k8s 12345kubeadm init \\ --kubernetes-version=v1.15.4 \\ --image-repository registry.aliyuncs.com/google_containers \\ --pod-network-cidr=10.24.0.0/16 \\ --ignore-preflight-errors=Swap 在当前账户下执行，kubectl配置调用 123mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config 使用fannel的overlay网络实现多节点pod通信 1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 查看pods信息 1kubectl get pods -A 配置dashboard 1kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml 配置后查看pod信息 1get pods -A 查看namespaces信息 1kubectl get namespaces 可以查看所有的namespaces信息设置好网络模式后，接下来查看下apiserver暴露的地址 1kubectl cluster-info 显示如下 12345Kubernetes master is running at https://172.17.0.9:6443Heapster is running at https://172.17.0.9:6443/api/v1/namespaces/kube-system/services/heapster/proxyKubeDNS is running at https://172.17.0.9:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxymonitoring-grafana is running at https://172.17.0.9:6443/api/v1/namespaces/kube-system/services/monitoring-grafana/proxymonitoring-influxdb is running at https://172.17.0.9:6443/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy 如果外网访问，换成外网地址就行了。我自己dashboard的访问地址: 1https://81.68.86.146:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 因为访问dashboard需要权限1.创建服务账号首先创建一个叫admin-user的服务账号，并放在kube-system名称空间下： 123456# admin-user.yamlapiVersion: v1kind: ServiceAccountmetadata: name: admin-user namespace: kube-system 执行kubectl create命令： 1kubectl create -f admin-user.yaml 2.绑定角色默认情况下，kubeadm创建集群时已经创建了admin角色，我们直接绑定即可： 12345678910111213# admin-user-role-binding.yamlapiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata: name: admin-userroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: admin-user namespace: kube-system 执行kubectl create命令： 1kubectl create -f admin-user-role-binding.yaml 3.获取Token现在我们需要找到新创建的用户的Token，以便用来登录dashboard： 12kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#x27;&#123;print $1&#125;&#x27;) 4 制作证书k8s默认启动了证书验证，我们创建证书 123456# 生成client-certificate-datagrep &#x27;client-certificate-data&#x27; ~/.kube/config | head -n 1 | awk &#x27;&#123;print $2&#125;&#x27; | base64 -d &gt;&gt; kubecfg.crt# 生成client-key-datagrep &#x27;client-key-data&#x27; ~/.kube/config | head -n 1 | awk &#x27;&#123;print $2&#125;&#x27; | base64 -d &gt;&gt; kubecfg.key# 生成p12openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name &quot;kubernetes-client&quot; 然后我们将kubecfg.p12 copy到windows双击安装证书即可。然后chrome 打开地址： 1https://81.68.86.146:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 单节点k8s,默认pod不被调度在master节点,需要设置去污点 1kubectl taint nodes --all node-role.kubernetes.io/master- //去污点，master节点可以被调度 输出如下 1node/k8s-master untainted 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"ReplicaSet和ReplicationController","date":"2020-10-27T06:48:40.000Z","path":"2020/10/27/docker18/","text":"前文提及kubectl根据pod yml启动pod，接下来我们删除pod 1kubectl delete -f pod_nginx.yml 查看运行pod 1kubectl get pods 编写yml，实例类型为ReplicationController 12345678910111213141516171819apiVersion: v1kind: ReplicationController metadata: name: nginxspec: replicas: 3 selector: app: nginx template: metadata: name: nginx labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 selector是选择器，告诉Service之间如何发现podteplate定义了pod格式metadata是pod的元信息spec指定pod内容，containers定义了容器接下来我们启动ReplicationController 1kubectl create -f rs_nginx.yml 因为我们定义了副本数量为3，所以启动三个pod 1kubectl get rc 查看replicationcontroller，可以看到启动了nginx的controller同时，我们查看下pods 1kubectl get pods 当我们删除其中一个pod时，controller会重新启动一个pod，保证副本数为三个 1kubectl delete pods nginx-6r92b 再次查看kubectl get pods 查看pod列表，发现pod数量仍为三个我们也可以扩充副本数量 1kubectl scale rc nginx --replicas=2 同样我们可以通过replicaset 设置启动pod 12345678910111213141516171819202122apiVersion: apps/v1kind: ReplicaSetmetadata: name: nginx labels: tier: frontendspec: replicas: 3 selector: matchLabels: tier: frontend template: metadata: name: nginx labels: tier: frontend spec: containers: - name: nginx image: nginx ports: - containerPort: 80 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"k8s最小调度单位pod","date":"2020-10-26T12:46:13.000Z","path":"2020/10/26/docker17/","text":"pod是k8s调度最小单位，一个pod可以包含多个容器，各容器之间共享同一个网络。可以通过yml文件创建一个pod 123456789101112apiVersion: v1kind: Podmetadata: name: nginx labels: app: nginxspec: containers: - name: nginx image: nginx ports: - containerPort: 80 yml文件中各个属性kind: 指定创建资源的角色/类型metadata: 资源的元数据/属性metadata下name和labels分别为name: web04-pod #资源的名字，在同一个namespace中必须唯一labels: #设定资源的标签spec: 指定该资源的内容 123456789spec:#specification of the resource content 指定该资源的内容 restartPolicy: Always #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器 nodeSelector: #节点选择，先给主机打标签kubectl label nodes kube-node1 zone=node1 zone: node1 containers: #容器 - name: nginx #容器名字 image: nginx #镜像名字 ports: - containerPort: 80 #容器对外开放的端口 启动pod通过Kubectl version可以查看看k8s版本根据pod的yml文件启动一个pod 1kubectl create -f pod_nginx.yml 根据当前的pod_yaml文件创建一个pod，会显示pod “nginx” created我们通过 1kubectl get pods 可以看到nginx 的pod已经运行也可以通过 1kubectl get pods -o wide 查看详细信息 12NAME READY STATUS RESTARTS AGE IP NODEnginx 1/1 RUNNING 0 1m 172.17.0.4 minikube 可以看到容器 运行在minikube这个节点上， 容器的ip为172.17.0.4我们通过minikube ssh 进入virtualbox里， 这样通过docker ps可以查看虚拟机中运行的容器我们通过docker network list 查看 虚拟机内部的所有网络docker network inspect bridge 查看bridge网络可以看到bridge网络里有容器为nginx的容器网络地址为172.17.0.4，正好就是我们通过kubectl get pods -o wide获取的除此之外，我们可以通过 1kubectl exec -it nginx sh 这种方式直接进入nginx pod 里的容器里了。如果pod中有多个容器，可以选择进入某个容器我们可以先查看nginx pod中的容器 1kubectl describe pods nginx 接下来我们可以通过-c 选项进入指定容器 1kubectl exec -c 容器id 我们启动pod后，容器运行在pod中，外界无法访问，需要将pod的端口暴漏出去 1kubectl port-forward nginx 8080:80 这样就将nginx容器内部的80端口映射为本机的8080端口，可以通过127.0.0.1：8080访问nginx服务了。 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"k8s基本概念和单节点服务搭建","date":"2020-10-20T03:11:51.000Z","path":"2020/10/20/docker16/","text":"K8s基本概念Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。k8s有两种节点，master节点和node节点master节点：是集群的大脑，master节点包括，Api Server，Scheduler，Controller 。Api Server组件，该组件主要是为了响应UI或者CLI的请求Scheduler组件： 用来调度容器运行和停止，以及运行在哪些节点上Contoller组件：维持服务可扩展，保证稳定运行数量Etcd组件：主要是分布式存储k8s的服务状态等。Node节点：包括Pod，Docker，kubelet，kube-proxy，fluentd Pod ：运行在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Docker： 容器技术kubelet：负责在创建容器，分配volume和network等kube-proxy：主要负责网络端口的代理和转发fluentd：负责日志的采集和存储。 minikube 搭建单节点集群安装minikube前提需要安装kubectl和VM1 安装kubectl 1curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl 然后提取权限 1chmod +x ./kubectl 将二进制文件添加至路径中 1cp kubectl /usr/local/bin 此时执行kubectl可以看到帮助信息2 安装virtual-box先升级apt 1sudo apt update &amp;&amp; sudo apt upgrade 然后安装依赖包 1sudo apt install gdebi build-essential 去virtual-box下载源码 1wget http://download.virtualbox.org/virtualbox/5.2.8/virtualbox-5.2_5.2.8-121009~Ubuntu~xenial_amd64.deb 安装virtual box 1gdebi virtualbox-5.2_5.2.8-121009~Ubuntu~xenial_amd64.deb 继续安装其他依赖包 1apt-get install libqt5x11extras5 libsdl1.2debian 3 关闭swap交换分区关闭swap 1swapoff -a 然后打开swap配置 1vi /etc/fstab 注释掉swap分区的那一行4 安装minikube从阿里云地址下载 1curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.26.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ 接下来我们查看下minikube 版本，显示版本证明安装成功 1minikube version 创建minikube集群 1minikube start 可以看到日志后minikube启动成功了5 kubectl命令 kubectl view config 查看配置信息kubectl config get-contexts 查看context信息假如我们有两个集群，可以使用两个context，利用不同的context链接不同集群kubectl cluster-info 查看集群信息 minikube ssh 进入虚拟主机环境，之后可以执行docker命令 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"Docker Secret加密","date":"2020-10-19T02:34:47.000Z","path":"2020/10/19/docker15/","text":"Docker Secret在我们启动docker或者service需要指定密码，这种密码我们有时不想被别人知道，所以可以采用docker secret方式管理。创建secret可以有两种方式，一种通过文件创建，一种通过命令行创建我们在本地创建一个文件passwd 1zack1024 接下我们可以通过如下命令创建secret 1docker secret create my-pw passwd 运行后可以看到屏幕输出如下 1qq463dkw4da9s05rwinntmo09 这是一段加密后的数字，接下来我们查看下所有secret 1docker secret list 可以看到secret列表 12ID NAME DRIVER CREATED UPDATEDqq463dkw4da9s05rwinntmo09 my-pw About a minute ago About a minute ago 为了保护隐私，我们可以将passwd这个文件删除。当然也可以通过命令行方式传入，从而创建secret 1echo &quot;zack1024&quot; | docker secret create mysql-root-pw - 接下来我们利用secret创建一些service 1docker service create --name se-busybox --secret my-pw busybox sh -c &quot;while true; do sleep 3600; done&quot; 接下来我们查看下跑起来的service 列表 1docker service list 可以看到服务列表，docker service ps se-busy的box 查看具体服务，可以看到这个服务运行的节点书和状态 12ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS6xgkpk55tno7 se-busybox.1 busybox:latest VM-0-9-ubuntu Running Running 19 seconds ago 接下来我们在VM-0-9-ubuntu这台机器上执行docker ps 找到se-busybox服务运行的容器 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES23d0dce1b7cf busybox:latest &quot;sh -c &#x27;while true; …&quot; 9 minutes ago Up 9 minutes se-busybox.1.6xgkpk55tno7fi6uiim4am00n 我们进入这个容器，docker exec -it 23d0dce1b7cf sh在容器里，接下来我们进入这个目录 cd /run/secrets/ 1234/run/secrets # lsmy-pw/run/secrets # cat my-pwzack1024 通过cat my-pw可以看到我们最初设定的密码。接下来我们利用secret构建mysql服务 1docker service create --name se-db --secret my-pw -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-pw mysql 启动mysql后进入容器内部也可以看到/run/secrets/目录下有my-pw文件，其内部记录的就是我们设置的密码。我们在容器内部执行 1mysql -u root -p 录入之前设置的密码, 可以看到连接成功。 通过docker-compose使用secrete可以通过secrets字段指定要使用的密钥，这个密钥必须提前通过docker secret create创建也可以通过secrets字段单独指定密钥名称，在其子域下指定file关键字,就是密码保存的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354version: &#x27;3.6&#x27;services: web: image: wordpress ports: - 8080:80 secrets: - my-pw environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD_FILE: /run/secrets/my-pw networks: - my-network depends_on: - mysql deploy: mode: replicated replicas: 3 restart_policy: condition: on-failure delay: 5s max_attempts: 3 update_config: parallelism: 1 delay: 10s mysql: image: mysql secrets: - my-pw environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my-pw MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-network deploy: mode: global placement: constraints: - node.role == managervolumes: mysql-data:networks: my-network: driver: overlaysecrets: my-pw: file: ./password 然后我们通过docker stack 启动服务 1docker stack deploy wordpress -c=docker-compose.yml 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"DockerStack 实战","date":"2020-10-16T07:54:04.000Z","path":"2020/10/16/docker14/","text":"Docker Stack简介docker stack是基于cluster集群模式，发布服务的一个功能。docker stack 有如下几个命令docker stack deploy 发布或者更新一个stackdocker stack list 获取所有stackdocker stack ps 列出stack中运行的taskdocker stack services 列出stack中的服务docker stack rm 移除stack wordpress实战基于docker stack 实现之前的wordpress功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647version: &#x27;3&#x27;services: web: image: wordpress ports: - 8080:80 environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD: root networks: - my-network depends_on: - mysql deploy: mode: replicated replicas: 3 restart_policy: condition: on-failure delay: 5s max_attempts: 3 update_config: parallelism: 1 delay: 10s mysql: image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-network deploy: mode: global placement: constraints: - node.role == managervolumes: mysql-data:networks: my-network: driver: overlay 简单解释下docker-compose的各个参数services : 要运行的服务，这里填写了两个服务，web服务和mysql服务web服务的构建方式为镜像构建，端口为80端口映射为8080端口environment : 表示环境变量，通过environment传递给容器networks : 两个服务都通过my-network 网络通信deploy : 这里定义了发布规则,mode 为replicated表示这个服务可以复制很多个实例模式为global表示之启动一个实例，不允许复制replicas : 表示副本数量restart_policy : 重启策略，condition为失败时，重启delay : 多个实例重启延迟为5smax_attempts : 表示最大尝试次数为3update_config ： 表示更新配置，parallelism表示并行更新数量placement ：设置服务运行的位置，constraints表示约束，node.role == manager只允许该服务运行在manager节点volumes ：表示挂载的卷networks: 设置网络driver为overlay，这样可以允许多主机互通 通过docker stack发布服务执行如下命令 1docker stack deploy wordpress --compose-file docker-compose.yml 可以看到创建了如下服务 123Creating network wordpress_my-networkCreating service wordpress_webCreating service wordpress_mysql 接下来我们看看运行了哪些stack 1docker stack list 会展示cluster运行的stack 12NAME SERVICES ORCHESTRATORwordpress 2 Swarm 可以看到名字为wordpress的stack正在运行，其上运行了两个服务查看wordpress上具体的服务 1docker stack services wordpress 可以看到服务 123ID NAME MODE REPLICAS IMAGE PORTS2soubn9aey1y wordpress_mysql global 1/1 mysql:5.7 p3h9g6tigocx wordpress_web replicated 3/3 wordpress:latest *:8080-&gt;80/tcp 有两个服务，分别是wordpress_mysql和wordpress_web。在web和mysql之前增加了wordpress这个stack的名字接下来列出wordpress中运行的task 1docker stack ps wordpress 可以看到stack上跑了三个服务 12345ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSgvtnr0dy5sjs wordpress_mysql.axapk9ke3o47r3er3jeqilpgg mysql:5.7 VM-0-9-ubuntu Running Running 24 minutes ago q15ncnt0cx73 wordpress_web.1 wordpress:latest instance-6nsdfhv9 Running Running 24 minutes ago z3ivbcopqguv wordpress_web.2 wordpress:latest VM-0-9-ubuntu Running Running 24 minutes ago zmlyu8lnw78x wordpress_web.3 wordpress:latest instance-6nsdfhv9 Running Running 24 minutes ago 如果要更新服务，可以通过修改docker-compose修改配置，然后重新deploy指定修改后的docker-compose即可。 最后可以通过docker stack rm 删除stack 1docker stack rm wordpress 可以看到服务被移除 123Removing service wordpress_mysqlRemoving service wordpress_webRemoving network wordpress_my-network 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker-compose实战","date":"2020-10-09T03:13:33.000Z","path":"2020/10/09/docker12/","text":"搭建wordpress容器先用mysql5.6镜像启动一个名字为mysql-wordpress的容器，接着基于这个容器我们启动一个wordpress容器 12docker run -d --name mysql-wordpress -v /home/zack/dockerwork/mysql-workpress:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=wordpress mysql:5.6docker run -d -e WORDPRESS_DB_HOST=mysql-wordpress:3306 -e WORDPRESS_DB_USESR=root -e WORDPRESS_DB_PASSWORD=root --link mysql-wordpress -p 7080:80 wordpress 之后访问服务器外网地址和7080端口就可以看到wordpress设置界面了docker为了简化构建多个容器的操作，提出了docker-compose的功能。 docker-compose的yaml文件我们将要启动的容器，挂在的目录，使用的网络等信息都写入名字为docker-compose.yaml文件里，之后通过docker-compose up启动多个容器。docker-compose其实是个批处理工具，接下来我们先介绍yaml的几个字段名字services：一个service代表一个container，可以通过dockerhub拉取镜像启动，也可以通过Dockerfile构建镜像启动volumes: 挂载的卷，docker会根据该字段创建对应的卷networks：网络命名空间，docker会根据该字段创建对应的网络接下来将wordpress容器启动的命令，我们通过docker-compose进行改造 12345678910111213141516171819202122232425262728293031version: &#x27;3&#x27;services: wordpress-cp: image: wordpress ports: - 8080:80 depends_on: - mysql-cp environment: WORDPRESS_DB_HOST: mysql-cp WORDPRESS_DB_USESR: root WORDPRESS_DB_PASSWORD: root networks: - my-bridge mysql-cp: image: mysql:5.6 environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-bridgevolumes: mysql-data:networks: my-bridge: driver: bridge depends_on表示依赖哪个镜像，可以起到控制镜像构建顺序的目的 写好wordpress的docker-compose后，我们接下来介绍docker-compose的命令和安装，通过docker-compose启动容器 docker-compose安装和命令通过curl命令安装docker-compose 1sudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 下载完成后修改权限 1sudo chmod +x /usr/local/bin/docker-compose 执行如下命令查看docker版本 1docker-compose --version 如果显示版本信息，证明安装成功了。接下来介绍几个常用的命令docker-compose up 命令可以找到当前目录下docker-compose.yml填写的service。当然也可以指定具体的compose文件 1docker-compose -f docker-compose.yml up 可以看到容器启动，但是此时ctrl c退出后，容器也将停止，所以可以采用后台启动的方式 1docker-compose -f docker-compose.yml up -d 此时执行docker ps可以看到容器启动了我的容器部署在云服务上，输入服务器地址和端口，可以看到wordpress的安装程序docker-compose stop 可以停止正在运行的容器docker-compose down 停止并删除容器docker-compose ps 显示通过docker-compose启动的容器docker-compose images 显示docker-compose容器和镜像信息docker-compose exec 后边接上yml中定义的service以及响应的命令，就可以实现进入容器等操作docker-compose network ls 查看docker-compose的网络 1docker-compose exec mysql-cp bash 上述命令进入mysql-cp容器中 compose启动flask实现一个Dockerfile，构造flask容器 1234567FROM python:2.7LABEL maintaner=&quot;ggroup@gmail.com&quot;COPY . /appWORKDIR /appRUN pip install flask redisEXPOSE 5000CMD [ &quot;python&quot;, &quot;app.py&quot; ] Dockerfile 中引用了python2.7的镜像，然后安装flask和redis库，导出5000端口，接着执行python文件app.py内部实现了一个简单的flask程序 12345678910111213141516from flask import Flaskfrom redis import Redisimport osimport socketapp = Flask(__name__)redis = Redis(host=os.environ.get(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), port=6379)@app.route(&#x27;/&#x27;)def hello(): redis.incr(&#x27;hits&#x27;) return &#x27;Hello Container World! I have been seen %s times and my hostname is %s.\\n&#x27; % (redis.get(&#x27;hits&#x27;),socket.gethostname())if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 接下来实现docker-compose.yml 12345678910111213141516version: &quot;3&quot;services: redis: image: redis web: build: context: . dockerfile: Dockerfile ports: - 8080:5000 environment: REDIS_HOST: redis 因为一个docker-compose.yml中定义的多个service是默认共享同一个网络的，所以app.py可以通过本地地址访问6379端口的redis服务。然后compose将5000端口映射为8080端口，并且导入了环境变量REDIS_HOST为redis我们通过docker-compose up -d 启动，然后docker ps 看到服务成功，接着在浏览器输入地址和8080端口就可以实现统计访问次数的功能了。 docker-compose水平扩展docker-compose提供了水平扩展伸缩的功能。修改docker-compose.yml文件，将web的端口映射注释掉，否则水平扩展会出现端口冲突。修改docker-compose.yml 12345678910111213141516171819202122version: &quot;3&quot;services: redis: image: redis web: build: context: . dockerfile: Dockerfile environment: REDIS_HOST: redis lb: image: dockercloud/haproxy links: - web ports: - 1080:80 volumes: - /var/run/docker.sock:/var/run/docker.sock 我们添加了haproxy负载均衡，将访问1080端口的请求映射给80端口。然后我们将web服务的端口注释掉，防止启动多个web服务导致端口被抢占。 1234567FROM python:2.7LABEL maintaner=&quot;ggcloud.gmail.com&quot;COPY . /appWORKDIR /appRUN pip install flask redisEXPOSE 80CMD [ &quot;python&quot;, &quot;app.py&quot; ] Dockerfile中修改了暴露的端口为80，这样负载均衡可以通过links指定web服务，从而访问该服务80端口接下来我们修改app.py程序 1234567891011121314151617from flask import Flaskfrom redis import Redisimport osimport socketapp = Flask(__name__)redis = Redis(host=os.environ.get(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), port=6379)@app.route(&#x27;/&#x27;)def hello(): redis.incr(&#x27;hits&#x27;) return &#x27;Hello Container World! I have been seen %s times and my hostname is %s.\\n&#x27; % (redis.get(&#x27;hits&#x27;),socket.gethostname())if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=80, debug=True) 将python程序修改为绑定80端口，接下来启动docker-compose up -d容器启动后可以通过 curl 127.0.0.1:1080 方式访问测试服务输出如下 1Hello Container World! I have been seen 1 times and my hostname is d14da1c8d66a. 我们通过docker-compose up –scale web=3 -d可以看出之前启动的web服务没有变化，又新启动了两个web服务，扩充为三个web服务了可以扩充，当然也可以缩减，将docker-compose up –scale web=1 -d 执行后，就缩减为1个web服务了我们将web服务扩充为5个，然后用curl脚本访问，循环访问 1for i in `seq 10`; do curl 127.0.0.1:1080; done 后台通过负载均衡将请求派发给不同的web服务 12345678910Hello Container World! I have been seen 2 times and my hostname is d14da1c8d66a.Hello Container World! I have been seen 3 times and my hostname is 0e3b0e1588b4.Hello Container World! I have been seen 4 times and my hostname is 3ed4382b162b.Hello Container World! I have been seen 5 times and my hostname is 77c3a5cff8d2.Hello Container World! I have been seen 6 times and my hostname is c65d07e6ab79.Hello Container World! I have been seen 7 times and my hostname is d14da1c8d66a.Hello Container World! I have been seen 8 times and my hostname is 0e3b0e1588b4.Hello Container World! I have been seen 9 times and my hostname is 3ed4382b162b.Hello Container World! I have been seen 10 times and my hostname is 77c3a5cff8d2.Hello Container World! I have been seen 11 times and my hostname is c65d07e6ab79. 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker-swarm实战","date":"2020-10-09T03:13:33.000Z","path":"2020/10/09/docker13/","text":"docker-swarm 简介docker-swarm是一个集群管理工具，主要有以下几个组件1 Swarm 主要负责集群的管理和编排工作2 Node节点，分为manager节点和worker节点3 Service是任务的定义，管理机或工作节点上执行4 Task是Service的实例，是容器运行的一组命令 docker-swarm搭建准备两台机器，在一台机器上执行swarm初始化 1docker swarm init --advertise-addr 81.68.86.146 会显示加入的token和地址端口 1docker swarm join --token SWMTKN-1-2ifek5rwyq0k1d4rhhcyxjrmijlbuxm27rfcvqtkoxdgqdgn4j-0epqxkqlixe1r8uvr47g69iox 81.68.86.146:2377 在另一台机器上执行上述加入操作,之后执行查看命令，可以看到集群节点状态 1docker node list 显示一下 123ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONaxapk9ke3o47r3er3jeqilpgg * VM-0-9-ubuntu Ready Active Leader 19.03.67ynq5qr8s8tn3j5vkr5ke19k0 instance-6nsdfhv9 Ready Active 19.03.12 docker-swarm service我们可以创建service服务，然后指定具体的副本数，docker会根据副本数将service生成指定数量的容器执行task，这些容器负载均衡分配到不同的节点上。我们先创建一个名为demo的service 1docker service create --name demo busybox sh -c &quot;while true; do sleep 3600; done&quot; 上述命令创建了一个名为demo的service, 我们可以通过docker service list 查看服务列表 1docker service list 可以看到服务列表， 存在名字为demo的服务 12ID NAME MODE REPLICAS IMAGE xr5psjjt0nvx demo replicated 1/1 busybox:latest 我们也可以通过docker ps 查看启动的容器通过如下命令可以查看service的详细信息 1docker service ps demo 可以看到服务运行在哪个节点上接下来我们扩充下服务的数量 1docker service scale demo=5 然后我们查看demo服务 1docker service ps demo 会看到如下效果,启动了五个任务分别跑在不同的节点上 123456ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSj78ygjp9r42k demo.1 busybox:latest VM-0-9-ubuntu Running Running 47 minutes ago 9w7xifrhztki demo.2 busybox:latest instance-6nsdfhv9 Running Running 19 seconds ago s15r73i10m43 demo.3 busybox:latest instance-6nsdfhv9 Running Running 19 seconds ago 3ep3sjw50fro demo.4 busybox:latest instance-6nsdfhv9 Running Running 19 seconds ago x80vmybr1dak demo.5 busybox:latest VM-0-9-ubuntu Running Running 22 seconds ago 通过 1docker service list 看到启动了五个容器，如果关闭其中一个，swarm会自动帮我们启动一个新的，保持数量为5个通过 1docker service rm demo 删除demo服务，这样所有运行的容器都会被删除，执行docker service ps demo会看到demo服务被删除了。执行docker ps 看到容器也被删掉了 service搭建wordpress利用service搭建wordpress，首先要创建一个共用网络，常见两个service，分别是mysql和wordpress 1docker network create -d overlay sw-net 创建一个overlay类型的网络sw-net，这个网络可以保证多个宿主机之间通信之后查看网络列表 1docker network list 可以看到我们新创建的网络。接下我们用service启动mysql服务 1docker service create --name mysql --env MYSQL_ROOT_PASSWORD=root --env MYSQL_DATABASE=wordpress --network sw-net --mount type=volume,source=mysql-data,destination=/var/lib/mysql mysql:5.6 注意–mount后的key和value对之间用逗号隔开，不能有空格命令运行后等待服务启动成功，根据docker service ps mysql 可以看到这个服务具体运行在哪个节点。接下来创建wordpress的service，和之前启动wordpress的容器类似 12docker service create --name wordpress -p 7080:80 --env WORDPRESS_DB_USESR=root --env WORDPRESS_DB_PASSWORD=root \\--env WORDPRESS_DB_HOST=mysql:3306 --network sw-net wordpress 服务更新先将服务扩充为多个，这样保证服务稳定性 1docker service scale wordpress=5 然后执行update 1docker service update --image wordpress:2.0 wordpress 可以看到wordpress会在后台更新 如果要更新端口则执行如下命令即可 1docker service update --publish-rm 8080:5000 --publish-add 8088:5000 wordpress 上述命令将8080端口移除，换为8088端口 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker网络(二)","date":"2020-09-15T07:28:09.000Z","path":"2020/09/15/docker11/","text":"docker网络是如何和宿主机相通的先用docker命令查看下我们的docker网络 1docker network list 可以看到网络列表 12345NETWORK ID NAME DRIVER SCOPEbd45b573efca bridge bridge localdffe767ef55b com-sig bridge localb58d4f1da54c host host local77d57a8a8f61 none null local 然后我们查看指定网络信息 1docker inspect network bd45b573efca 可以看到test1容器的网络信息 123456789&quot;Containers&quot;: &#123; &quot;07f5643a681c19fb9d8907c62631478123e8e1bb520d7c579a8c231500147bbd&quot;: &#123; &quot;Name&quot;: &quot;test1&quot;, &quot;EndpointID&quot;: &quot;e28c35eb738ed69124d26ab141e220a18016eaf11a6c703b932e012c8b09b20e&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:04&quot;, &quot;IPv4Address&quot;: &quot;172.18.0.4/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;,&#125; test1这个容器连接的是docker0这个桥。我们可以通过ip a查看网桥和接口可以看到docker0信息 123456docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:54:68:91:f7 brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:54ff:fe68:91f7/64 scope link valid_lft forever preferred_lft forever 也可以看到veth的接口信息，test容器的网络其实是通过vetch的接口连接到docker0上的 1sudo docker exec test1 ip a 可以看到test容器的veth接口，该接口连接的就是docker0网桥接下来我们安装个工具 12sudo apt-get install bridge-utilsbrctl show 这样看到docker0连接的接口veth077a502,而该接口就是和容器连接的接口 12bridge name bridge id STP enabled interfacesdocker0 8000. 0242546891f7 no veth077a502 这样，容器和宿主机就连接了。 多个容器如何实现网络互联每个容器通过自己的veth连接docker0网桥，从而达到网络互联的目的而bridge0可以通过nat映射访问外网 多个容器之间互联可以通过link进行连接，但是link是单向的，比如 1docker run -d --name test2 --link test1 busybox /bin/sh -c &quot;while true; do sleep 3000; done&quot; test2是单方向连接test1，也就是从test2中可以访问test1，而test1是无法访问test2的可以通过构建network实现两个容器互相访问 1docker network create -d bridge com-sig 输入 1docker network ls 可以看到docker网络 12NETWORK ID NAME DRIVER SCOPEbd45b573efca bridge bridge local 启动新的容器指定network为com-sig 1docker run -d --name test2 --network com-sig busybox /bin/sh -c &quot;while true; do sleep 3000; done&quot; 对于已经存在的容器，可以通过connect命令将两个容器连接到一个网络 1docker network connect com-sig test1 上述命令将test1连接到com-sig网络里，这样test1和test2就可以通信了。 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker网络(一)","date":"2020-09-10T02:53:48.000Z","path":"2020/09/10/docker10/","text":"构建两个busybox容器构建两个busybox容器 12docker run -d --name test1 busybox /bin/sh -c &quot;while true; do sleep 3000; done&quot;docker run -d --name test2 busybox /bin/sh -c &quot;while true; do sleep 3000; done&quot; 然后我们分别执行ip a命令，看看各个容器的网络地址 1docker exec -it test1 ip a 可以看到test1的网络地址 123456781: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever806: eth0@if807: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:12:00:05 brd ff:ff:ff:ff:ff:ff inet 172.18.0.5/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever 看看test2 1docker exec -it test2 ip a 可以看到test2的网络地址 123456781: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever808: eth0@if809: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:12:00:06 brd ff:ff:ff:ff:ff:ff inet 172.18.0.6/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever 我们通过test1 ping test2 1docker exec -it test2 ping 172.18.0.5 可以看到ping成功了 12364 bytes from 172.18.0.5: seq=0 ttl=64 time=0.092 ms64 bytes from 172.18.0.5: seq=1 ttl=64 time=0.074 ms64 bytes from 172.18.0.5: seq=2 ttl=64 time=0.073 ms linux 构建network namespace联通本节在linux系统设置两个namespace连接，两个network namespace就好比是docker这样方便我们了解网络连接的原理查看本机net namespace 1ip netns list 添加network namespace 12sudo ip netns add network1sudo ip netns add network2 查看network1 ip link 信息 1sudo ip netns exec network1 ip link 可以看到network1的link信息 121: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 设置network1的link信息 1sudo ip netns exec network1 ip link set dev lo up 可以看到lo信息不再时DOWN，而是UNKNOWN模式了 121: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 用同样的方法把network2的命名空间的模式也打开 1sudo ip netns exec network1 ip link set dev lo up 通过veth技术将两个network连接起来 1sudo ip link add veth-network1 type veth peer name veth-network2 此时执行 1sudo ip link 可以看到link信息新增了两个veth，接下来将veth-network1接口添加到network1里将veth-network2接口添加到network2里 12sudo ip link set veth-network1 netns network1sudo ip link set veth-network2 netns network2 接下来我们查看network1的link信息 1sudo ip netns exec network1 ip link 可以看到network1的ip link信息 12341: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00811: veth-network1@if810: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether ca:dd:69:8a:59:18 brd ff:ff:ff:ff:ff:ff link-netnsid 1 接下来为两个namespace设置地址 12sudo ip netns exec network1 ip addr add 192.168.1.1/24 dev veth-network1sudo ip netns exec network2 ip addr add 192.168.1.2/24 dev veth-network2 然后将两个namespace的veth设置启动 12sudo ip netns exec network1 ip link set dev veth-network1 upsudo ip netns exec network2 ip link set dev veth-network2 up 这时候再查看ip信息 1sudo ip netns exec network1 ip link 可以看到network1的veth端口up 12341: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00811: veth-network1@if810: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether ca:dd:69:8a:59:18 brd ff:ff:ff:ff:ff:ff link-netnsid 然后查看两个网络的ip信息 1sudo ip netns exec network1 ip a 可以看到network1的ip信息 123456811: veth-network1@if810: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether ca:dd:69:8a:59:18 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet 192.168.1.1/24 scope global veth-network1 valid_lft forever preferred_lft forever inet6 fe80::c8dd:69ff:fe8a:5918/64 scope link valid_lft forever preferred_lft forever 然后通过network2去ping包给network1 1sudo ip netns exec network2 ping 192.168.1.1 可以看到这两个网络现在互通了。 12364 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.036 ms64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.024 ms64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.046 ms 以上就是linux环境下通过network的namespace方式达到网络互联的。 个人公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"Dockerfile实战例子","date":"2020-09-09T01:25:15.000Z","path":"2020/09/09/docker09/","text":"构建flask镜像先实现一个flask的python程序app.py 12345678from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;Hello World&#x27;if __name__ == &#x27;__main__&#x27;: app.debug = True # 设置调试模式，生产模式的时候要关掉debug app.run(host=&#x27;0.0.0.0&#x27;,port=5000) 接下来实现一个Dockerfile，构造python镜像 123456FROM python:3.6RUN pip install flaskWORKDIR /appCOPY app.py /app/EXPOSE 5000CMD [&quot;python&quot;, &quot;app.py&quot;] 创建镜像 1docker build -t secondtonone1/python-flask . 启动容器 1docker run -d --name py-flask -p 5001:5000 550aa063e1bc 这时候通过网页输入 服务器ip:5001即可看到输出hello world 容器配置stressDockerfile配置stress 1234FROM ubuntu:18.04RUN apt-get update &amp;&amp; apt-get install -y stressENTRYPOINT [&quot;usr/bin/stress&quot;]CMD [&quot;--vm 1 --vm-bytes 128M --verbose&quot;] 接下来生成镜像 1docker build -t secondtonone1/stress . 启动容器 1docker run -it --rm secondtonone1/stress 可以看到默认是使用ENTRYPOINT里的命令，弹出了help提示我们重新启动一个新的容器，后边带着参数，这样可以覆盖Dockerfile的CMD 1docker run -it --rm secondtonone1/stress --vm 1 --vm-bytes 128M --verbose 个人公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"images的发布和私有仓库","date":"2020-09-07T10:50:10.000Z","path":"2020/09/07/docker08/","text":"images发布到docker hub首先登录https://hub.docker.com注册自己的账号，然后创建仓库接着将我们之前的一个镜像打tag，tag的形式为id/镜像名:版本, id就是dockerhub的id。 1234567#登录docker login#给镜像打标签docker tag status secondtonone1/status#查看打标签后的镜像docker imagesdocker push secondtonone1/status 之后登录docker hub网址就能看到我们的仓库了如果将本地的镜像删除，再次pull，就可以从docker-hub中拉取刚才提交的镜像 1234#删除本地镜像rmi secondtonone1/status#拉取远程镜像docker pull secondtonone1/status 搭建私有仓库可以拉取registry镜像搭建私有仓库 1docker pull registry:2 然后启动镜像 1docker run -d -v /home/zack/dockerwork/registry -p 5000:5000 --restart always --name myregistry registry:2 可以从其他机器telnet这个台机器的5000端口，保证端口畅通生成一个新的镜像，镜像名字要用这台机器的 地址:端口/镜像名 1docker build -t 81.68.86.146:5000/comsig . 此时可以尝试提交镜像，由于镜像仓库未配置权限信息，所以会提交失败。此时进入/etc/docker下，修改daemon.json文件 1234&#123; &quot;registry-mirrors&quot;: [&quot;https://hya0o79u.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;81.68.86.146:5000&quot;]&#125; registry-mirrors是阿里云加速地址，insecure-registries是我们配置的私有仓库的地址。接着修改dockerservice配置, sudo vim /lib/systemd/system/docker.service添加 1EnvironmentFile=-/etc/docker/aemon.json 接下来 push我们的镜像到私有仓库 1docker push 81.68.86.146:5000/comsig 可以去docker官网https://docs.docker.com/registry/spec/api/#catalog查看相应的registry的api, 进而获取私有仓库信息。在浏览器输入81.68.86.146:5000/v2/_catalog可以看到结果如下{“repositories”:[“comsig”]} 个人公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker之CMD, ENTRYPOINT, RUN使用和对比","date":"2020-09-07T06:28:43.000Z","path":"2020/09/07/docker07/","text":"CMDCMD命令是在容器启动后执行的命令，一个Dockerfile可以有多个CMD，但是只有最后一个CMD生效。当容器启动时如果指定了命令，那么CMD的命令将被忽略。 写一个Dockerfile 1234FROM alpine:latestWORKDIR /workdirENV name &quot;Docker&quot;CMD echo $name 生成新的镜像 secondtonone1/alpine-cmddocker build -t secondtonone1/alpine-cmd .生成后生成容器 1docker run --rm --name cmd secondtonone1/alpine-cmd 可以看到输出docker了接下来我们在容器启动时后边增加一个命令 1docker run --rm -it --name cmd secondtonone1/alpine-cmd sh 此时进入了容器内部，执行了sh命令。Dockerfile中的cmd被忽略了。 RUNrun命令是在构建镜像时执行的命令，我们可以安装一些应用。 12345FROM ubuntu:18.04WORKDIR /workdirRUN apt-get updateRUN apt-get install -y net-toolsCMD netstat 生成镜像 1docker build -f Dockerfile -t cmd2 . 生成容器并启动 1docker run -it --rm cmd2 可以看到容器启动后调用了cmd命令netstat 1234Active Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State Active UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Path ENTRYPOINTENTRYPOINT 和CMD不同，他不会被docker启动后执行的命令覆盖 12345FROM ubuntu:18.04WORKDIR /workdirRUN apt-get updateRUN apt-get install -y net-toolsENTRYPOINT netstat 生成镜像 1docker build -f Dockerfile -t cmd3 . 生成容器并启动 1docker run -it --rm cmd3 /bin/bash 可以看到容器启动后并没有执行/bin/bash命令，而是调用了ENTRYPOINT命令netstat 1234Active Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State Active UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Path RUN和CMD支持参数形式命令123456FROM ubuntu:18.04WORKDIR /workdirENV name &quot;Docker&quot;RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;apt-get update&quot;] RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;apt-get install -y net-tools&quot;] CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo Hello $name !&quot;] 生成镜像 1docker build -f ./Dockerfile -t cmd4 . 运行容器 1docker run -it --rm cmd4 可以看到输出了Hello, Docker! 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"golang操作mongo","date":"2020-08-20T00:58:56.000Z","path":"2020/08/20/golang34/","text":"本文采用mongo-driver/mongo驱动操作数据库 设计mongo插件结构将代码分为如下结构model : odm模型，主要是映射为数据库存储的表结构constants : 存储一些常量config : mongo的配置信息，比如空闲时长，连接数，超时时间等mongodb : 实现了mongo的连接和关闭等功能。 目录结构如下 mongo的连接和断开在mongodb.go中实现了连接和断开操作初始化 1234567891011121314var ( DB *Database)type Database struct &#123; Mongo *mongo.Client&#125;//初始化func Init() &#123; DB = &amp;Database&#123; Mongo: SetConnect(), &#125;&#125; 连接数据库 12345678910111213141516171819202122232425262728293031323334353637func SetConnect() *mongo.Client &#123; var retryWrites bool = false ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() clientOptions := options.Client().SetHosts(config.GetConf().MongoConf.Hosts). SetMaxPoolSize(config.GetConf().MongoConf.MaxPoolSize). SetHeartbeatInterval(constants.HEART_BEAT_INTERVAL). SetConnectTimeout(constants.CONNECT_TIMEOUT). SetMaxConnIdleTime(constants.MAX_CONNIDLE_TIME). SetRetryWrites(retryWrites) //设置用户名和密码 username := config.GetConf().MongoConf.Username password := config.GetConf().MongoConf.Password if len(username) &gt; 0 &amp;&amp; len(password) &gt; 0 &#123; clientOptions.SetAuth(options.Credential&#123;Username: username, Password: password&#125;) &#125; client, err := mongo.Connect(ctx, clientOptions) if err != nil &#123; fmt.Println(err) &#125; // Check the connection err = client.Ping(context.TODO(), nil) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(&quot;Connected to MongoDB!&quot;) return client&#125; 关闭数据库 12345func Close() &#123; ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() DB.Mongo.Disconnect(ctx)&#125; 在model中定义模型定义的模型加上bson标签，这样可以映射到数据库里了 1234567type UserData struct &#123; Id string `bson:&quot;_id,omitempty&quot; json:&quot;id&quot;` Name string `bson:&quot;name&quot; json:&quot;name&quot;` Number int `bson:&quot;number&quot; json:&quot;number&quot;` Age int `bson:&quot;age&quot; json:&quot;age&quot;` BirthMonth int `bson:&quot;birthMonth&quot; json:&quot;birthMonth&quot;`&#125; 在main函数中实现一些demo在main函数中实现一些demo，包括单条插入，多条插入，单条更新，多条更新，分组查询，分页查询1 单条插入 123456789101112131415161718192021222324//单条插入func insertOne() &#123; client := mongodb.DB.Mongo // 获取数据库和集合 collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) userdata := model.UserData&#123;&#125; userdata.Age = 13 userdata.BirthMonth = 11 userdata.Number = 3 userdata.Name = &quot;zack&quot; ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() // 插入一条数据 insertOneResult, err := collection.InsertOne(ctx, &amp;userdata) if err != nil &#123; fmt.Println(&quot;insert one error is &quot;, err) return &#125; log.Println(&quot;collection.InsertOne: &quot;, insertOneResult.InsertedID) //将objectid转换为string docId := insertOneResult.InsertedID.(primitive.ObjectID) recordId := docId.Hex() fmt.Println(&quot;insert one ID str is :&quot;, recordId)&#125; 2 多条插入 12345678910111213141516171819202122232425262728//多条插入func insertMany() &#123; ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() client := mongodb.DB.Mongo // 获取数据库和集合 collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) userdata1 := model.UserData&#123;&#125; userdata1.Age = 20 userdata1.BirthMonth = 11 userdata1.Number = 4 userdata1.Name = &quot;Lilei&quot; userdata2 := model.UserData&#123;&#125; userdata2.Age = 20 userdata2.BirthMonth = 12 userdata2.Number = 5 userdata2.Name = &quot;HanMeiMei&quot; var list []interface&#123;&#125; list = append(list, &amp;userdata1) list = append(list, &amp;userdata2) result, err := collection.InsertMany(ctx, list) if err != nil &#123; fmt.Println(&quot;insert many error is &quot;, err) &#125; fmt.Println(&quot;insert many success, res is &quot;, result.InsertedIDs)&#125; 3 查找单条 12345678910111213141516171819202122232425//查找单个func findOne() &#123; client := mongodb.DB.Mongo // 获取数据库和集合 collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) filter := bson.M&#123;&quot;name&quot;: &quot;HanMeiMei&quot;&#125; ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() singleResult := collection.FindOne(ctx, filter) if singleResult == nil || singleResult.Err() != nil &#123; fmt.Println(&quot;find one error is &quot;, singleResult.Err().Error()) return &#125; userData := &amp;model.UserData&#123;&#125; err := singleResult.Decode(userData) if err != nil &#123; fmt.Println(&quot;find one failed error is &quot;, err) return &#125; fmt.Println(&quot;find one success, res is &quot;, userData)&#125; 4 查找多条 123456789101112131415161718192021222324252627282930//查询多个结果集，用cursorfunc findMany() &#123; client := mongodb.DB.Mongo collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() filter := bson.M&#123;&quot;birthMonth&quot;: bson.M&#123;&quot;$lte&quot;: 12&#125;&#125; cursor, err := collection.Find(ctx, filter) if err != nil &#123; fmt.Println(&quot;find res failed , error is &quot;, err) return &#125; defer cursor.Close(context.Background()) result := make(map[string]*model.UserData) for cursor.Next(context.Background()) &#123; ud := &amp;model.UserData&#123;&#125; err := cursor.Decode(ud) if err != nil &#123; fmt.Println(&quot;decode error is &quot;, err) continue &#125; result[ud.Name] = ud &#125; fmt.Println(&quot;success is &quot;, result) return&#125; 5 更新一条 1234567891011121314151617181920212223242526//更新func updateOne() &#123; client := mongodb.DB.Mongo collection, _ := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION).Clone() ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() /* oid, err := primitive.ObjectIDFromHex(obj.RecordId) if err != nil &#123; logging.Logger.Info(&quot;convert string from object failed&quot;) return err &#125; filter := bson.M&#123;&quot;_id&quot;: oid&#125; */ filter := bson.M&#123;&quot;name&quot;: &quot;zack&quot;&#125; value := bson.M&#123;&quot;$set&quot;: bson.M&#123; &quot;number&quot;: 1024&#125;&#125; _, err := collection.UpdateOne(ctx, filter, value) if err != nil &#123; fmt.Println(&quot;update user data failed, err is &quot;, err) return &#125; fmt.Println(&quot;update success !&quot;) return&#125; 6 更新多条 12345678910111213141516171819//更新多条记录func updateMany() &#123; client := mongodb.DB.Mongo collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() var names = []string&#123;&quot;zack&quot;, &quot;HanMeiMei&quot;&#125; filter := bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$in&quot;: names&#125;&#125; value := bson.M&#123;&quot;$set&quot;: bson.M&#123;&quot;birthMonth&quot;: 3&#125;&#125; result, err := collection.UpdateMany(ctx, filter, value) if err != nil &#123; fmt.Println(&quot;update many failed error is &quot;, err) return &#125; fmt.Println(&quot;update many success !, result is &quot;, result) return&#125; 7 分组查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//分组查询func findGroup() &#123; client := mongodb.DB.Mongo collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() //复杂查询，先匹配后分组 pipeline := bson.A&#123; bson.M&#123; &quot;$match&quot;: bson.M&#123;&quot;birthMonth&quot;: 3&#125;, &#125;, bson.M&#123;&quot;$group&quot;: bson.M&#123; &quot;_id&quot;: bson.M&#123;&quot;birthMonthUid&quot;: &quot;$birthMonth&quot;&#125;, &quot;totalCount&quot;: bson.M&#123;&quot;$sum&quot;: 1&#125;, &quot;nameG&quot;: bson.M&#123;&quot;$min&quot;: &quot;$name&quot;&#125;, &quot;ageG&quot;: bson.M&#123;&quot;$min&quot;: &quot;$age&quot;&#125;, &#125;, &#125;, //bson.M&#123;&quot;$sort&quot;: bson.M&#123;&quot;time&quot;: 1&#125;&#125;, &#125; fmt.Println(&quot;pipeline is &quot;, pipeline) cursor, err := collection.Aggregate(ctx, pipeline) fmt.Println(&quot;findGroup cursor is &quot;, cursor) if err != nil &#123; fmt.Printf(&quot;dao.findGroup collection.Aggregate() error=[%s]\\n&quot;, err) return &#125; for cursor.Next(context.Background()) &#123; doc := cursor.Current totalCount, err_2 := doc.LookupErr(&quot;totalCount&quot;) if err_2 != nil &#123; fmt.Printf(&quot;dao.findGroup totalCount err_2=[%s]\\n&quot;, err_2) return &#125; nameData, err_4 := doc.LookupErr(&quot;nameG&quot;) if err_4 != nil &#123; fmt.Printf(&quot;dao.findGroup insertDateG err_4=[%s]\\n&quot;, err_4) return &#125; ageData, err_5 := doc.LookupErr(&quot;ageG&quot;) if err_5 != nil &#123; fmt.Printf(&quot;dao.findGroup ageG err_5=[%s]\\n&quot;, err_5) continue &#125; fmt.Println(&quot;totalCount is &quot;, totalCount) fmt.Println(&quot;nameData is &quot;, nameData) fmt.Println(&quot;ageData is &quot;, ageData) &#125;&#125; 8 分页查询 123456789101112131415161718192021222324252627282930313233343536//分页查询func limitPage() &#123; client := mongodb.DB.Mongo collection := client.Database(constants.DB_DATABASES).Collection(constants.DB_COLLECTION) ctx, cancel := context.WithTimeout(context.Background(), constants.QUERY_TIME_OUT) defer cancel() filter := bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$gte&quot;: 0&#125;&#125; SORT := bson.D&#123;&#123;&quot;number&quot;, -1&#125;&#125; findOptions := options.Find().SetSort(SORT) //从第1页获取，每次获取10条 skipTmp := int64((1 - 1) * 10) limitTmp := int64(10) findOptions.Skip = &amp;skipTmp findOptions.Limit = &amp;limitTmp cursor, err := collection.Find(ctx, filter, findOptions) defer cursor.Close(context.Background()) if err != nil &#123; fmt.Println(&quot;limit page error is &quot;, err) return &#125; for cursor.Next(context.Background()) &#123; ud := &amp;model.UserData&#123;&#125; err := cursor.Decode(ud) if err != nil &#123; fmt.Println(&quot;user data decode error is &quot;, err) continue &#125; fmt.Println(&quot;user data is &quot;, ud) &#125;&#125; 源码地址可以下载源码，二次封装放到项目中直接使用https://github.com/secondtonone1/golang-/tree/master/gomongo 感谢关注公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"docker命令补充","date":"2020-08-18T03:42:08.000Z","path":"2020/08/18/docker06/","text":"基于本地模板导入镜像假如本地有一个ubuntu系统模板压缩包, 可以通过import导入生成新的镜像 1cat ubuntu-18.04.tar.gz | docker import - ubuntu:18.04 存出和导入镜像存出镜像 1docker save -o ubuntu-18.04.tar ubuntu:18.04 导入镜像 1docker load -i ubuntu-18.04.tar 导出容器1docker export -o ce.tar ce5 导入容器1docker import ce.tar - ce:v1.0 查看容器内进程1docker top 容器id docker私有仓库先拉取registry镜像 1docker pull registry 根据registry启动镜像，构造仓库 1docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry 然后我们查看本地有哪些镜像，随便选择一个推送上去 1docker images 选择一个mongo,我们打个tag，tag前面要写上我们服务器地址和仓库端口号 1docker tag mymongo:latest 81.68.86.146:5000/mymongo 推送到私有仓库 1docker push 81.68.86.146:5000/mymongo 如果出现了http错误，请修改/etc/docker/daemon.json文件 1&quot;insecure-registries&quot;: [&quot;81.68.86.146:5000&quot;] 然后重启docker服务 123sudo systemctl daemon-reloadsudo systemctl restart docker.servicesudo systemctl enable docker.service 重启docker 1docker restart $(docker ps -aq) 这样再次push就可以将镜像push到docker私有仓库了。 利用容器卷备份和迁移数据1 备份，可以将数据备份至挂在目录，这样外界就可以访问并获取了。用ubuntu镜像启动一个新的容器worker，该容器和dbdata容器共享卷, worker启动后将/dbdata下的数据打包放在/backup下 1docker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata 2 还原启动一个容器,挂在/dbdata目录 1docker run -v /dbdata --name dbdata2 ubuntu /bin/bash 再用ubuntu 启动一个新的镜像，共享dbdata2容器的卷 1docker run --volume-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar docker 设置ssh1 拉取ubuntu镜像 1docker pull ubuntu:18.04 2 启动ubuntu容器,将22端口映射为1022端口 1docker run -it -p 1022:22 ubuntu:18.04 3 在容器中安装如下应用 12345apt-get updateapt-get upgradeapt-get install vimapt-get install openssh-serverapt-get install net-tools 然后vim /etc/ssh/sshd_config将PermitRootLogin设置为yes创建文件夹 1mkdir -p /var/run/sshd 然后启动服务 1/usr/sbin/sshd -D &amp; 这时我们查看网路端口 1netstat -tunpl 可以看到22端口启动了为了让容器启动时可以自启动ssh服务,我们实现一个脚本vim /run.sh添加如下 12#!/bin/bash/usr/sbin/sshd -D 然后赋予这个脚本执行权限 1chmod +x /run.sh 然后exit退出，基于改造的docker提交新的镜像 1docker commit cafd85cb0645 ubuntu:ssh 然后我们基于这个镜像启动新的容器 1docker run -d --name ubuntu-ssh -p 1022:22 ca1a463f5c99 /run.sh 因为ssh登录需要账户名和密码，账户名为root，密码我们进入容器设置下 12docker exec -it 28afa8e39353 /bin/bashpasswd 安装后输入passwd,设置密码.之后通过ssh连接就可以了 1ssh root@172.98.23.45 -p 1022 感谢关注我的公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker实战","date":"2020-08-10T01:31:06.000Z","path":"2020/08/10/docker05/","text":"安装mysql今天试试mysql实战安装myql先pull镜像 1docker pull mysql:5.6 接着启动mysql镜像 123456docker run -p 12345:3306 --name mysql56 \\-v /home/zack/dockerwork/mysql/conf:/etc/mysql/conf.d \\-v /home/zack/dockerwork/mysql/logs:/logs \\-v /home/zack/dockerwork/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:5.6 我们查看下docker ps 列出所有docker进程然后我们进入docker里 1docker exec -it 615164d51197 /bin/bash 进入后我们使用myql登录 1mysql -uroot -p 输入密码后进入mysql。之后就可以建立数据库和表了。 启动mongo容器首先先下载mongo的安装包，然后解压放在自己设定的目录下 1234567891011FROM ansible/centos7-ansible:latestRUN mkdir -p /data/mongodb/log/RUN mkdir -p /data/mongodb/binRUN mkdir -p /data/mongodb/data#RUN yum install libssl1.0.0 libssl-devENV PATH /data/mongodb/bin:$PATHADD mongodb-linux-x86_64-rhel70-4.2.8 /data/mongodbWORKDIR /data/mongodb/EXPOSE 60000#VOLUME [&quot;/data/env/mongo/data/:/data/mongodb/data&quot;,&quot;/data/env/mongo/log/:/data/mongodb/log/&quot;]CMD [&quot;/data/mongodb/bin/mongod&quot;,&quot;-f&quot;, &quot;/data/mongodb/mongodb.conf&quot;] 根据Dockerfile生成镜像 1docker build -f ./Dockerfile -t mymongo . 启动docker 1docker run -p 54321:60000 --name submitmg -v /home/zack/dockerwork/mongodb_/data:/data/mongodb/data -v /home/zack/dockerwork/mongodb_/log:/data/mongodb/log/ --privileged=true -d mymongo 进入docker容器 1docker exec -it cdebf8e13939 /bin/bash 登录数据库 1./mongo --port 60000 创建数据库 submit 1use submit 创建数据库表 1db.createCollection(&quot;log_info&quot;) 文档结构如下 12345678&#123; &quot;compareid&quot;:&quot;12345&quot;, &quot;ic&quot;:&quot;23333HC&quot;, &quot;phone&quot;:&quot;18301152001&quot;, &quot;url&quot;:&quot;www.singlepo.com&quot;, &quot;dir&quot;:0, &quot;imageurl&quot;:&quot;www.singlepo.com/wangqiang.jpg&quot;&#125; 创建索引 1db.log_info.createIndex(&#123;&quot;ic&quot;:1,&quot;compareid&quot;:-1&#125;) 插入数据测试 12345678db.log_info.insert(&#123; &quot;compareid&quot;:&quot;12345&quot;, &quot;ic&quot;:&quot;23333HC&quot;, &quot;phone&quot;:&quot;18301152001&quot;, &quot;url&quot;:&quot;www.singlepo.com&quot;, &quot;dir&quot;:0, &quot;imageurl&quot;:&quot;www.singlepo.com/wangqiang.jpg&quot;&#125;) 查询刚才插入的数据 1db.log_info.find() 启动redis容器1 拉取镜像 1docker pull redis:3.2 2 用镜像启动容器 123docker run -p 6679:6379 -v /home/zack/dockerwork/redis/data:/data -v /home/zack/dockerwork/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes 3 配置redis在/home/zack/dockerwork/redis/conf/redis.conf下创建redis.conf文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586port 6379tcp-backlog 511timeout 0tcp-keepalive 0loglevel noticelogfile &quot;&quot;databases 16save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbchecksum yesdbfilename dump.rdbdir ./slave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay noslave-priority 100maxheap 51200000heapdir ./appendonly noappendfilename &quot;appendonly.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-entries 512list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes 4 启动客户端docker exec -it 139abd0bd512 redis-cli进入命令模式后就可以set key value测试了。退出容器可以在redis/data路径里看到appendonly.aof文件里有命令 感谢关注公众号今天的笔记就这些吧，感谢关注公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"Dockerfile入门","date":"2020-08-03T02:08:29.000Z","path":"2020/08/03/docker04/","text":"今天介绍下Dockerfile的基本命令和使用案例 Dockerfile基本命令1234567891011FROM ：基础镜像，该镜像基于哪个镜像生成MAINTAINER ：镜像维护者的姓名和邮箱RUN ：构建容器时需要运行的命令EXPOSE ：容器对外暴露的端口WORKDIR ： 指定在创建容器后，终端默认登录进来的工作目录ENV ：用来在构建镜像过程中设置环境变量ADD : 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包COPY : 类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中CMD : 指定容器启动时要运行的命令，如果有多个CMD命令，只有最后一个生效，CMD会被docker run 之后的参数替换。ENTRYPOINT ：指定一个容器启动时要运行的命令，ENTRYPOINT的目的和CMD一样，都是指定容器启动程序及参数ONBUILD ：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发。 Dockerfile使用示例123456789101112FROM centosMAINTAINER zack&lt;zack@163.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;success---------ok&quot;CMD /bin/bash 根据Dockerfile生辰镜像docker build -t mycentos:v1.0 . 启动容器docker run -it –name mycentosdk 2081f3e41884 ENTRYPOINT 案例entrypoint可以接收 命令行参数，从而达到组合命令的效果现在我们制作一个请求网页的镜像 123FROM centosRUN yum install -y curlENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot; ] 接下来生成镜像 12345docker build -f ./Dockerfile -t ipcheck .``之后分别运行两个命令做对比``` cmddocker run --name ipcheck01 --rm ipcheck 这个是进阶版本 1docker run --name ipcheck02 --rm ipcheck -i 会分别看到不同的效果，-i 的启动方式会额外打印请求的头部信息。 ONBUILD 案例当子类镜像继承父类镜像时，ONBUILD会被执行,我们将上边的Dockerfile改进下 1234FROM centosRUN yum install -y curlENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]ONBUILD RUN echo &quot;father images onbuild ...&quot; 然后我们生成镜像 1docker build -f ./Dockerfile01 -t fatherdk . 我们再写一个子类Dockerfile 123FROM fatherdkRUN yum install -y curlENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;] 我们生成一个子类镜像 1docker build -f ./Dockerfile02 -t sondk . 可以看到构建子类镜像同时会触发父类镜像 综合运用上述命令构造tomcat镜像先写一个Dockerfile 安装tomcat以及jdk 123456789101112131415161718192021222324FROM centosMAINTAINER zack&lt;zack@126.com&gt;#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下COPY c.txt /usr/local/cincontainer.txt#把java与tomcat添加到容器中ADD jdk-8u144-linux-x64.tar.gz /usr/localADD apache-tomcat-9.0.10.tar.gz /usr/local#安装vim 编辑器RUN yum -y install vim#设置工作访问时的WORKDIR路径，登录落脚点ENV MYPATH /usr/localWORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_144ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.10ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.10ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE 8080#启动时运行tomcat# ENTRYPOIINT [&quot;/usr/local/apache-tomcat-9.0.10/bin/startup.sh&quot; ]# CMD [&quot;/usr/local/apache-tomcat-9.0.10/bin/catalina.sh&quot;, &quot;run&quot; ]CMD /usr/local/apache-tomcat-9.0.10/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.10/logs/catalina.out 生成镜像 1docker build -t zacktomcat . 运行容器 1docker run -d -p 9080:8080 --name myt9 -v /home/zack/dockerwork/tomcat9/test:/usr/local/apache-tomcat-9.0.10/webapps/test -v /home/zack/dockerwork/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.10/logs --privileged=true zacktomcat 在浏览器输入地址和端口9080就可以看到tomcat的首页了。 感谢关注公众号今天的笔记就这些吧，感谢关注公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker 容器卷","date":"2020-07-16T05:07:21.000Z","path":"2020/07/16/docker03/","text":"今天介绍docker容器卷的概念，当我们想将docker内的文件路径挂载在宿主机上时，可以采用这种方式。目前可以通过启动命令时使用-v选项设置卷，也可以通过dockerfile设置。我们查看下当前宿主机存在的镜像 1sudo docker images 通过-v 命令启动一个卷1docker run -it --name centosvolum -v /home/zack/dockervol:/dockervol centos:latest -v 表示卷的选项，/home/zack/dockervol 表示宿主机目录，/dockervol表示docker内部路径，通过-v选项将两个路径关联起来。 我们在docker内创建volum.txt，会看到宿主机也自动创建了一个volum.txt文件。这样当我们修改其中一个文件时，另一端可以更新为最新的。我们修改docker内的volum.txt，新增一些文本内容 12vim /dockervol/volum.txt添加几行文本 然后在宿主机一端输入命令 1cat /home/zack/dockervol/volum.txt 可以看到宿主机里的volum.txt中更新为我们在docker中录入的内容 也可以挂在一个只读的docker路径 1docker run -it --name centos-volume-ro -v /home/zack/dockervol:/dockervol:ro centos:latest 如果我们在docker内/dockervol/路径下创建文件，会显示只允许只读操作的提示但是我们可以在宿主机创建文件， 123touch volumro.txtecho ‘I am a readonly file’ &gt;&gt; volumro.txtcat volumro.txt 这样docker路径下可以显示新创建的文件和读取文件内容, 进入docker并查看volumro.txt 12docker exec -it centos-volume-ro /bin/bashcat /dockervol/volumro.txt 就可以看到我们刚才录入的数据了 通过Dockerfile设置volume也可以通过Dockerfile设置volume卷信息，我们写一个Dockerfile 1234from centosVOLUME [&quot;/dockervolume/container1&quot;, &quot;/dockervolume2/container2&quot;]CMD echo &quot;build success ....&quot;CMD /bin/bash 我们根据这个Dockerfile生成镜像 1go build -f ./Dockerfile -t zack/dkcentos . 构建完成后可以通过docker images查看生成的镜像接下来根据zack/dkcentos 生成容器 1docker run -it --name dk01 zack/dkcentos docker ps 可以看到正在运行的docker执行如下命令可以查看容器的卷信息 1docker inspect 17a36db2cabc 多个容器数据共享通过容器之间继承，将卷空间互相共享 1docker run -it --name dk02 --volumes-from dk01 zack/dkcentos 通过volumes-from选项将dk02容器继承dk01，实现卷的共享，所以我们在dk02的/dockervolume/container1目录下创建一个文件并写入hello, dk02 12touch dk02.txtecho &quot;Hello, dk02&quot; &gt;&gt; dk02.txt 会看到dk01容器的/dockervolume/container1目录下也会生成dk02.txt，并且包含写入的文本。接下来基于dk01再创建一个dk03容器 1docker run -it --name dk03 --volumes-from dk01 zack/dkcentos 会看到dk03容器的/dockervolume/container1目录下也会生成dk02.txt，并且包含写入的文本。此时停止容器dk01 1docker stop dk01 然后在dk03的/dockervolume2/container2目录下创建dk03.txt，写入文本很Hello, dk03 12touch dk03.txtecho &quot;Hello, dk03&quot; &gt;&gt; dk03.txt 此时查看dk02， 可以看到/dockervolume2/container2文件夹下产生了dk03.txt，并且包含Hello, dk03文本此时启动dk01, 其/dockervolume2/container2文件夹下也会同步dk03.txt 感谢关注公众号今天的笔记就这些吧，感谢关注公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker命令(二)","date":"2020-07-02T12:45:53.000Z","path":"2020/07/02/docker02/","text":"删除dockersudo docker rm 容器id如果容器正在运行，可以执行强制删除命令sudo docker rm -f 容器id 启动端口映射可以将容器内的端口映射到宿主机上的某个端口，从而达到通过访问宿主机端口访问容器的目的比如我们启动一个tomcat容器docker run -it –name mytomcat -p 8888:8080 tomcat然后可以看到tomcat镜像启动日志，我们exit退出，通过docker ps 查看tomcat镜像还在此时我打开浏览器访问8888端口，可以看到端口和地址是可以访问的，但是资源文件不存在我们用exec命令进入容器docker exec -it ce0da6732832 /bin/bash进入容器后我们将webapps删除，然后将webapps.dist内容复制为webappsrm -rf ./webappscp -r ./webapps.dist ./webapps这时我们重启容器docker restart ce0da6732832这时我们登录浏览器访问8888端口，可以看到tomcat信息了 将容器副本打包为新的镜像可以将容器副本打包为一个新的镜像，docker commit -a “作者名” -m “说明” 容器id 镜像名:版本号我们将我们改造好的tomcat容器打造为新的镜像docker commit -a “secondtonone1” -m “new mytomcat” ce0da6732832 secondtonone1/mytomcat:v1.0屏幕会输出镜像id此时我们查看镜像docker images -a可以看到有两个tomcat镜像，secondtonone1/mytomcat:v1.0的是我们新生成的 根据镜像启动新的docker我们通过secondtonone1/mytomcat:v1.0docker run -id –name mytomcat1.0 -P secondtonone1/mytomcat:v1.0通过查看容器运行，看到如下运行了两个tomcat，其中tomcat1.0是新生成的，他被分配了随机端口32768在浏览器输入地址和32768端口，可以看到新生成的tomcat docker已经运行了。 感谢关注公众号今天的笔记就这些吧，感谢关注公众号","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"docker 基本命令","date":"2020-07-02T01:15:38.000Z","path":"2020/07/02/docker1/","text":"docker 基本命令今天介绍一些docker基本命令，自己最近在学习。docker安装就不介绍了，接下来介绍一些docker常用命令 查看镜像查看本地所有镜像sudo docker images -a如果查看镜像idsudo docker images -aq查看摘要信息sudo docker images –digests查看摘要和imageid 的全部信息sudo docker images –digests –no-trunc在docker仓库搜索tomcat镜像sudo docker search tomcat搜索星数大于30的tomcat镜像sudo docker search -s 30 tomcat 拉取镜像将tomcat镜像拉取到本地sudo docker pull tomcat上面的命令相当于sudo docker pull tomcat:latest 删除镜像sudo docker rmi tomcat删除本地所有镜像sudo docker rmi -f $(docker images -aq) 创建容器启动centos容器，本地没有centos镜像会优先拉取，然后启动sudo docker run -it centos上面的命令it表示交互方式，并启动新的终端，所以会进入新的终端，终端环境是centos镜像docker run -d –name mycentos centos 启动后退出，ps看不到-d 表示以守护进程方式启动，但是由于容器没有任务，所以自动关闭了，所以ps命令看不到。– name 指定新启动的容器的名字 查看本地正在运行的dockersudo docker ps 查看上一次运行的dockersudo docker ps -l 查看本地所有dockersudo docker ps -a 退出docker当我们在docker的终端中，想要退出终端，可以使用exit命令exit命令会导致容器关闭我们也可以使用Ctrl p q的方式退出，按住ctr键，然后先按p,再按q，这种方式退出容器，不会导致容器关闭。 关闭容器我们可以根据容器id关闭指定容器sudo docker stop 0ebc1216db4b强制关闭容器sudo docker kill 0ebc1216db4b 重启和启动容器根据容器id启动容器sudo docker start 0ebc1216db4b根据容器id重启容器sudo docker restart 0ebc1216db4b 查看容器日志docker logs -f -t –tail 行数 容器id-f 跟随最新的文件-t 打印时间–tail 显示最近多少条我们创建一个mycentos的容器，让其以守护方式运行，并且执行轮询输出hello worlddocker run –name mycentos -d centos /bin/sh -c “while true ; do echo hello world ; sleep 2; done “我们查看docker日志docker logs -f -t –tail 3 380975cf268a 查看容器内部进程我们之前创建的mycentos容器以守护进程的方式轮询输出hello world可以根据容器id查看其内部进程docker top 380975cf268a同样可以查看容器内部细节docker inspect 380975cf268a 进入容器如果容器在后台运行，可以通过attach和exec命令向容器发送指令，也可以实现进入容器的效果docker attach 本机的输入直接输到容器中， 不启动新的终端，执行命令docker attach 56d3b13fdc70 //进入docker中docker exec 在docker 里面新开了一个bash 进程，在该终端可以通过命令和容器交互，执行命令//exec也可以实现进入容器的目的docker exec -it 56d3b13fdc70 /bin/bash上述命令通过exec 向容器发送 /bin/bash命令，这样会产生新的终端，进入dockerdocker exec -it 56d3b13fdc70 ls上述命令没有进入容器，但是通过容器启动的新终端向容器发送了ls命令 将容器内容copy至宿主机docker cp 容器id:文件路径 宿主机路径例如docker cp 56d3b13fdc70:/tmp/tmp.log /download将容器中的文件copy至宿主机/download文件夹下","categories":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.limerence2017.com/tags/docker/"}]},{"title":"化繁为简，写一个简单好用的server","date":"2020-06-29T04:19:29.000Z","path":"2020/06/29/golang33/","text":"为什么要造轮子目前很著名的轮子有libevent，boost等高并发的网络库，可以说著名的网络库我都用过，用过才知道当要实现一些定制化的功能时并不方便，不但要了解底层源码，而且还要进行适当的改造，总有种黑盒开发的感觉，所以在15年我就开始自己封装一些epoll,select模型，当时基于多路复用用reactor模式封装了betternet，虽然稳定性不如成熟的网络库，但是可以根据需求灵活修改网络层和应用层，这是难能可贵的。市面上也有一些成型的即时通信server，使用过kbengine，origine等集成度较高的server，当要实现一些心跳，逻辑检测，连接管理等需求时，还是要修改底层的源码，感觉很糟糕。18年接触golang，net包里封装的网络模型和协程管理，很完善的调度策略让我眼前一亮，所以考虑能不能基于golang的官方net包做一些框架上的设计，搭建一个高可用的网络服务。19年基于net包实现了wentby这个服务器，并发和稳定性都不错，最近又翻看了原来的代码，觉得很多地方可以精简一下，而且不想为了兼容别人的开发习惯降低服务器的效率，也不想增加复杂度，所以干脆做一个精简的server给自己用，只要他稳定高效就可以了，线程安全这种问题交由开发者考虑。读了redis网络服务那块也就500行，简约而不简单。 简单的设计我的想法时尽可能减少线程切换的开销，尽可能精简的处理消息，同时也尽可能减少资源的开销，我的想法是这样的当有新的连接建立时，I/O网络协程开辟新的协程，这个协程管理新的连接，负责读取客户端发送的数据。理论上每个连接建立后都有一个单独的协程为其服务，所以对于不同的连接，他们读取数据是并发进行的，无需加锁。同时在各自的协程里完成粘包处理，反序列化为一个逻辑请求包，将该逻辑请求投递的逻辑协程中。逻辑协程可以配置多个，也可以配置一个，建议配置一个，因为多协程处理共享区存在加锁问题，我在逻辑协程底层做了判断，如果逻辑协程数大于1则加锁，否则无锁。我觉得大部分的请求都是I/O密集型的，所以逻辑队列为1个足够，而且能保证应用层是线性处理的。当逻辑协程处理好逻辑请求后，将数据包投递到发送协程。这里发送协程数量也是可配置的，为了尽可能提升发送效率，我这里根据连接的id分配给指定协程发送，比如连接id为1的socket他的发送请求只交给发送携程1，这里用到了取余分配的原则。 用到了哪些技术和库1 网络方面用到了go的原生net包。2 协程分配和管理是自己实现的，协同和退出等通知都是通过channel实现的3 配置和日志库用的beego的，主要是方便，懒得写文件管理。4 由于go的网络层不会提供文件描述符，这里用到了uuid库生成string类型uid管理tcp5 websocket用的原生net/websocket包，也没有单独开辟协程读写和处理，我觉得越简单越好5 websocket每个请求其实是放在独立的协程中管理的，所以各协程处理逻辑时要加锁，这个我处理好了，应用层只需要安心写逻辑就可以。 效率怎么样效率测试了一下，单节点8000以上的长连接，每个连接不间断收发请求未出现卡顿现象，延迟也都在10ms之内，而且未出现连接异常中断和丢包现象。 是否商用目前用于公司内部呼叫系统的并发服务，基于webrtc实现信令控制，消息转发。 源码地址目前代码已经开源https://github.com/secondtonone1/wentmin 展望随着经验的丰富，肯定会不满足现状的，以后会不断优化和扩充。","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"谈谈golang的netpoll原理(二)","date":"2020-05-20T03:17:16.000Z","path":"2020/05/20/golang32/","text":"接上文我们查看了bind和listen流程，直到了listen操作会在内核初始化一个epoll表，并将listen的描述符加入到epoll表中 如何保证epoll表初始化一次前文我们看到pollDesc的init函数中调用了runtime的pollOpen函数完成的epoll创建和描述符加入，这里再贴一次代码 12345678910111213func (pd *pollDesc) init(fd *FD) error &#123; serverInit.Do(runtime_pollServerInit) ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd)) if errno != 0 &#123; if ctx != 0 &#123; runtime_pollUnblock(ctx) runtime_pollClose(ctx) &#125; return errnoErr(syscall.Errno(errno)) &#125; pd.runtimeCtx = ctx return nil&#125; runtime_pollServerInit link的是runtime/netpoll.go中的poll_runtime_pollServerInit函数由于serverInit是sync.Once类型，所以runtime_pollServerInit只被初始化一次，而epoll模型的初始化就是在该函数完成 1234567891011121314func poll_runtime_pollServerInit() &#123; netpollGenericInit()&#125;func netpollGenericInit() &#123; if atomic.Load(&amp;netpollInited) == 0 &#123; lock(&amp;netpollInitLock) if netpollInited == 0 &#123; netpollinit() atomic.Store(&amp;netpollInited, 1) &#125; unlock(&amp;netpollInitLock) &#125;&#125; netpollinit实现了不同模型的初始化，epoll的实现在runtime/netpoll_epoll.go中 123456789101112func netpollinit() &#123; epfd = epollcreate1(_EPOLL_CLOEXEC) if epfd &lt; 0 &#123; epfd = epollcreate(1024) if epfd &lt; 0 &#123; println(&quot;runtime: epollcreate failed with&quot;, -epfd) throw(&quot;runtime: netpollinit failed&quot;) &#125; closeonexec(epfd) &#125; //...&#125; 可以看到上述代码里实现了epoll模型的初始化，所以对于一个M主线程只会初始化一张epoll表，所有要监听的文件描述符都会放入这个表中。 跟随accept看看goroutine挂起逻辑当我们调用Listener的Accept时，Listener为接口类型，实际调用的为TCPListener的Accept函数 12345678910func (l *TCPListener) Accept() (Conn, error) &#123; if !l.ok() &#123; return nil, syscall.EINVAL &#125; c, err := l.accept() if err != nil &#123; return nil, &amp;OpError&#123;Op: &quot;accept&quot;, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err&#125; &#125; return c, nil&#125; Accept内部调用了accept函数，该函数内部实际调用netFD的accept 1234567func (ln *TCPListener) accept() (*TCPConn, error) &#123; fd, err := ln.fd.accept() if err != nil &#123; return nil, err &#125; //...&#125; 在net/fd_unix.go中实现了linux环境下accept的操作 123456789101112131415161718192021func (fd *netFD) accept() (netfd *netFD, err error) &#123; d, rsa, errcall, err := fd.pfd.Accept() if err != nil &#123; if errcall != &quot;&quot; &#123; err = wrapSyscallError(errcall, err) &#125; return nil, err &#125; if netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != nil &#123; poll.CloseFunc(d) return nil, err &#125; if err = netfd.init(); err != nil &#123; netfd.Close() return nil, err &#125; lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd) netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa)) return netfd, nil&#125; 上述函数内部调用的是net/fd_unix.go内部实现的Accept函数 123456789101112131415161718192021222324252627282930func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) &#123; if err := fd.readLock(); err != nil &#123; return -1, nil, &quot;&quot;, err &#125; defer fd.readUnlock() if err := fd.pd.prepareRead(fd.isFile); err != nil &#123; return -1, nil, &quot;&quot;, err &#125; for &#123; s, rsa, errcall, err := accept(fd.Sysfd) if err == nil &#123; return s, rsa, &quot;&quot;, err &#125; switch err &#123; case syscall.EAGAIN: if fd.pd.pollable() &#123; if err = fd.pd.waitRead(fd.isFile); err == nil &#123; continue &#125; &#125; case syscall.ECONNABORTED: // This means that a socket on the listen // queue was closed before we Accept()ed it; // it&#x27;s a silly error, so try again. continue &#125; return -1, nil, errcall, err &#125;&#125; 上述函数就是tcp底层的函数了，accept(fd.Sysfd)监听fd.Sysfd描述符，等待可读事件到来，当可读事件到来后，就可以认为来了一个新的连接，从而创建一个新的描述符给新的连接。当accept出现错误时，需要判断err类型，如果是EAGAIN说明当前没有连接到来，就调用waitRead等待连接，ECONNABORTED说明连接还未accept就断开了，可以忽略。 123func (pd *pollDesc) waitRead(isFile bool) error &#123; return pd.wait(&#x27;r&#x27;, isFile)&#125; 进而调用pollDesc的wait操作 1234567func (pd *pollDesc) wait(mode int, isFile bool) error &#123; if pd.runtimeCtx == 0 &#123; return errors.New(&quot;waiting for unsupported file type&quot;) &#125; res := runtime_pollWait(pd.runtimeCtx, mode) return convertErr(res, isFile)&#125; wait函数中判断pd的runtime上下文是否正常，然后调用runtime包的poll_runtime_pollWait实现挂起等待 12345678910111213141516func poll_runtime_pollWait(pd *pollDesc, mode int) int &#123; err := netpollcheckerr(pd, int32(mode)) if err != 0 &#123; return err &#125; if GOOS == &quot;solaris&quot; || GOOS == &quot;illumos&quot; || GOOS == &quot;aix&quot; &#123; netpollarm(pd, mode) &#125; for !netpollblock(pd, int32(mode), false) &#123; err = netpollcheckerr(pd, int32(mode)) if err != 0 &#123; return err &#125; &#125; return 0&#125; poll_runtime_pollWait运行在内核M线程中，轮询调用netpollblock，所以内核M线程一直在轮询检测netpollblock返回值，当其返回true时循环就可以退出，从而用户态协程就可以继续运行了。 1234567891011121314151617181920212223242526272829func netpollblock(pd *pollDesc, mode int32, waitio bool) bool &#123; gpp := &amp;pd.rg if mode == &#x27;w&#x27; &#123; gpp = &amp;pd.wg &#125; // set the gpp semaphore to WAIT for &#123; old := *gpp if old == pdReady &#123; *gpp = 0 return true &#125; if old != 0 &#123; throw(&quot;runtime: double wait&quot;) &#125; if atomic.Casuintptr(gpp, 0, pdWait) &#123; break &#125; &#125; if waitio || netpollcheckerr(pd, mode) == 0 &#123; gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5) &#125; old := atomic.Xchguintptr(gpp, 0) if old &gt; pdWait &#123; throw(&quot;runtime: corrupted polldesc&quot;) &#125; return old == pdReady&#125; netpollblock内部根据读模式还是写模式，获取pollDesc成员变量的读协程或者写协程地址，然后判断其状态是否为pdReady，这里要详细说一下，golang阻塞一个用户态协程是要将其状态设置为0(正在运行)或者pdWait(阻塞)，这里为0，所以逻辑继续往下走，之后做了一个原子操作将gpp设置为pdWait状态，接着根据这个状态，执行gopark函数，阻塞住用户态协程。当内核想激活用户协程时gopark会返回，然后该函数判断gpp是否为pdReady，从而激活用户态协程。 12345678910111213141516171819func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) &#123; if reason != waitReasonSleep &#123; checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy &#125; mp := acquirem() gp := mp.curg status := readgstatus(gp) if status != _Grunning &amp;&amp; status != _Gscanrunning &#123; throw(&quot;gopark: bad g status&quot;) &#125; mp.waitlock = lock mp.waitunlockf = unlockf gp.waitreason = reason mp.waittraceev = traceEv mp.waittraceskip = traceskip releasem(mp) // can&#x27;t do anything that might move the G between Ms here. mcall(park_m)&#125; gopark将用户态协程放在等待队列中，然后调用mcall触发汇编代码。之后会检测调用unlockf函数，如果unlockf返回false则说明可以解锁用户态协程了。另外官网的注释说unlockf不要访问用户态协程的stack，因为G’s stack可能会在gopark和unlockf之间被移除。到目前为止，我们理解了用户态协程挂起原理。 epoll就绪后如何激活用户态协程想知道如果激活挂起的用户态协程，就要先看看epoll_wait判断就绪事件后怎么处理的。runtime/netpoll_epoll.go中实现了epollwait逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445func netpoll(delay int64) gList &#123; if epfd == -1 &#123; return gList&#123;&#125; &#125; //... var events [128]epolleventretry: n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms) if n &lt; 0 &#123; if n != -_EINTR &#123; println(&quot;runtime: epollwait on fd&quot;, epfd, &quot;failed with&quot;, -n) throw(&quot;runtime: netpoll failed&quot;) &#125; // If a timed sleep was interrupted, just return to // recalculate how long we should sleep now. if waitms &gt; 0 &#123; return gList&#123;&#125; &#125; goto retry &#125; var toRun gList for i := int32(0); i &lt; n; i++ &#123; ev := &amp;events[i] if ev.events == 0 &#123; continue &#125; //... var mode int32 if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 &#123; mode += &#x27;r&#x27; &#125; if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 &#123; mode += &#x27;w&#x27; &#125; if mode != 0 &#123; pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) pd.everr = false if ev.events == _EPOLLERR &#123; pd.everr = true &#125; netpollready(&amp;toRun, pd, mode) &#125; &#125; return toRun&#125; 可以看出netpoll函数调用epollwait返回就绪事件列表，然后遍历就绪的事件列表，从事件类型中取出pollDesc数据，调用netpollready将曾经挂起的协程放入gList中，然后返回该列表 123456789101112131415func netpollready(toRun *gList, pd *pollDesc, mode int32) &#123; var rg, wg *g if mode == &#x27;r&#x27; || mode == &#x27;r&#x27;+&#x27;w&#x27; &#123; rg = netpollunblock(pd, &#x27;r&#x27;, true) &#125; if mode == &#x27;w&#x27; || mode == &#x27;r&#x27;+&#x27;w&#x27; &#123; wg = netpollunblock(pd, &#x27;w&#x27;, true) &#125; if rg != nil &#123; toRun.push(rg) &#125; if wg != nil &#123; toRun.push(wg) &#125;&#125; netpollready调用了unblock函数，并且将协程写入glist中 12345678910111213141516171819202122232425262728func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g &#123; gpp := &amp;pd.rg if mode == &#x27;w&#x27; &#123; gpp = &amp;pd.wg &#125; for &#123; old := *gpp if old == pdReady &#123; return nil &#125; if old == 0 &amp;&amp; !ioready &#123; // Only set READY for ioready. runtime_pollWait // will check for timeout/cancel before waiting. return nil &#125; var new uintptr if ioready &#123; new = pdReady &#125; if atomic.Casuintptr(gpp, old, new) &#123; if old == pdReady || old == pdWait &#123; old = 0 &#125; return (*g)(unsafe.Pointer(old)) &#125; &#125;&#125; netpollunblock函数修改pd所在协程的状态为0，表示可运行状态，所以netpoll函数内部做了这样几件事，根据就绪事件列表找到对应的协程，将挂起的协程状态设置为0表示可运行，然后将该协程放入glist中。在runtime/proc.go中findrunnable会判断是否初始化epoll，如果初始化了则调用netpoll，从而获取glist，然后traceGoUnpark激活挂起的协程 12345678910111213141516func findrunnable() (gp *g, inheritTime bool) &#123; _g_ := getg() //... if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 &#123; if list := netpoll(0); !list.empty() &#123; // non-blocking gp := list.pop() injectglist(&amp;list) casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled &#123; traceGoUnpark(gp, 0) &#125; return gp, false &#125; &#125; //...&#125; 以上就是golang网络调度和协程控制的原理，golang通过epoll和用户态协程调度结合的方式，实现了高并发的网络处理，这种思路是值得日后我们设计产品借鉴的。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"谈谈golang的netpoll原理(一)","date":"2020-05-17T04:30:15.000Z","path":"2020/05/17/golang31/","text":"今天谈谈golang源码netpoll部分实现的细节和协程阻塞调度原理 epoll原理epoll是linux环境下i/o多路复用的模型，结合下图简单说明epoll工作原理 上图说明了epoll生成描epoll表的基本流程，生成socket用来绑定和监听新的连接，将该socket放入epoll内核表，然后调用wait等待就绪事件。当epoll wait返回就绪事件时，判断是否是新的连接，如果是新的连接则将描述符加入epoll表，监听读写事件。如果不是新的连接，说明已建立的连接上有读或写就绪事件，这样我们根据EPOLLOUT或者EPOLLIN进行写或者读操作，上图是echo server的基本原理，实际生产中监听EPOLLIN还是EPOLLOUT根据实际情况而定。以上是单线程下epoll工作原理。 golang 网络层如何封装的epollgolang 网络层封装epoll核心文件在系统文件src/runtime/netpoll.go, 这个文件中调用了不同平台封装的多路复用api，linux环境下epoll封装的文件在src/runtime/netpoll_epoll.go中，windows环境下多路复用模型实现在src/runtime/netpoll_windows.go。golang的思想意在将epoll操作放在runtime包里，而runtime是负责协程调度的功能模块，程序启动后runtime运行时是在单独的线程里，个人认为是MPG模型中M模型，epoll模型管理放在这个单独M中调度，M其实是运行在内核态的，在这个内核态线程不断轮询检测就绪事件，将读写就绪事件抛出，从而触发用户态协程读写调度。而我们常用的read，write，accept等操作其实是在用户态操作的，也就是MPG模型中的G，举个例子当read阻塞时，将该协程挂起，当epoll读就绪事件触发后查找阻塞的协程列表，将该协程激活，用户态G激活后继续读，这样在用户态操作是阻塞的，在内核态其实一直是轮询的，这就是golang将epoll和协程调度结合的原理。 golang 如何实现协程和描述符绑定golang 在internal/poll/fd_windows.go和internal/poll/fd_unix.go中实现了基本的描述符结构 1234567891011type netFD struct &#123; pfd poll.FD // immutable until Close family int sotype int isConnected bool // handshake completed or use of association with peer net string laddr Addr raddr Addr&#125; netFD中pfd结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243type FD struct &#123; // Lock sysfd and serialize access to Read and Write methods. fdmu fdMutex // System file descriptor. Immutable until Close. Sysfd syscall.Handle // Read operation. rop operation // Write operation. wop operation // I/O poller. pd pollDesc // Used to implement pread/pwrite. l sync.Mutex // For console I/O. lastbits []byte // first few bytes of the last incomplete rune in last write readuint16 []uint16 // buffer to hold uint16s obtained with ReadConsole readbyte []byte // buffer to hold decoding of readuint16 from utf16 to utf8 readbyteOffset int // readbyte[readOffset:] is yet to be consumed with file.Read // Semaphore signaled when file is closed. csema uint32 skipSyncNotif bool // Whether this is a streaming descriptor, as opposed to a // packet-based descriptor like a UDP socket. IsStream bool // Whether a zero byte read indicates EOF. This is false for a // message based socket connection. ZeroReadIsEOF bool // Whether this is a file rather than a network socket. isFile bool // The kind of this file. kind fileKind&#125; FD是用户态基本的描述符结构，内部几个变量通过注释可以读懂，挑几个难理解的fdmu 控制读写互斥访问的锁，因为可能几个协程并发读写Sysfd 系统返回的描述符，不会更改除非系统关闭回收rop 为读操作，这个其实是根据不同系统网络模型封装的统一类型，比如epoll，iocp等都封装为统一的operation，根据不同的系统调用不同的模型wop 为写操作封装的类型pd 这个是最重要的结构，内部封装了协程等基本信息，这个变量会和内核epoll线程通信，从而实现epoll通知和控制用户态协程的效果。下面我们着重看看pollDesc结构 123type pollDesc struct &#123; runtimeCtx uintptr&#125; pollDesc内部存储了一个unintptr的变量，uintptr为四字节大小的变量，可以存储指针。runtimeCtx顾名思义，为运行时上下文，其初始化代码如下 12345678910111213func (pd *pollDesc) init(fd *FD) error &#123; serverInit.Do(runtime_pollServerInit) ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd)) if errno != 0 &#123; if ctx != 0 &#123; runtime_pollUnblock(ctx) runtime_pollClose(ctx) &#125; return errnoErr(syscall.Errno(errno)) &#125; pd.runtimeCtx = ctx return nil&#125; runtime_pollOpen实际link的是runtime包下的poll_runtime_pollOpen函数，具体实现在runtime/netpoll.go 12345678910111213141516171819202122232425//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpenfunc poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) &#123; pd := pollcache.alloc() lock(&amp;pd.lock) if pd.wg != 0 &amp;&amp; pd.wg != pdReady &#123; throw(&quot;runtime: blocked write on free polldesc&quot;) &#125; if pd.rg != 0 &amp;&amp; pd.rg != pdReady &#123; throw(&quot;runtime: blocked read on free polldesc&quot;) &#125; pd.fd = fd pd.closing = false pd.everr = false pd.rseq++ pd.rg = 0 pd.rd = 0 pd.wseq++ pd.wg = 0 pd.wd = 0 unlock(&amp;pd.lock) var errno int32 errno = netpollopen(fd, pd) return pd, int(errno)&#125; 可以看出通过pollcache.alloc返回*pollDesc类型的变量pd，并且用pd初始化了netpollopen，这里我们稍作停留，谈谈pollcache 12345678910111213141516171819202122func (c *pollCache) alloc() *pollDesc &#123; lock(&amp;c.lock) if c.first == nil &#123; const pdSize = unsafe.Sizeof(pollDesc&#123;&#125;) n := pollBlockSize / pdSize if n == 0 &#123; n = 1 &#125; // Must be in non-GC memory because can be referenced // only from epoll/kqueue internals. mem := persistentalloc(n*pdSize, 0, &amp;memstats.other_sys) for i := uintptr(0); i &lt; n; i++ &#123; pd := (*pollDesc)(add(mem, i*pdSize)) pd.link = c.first c.first = pd &#125; &#125; pd := c.first c.first = pd.link unlock(&amp;c.lock) return pd&#125; alloc函数做了这样的操作，如果链表头为空则初始化pdSize个pollDesc节点，并pop出头部，如果不为空则直接pop出头部节点，每个节点的类型就是*pollDesc类型，具体实现在runtime/netpoll.go中 123456789101112131415161718192021222324type pollDesc struct &#123; link *pollDesc // in pollcache, protected by pollcache.lock // The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations. // This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime. // pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification) // proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated // in a lock-free way by all operations. // NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg), // that will blow up when GC starts moving objects. lock mutex // protects the following fields fd uintptr closing bool everr bool // marks event scanning error happened user uint32 // user settable cookie rseq uintptr // protects from stale read timers rg uintptr // pdReady, pdWait, G waiting for read or nil rt timer // read deadline timer (set if rt.f != nil) rd int64 // read deadline wseq uintptr // protects from stale write timers wg uintptr // pdReady, pdWait, G waiting for write or nil wt timer // write deadline timer wd int64 // write deadline&#125; 其中rt和wt分别是读写定时器，用来防止读写超时。fd为描述符指针，lock负责保护pollDesc内部成员变量读写防止多线程操作导致并发问题。除此之外最重要的是rg和wg两个变量，rg保存了用户态操作pollDesc的读协程地址，wg保存了用户态操作pollDesc写协程地址。举个例子，当我们在在用户态协程调用read阻塞时rg就被设置为该读协程，当内核态epoll_wait检测read就绪后就会通过rg找到这个协程让后恢复运行。rg,wg默认是0，rg为pdReady表示读就绪，可以将协程恢复，为pdWait表示读阻塞，协程将要被挂起。wg也是如此。所以golang其实是通过pollDesc实现用户态和内核态信息的共享的。回到之前poll_runtime_pollOpen函数，我们就理解了其内部生成*pollDesc，并且传入netpollopen函数，netpollopen对应实现了epoll的init和wait，从而达到了用户态信息和内核态的关联。netpollopen函数不同模型的实现不相同，epoll的实现在runtime/netpoll_epoll.go中 123456func netpollopen(fd uintptr, pd *pollDesc) int32 &#123; var ev epollevent ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)&#125; 从而实现了epoll将fd添加至内核epoll表里，同样pd作为event的data传入内核表，从而实现内核态和用户态协程的关联。runtime/netpoll_epoll.go实现了epoll模型的基本操作，详见源码。 golang如何将一个描述符加入epoll表中传统的流程为:生成socket–&gt; bind socket–&gt; listen–&gt; accept在golang中生成socket，bind，以及listen统一封装好了Listen–&gt; lc.Listen –&gt; sl.listenTCP –&gt; internetSocketinternetSocket –&gt; socket –&gt; newFD &amp;&amp; listenStream在newFD中完成了描述符创建，在listenStream完成了bind和listen。newFD只初始化了基本的结构，未完成pollDesc类型变量pd的初始化。我们跟随源码查看listen的绑定流程 12345678910111213141516171819202122232425func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) &#123; addrs, err := DefaultResolver.resolveAddrList(ctx, &quot;listen&quot;, network, address, nil) if err != nil &#123; return nil, &amp;OpError&#123;Op: &quot;listen&quot;, Net: network, Source: nil, Addr: nil, Err: err&#125; &#125; sl := &amp;sysListener&#123; ListenConfig: *lc, network: network, address: address, &#125; var l Listener la := addrs.first(isIPv4) switch la := la.(type) &#123; case *TCPAddr: l, err = sl.listenTCP(ctx, la) case *UnixAddr: l, err = sl.listenUnix(ctx, la) default: return nil, &amp;OpError&#123;Op: &quot;listen&quot;, Net: sl.network, Source: nil, Addr: la, Err: &amp;AddrError&#123;Err: &quot;unexpected address type&quot;, Addr: address&#125;&#125; &#125; if err != nil &#123; return nil, &amp;OpError&#123;Op: &quot;listen&quot;, Net: sl.network, Source: nil, Addr: la, Err: err&#125; // l is non-nil interface containing nil pointer &#125; return l, nil&#125; 可以看出Listen函数返回的类型为Listener接口类型，其内部根据la类型调用不同的listen函数，这里查看listenTCP 1234567func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error) &#123; fd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, &quot;listen&quot;, sl.ListenConfig.Control) if err != nil &#123; return nil, err &#125; return &amp;TCPListener&#123;fd: fd, lc: sl.ListenConfig&#125;, nil&#125; internetSocket内部调用socket生成描述符返回 1234567891011121314151617181920212223242526272829303132333435func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) &#123; s, err := sysSocket(family, sotype, proto) if err != nil &#123; return nil, err &#125; if err = setDefaultSockopts(s, family, sotype, ipv6only); err != nil &#123; poll.CloseFunc(s) return nil, err &#125; if fd, err = newFD(s, family, sotype, net); err != nil &#123; poll.CloseFunc(s) return nil, err &#125; if laddr != nil &amp;&amp; raddr == nil &#123; switch sotype &#123; case syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET: if err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != nil &#123; fd.Close() return nil, err &#125; return fd, nil case syscall.SOCK_DGRAM: if err := fd.listenDatagram(laddr, ctrlFn); err != nil &#123; fd.Close() return nil, err &#125; return fd, nil &#125; &#125; if err := fd.dial(ctx, laddr, raddr, ctrlFn); err != nil &#123; fd.Close() return nil, err &#125; return fd, nil&#125; socket函数做了这样几件事1 调用sysSocket生成描述符2 调用newFD封装描述符，构造netFD类型变量3 调用netFD的listenDatagram方法，实现bind和listen 12345678910111213141516171819202122232425262728293031func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error &#123; var err error if err = setDefaultListenerSockopts(fd.pfd.Sysfd); err != nil &#123; return err &#125; var lsa syscall.Sockaddr if lsa, err = laddr.sockaddr(fd.family); err != nil &#123; return err &#125; if ctrlFn != nil &#123; c, err := newRawConn(fd) if err != nil &#123; return err &#125; if err := ctrlFn(fd.ctrlNetwork(), laddr.String(), c); err != nil &#123; return err &#125; &#125; if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil &#123; return os.NewSyscallError(&quot;bind&quot;, err) &#125; if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil &#123; return os.NewSyscallError(&quot;listen&quot;, err) &#125; if err = fd.init(); err != nil &#123; return err &#125; lsa, _ = syscall.Getsockname(fd.pfd.Sysfd) fd.setAddr(fd.addrFunc()(lsa), nil) return nil&#125; listenStream除了bind和listen操作之外，还执行了netFD的init操作，这个init操作就是将netFD和epoll关联，将描述符和协程信息写入epoll表 1234567func (fd *netFD) init() error &#123; errcall, err := fd.pfd.Init(fd.net, true) if errcall != &quot;&quot; &#123; err = wrapSyscallError(errcall, err) &#125; return err&#125; 前文讲过fd.pfd为FD类型，是和epoll通信的核心结构，FD的Init方法内完成了pollDesc类型成员变量pd和epoll的关联。其内部调用了fd.pd.init(fd)，pd就是fd的pollDesc类型成员变量，其init函数上面已经解释过了调用了runtime_pollOpen，runtime_pollOpen是link到runtime/netpoll.go中poll_runtime_pollOpen函数，这个函数将用户态协程的pollDesc信息写入到epoll所在的单独线程，从而实现用户态和内核态的关联。总结下bind和listen后续的消息流程就是：listenStream –&gt; bind&amp;listen&amp;init –&gt; pollDesc.Init –&gt; runtime_pollOpen –&gt; poll_runtime_pollOpen –&gt; epollctl(EPOLL_CTL_ADD) 到此为止golang网络描述符从生成到绑定和监听，以及写入epoll表的流程分析完毕，下一篇分析accept流程以及用户态协程如何挂起，epoll就绪后如何唤醒协程。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"谈谈高并发秒拍系统架构设计","date":"2020-05-15T04:36:07.000Z","path":"2020/05/15/golang30/","text":"缓冲系统结构今天谈谈电商秒杀抢购或者高并发集中访问情况下，如何设计稳定高效的缓冲系统。常用的做法是采取逻辑分离，将秒杀功能分化为不同的逻辑进行设计，降低耦合度同时增加缓冲队列降低访问压力。 可以将秒杀抢购功能分为接入层和逻辑层，接入层主要负责基本的判断如token检测，用户检测，请求是否合法等，逻辑层则做主要的逻辑处理和判断。如下图1 秒杀接入层主协程启动后，启动多个接入层的读协程和写协程，当有请求到来时接入层主协程判断是否合理，将合理的请求写入chan缓冲队列。2 然后多个接入层的读协程从chan中读取待处理的消息，每个协程操作redis，将待处理的请求判断无误后写入redis待处理请求队列中。3 逻辑层主协程启动多个逻辑层读协程和写协程，逻辑层读协程从redis的待处理请求队列中读取待处理请求，进行并发处理，然后写入逻辑层chan队列中4 逻辑层写协程从逻辑层chan取出处理结果写入redis的处理结果队列5 接入层的读协程并发从redis处理结果队列中取出处理结果，将处理结果写入主协程，从而完成整个消息流程。消息处理通过接入层和逻辑层分离解耦，压力降低，同时每层带有多个读写协程和自己的chan缓冲队列，实现了异步处理。redis的加入也让高并发处理更稳定和安全。 代码实现接入层主协程逻辑判断和消息写入chan中，同时监听读协程返回的处理结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768func SecKill(req *config.SecRequest) (data map[string]interface&#123;&#125;, err error) &#123; data = make(map[string]interface&#123;&#125;, components.INIT_INFO_SIZE) //。。。。省略判断逻辑 msgtoredis := &amp;MsgReqToRedis&#123; ProductId: req.ProductId, UserId: req.UserId, &#125; writetimer := time.NewTimer(time.Second * 5) defer writetimer.Stop() select &#123; case &lt;-writetimer.C: logs.Debug(&quot;msg write to redis chan timeout, maybe chan has beeen closed&quot;) data[&quot;status&quot;] = config.MSG_CHAN_CLOSED data[&quot;message&quot;] = &quot;msg chan to redis closed&quot; return case MsgRdMgr.MsgChanToRedis &lt;- msgtoredis: logs.Debug(&quot;msg chan to redis success&quot;) &#125; //设置定时器，超时检测，防止请求阻塞 ticker := time.NewTicker(time.Duration(10) * time.Second) defer func() &#123; ticker.Stop() &#125;() select &#123; case msgrsp, ok := &lt;-MsgRdMgr.MsgChanFromRedis: if !ok &#123; logs.Debug(&quot;msg rsp from redis chan closed &quot;) data[&quot;status&quot;] = config.MSG_CHAN_CLOSED data[&quot;message&quot;] = &quot;msg chan from redis closed&quot; return &#125; if msgrsp.Status != config.STATUS_SEC_SUCCESS &#123; logs.Debug(msgrsp.Message) data[&quot;status&quot;] = msgrsp.Status data[&quot;message&quot;] = msgrsp.Message return &#125; datamap := make(map[string]interface&#123;&#125;, components.INIT_INFO_SIZE) datamap[&quot;productid&quot;] = msgrsp.ProductId datamap[&quot;userid&quot;] = msgrsp.UserId datamap[&quot;token&quot;] = msgrsp.Token data[&quot;data&quot;] = datamap data[&quot;status&quot;] = config.STATUS_SEC_SUCCESS data[&quot;message&quot;] = &quot;seckill success&quot; //更新product 信息 components.SKConfData.SecInfoRWLock.Lock() defer components.SKConfData.SecInfoRWLock.Unlock() components.SKConfData.SecInfoData[msgrsp.ProductId].Left = msgrsp.Left return case &lt;-ticker.C: data[&quot;status&quot;] = config.STATUS_REQ_TIMEOUT data[&quot;message&quot;] = &quot;seckill timeout&quot; return case &lt;-MsgRdMgr.FromRedisGrClose: data[&quot;status&quot;] = config.FROM_REDIS_GR_CLOSED data[&quot;message&quot;] = &quot;from redis chan group closed&quot; return case &lt;-MsgRdMgr.ToRedisGrClose: data[&quot;status&quot;] = config.TO_REDIS_GR_CLOSED data[&quot;message&quot;] = &quot;to redis chan group closed&quot; return &#125;&#125; 接入层读协程从redis处理结果队列中读取结果 12345678910111213141516171819202122232425262728293031323334353637func ReadFromRedis(wg *sync.WaitGroup) &#123; conn := components.MsgReqPool.Get() defer func() &#123; wg.Done() conn.Close() &#125;() for &#123; reply, err := conn.Do(&quot;blpop&quot;, &quot;msgfromredis&quot;, 0) if err != nil &#123; logs.Debug(&quot;pop from msgfromredis failed ...%s&quot;, err.Error()) continue &#125; if reply == nil &#123; logs.Debug(&quot;msg read from redis ,data is nil&quot;) continue &#125; kvarray, err := redis.Strings(reply, err) if err != nil &#123; logs.Debug(&quot;msgfromredis string convert failed, %v&quot;, err.Error()) continue &#125; logs.Debug(&quot;read from redis msgfromredis , ip is %v&quot;, kvarray) msgfromrd := new(MsgRspFromRedis) err = json.Unmarshal([]byte(kvarray[1]), msgfromrd) if err != nil &#123; logs.Warn(&quot;json unmarshal failed , err is : %v&quot;, err.Error()) continue &#125; select &#123; case MsgRdMgr.MsgChanFromRedis &lt;- msgfromrd: logs.Debug(&quot;read from redis success, put data intto read redis chan&quot;) continue &#125; &#125;&#125; 接入层写协程向redis待处理请求队列中写入请求 1234567891011121314151617181920212223242526272829//proxy向redis中写func WriteToRedis(wg *sync.WaitGroup) &#123; defer func() &#123; wg.Done() &#125;() for &#123; select &#123; case msgtoredis, ok := &lt;-MsgRdMgr.MsgChanToRedis: if !ok &#123; logs.Debug(&quot;msg chan to redis closed&quot;) return &#125; jsmal, err := json.Marshal(msgtoredis) if err != nil &#123; logs.Debug(&quot;json marshal failed&quot;) continue &#125; conn := components.MsgReqPool.Get() defer conn.Close() _, err = conn.Do(&quot;rpush&quot;, &quot;msgtoredis&quot;, string(jsmal)) if err != nil &#123; logs.Debug(&quot;rpush to msgtoredis failed ...%s&quot;, err.Error()) continue &#125; &#125; &#125;&#125; 同样的道理，逻辑层也实现了读写协程，和上面类似不做赘述我们可以看看效果，分别启动接入层和逻辑层进程，然后再浏览器启动输入请求http://localhost:9091/seckill?product_id=12&amp;user_id=14可以看到两个进程打印的日志信息浏览器返回处理结果具体源码地址https://github.com/secondtonone1/golang-/tree/master/seckill感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（十）","date":"2020-04-02T05:42:06.000Z","path":"2020/04/02/golang29/","text":"前情回顾前文我们完成了日志管理系统后台开发。 本节目标这次为日志管理搭建一个web管理平台，可以通过web端录入项目和配置信息，以及项目对应的日志路径和采集信息，并且写入etcd，这样通过之前编写的日志采集系统可以根据etcd采集对应的日志。 选择beego作为web后台开发web端采用beego框架进行开发，beego是一个采用mvc三层架构设计的web框架。这里阐述下web管理平台的架构和功能。components里包含web平台用到的组件，包括beego日志插件，etcd插件，mysql插件。conf里包含了web的配置信息，配置在app.conf这个文件中。logs存储了web平台生成的日志controllers为mvc架构中的c，也就是控制层，将models数据映射到view中。models为mvc架构中的m，也就是数据层，负责从mysql中读取数据以及写入数据views为mvc架构中的v，也就是视图层，这里为web端展示的前端界面。routers保存了路由回应的回调函数，这样根据对应的路由调用不同的函数，从而调用不同的controller。statics存储了css和js文件，这个主要是网页端用到的。 代码流程main函数中初始化插件，并且启动beego 12345678910111213141516171819202122232425262728func init_components() bool &#123; err := components.InitLogger() //调用logger初始化 if err != nil &#123; logs.Warn(&quot;initDb failed, err :%v&quot;, err) return false &#125; err = components.InitDb() if err != nil &#123; logs.Warn(&quot;initDb failed, err:%v&quot;, err) return false &#125; err = components.InitEtcd() if err != nil &#123; logs.Warn(&quot;init etcd failed, err:%v&quot;, err) return false &#125; return true&#125;func main() &#123; if init_components() == false &#123; return &#125; beego.Run()&#125; 插件初始化具体可以查看我的源码，之后在最下方我给出源码链接。接下来我们看看routers中路由规则的注册 123456789func init() &#123; beego.Router(&quot;/index&quot;, &amp;AppController.AppController&#123;&#125;, &quot;*:AppList&quot;) beego.Router(&quot;/app/list&quot;, &amp;AppController.AppController&#123;&#125;, &quot;*:AppList&quot;) beego.Router(&quot;/app/apply&quot;, &amp;AppController.AppController&#123;&#125;, &quot;*:AppApply&quot;) beego.Router(&quot;/app/create&quot;, &amp;AppController.AppController&#123;&#125;, &quot;*:AppCreate&quot;) beego.Router(&quot;/log/apply&quot;, &amp;LogController.LogController&#123;&#125;, &quot;*:LogApply&quot;) beego.Router(&quot;/log/list&quot;, &amp;LogController.LogController&#123;&#125;, &quot;*:LogList&quot;) beego.Router(&quot;/log/create&quot;, &amp;LogController.LogController&#123;&#125;, &quot;*:LogCreate&quot;)&#125; /index为首页展示/app/list为项目列表/app/apply为创建项目/app/create为创建项目后跳转的路由/log/apply为创建日志/log/list为为日志列表展示/log/create为日志创建成功后跳转的路由接下来通过一个路由说说逻辑流程。当用户在浏览器输入http://localhost:8080/index,web后端通过路由调用Controller中的AppList函数 12345678910111213141516171819func (p *AppController) AppList() &#123; logs.Debug(&quot;enter index controller&quot;) p.Layout = &quot;layout/layout.html&quot; appList, err := model.GetAllAppInfo() if err != nil &#123; p.Data[&quot;Error&quot;] = fmt.Sprintf(&quot;服务器繁忙&quot;) p.TplName = &quot;app/error.html&quot; logs.Warn(&quot;get app list failed, err:%v&quot;, err) return &#125; logs.Debug(&quot;get app list succ, data:%v&quot;, appList) p.Data[&quot;applist&quot;] = appList p.TplName = &quot;app/index.html&quot;&#125; 可以看到我们设置了布局文件和模板文件，并且调用models获取所有项目的信息，然后设置到data中，通过模板返回。前端可以通过网页展示项目列表。GetAllAppInfo获取项目信息的实现放在model层。 123456789func GetAllAppInfo() (appList []AppInfo, err error) &#123; err = Db.Select(&amp;appList, &quot;select app_id, app_name, app_type, create_time, develop_path from tbl_app_info&quot;) if err != nil &#123; logs.Warn(&quot;Get All App Info failed, err:%v&quot;, err) return &#125; return&#125; model通过查询数据库将项目信息返回。这些数据存储在mysql表中。这里其实是通过orm映射，将数据库表的数据存储在我们定义的结构体 12345678type AppInfo struct &#123; AppId int `db:&quot;app_id&quot;` AppName string `db:&quot;app_name&quot;` AppType string `db:&quot;app_type&quot;` CreateTime string `db:&quot;create_time&quot;` DevelopPath string `db:&quot;develop_path&quot;` IP []string&#125; 数据库表如下 测试web管理平台我们点击项目申请,填写项目信息提交后可以看到项目列表同样我们点击日志申请，填写信息查看日志信息数据库表也存储成功了 源码下载https://github.com/secondtonone1/golang-/tree/master/logcatchsys感谢关注我的公众号个人微信号1017234088, 添加请注明来源!","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（九）","date":"2020-03-24T05:11:18.000Z","path":"2020/03/24/golang28/","text":"前情回顾前文我们完成了kafka消费逻辑实现，并将消息放入elasticsearch，然后通过kibana可视化工具查看我们的日志。 本节目标前文只是完成了kafka消息消费以及放入elastic，这次将项目完善，使其支持热更新，就是当config.yaml中监控的日志改变，或者etcd数据有改变时，动态启动协程监控新增日志，关闭取消的日志监控协程。 新增变量控制协程自启动kafkaconsumer.go中新增如下代码 123456789101112131415161718var topicMap map[string]map[int32]*TopicDatavar topicSet map[string]boolvar etcd_topicSet map[string]boolvar etcd_topicMap map[string]map[int32]*TopicDatavar topicChan chan *TopicPartvar etcd_topicChan chan *TopicPartvar consumer_list []sarama.Consumervar etcdcli *clientv3.Clientfunc init() &#123; topicMap = make(map[string]map[int32]*TopicData) etcd_topicMap = make(map[string]map[int32]*TopicData) topicSet = make(map[string]bool) etcd_topicSet = make(map[string]bool) topicChan = make(chan *TopicPart, 20) etcd_topicChan = make(chan *TopicPart, 20) consumer_list = make([]sarama.Consumer, 0, 20)&#125; topicMap用来存储config.yaml中直接记录的日志topic以及协程参数，etcd_topicMap用来记录etcd中记录的topic以及协程参数。topicSet用来记录config.yaml中直接记录的日志topic, etcd_topicSet用来记录etcd中记录的topic。topicChan当监控日志写入elastic的协程异常崩溃时，通过该chan返回topic信息，然后我们通过topicMap找到topic对应的协程重启。etcd_topicChan协程根据etcd的保存的topic，监控etlastic处理，如果该协程崩溃，则通过etcd_topicMap中查找topic对应的协程重启。consumer_list保存了kafka消费者列表。etcdcli时etcd的客户端，用来处理etcd读写。 根据config中配置的日志topic生成set1234567891011121314151617func ConstructTopicSet() map[string]bool &#123; topicSetTmp := make(map[string]bool) configtopics, _ := logconfig.ReadConfig(logconfig.InitVipper(), &quot;collectlogs&quot;) if configtopics == nil &#123; goto CONFTOPIC &#125; for _, configtopic := range configtopics.([]interface&#123;&#125;) &#123; confmap := configtopic.(map[interface&#123;&#125;]interface&#123;&#125;) for key, val := range confmap &#123; if key.(string) == &quot;logtopic&quot; &#123; topicSetTmp[val.(string)] = true &#125; &#125; &#125;CONFTOPIC: return topicSetTmp&#125; 根据config中配置的etcd键值获取val，然后获取topic生成setetcdconsumer.go中通过GetTopicSet从etcd中读取topic生生set 123456789101112131415161718192021222324252627282930313233343536func GetTopicSet(cli *clientv3.Client) (interface&#123;&#125;, error) &#123; etcdKeys, etcdres := logconfig.ReadConfig(logconfig.InitVipper(), &quot;etcdkeys&quot;) if !etcdres &#123; fmt.Println(&quot;read config etcdkeys failed&quot;) return nil, errors.New(&quot;read config etcdkeys failed&quot;) &#125; fmt.Println(reflect.TypeOf(etcdKeys)) topicSet := make(map[string]bool) for _, keyval := range etcdKeys.([]interface&#123;&#125;) &#123; ctxtime, cancel := context.WithTimeout(context.Background(), time.Second) resp, err := cli.Get(ctxtime, keyval.(string)) cancel() if err != nil &#123; fmt.Println(&quot;get failed, err:&quot;, err) continue &#125; for _, ev := range resp.Kvs &#123; fmt.Printf(&quot;%s : %s ...\\n&quot;, ev.Key, ev.Value) etcdLogConf := make([]*etcdlogconf.EtcdLogConf, 0, 20) unmarsherr := json.Unmarshal(ev.Value, &amp;etcdLogConf) if unmarsherr != nil &#123; fmt.Println(&quot;unmarshal error !, error is &quot;, unmarsherr) continue &#125; for _, etcdval := range etcdLogConf &#123; topicSet[etcdval.Topic] = true &#125; &#125; &#125; return topicSet, nil&#125; 将集合转化为map，并配置协程然后启动123456789101112131415161718192021222324252627282930313233func ConvertSet2Map(consumer sarama.Consumer, topicSet map[string]bool, topicMaps map[string]map[int32]*TopicData, topic_chan chan *TopicPart) &#123; for key, _ := range topicSet &#123; partitionList, err := consumer.Partitions(key) if err != nil &#123; fmt.Println(&quot;get consumer partitions failed&quot;) fmt.Println(&quot;error is &quot;, err.Error()) continue &#125; for partition := range partitionList &#123; pc, err := consumer.ConsumePartition(key, int32(partition), sarama.OffsetNewest) if err != nil &#123; fmt.Println(&quot;consume partition error is &quot;, err.Error()) continue &#125; // defer pc.AsyncClose() topicData := new(TopicData) topicData.Ctx, topicData.Cancel = context.WithCancel(context.Background()) topicData.KafConsumer = pc topicData.TPartition = new(TopicPart) topicData.TPartition.Partition = int32(partition) topicData.TPartition.Topic = key _, okm := topicMaps[key] if !okm &#123; topicMaps[key] = make(map[int32]*TopicData) &#125; topicMaps[key][int32(partition)] = topicData go PutIntoES(topicData, topic_chan) &#125; &#125;&#125; 从kafka中读取消息，并调用上面的函数启动协程监控es从kafka中读取信息，然后根据配置生成set和map，启动协程监控es 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384func ConsumeTopic(consumer sarama.Consumer) &#123; ConvertSet2Map(consumer, topicSet, topicMap, topicChan) ConvertSet2Map(consumer, etcd_topicSet, etcd_topicMap, etcd_topicChan) //监听配置文件 ctx, cancel := context.WithCancel(context.Background()) pathChan := make(chan interface&#123;&#125;) etcdChan := make(chan interface&#123;&#125;) go logconfig.WatchConfig(ctx, logconfig.InitVipper(), pathChan, etcdChan) defer func(cancel context.CancelFunc) &#123; consumer_once.Do(func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;consumer main goroutine panic, &quot;, err) &#125; cancel() &#125;) &#125;(cancel) for &#123; select &#123; //检测监控路径的协程崩溃，重启 case topicpart := &lt;-topicChan: fmt.Printf(&quot;receive goroutine exited, topic is %s, partition is %d\\n&quot;, topicpart.Topic, topicpart.Partition) //重启消费者读取数据的协程 val, ok := topicMap[topicpart.Topic] if !ok &#123; continue &#125; tp, ok := val[topicpart.Partition] if !ok &#123; continue &#125; tp.Ctx, tp.Cancel = context.WithCancel(context.Background()) go PutIntoES(tp, topicChan) //检测etcd配置解析后，监控路径的协程崩溃，重启 case topicpart := &lt;-etcd_topicChan: fmt.Printf(&quot;receive goroutine exited, topic is %s, partition is %d\\n&quot;, topicpart.Topic, topicpart.Partition) //重启消费者读取数据的协程 val, ok := etcd_topicMap[topicpart.Topic] if !ok &#123; continue &#125; tp, ok := val[topicpart.Partition] if !ok &#123; continue &#125; tp.Ctx, tp.Cancel = context.WithCancel(context.Background()) go PutIntoES(tp, etcd_topicChan) //检测vipper监控返回配置的更新 case pathchange, ok := &lt;-pathChan: if !ok &#123; fmt.Println(&quot;vipper watch goroutine exited&quot;) goto LOOPEND &#125; //fmt.Println(pathchange) topicSetTemp := make(map[string]bool) for _, chval := range pathchange.([]interface&#123;&#125;) &#123; for logkey, logval := range chval.(map[interface&#123;&#125;]interface&#123;&#125;) &#123; if logkey.(string) == &quot;logtopic&quot; &#123; topicSetTemp[logval.(string)] = true &#125; &#125; &#125; UpdateTopicLogRoutine(topicSetTemp) //fmt.Println(topicSetTemp) case etcdchange, ok := &lt;-etcdChan: if !ok &#123; fmt.Println(&quot;vipper watch goroutine extied&quot;) goto LOOPEND &#125; fmt.Println(etcdchange) topicsetTemp, err := etcdconsumer.GetTopicSet(etcdcli) if err != nil &#123; continue &#125; UpdateEtcdTopicLogRoutine(topicsetTemp.(map[string]bool)) &#125; &#125;LOOPEND: fmt.Printf(&quot;for exited &quot;)&#125; go logconfig.WatchConfig 启动协程，调用vipper监控配置，当配置有更新时消费者协程处理更新的topic。同时支持子协程异常崩溃时，消费者协程重启该协程。 通过kibana看到的日志信息kibana中ManageMent管理，然后新增index，elastic的index我们设置的是topic，所以我们新建几个index,etcd_log, golang_log, logdir2。然后kibana中可以看到这几个index的日志信息了 源码下载https://github.com/secondtonone1/golang-/tree/master/logcatchsys感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（八）","date":"2020-01-15T03:09:49.000Z","path":"2020/01/15/golang27/","text":"前情回顾前文我们完成了日志采集系统基本功能，包括日志监控，日志采集，配置热更新，协程动态启动和关闭，同时扩充支持了etcd管理文件路径。 本节目标本节新增日志查询和检索功能。基本思路是将日志信息从kafka中读取，然后放到elasticsearch中，elasticsearch是一个分布式多用户能力的全文搜索引擎，我们可以通过它提供的web接口访问和查询指定数据。另外，为了更方便的检索和查询，可以利用kibana配合elastic可视化查询。Kibana 是为 Elasticsearch设计的开源分析和可视化平台。 源码实现将日志从kafka中读取并解析写入elastic这部分功能，我们将其提炼到另外一个进程中，单独启动监控并处理kafka数据。 12345678910111213141516package mainimport ( &quot;fmt&quot; kafconsumer &quot;golang-/logcatchsys/kafconsumer&quot; &quot;golang-/logcatchsys/logconfig&quot;)func main() &#123; v := logconfig.InitVipper() if v == nil &#123; fmt.Println(&quot;vipper init failed!&quot;) return &#125; kafconsumer.GetMsgFromKafka()&#125; 主函数调用了我封装的kafconsumer包的读取消息函数GetMsgFromKafka。 1234567891011121314151617181920212223242526272829303132333435363738func GetMsgFromKafka() &#123; fmt.Println(&quot;kafka consumer begin ...&quot;) config := sarama.NewConfig() config.Consumer.Return.Errors = true var kafkaddr = &quot;localhost:9092&quot; kafkaconf, _ := logconfig.ReadConfig(logconfig.InitVipper(), &quot;kafkaconfig.kafkaaddr&quot;) if kafkaconf != nil &#123; kafkaddr = kafkaconf.(string) &#125; //创建消费者 consumer, err := sarama.NewConsumer([]string&#123;kafkaddr&#125;, config) if err != nil &#123; fmt.Println(&quot;consumer create failed, error is &quot;, err.Error()) return &#125; defer func(consumer sarama.Consumer) &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;consumer panic error &quot;, err) &#125; consumer.Close() topicSet = nil //回收所有协程 for _, val := range topicMap &#123; for _, valt := range val &#123; valt.Cancel() &#125; &#125; topicMap = nil &#125;(consumer) topicSetTmp := ConstructTopicSet() if topicSetTmp == nil &#123; fmt.Println(&quot;construct topic set error &quot;) return &#125; topicSet = topicSetTmp ConsumeTopic(consumer)&#125; GetMsgFromKafka中创建了kafka消费者，然后根据配置调用ConstructTopicSet构造topic集合，topicSet集合其实是一个map，保证了集合中的topic不重复。然后调用ConsumeTopic函数根据topic从kafka取出数据。 1234567891011121314151617func ConstructTopicSet() map[string]bool &#123; topicSetTmp := make(map[string]bool) configtopics, _ := logconfig.ReadConfig(logconfig.InitVipper(), &quot;collectlogs&quot;) if configtopics == nil &#123; goto CONFTOPIC &#125; for _, configtopic := range configtopics.([]interface&#123;&#125;) &#123; confmap := configtopic.(map[interface&#123;&#125;]interface&#123;&#125;) for key, val := range confmap &#123; if key.(string) == &quot;logtopic&quot; &#123; topicSetTmp[val.(string)] = true &#125; &#125; &#125;CONFTOPIC: return topicSetTmp&#125; ConstructTopicSet读取配置中的topic列表，然后将这些topic放到map中返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func ConsumeTopic(consumer sarama.Consumer) &#123; for key, _ := range topicSet &#123; partitionList, err := consumer.Partitions(key) if err != nil &#123; fmt.Println(&quot;get consumer partitions failed&quot;) fmt.Println(&quot;error is &quot;, err.Error()) continue &#125; for partition := range partitionList &#123; pc, err := consumer.ConsumePartition(key, int32(partition), sarama.OffsetNewest) if err != nil &#123; fmt.Println(&quot;consume partition error is &quot;, err.Error()) continue &#125; defer pc.AsyncClose() topicData := new(TopicData) topicData.Ctx, topicData.Cancel = context.WithCancel(context.Background()) topicData.KafConsumer = pc topicData.TPartition = new(TopicPart) topicData.TPartition.Partition = int32(partition) topicData.TPartition.Topic = key _, okm := topicMap[key] if !okm &#123; topicMap[key] = make(map[int32]*TopicData) &#125; topicMap[key][int32(partition)] = topicData go ReadFromEtcd(topicData) &#125; &#125; for &#123; select &#123; case topicpart := &lt;-topicChan: fmt.Printf(&quot;receive goroutine exited, topic is %s, partition is %d\\n&quot;, topicpart.Topic, topicpart.Partition) //重启消费者读取数据的协程 val, ok := topicMap[topicpart.Topic] if !ok &#123; continue &#125; tp, ok := val[topicpart.Partition] if !ok &#123; continue &#125; tp.Ctx, tp.Cancel = context.WithCancel(context.Background()) go ReadFromEtcd(tp) &#125; &#125;&#125; ConsumeTopic实际是将topic集合中的topic遍历放到map中，然后启动协程调用ReadFromEtcd函数读取消息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677func ReadFromEtcd(topicData *TopicData) &#123; fmt.Printf(&quot;kafka consumer begin to read message, topic is %s, part is %d\\n&quot;, topicData.TPartition.Topic, topicData.TPartition.Partition) logger := log.New(os.Stdout, &quot;LOGCAT&quot;, log.LstdFlags|log.Lshortfile) elastiaddr, _ := logconfig.ReadConfig(logconfig.InitVipper(), &quot;elasticconfig.elasticaddr&quot;) if elastiaddr == nil &#123; elastiaddr = &quot;localhost:9200&quot; &#125; esClient, err := elastic.NewClient(elastic.SetURL(&quot;http://&quot;+elastiaddr.(string)), elastic.SetErrorLog(logger)) if err != nil &#123; // Handle error logger.Println(&quot;create elestic client error &quot;, err.Error()) return &#125; info, code, err := esClient.Ping(&quot;http://&quot; + elastiaddr.(string)).Do(context.Background()) if err != nil &#123; logger.Println(&quot;elestic search ping error, &quot;, err.Error()) esClient.Stop() esClient = nil return &#125; fmt.Printf(&quot;Elasticsearch returned with code %d and version %s\\n&quot;, code, info.Version.Number) esversion, err := esClient.ElasticsearchVersion(&quot;http://&quot; + elastiaddr.(string)) if err != nil &#123; fmt.Println(&quot;elestic search version get failed, &quot;, err.Error()) esClient.Stop() esClient = nil return &#125; fmt.Printf(&quot;Elasticsearch version %s\\n&quot;, esversion) defer func(esClient *elastic.Client) &#123; if err := recover(); err != nil &#123; fmt.Printf(&quot;consumer message panic %s, topic is %s, part is %d\\n&quot;, err, topicData.TPartition.Topic, topicData.TPartition.Partition) topicChan &lt;- topicData.TPartition &#125; &#125;(esClient) var typestr = &quot;catlog&quot; typeconf, _ := logconfig.ReadConfig(logconfig.InitVipper(), &quot;elasticconfig.typestr&quot;) if typeconf != nil &#123; typestr = typeconf.(string) &#125; for &#123; select &#123; case msg, ok := &lt;-topicData.KafConsumer.Messages(): if !ok &#123; fmt.Println(&quot;etcd message chan closed &quot;) return &#125; fmt.Printf(&quot;%s---Partition:%d, Offset:%d, Key:%s, Value:%s\\n&quot;, msg.Topic, msg.Partition, msg.Offset, string(msg.Key), string(msg.Value)) idstr := strconv.FormatInt(int64(msg.Partition), 10) + strconv.FormatInt(msg.Offset, 10) logdata := &amp;LogData&#123;Topic: msg.Topic, Log: string(msg.Value), Id: idstr&#125; createIndex, err := esClient.Index().Index(msg.Topic).Type(typestr).Id(idstr).BodyJson(logdata).Do(context.Background()) if err != nil &#123; logger.Println(&quot;create index failed, &quot;, err.Error()) continue &#125; fmt.Println(&quot;create index success, &quot;, createIndex) case &lt;-topicData.Ctx.Done(): fmt.Println(&quot;receive exited from parent goroutine !&quot;) return &#125; &#125;&#125; ReadFromEtcd函数将kafka中读取的数据写入elastic中，同时如果协程崩溃向父协程发送通知，重启该协程。 效果展示我们启动之前的日志监控程序，然后启动现在设计的信息处理程序。可以看到日志不断被写入时，监控程序将日志的变化信息写入kafka。同时，信息处理程序不断的从kafka中读取数据写入elastic。我们通过kibana查询数据 源码下载https://github.com/secondtonone1/golang-/tree/master/logcatchsys感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"2019再见","date":"2019-12-31T09:46:45.000Z","path":"2019/12/31/new3/","text":"2019最后一天，做个总结吧 今年读了七本英文书阿加莎系列《尼罗河惨案》，《怪屋》，《东方快车谋杀案》，《寓所谜案》狄更斯系列《雾都孤儿》，《远大前程》商业创新《从零到一》 编程水平提升编程水平明显提升，通过自己制定的弱点针对训练，并发编程水平有明显提升github提交量574，比去年增加30%，提交量为自己独立开发项目的提交次数， golang今年完成了golang的自学，已经能熟练使用golang，并利用其协程特性写出高并发的网络框架wentby，wentby名字的意思是为了纪念和薄荷第一期学员分开。之后基于wentby完成二次开发，制作了游戏服务器wentserver，经测试并发量和稳定性可观。也学习了golang的大部分库，gomicro，gprc，vipper等很熟练运用，而且对etcd，kafka，elesticsearch等高并发信息处理缓存工具有了新的认识。结合这些知识搞了个日志采集系统。 C++我的本命语言C++，今年并没有突破性长进，主要是等明年C++20出来再一波学了，写点教程和工具。 python最喜欢的语言，今年没有实质性突破，现在已经具备用python实现各种工具的水平。 网络编程IO多路复用那一套一直记着，今年没搞，这个有印象就足够了，知道原理以后结合实际情况封装也没问题，我估计以后这种轮子也不用开发者自己造了，golang实现的就挺好，C++也有boost，libevent等网络库也会用，网络这边自己也比较擅长。 公众号粉丝涨了160公众号粉丝涨了200多，又掉了六十多，慢慢运营吧，反正就是分享自己的技术，也没想过炒粉，不过今年10月份开了流量主，这两个月赚了470多块钱。 年度重磅~胖虎诞生！我给女儿取了个小名，胖虎，四月出生的白羊座 个人博客不断完善个人博客不断完善，增加了搜索和评论，而且完成了大部分技术的录入，以后打算做成检索式的博客系统。 展望2020能多赚钱就多赚钱，技术方面学一学前端vue和js，顺便把C++20捡回来，做个独立的博客系统，公众号粉丝正确突破一千。还有最重要的，身体健康，万事如意。","categories":[{"name":"生活感悟","slug":"news","permalink":"http://www.limerence2017.com/categories/news/"}],"tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://www.limerence2017.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"}]},{"title":"Go项目实战：打造高并发日志采集系统（七）","date":"2019-12-27T02:52:20.000Z","path":"2019/12/27/golang26/","text":"前情回顾前文我们完成了日志采集系统基本功能，包括日志监控，日志采集，配置热更新，协程动态启动和关闭等。 本节目标前文我们是通过将要监控的日志路径配置在配置文件中，根据配置文件热更新动态监控日志。本节将etcd服务加入系统中，可以将要监控的日志文件路径和主题序列化为字符串保存到etcd中，这样系统可以监控etcd中该值得变化，从而动态启动协程和关闭协程监控指定日志。这样可以通过etcd和配置文件两种方式监控日志。 图解系统监控日志流程 前文的日志系统流程如下扩充后的日志系统流程如下可见改进后的系统支持etcd服务检测日志路径变化，从而启动协程进行监控。 设计思路我们在配置文件中添加几个key值，用来记录etcd存储的key。1 我们的系统读取配置文件中的etcd的key值，启动协程A读取etcd中key的value，进而启动子协程B监控value记录的日志路径。2 协程A还要监控etcd中的key对应的value是否有变化，如果value中有日志路径新增，则启动新的协程B监控新增日志。如果value中有日志路径减少，关闭旧的协程B。3 当配置文件中的key有变化，我们关闭原来的协程A及其子协程B，启动新的协程A，这样协程A继续启动新的子协程B监控日志。而且新的协程A还要监控etcd的value是否有变化。 代码实现简单阐述下部分代码，完整代码在文末。 123456789101112131415161718type EtcdLogConf struct &#123; Path string `json:&quot;path&quot;` Topic string `json:&quot;topic&quot;` Ctx context.Context `json:&quot;-&quot;` Cancel context.CancelFunc `json:&quot;-&quot;` KeyChan chan string `json:&quot;-&quot;` KafkaProducer *kafkaqueue.ProducerKaf `json:&quot;-&quot;`&#125;type EtcdLogMgr struct &#123; Ctx context.Context Cancel context.CancelFunc KeyChan chan string KafkaProducer *kafkaqueue.ProducerKaf EtcdKey string EtcdClient *clientv3.Client EtcdConfMap map[string]*EtcdLogConf&#125; 定义了两个结构，EtcdLogMgr用来管理协程A，EtcdLogConf用来管理协程B。 12345678910111213141516171819202122232425func ConstructEtcd(etcdDatas interface&#123;&#125;, keyChan chan string, kafkaProducer *kafkaqueue.ProducerKaf, etcdaddr interface&#123;&#125;) map[string]*EtcdLogMgr &#123; etcdMgr := make(map[string]*EtcdLogMgr) if etcdDatas == nil &#123; return etcdMgr &#125; logkeys := etcdDatas.([]interface&#123;&#125;) for _, logkey := range logkeys &#123; clientv3 := InitEtcdClient(etcdaddr) if clientv3 == nil &#123; continue &#125; etcdData := new(EtcdLogMgr) ctx, cancel := context.WithCancel(context.Background()) etcdData.Ctx = ctx etcdData.Cancel = cancel etcdData.KafkaProducer = kafkaProducer etcdData.KeyChan = keyChan etcdData.EtcdKey = logkey.(string) etcdData.EtcdClient = clientv3 etcdMgr[logkey.(string)] = etcdData fmt.Println(etcdData.EtcdKey, &quot; init success &quot;) &#125; return etcdMgr&#125; ConstructEtcd根据参数构造了一个map返回，这个map主要是管理A类型的协程。这个map在主函数检测到配置文件中的etcd的key值变化会动态修改map中key对应的value，并且启动或关闭对应的协程A。 1234567891011121314151617181920212223242526272829303132333435363738394041//根据etcd中的日志监控信息启动和关闭协程func UpdateEtcdGoroutine(etcdMgr map[string]*EtcdLogMgr, etcdlogData interface&#123;&#125;, kafkaProducer *kafkaqueue.ProducerKaf,keyChan chan string, etcdaddr interface&#123;&#125;) &#123; if etcdlogData == nil &#123; return &#125; logkeys := etcdlogData.([]interface&#123;&#125;) newkeyMap := make(map[string]bool) for _, logkey := range logkeys &#123; fmt.Println(&quot;update key is &quot;, logkey.(string)) newkeyMap[logkey.(string)] = true &#125; for oldkey, oldval := range etcdMgr &#123; if _, ok := newkeyMap[oldkey]; !ok &#123; oldval.Cancel() delete(etcdMgr, oldkey) &#125; &#125; for newkey, _ := range newkeyMap &#123; if _, ok := etcdMgr[newkey]; !ok &#123; clientv3 := InitEtcdClient(etcdaddr) if clientv3 == nil &#123; continue &#125; etcdData := new(EtcdLogMgr) ctx, cancel := context.WithCancel(context.Background()) etcdData.Ctx = ctx etcdData.Cancel = cancel etcdData.KafkaProducer = kafkaProducer etcdData.KeyChan = keyChan etcdData.EtcdKey = newkey etcdData.EtcdClient = clientv3 etcdMgr[newkey] = etcdData fmt.Println(etcdData.EtcdKey, &quot; init success &quot;) go WatchEtcdKeys(etcdData) &#125; &#125;&#125; UpdateEtcdGoroutine功能就是通过config.yaml中etcd的key变化而动态启动和关闭协程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func WatchEtcdKeys(etcdMgr *EtcdLogMgr) &#123; defer func() &#123; if erreco := recover(); erreco != nil &#123; etcdMgr.KeyChan &lt;- etcdMgr.EtcdKey fmt.Println(&quot;watch etcd panic, exited&quot;) goto CLEARLOG_GOROUTINE &#125; fmt.Println(&quot;watch etcd exit&quot;) etcdMgr.EtcdClient.Close() CLEARLOG_GOROUTINE: for _, val := range etcdMgr.EtcdConfMap &#123; val.Cancel() &#125; etcdMgr.EtcdConfMap = nil &#125;() etcdMgr.EtcdConfMap = make(map[string]*EtcdLogConf) ctxtime, cancel := context.WithTimeout(context.Background(), time.Second) resp, err := etcdMgr.EtcdClient.Get(ctxtime, etcdMgr.EtcdKey) cancel() if err != nil &#123; fmt.Println(&quot;get failed, err:&quot;, err) return &#125; for _, ev := range resp.Kvs &#123; fmt.Printf(&quot;%s : %s ...\\n&quot;, ev.Key, ev.Value) etcdLogConf := make([]*EtcdLogConf, 0, 20) unmarsherr := json.Unmarshal(ev.Value, &amp;etcdLogConf) if unmarsherr != nil &#123; fmt.Println(&quot;unmarshal error !, error is &quot;, unmarsherr) continue &#125; for _, etcdval := range etcdLogConf &#123; etcdMgr.EtcdConfMap[etcdval.Topic] = etcdval etcdval.Ctx, etcdval.Cancel = context.WithCancel(context.Background()) etcdval.KeyChan = logConfChan etcdval.KafkaProducer = etcdMgr.KafkaProducer go WatchEtcdFile(etcdval) &#125; fmt.Println(etcdMgr.EtcdConfMap) &#125; watchChan := etcdMgr.EtcdClient.Watch(etcdMgr.Ctx, etcdMgr.EtcdKey) for &#123; select &#123; case wresp, ok := &lt;-watchChan: if !ok &#123; fmt.Println(&quot;watch etcd key receive parent goroutine exited&quot;) return &#125; UpdateEtcdFile(etcdMgr, &amp;wresp) case logConfKey := &lt;-logConfChan: etcdvalt, ok := etcdMgr.EtcdConfMap[logConfKey] if !ok &#123; continue &#125; //重启日志监控协程 go WatchEtcdFile(etcdvalt) &#125; &#125;&#125; WatchEtcdKeys里实现了协程A从etcd中读取key对应的value，并且序列化出日志路径和主题。然后启动子协程B执行WatchEtcdFile操作，WatchEtcdFile就是之前我们实现的监控指定路径的日志逻辑。 1234func WatchEtcdFile(etcdFile *EtcdLogConf) &#123; logtailf.WatchLogFile(etcdFile.Topic, etcdFile.Path, etcdFile.Ctx, etcdFile.KeyChan, etcdFile.KafkaProducer)&#125; WatchEtcdFile内部调用了logtailf包的WatchLogFile，这个是之前我们实现的日志监控逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func UpdateEtcdFile(etcdMgr *EtcdLogMgr, wresp *clientv3.WatchResponse) &#123; etcdNewMap := make(map[string]*EtcdLogConf) for _, ev := range wresp.Events &#123; fmt.Printf(&quot;%s %q:%q\\n&quot;, ev.Type, ev.Kv.Key, ev.Kv.Value) if ev.Type == mvccpb.DELETE &#123; continue &#125; //panic(&quot;test panic&quot;) etcdLogConfTmp := make([]*EtcdLogConf, 0, 20) unmarsherr := json.Unmarshal(ev.Kv.Value, &amp;etcdLogConfTmp) if unmarsherr != nil &#123; fmt.Println(&quot;unmarshal error !, error is &quot;, unmarsherr) continue &#125; for _, logslice := range etcdLogConfTmp &#123; etcdNewMap[logslice.Topic] = logslice &#125; &#125; for oldkey, oldval := range etcdMgr.EtcdConfMap &#123; _, ok := etcdNewMap[oldkey] if !ok &#123; //该日志文件取消监控 oldval.Cancel() delete(etcdMgr.EtcdConfMap, oldkey) &#125; &#125; for newkey, newval := range etcdNewMap &#123; oldval, ok := etcdMgr.EtcdConfMap[newkey] if !ok &#123; //新增日志文件，启动协程监控 etcdMgr.EtcdConfMap[newval.Topic] = newval newval.Ctx, newval.Cancel = context.WithCancel(context.Background()) newval.KeyChan = logConfChan newval.KafkaProducer = etcdMgr.KafkaProducer go WatchEtcdFile(newval) continue &#125; //判断val是否修改 if newval.Path != oldval.Path &#123; oldval.Cancel() delete(etcdMgr.EtcdConfMap, oldval.Topic) etcdMgr.EtcdConfMap[newval.Topic] = newval newval.Ctx, newval.Cancel = context.WithCancel(context.Background()) newval.KeyChan = logConfChan newval.KafkaProducer = etcdMgr.KafkaProducer go WatchEtcdFile(newval) continue &#125; &#125;&#125; UpdateEtcdFile实现了当etcd中的val有变化时，该函数对比之前的数据，启动新的协程监控新日志，如果日志路径删除，则关闭监控该日志的协程 测试在配置文件config.yaml中添加 1234567etcdkeys: - &quot;collectlogkey1&quot; - &quot;collectlogkey2&quot;etcdconfig: - &quot;localhost:2379&quot; - &quot;localhost:3379&quot; - &quot;localhost:4379&quot; etcdkeys为etcd服务中记录的key, etcdconfig为etcd服务的地址列表，我们启动的是个集群。安装etcd服务后，启动etcd集群，这个百度一下就知道了。然后我们启动日志采集系统，看到如下因为etcd服务中没有collectlogkey1和collectlogkey2，所以我们的采集系统没有输出监控信息。但是采集系统已经启动协程A监控这两个key了，当etcd中这两个key有value或改变，协程A会启动协程B监控日志。我们通过测试程序向etcd写入日志路径信息我们向collectlogkey1写入了两个日志路径，可以看到采集系统协程A检测到etcd变化从而启动了协程B监控这两个日志如果我们修改etcd中collectlogkey1的值，改为只监控一个日志，日志采集系统会动态关闭无用的协程B如果我们将collectlogkey1从etcd中删除, 那么采集系统会自动关闭监控collectlogkey1的协程A的所有子协程B。 总结通过增加etcd服务监控，使系统的功能更全面。通过配置文件中etcd的多个key,主协程启动并管理多个协程A，而每个协程A根据etcd中key对应的value启动多个协程B，协程B监控指定日志的变化。这种协程嵌套使用一定要注意协程异常退出和正常退出这两种情况，以及资源回收问题。当协程A异常退出时，主协程重启协程A，当协程B异常退出时，协程A重启协程B。当协程A正常退出时，通知其下所有子协程B正常退出。源码下载https://github.com/secondtonone1/golang-/tree/master/logcatchsys感谢关注公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（六）","date":"2019-12-06T07:37:15.000Z","path":"2019/12/06/golang25/","text":"前情回顾前文我们完成了日志采集系统的日志文件监控，配置文件热更新，协程异常检测和保活机制。 本节目标本节加入kafka消息队列，kafka前文也介绍过了，可以对消息进行排队，解耦合和流量控制的作用，为什么一定要用kafka呢？主要原因就是在日志高并发读取后，如果直接将消息发给前端或者写入数据库，会造成崩溃或者卡死。kafka可以对消息进行排队和减轻压力，这样无论以后将这些消息录入数据库也好，传给前端分析也好，都能保证系统稳定性。代码我们也写过和测试了，只需要将之前写好的kafka读写消息代码整合过来即可。 主函数创建kafka生产者在主函数中创建kafkaProducer,然后在defer中回收该资源。我们将该producer传递给每个监控日志的协程中，当日志有修改，就通过producer将修改的信息写入kafka，用kafka排队和缓存，可以提高稳定性，减少流量高峰。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func main() &#123; //省略... kafkaProducer := &amp;kafkaqueue.ProducerKaf&#123;Producer: producer&#125; configMgr = make(map[string]*logconfig.ConfigData) keyChan := make(chan string, KEYCHANSIZE) ConstructMgr(configPaths, keyChan, kafkaProducer) defer func() &#123; mainOnce.Do(func() &#123; //省略... kafkaProducer.Producer.Close() &#125;) &#125;() for &#123; select &#123; case pathData, ok := &lt;-pathChan: if !ok &#123; return &#125; //省略... for conkey, conval := range pathDataNew &#123; oldval, ok := configMgr[conkey] if !ok &#123; //省略... go logtailf.WatchLogFile(configData.ConfigKey, configData.ConfigValue, ctx, keyChan, kafkaProducer) continue &#125; if oldval.ConfigValue != conval.(string) &#123; //省略... go logtailf.WatchLogFile(conkey, conval.(string), ctx, keyChan, kafkaProducer) continue &#125; &#125; case keystr := &lt;-keyChan: val, ok := configMgr[keystr] if !ok &#123; continue &#125; //省略... go logtailf.WatchLogFile(keystr, val.ConfigValue, ctxcover, keyChan, kafkaProducer) &#125; &#125;&#125; WatchLogFile函数携带了该producer。有人会问多个协程共享producer是否会出问题？我查看了Producer发送消息的源码红框中使用了chan传递数据，所以在多个协程调用producer的发送函数是没问题的。 监控协程写入kafka消息当日志新增时，我们在监控日志的协程向kafka写入消息 123456789101112131415func WatchLogFile(pathkey string, datapath string, ctx context.Context, keychan chan&lt;- string, kafProducer *kafkaqueue.ProducerKaf) &#123; //省略逻辑... for true &#123; select &#123; case msg, ok := &lt;-tailFile.Lines: //省略逻辑... kafProducer.PutIntoKafka(pathkey, msg.Text) case &lt;-ctx.Done(): fmt.Println(&quot;receive main gouroutine exit msg&quot;) fmt.Println(&quot;watch log file &quot;, pathkey, &quot; goroutine exited&quot;) return &#125; &#125;&#125; 封装kafkaProducer上述代码中调用的kafkaProducer是我自己封装的，其实就是组合了原生的kafka生产者，并且封装了发送函数 1234567891011121314151617181920func CreateKafkaProducer() (sarama.SyncProducer, error) &#123; config := sarama.NewConfig() // 等待服务器所有副本都保存成功后的响应 config.Producer.RequiredAcks = sarama.WaitForAll // 随机的分区类型：返回一个分区器，该分区器每次选择一个随机分区 config.Producer.Partitioner = sarama.NewRandomPartitioner // 是否等待成功和失败后的响应 config.Producer.Return.Successes = true // 使用给定代理地址和配置创建一个同步生产者 producer, err := sarama.NewSyncProducer([]string&#123;&quot;localhost:9092&quot;&#125;, config) if err != nil &#123; fmt.Println(&quot;create producer failed, &quot;, err.Error()) return nil, err &#125; fmt.Println(&quot;create kafka producer success&quot;) return producer, nil&#125; 上面的函数返回了原生的kafka生产者接口，接下来我们封装这个原生接口，然后编写了写入kafka的方法。 1234567891011121314151617181920type ProducerKaf struct &#123; Producer sarama.SyncProducer&#125;func (p *ProducerKaf) PutIntoKafka(keystr string, valstr string) &#123; //构建发送的消息， msg := &amp;sarama.ProducerMessage&#123; Topic: &quot;logcatchsys&quot;, Key: sarama.StringEncoder(keystr), Value: sarama.StringEncoder(valstr), &#125; partition, offset, err := p.Producer.SendMessage(msg) if err != nil &#123; fmt.Println(&quot;Send message Fail&quot;) fmt.Println(err.Error()) &#125; fmt.Printf(&quot;Partition = %d, offset=%d, msgvalue=%s \\n&quot;, partition, offset, valstr)&#125; 启动kafka测试我们先启动zookeeper和kafkazookeeper进入bin文件夹点击zkServer.cmd即可启动kafka启动使用如下命令 1.\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties 然后我们创建主题logcatchsys 1.\\bin\\windows\\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 16 --topic logcatchsys 这样我们为主题logcatchsys创建了16个分区。接下来我们启动消费者 1.\\bin\\windows\\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic logcatchsys --from-beginning 然后我们启动我们的采集系统和测死脚本，看到如下可以看到当日志文件不断被写入时，我们的采集系统会将修改的内容实时监控并写入kafka队列，然后kafka消费者从队列中取出这些消息。 总结目前完成了日志采集系统所有功能的开发和测试，包括配置文件的热更新，监控协程的自动关闭和启动，异常修复和自启动，日志消息的监听，kafka消息的读写等。但这并不是终点，只是一个起点，以后会配合前端开发不断完善，目前先告一段落。源码下载https://github.com/secondtonone1/golang-/tree/master/logcatchsys感谢关注公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（五）","date":"2019-12-04T05:54:55.000Z","path":"2019/12/04/golang24/","text":"前情回顾前文我们完成了如下功能1 根据配置文件启动多个协程监控日志，并启动协程监听配置文件。2 根据配置文件热更新，动态协调日志监控。3 编写测试代码，向文件中不断写入日志并备份日志，验证系统健壮性。 本节目标我们旨在编写一个健壮性较强的日志监控系统，不得不考虑这样一个问题，当某个日志监控协程崩溃或者异常退出，该如何处理？我的想法是当监控日志文件的协程异常退出时，在主协程复活这个异常退出的协程，使其继续工作，这样极大的增强了系统的稳定性。 借尸还魂，增加异常处理我们在tailf.go的WatchLogFile中增加异常处理，在协程崩溃时打印日志信息，并且向keychan中写入字符串通知主协程处理。 123456789101112func WatchLogFile(pathkey string, datapath string, ctx context.Context, keychan chan&lt;- string) &#123; //省略之前写好的逻辑 //.... defer func() &#123; if errcover := recover(); errcover != nil &#123; fmt.Println(&quot;goroutine watch &quot;, pathkey, &quot; panic&quot;) fmt.Println(errcover) keychan &lt;- pathkey &#125; &#125;() //省略逻辑....&#125; WatchLogFile函数进行了扩充，增加了pathkey字符串表示监控哪个日志文件，pathkey实际是config.yaml中的路径的key值。keychan 实际是一个缓冲chan，用来和主协程通信，告诉自己挂掉了。WatchLogFile 中其余逻辑和前文一样，不做赘述。 主协程中增加复活逻辑同样，在主协程中我们需要创建keychan这个缓冲chan，并且捕获子协程发过来的崩溃消息。 123456789101112131415161718192021func main()&#123; //....省略 keyChan := make(chan string, KEYCHANSIZE) //.... for &#123; select &#123; case pathData, ok := &lt;-pathChan: //省略... case keystr := &lt;-keyChan: val, ok := configMgr[keystr] if !ok &#123; continue &#125; fmt.Println(&quot;recover goroutine watch &quot;, keystr) var ctxcover context.Context ctxcover, val.ConfigCancel = context.WithCancel(context.Background()) go logtailf.WatchLogFile(keystr, val.ConfigValue, ctxcover, keyChan) &#125; &#125;&#125; 在主协程中愿有逻辑基础上，我们增加了keyChan的初始化，以及keychan数据的监听。当主协程收到keychan的数据时，我们可以根据keystr修改其对应的context，并且启动新的协程继续监听该日志文件。这样就达到了复活那些异常死掉的协程的目的。 keychan该如何回收keychan被多个子协程引用，该如何回收？这种情况下多个子协程写数据，一个主协程接受数据，我们常用的策略如下：1 不要在接受协程中关闭chan，因为如果此时有其他发送协程向关闭的chan写数据会导致崩溃。2 有多个发送协程，等待最后一个发送协程退出时关闭chan可防止崩溃。3 不作处理，等待系统回收，前提是保证所有协程正常退出，否则会导致资源泄漏。我再三考虑了一下，统计最后协程退出会增加逻辑的复杂性，所以交给系统回收吧，但是我做好了协程的死锁检测和退出通知，应该不会有问题。 制造协程崩溃现场，模拟测试系统稳定性为了测试我们的系统稳定性，我在修改WatchLogFile函数，新增如下处理，中断key值为logdir3的监控协程，进而观察主协程能否再次启动协程监听该日志文件。 123456789101112131415func WatchLogFile(pathkey string, datapath string, ctx context.Context, keychan chan&lt;- string) &#123; //...省略 defer func() &#123; if errcover := recover(); errcover != nil &#123; fmt.Println(&quot;goroutine watch &quot;, pathkey, &quot; panic&quot;) fmt.Println(errcover) keychan &lt;- pathkey &#125; &#125;() //模拟崩溃 if pathkey == &quot;logdir3&quot; &#123; panic(&quot;test panic &quot;) &#125; //...省略 然后我们启动日志系统，看到如下效果从日志上可以看到每当我们的协程挂掉，主协程会启动新的协程继续监听日志，保证了系统的稳定性。谢谢关注我的公众号源码下载地址https://github.com/secondtonone1/golang-/tree/master/logcatchsys","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（四)","date":"2019-12-03T06:01:29.000Z","path":"2019/12/03/golang23/","text":"前情回顾前文我们完成了如下目标1 项目架构整体编写2 使框架支持热更新 本节目标在前文的框架基础上，我们1 将之前实现的日志监控功能整合到框架中。2 一个日志对应一个监控协程，当配置热更新后根据新配置动态关闭和启动协程。3 编写测试代码，模拟向文件中不断写入日志，并备份日志，观察监控功能是否健壮。 增加协程监控日志文件我们将之前实现的日志监控功能整合到现有框架，文件结构如下logdir为存储日志的文件夹，模拟不同系统记录的日志。实际生产中不同系统会自己记录日志并保存在指定文件夹中，logdir模拟的就是这些指定文件。logtailf实现日志文件的监控功能。writefile模拟不同系统向指定文件夹写入日志，用来测试日志写入和备份时，我们的采集系统是否健壮。我们先看下logtailf.go 1234567891011121314151617181920212223242526272829303132333435363738func WatchLogFile(datapath string, ctx context.Context) &#123; fmt.Println(&quot;begin goroutine watch log file &quot;, datapath) tailFile, err := tail.TailFile(datapath, tail.Config&#123; //文件被移除或被打包，需要重新打开 ReOpen: true, //实时跟踪 Follow: true, //如果程序出现异常，保存上次读取的位置，避免重新读取 Location: &amp;tail.SeekInfo&#123;Offset: 0, Whence: 2&#125;, //支持文件不存在 MustExist: false, Poll: true, &#125;) if err != nil &#123; fmt.Println(&quot;tail file err:&quot;, err) return &#125; for true &#123; select &#123; case msg, ok := &lt;-tailFile.Lines: if !ok &#123; fmt.Printf(&quot;tail file close reopen, filename: %s\\n&quot;, tailFile.Filename) time.Sleep(100 * time.Millisecond) continue &#125; //fmt.Println(&quot;msg:&quot;, msg) //只打印text fmt.Println(&quot;msg:&quot;, msg.Text) case &lt;-ctx.Done(): fmt.Println(&quot;receive main gouroutine exit msg&quot;) fmt.Println(&quot;watch log file &quot;, datapath, &quot; goroutine exited&quot;) return &#125; &#125;&#125; 只有一个函数WatchLogFile用来监控指定路径的日志文件，两个参数分别为日志路径和上下文开关，开关用来关闭这个协程，整体功能和前几篇讲述的一样，不做赘述。接下来我们在main.go中填加协程启动逻辑监控日志文件 12345678910111213func ConstructMgr(configPaths interface&#123;&#125;) &#123; configDatas := configPaths.(map[string]interface&#123;&#125;) for conkey, confval := range configDatas &#123; configData := new(logconfig.ConfigData) configData.ConfigKey = conkey configData.ConfigValue = confval.(string) ctx, cancel := context.WithCancel(context.Background()) configData.ConfigCancel = cancel configMgr[conkey] = configData go logtailf.WatchLogFile(configData.ConfigValue, ctx) &#125;&#125; ConstructMgr新增了协程启动逻辑，并且将协程的ctx保存在map中，这样主协程可以根据热更新启动和关闭这个协程。然后我完善了main函数中的析构函数 123456789101112defer func() &#123; mainOnce.Do(func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;main goroutine panic &quot;, err) // 这里的err其实就是panic传入的内容 &#125; cancel() for _, oldval := range configMgr &#123; oldval.ConfigCancel() &#125; configMgr = nil &#125;) &#125;() 析构函数里遍历map，关闭所有监控协程，并且将map设置为nil回收资源。在main函数中添加热更新控制协程开关。 12345678910111213141516171819202122232425262728293031323334for oldkey, oldval := range configMgr &#123; _, ok := pathDataNew[oldkey] if ok &#123; continue &#125; oldval.ConfigCancel() delete(configMgr, oldkey)&#125;for conkey, conval := range pathDataNew &#123; oldval, ok := configMgr[conkey] if !ok &#123; configData := new(logconfig.ConfigData) configData.ConfigKey = conkey configData.ConfigValue = conval.(string) ctx, cancel := context.WithCancel(context.Background()) configData.ConfigCancel = cancel configMgr[conkey] = configData fmt.Println(conval.(string)) go logtailf.WatchLogFile(configData.ConfigValue, ctx) continue &#125; if oldval.ConfigValue != conval.(string) &#123; oldval.ConfigValue = conval.(string) oldval.ConfigCancel() ctx, cancel := context.WithCancel(context.Background()) oldval.ConfigCancel = cancel go logtailf.WatchLogFile(conval.(string), ctx) continue &#125;&#125; 对比新旧配置，如果路径取消，则停止监控其的协程，如果路径新增或修改，则启动新的协程。这样我们启动程序看到如下效果 编写测试文件，模拟日志写入和备份我们在writefile.go中实现日志写入和备份，这部分内容前几篇有讲解，我只是将原来实现的功能搬过来 1234567891011121314151617181920212223242526272829303132333435363738394041func writeLog(datapath string, wg *sync.WaitGroup) &#123; filew, err := os.OpenFile(datapath, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644) if err != nil &#123; fmt.Println(&quot;open file error &quot;, err.Error()) return &#125; defer func() &#123; wg.Done() &#125;() w := bufio.NewWriter(filew) for i := 0; i &lt; 20; i++ &#123; timeStr := time.Now().Format(&quot;2006-01-02 15:04:05&quot;) fmt.Fprintln(w, &quot;Hello current time is &quot;+timeStr) time.Sleep(time.Millisecond * 100) w.Flush() &#125; logBak := time.Now().Format(&quot;20060102150405&quot;) + &quot;.txt&quot; logBak = path.Join(path.Dir(datapath), logBak) filew.Close() err = os.Rename(datapath, logBak) if err != nil &#123; fmt.Println(&quot;Rename error &quot;, err.Error()) return &#125;&#125;func main() &#123; v := viper.New() configPaths, confres := logconfig.ReadConfig(v) if !confres &#123; fmt.Println(&quot;config read failed&quot;) return &#125; wg := &amp;sync.WaitGroup&#123;&#125; for _, confval := range configPaths.(map[string]interface&#123;&#125;) &#123; wg.Add(1) go writeLog(confval.(string), wg) &#125; wg.Wait()&#125; 根据配置文件启动多个协程，向日志文件中不断写入日志，写入20条后备份日志，我们启动日志收集程序和这个测试程序，可以看到日志不断被写入，日志收集程序不断打印日志新增的内容日志备份为不同的文件可以看到日志收集系统在日志不断写入时，可以健壮运行 热更新控制监控协程打开和关闭现在config.yaml文件中路径记录如下 1234configpath: logdir1: &quot;D:/golangwork/src/golang-/logcatchsys/logdir1/log.txt&quot; logdir2: &quot;D:/golangwork/src/golang-/logcatchsys/logdir2/log.txt&quot; logdir3: &quot;D:/golangwork/src/golang-/logcatchsys/logdir3/log.txt&quot; 我们启动日志收集程序，模拟热更新配置，将logdir3这条数据修改,配置变为如下 1234configpath: logdir1: &quot;D:/golangwork/src/golang-/logcatchsys/logdir1/log.txt&quot; logdir2: &quot;D:/golangwork/src/golang-/logcatchsys/logdir2/log.txt&quot; logdir4: &quot;D:/golangwork/src/golang-/logcatchsys/logdir4/log.txt&quot; 我们可以看到程序作出检测，并关闭了曾经监控logdir3的协程，并启动了新的协程监控logdir4，而其他的日志监控协程不受影响，正常运行。 源码下载地址https://github.com/secondtonone1/golang-/tree/master/logcatchsys我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（三)","date":"2019-12-02T06:38:26.000Z","path":"2019/12/02/golang22/","text":"前文中已经完成了文件的监控，kafka信息读写，今天主要完成配置文件的读写以及热更新。并且规划一下系统的整体结构，然后将之前的功能串起来形成一套完整的日志采集系统。 前情提要上一节我们完成了如下目标1 完成kafka消息读写2 借助tailf实现文件监控，并模拟测试实时写文件以及文件备份时功能无误。 本节目标1 编写系统结构，在主函数中加载配置2 管理配置文件，实现热更新 实现文件管理，支持热更新golang中vipper库提供了配置文件的读取和监控功能，我们可以监控配置文件从而实现热更新。先规划下日志采集系统的目录结构logcatchsys为项目根目录，其下logcatchsys文件夹中main.go为系统启动的主函数，该文件加载配置，根据配置启动协程，监控指定目录的日志文件，当配置更新时，main做热更新，如果路径从配置中删除，则中止对应的监控协程。如果有新的路径添加到配置文件，则启动协程监控，如果路径有修改，则中止原路径协程，启动新的协程监听修改后的路径。logconfig为配置存放的路径，logconfig.go主要负责配置的管理，包括监控。 1234567var onceLogConf sync.Oncetype ConfigData struct &#123; ConfigKey string ConfigValue string ConfigCancel context.CancelFunc&#125; 在logconfig.go中定义了once操作的变量onceLogConf，该变量保证监控配置的协程退出后只执行一次析构。ConfigData结构体存储了配置文件中路径的信息，ConfigKey表示路径名，ConfigValue表示路径值，ConfigCancel存储上下文的CancelFunc，因为一个路径对应一个日志文件，监控日志文件就要开启协程，我是通过context管理监控日志的协程的。在config.yaml中记录的路径信息如下: 12345configpath: logdir1: &quot;../logdir1/log.txt&quot; logdir2: &quot;../logdir2/log.txt&quot; logdir3: &quot;../logdir3/log.txt&quot; logdir5: &quot;../logdir3/log.txt&quot; logdir1对应ConfigKey../logdir1/log.txt对应ConfigValue接下来在logconfig.go中我实现了配置文件的加载 12345678910111213141516171819202122func ReadConfig(v *viper.Viper) (interface&#123;&#125;, bool) &#123; //设置读取的配置文件 v.SetConfigName(&quot;config&quot;) //添加读取的配置文件路径 _, filename, _, _ := runtime.Caller(0) fmt.Println(filename) fmt.Println(path.Dir(filename)) v.AddConfigPath(path.Dir(filename)) //设置配置文件类型 v.SetConfigType(&quot;yaml&quot;) if err := v.ReadInConfig(); err != nil &#123; fmt.Printf(&quot;err:%s\\n&quot;, err) return nil, false &#125; configPaths := v.Get(&quot;configpath&quot;) if configPaths == nil &#123; return nil, false &#125; return configPaths, true&#125; 以及配置文件的监听 1234567891011121314151617181920212223242526func WatchConfig(ctx context.Context, v *viper.Viper, pathChan chan interface&#123;&#125;) &#123; defer func() &#123; onceLogConf.Do(func() &#123; fmt.Println(&quot;watch config goroutine exit&quot;) if err := recover(); err != nil &#123; fmt.Println(&quot;watch config goroutine panic &quot;, err) &#125; close(pathChan) &#125;) &#125;() //设置监听回调函数 v.OnConfigChange(func(e fsnotify.Event) &#123; //fmt.Printf(&quot;config is change :%s \\n&quot;, e.String()) configPaths := v.Get(&quot;configpath&quot;) if configPaths == nil &#123; return &#125; pathChan &lt;- configPaths &#125;) //开始监听 v.WatchConfig() //信道不会主动关闭，可以主动调用cancel关闭 &lt;-ctx.Done()&#125; 当配置文件config.yaml有变动时，OnConfigChange传入的匿名函数会触发，从而将configpath节点的value传入chan中，这样main函数可以从外部获取最新的配置文件。ctx为上下文，当main函数执行上下文中止时，监控配置的协程会自动退出。 根据配置变动，实现热更新在main.go中,定义了mainOnce控制主协程资源析构，并且通过ConstructMgr全局函数构造configMgr这样的map记录最新的配置信息。 1234567891011121314var mainOnce sync.Oncevar configMgr map[string]*logconfig.ConfigDatafunc ConstructMgr(configPaths interface&#123;&#125;) &#123; configDatas := configPaths.(map[string]interface&#123;&#125;) for conkey, confval := range configDatas &#123; configData := new(logconfig.ConfigData) configData.ConfigKey = conkey configData.ConfigValue = confval.(string) _, cancel := context.WithCancel(context.Background()) configData.ConfigCancel = cancel configMgr[conkey] = configData &#125;&#125; 接下来实现主函数 1234567891011121314151617181920func main() &#123; v := viper.New() configPaths, confres := logconfig.ReadConfig(v) if configPaths == nil || !confres &#123; fmt.Println(&quot;read config failed&quot;) return &#125; configMgr = make(map[string]*logconfig.ConfigData) ConstructMgr(configPaths) ctx, cancel := context.WithCancel(context.Background()) pathChan := make(chan interface&#123;&#125;) go logconfig.WatchConfig(ctx, v, pathChan) defer func() &#123; mainOnce.Do(func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;main goroutine panic &quot;, err) // 这里的err其实就是panic传入的内容 &#125; cancel() &#125;) &#125;() 在主函数中读取配置，并且将配置的路径信息存储在configMgr中。接着启动了一个协程用来监控配置文件，并且我实现了主协程的资源回收。我们在main中继续添加接受监控协程的数据逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 for &#123; select &#123; case pathData, ok := &lt;-pathChan: if !ok &#123; return &#125; fmt.Println(&quot;main goroutine receive pathData&quot;) fmt.Println(pathData) pathDataNew := pathData.(map[string]interface&#123;&#125;) for oldkey, oldval := range configMgr &#123; _, ok := pathDataNew[oldkey] if ok &#123; continue &#125; oldval.ConfigCancel() delete(configMgr, oldkey) &#125; for conkey, conval := range pathDataNew &#123; oldval, ok := configMgr[conkey] if !ok &#123; configData := new(logconfig.ConfigData) configData.ConfigKey = conkey configData.ConfigValue = conval.(string) _, cancel := context.WithCancel(context.Background()) configData.ConfigCancel = cancel configMgr[conkey] = configData continue &#125; if oldval.ConfigValue != conval.(string) &#123; oldval.ConfigValue = conval.(string) oldval.ConfigCancel() _, cancel := context.WithCancel(context.Background()) oldval.ConfigCancel = cancel continue &#125; &#125; for mgrkey, mgrval := range configMgr &#123; fmt.Println(mgrkey) fmt.Println(mgrval) &#125; &#125; &#125;&#125; 主协程接受数据后对比新旧数据，将旧的配置中被删除的路径剔除，增加和修改新的路径。日志监控留给之后处理，这里打印下更新后的配置信息。整体运行下main函数，然后我们手动修改config.yaml，将logdir4修改为logdir5，可以看到如下信息证明我们的热更新处理逻辑没有问题。下一节基于现有的逻辑,添加日志文件的监控处理，启动多个协程管理日志文件。源码下载https://github.com/secondtonone1/golang-/tree/master/logcatchsys我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go项目实战：打造高并发日志采集系统（二）","date":"2019-11-27T08:55:16.000Z","path":"2019/11/27/golang21/","text":"日志统计系统的整体思路就是监控各个文件夹下的日志，实时获取日志写入内容并写入kafka队列，写入kafka队列可以在高并发时排队，而且达到了逻辑解耦合的目的。然后从kafka队列中读出数据，根据实际需求显示网页上或者控制台等。 前情提要上一节我们完成了如下目标1 配置kafka，并启动消息队列。2 编写代码向kafka录入消息，并且从kafka读取消息。 本节目标1 写代码从kafka中读取消息，保证kafka消息读写功能无误。2 借助tailf实现文件监控，并模拟测试事实写文件以及文件备份时功能无误。3 本系列文章开发语言使用Go 从kafka中读取消息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func main()&#123; fmt.Println(&quot;consumer begin...&quot;) config := sarama.NewConfig() config.Consumer.Return.Errors = true wg :=sync.WaitGroup&#123;&#125; //创建消费者 consumer, err := sarama.NewConsumer([]string&#123;&quot;localhost:9092&quot;&#125;,config) if err != nil &#123; fmt.Println(&quot;consumer create failed, error is &quot;, err.Error()) return &#125; defer consumer.Close() //Partitions(topic):该方法返回了该topic的所有分区id partitionList, err := consumer.Partitions(&quot;test&quot;) if err != nil &#123; fmt.Println(&quot;get consumer partitions failed&quot;) fmt.Println(&quot;error is &quot;, err.Error()) return &#125; for partition := range partitionList &#123; //ConsumePartition方法根据主题， //分区和给定的偏移量创建创建了相应的分区消费者 //如果该分区消费者已经消费了该信息将会返回error //OffsetNewest消费最新数据 pc, err := consumer.ConsumePartition(&quot;test&quot;, int32(partition), sarama.OffsetNewest) if err != nil &#123; panic(err) &#125; //异步关闭，保证数据落盘 defer pc.AsyncClose() wg.Add(1) go func(sarama.PartitionConsumer) &#123; defer wg.Done() //Messages()该方法返回一个消费消息类型的只读通道，由代理产生 for msg := range pc.Messages() &#123; fmt.Printf(&quot;%s---Partition:%d, Offset:%d, Key:%s, Value:%s\\n&quot;, msg.Topic,msg.Partition, msg.Offset, string(msg.Key), string(msg.Value)) &#125; &#125;(pc) &#125; wg.Wait() consumer.Close() &#125; 这样我们启动zookeeper和kafka后，分别运行前文实现的向kafka中写入数据的代码，以及现在的从kafka中消费的代码，看到如下效果 实现文件监控实现文件监控，主要是在文件中有内容写入时，程序可以及时获取写入的内容，类似于Linux命令中的tailf -f 某个文件的功能。golang 中提供了tail库，我们借助这个库完成指定文件的监控，我的文件组织如下logdir文件夹下的log.txt记录的是不断增加的日志文件tailf文件夹下logtailf.go实现log.txt监控功能。writefile文件夹下writefile.go实现的是向log.txt文件写日志并备份的功能。 1234567891011121314151617181920212223242526272829303132333435func main() &#123; logrelative := `../logdir/log.txt` _, filename, _, _ := runtime.Caller(0) fmt.Println(filename) datapath := path.Join(path.Dir(filename), logrelative) fmt.Println(datapath) tailFile, err := tail.TailFile(datapath, tail.Config&#123; //文件被移除或被打包，需要重新打开 ReOpen: true, //实时跟踪 Follow: true, //如果程序出现异常，保存上次读取的位置，避免重新读取 Location: &amp;tail.SeekInfo&#123;Offset: 0, Whence: 2&#125;, //支持文件不存在 MustExist: false, Poll: true, &#125;) if err != nil &#123; fmt.Println(&quot;tail file err:&quot;, err) return &#125; for true &#123; msg, ok := &lt;-tailFile.Lines if !ok &#123; fmt.Printf(&quot;tail file close reopen, filename: %s\\n&quot;, tailFile.Filename) time.Sleep(100 * time.Millisecond) continue &#125; //fmt.Println(&quot;msg:&quot;, msg) //只打印text fmt.Println(&quot;msg:&quot;, msg.Text) &#125;&#125; 为了测试监控的功能。我们实现向log.txt中每隔0.1s写入一行”Hello+时间戳”的日志。当写入20条内容后我们将log.txt备份重命名。然后创建新的log.txt继续写入。在writefile.go实现一个函数定时写入，并且备份功能 1234567891011121314151617181920212223func writeLog(datapath string) &#123; filew, err := os.OpenFile(datapath, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644) if err != nil &#123; fmt.Println(&quot;open file error &quot;, err.Error()) return &#125; w := bufio.NewWriter(filew) for i := 0; i &lt; 20; i++ &#123; timeStr := time.Now().Format(&quot;2006-01-02 15:04:05&quot;) fmt.Fprintln(w, &quot;Hello current time is &quot;+timeStr) time.Sleep(time.Millisecond * 100) w.Flush() &#125; logBak := time.Now().Format(&quot;20060102150405&quot;) + &quot;.txt&quot; logBak = path.Join(path.Dir(datapath), logBak) filew.Close() err = os.Rename(datapath, logBak) if err != nil &#123; fmt.Println(&quot;Rename error &quot;, err.Error()) return &#125;&#125; 然后我们实现main函数，调用三次writeLog，这样会产生三个备份文件 123456789func main() &#123; logrelative := `../logdir/log.txt` _, filename, _, _ := runtime.Caller(0) fmt.Println(filename) datapath := path.Join(path.Dir(filename), logrelative) for i := 0; i &lt; 3; i++ &#123; writeLog(datapath) &#125;&#125; 我们分别启动文件监控和文件写入程序，效果如下可以看到,当log.txt有内容写入时，logtailf.go实现了动态监控，而且当文件备份时，logtailf.go提示了文件被重命名备份。最终我们看到产生三个备份文件 总结目前我们已经完成了kafka消息读写，文件监控，动态写入和备份等功能，接下来我们实现项目的配置化和统筹代码。源码下载https://github.com/secondtonone1/golang-感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"大家都一样，用命换钱","date":"2019-11-25T08:01:39.000Z","path":"2019/11/25/news2/","text":"最近闹得沸沸扬扬的网易员工被强退事件，说点自己的看法。 事件始末一个网易前员工，因为被检测出扩张型心肌病被网易提出单方面辞退，辞退原因是其绩效审核为D级，这位员工否认绩效审核结果，公司仍坚持辞退该员工，该员工要求索赔之后受到公司各种威胁以至于家人也受到牵连。具体事件在此处 https://mp.weixin.qq.com/s/FW7uR5t6UMMxgkCcAvk-MA 网易道歉网易于11月25日及时发布道歉信 我们都卑微到尘埃我看过该员工的公众号几篇文章之后，发现他对网易公司态度由自豪，乐观到恐惧，厌恶。这是一个很真实的状态，而且员工离职索要赔偿也是合理要求，该员工曾认为为公司努力加班才是不虚度光阴，其离职前几个月绩效一直很好。这么一个优秀上进的人，在其患病期间绩效审核为D了。该员工否认了审核结果，还期望着能够继续工作，随着公司强制辞退的推进，已经没有商量的余地。从网易道歉信中，可以看出网易仅仅否认了该员工对绩效审核的看法，让人细思极恐，也就是该员工其他所述事实得到了默认。其实我们周围的人被强制辞退不给补偿的比比皆是，好多人也只能忍气吞声。这次事件闹大一方面该员工身患绝症引起关注，另一方面又是名企变着花样的拖延补偿，甚至威胁其家人。我们作为底层的劳动力，卑微到骨子里，时常成为上层领导晋升和提高绩效的工具。我之前是一名游戏开发程序员，游戏这个领域相对其他领域更艰辛一些，我也经历过类似该员工强制加班的境遇，在游戏公司加班是家常便饭，给的补助也不多，好多公司不喜欢给补助，美其名曰可以调休，我认识的一个游戏开发的朋友，加班累计的调休已经四百多天，可他每次申请调休公司都以各种理由拒绝，印象最深刻的就是某公司要求我们每天晚上12点查看服务器日志，本来睡着的我听到12点的闹铃后爬起来去查看远端日志，就这样坚持了半年多，身体吃不消就提了离职，以至于离职后的三个月我把手机设置为静音，因为我听到闹铃就恐惧和反感。在北上广这些一线城市，互联网和游戏领域缺口极大，给出的薪水比其他领域高出很多，可是进入这个圈子大家都知道，不过是用时间和生命换点钱，平均下来性价比并不高，在IT领域劳动力很廉价，因为你不去，总有人愿意为高薪迎难而上。我在Google的朋友说他们公司并不鼓励加班，因为好多技术难题并不是靠加班解决的，公司更提倡时间的高效利用。我经历的一些公司，总是把写好的产品推倒重做，员工加班无非就是为公司高层的错误指挥买账罢了，好多公司鼓吹狼性文化，我想想觉得挺可笑的，资本剥削喊得口号逼格都这么高。 经济学解释互联网现状为什么中国的互联网公司普遍都鼓励员工承受高压力，高加班呢？我之前也不懂，直到我读了一本书&lt;从0到1&gt;，书中讲述了两种创业模式，一种是从0到1，即技术创新，从无到有。一种是从1到N，即复制已有的成功案例。中国90%IT公司都是从1到N的复制，高端点的BAT复制国外的产品，低端点的中小公司复制国内成功的。而国外鼓励的是从0到1，无论是Google还是FaceBook，亦或是当年的微软Windows这些都是从无到有的突破。有人会说BAT也很成功啊，马爸爸不是全国偶像吗？我想说的是那是他们的成功，对我们来说更关注这两种模式会带来什么。&lt;从0到1&gt;书中讲述了这两种模式带来的不同结果，从0到1会导致垄断，技术革新和社会进步，是垂直进步。而从1打N是高频复制，胡导致竞争，压榨剥削，是水平进步。而相比竞争，垄断能获取更高的利润，也能让公司有更多的资本全方面的发展和关注员工，而竞争形态的公司需要节约开销，投入更多的劳动力去竞争市场，毕竟没有垄断的技术。Google的核心技术为搜索引擎，公司收入的80%来源于广告和搜索服务。而书中描述同样作为广告收入，微软获利仅为Google的8%，为了掩盖垄断的真相，Google会全方向发展，以至于有了后来的VR技术，Android手机，Golang微服务等等。有人会问BAT不是垄断吗？我告诉你不是的，只是你看到的更像是垄断罢了，他们是通过水平进步不断扩大规模，与其他企业竞争变大的。只要有竞争就要节约开销，抢占资本，剥削人力。现在看看网易的做法其实是符合经济学观点的，毕竟要和同类游戏公司抢占市场。垄断，需要的是对技术的改进和创新，因为只有你在某个领域拥有独占技术才会没有竞争，这样你的利润是独享的。中国人不喜欢造轮子，更喜欢做产品。Android系统出来了，我们就基于国外的系统做App就好了，如果告我侵权，我就再做系统，反正现在开源，大家都用嘛。游戏引擎也是国外开发较多，网络库什么的基础架构都是国外研究深入，国人只管用这一套成熟的框架迭代开发就好了，某大厂说三个月我就给你搞出个手游信不信？我从事Golang开发时发现底层框架和语言设计非常优秀，做微服务的时候也只能去看国外的资料，这类基础建设正是我们国人欠缺的，在追逐利益的市场里，搞技术创新或许是傻X才做的事，可往往被掩盖的真相就是这么讽刺，只有通过技术创新和垄断才能促进社会进步，达到利益最大化。","categories":[{"name":"生活感悟","slug":"news","permalink":"http://www.limerence2017.com/categories/news/"}],"tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://www.limerence2017.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"}]},{"title":"Go项目实战：打造高并发日志采集系统（一）","date":"2019-11-21T03:33:52.000Z","path":"2019/11/21/golang20/","text":"项目结构本系列文章意在记录如何搭建一个高可用的日志采集系统，实际项目中会有多个日志文件分布在服务器各个文件夹，这些日志记录了不同的功能。随着业务的增多，日志文件也再增多，企业中常常需要实现一个独立的日志采集系统，实时采集各个日志信息，并记录和输出到控制台或网页上，方便监控和查询。本文日志采集系统架构如下 日志采集系统监控各个日志文件，当日志文件有日志录入时，日志采集系统实时获取日志内容并下入kafka队列中，之后可以实现Web端从kafaka取出信息，并前端显示。也可以将kafka的信息控制台输出，这个主要是看具体需求。本系列文章主要讲述如何搭建kafaka服务，编写高并发日志采集系统，稳定高效录入信息，以及从kafka中读取采集的日志。 本节目标1 配置kafka，并启动消息队列。2 编写代码向kafka录入消息，并且从kafka读取消息。 kafka简介和搭建Kafka是一种高吞吐量的分布式发布订阅消息系统，由Java编写，内部使用了zookeeper(分布式应用程序协调服务)，所以安装Kafka之前需要先安装jdk和zookeeper。 JDK安装去官网https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载jdk，按步骤安装。之后配置环境变量即可。 Zookeeper安装这里说下windows安装流程，linux类似。从网址http://zookeeper.apache.org/releases.html下载zookeeper，之后解压即可使用。我在windows创建了一个文件夹D:\\kafkazookeeper，将zookeeper解压到该文件夹。打开D:\\kafkazookeeper\\zookeeper-3.4.14\\conf，把zoo_sample.cfg复制一份命名为zoo.cfg，从文本编辑器里打开zoo.cfg修改如下内容 12dataDir=D:\\\\kafkazookeeper\\\\zookeeper-3.4.14\\\\datadataLogDir=D:\\\\kafkazookeeper\\\\zookeeper-3.4.14\\\\log 目录根据你个人设置就行了。接下来添加如下环境变量 12ZOOKEEPER_HOME: D:\\kafkazookeeper\\zookeeper-3.4.14Path: 在现有的值后面添加 &quot;;%ZOOKEEPER_HOME%\\bin; ZOOKEEPER_HOME值就是你的kafka安装目录。接下来进入D:\\kafkazookeeper\\zookeeper-3.4.14\\bin启动zkServer.cmd看到zookeeper服务跑起来了，默认端口为2181，不要关闭。 kafka安装下载地址http://kafka.apache.org/downloads.html将其解压到我自己的D:\\kafkazookeeper目录下，打开D:\\kafkazookeeper\\kafka_2.12-2.2.0\\config修改log.dirs，设置为 1log.dirs=D:\\\\kafkazookeeper\\\\kafka_2.12-2.2.0\\\\logs 在kafka目录里执行如下命令,启动kafka 1.\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties 测试kafka创建topics在kafka目录里执行如下命令 1.\\bin\\windows\\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 这样我们创建了一个主题，这个主题相当于一个标签，用于消息读写。 打开一个Producer同样在kafka目录下执行 1.\\bin\\windows\\kafka-console-producer.bat --broker-list localhost:9092 --topic test 这样我们基于test主题启动了一个生产者 打开一个Consumer同样在kafka目录下执行 1.\\bin\\windows\\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning 我们在生产者窗口写一些消息注入hello consumer，消费者窗口会取出消息并显示 hello consumer 实现代码向kafka写入消息1234567891011121314151617181920212223242526272829303132333435363738394041func main() &#123; config := sarama.NewConfig() // 等待服务器所有副本都保存成功后的响应 config.Producer.RequiredAcks = sarama.WaitForAll // 随机的分区类型：返回一个分区器，该分区器每次选择一个随机分区 config.Producer.Partitioner = sarama.NewRandomPartitioner // 是否等待成功和失败后的响应 config.Producer.Return.Successes = true // 使用给定代理地址和配置创建一个同步生产者 producer, err := sarama.NewSyncProducer([]string&#123;&quot;localhost:9092&quot;&#125;, config) if err != nil &#123; panic(err) &#125; defer producer.Close() //构建发送的消息， msg := &amp;sarama.ProducerMessage&#123; //Topic: &quot;test&quot;,//包含了消息的主题 Partition: int32(10), // Key: sarama.StringEncoder(&quot;key&quot;), // &#125; inputReader := bufio.NewReader(os.Stdin) for&#123; value, _ , err := inputReader.ReadLine() if err != nil &#123; fmt.Printf(&quot;error:&quot;, err.Error()) return &#125; msgType , _, err := inputReader.ReadLine() msg.Topic = string(msgType) fmt.Println(&quot;topic is : &quot;,msg.Topic) fmt.Println(&quot;value is : &quot;,string(value)) msg.Value = sarama.ByteEncoder(value) partition, offset, err := producer.SendMessage(msg) if err != nil &#123; fmt.Println(&quot;Send message Fail&quot;) fmt.Println(err.Error()) &#125; fmt.Printf(&quot;Partition = %d, offset=%d\\n&quot;, partition, offset) &#125;&#125; 上述代码基于本地端口9092创建了生产者，然后构造了消息的分区大小以及Key值，接下来循环读取终端录入信息，第一行为value，第二行为topic，然后将消息发送到kafka，并且打印存储的分区和位移。我们运行我们的程序，录入消息，可以看到消息发送到kafka后被消费者获取。下一篇，我们完善消费者程序，并且实现文件监控和读取。","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang实现生产者消费者模型","date":"2019-11-08T07:57:04.000Z","path":"2019/11/08/golang18/","text":"生产者消费者模型分析操作系统中的经典模型，由若干个消费者和生产者，消费者消耗系统资源，生产者创造系统资源，资源的数量要保持在一个合理范围(小于数量上限，大约0)。而消费者和生产者是通过并发或并行方式访问系统资源的，需要保持资源的原子操作。其实就是生产者线程增加资源数，如果资源数大于最大值则生产者线程挂起等待，当收到消费者线程的通知后继续生产。消费者线程减少资源数，如果资源数为0，则消费者线程挂起，等待生产者通知后继续生产。将该模型提炼成伪代码如下: 12345678910111213141516171819func consume()&#123; Lock() if count &lt;= 0 挂起等待(解锁，并等待资源数大于0) 收到系统通知资源数大约0，抢占加锁 count-- 如果当前资源数由最大值变少则通知生产者生产 ULock()&#125;func produce()&#123; Lock() if count &gt;= 最大值 挂起等待(解锁，并等待资源数小于最大值) 收到系统通知资源小于最大值，抢占加锁 count++ 如果当前资源数由最小值0增加则通知消费者可以消耗 ULock()&#125; consume()消耗资源，produce()生产资源，之前实现过C版本的该模型http://www.limerence2017.com/2017/08/08/pthreadwait/C方式实现的是抢占式的，线程切换开销较大。下面给出golang协程方式的实现。 先实现资源的互斥访问对于资源的互斥访问，其他语言提供了线程锁，golang也有线程锁，当然可以通过channel实现，这里我给出加锁访问资源的方式，因为channel内部也是通过加锁实现的，而且我习惯用channel做协程通信，对于共享资源的控制习惯用锁来控制，也比较高效。 先定义几个全局变量 123456789const ( PRODUCER_MAX = 5 CONSUMER_MAX = 2 PRODUCT_MAX = 20)var productcount = 0var lock sync.Mutexvar wgrp sync.WaitGroup productcount为资源的数量，需要互斥处理。wgrp主要是主协程用来等待其他协程退出。PRODUCT_MAX 表示资源的上限，达到该值，生产者停止生产。PRODUCER_MAX 表示生产者协程数量CONSUMER_MAX 表示消费者协程数量我们实现生产者代码 1234567891011121314151617181920212223//生产者func Produce(index int, wgrp *sync.WaitGroup) &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;Producer &quot;, index, &quot; panic&quot;) &#125; wgrp.Done() &#125;() for &#123; time.Sleep(time.Second) lock.Lock() fmt.Println(&quot;Producer &quot;, index, &quot; begin produce&quot;) if productcount &gt;= PRODUCT_MAX &#123; fmt.Println(&quot;Products are full&quot;) lock.Unlock() return &#125; productcount++ fmt.Println(&quot;Products count is &quot;, productcount) lock.Unlock() &#125;&#125; defer 的匿名函数主要是用来回收资源，不是重点for循环内部生产者循环增加资源，为保证productcount的互斥访问，我们加了锁。当productcount达到上限后解锁并返回，否则就增加数量，然后释放锁。同样的道理我们实现了消费者 12345678910111213141516171819202122func Consume(index int, wgrp *sync.WaitGroup) &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;Consumer &quot;, index, &quot; panic&quot;) &#125; wgrp.Done() &#125;() for &#123; time.Sleep(time.Second) lock.Lock() fmt.Println(&quot;Consumer &quot;, index, &quot; begin consume&quot;) if productcount &lt;= 0 &#123; fmt.Println(&quot;Products are empty&quot;) lock.Unlock() return &#125; productcount-- fmt.Println(&quot;Products count is &quot;, productcount) lock.Unlock() &#125;&#125; 消费者加锁减少productcount数量，当productcount为0，则解锁并返回。然后我们实现主函数 1234567891011func main() &#123; wgrp.Add(PRODUCER_MAX + CONSUMER_MAX) for i := 0; i &lt; PRODUCER_MAX; i++ &#123; go Produce(i, &amp;wgrp) &#125; for i := 0; i &lt; CONSUMER_MAX; i++ &#123; go Consume(i, &amp;wgrp) &#125; wgrp.Wait()&#125; 我们创建了若干生产者和消费者，主协程通过wgrp等待其他协程退出。我们看下效果可以看出并发的访问实现了，但是并没有实现条件等待和控制，比如当数量上限后其他生产者也可以访问。接下来我们实现的是当数量上限是生产者挂起等待，直到消费者通知其生产。数量为0时消费者挂起，等待生产者激活。也就是条件等待和异步协同。 实现条件等待和异步协同协程之间的同步和等待可以使用channel，我们增加了两个全局非缓冲channel 12var produce_wait chan struct&#123;&#125;var consume_wait chan struct&#123;&#125; produce_wait 用来控制生产者阻塞等待consume_wait 用来控制消费者阻塞等待 我们修改下生产者 1234567891011121314151617181920212223242526272829303132//生产者func Produce(index int, wgrp *sync.WaitGroup) &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;Producer &quot;, index, &quot; panic&quot;) &#125; wgrp.Done() &#125;() for &#123; time.Sleep(time.Second) lock.Lock() fmt.Println(&quot;Producer &quot;, index, &quot; begin produce&quot;) if productcount &gt;= PRODUCT_MAX &#123; fmt.Println(&quot;Products are full&quot;) lock.Unlock() //产品满了，生产者wait &lt;-produce_wait continue &#125; lastcount := productcount productcount++ fmt.Println(&quot;Products count is &quot;, productcount) lock.Unlock() //产品数由0到1，激活消费者 if lastcount == 0 &#123; var consumActive struct&#123;&#125; consume_wait &lt;- consumActive &#125; &#125;&#125; 在18行增加了&lt;-produce_wait，这样生产者会挂起，等待消费者向produce_wait写入，从而得到激活。另外26行增加了判断，当资源数由0到1时，激活消费者。同样消费者实现类似 1234567891011121314151617181920212223242526272829303132//消费者func Consume(index int, wgrp *sync.WaitGroup) &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;Consumer &quot;, index, &quot; panic&quot;) &#125; wgrp.Done() &#125;() for &#123; time.Sleep(time.Second) lock.Lock() fmt.Println(&quot;Consumer &quot;, index, &quot; begin consume&quot;) if productcount &lt;= 0 &#123; fmt.Println(&quot;Products are empty&quot;) lock.Unlock() //产品空了，消费者等待 &lt;-consume_wait continue &#125; lastcount := productcount productcount-- fmt.Println(&quot;Products count is &quot;, productcount) lock.Unlock() //产品数由PRODUCT_MAX变少，激活生产者 if lastcount == PRODUCT_MAX &#123; var productActive struct&#123;&#125; produce_wait &lt;- productActive &#125; &#125;&#125; 这里我们要有并发的思想，考虑这样一个场景，当前产品数达到上限，Produce运行完16行，刚刚解锁，还没来得及运行18行挂起，Consume抢占到锁正常运行消耗资源，运行到28行，优先对produce_wait写入，此时该消费者挂起，生产者收到信号后，他们都会继续执行。我们完善下main函数 12345678910111213func main() &#123; wgrp.Add(PRODUCER_MAX + CONSUMER_MAX) produce_wait = make(chan struct&#123;&#125;) consume_wait = make(chan struct&#123;&#125;) for i := 0; i &lt; CONSUMER_MAX; i++ &#123; go Consume(i, &amp;wgrp) &#125; for i := 0; i &lt; PRODUCER_MAX; i++ &#123; go Produce(i, &amp;wgrp) &#125; wgrp.Wait()&#125; 执行golang的锁检测并运行go run -race main.go可以看到是可以正常运行的我们继续用并发思想分析，我们实现了基本功能，但是有个瑕疵，我们的生产者协程较多，比如生产者协程1判断生产上限在18行挂起，其他生产者如果抢占锁后进入生产判断数量上限，也会在18行挂起，由于我们的produce_wait是非缓冲的，那么当消费者来激活时，只有一个生产者被激活，另一个一直挂着，等到消费者激活才能继续生产。这么做在一定程度限制了生产者，我们可以通过引入两个bool变量通知其他协程睡眠，避免此问题。 增加bool变量实现休眠我们可以引入两个bool变量 12var stopProduce = falsevar stopConsume = false 当资源达到上限或下限时，挂起单个协程，通过这两个变量休眠同类协程。由于golang没有提供给我们休眠的api，我们就让同类型的协程sleep一会，这样也是可以提高模型并发的。改进的生产者 123456789101112131415161718192021222324252627282930313233343536373839//生产者func Produce(index int, wgrp *sync.WaitGroup) &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(&quot;Producer &quot;, index, &quot; panic&quot;) &#125; wgrp.Done() &#125;() for &#123; time.Sleep(time.Second) lock.Lock() if stopProduce &#123; fmt.Println(&quot;Producer &quot;, index, &quot; stop produce, sleep 5 seconds&quot;) lock.Unlock() time.Sleep(time.Second * 5) continue &#125; fmt.Println(&quot;Producer &quot;, index, &quot; begin produce&quot;) if productcount &gt;= PRODUCT_MAX &#123; fmt.Println(&quot;Products are full&quot;) stopProduce = true lock.Unlock() //产品满了，生产者wait &lt;-produce_wait lock.Lock() stopProduce = false lock.Unlock() continue &#125; productcount++ fmt.Println(&quot;Products count is &quot;, productcount) if stopConsume &#123; var consumActive struct&#123;&#125; consume_wait &lt;- consumActive &#125; lock.Unlock() &#125;&#125; 我们在22行设置了stopProduce为true，然后在25行挂起了该协程，其他生产者协程发现stopProduce为true，则睡眠5秒。此办法保证了资源数临界值后仅有单个协程挂起，不会影响到其他同类协程。同样实现消费者，这里不做赘述。考虑这样一个场景，如果在生产者设置bool解锁后，其他消费者抢占锁后为了激活生产者，优先写入信道produce_wait，此时生产者还没有从produce_wait读取，也不会有问题，毕竟生产者迟早要读取。接下来我们测试下可以看到当生产者1生产数上限后，其他生产者会进入休眠。当消费者激活后，生产者继续生产，其他生产者休眠后同样可以生产。提高了并发效率。 源码下载完整版源码地址https://github.com/secondtonone1/golang-/tree/master/producerconsumer 感谢关注公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang channel详解和协程优雅退出","date":"2019-11-08T07:57:04.000Z","path":"2019/11/08/golang19/","text":"非缓冲chan，读写对称非缓冲channel,要求一端读取，一端写入。channel大小为零，所以读写操作一定要匹配。 123456789func main() &#123; nochan := make(chan int) go func(ch chan int) &#123; data := &lt;-ch fmt.Println(&quot;receive data &quot;, data) &#125;(nochan) nochan &lt;- 5 fmt.Println(&quot;send data &quot;, 5)&#125; 我们启动了一个协程从channel中读取数据，在主协程中写入，程序的运行流程是主协程优先启动，运行到nochan&lt;-5写入是阻塞，然后启动协程读取，从而完成协程间通信。程序输出 12receive data 5send data 5 如果将启动协程的代码放在nochan&lt;-5下边，这样会造成主协程阻塞，无法启动协程，一直挂起。 123456789func main() &#123; nochan := make(chan int) nochan &lt;- 5 fmt.Println(&quot;send data &quot;, 5) go func(ch chan int) &#123; data := &lt;-ch fmt.Println(&quot;receive data &quot;, data) &#125;(nochan) &#125; 上述代码在运行时golang会直接panic，日志输出dead lock警告。我们可以通过go run -race 选项检测并运行，是可以看到主协程一直阻塞，子协程无法启动的。 WaitGroup 待时而动1234567891011121314151617func main() &#123; nochan := make(chan int) waiter := &amp;sync.WaitGroup&#123;&#125; waiter.Add(2) go func(ch chan int, wt *sync.WaitGroup) &#123; data := &lt;-ch fmt.Println(&quot;receive data &quot;, data) wt.Done() &#125;(nochan, waiter) go func(ch chan int, wt *sync.WaitGroup) &#123; ch &lt;- 5 fmt.Println(&quot;send data &quot;, 5) wt.Done() &#125;(nochan, waiter) waiter.Wait()&#125; 通过waitgroup管理两个协程，主协程等待两个子协程退出。 12receive data 5send data 5 range 自动读取使用range可以自动的从channel中读取，当channel被关闭时，for循环退出,否则一直挂起 123456789101112131415161718func main() &#123; catchan := make(chan int, 2) go func(ch chan int) &#123; for i := 0; i &lt; 2; i++ &#123; ch &lt;- i fmt.Println(&quot;send data is &quot;, i) &#125; //不关闭close，主协程将无法range退出 close(ch) fmt.Println(&quot;goroutine1 exited&quot;) &#125;(catchan) for data := range catchan &#123; fmt.Println(&quot;receive data is &quot;, data) &#125; fmt.Println(&quot;main exited&quot;)&#125; 输出如下 123456receive data is 0send data is 0send data is 1goroutine1 exitedreceive data is 1main exited 如果不写close(ch)，主协程将一直挂起，编译会出现死锁panic。可以通过go run -race 选项检查看到主协程一直挂起。 缓冲channel, 先进先出非缓冲channel内部其实是一个加锁的队列，先进先出。先写入的数据优先读出来。 12345678910111213func main() &#123; catchan := make(chan int, 2) go func(ch chan int) &#123; for i := 0; i &lt; 2; i++ &#123; ch &lt;- i fmt.Println(&quot;send data is &quot;, i) &#125; &#125;(catchan) for i := 0; i &lt; 2; i++ &#123; data := &lt;-catchan fmt.Println(&quot;receive data is &quot;, data) &#125;&#125; 输出如下 1234send data is 0send data is 1receive data is 0receive data is 1 主协程从catchan中读取数据，子协程先catchan中写数据。主协程运行到读取位置先阻塞，子协程启动后向catchan中写数据后，主协程继续读取。如果将主协程的for循环卸载go启动子协程之前，会造成编译警告死锁，当然可以通过go run -race 查看到主协程一直挂起。 读取关闭的channel从关闭的channel中读取数据，优先读出其中没有取出的数据，然后读出存储类型的空置。循环读取关闭的channel不会阻塞，会一直读取空值。可以通过读取结果的bool值判断该channel是否关闭。 123456789101112131415161718func main() &#123; nochan := make(chan int) go func(ch chan int) &#123; ch &lt;- 100 fmt.Println(&quot;send data&quot;, 100) close(ch) fmt.Println(&quot;goroutine exit&quot;) &#125;(nochan) data := &lt;-nochan fmt.Println(&quot;receive data is &quot;, data) //从关闭的 data, ok := &lt;-nochan if !ok &#123; fmt.Println(&quot;receive close chan&quot;) fmt.Println(&quot;receive data is &quot;, data) &#125; fmt.Println(&quot;main exited&quot;)&#125; 输出如下 123456receive data is 100send data 100goroutine exitreceive close chanreceive data is 0main exited 主协程运行到data := &lt;- nochan阻塞，子协程启动后向ch中写入数据，并关闭ch,此时主协程继续执行，取出一个数据后，再次取出为空值，并且ok为false表示ch已经被关闭。 切忌重复关闭channel重复关闭channel会导致panic 12345678910111213141516func main() &#123; nochan := make(chan int) go func(ch chan int) &#123; close(ch) fmt.Println(&quot;goroutine exit&quot;) &#125;(nochan) data, ok := &lt;-nochan if !ok &#123; fmt.Println(&quot;receive close chan&quot;) fmt.Println(&quot;receive data is &quot;, data) &#125; //二次关闭 close(nochan) fmt.Println(&quot;main exited&quot;)&#125; 输出如下 1234goroutine exitreceive close chanreceive data is 0panic: close of closed channel 子协程退出后，主协程读取到退出信息，主协程再次关闭chan导致主协程崩溃。 切忌向关闭的channel写数据向关闭的channel写数据会导致panic 12345678910111213141516171819202122func main() &#123; nochan := make(chan int) go func(ch chan int) &#123; close(ch) fmt.Println(&quot;goroutine1 exit&quot;) &#125;(nochan) data, ok := &lt;-nochan if !ok &#123; fmt.Println(&quot;receive close chan&quot;) fmt.Println(&quot;receive data is &quot;, data) &#125; go func(ch chan int) &#123; &lt;-ch fmt.Println(&quot;goroutine2 exit&quot;) &#125;(nochan) //向关闭的channel中写数据 nochan &lt;- 200 fmt.Println(&quot;main exited&quot;)&#125; 主线程运行到nochan读取数据阻塞，此时子协程1关闭，主协程继续执行获知nochan被关闭，然后启动子协程2，继续运行nochan&lt;-200，此时nochan已被关闭，导致panic，效果如下 12345receive close chanreceive data is 0goroutine1 exitgoroutine2 exitpanic: send on closed channel 切忌关闭nil的channel关闭nil值的channel会导致panic 12345678910111213141516func main() &#123; var nochan chan int = nil go func(ch chan int) &#123; //关闭nil channel会panic close(ch) fmt.Println(&quot;goroutine exit&quot;) &#125;(nochan) //从nil channel中读取会阻塞 data, ok := &lt;-nochan if !ok &#123; fmt.Println(&quot;receive close chan&quot;) fmt.Println(&quot;receive data is &quot;, data) &#125; fmt.Println(&quot;main exited&quot;)&#125; 主协程定义了一个nil值的nochan，并未开辟空间。运行至data, ok := &lt;-nochan 阻塞，此时启动子协程，关闭nochan，导致panic效果如下 1panic: close of nil channel 读或写nil的channel都会阻塞向nil的channel写数据，或者读取nil的channel也会导致阻塞。 12345678910111213141516func main() &#123; var nochan chan int = nil go func(ch chan int) &#123; fmt.Println(&quot;goroutine begin receive data&quot;) data, ok := &lt;-nochan if !ok &#123; fmt.Println(&quot;receive close chan&quot;) &#125; fmt.Println(&quot;receive data is &quot;, data) fmt.Println(&quot;goroutine exit&quot;) &#125;(nochan) fmt.Println(&quot;main begin send data&quot;) //向nil channel中写数据会阻塞 nochan &lt;- 100 fmt.Println(&quot;main exited&quot;)&#125; 如果直接编译系统会判断死锁panic，我们用go run -race main.go死锁检测，并运行，看到主协程一直挂起，子协程也一直挂起。结果如下 12goroutine begin receive datamain begin send data 主协程和子协程都阻塞了，一直挂起。 select 多路复用，大巧不工select 内部可以写多个协程读写，通过case完成多路复用，其结构如下 12345678select &#123; case ch &lt;- 100: ... case &lt;- ch2: ... dafault: ...&#125; 如果有多个case满足条件，则select随机选择一个执行。否则进入dafault执行。我们可以利用上面的九种原理配合select创造出各种并发场景。 总结1 当我们不使用一个channel时将其置为nil，这样select就不会检测它了。2 当多个子协程想获取主协程退出通知时，可以从同一个chan中读取，如果主协程退出则关闭这个chan，那么所有从chan读取的子协程就会获得退出消息。从而实现广播。3 为保证协程优雅退出，关闭channel的操作尽量放在对channel执行写操作的协程中。 并发实战假设有这样的需求：1 主协程启动两个协程，协程1负责发送数据给协程2，协程2负责接收并累加获得的数据。2 主协程等待两个子协程退出，当主协程意外退出时通知两个子协程退出。3 当发送协程崩溃和主动退出时通知接收协程也要退出，然后主协程退出4 当接收协程崩溃或主动退出时通知发送协程退出，然后主协程退出。5 无论三个协程主动退出还是panic，都要保证所有资源手动回收。下面我们用上面总结的十招完成这个需求 12345678datachan := make(chan int)groutineclose := make(chan struct&#123;&#125;)mainclose := make(chan struct&#123;&#125;)var onceclose sync.Oncevar readclose sync.Oncevar sendclose sync.Oncevar waitgroup sync.WaitGroupwaitgroup.Add(2) datachan: 用来装载发送协程给接收协程的数据groutineclose: 用于发送协程和接收协程之间关闭通知onceclose: 保证datachan一次关闭。readclose: 保证接收协程资源一次回收。sendclose: 保证发送协程资源一次回收。waitgroup: 主协程管理两个子协程。接下来我们实现发送协程 12345678910111213141516171819202122232425262728go func(datachan chan int, gclose chan struct&#123;&#125;, mclose chan struct&#123;&#125;, group *sync.WaitGroup) &#123; defer func() &#123; onceclose.Do(func() &#123; close(gclose) &#125;) sendclose.Do(func() &#123; close(datachan) fmt.Println(&quot;send goroutine closed !&quot;) group.Done() &#125;) &#125;() for i := 0; i &lt; 100; i++ &#123; select &#123; case &lt;-gclose: fmt.Println(&quot;other goroutine exited&quot;) return case &lt;-mclose: fmt.Println(&quot;main goroutine exited&quot;) return /* default: datachan &lt;- i */ case datachan &lt;- i: &#125; &#125; &#125;(datachan, groutineclose, mainclose, &amp;waitgroup) 发送协程在defer函数中回收了和接收协程公用的chan，也主动关闭了数据chan，这么做保证关闭不会panic。此外还对group做了释放。其实将datachan &lt;- i 放在default分支也是可以的。但是为了保证接收协程退出后该发送协程也要及时退出，就放在case逻辑中，这样不会死锁。发送协程累计发送100次数据给接收协程，然后退出。接下来我们实现接收协程 123456789101112131415161718192021222324252627282930go func(datachan chan int, gclose chan struct&#123;&#125;, mclose chan struct&#123;&#125;, group *sync.WaitGroup) &#123; sum := 0 defer func() &#123; onceclose.Do(func() &#123; close(gclose) &#125;) readclose.Do(func() &#123; fmt.Println(&quot;sum is &quot;, sum) fmt.Println(&quot;receive goroutine closed !&quot;) group.Done() &#125;) &#125;() for i := 0; ; i++ &#123; select &#123; case &lt;-gclose: fmt.Println(&quot;other goroutine exited&quot;) return case &lt;-mclose: fmt.Println(&quot;main goroutine exited&quot;) return case data, ok := &lt;-datachan: if !ok &#123; fmt.Println(&quot;receive close chan data&quot;) return &#125; sum += data &#125; &#125; &#125;(datachan, groutineclose, mainclose, &amp;waitgroup) 和发送协程一样，接收协程也通过once操作保证公用的通知chan只回收一次。然后回收了自己的资源。接收协程一直循环获取数据，如果收到主协程退出或者发送协程退出的通知，就退出。接下来我们继续编写主协程的等待和回收操作 1234567defer func() &#123; close(mainclose) time.Sleep(time.Second * 5) &#125;() waitgroup.Wait() fmt.Println(&quot;main exited&quot;) 这些逻辑我们都写在main函数里即可。主协程通过waitgroup等待两个协程，并通过defer通知两个协程退出。运行代码效果如下 12345send goroutine closed !receive close chan datasum is 4950receive goroutine closed !main exited 可以看出发送协程退出接收协程也退出了，接收协程正好计算100次累加，数值为4950。主协程也退出了。 测试接收协程异常退出接下来我们测试接收协程异常退出后，发送协程和主协程退出是否回收资源。我们将接收协程的case逻辑改为i&gt;=20时该接收协程主动panic 123456789case data, ok := &lt;-datachan: if !ok &#123; fmt.Println(&quot;receive close chan data&quot;) return &#125; sum += data if i &gt;= 20 &#123; panic(&quot;receive goroutine test panic !!&quot;) &#125; 运行代码看下效果 12345678recover !close gclose channelsum is 210receive goroutine closed !other goroutine exitedsend goroutine closed !main exiteddefer main close 我们在接收协程的defer里增加了recover逻辑，可以看到三个协程都正常退出并回收了各自的资源。 测试主协程主动退出我们将主协程的等待代码去掉，并且在defer中增加延时退出，方便看到两个协程退出情况 12345678defer func() &#123; fmt.Println(&quot;defer main close&quot;) close(mainclose) time.Sleep(time.Second * 10)&#125;()time.Sleep(time.Second * 10)fmt.Println(&quot;main exited&quot;) 运行看效果 1234567main exiteddefer main closemain goroutine exitedsum is 88074498378441receive goroutine closed !main goroutine exitedsend goroutine closed ! 看到三个协程正常退出，并回收了资源。 源码下载https://github.com/secondtonone1/golang-/tree/master/channelpractice","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"图解Go协程调度原理，小白都能理解","date":"2019-11-05T02:42:53.000Z","path":"2019/11/05/golang17/","text":"阅读本文仅需五分钟，golang协程调度原理，小白也能看懂，超实用。 什么是协程对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行抢占式调度。协程，又称微线程，纤程。英文名Coroutine。协程的调用有点类似子程序，如程序A调用了子程序B，子程序B调用了子程序C，当子程序C结束了返回子程序B继续执行之后的逻辑，当子程序B运行结束了返回程序A，直到程序A运行结束。但是和子程序相比，协程有挂起的概念，协程可以挂起跳转执行其他协程，合适的时机再跳转回来。 线程调度原理N:1模型，多个用户空间线程在1个内核空间线程上运行。优势是上下文切换非常快，因为这些线程都在内核态运行，但是无法利用多核系统的优点。1:1模型，1个内核空间线程运行一个用户空间线程。这种充分利用了多核系统的优势但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。POSIX线程模型(pthread)就是这么做的。M:N模型，内核空间开启多个内核线程，一个内核空间线程对应多个用户空间线程。效率非常高，但是管理复杂。 goroutine调度原理本质上goroutine就是协程，但是完全运行在用户态，借鉴了M:N模型。如下图相比其他语言，golang采用了MPG模型管理协程，更加高效，但是管理非常复杂。M：内核级线程G：代表一个goroutineP：Processor，处理器，用来管理和执行goroutine的。 G-M-P三者的关系与特点：P的个数取决于设置的GOMAXPROCS，go新版本默认使用最大内核数，比如你有8核处理器，那么P的数量就是8M的数量和P不一定匹配，可以设置很多M，M和P绑定后才可运行，多余的M处于休眠状态。P包含一个LRQ（Local Run Queue）本地运行队列，这里面保存着P需要执行的协程G的队列除了每个P自身保存的G的队列外，调度器还拥有一个全局的G队列GRQ（Global Run Queue），这个队列存储的是所有未分配的协程G。 假设我们的主机是单核的，那么协程运行图是这样：红色部分表示挂起和休眠，黄色部分表示准备就绪等待运行，绿色部分表示正在运行。主机是单核的所以只有一个处理器P，但是系统初始化了两个线程M0和M1，处理器P优先绑定了M0线程，M1进入休眠状态。P的LRQ队列里有G1,G2,G3等待处理。P目前正在处理G0,全局等待队列GRQ里保存着G4,G5，表示这两个协程还未分配给P。如果G0在短时间内处理完，P就会从LRQ中取出G1继续处理。并且将GRQ全局队列中的部分协程加入LRQ中。如下图假设现在G1处理速度很慢，系统就会让M0线程休眠，挂起协程G1，唤醒线程M1进行处理其他的协程。这里M1会将M0未处理的协程取走处理。等到M1协程队列中所有协程处理完再次唤醒M0，或者M1处理某个协程时间较长被挂起，M0也会被唤醒。上面的讨论是单核主机情况，如果是多核的，就会运行多个P和M，如下图M0和M1分别运行在不同的内核中，M0处理G1,G2,G3，M1处理G4,G5,G6。有人会问，当M0处理完所有的协程，而M1还未处理完，系统会如何做呢？M0会取走M1的一半数量未处理的协程。 总结golang协程设计非常优秀，一方面极大的利用了内核线程和处理器资源，另一方面每个处理器的LRQ队列的协程都处于用户态，这些协程的处理和挂起操作都是用户态的，协程切换开销非常小。相比其他语言的线程设计，更加轻量和高效。以上就是golang协程调度原理。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"不推荐新手的编程语言，你中枪了吗","date":"2019-10-31T04:57:40.000Z","path":"2019/10/31/news1/","text":"TIOBE 编程语言排名前20随着时代的发展，编程语言日益丰富。诚然，熟练掌握多门编程语言是很多开发者梦寐以求的事，不过人的精力有限，要有选择性的学习。最好是能够结合自己的工作或者爱好有针对性的训练和学习。语言只是工具，但是这些工具的应用场景不尽相同。下图为TIOBE 2019年9月统计的编程语言排名 可以看出前四名Java, C, Python, C++ 一直处于稳定地位。但是Java，C++，C都有下滑，反而python一直处于上升状态，而有些语言的使用场景正在不断缩减，这里列举五种编程语言，他们的使用率处于下滑趋势，就业机会也在锐减，不推荐新手入行学习。 Perl语言Perl，一种功能丰富的计算机程序语言，运行在超过100种计算机平台上。于1987年，2005年前一直位于排行榜前三。至今跌破前20，Perl追求的是简单， 解决一个一般的问题用它几行代码就完成了，而且跨平台。Perl还可以帮你写更安全的程序。除了其它语言提供的典型的安全接口之外，Perl还通过一种跟踪数据的机制给你提供预防意外安全错误的保护，这样就可以在灾害发生之前预防其发生。但是随着python的日益崛起，python扩展性比perl更加优秀，上手也简单。perl的市场和使用场景不断缩小，目前就业机会并不多，相比Perl，我更推荐学习python，就业机会广，语言库全面，而且简单易上手。 DelphiObject Pascal 是一种高级编译语言，具有强类型特性，支持结构化和面向对象编程。Object pascal并没有像C/C++那样成为业内标准，导致了跨平台的问题，Delphi之父Anders Hejlsberg离开Borland去了微软，导致Delphi的编译器没有发展，Anders Hejlsberg去了微软之后推出了.NET框架，主打语言是C#，无论从类库命名还是代码风格都与Delphi很像，C#语法接近C，很多C程序员和Delphi程序员都可以上手，这也导致了Delphi的部分开发者流失。另外Java的不断丰富和壮大，抢占了大部分Delphi的市场，而且Java开发难度和学习成本都不高，成为炙手可热的语言。随着市场的变化，桌面应用正在大幅减少，Delphi显然不是一个理想的WEB开发语言，使用Delphi编写一些项目，对程序员的开发素质和能力要求较高，而使用Java或C#只需要更少和更加普通的程序员，所以Delphi的衰退也是一种必然。 RubyRuby，一种简单快捷的面向对象（面向对象程序设计）脚本语言，在20世纪90年代由日本人开发。Ruby已经慢慢走向衰退了，现在WEB开发里，NODE.JS+前端各种框架是主流，PHP、ruby、Asp.net、python等语言在网站编程方面只会越来越少。数据领域方面，机器学习和人工智能中，python语言是主流，科学计算中PYTHON、matlab、R等语言是主流。网络编程和服务器处理等C++，Golang使用较多。2018 年，Ruby 的工作岗位需求减少了 56%，这样的数据是非常惊人的，它意味着企业正在弃 Ruby 而去，而且仍处于衰退趋势。 Object-C苹果的 Objective-C 已经有 35 年的历史了，不过很明显，如今苹果公司已经不管它的死活了，五年前，苹果为其生态系统推出全新且经过改进的编程语言 Swift，并且迅速登上编程语言的舞台，毋庸置疑，他们最希望开发者能迅速接受 Swift 以替代掉 Objective-C。平心而论，越来越多的开发者已经开始使用Swift（尤其是它的功能已经越来越丰富了），不过，出乎意料的是 Objective-C 在流行编程语言排行榜上的排名也没有预想的那么糟糕，这可能是在 35 年的遗留代码中，许多开发人员只是更喜欢使用他们一直使用的语言。因为 Swift 正在成为一种非常有效的语言，用于构建 iOS、macOS 以及即将推出的跨平台应用程序，Object-C的部分程序员正在转型和做调整。 推荐语言本文并非引战，旨在通过分析TIOBE语言使用趋势排行以及市场变化，给新手和入行程序员一些语言选择方面的建议。如果你已经在一个领域中拥有足够的经验和特长，完全可以解决遇到的大部分问题，也不会面临就业危机。2019是变化最多的一年，5G时代的来临，网络技术高速发展，云服务的不断推进，Golang的应用会变得越来越广泛，另外人工智能和机器学习热度一直不错，python在数据处理这个领域占据的地位一直在上升，也是值得学习的编程语言。前端Web技术javascript一直有着不错的就业机会和薪水待遇。服务器编程C++和Java还是老样子，一个主打效率，一个面向广泛。C++服务器多用在游戏领域，游戏前端技术底层也是C++去实现引擎，上层用js较多，Java多用在移动服务领域，这些语言都有不错的市场，毕竟人生苦短，仔细斟酌后大家自行选择。感谢关注我的公众号","categories":[{"name":"生活感悟","slug":"news","permalink":"http://www.limerence2017.com/categories/news/"}],"tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://www.limerence2017.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"}]},{"title":"区块链，并不是想象的那么乐观","date":"2019-10-29T05:34:04.000Z","path":"2019/10/29/eos10/","text":"区块链现状“新华社北京10月25日电，区块链技术的集成应用在新的技术革新和产业变革中起着重要作用。我们要把区块链作为核心技术自主创新的重要突破口，明确主攻方向，加大投入力度，着力攻克一批关键核心技术，加快推动区块链技术和产业创新发展。”目前国家比较重视区块链技术的自主创新，而且也明鼓励技术突破。而且我国成为了首个发行数字货币的国家。DCEP（Digital Currency Electronic Payment），是中国人民银行研发的电子货币。有利于人民币的流通和国际化。同时DCEP可以实现货币创造、记账、流动等数据的实时采集。 最近随着国家对区块链技术的重视，不少虚拟货币也随之增值 说点我自己的看法，区块链技术是现有技术的组合(分布式设计，P2P网络，共识算法等)，是思想上的创新和变革。但是币圈很乱，也很浮躁，百分之九十的公司并没有研发区块链相关技术，而是致力于发币，发币割韭菜。早些年，有些公司结合区块链技术写个白皮书就能拉来投资，至于白皮书的技术和设想能否实现，他们自己也不知道。我加入的几个群，讨论技术的少之又少，多半都是哪个公司发币了，要不要炒币。目前没看到国内哪个公司发行高可用的区块链操作系统，比特币定位越来越明确，就是作为虚拟的加密数字货币。而EOS(柚子链)，Ethereum(以太坊)等则定位为区块链操作系统，类似于Linux，Windows等操作系统，可以在上面跑应用，而这些应用叫做dapp，目前这些区块链成熟产品都不是国产的，目前技术这块，还有待突破。 没有成熟区块链产品无论国内还是国外，没有成熟的区块链产品落地。我查看了几款区块链相关的dapp，大部分是结合交易所开发相关钱包，钱包就是一款dapp，支持购买相应的虚拟货币。还有一部分dapp是区块链小游戏，说是小游戏都有点过，就是博彩类转骰子的功能，说白了还不过是满足大部分的赌徒心里。就目前成熟的三款区块链产品来谈，比特币定位为虚拟货币，不做操作系统发展，剩下两个EOS和Ethereum是区块链操作系统，EOS比Ethereum效率更好一些，毕竟不是完全去中心化，EOS通过部分中心化的共识算法，提升了效率。目前基于EOS开发的dapp也没什么两点，而且没有得到推广和应用。 究竟什么原因呢？我认为主要原因是性能瓶颈并未突破。性能方面，CPU，RAM,NET等都受限于节点配置(所谓节点打个比方就好比是P2P网络中的节点),拿EOS举例，开发者想要基于EOS做dapp并发布(就好比我们开发一款app上android应用市场一样)，需要支付一定的费用购买相应的EOS代币，再通过EOS代币抵押给EOS系统，租赁CPU,NET，购买RAM。就这操蛋的设计，不说开发一款应用难度，单说资金这块就能卡死一部分开发者。EOS的资源购买和抵押是非常贵的，这也是没有成熟dapp落地的主要原因。大部分公司都没有这么多资金试水，何况独立开发者。换句话说，我有相同的钱能做一款爆款互联网app，上android和ios市场，还有资金运维，干嘛非要跟自己过不去，拿一个技术有瓶颈的区块链操作系统试水啊？有钱烧的？烧钱不是这么烧的。EOS提供了合约机制，所谓合约其实就是规则，告诉每个节点执行那些操作，处理那些请求，可悲的是，合约所支持的数据结构也有限，而且RAM,NET,CPU等使用也要谨慎。比如把现在成熟的一些手游移植到EOS中，受限的不是玩法实现的难度，反而是合约所限制的内存带宽等资源。 到现在还不懂区块链是什么有很多人，我相信至少70%的人不知道区块链是什么。我的很多搞开发的朋友也不知道，更何况平民老百姓了。很多资料上说区块链就是分布式账本，我给大家解释一下，传统的服务器和客户端模型是C/S结构，C/S结构就是多个Client对应一个Server，如下图多个Client向一个Server请求数据，这是传统的C/S框架。后来为了解决单个Server的瓶颈和限制，提出了分布式设计的思想，可部署多个Server，这些Server协同处理客户端请求，如下图当客户端大量请求时，优先将请求发送给balancer负载均衡器，负载均衡器通过负载均衡算法(轮询，随机等)派发给空闲服务器。服务器处理好后再互相同步。目前，大部分的互联网公司都采用这种结构。只是随着云技术的推广和应用，将Server中不同的服务处理独立成一个服务Service，部署到docker中独立运行，思路大体相同。接下来谈谈区块链，区块链其实和分布式进程类似，就是将上面的Server独立成节点，各个节点之间通过同步算法同步数据。同步算法涉及安全性，高效性，去冗余等规则，这些算法就是我们经常听到的共识算法，大部分算法都用到了拜占庭协议，感兴趣的可以了解下。节点之间通过共识算法同步数据，每个节点都记录了区块信息，这些区块信息在节点中是通过链表组织的，后一个块记录了前一个块的信息，所以当某个节点篡改区块链信息时，其他节点可以通过共识算法判断出它是内鬼，就会将这个节点信息修复。一个节点中区块的组织形式如下那么当一个请求过来，节点收到请求后该如何处理呢？这就要谈到合约机制了。合约其实就是一串代码，定义了一系列函数，这些函数可被节点调用。我们只需要将写好的合约编译，发布在指定节点，之后节点通过同步算法同步给其他节点，这样网络中大部分节点就能处理客户端请求了。区块链的知识并不复杂，感兴趣的读者可以了解下EOS，这里有我对EOS源码的剖析http://www.limerence2017.com/categories/blockchain/ 是否有必要转行做区块链开发不少开发者都会有疑问是否要转行做区块链开发，毕竟区块链是新兴的技术，而且薪水也不低，我认为还是取决于自己吧，区块链技术目前还在发展之中，落地应用少之又少，如果你觉得这是风口浪尖，可以搏一搏，而且你又对区块链相关技术特别感兴趣，那么可以试着做一下转型，区块链目前招聘的岗位也不多，大部分招聘合约开发，钱包开发，也有招聘跨链研究的，如果你觉得目前操之过急，那么你可以安心做好目前的工作，业余时间了解相关技术和知识，见风使舵也不迟。 感兴趣的读者可以先了解下区块链相关知识：共识算法, P2P网络, boost::asio , EOS合约写法等。这是我用boost::asio写的异步服务器，和EOS网络层实现方式差不多。https://github.com/secondtonone1/boostserver 感谢关注我的公众号","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"python学习(28) Tinker+BeautifulSoup+Request抓取美女壁纸","date":"2019-10-22T08:40:00.000Z","path":"2019/10/22/python29/","text":"抓取准备今天是10月24日，祝所有程序员节日快乐。今天打算写个爬虫抓取3DMGAME论坛美女cosplay壁纸。论坛首页网址为https://www.3dmgame.com/tu_53_1/我们点击其中一个图集，然后网页跳转，看下源码 123456789101112131415&lt;div class=&quot;dg-wrapper&quot;&gt; &lt;a data-src = &quot;/uploads/images/thumbpicfirst/20190730/1564452665_126346.jpg&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/thumbpicfirst/20190730/1564452665_126346.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;miaoshu&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;num&quot;&gt;&lt;i&gt;&lt;/i&gt; /&lt;u&gt;&lt;/u&gt;&lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;a data-src = &quot;/uploads/images/thumbpicfirst/20190730/1564452665_242197.jpg&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/thumbpicfirst/20190730/1564452665_242197.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;miaoshu&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;num&quot;&gt;&lt;i&gt;&lt;/i&gt; /&lt;u&gt;&lt;/u&gt;&lt;/div&gt; &lt;/div&gt; &lt;/a&gt; 网址是静态的，我们直接提取其中的图片链接再下载即可。抓取网页采用的是python的requests库，直接发送http请求即可。收到回包后，通过BeautifulSoup提炼其中图片地址再次下载即可。另外我们的界面用的是python自带的Tinker编写的。 代码实现实现线程装饰器1234567def thread_run(func): def wraper(*args, **kwargs): t = threading.Thread(target=func, args=args, kwargs=kwargs) t.daemon = True t.start() return wraper 封装了一个装饰器，启动线程并调用传入的函数。 我们实现了DownloadFrame类类里实现如下方法 123456789101112131415161718192021222324252627282930def prepare(self, downloadlinks): self.flag = True self.downloadlinks = downloadlinks self.base_url = self.downloadlinks fail = 0 try: url = self.base_url result = requests.get(url, headers=HEADERS,timeout=10) restxt = result.content.decode(&#x27;UTF-8&#x27;) soup = BeautifulSoup(restxt,&#x27;lxml&#x27;) titles = soup.select(&#x27;div .bt&#x27;) if titles is None or len(titles)==0: print(&quot;html page res not found ! \\n&quot;) return title = re.split(r&#x27;[;,\\s]&#x27;,titles[0].text)[0] curdir = os.path.dirname(os.path.abspath(__file__)) picpath = os.path.join(curdir,title) if not os.path.exists(picpath): os.mkdir(picpath) print(picpath) imglist = soup.select(&#x27;.dg-wrapper img&#x27;) if imglist is None or len(imglist)==0: print(&quot;html page res not found ! \\n&quot;) return self.downloadPic(imglist,picpath) except Exception as e: print(e) time.sleep(3) prpare函数实现了请求指定网页，并用BeautifulSoup处理回包的功能。 123456789101112131415161718192021222324@thread_run def download(self, url, path): try: if lock.acquire(): self.name += 1 imgname = str(self.name)+&#x27;.&#x27;+url.split(&#x27;.&#x27;)[-1] filename = os.path.join(path,imgname) lock.release() print(url) print(filename) # res = requests.get(url, headers=header ) res = requests.get(url, headers=HEADERS,timeout=10 ) with open(filename, &#x27;wb&#x27;) as f: f.write(res.content) # 下载完后检查是否完成下载 if lock.acquire(): if self.flag: self.flag = False messagebox.showinfo(&quot;提示&quot;, &quot;下载完成&quot;) lock.release() except Exception as e: print(e) download传给了我们之前封装的装饰器thread_fun, download实现了下载指定图片的功能。 效果展示下载图片感谢关注我的公众号 源码下载https://github.com/secondtonone1/python-/tree/master/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E6%8A%93%E5%8F%963DGAME%E8%AE%BA%E5%9D%9B%E5%A3%81%E7%BA%B8也可以阅读原文下载","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"Go进阶篇(02) 反射用法详解","date":"2019-10-14T08:44:41.000Z","path":"2019/10/14/golang16/","text":"反射是什么反射其实就是通过变量动态获取其值和类型的一种技术，有些语言是支持反射的比如python, golang,有些是不支持反射的比如C++前文我们分析过interface的结构，无论空接口还是有方法的接口，其内部都包含type和value两个类型，type指向了变量实际的类型value指向了变量实际的值。而反射就是获取这两个类型的数据。golang总类型分为包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型反射只能作用于interface{}类型，interface{}类型时concrete类型下面介绍golang反射的基本用法 reflect.ValueOf与reflect.TypeOf12345678 var num float64 = 13.14rtype := reflect.TypeOf(num)fmt.Println(&quot;reflect type is &quot;, rtype)rvalue := reflect.ValueOf(num)fmt.Println(&quot;reflect value is &quot;, rvalue)fmt.Println(&quot;reflect value kind is&quot;, rvalue.Kind())fmt.Println(&quot;reflect type kind is&quot;, rtype.Kind())fmt.Println(&quot;reflect value type is&quot;, rvalue.Type()) golang 提供了反射功能的包reflect, reflect中ValueOf能够将变量转化为reflect.Value类型，reflect.TypeOf可以将变量转化为reflect.Type类型。 reflect.Type 表示变量的实际类型。reflect.Value 表示变量的实际值。 reflect.Value类型提供了Kind()方法，获取变量实际的种类。reflect.Value类型提供了Type()方法，获取变量实际的类型。relfect.Type 同样提供了Kind()方法，获取变量的种类。上面程序的输出结果为 12345reflect type is float64reflect value is 13.14reflect value kind is float64reflect type kind is float64reflect value type is float64 可见通过反射可以获取变量的实际类型和数值，那么Kind和Type有什么区别呢？这个区别在于结构体，之后再谈。如果您只需要了解反射的基础知识，看到这里就可以了，下面介绍反射复杂的玩法。 通过reflect.Value修改变量如果一个变量是reflect.Value类型，则可以通过SetInt,SetFloat,SetString等方法修改变量的值，但是reflect.Value必须是指针类型，否则无法修改原变量的值。可以通过Canset方法判断reflect.Value是否可以修改。另外如果reflect.Value为指针类型，需要通过Elem()解引用方可使用其方法。我们继续上面的例子补充代码。 12345678910111213141516171819var num float64 = 13.14rtype := reflect.TypeOf(num)fmt.Println(&quot;reflect type is &quot;, rtype)rvalue := reflect.ValueOf(num)fmt.Println(&quot;reflect value is &quot;, rvalue)fmt.Println(&quot;reflect value kind is&quot;, rvalue.Kind())fmt.Println(&quot;reflect type kind is&quot;, rtype.Kind())fmt.Println(&quot;reflect value type is&quot;, rvalue.Type())rptrvalue := reflect.ValueOf(&amp;num)fmt.Println(&quot;reflect value is &quot;, rptrvalue)fmt.Println(&quot;reflect value kind is&quot;, rptrvalue.Kind())fmt.Println(&quot;reflect type kind is&quot;, rptrvalue.Kind())fmt.Println(&quot;reflect value type is&quot;, rptrvalue.Type())if rptrvalue.Elem().CanSet() &#123; rptrvalue.Elem().SetFloat(131.4)&#125;fmt.Println(num) 输出如下 12345678910reflect type is float64reflect value is 13.14reflect value kind is float64reflect type kind is float64reflect value type is float64reflect value is 0xc000012098reflect value kind is ptrreflect type kind is ptrreflect value type is *float64131.4 可以看到通过rptrvalue.Elem().SetFloat(131.4)成功修改了num的数值。而且通过打印rptrvalue的Kind为ptr指针种类，Type为float64的指针类型注意，如果通过rptrvalue.SetFloat(131.4)会导致panic崩溃，因为此时rptrvalue为指针类型需要通过Elem()解引用才可以使用方法。这个Elem()相当于C++编程中解引用的* 通过Interface()将relect.Value类型转换为interface{}类型我们可通过Interface()将relect.Value类型转换为interface{}类型，进而转换为原始类型。继续上边的代码，我们完善代码 1234567891011121314151617181920212223242526var num float64 = 13.14rtype := reflect.TypeOf(num)fmt.Println(&quot;reflect type is &quot;, rtype)rvalue := reflect.ValueOf(num)fmt.Println(&quot;reflect value is &quot;, rvalue)fmt.Println(&quot;reflect value kind is&quot;, rvalue.Kind())fmt.Println(&quot;reflect type kind is&quot;, rtype.Kind())fmt.Println(&quot;reflect value type is&quot;, rvalue.Type())rptrvalue := reflect.ValueOf(&amp;num)fmt.Println(&quot;reflect value is &quot;, rptrvalue)fmt.Println(&quot;reflect value kind is&quot;, rptrvalue.Kind())fmt.Println(&quot;reflect type kind is&quot;, rptrvalue.Kind())fmt.Println(&quot;reflect value type is&quot;, rptrvalue.Type())if rptrvalue.Elem().CanSet() &#123; rptrvalue.Elem().SetFloat(131.4)&#125;fmt.Println(num)//rvalue 为reflect包的Value类型//可通过Interface()转化为interface&#123;&#125;类型，进而转化为原始类型rawvalue := rvalue.Interface().(float64)fmt.Println(&quot;rawvalue is &quot;, rawvalue)rawptrvalue := rptrvalue.Interface().(*float64)fmt.Println(&quot;rawptrvalue is &quot;, *rawptrvalue) 输出如下 1234567891011reflect value is 13.14reflect value kind is float64reflect type kind is float64reflect value type is float64reflect value is 0xc000012098reflect value kind is ptrreflect type kind is ptrreflect value type is *float64131.4rawvalue is 13.14rawptrvalue is 131.4 可以看出rvalue.Interface().(float64)将reflect.Value类型转换为float类型rptrvalue.Interface().(*float64)将reflect.Value类型转换为float指针类型在这两个转换前，我们不是已经将num值修改为131.4了吗？为什么rvalue.Interface().(float64)转换后还是13.14呢？因为rvalue为值类型不是指针类型，只是存储了num未修改前的一个副本，其值为13.14，所以转化为float类型值仍为13.14。而rptrvalue为指针类型，指向的空间为num所在的空间，所以转化为float指针后指向num所在空间。num修改了，rptrvalue指向空间的数据就修改了。到目前为止第一个例子就完整的写完了。 Kind和Type有何不同？我们先定义一个结构体Hero 1234type Hero struct &#123; name string id int&#125; 接着我们实现一个函数，通过反射判断结构体类型 12345678910func ReflectTypeValue(itf interface&#123;&#125;) &#123; rtype := reflect.TypeOf(itf) fmt.Println(&quot;reflect type is &quot;, rtype) rvalue := reflect.ValueOf(itf) fmt.Println(&quot;reflect value is &quot;, rvalue) fmt.Println(&quot;reflect value kind is&quot;, rvalue.Kind()) fmt.Println(&quot;reflect type kind is&quot;, rtype.Kind()) fmt.Println(&quot;reflect value type is&quot;, rvalue.Type())&#125; 上面函数参数为空接口，可以接受任何类型数据，内部调用了反射的TypeOf和ValueOf转化，判断参数类型和种类我们在main函数测试下 12ReflectTypeValue(Hero&#123;name: &quot;zack&quot;, id: 1&#125;)ReflectTypeValue(&amp;Hero&#123;name: &quot;zack&quot;, id: 1&#125;) 输出如下 12345678910reflect type is main.Heroreflect value is &#123;zack 1&#125;reflect value kind is structreflect type kind is structreflect value type is main.Heroreflect type is *main.Heroreflect value is &amp;&#123;zack 1&#125;reflect value kind is ptrreflect type kind is ptrreflect value type is *main.Hero 看的出来，Hero结构体的Kind为struct,Type为main.Hero,因为Hero定义在main包，所以为main.Hero结构体的值为{zack 1}Hero指针的Kind为ptr,Type也为*main.Hero，值为&amp;{zack 1}这其实就是Kind和Type的区别，Type为具体的类型，Kind为种类，比如指针ptr，结构体struct,整形int等。下面我们进行更复杂的结构体遍历和探测 通过reflect.Value的NumField函数获取结构体成员数量reflect.Value类型提供了NumField()函数，用来返回结构体成员数量。我们先实现一个函数遍历探测结构体成员。 123456789 func ReflectStructElem(itf interface&#123;&#125;) &#123; rvalue := reflect.ValueOf(itf) for i := 0; i &lt; rvalue.NumField(); i++ &#123; elevalue := rvalue.Field(i) fmt.Println(&quot;element &quot;, i, &quot; its type is &quot;, elevalue.Type()) fmt.Println(&quot;element &quot;, i, &quot; its kind is &quot;, elevalue.Kind()) fmt.Println(&quot;element &quot;, i, &quot; its value is &quot;, elevalue) &#125;&#125; ReflectStructElem函数首先通过reflect.ValueOf获取reflect.Value类型，在通过reflect.Value类型的NumField获取实际结构体内的成员个数。rvalue.Field(i)根据索引依次获取结构体每个成员，elevalue类型为reflect.Value类型，所以可以通过Kind,Type等方法获取成员的类型和种类。我们在主函数调用上面的方法 1ReflectTypeValue(Hero&#123;name: &quot;zack&quot;, id: 1&#125;) Hero为我们上个例子定义的结构体，输出如下 123456element 0 its type is stringelement 0 its kind is stringelement 0 its value is zack fairelement 1 its type is intelement 1 its kind is intelement 1 its value is 2 可见通过reflect.Value的NumField是可以遍历探测结构体成员的值得。下面我们试试在main函数中加入这样一段代码 1ReflectStructElem(&amp;Hero&#123;name: &quot;Rolin&quot;, id: 20&#125;) 这次ReflectStructElem的参数为Hero指针类型,运行发现程序崩溃了。我们查看下NumField的源码 12345func (v Value) NumField() int &#123; v.mustBe(Struct) tt := (*structType)(unsafe.Pointer(v.typ)) return len(tt.fields)&#125; 可以看出NumField内部判断v必须为Struct类型，然后取出v的typ字段转化为结构体指针进行操作。所以NumField只能用在探测结构体类型,指针，int，float，string等类型都不能使用NumField方法。那如果我们想遍历结构体指针类型怎么办？比如*Hero类型？答案是可以的，通过Elem()解引用即可。我们再实现一个函数，用来探测结构体指针类型成员变量。 123456789func ReflectStructPtrElem(itf interface&#123;&#125;) &#123; rvalue := reflect.ValueOf(itf) for i := 0; i &lt; rvalue.Elem().NumField(); i++ &#123; elevalue := rvalue.Elem().Field(i) fmt.Println(&quot;element &quot;, i, &quot; its type is &quot;, elevalue.Type()) fmt.Println(&quot;element &quot;, i, &quot; its kind is &quot;, elevalue.Kind()) fmt.Println(&quot;element &quot;, i, &quot; its value is &quot;, elevalue) &#125;&#125; ReflectStructPtrElem先通过reflect.ValueOf接口类型转化为reflect.Value类型的rvalue,此时rvalue实际类型为结构体指针类型，所以通过Elem()解除引用,这样rvalue.Elem()为Hero类型。接下来就可以遍历和获取结构体成员了。main函数中添加如下代码 12heroptr := &amp;Hero&#123;name: &quot;zack fair&quot;, id: 2&#125;ReflectStructPtrElem(heroptr) 输出 123456element 0 its type is stringelement 0 its kind is stringelement 0 its value is zack fairelement 1 its type is intelement 1 its kind is intelement 1 its value is 2 到目前为止，我们学会了通过反射获取基本类型(int,string,float等)的变量，也可以获取结构体类型和结构体指针类型的变量，以及探测其内部成员。接下来我们考虑修改结构体成员的值。 通过reflect.Value的NumMethod获取结构体方法我们要修改结构体成员变量的值，可以通过之前的Set方法吗？答案是可以的，但是要求比较苛刻，要求反射的对象是结构体指针，并且修改的成员也是指针类型才可以。而对于非指针类型的成员变量怎么修改呢？我们先完善函数 ReflectStructPtrElem 12345678910111213141516func ReflectStructPtrElem(itf interface&#123;&#125;) &#123; rvalue := reflect.ValueOf(itf) for i := 0; i &lt; rvalue.Elem().NumField(); i++ &#123; elevalue := rvalue.Elem().Field(i) fmt.Println(&quot;element &quot;, i, &quot; its type is &quot;, elevalue.Type()) fmt.Println(&quot;element &quot;, i, &quot; its kind is &quot;, elevalue.Kind()) fmt.Println(&quot;element &quot;, i, &quot; its value is &quot;, elevalue) &#125; if rvalue.Elem().Field(1).CanSet() &#123; rvalue.Elem().Field(1).SetInt(100) &#125; else &#123; fmt.Println(&quot;struct element 1 can&#x27;t be changed&quot;) &#125;&#125; 上面代码添加了功能，获取结构体指针类型的变量的第二个成员，判断是否可以修改。测试下 12heroptr := &amp;Hero&#123;name: &quot;zack fair&quot;, id: 2&#125;ReflectStructPtrElem(heroptr) 输出如下 1234567element 0 its type is stringelement 0 its kind is stringelement 0 its value is zack fairelement 1 its type is intelement 1 its kind is intelement 1 its value is 2struct element 1 can&#x27;t be changed 可见*Hero虽然为结构体指针类型，但是成员id为int类型，不可被更改。有什么办法更改Hero成员变量吗？答案是有的，通过Hero的方法，我们给Hero完善几个方法 1234567891011121314151617181920type Hero struct &#123; name string id int&#125;func (h Hero) PrintData() &#123; fmt.Println(&quot;Hero name is &quot;, h.name, &quot; id is &quot;, h.id)&#125;func (h Hero) SetName(name string) &#123; h.name = name&#125;func (h *Hero) SetName2(name string) &#123; h.name = name&#125;func (h *Hero) PrintData2() &#123; fmt.Println(&quot;Hero name is &quot;, h.name, &quot; id is &quot;, h.id)&#125; 我们分别为Hero类增加了四个方法，两个为Hero实现，两个为Hero实现。通过前面几篇文章我介绍过Hero类型变量只能访问基于Hero实现的方法，而Hero指针类型的变量可以访问所有Hero方法。包括Hero和Hero实现的所有方法。与探测结构体成员变量一样，反射提供了方法探测和调用的api。reflect.Value提供了MethodField方法获取结构体实现的方法数量，通过reflect.Value的Method方法获取指定方法并调用。我们实现一个函数 1234567891011121314151617181920func ReflectStructMethod(itf interface&#123;&#125;) &#123; rvalue := reflect.ValueOf(itf) rtype := reflect.TypeOf(itf) for i := 0; i &lt; rvalue.NumMethod(); i++ &#123; methodvalue := rvalue.Method(i) fmt.Println(&quot;method &quot;, i, &quot; value is &quot;, methodvalue) methodtype := rtype.Method(i) fmt.Println(&quot;method &quot;, i, &quot; type is &quot;, methodtype) fmt.Println(&quot;method &quot;, i, &quot; name is &quot;, methodtype.Name) fmt.Println(&quot;method &quot;, i, &quot; method.type is &quot;, methodtype.Type) &#125; //reflect.ValueOf 方法调用,无参方法调用 fmt.Println(rvalue.Method(0).Call(nil)) //有参方法调用 params := []reflect.Value&#123;reflect.ValueOf(&quot;Rolin&quot;)&#125; fmt.Println(rvalue.Method(1).Call(params)) //虽然修改了，但是并没有生效 fmt.Println(rvalue.Method(0).Call(nil))&#125; 对上面的函数做详细讲解rvalue := reflect.ValueOf(itf) 将参数itf转化为reflect.Value类型rtype := reflect.TypeOf(itf) 将参数itf转化为reflect.Type类型rvalue.NumMethod 获取结构体实现的方法个数methodvalue := rvalue.Method(i)根据索引i获取对应的方法，methodvalue 为reflect.Value类型methodtype := rtype.Method(i) 根据索引i获取对应的方法，methodtype 为reflect.Method类型，可以进一步获取方法类型，名字等信息。rvalue.Method(0).Call(nil)为方法调用，如果itf为Hero类型，则调用了结构体的第一个方法PrintData,Call的参数为一个reflect.Value类型的slice。这个slice存储的就是函数调用所需的参数。由于PrintData参数为空，所以这里传nil就行。params := []reflect.Value{reflect.ValueOf(“Rolin”)}构造了参数列表如果itf为Hero类型rvalue.Method(1).Call(params)调用了结构体实现的第二个方法SetName那么综上所述，其实上面的函数ReflectStructMethod功能就是遍历结构体所实现的方法，打印方法地址和名字，类型等信息。然后调用了打印方法和修改方法。我们在main函数里添加代码测试 1ReflectStructMethod(Hero&#123;name: &quot;zack fair&quot;, id: 2&#125;) 输出 12345678910method 0 value is 0x4945d0method 0 type is &#123;PrintData func(main.Hero) &lt;func(main.Hero) Value&gt; 0&#125;method 0 name is PrintDatamethod 0 method.type is func(main.Hero)method 1 value is 0x4945d0method 1 type is &#123;SetName func(main.Hero, string) &lt;func(main.Hero, string) Value&gt; 1&#125;method 1 name is SetNamemethod 1 method.type is func(main.Hero, string)Hero name is zack fair id is 2Hero name is zack fair id is 2 可以看出每次遍历我们打印的方法地址methodvalue都为0x4945d0,其实这个地址就是存储在interface的itab中的fun方法集地址。还记得我之前剖析interface内部实现的这个图吗?fun我之前说过为unitptr类型的数组，大小为1，其实这是一个柔性数组，实际大小取决于方法个数0x4945d0就是个柔型数组的首地址。接着打印methodtype，其实就是Method类型的结构体，包含方法名，参数，方法的索引。方法在fun数组中是按照字符大小排序的，这个读者可以自己gdb调试或者查看汇编源码。接着我们在循环外调用了打印函数PrintData()和修改函数SetName()但是我们看到，修改函数并没有生效。因为SetName是基于Hero实现的，达不到修改自身属性的目的。需要调用SetName2来修改。SetName2是基于*Hero实现的。为了达到修改成员变量的目的，我们在实现一个函数 12345678910111213141516171819202122232425262728293031func ReflectStructPtrMethod(itf interface&#123;&#125;) &#123; rvalue := reflect.ValueOf(itf) rtype := reflect.TypeOf(itf) fmt.Println(&quot;Hero pointer struct method list......................&quot;) for i := 0; i &lt; rvalue.NumMethod(); i++ &#123; methodvalue := rvalue.Method(i) fmt.Println(&quot;method &quot;, i, &quot; value is &quot;, methodvalue) methodtype := rtype.Method(i) fmt.Println(&quot;method &quot;, i, &quot; type is &quot;, methodtype) fmt.Println(&quot;method &quot;, i, &quot; name is &quot;, methodtype.Name) fmt.Println(&quot;method &quot;, i, &quot; method.type is &quot;, methodtype.Type) &#125; //reflect.ValueOf 方法调用,无参方法调用 fmt.Println(rvalue.Method(1).Call(nil)) //有参方法调用 params := []reflect.Value&#123;reflect.ValueOf(&quot;Rolin&quot;)&#125; fmt.Println(rvalue.Method(3).Call(params)) //修改了，生效 fmt.Println(rvalue.Method(0).Call(nil)) fmt.Println(&quot;Hero Struct method list......................&quot;) for i := 0; i &lt; rvalue.Elem().NumMethod(); i++ &#123; methodvalue := rvalue.Elem().Method(i) fmt.Println(&quot;method &quot;, i, &quot; value is &quot;, methodvalue) methodtype := rtype.Elem().Method(i) fmt.Println(&quot;method &quot;, i, &quot; type is &quot;, methodtype) fmt.Println(&quot;method &quot;, i, &quot; name is &quot;, methodtype.Name) fmt.Println(&quot;method &quot;, i, &quot; method.type is &quot;, methodtype.Type) &#125;&#125; ReflectStructPtrMethod 用来接收结构体指针rvalue 实际为结构体指针类型rvalue.NumMethod获取结构体指针实现的方法，这其中包含结构体实现的方法和结构体指针实现的方法。如果参数itf为*Hero类型，则NumMethod为4，包括基于Hero指针和Hero结构体实现的方法。这里可能有读者会问如果rvalue为指针类型为什么不需要用Elem()解引用再调用NumMethod?我们看下NumMethod的方法源码 123456789func (v Value) NumMethod() int &#123; if v.typ == nil &#123; panic(&amp;ValueError&#123;&quot;reflect.Value.NumMethod&quot;, Invalid&#125;) &#125; if v.flag&amp;flagMethod != 0 &#123; return 0 &#125; return v.typ.NumMethod()&#125; 可见NumMethod和NumField不同，并没有要求v为结构体类型，所以结构体指针也能调用NumMethod。只是结构体指针和结构体调用NumMethod会返回不同的数量，比如rvalue实际类型为*Hero类型,rvalue.Elem().NumMethod()解引用返回值为2,因为Hero实现了PrintData和SetName方法。我们调用了方法进行修改，然后为了测试解引用和不解引用调用NumMethod的区别，分别进行了打印。在main函数中测试 12345678910111213141516171819202122232425262728Hero pointer struct method list......................method 0 value is 0x4945d0method 0 type is &#123;PrintData func(*main.Hero) &lt;func(*main.Hero) Value&gt; 0&#125;method 0 name is PrintDatamethod 0 method.type is func(*main.Hero)method 1 value is 0x4945d0method 1 type is &#123;PrintData2 func(*main.Hero) &lt;func(*main.Hero) Value&gt; 1&#125;method 1 name is PrintData2method 1 method.type is func(*main.Hero)method 2 value is 0x4945d0method 2 type is &#123;SetName func(*main.Hero, string) &lt;func(*main.Hero, string) Value&gt; 2&#125;method 2 name is SetNamemethod 2 method.type is func(*main.Hero, string)method 3 value is 0x4945d0method 3 type is &#123;SetName2 func(*main.Hero, string) &lt;func(*main.Hero, string) Value&gt; 3&#125;method 3 name is SetName2method 3 method.type is func(*main.Hero, string)Hero name is zack fair id is 2Hero name is Rolin id is 2Hero Struct method list......................method 0 value is 0x4945d0method 0 type is &#123;PrintData func(main.Hero) &lt;func(main.Hero) Value&gt; 0&#125;method 0 name is PrintDatamethod 0 method.type is func(main.Hero)method 1 value is 0x4945d0method 1 type is &#123;SetName func(main.Hero, string) &lt;func(main.Hero, string) Value&gt; 1&#125;method 1 name is SetNamemethod 1 method.type is func(main.Hero, string) 可以看到Hero指针的方法个数为4个，Hero结构体方法个数为2个，并且通过调用SetName2方法达到修改成员变量的目的了。 通过方法名获取方法reflect.Value提供了MethodByName方法，根据名字获取具体方法我们写一个函数，获取方法并调用 123456789101112131415161718func GetMethodByName(itf interface&#123;&#125;) &#123; rvalue := reflect.ValueOf(itf) methodvalue := rvalue.MethodByName(&quot;PrintData2&quot;) if !methodvalue.IsValid() &#123; return &#125; methodvalue.Call(nil) methodset := rvalue.MethodByName(&quot;SetName2&quot;) if !methodset.IsValid() &#123; return &#125; params := []reflect.Value&#123;reflect.ValueOf(&quot;Hurricane&quot;)&#125; methodset.Call(params) methodvalue.Call(nil)&#125; rvalue.MethodByName(“PrintData2”)获取名字为PrintData2的方法。methodvalue.IsValid() 判断是否获取成功。methodvalue.Call(nil) 调用方法。我们在main函数里调用这个函数测试下 1GetMethodByName(&amp;Hero&#123;name: &quot;zack fair&quot;, id: 2&#125;) 输出如下 12Hero name is zack fair id is 2Hero name is Hurricane id is 2 可见通过名字获取方法并调用，也能达到修改Hero成员属性的目的。读者可以在main函数中添加如下代码，测试下，看看效果，并想想为什么 1GetMethodByName(Hero&#123;name: &quot;Itach&quot;, id: 20&#125;) 总结本文提供了golang反射包的基本api和方法，讲述了如何使用reflect包动态获取参数类型和种类，以及结构体和机构体指针成员等。接着我们讨论了方法的获取和调用。反射是golang提供的强大功能，可以动态获取和判断类型，调用成员方法等。反射是一把双刃剑，提供动态获取类型和动态调用的强大功能，同时也会造成程序效率的衰退，因为反射是通过类型转换和循环遍历探测其类型达到的，建议适度使用，在能确定类型时尽量用interface进行转换。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go进阶篇(01) interface应用和复习","date":"2019-10-11T07:10:37.000Z","path":"2019/10/11/golang15/","text":"interface 意义？golang 为什么要创造interface这种机制呢？我个人认为最主要的就是做约束，定义一种规范，大家可以按照同一种规范实现各自的功能，从而实现多态。同时当interface做函数形参，可以很好地限制传入参数，并且根据不同的实参调用达到多态的效果。多态的意思就是多种多样的功能，比如我们定义了一个接口 1234type IOInter interface&#123; write()int read()int&#125; 定义了一个IOInter的接口，只要别人实现了write和read方法，都可以转化为这个接口。至于具体怎么读，读什么，网络IO还是文件IO取决于具体的实现，这就形成了多样化的功能，从而实现多态。同时IOInter做函数的形参， 123func WriteFunc(io IOInter)&#123; io.Write()&#125; 还达到了安全限制的功能。比如没有实现读写功能的类实例无法传给WriteFunc,WriteFunc内部调用io的Write函数会根据实参具体的实现完成特定的读写。我们通过一个小例子实战下接口做形参的意义。golang中sort包提供了几个排序api，我们先实现一个int类型slice排序功能。 123 arrayint := []int&#123;6, 1, 0, 5, 2, 7&#125;sort.Ints(arrayint)fmt.Println(arrayint) sort.Ints可以完成对整形slice的排序，同样sort.Strings可以完成对string类型slice的排序 123 arraystring := []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;Alis&quot;, &quot;and&quot;, &quot;Bob&quot;&#125;sort.Strings(arraystring)fmt.Println(arraystring) 如果有这样一个需求，游戏中有很多个英雄，每个英雄有四个属性，攻击，防御，名字，出生时间，对这些英雄排序，从小到大，优先按照攻击排序，其次攻击相等的按照防御排序，如果防御相等的按照出生时间排序。这是比较规则，我们根据sort包的Sort函数可以实现这个功能。首先我们先定义英雄的结构 123456type Hero struct &#123; Name string Attack int Defence int GenTime int64&#125; 其次我们再定义一个英雄列表 1type HeroList []*Hero 接下来，我们看看golang的sort包实现的Sort源码 1234func Sort(data Interface) &#123; n := data.Len() quickSort(data, 0, n, maxDepth(n))&#125; 可以看出，Sort函数有一个Interface类型的形参，我们继续查看Interface的类型 123456789type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 可以看出Interface是一个接口，内部声明了三个方法Len,Less,Swap.我们需要给自己的英雄列表实现这三个方法，就可以调用Sort排序了。先实现Len方法。 123func (hl HeroList) Len() int &#123; return len(hl)&#125; Len功能很简单，就是实现了列表大小的获取。接下来实现比较函数Less,Less是按照我们之前说的英雄比较规则实现 1234567891011121314151617181920func (hl HeroList) Less(i, j int) bool &#123; if i &lt; 0 || j &lt; 0 &#123; return true &#125; lenth := len(hl) if i &gt;= lenth || j &gt;= lenth &#123; return true &#125; if hl[i].Attack != hl[j].Attack &#123; return hl[i].Attack &lt; hl[j].Attack &#125; if hl[i].Defence != hl[j].Defence &#123; return hl[i].Defence &lt; hl[j].Defence &#125; return hl[i].GenTime &lt; hl[j].GenTime&#125; 优先判断攻击是否相等，不相等就按照攻击力大小排序，小于返回true，从而实现从小到大排序其次，攻击相等按照防御排序，以此类推。接下来实现交换函数，交换英雄列表中的两个英雄 12345678910111213func (hl HeroList) Swap(i, j int) &#123; if i &lt; 0 || j &lt; 0 &#123; return &#125; lenth := len(hl) if i &gt;= lenth || j &gt;= lenth &#123; return &#125; hl[i], hl[j] = hl[j], hl[i]&#125; 这样，我们的英雄列表功能和结构都设计好了，写个main函数测试下 12345678910111213141516171819//自定义类型排序用sort.Sort var herolists HeroList for i := 0; i &lt; 10; i++ &#123; generate := time.Now().Unix() name := fmt.Sprintf(&quot;Hero%d&quot;, generate) hero := Hero&#123; Name: name, Attack: rand.Intn(100), Defence: rand.Intn(200), GenTime: generate, &#125; herolists = append(herolists, &amp;hero) time.Sleep(time.Duration(1) * time.Second) &#125; sort.Sort(herolists) for _, value := range herolists &#123; fmt.Print(value.Name, &quot; &quot;, value.Attack, &quot; &quot;, value.Defence, &quot; &quot;, value.GenTime, &quot;\\n&quot;) &#125; 我们通过for循环，每一秒生成一个英雄，攻击力和防御力随机，然后调用sort排序，接下来打印下看看效果 12345678910Hero1570780749 11 45 1570780749Hero1570780744 25 140 1570780744Hero1570780748 28 74 1570780748Hero1570780750 37 106 1570780750Hero1570780742 47 59 1570780742Hero1570780745 56 100 1570780745Hero1570780747 62 89 1570780747Hero1570780741 81 87 1570780741Hero1570780743 81 118 1570780743Hero1570780746 94 111 1570780746 看的出来，优先按照攻击力排序，攻击力相同则按照防御值排序。这样，这个排序的小功能就做好了。 interface万能接口interface{}空接口可以接受任何类型的变量，从而可以实现类似于泛型编程的功能。golang本身并不支持泛型，原作者说泛型编程太过复杂，以后会更新进来。interface{}类型的变量在使用时要转化为具体的类型，否则会报错。转化方法前文提起过，现在复习一遍 12345678 var ife interface&#123;&#125;ife = herolistsval, ok := ife.(HeroList)if !ok &#123; fmt.Println(&quot;ife can&#x27;t transfer to HeroList!&quot;) return&#125;fmt.Println(&quot;herolist&#x27;s len is &quot;, val.Len()) herolists是上个例子定义的英雄列表，将它赋值给ife后，ife为interface{}类型,不能直接使用，所以用ife.(HeroList)来转换为HeroList类型。当然interface{}还可以做类型判断 123456789101112func JudgeType(itf interface&#123;&#125;) &#123; switch itf.(type) &#123; case string: fmt.Println(&quot;type is string&quot;) case int: fmt.Println(&quot;type is int&quot;) case HeroList: fmt.Println(&quot;type is HeroList&quot;) default: fmt.Println(&quot;unknown type &quot;) &#125;&#125; interface实现万能类型双向链表基于上面的知识，我们再做一个例子，实现双向链表，支持头部插入，尾部插入，指定位置插入，指定位置删除，可存储任意类型数据我们先定义链表的基本结构 12345678910type LinkList struct &#123; Head *LinkEle Tail *LinkEle&#125;type LinkEle struct &#123; Data interface&#123;&#125; Pre *LinkEle Next *LinkEle&#125; LinkeEle是链表中的每个节点类型，包含Data数据域，其为interface{}类型，以及Pre指向前一个节点的指针，Next指向后一个节点的指针。LinkList是链表结构，包含头和尾部节点的指针好的，为了方便取出节点数据域，我们给LinkEle实现一个GetData方法。 123func (le *LinkEle) GetData() interface&#123;&#125; &#123; return le.Data&#125; 接下来我们实现插入操作，实现头部插入,基本思路为在头部节点前插入新节点，然后将新节点和头部节点连接，更新新节点为头部节点 12345678910111213func (ll *LinkList) InsertHead(le *LinkEle) &#123; if ll.Tail == nil &amp;&amp; ll.Head == nil &#123; ll.Tail = le ll.Head = ll.Tail return &#125; ll.Head.Pre = le le.Pre = nil le.Next = ll.Head ll.Head = le&#125; 上面先判断链表是否为空，如果链表为空，那么直接更新头尾信息即可，否则就需要执行连接操作。同样的道理我们实现尾部插入尾部插入实在尾部节点的后边插入 1234567891011func (ll *LinkList) InsertTail(le *LinkEle) &#123; if ll.Tail == nil &amp;&amp; ll.Head == nil &#123; ll.Tail = le ll.Head = ll.Tail return &#125; ll.Tail.Next = le le.Pre = ll.Tail le.Next = nil ll.Tail = le&#125; 我们测试下实现的功能 123456789101112131415161718192021222324252627282930313233343536 ll := &amp;LinkList&#123;nil, nil&#125;fmt.Println(&quot;insert head .....................&quot;)for i := 0; i &lt; 2; i++ &#123; num := rand.Intn(100) node1 := &amp;LinkEle&#123;Data: num, Next: nil, Pre: nil&#125; ll.InsertHead(node1) fmt.Println(num)&#125;fmt.Println(&quot;after insert head .................&quot;)for node := ll.Head; node != nil; node = node.Next &#123; val, ok := node.GetData().(int) if !ok &#123; fmt.Println(&quot;interface transfer error&quot;) break &#125; fmt.Println(val)&#125;fmt.Println(&quot;insert tail .....................&quot;)for i := 0; i &lt; 2; i++ &#123; num := rand.Intn(100) node1 := &amp;LinkEle&#123;Data: num, Next: nil, Pre: nil&#125; ll.InsertTail(node1) fmt.Println(num)&#125;fmt.Println(&quot;after insert tail .................&quot;)for node := ll.Head; node != nil; node = node.Next &#123; val, ok := node.GetData().(int) if !ok &#123; fmt.Println(&quot;interface transfer error&quot;) break &#125; fmt.Println(val)&#125; 我们初始化了一个LinkList类型的链表变量ll,然后在头部插入两个节点，在尾部插入两个节点,看看效果 1234567891011121314insert head .....................8187after insert head .................8781insert tail .....................4759after insert tail .................87814759 头部插入先插入81,然后插入87，所以列表变为87,81接着尾部插入47,59，列表变为87,81,47,59接下来实现在指定位置的节点后插入节点 123456789101112131415161718192021222324252627282930313233343536373839404142func (ll *LinkList) InsertIndex(le *LinkEle, index int) &#123; if index &lt; 0 &#123; return &#125; if ll.Head == nil &#123; ll.Head = le ll.Tail = ll.Head return &#125; node := ll.Head indexfind := 0 for ; indexfind &lt; index; indexfind++ &#123; if node.Next == nil &#123; break &#125; node = node.Next &#125; if indexfind != index &#123; fmt.Println(&quot;index is out of range&quot;) return &#125; //node 后边的节点缓存起来 nextnode := node.Next //node 和le连接起来 node.Next = le le.Pre = node if node == ll.Tail &#123; ll.Tail = le return &#125; //le和next node 连接起来 if nextnode != nil &#123; nextnode.Pre = le le.Next = nextnode &#125;&#125; 首先判断链表是否为空，如果为空，则直接更新节点为列表头尾节点。否则判断插入位置是否越界，如果越界则直接返回。如果不越界，则将节点插入，并判断插入节点是否为最后位置，如果为最后位置，则更新其为尾结点。接下来我们测试在第三个节点后边插入节点。补充代码如下，前边的插入不变，看下效果 1234567891011121314151617fmt.Println(&quot;insert after third element........&quot;) &#123; num := rand.Intn(100) node1 := &amp;LinkEle&#123;Data: num, Next: nil, Pre: nil&#125; ll.InsertIndex(node1, 2) fmt.Println(num) &#125; fmt.Println(&quot;after insert index .................&quot;) for node := ll.Head; node != nil; node = node.Next &#123; val, ok := node.GetData().(int) if !ok &#123; fmt.Println(&quot;interface transfer error&quot;) break &#125; fmt.Println(val) &#125; 结果如下 12345678910111213141516171819202122insert head .....................8187after insert head .................8781insert tail .....................4759after insert tail .................87814759insert after third element........81after insert index .................8781478159 前边是头部和尾部插入的输出，接着我们在第三个位置节点后插入81,打印看到确实插入在了47的后边。同样我们接下来实现删除操作，删除指定位置的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func (ll *LinkList) DelIndex(index int) &#123; if index &lt; 0 &#123; return &#125; if ll.Head == nil &#123; return &#125; node := ll.Head indexfind := 0 for ; indexfind &lt; index; indexfind++ &#123; if node.Next == nil &#123; break &#125; node = node.Next &#125; if indexfind != index &#123; fmt.Println(&quot;index is out of range&quot;) return &#125; if ll.Head == ll.Tail &#123; ll.Tail = nil ll.Head = ll.Tail return &#125; //如果是头节点 if node == ll.Head &#123; ll.Head = node.Next node.Next.Pre = nil return &#125; //如果是尾结点 if node == ll.Tail &#123; ll.Tail = node.Pre ll.Tail.Next = nil return &#125; //将前后连接起来 node.Pre.Next = node.Next node.Next.Pre = node.Pre&#125; 和插入操作类似，判断是否为空链表，是否只有一个节点等情况，接着判断删除的是否为头结点，是否为尾节点，否则就执行删除后的连接操作。继续上边的测试代码，我们添加如下测试代码补充测试 1234567891011fmt.Println(&quot;delete second element, its index is 1&quot;) ll.DelIndex(1) fmt.Println(&quot;after delete second element, its index is 1&quot;) for node := ll.Head; node != nil; node = node.Next &#123; val, ok := node.GetData().(int) if !ok &#123; fmt.Println(&quot;interface transfer error&quot;) break &#125; fmt.Println(val) &#125; 输出如下 12345678910118781478159delete second element, its index is 1after delete second element, its index is 187478159 我们删除了index为1，也就是第二个节点81，测试成功了。由于链表的数据域Data为空接口类型，所以可以存储各种类型的数据，只需要在GetData时做具体类型转换即可。接下来读者可以自己考虑实现删除头部节点，删除尾部节点等。可以下载我的源码 :https://github.com/secondtonone1/golang-/tree/master/day26 总结本文通过两个小例子实战，演示了interface常用的用法，为接下来讲解反射做铺垫。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang 接口内部实现","date":"2019-09-24T06:16:53.000Z","path":"2019/09/24/golang14/","text":"前文介绍过golang interface用法，本文详细剖析interface内部实现和细节。 empty interface实现细节interface底层使用两种类型实现的，一个是eface，一个是iface。当interface中没有方法的时候，底层是通过eface实现的。当interface包含方法时，那么它的底层是通过iface实现的。对于iface和eface具体实现在go源码runtime2.go中，我们看下源码 1234type eface struct &#123; _type *_type data unsafe.Pointer&#125; 可以看到eface包含两个结构，一个是_type类型指针，一个是unsafe包的Pointer变量继续追踪Pointer 12type Pointer *ArbitraryTypetype ArbitraryType int 可以看出Pointer实际上是int类型的指针。我们再看看_type类型 12345678910111213141516type _type struct &#123; size uintptr ptrdata uintptr // size of memory prefix holding all pointers hash uint32 tflag tflag align uint8 fieldalign uint8 kind uint8 alg *typeAlg // gcdata stores the GC type data for the garbage collector. // If the KindGCProg bit is set in kind, gcdata is a GC program. // Otherwise it is a ptrmask bitmap. See mbitmap.go for details. gcdata *byte str nameOff ptrToThis typeOff&#125; size 为该类型所占用的字节数量。kind 表示类型的种类，如 bool、int、float、string、struct、interface 等。str 表示类型的名字信息，它是一个 nameOff(int32) 类型，通过这个 nameOff，可以找到类型的名字字符串 eface结构总结图eface 分两个部分， *_type 类型为实际类型转化为type类型的指针，data为实际数据。 具体类型如何转化为eface我们写一段程序efacedemo.go，然后用gobuild命令生成可执行文件，再用汇编查看下源码。 1234567891011121314151617181920package mainimport &quot;fmt&quot;type EmpInter interface &#123;&#125;type EmpStruct struct &#123; num int&#125;func main() &#123; emps := EmpStruct&#123;num: 1&#125; var empi EmpInter empi = emps fmt.Println(empi) fmt.Println(emps)&#125; 先用gcflags标记编译生成可执行文件efacedemogo build -gcflags “-l” -o efacedemo efacedemo.go然后执行go tool objdump 将 可执行程序efacedemo中main包的main函数转为汇编代码go tool objdump -s “main.main” efacedemo 1234567891011121314151617181920212223242526272829303132333435363738efacedemo.go:12 0x48ffa0 65488b0c2528000000 MOVQ GS:0x28, CX efacedemo.go:12 0x48ffa9 488b8900000000 MOVQ 0(CX), CX efacedemo.go:12 0x48ffb0 483b6110 CMPQ 0x10(CX), SP efacedemo.go:12 0x48ffb4 0f86ae000000 JBE 0x490068 efacedemo.go:12 0x48ffba 4883ec48 SUBQ $0x48, SP efacedemo.go:12 0x48ffbe 48896c2440 MOVQ BP, 0x40(SP) efacedemo.go:12 0x48ffc3 488d6c2440 LEAQ 0x40(SP), BP efacedemo.go:16 0x48ffc8 48c7042401000000 MOVQ $0x1, 0(SP) efacedemo.go:16 0x48ffd0 e8fb89f7ff CALL runtime.convT64(SB) //注意这里调用runtime包的convT64函数 efacedemo.go:16 0x48ffd5 488b442408 MOVQ 0x8(SP), AX efacedemo.go:17 0x48ffda 0f57c0 XORPS X0, X0 efacedemo.go:17 0x48ffdd 0f11442430 MOVUPS X0, 0x30(SP) efacedemo.go:17 0x48ffe2 488d0d17c20100 LEAQ runtime.types+111104(SB efacedemo.go:17 0x48ffe9 48894c2430 MOVQ CX, 0x30(SP) efacedemo.go:17 0x48ffee 4889442438 MOVQ AX, 0x38(SP) efacedemo.go:17 0x48fff3 488d442430 LEAQ 0x30(SP), AX efacedemo.go:17 0x48fff8 48890424 MOVQ AX, 0(SP) efacedemo.go:17 0x48fffc 48c744240801000000 MOVQ $0x1, 0x8(SP) efacedemo.go:17 0x490005 48c744241001000000 MOVQ $0x1, 0x10(SP) efacedemo.go:17 0x49000e e8fd98ffff CALL fmt.Println(SB) efacedemo.go:18 0x490013 48c7042401000000 MOVQ $0x1, 0(SP) efacedemo.go:18 0x49001b e8b089f7ff CALL runtime.convT64(SB) //注意这里调用runtime包的convT64函数 efacedemo.go:18 0x490020 488b442408 MOVQ 0x8(SP), AX efacedemo.go:18 0x490025 0f57c0 XORPS X0, X0 efacedemo.go:18 0x490028 0f11442430 MOVUPS X0, 0x30(SP) efacedemo.go:18 0x49002d 488d0dccc10100 LEAQ runtime.types+111104(SB efacedemo.go:18 0x490034 48894c2430 MOVQ CX, 0x30(SP) efacedemo.go:18 0x490039 4889442438 MOVQ AX, 0x38(SP) efacedemo.go:18 0x49003e 488d442430 LEAQ 0x30(SP), AX efacedemo.go:18 0x490043 48890424 MOVQ AX, 0(SP) efacedemo.go:18 0x490047 48c744240801000000 MOVQ $0x1, 0x8(SP) efacedemo.go:18 0x490050 48c744241001000000 MOVQ $0x1, 0x10(SP) efacedemo.go:18 0x490059 e8b298ffff CALL fmt.Println(SB) efacedemo.go:20 0x49005e 488b6c2440 MOVQ 0x40(SP), BP efacedemo.go:20 0x490063 4883c448 ADDQ $0x48, SP efacedemo.go:20 0x490067 c3 RET efacedemo.go:12 0x490068 e883f2fbff CALL runtime.morestack_noctx efacedemo.go:12 0x49006d e92effffff JMP main.main(SB) 抛开寄存器寻址和寄存数据不谈，我们看到efacedemo.go:16行， CALL runtime.convT64(SB)语句说明调用了runtime包的convT64函数这个函数在runtime.go 中有声明 1234567// Specialized type-to-interface conversion.// These return only a data pointer.func convT16(val any) unsafe.Pointer // val must be uint16-like (same size and alignment as a uint16)func convT32(val any) unsafe.Pointer // val must be uint32-like (same size and alignment as a uint32)func convT64(val any) unsafe.Pointer // val must be uint64-like (same size and alignment as a uint64 and contains no pointers)func convTstring(val any) unsafe.Pointer // val must be a stringfunc convTslice(val any) unsafe.Pointer // val must be a slice 看注释就知道是type类型转化为interface类型，计算机将EmpStruct强制转化为type类型后，type类型进一步转化为interface，并且将EmpStruct数据转化为unsafe.Pointer,毕竟int在64位机器中为8字节，所以采用了convT64函数。还有一个函数convT2E,这个函数是将type转化为eface类型，大家可以读一读runtime源码。convT2E源码 123456789101112131415func convT2E(t *_type, elem unsafe.Pointer) (e eface) &#123; if raceenabled &#123; raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2E)) &#125; if msanenabled &#123; msanread(elem, t.size) &#125; x := mallocgc(t.size, t, true) // TODO: We allocate a zeroed object only to overwrite it with actual data. // Figure out how to avoid zeroing. Also below in convT2Eslice, convT2I, convT2Islice. typedmemmove(t, x, elem) e._type = t e.data = x return&#125; 内部调用了typedmemove做类型判断，所以一个类能否转化为某个接口是在runtime这一层做判断的。判断条件就是我之前所说的是否实现了该接口所有的方法。将上面的代码用eface图解就是 具体类型如何转换为iface当接口中带有方法的时候，接口底层的实现就是通过iface结构实现的。我们下一个带方法的接口，然后反汇编一下。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;type EmpInter interface &#123; GetNum() int&#125;type EmpStruct struct &#123; num int&#125;func (es *EmpStruct) GetNum() int &#123; return es.num&#125;func main() &#123; emps := EmpStruct&#123;num: 1&#125; var empi EmpInter empi = &amp;emps fmt.Println(empi) fmt.Println(emps)&#125; 和之前操作一样，先编译go build -gcflags “-l” -o ifacedemo ifacedemo.go然后反汇编找到指令go tool objdump -s “main.main” ifacedemo生成的汇编指令如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ifacedemo.go:17 0x48ffb0 65488b0c2528000000 MOVQ GS:0x28, CX ifacedemo.go:17 0x48ffb9 488b8900000000 MOVQ 0(CX), CX ifacedemo.go:17 0x48ffc0 483b6110 CMPQ 0x10(CX), SP ifacedemo.go:17 0x48ffc4 0f86c1000000 JBE 0x49008b ifacedemo.go:17 0x48ffca 4883ec50 SUBQ $0x50, SP ifacedemo.go:17 0x48ffce 48896c2448 MOVQ BP, 0x48(SP) ifacedemo.go:17 0x48ffd3 488d6c2448 LEAQ 0x48(SP), BP ifacedemo.go:19 0x48ffd8 488d0521c30100 LEAQ runtime.types+111360(SB), AX ifacedemo.go:19 0x48ffdf 48890424 MOVQ AX, 0(SP) ifacedemo.go:19 0x48ffe3 e868b3f7ff CALL runtime.newobject(SB) ifacedemo.go:19 0x48ffe8 488b442408 MOVQ 0x8(SP), AX ifacedemo.go:19 0x48ffed 4889442430 MOVQ AX, 0x30(SP) ifacedemo.go:19 0x48fff2 48c70001000000 MOVQ $0x1, 0(AX) ifacedemo.go:22 0x48fff9 488b0d48ce0400 MOVQ go.itab.*main.EmpStruct,main.EmpInter+8(SB), CX ifacedemo.go:22 0x490000 0f57c0 XORPS X0, X0 ifacedemo.go:22 0x490003 0f11442438 MOVUPS X0, 0x38(SP) ifacedemo.go:22 0x490008 48894c2438 MOVQ CX, 0x38(SP) ifacedemo.go:22 0x49000d 4889442440 MOVQ AX, 0x40(SP) ifacedemo.go:22 0x490012 488d4c2438 LEAQ 0x38(SP), CX ifacedemo.go:22 0x490017 48890c24 MOVQ CX, 0(SP) ifacedemo.go:22 0x49001b 48c744240801000000 MOVQ $0x1, 0x8(SP) ifacedemo.go:22 0x490024 48c744241001000000 MOVQ $0x1, 0x10(SP) ifacedemo.go:22 0x49002d e8de98ffff CALL fmt.Println(SB) ifacedemo.go:23 0x490032 488b442430 MOVQ 0x30(SP), AX ifacedemo.go:23 0x490037 488b00 MOVQ 0(AX), AX ifacedemo.go:23 0x49003a 48890424 MOVQ AX, 0(SP) ifacedemo.go:23 0x49003e e88d89f7ff CALL runtime.convT64(SB) ifacedemo.go:23 0x490043 488b442408 MOVQ 0x8(SP), AX ifacedemo.go:23 0x490048 0f57c0 XORPS X0, X0 ifacedemo.go:23 0x49004b 0f11442438 MOVUPS X0, 0x38(SP) ifacedemo.go:23 0x490050 488d0da9c20100 LEAQ runtime.types+111360(SB), CX ifacedemo.go:23 0x490057 48894c2438 MOVQ CX, 0x38(SP) ifacedemo.go:23 0x49005c 4889442440 MOVQ AX, 0x40(SP) ifacedemo.go:23 0x490061 488d442438 LEAQ 0x38(SP), AX ifacedemo.go:23 0x490066 48890424 MOVQ AX, 0(SP) ifacedemo.go:23 0x49006a 48c744240801000000 MOVQ $0x1, 0x8(SP) ifacedemo.go:23 0x490073 48c744241001000000 MOVQ $0x1, 0x10(SP) ifacedemo.go:23 0x49007c e88f98ffff CALL fmt.Println(SB) ifacedemo.go:25 0x490081 488b6c2448 MOVQ 0x48(SP), BP ifacedemo.go:25 0x490086 4883c450 ADDQ $0x50, SP ifacedemo.go:25 0x49008a c3 RET ifacedemo.go:17 0x49008b e860f2fbff CALL runtime.morestack_noctxt(SB) ifacedemo.go:17 0x490090 e91bffffff JMP main.main(SB) :-1 0x490095 cc INT $0x3 :-1 0x490096 cc INT $0x3 :-1 0x490097 cc INT $0x3 :-1 0x490098 cc INT $0x3 :-1 0x490099 cc INT $0x3 :-1 0x49009a cc INT $0x3 :-1 0x49009b cc INT $0x3 :-1 0x49009c cc INT $0x3 :-1 0x49009d cc INT $0x3 :-1 0x49009e cc INT $0x3 :-1 0x49009f cc INT $0x3 抛开寄存器寻址和移动数据，我们查看call和重要的数据copy19行LEAQ runtime.types+111360(SB), AX做了类型上的转换19行CALL runtime.newobject(SB)调用了runtime包的newobject方法，开辟我们结构体的指针22行MOVQ go.itab.*main.EmpStruct,main.EmpInter+8(SB), CX将我们结构体部分信息保存在itab中。23行 CALL runtime.convT64(SB)， 实际上将64位的num转化为数据存在data域中。这些函数都可以在runtime包中找到，读者可以自己阅读。另外，还有个重要函数convT2I 1234567891011121314func convT2I(tab *itab, elem unsafe.Pointer) (i iface) &#123; t := tab._type if raceenabled &#123; raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) &#125; if msanenabled &#123; msanread(elem, t.size) &#125; x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return&#125; 这个函数将Type类型转化为Iface类型。类似的函数还有convT2Inoptr(Type转Iface指针)。读者可以自己阅读源码。通过上面的调试和分析，我们知道iface中结构和eface略有不同，多出一个itab类型的结构，我们看看iface源码 1234type iface struct &#123; tab *itab data unsafe.Pointer&#125; 和eface不同，iface的第一个字段是itab指针。我们继续查看itab的定义 1234567type itab struct &#123; inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.&#125; itab 各参数含义inter和_type共同确认实际的类型信息，因为在接口中有方法的时候，itab要保存接口方法的一些额外信息，如名字，类型等。hash 用于查询类型和判断类型，比如接口赋值，接口转换判断等。fun 为具体的方法集，所有的方法保存在fun里。虽然fun大小为1，但是这其实是一个柔型数组，后面的地址空间连续且安全，后面能存多少函数，取决于itab初始化多大的空间。 图解iface结构结合代码，具象化的绘制一下以上就是interface内部结构和动态调用的原理。根据fun方法集动态调用具体类的方法，从而实现了多态。 gdb调试除了可以通过反汇编的方式查看代码指令，其实通过汇编查看函数调用也是很不错的手段。 go build -gcflags “-N -l” -o ifacedemo ifacedemo.go 先编译出可执行文件, -N 忽略优化 然后gdb调试 gdb ifacedemo 进入gdb调试界面 1234567891011 (gdb) list 2015 &#125;16 17 func main() &#123;18 19 emps := EmpStruct&#123;num: 1&#125;20 var empi EmpInter21 empi = &amp;emps22 fmt.Println(empi)23 fmt.Println(emps)24 输入list 20 为了列举 20行左右代码，然后我们在22行处打个断点,执行run让程序跑在断点处停止 12345678910(gdb) break 22Breakpoint 1 at 0x4872ea: file /home/secondtonone/workspace/goProject/src/golang-/ifacedemo/ifacedemo.go, line 22.(gdb) run Starting program: /home/secondtonone/workspace/goProject/src/golang-/ifacedemo/ifacedemo [New LWP 9562][New LWP 9563][New LWP 9564]Thread 1 &quot;ifacedemo&quot; hit Breakpoint 1, main.main () at /home/secondtonone/workspace/goProject/src/golang-/ifacedemo/ifacedemo.go:2222 fmt.Println(empi) 接下来我们查看下empi这个接口的数据信息 12(gdb) p empi$1 = &#123;tab = 0x4d0ee0 &lt;EmpStruct,main.EmpInter&gt;, data = 0xc000078010&#125; 看得出empi是iface结构的，包含tab和data两个字段。 我们查看下tab里的内容 1234(gdb) p empi.tab $2 = (runtime.itab *) 0x4d0ee0 &lt;EmpStruct,main.EmpInter&gt;(gdb) p *empi.tab$3 = &#123;inter = 0x4a17a0, _type = 0x49f3c0, hash = 4144246241, _ = &quot;\\000\\000\\000&quot;, fun = &#123;4747840&#125;&#125; 可以看得出 tab是个地址，我们*解引用看到内部内容和上面所述一样，inter, _type, hash, 函数集合fun 接下来我们将代码反汇编 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 (gdb) disassDump of assembler code for function main.main: 0x0000000000487260 &lt;+0&gt;: mov %fs:0xfffffffffffffff8,%rcx 0x0000000000487269 &lt;+9&gt;: lea -0x58(%rsp),%rax 0x000000000048726e &lt;+14&gt;: cmp 0x10(%rcx),%rax 0x0000000000487272 &lt;+18&gt;: jbe 0x487443 &lt;main.main+483&gt; 0x0000000000487278 &lt;+24&gt;: sub $0xd8,%rsp 0x000000000048727f &lt;+31&gt;: mov %rbp,0xd0(%rsp) 0x0000000000487287 &lt;+39&gt;: lea 0xd0(%rsp),%rbp 0x000000000048728f &lt;+47&gt;: lea 0x1b22a(%rip),%rax # 0x4a24c0 0x0000000000487296 &lt;+54&gt;: mov %rax,(%rsp) 0x000000000048729a &lt;+58&gt;: callq 0x40b070 &lt;runtime.newobject&gt; 0x000000000048729f &lt;+63&gt;: mov 0x8(%rsp),%rax 0x00000000004872a4 &lt;+68&gt;: mov %rax,0x68(%rsp) 0x00000000004872a9 &lt;+73&gt;: movq $0x0,0x30(%rsp) 0x00000000004872b2 &lt;+82&gt;: movq $0x1,0x30(%rsp) 0x00000000004872bb &lt;+91&gt;: mov 0x68(%rsp),%rax 0x00000000004872c0 &lt;+96&gt;: movq $0x1,(%rax) 0x00000000004872c7 &lt;+103&gt;: xorps %xmm0,%xmm0 0x00000000004872ca &lt;+106&gt;: movups %xmm0,0x70(%rsp) 0x00000000004872cf &lt;+111&gt;: mov 0x68(%rsp),%rax 0x00000000004872d4 &lt;+116&gt;: mov %rax,0x50(%rsp) 0x00000000004872d9 &lt;+121&gt;: lea 0x49c00(%rip),%rcx # 0x4d0ee0 &lt;go.itab.*main.EmpStruct,main.EmpInter&gt; 0x00000000004872e0 &lt;+128&gt;: mov %rcx,0x70(%rsp) 0x00000000004872e5 &lt;+133&gt;: mov %rax,0x78(%rsp) 0x00000000004872ea &lt;+138&gt;: mov 0x78(%rsp),%rax 0x00000000004872ef &lt;+143&gt;: mov 0x70(%rsp),%rcx 0x00000000004872f4 &lt;+148&gt;: mov %rcx,0x80(%rsp) 0x00000000004872fc &lt;+156&gt;: mov %rax,0x88(%rsp) 0x0000000000487304 &lt;+164&gt;: mov %rcx,0x48(%rsp) 0x0000000000487309 &lt;+169&gt;: cmpq $0x0,0x48(%rsp) 0x000000000048730f &lt;+175&gt;: jne 0x487316 &lt;main.main+182&gt; 0x0000000000487311 &lt;+177&gt;: jmpq 0x48743e &lt;main.main+478&gt; 0x0000000000487316 &lt;+182&gt;: test %al,(%rcx) 0x0000000000487318 &lt;+184&gt;: mov 0x8(%rcx),%rax 0x000000000048731c &lt;+188&gt;: mov %rax,0x48(%rsp) 0x0000000000487321 &lt;+193&gt;: jmp 0x487323 &lt;main.main+195&gt; 0x0000000000487323 &lt;+195&gt;: xorps %xmm0,%xmm0 0x0000000000487326 &lt;+198&gt;: movups %xmm0,0x90(%rsp) 0x000000000048732e &lt;+206&gt;: lea 0x90(%rsp),%rax 0x0000000000487336 &lt;+214&gt;: mov %rax,0x40(%rsp) 0x000000000048733b &lt;+219&gt;: test %al,(%rax) 0x000000000048733d &lt;+221&gt;: mov 0x48(%rsp),%rcx 0x0000000000487342 &lt;+226&gt;: mov 0x88(%rsp),%rdx 0x000000000048734a &lt;+234&gt;: mov %rcx,0x90(%rsp) 0x0000000000487352 &lt;+242&gt;: mov %rdx,0x98(%rsp) 0x000000000048735a &lt;+250&gt;: test %al,(%rax) 0x000000000048735c &lt;+252&gt;: jmp 0x48735e &lt;main.main+254&gt; 0x000000000048735e &lt;+254&gt;: mov %rax,0xa0(%rsp) 0x0000000000487366 &lt;+262&gt;: movq $0x1,0xa8(%rsp) 0x0000000000487372 &lt;+274&gt;: movq $0x1,0xb0(%rsp) 0x000000000048737e &lt;+286&gt;: mov %rax,(%rsp) 0x0000000000487382 &lt;+290&gt;: movq $0x1,0x8(%rsp) 0x000000000048738b &lt;+299&gt;: movq $0x1,0x10(%rsp) 0x0000000000487394 &lt;+308&gt;: callq 0x480c60 &lt;fmt.Println&gt;=&gt; 0x0000000000487399 &lt;+313&gt;: mov 0x68(%rsp),%rax 0x000000000048739e &lt;+318&gt;: mov (%rax),%rax 0x00000000004873a1 &lt;+321&gt;: mov %rax,0x38(%rsp) 0x00000000004873a6 &lt;+326&gt;: mov %rax,(%rsp) 0x00000000004873aa &lt;+330&gt;: callq 0x408950 &lt;runtime.convT64&gt; 0x00000000004873af &lt;+335&gt;: mov 0x8(%rsp),%rax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 显示的就是在main包main函数的反汇编。和我们之前用tool工具看到的一样。 到此为止，interface内部结构和特性介绍完毕 感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang接口","date":"2019-09-12T06:59:46.000Z","path":"2019/09/12/golang13/","text":"接口简介golang 中接口是常用的数据结构，接口可以实现like的功能。什么叫like呢？比如麻雀会飞，老鹰会飞，他们都是鸟，鸟有翅膀可以飞。飞机也可以飞，飞机就是像鸟一样，like bird, 所以我们可以说飞机，气球，苍蝇都像鸟一样可以飞翔。但他们不是鸟，那么对比继承的关系，老鹰继承自鸟类，它也会飞，但他是鸟。先看一个接口定义 123type Bird interface &#123; Fly() string&#125; 定义了一个Bird类型的interface， 内部生命了一个Fly方法，参数为空，返回值为string。接口声明方法和struct不同，接口的方法写在interface中，并且不能包含func和具体实现。另外interface内部不能声明成员变量。下面去实现蝴蝶类和飞机类，实现like-bird的功能。像鸟一样飞。 1234567891011121314151617type Plane struct &#123; name string&#125;func (p *Plane) Fly() string &#123; fmt.Println(p.name, &quot; can fly like a bird&quot;) return p.name&#125;type Butterfly struct &#123; name string&#125;func (bf *Butterfly) Fly() string &#123; fmt.Println(bf.name, &quot; can fly like a bird&quot;) return bf.name&#125; 实现了Plane和Butterfly类，并且实现了Fly方法。那么飞机和蝴蝶就可以像鸟一样飞了。我们在主函数中调用 12345 pl := &amp;Plane&#123;name: &quot;plane&quot;&#125;pl.Fly()bf := &amp;Butterfly&#123;name: &quot;butterfly&quot;&#125; bf.Fly() 输出如下 12plane can fly like a birdbutterfly can fly like a bird 有人会问，单独实现Plane和Butterfly不就好了，为什么要和Bird扯上关系呢？因为接口作为函数形参，可以接受不同的实参类型，只要这些实参实现了接口的方法，都可以达到动态调用不同实参的方法。 123func FlyLikeBird(bird Bird) &#123; bird.Fly()&#125; 下面我们在main函数中调用上面这个函数，传入不同的实参 12 FlyLikeBird(pl)FlyLikeBird(bf) 输出如下 12plane can fly like a birdbutterfly can fly like a bird 这样就是实现了动态调用。有点类似于C++的多态，golang又不是通过继承达到这个效果的，只要结构体实现了接口的方法就可以转化为接口类型。golang这种实现机制突破了Java，C++等传统静态语言显示继承的弊端。 接口类型转换和判断struct类型如果实现了接口方法，可以赋值给对应的接口类型，接口类型同样可以转化为struct类型。我们再写一个函数，通过该函数内部将bird接口转化为不同的类型，从而打印具体的传入类型。 123456789101112131415func GetFlyType(bird Bird) &#123; _, ok := bird.(*Butterfly) if ok &#123; fmt.Println(&quot;type is *butterfly&quot;) return &#125; _, ok = bird.(*Plane) if ok &#123; fmt.Println(&quot;type is *Plane&quot;) return &#125; fmt.Println(&quot;unknown type&quot;)&#125; main函数调用 123456func main() &#123; pl := &amp;Plane&#123;name: &quot;plane&quot;&#125; bf := &amp;Butterfly&#123;name: &quot;butterfly&quot;&#125; GetFlyType(pl) GetFlyType(bf)&#125; 输出如下 12type is *Planetype is *butterfly 看得出来接口也是可以转化为struct的。结构体变量, bool类型:=接口类型.(结构体类型)bool类型为false说明不能转化，true则能转化。 万能接口interface{}golang 提供了万能接口, 类型为interface{}, 任何具体的结构体类型都能转化为该类型。我们将之前判断类型的例子稍作修改。定义Human类和Human的Walk方法，然后实现另一个判断函数，参数为interface{} 1234567891011121314151617181920212223242526type Human struct &#123;&#125;func (*Human) Walk() &#123;&#125;func GetFlyType2(inter interface&#123;&#125;) &#123; _, ok := inter.(*Butterfly) if ok &#123; fmt.Println(&quot;type is *butterfly&quot;) return &#125; _, ok = inter.(*Plane) if ok &#123; fmt.Println(&quot;type is *Plane&quot;) return &#125; _, ok = inter.(*Human) if ok &#123; fmt.Println(&quot;type is *Human&quot;) return &#125; fmt.Println(&quot;unknown type&quot;)&#125; 在main函数中调用，我们看看结果 12345678func main() &#123; pl := &amp;Plane&#123;name: &quot;plane&quot;&#125; bf := &amp;Butterfly&#123;name: &quot;butterfly&quot;&#125; hu := &amp;Human&#123;&#125; GetFlyType2(pl) GetFlyType2(bf) GetFlyType2(hu)&#125; 看到输出 123type is *Planetype is *butterflytype is *Human .(type)判断具体类型接口还提供了一个功能，通过.(type)返回具体类型，但是.(type)只能用在switch中。我们实现另一个版本的类型判断 123456789101112func GetFlyType3(inter interface&#123;&#125;) &#123; switch inter.(type) &#123; case *Butterfly: fmt.Println(&quot;type is *Butterfly&quot;) case *Plane: fmt.Println(&quot;type is *Plane&quot;) case *Human: fmt.Println(&quot;type is *Human&quot;) default: fmt.Println(&quot;unknown type &quot;) &#125;&#125; main函数中调用这个函数 123 GetFlyType3(pl)GetFlyType3(bf)GetFlyType3(hu) 输出结果如下 123type is *Planetype is *Butterflytype is *Human 所以.(type)也实现了类型转换 这样接口基础都介绍完毕了，下一篇介绍接口内部实现和剖析。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang结构体","date":"2019-09-11T07:37:30.000Z","path":"2019/09/11/golang12/","text":"golang支持面向对象的设计，一般支持面向对象的语言都会有class的设计，但是golang没有class关键字，只有struct结构体。通过结构体达到类的效果，这叫做大成若缺，其用不弊。 struct简介在使用struct之前，先介绍golang的一个特性，golang允许用户将类型A定义为另一种类型B，并为类型B添加方法。 1234type Integer int func (a Integer) Less (b Integer) bool&#123; return a &lt; b&#125; 我们将int定义为一种新的类型Integer，Integer就和int不是一个类型了，这和C++不一样。然后为Integer添加了方法Less，所有Integer对象都可以使用Less方法。类似于C++的成员函数。下面我们使用一下 12345func main() &#123; var varint1 Integer = 100 var varint2 Integer = 200 fmt.Println(varint1.Less(varint2))&#125; 定义了两个变量varint1和varint2，调用了varint1的Less方法，输出true下面介绍struct的基本定义 12345//构造函数和初始化type Rect struct&#123; x,y float64 width, height float64&#125; 定义了一个结构体Rect，Rect包含四个成员，x,y为float64类型，width, height为float64类型。下面为Rect定义方法，计算矩形面积 123func (r* Rect) Area() float64&#123; return r.width* r.height&#125; golang结构体没有public,private等字段，是通过成员的大小写区分权限的。大写的结构体成员，别的包可以访问，小写的成员不可被别的包访问。Rect的成员都为小写，所以别的包无法访问，但是可以通过定义大写的方法，提供给别的包访问 12345678910111213141516171819func (r *Rect) GetX() float64 &#123; return r.x&#125;func (r *Rect) GetY() float64 &#123; return r.y&#125;func (r *Rect) Area() float64 &#123; return r.width * r.height&#125;func (r *Rect) GetWidth() float64 &#123; return r.width&#125;func (r *Rect) GetHeight() float64 &#123; return r.height&#125; 这样其他的包就可以通过Rect的方法访问Rect内部变量值了。 结构体方法和函数的区别结构体方法就好比是C++的成员函数，是类对象调用的方法。函数和结构体对象无关，可以自由编写。二者定义也有区别 1234567func (this* 结构体类型) 方法名(方法参数列表) 方法返回值&#123; //方法内部实现&#125;func 函数名(函数参数列表) 函数返回值&#123; //函数内部实现&#125; golang的精髓是组合123456789type Inner struct &#123; Name string Num int&#125;type Wrappers struct &#123; inner Inner Name string&#125; Wrappers 包含了Inner结构体，golang中叫做组合。下面写代码打印信息,我们先为Wrappers添加方法 12345func (wp *Wrappers) PrintInfo() &#123; fmt.Println(wp.Name) fmt.Println(wp.inner.Name) fmt.Println(wp.inner.Num)&#125; 定义变量调用方法 1234func main() &#123; wp := &amp;Wrappers&#123;Name: &quot;wrapper&quot;, inner: Inner&#123;Name: &quot;inner&quot;, Num: 100&#125;&#125; wp.PrintInfo()&#125; 打印结果如下 123wrapperinner100 组合后，打印内部成员inner的Name需要显示指定wp.inner.Name,因为默认打印wp.Name是Wrappers的。 匿名组合实现继承(派生)12345678910111213141516171819202122//匿名组合和派生type Base struct &#123; Name string&#125;func (base *Base) Foo() &#123; fmt.Println(&quot;this is Base Foo&quot;)&#125;func (base *Base) Bar() &#123; fmt.Println(&quot;this is Base Bar&quot;)&#125;type Foo struct &#123; //匿名组合 Base&#125;func (foo *Foo) Foo() &#123; foo.Base.Foo() fmt.Println(&quot;this is Foo Foo&quot;)&#125; Foo内部组合了Base,但是并没有显示指定成员名，Foo内部只写了Base类型，这叫做匿名组合，匿名组合会在Foo内部自动生成Base同名的成员变量Base，golang根据匿名组合，会认为Foo继承自Base，从而Foo拥有Base的方法和成员。下面写代码看看效果 1234567891011func main() &#123; foo := &amp;Foo&#123;&#125; //Foo继承Base，所以拥有Name属性 foo.Name = &quot;foobase&quot; //Foo 重写(覆盖)了Base的Foo foo.Foo() //Foo继承了Base的Bar函数 foo.Bar() //显示调用基类Base的Foo foo.Base.Foo()&#125; 由于Foo继承Base后重写了Foo方法，所以想要调用Base的Foo方法，需要显示调用。 匿名指针组合匿名组合如果是指针类型，在子类对象定义时需要显示初始化基类指针，否则会出问题。先定义匿名组合结构体 12345678910//匿名指针组合type DerivePoint struct &#123; *Base&#125;func (derivep *DerivePoint) Foo() bool &#123; fmt.Println(&quot;this is DerivePoint Foo&quot;) fmt.Println(&quot;inherit base ,name is &quot;, derivep.Name) return true&#125; 定义了DerivePoint类，和方法Foo，在Foo内部打印了derivep的Name，该Name继承自*Base下面调用 12dr := &amp;DerivePoint&#123;Base: &amp;Base&#123;Name: &quot;base&quot;&#125;&#125;dr.Foo() 输出如下 12this is DerivePoint Fooinherit base ,name is base 可见输出了Name值。 匿名组合造成命名冲突123456//重复定义，因为匿名组合默认用类型做变量名type MyJob struct &#123; *Logger Name string *log.Logger // duplicate field Logger&#125; MyJob匿名组合了Logger类和log.Logger类，由于匿名组合默认用类型做变量名，所以编译器会认为定义了两个Logger名的成员，从而报错，所以匿名组合一定要注意这一点。 多重继承golang 支持多重继承，实现多重继承只需要多个匿名组合即可。 golang结构体介绍完毕，关注我的公众号领取学习资料","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang 函数介绍","date":"2019-09-11T06:50:45.000Z","path":"2019/09/11/golang11/","text":"函数简介函数是编程语言中不可缺少的部分，在golang这门语言中函数是一等公民。也是使用好golang的必备技能。看下golang函数的格式 123func 函数名(函数参数)返回值类型&#123;&#125; 一个简单的函数 123func HelloFunc(str string) string&#123; return str&#125; 该函数返回传入的字符串,函数调用如下 1fmt.Println(Hello(&quot;Nice to meet you!&quot;)) 返回多个返回值golang 允许函数返回多个返回值 12345678func Add(a int, b int) (ret int, err error) &#123; if a &lt; 0 || b &lt; 0 &#123; //不允许负数相加 err = errors.New(&quot;should be non-negative numbers&quot;) return &#125; return a + b, nil&#125; 函数返回两个数相加的结果和错误，下面调用这个函数 123456res, err:=Add(100, 200) if err != nil&#123; fmt.Println(&quot;add error !&quot;) return&#125;fmt.Println(&quot;add result is &quot;, res) 函数内部可以使用标签123456789func myfunc() &#123; i := 0HERE: fmt.Println(i) i++ if i &lt; 10 &#123; goto HERE &#125;&#125; goto会跳转到fmt.Println(n)处继续执行，达到i循环自增并输出的效果 函数可变参数golang 中允许函数使用可变参数 123456//不定参数func myfuncv(args ...int) &#123; for _, arg := range args &#123; fmt.Println(arg) &#125;&#125; 可变参数的写法是参数名后加上…类型，我们调用一下这个函数 1myfuncv(1,2,4,7,8) 可变参数可以通过切片获取元素。再写一个函数 123456func myfuncv3(args ...int) &#123; //按原样传递 myfuncv(args...) //按切片传递 myfuncv(args[1:]...)&#125; 这个函数内部将参数用展开传递给myfuncv,args是一个切片，展开用…，这样myfuncv就可以继续处理了。下面来个复杂点的，带interface参数的函数 12345678910111213141516func MyPrintf(args ...interface&#123;&#125;) &#123; for _, arg := range args &#123; //interface 任意类型， //arg.(type)只能用于switch结构 switch arg.(type) &#123; case int: fmt.Println(arg, &quot;is an int value.&quot;) case string: fmt.Println(arg, &quot;is a string value.&quot;) case int64: fmt.Println(arg, &quot;is an int64 value&quot;) default: fmt.Println(arg, &quot;is an unknown type&quot;) &#125; &#125;&#125; MyPrintf函数将参数args遍历后根据类型判断，做出相应输出。interface类型的变量后边加上.(type)就可以返回他的类型。接口的相关知识之后讲解。目前就介绍到此，我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang 使用etcd","date":"2019-08-29T08:40:47.000Z","path":"2019/08/29/golang10/","text":"etcd 安装和配置下载etcd release版本：https://github.com/coreos/etcd/releases/我的是windows版本，下载win64的就行了，下载后进入文件夹，建立几个配置文件启动就行了，可以写yml文件，我是windows的就做成了bat命令。一般是一个节点对应一个配置，一个节点的配置如下yml文件版本 123456789name: etcd-1data-dir: .\\data\\etcd01 advertise-client-urls: http://127.0.0.1:2379 listen-client-urls: http://127.0.0.1:2379 listen-peer-urls: http://127.0.0.1:2380 initial-advertise-peer-urls: http://127.0.0.1:2380 initial-cluster-token: etcd-cluster-1 initial-cluster: etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^initial-cluster-state: new 各参数含义: 1234567891011121314151617etcd 命令含义`--name` etcd集群中的节点名，这里可以随意，可区分且不重复就行`--listen-peer-urls`监听的用于节点之间通信的url，可监听多个，集群内部将通过这些url进行数据交互(如选举，数据同步等) `--initial-advertise-peer-urls`建议用于节点之间通信的url，节点间将以该值进行通信。`--listen-client-urls`监听的用于客户端通信的url,同样可以监听多个。`--advertise-client-urls`建议使用的客户端通信url,该值用于etcd代理或etcd成员与etcd节点通信。`--initial-cluster-token etcd-cluster-1`节点的token值，设置该值后集群将生成唯一id,并为每个节点也生成唯一id,当使用相同配置文件再启动一个集群时，只要该token值不一样，etcd集群就不会相互影响。-`-initial-cluster`也就是集群中所有的initial-advertise-peer-urls 的合集`--initial-cluster-state new`新建集群的标志，初始化状态使用 new，建立之后改此值为 existing 当然我的是windows版本，那么我就写bat文件就行了，我建立了三个bat文件对应三个节点。start1.bat 1234567891011.\\etcd.exe --name etcd01 ^--data-dir .\\data\\etcd01 ^--advertise-client-urls http://127.0.0.1:2379 ^--listen-client-urls http://127.0.0.1:2379 ^--listen-peer-urls http://127.0.0.1:2380 ^--initial-advertise-peer-urls http://127.0.0.1:2380 ^--initial-cluster-token etcd-cluster-1 ^--initial-cluster etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^--initial-cluster-state newpause start2.bat 12345678910.\\etcd.exe --name etcd02 ^--data-dir .\\data\\etcd02 ^--advertise-client-urls http://127.0.0.1:3379 ^--listen-client-urls http://127.0.0.1:3379 ^--listen-peer-urls http://127.0.0.1:2381 ^--initial-advertise-peer-urls http://127.0.0.1:2381 ^--initial-cluster-token etcd-cluster-1 ^--initial-cluster etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^--initial-cluster-state newpause start3.bat 12345678910.\\etcd.exe --name etcd03 ^--data-dir .\\data\\etcd03 ^--advertise-client-urls http://127.0.0.1:4379 ^--listen-client-urls http://127.0.0.1:4379 ^--listen-peer-urls http://127.0.0.1:2382 ^--initial-advertise-peer-urls http://127.0.0.1:2382 ^--initial-cluster-token etcd-cluster-1 ^--initial-cluster etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^--initial-cluster-state newpause 这三个bat文件放在之前etcd解压的文件夹里，我的目录结构如下接下来分别启动弄三个bat文件，然后在终端输入./etcdctl member list查看节点和集群信息如果是yml文件写的配置，可以通过./etcd –config-file=/etc/etcd/conf.yml启动/etc/etcd/conf.yml是yml文件所在路径。 目前节点和集群启动完毕。 etcd 常用命令查询集群信息查看集群状态存储数据读取数据删除数据etcd api分为2.0版本和3.0版本使用3.0版本api需要在命令前加ETCDCTL_API=3 golang 访问etcd集群golang 安装etcd包 1go get go.etcd.io/etcd/clientv3 大部分会失败，去github克隆吧 1git clone https://github.com/etcd-io/etcd 接下来编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot; &quot;go.etcd.io/etcd/clientv3&quot;)const ( EtcdKey string = &quot;name&quot; EtcdVal string = &quot;zack&quot;)func main() &#123; //建立连接 cli, err := clientv3.New(clientv3.Config&#123; Endpoints: []string&#123;&quot;localhost:2379&quot;, &quot;localhost:3379&quot;, &quot;localhost:4379&quot;&#125;, DialTimeout: 5 * time.Second, &#125;) if err != nil &#123; fmt.Println(&quot;connect failed, err:&quot;, err) return &#125; fmt.Println(&quot;connect succ&quot;) defer cli.Close() //存储数据 ctx, cancel := context.WithTimeout(context.Background(), time.Second) _, err = cli.Put(ctx, EtcdKey, string(EtcdVal)) cancel() if err != nil &#123; fmt.Println(&quot;put failed, err:&quot;, err) return &#125; //读取数据 ctx, cancel = context.WithTimeout(context.Background(), time.Second) resp, err := cli.Get(ctx, EtcdKey) cancel() if err != nil &#123; fmt.Println(&quot;get failed, err:&quot;, err) return &#125; for _, ev := range resp.Kvs &#123; fmt.Printf(&quot;%s : %s\\n&quot;, ev.Key, ev.Value) &#125;&#125; 谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"解密定时器的实现细节","date":"2019-07-02T01:55:31.000Z","path":"2019/07/02/golang09/","text":"后端开发常常需要设计定时器，介于现在可用的网络库和第三方库较为全面，所以不需要我们自己造轮子了，有时候做技术开发需要知其然，知其所以然。定时器的实现有很多种方式，采用小根堆实现定时器是较为常见的一种。 一个假定的定时器结构如果用golang实现，定时器的每个任务应该包含如下结构 12345678type HeapEle struct &#123; //任务的回调函数 callback func(interface&#123;&#125;) bool //回调函数的参数 params interface&#123;&#125; //任务设置的定时器时间 deadline int64&#125; 当我们将任务加入定时器时，实际就是将回调函数(callback)和参数(params)以及截至时间(deadline)保存好放到小根堆中。每次从堆顶pop出截止日期最小的任务，调用回调函数执行任务。如果是一次性任务执行完就不需要加入堆，如果是轮询任务，则执行完继续加入堆中。好，我们先不讨论堆的问题，先写一个demo模拟定时器任务如何callback的。在main函数中 123456789101112131415161718192021222324//任务截止时间 deadline := time.Now().Unix() + (int64)(10) heape := new(HeapEle) heape.deadline = deadline //任务参数 heape.params = []int&#123;1, 2, 3&#125; //任务回调函数 heape.callback = func(params interface&#123;&#125;) bool &#123; switch params.(type) &#123; case string: fmt.Println(params) case []string: strs := params.([]string) for _, str := range strs &#123; fmt.Println(str) &#125; case []int: nums := params.([]int) for _, num := range nums &#123; fmt.Println(num) &#125; &#125; return true &#125; 我们new了一个任务(HeapEle)对象，设定了回调函数和参数以及截止日期。接下来在main函数中继续模拟定时器到期情况 1234time.Sleep(time.Duration(time.Second * 11))if time.Now().Unix() &gt;= heape.deadline &#123; heape.callback(heape.params)&#125; 定时器时间到期后触发callback，输出如下 123123 好了，上面模拟了一个简易的定时器调用过程和基本数据结构，这只是定时器要完成的一个核心部分，第二个核心部分是如何对任务进行排序和增删，这就要引入小根堆来管理任务了。 小根堆小根堆根据任务截止时间，将截止时间小的放在堆顶，为了方便讲述原理，我们将任务序列简化为一个int型数组，每个元素为int数值表示截止时间。 将任务序列初始化为小根堆假设任务序列为[6,1,0,5,2,9]，我们将所有元素构造为完全二叉树将这个完全二叉树调节为小根堆，首先从最后一个非叶子节点开始，将其子树调节为小根堆，然后一次从右往左，从下往上处理，直到根节点所在子树全部处理完成。这个过程和前一篇讲述的构造大根堆类似，我们再重新讲解一遍。最后一个非叶子节点为下标2的元素0，因为0比其左节点9小，所以不需要调节，此时下标2所在子树为小根堆。接下来从右往左，从下往上，依次处理，处理下标为1的元素1,1比其两个子节点都小，则不需要调节，下标1所在子树为小根堆。接下来处理下标为0的元素6，6比其最小的子节点0小，所以二者交换位置。调整后继续判断，6比其左节点9小，则不需要交换，否则继续交换不断向下调整。直到为叶子结点或者满足小根堆需求。到目前为止，小根堆已经构造完毕。 小根堆插入新节点如果最后一个非叶子结点没有左节点，将新节点插入到最后一个非叶子节点的左节点，否则插入右节点。例如在上述小根堆中插入新节点，元素值为3，现将其插入下标为2的节点的右节点。新节点元素值3比其父节点元素值6小，所以将3上移移动后元素3比其父节点元素0大，所以不需要继续上移，否则继续上移，直到满足小根堆或者元素3移动到根节点。 小根堆对顶元素pop还是上边的小根堆，取出堆顶元素0，后如何快速构造小根堆呢？当然可以将剩下的元素当做序列重新构造小根堆，这么做是可以实现的，毕竟之前我们的堆排序是这么做的。除此之外，给大家推荐一个方便快速的方法，就是将最后一个叶子节点放到根节点位置，然后不断向下调节根节点使其满足小根堆为止。删除后继续调整对顶元素6，其两个子节点元素1和元素3,1是最小的，所以将6和1位置交换。交换后6比其最小的子节点2还大，所以继续下调，直到6为叶子结点或者满足小根堆条件。这样一个小根堆就调整好了。 代码实现上边讲述了小根堆的构造，插入，删除等操作，大根堆和小根堆类似，这里定义了大根堆的基本结构和交换操作。读者可以这些大根堆的代码仿写小根堆，当做读后习题。 123456789101112131415type BigRootHeap struct &#123; m_array []int&#125;func (bh *BigRootHeap) swap(array []int, i, j int) &#123; if i &gt;= len(array) || j &gt;= len(array) &#123; return &#125; temp := array[i] array[i] = array[j] array[j] = temp&#125; 初始化一个大根堆 12345678910func (bh *BigRootHeap) initHeap(array []int) &#123; bh.m_array = make([]int, len(array)) copy(bh.m_array, array) length := len(bh.m_array) //每次循环后长度减少，因为每次循环最后元素都变为最大 for index := length/2 - 1; index &gt;= 0; index-- &#123; bh.adjustDown(bh.m_array, index, length) &#125;&#125; 节点下调 123456789101112131415161718192021222324252627282930func (bh *BigRootHeap) adjustDown(array []int, index, length int) &#123; //index 的左右子节点 leftchild := index*2 + 1 rightchild := leftchild + 1 maxchild := leftchild for &#123; //如果左节点比长度大，说明该节点为子节点 if leftchild &gt; length-1 &#123; break &#125; //右节点存在，且比左节点大 if rightchild &lt;= length-1 &amp;&amp; array[rightchild] &gt; array[maxchild] &#123; maxchild = rightchild &#125; //如果堆顶元素最大，则退出 if array[index] &gt; array[maxchild] &#123; break &#125; //堆顶元素小于其子节点，则交换，并且将堆顶元素继续下调 bh.swap(array, index, maxchild) index = maxchild leftchild = index*2 + 1 rightchild = leftchild + 1 maxchild = leftchild &#125;&#125; 节点上调 123456789101112131415161718func (bh* BigRootHeap) adjustUp(array []int, index, length int)&#123; parent := (index+1)/2-1 for&#123; if index &lt;= 0&#123; break &#125; if(bh.m_array[index] &lt;= bh.m_array[parent])&#123; break &#125; bh.swap(bh.m_array,index,parent) index = parent parent = (index+1)/2-1 &#125;&#125; 插入节点 1234567func (bh* BigRootHeap) insertNode(node int)&#123; bh.m_array = append(bh.m_array,node) length:=len(bh.m_array) index := length-1 bh.adjustUp(bh.m_array,index,length)&#125; 取出堆顶元素 1234567891011func (bh *BigRootHeap) popBigRoot() (bool, int) &#123; length := len(bh.m_array) if length &lt;= 0 &#123; return false, 0 &#125; temp := bh.m_array[0] bh.swap(bh.m_array, 0, length-1) bh.m_array = append(bh.m_array[0:length-1], bh.m_array[length:]...) bh.adjustDown(bh.m_array, 0, len(bh.m_array)) return true, temp&#125; 初始化堆，增加节点，删除节点这些基本操作已经实现了。 思考和总结上述两部分分别介绍了定时器任务的基本结构和小根堆的操作，以及大根堆代码的实现，你可以将大根堆仿写成小根堆吗？然后结合你的小根堆和定时器数据结构，做一个定时器吗？自己试着做一做吧，定时器触发的基本思路是这样 12345678for&#123; for(判断堆顶任务的时间&gt;= now)&#123; 小根堆取出堆顶任务 执行任务的回调函数 &#125; time.sleep(time.Duration(time.Second*0.5))&#125;这段代码可以开个协程处理哈。 到此为止，介绍完毕。源码下载地址谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang实现堆排序","date":"2019-07-01T07:14:31.000Z","path":"2019/07/01/golang08/","text":"前文介绍了golang实现基本的四中排序，本文带领大家实现堆排序，堆排序是效率很高的算法，通过取出大根堆堆顶元素从而实现排序的算法。该算法以出色的效率著称，时间复杂度为O (nlgn) 堆排序描述什么是大根堆1 大根堆是一颗完全二叉树2 该完全二叉树，根节点一定大于等于其左右子节点，并且大于等于其子树所有节点。 完全二叉树完全二叉树是相对于满二叉树来讲的，对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 满二叉树：一棵深度为 k，且有 2k - 1 个节点称之为满二叉树，即每一层上的节点数都是最大节点数。 也就是说完全二叉树可以这么理解，在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree） 下图就是一个完全二叉树 算法图解假设有序列下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 6 | 1 | 0 | 5 | 2 | 9 |将该序列构造成上图的二叉树，首先从最后一个非叶子结点(也就是下标2的节点元素0)开始，将其所在子树调节为大根堆由于9比0大，所以二者交换位置，这样下标2所在子树就变为大根堆了。接下来从右往左，从下往上依次处理所有非叶子节点所在子树，使其依次形成大根堆。下面处理下标为1的子树。下标1的两个子节点中5比2大，选择最大的子节点5和1比较，由于5比1大，所以二者交换位置，这样下标1所在子树就变为大根堆了。接下来处理下标0所在子树，使其成为大根堆。同样选择下标0最大的子节点9和下标0的元素6交换位置，这样最大元素9放在下标0的位置，由于6和9交换位置，还要考虑元素6所在的下标为1的子树是否因为交换导致失去大根堆特性，如果6比其子节点小，则继续将6下移，直到找到合理位置。此时6比其子节点0大，所以不需要移动了。下标0就是根节点，到此为止一颗大根堆构造完成。接下来将根节点9和最后一个元素交换，n为最后一个元素。这样调节前n-1节点，是这些节点构成大根堆。具体操作如下图交换最后一个元素和根节点将最后一个元素排出不再比较，比较前n-1个元素，重新构造大根堆。以此类推，将n-1个节点调整为大根堆前n-1调节为大根堆后，将根元素和第n-1元素交换将第n-1个元素取出。这样最后两个元素分别为6,9，是从小到大拍好的顺序，继续使前n-2节点形成大根堆。直到n=1 算法实现首先定义一个HeapSort类，然后设计一个成员函数adjustHeap，该函数主要实现将index所在位置的子树构造成大根堆。adjustHeap的三个参数分别为一段连续的数据序列，index表示子树根所在位置，length表示要排序的长度。 123456789101112131415161718192021222324252627282930313233343536type HeapSort struct &#123;&#125;//调整index为根的子树，此时index的左右子树都是大根树//比较index和其左右节点，将index根节点设置为最大的元素//可能会引起子树失效，所以会循环处理修改的子树func (hs *HeapSort) adjustHeap(array []int, index, length int) &#123; //index 的左右子节点 leftchild := index*2 + 1 rightchild := leftchild + 1 maxchild := leftchild for &#123; //如果左节点比长度大，说明该节点为子节点 if leftchild &gt; length-1 &#123; break &#125; //右节点存在，且比左节点大 if rightchild &lt;= length-1 &amp;&amp; array[rightchild] &gt; array[maxchild] &#123; maxchild = rightchild &#125; //index 元素比最大子节点大，则不需要交换，退出 if array[index] &gt; array[maxchild] &#123; break &#125; //比较自己元素和最大节点的元素，做交换 hs.swap(array, index, maxchild) index = maxchild leftchild = index*2 + 1 rightchild = leftchild + 1 maxchild = leftchild &#125;&#125; 接下来实现一个小函数，用来交换两个位置的元素 12345678910func (hs *HeapSort) swap(array []int, i, j int) &#123; if i &gt;= len(array) || j &gt;= len(array) &#123; return &#125; temp := array[i] array[i] = array[j] array[j] = temp&#125; 接下来实现将n个元素排序成大根堆，并且交换根元素和第n个元素，并将第n各元素排出，继续比较n-1个元素构造大根堆的逻辑 123456789101112131415161718func (hs *HeapSort) sort(array []int) &#123; //每次循环后长度减少，因为每次循环最后元素都变为最大 for length := len(array); length &gt; 1; length-- &#123; //最后一个非叶子节点索引 lastnode := length/2 - 1 //从最后一个非叶子节点一次从左到右，从下到上排序子树 //循环过后得到一个大顶堆(此时还不是大根堆) for i := lastnode; i &gt;= 0; i-- &#123; hs.adjustHeap(array, i, length) &#125; //将堆顶元素放到末尾 hs.swap(array, 0, length-1) fmt.Println(array) &#125;&#125; ok，算法完成，可以进行测试了 123456func main() &#123; //数组初始化 array := []int&#123;6, 1, 0, 5, 2, 9, 6&#125; hs := new(HeapSort) hs.sort(array)&#125; 结果如下，打印的是每次排出元素后序列的结果 123456[6 5 6 1 2 0 9][0 5 6 1 2 6 9][2 5 0 1 6 6 9][1 2 0 5 6 6 9][0 1 2 5 6 6 9][0 1 2 5 6 6 9] 目前为止，堆排序介绍完了，欢迎下载源码源码下载地址谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang实现四种排序(快速，冒泡，插入，选择)","date":"2019-06-29T01:58:13.000Z","path":"2019/06/29/golang07/","text":"前面已经介绍golang基本的语法和容器了，这一篇文章用golang实现四种排序算法,快速排序，插入排序，选择排序，冒泡排序。既可以总结前文的基础知识，又可以熟悉下golang如何实现这四种排序。 快速排序算法介绍假设用户输入了如下数组 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 6 | 2 | 7 | 3 | 8 | 9 | 创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 3 | 2 | 7 | 6 | 8 | 9 | i=0 j=3 k=6接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表： 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 3 | 2 | 6 | 7 | 8 | 9 | i=2,j=3,k=6接下来继续重复上边的步骤，从j开始，从右往左找比k小的，此时i=2,j=3，j再移动一位就和i相等了，此时就完成了k=6的排序，此时k=6,i和j相等都为2，6右边的数都比6大，6左边的数比6小。接下来分别比较6左边的序列(下标从0到1)和6右边(下标从3到5)的序列，同样采用上述办法，直到所有序列都比较完成。 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func quickSort(slice []int, begin int, end int) &#123; //slice为空 if len(slice) == 0 &#123; return &#125; //end越界 if end &gt;= len(slice) &#123; return &#125; //begin越界 if begin &lt; 0 &#123; return &#125; //下标碰头无须比较 if begin &gt;= end &#123; return &#125; //i从左到右，j从右到左 i := begin j := end //value就是比较的值 value := slice[i] for &#123; //从右往左比较，找到比value小的交换位置 index := j for ; index &gt; i; index-- &#123; if value &gt; slice[index] &#123; slice[i] = slice[index] //slice[index] = value break &#125; &#125; //更新j的位置 j = index //从左往右比较 for index = i; index &lt; j; index++ &#123; if value &lt; slice[index] &#123; slice[j] = slice[index] //slice[index] = value break &#125; &#125; //更新i的位置 i = index //i和j碰头则更新value的位置，并且比较value左右序列 //fmt.Println(i, j) if i &gt;= j &#123; slice[i] = value quickSort(slice, begin, i-1) quickSort(slice, i+1, end) return &#125; //否则继续比较，此时i,j已经缩小范围 &#125;&#125;上述算法时间复杂度达到O(nlogn) 插入排序算法描述假设用户输入了如下数组 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 6 | 2 | 7 | 3 | 8 | 9 | 假设从小到大排序插入排序先从下标为1的元素2开始，比较前边下标为0的元素6,2比6小，则将6移动到2的位置，2放到6的位置 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 6 | 7 | 3 | 8 | 9 | 记下来比较下标为2的元素7，和前边0~1下标的元素对比，从后往前找，如果找到比7大的元素，则将该元素后边的序列依次后移，将7插入该元素位置目前7不需要移动。接下来寻找下标为3 的元素3，从下标3往前找，由于下标1,下标2的元素都比3大，所以依次后移，将3放倒下标1的位置。 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 3 | 6 | 7 | 8 | 9 |以此类推，进行比较。 算法实现1234567891011121314151617181920func insertSort(slice []int) &#123; if len(slice) &lt;= 0 &#123; return &#125; for i := 1; i &lt; len(slice); i++ &#123; //下标i的元素temp temp := slice[i] for j := i - 1; j &gt;= 0; j-- &#123; //从i-1的位置往前查找，如果前边的元素比temp大 //就进行后移 if temp &lt; slice[j] &#123; slice[j+1] = slice[j] &#125; //否则找到比temp小的就将tmep插入。 slice[j+1] = temp break &#125; &#125;&#125; 该算法时间复杂度为O(n*n) 冒泡排序算法描述假设用户输入了如下数组 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 6 | 2 | 7 | 3 | 8 | 9 |冒泡排序依次比较相邻的两个元素 ，将大的元素后移即可。先比较下标为0和下标为1的元素，6比2大，所以6和2交换位置。 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 6 | 7 | 3 | 8 | 9 |接下来比较下标为1和下标为2的元素，6比7小所以不做交换。然后比较7和3,7比3大，7和三交换位置，以此类推，直到比较到最后一个元素 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 6 | 3 | 7 | 8 | 9 |经过这一轮相邻元素的比较，将最大的元素9冒泡到最后的位置。接下来重复上述步骤，从下标0开始到下标4两两比较，将第二大元素放到下标4的位置，因为下标5已经是最大元素，所以不参与比较。 算法实现123456789func bubbleSort(slice []int) &#123; for i := 0; i &lt; len(slice); i++ &#123; for j := 0; j &lt; len(slice)-i-1; j++ &#123; if slice[j] &gt; slice[j+1] &#123; slice[i], slice[j+1] = slice[j+1], slice[j] &#125; &#125; &#125;&#125; 选择排序算法描述假设用户输入了如下数组 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 6 | 2 | 7 | 3 | 8 | 9 |从下标0开始，比较6和其他位置的元素，找到最小的元素2和6交换位置 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 6 | 7 | 3 | 8 | 9 |接下来从下标1开始，比较6和后边位置的元素，选择最小的和6交换位置。 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 3 | 7 | 6 | 8 | 9 |以此类推，从下标2开始，比较7和后边的元素，选择最小的6交换位置 下标 | 0 | 1 | 2 | 3 | 4 | 5 |数值 | 2 | 3 | 6 | 7 | 8 | 9 |以此类推，直到下标5的位置元素都比较完。 算法实现123456789func selectSort(slice []int) &#123; for i := 0; i &lt; len(slice); i++ &#123; for j := i + 1; j &lt; len(slice); j++ &#123; if slice[i] &gt; slice[j] &#123; slice[i], slice[j] = slice[j], slice[i] &#125; &#125; &#125;&#125; 该算法时间复杂度为o(n*n) main函数中调用并测试12345678910111213141516func main() &#123; array := [...]int&#123;6, 2, 7, 3, 8, 9&#125; slice := array[:] quickSort(slice, 0, len(slice)-1) fmt.Println(slice) slice2 := array[:] bubbleSort(slice2) fmt.Println(slice2) slice3 := array[:] selectSort(slice3) fmt.Println(slice3) slice4 := array[:] insertSort(slice4) fmt.Println(slice4)&#125; 到此为止，四种基本的比较算法已经完成，感兴趣的可以自己实现以下。上述所有源码下载地址源码下载地址谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"boost::multi_index 提供一种千人在线即时排行榜的设计思路","date":"2019-06-23T07:57:09.000Z","path":"2019/06/23/cpp01/","text":"做游戏或金融后台开发，经常会遇到设计开发排行榜的需求。比如玩家的充值排行，战力排行等等。而这种排行基本都是即时更新的，快速排序对于单一类型排序可以满足需求，但是对于多种类的排序就很吃力，比如实现一个排行榜，有战力排序，有充值排序，如下图 快速排序的缺陷如果用快速排序实现，需要定义四种比较规则，而且qsort排序需要一段连续空间，如数组或者vector，为节约内存，每个元素存储玩家基本信息的指针。之后为每种排行类型定义单独的比较规则。代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct PowerCmp;struct ChargeCmp;//玩家基本信息class PlayrInfo&#123;public: int getPower()const&#123; return u_power; &#125; int getCharge()const&#123; return u_charge; &#125;private: int u_ind; //玩家唯一id int u_power; //玩家战力 int u_charge; //玩家充值数量&#125;;bool chargeCmp(PlayrInfo *a, PlayrInfo *b) &#123; return a-&gt;getCharge() &gt; b-&gt;getCharge();&#125;bool powerCmp(PlayrInfo *a, PlayrInfo *b) &#123; return a-&gt;getPower() &gt; b-&gt;getPower();&#125;int main(int argc, char* argv[])&#123; //分别实现排序 vector&lt;PlayrInfo*&gt; vecPlayer; sort(vecPlayer.begin(),vecPlayer.end(),powerCmp); sort(vecPlayer.begin(),vecPlayer.end(),chargeCmp); getchar(); return 0;&#125; 这么做有几个坏处1 每个排行都要开辟一段连续的序列，即使存储指针也会造成空间的浪费。2 qsort适合中小数量排序，当人数上千或万以上会造成瓶颈。但是可以通过插入排序优化。下面提出一种新的结构来处理排序，boost::multi_index 实现了多索引结构，支持按照多个键值排序，可以极大减轻压力。 multi_index 多索引处理排行榜multi_index 是boost库提出的多索引结构表，可以设定多个主键进行排序，如战力，充值等等，但是必须要有一个唯一主键，我们将player的id设为唯一主键。为了方便输出我们先完善下PlayerInfo类，重载输出运算符 123456789101112131415161718192021222324252627//玩家基本信息class PlayrInfo&#123;public: PlayrInfo(int id, int power, int charge):u_ind(id),u_charge(charge),u_power(power)&#123;&#125; int getPower()const&#123; return u_power; &#125; int getCharge()const&#123; return u_charge; &#125;private: int u_ind; //玩家唯一id int u_power; //玩家战力 int u_charge; //玩家充值数量 //重载输出 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,const boost::shared_ptr&lt;PlayrInfo&gt; &amp; e) &#123; //获取引用计数 //cout &lt;&lt; e.use_count(); //获取原始指针 //e.get() os&lt;&lt;e-&gt;u_ind&lt;&lt;&quot; &quot;&lt;&lt;e-&gt;u_power&lt;&lt;&quot; &quot;&lt;&lt;e-&gt;u_charge&lt;&lt;std::endl; return os; &#125;&#125;; 由于multi_index 各主键排序需要设置比较规则，默认是从小到大，int类型可以用greater， less等。greater从大到小, less从小到大,也可以自己实现仿函数。 1234567struct powerOperator&#123; bool operator()(int a, int b) const &#123; return a &gt; b; &#125;&#125;; 定义operator()一定要加上const，因为没有修改参数数据。 multi_index 表定义基于playerinfo实现multi_index表如下 123456789101112131415struct by_id;struct by_power;struct by_charge;typedef multi_index_container&lt; boost::shared_ptr&lt;PlayrInfo&gt;, //插入的主体，当然可以是PlayrInfo本身 indexed_by&lt; //唯一主键，不可重复, std::greater&lt;int&gt; 为id规则从大到小，默认从小到大 //tag&lt;by_id&gt;为标签名，可写可不写 ordered_unique&lt;tag&lt;by_id&gt; , const_mem_fun&lt;PlayrInfo,int,&amp;PlayrInfo::getId&gt;&gt;, //可重复的主键 ordered_non_unique&lt;tag&lt;by_power&gt;, const_mem_fun&lt;PlayrInfo, int, &amp;PlayrInfo::getPower&gt;, powerOperator &gt;, ordered_non_unique&lt;tag&lt;by_charge&gt;, const_mem_fun&lt;PlayrInfo, int, &amp;PlayrInfo::getCharge&gt;, greater&lt;int&gt; &gt; &gt;&gt; PlayerContainer; by_id， by_power等都是标签，只需要声明一个结构体，然后tag&lt;标签名&gt;放到索引里。当然可以不带tag，带tag是为了之后获取方便。powerOperator是定义的战力比较规则，greater定义的充值金额比较规则，是从大到小排序。 multi_index 根据标签获取排序序列multi_index表在数据插入的时候就根据各个主键排序规则进行排序，所以只需要按照主键取出，获得序列就是排好序的数据。 我们先按照id获取，然后打印输出结果 12auto&amp; ids = con.get&lt;by_id&gt;();copy(ids.begin(), ids.end(), ostream_iterator&lt;boost::shared_ptr&lt;PlayrInfo&gt; &gt;(cout)); 结果如下，可以看出是按照id从小到大排序输出的。 1231 1231 100002 22222 20003 19999 222222 那我们按照战力获取 12auto&amp; powers = con.get&lt;by_power&gt;();copy(powers.begin(), powers.end(), ostream_iterator&lt;boost::shared_ptr&lt;PlayrInfo&gt; &gt;(cout)); 结果能看出是按照战力从大到小输出 1232 22222 20003 19999 2222221 1231 10000 multi_index 删除数据删除元素如果是根据唯一主键删除，可以直接删除，如果是非唯一主键，需要查出所有记录并删除。删除唯一主键为2的玩家 1234567auto &amp;itfind = ids.find(2); if (itfind != ids.end())&#123; ids.erase(itfind); cout &lt;&lt; &quot;after erase: &quot;&lt;&lt;endl; copy(con.begin(), con.end(), ostream_iterator&lt;boost::shared_ptr&lt;PlayrInfo&gt; &gt;(cout)); &#125; 结果 123after erase:1 1231 100003 19999 222222 插入一条战力重复的数据，并且遍历删除所有战力为1231的玩家 12345678910con.insert(boost::make_shared&lt;PlayrInfo&gt;(4, 1231, 10000));auto &amp;beginit = powers.lower_bound(1231);auto &amp; endit = powers.upper_bound(1231);for( ; beginit != powers.end()&amp;&amp; beginit != endit; )&#123; cout &lt;&lt; &quot;....................&quot; &lt;&lt;endl; cout &lt;&lt; *beginit; beginit = powers.erase(beginit);&#125; copy(powers.begin(), powers.end(), ostream_iterator&lt;boost::shared_ptr&lt;PlayrInfo&gt; &gt;(cout)); 结果 12345....................1 1231 10000....................4 1231 100003 19999 222222 lower_bound 获取的是战力为1231的玩家迭代器的起始值，upper_bound获取的是战力为1231的玩家的最大值的下一个元素。 multi_index 修改数据修改数据可以用replace，也可以用modifyreplace 失败不会删除条目，但是二次copy造成效率低下modify失败会删除对应条目，容易暴力误删除，但是效率高replace 找到战力为19999的玩家，并且替换为新的数据。 123456auto piter = powers.find(19999);if(piter != powers.end() )&#123; auto newvalue = boost::make_shared&lt;PlayrInfo&gt;(100,200,300); powers.replace(piter, newvalue); copy(powers.begin(), powers.end(), ostream_iterator&lt;boost::shared_ptr&lt;PlayrInfo&gt; &gt;(cout));&#125; 下面用modify修改数据 12345678piter = powers.find(200); if(piter != powers.end())&#123; auto newp = 1024; powers.modify(piter, [&amp;](boost::shared_ptr&lt;PlayrInfo&gt; &amp; playptr)-&gt;void&#123; playptr-&gt;setPower(newp) ; &#125;); copy(powers.begin(), powers.end(), ostream_iterator&lt;boost::shared_ptr&lt;PlayrInfo&gt; &gt;(cout)); &#125; modify 第一个参数和replace一样，都是要修改的迭代器，第二个参数是一个函数对象，参数类型为表中元素类型。到目前为止，multi_index介绍完毕，用该多索引结构可以高效实现多级排序，非常适用于即时排行榜。源码下载https://github.com/secondtonone1/boost-multi_index-我的公众号，谢谢关注","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"Go(05)map介绍","date":"2019-06-11T09:12:28.000Z","path":"2019/06/11/golang06/","text":"基本用法map同样也是引用类型，map在使用前需要通过make进行初始化，否则会报panic错误。 map 初始化和插入12345678910type PersonInfo struct &#123; ID string Name string Address string &#125; var personDB map[string]PersonInfo personDB = make(map[string]PersonInfo) personDB[&quot;12345&quot;] = PersonInfo&#123;&quot;12345&quot;, &quot;Tom&quot;, &quot;Room 203&quot;&#125; personDB[&quot;1&quot;] = PersonInfo&#123;&quot;1&quot;, &quot;Jack&quot;, &quot;Room 102&quot;&#125; 可以看到map使用前用make先构造初始化，之后进行了插入，如果key存在，则修改value map 查找12345678//从这个map查找键为&quot;1234&quot; person, ok := personDB[&quot;1234&quot;] if ok &#123; fmt.Println(&quot;Found person&quot;, person.Name, &quot;with ID 1234&quot;) &#125; else &#123; fmt.Println(&quot;Did not find person with ID 1234&quot;) &#125; 查找指定key，返回值为value和bool类型结果，所以先判断bool类型值是否为true map 进阶map可以直接显示初始化不需要make构造。 1var data map[string]int = map[string]int&#123;&quot;bob&quot;: 18, &quot;luce&quot;: 28&#125; map是引用类型，函数通过修改形参，达到修改外部实参的功能 1234567891011121314151617func modify(data map[string]int, key string, value int) &#123; v, res := data[key] //不存在,则res是false if !res &#123; fmt.Println(&quot;key not find&quot;) return &#125; fmt.Println(&quot;key is &quot;, key, &quot;value is &quot;, v) data[key] = value&#125;func main() &#123; var data map[string]int = map[string]int&#123;&quot;bob&quot;: 18, &quot;luce&quot;: 28&#125; modify(data, &quot;lilei&quot;, 28) modify(data, &quot;luce&quot;, 22) fmt.Println(data)&#125; map 大小可以通过len函数获得，如果不采用显示初始化方式，只声明map，在使用前一定要make初始化map遍历采用range方式，且map是无序的，切记。 1234567891011121314151617//map大小 fmt.Println(len(data)) //map 使用前一定要初始化，可以显示初始化，也可以用make var data2 map[string]int = make(map[string]int, 3) fmt.Println(data2) //当key不存在时，则会插入 data2[&quot;sven&quot;] = 19 fmt.Println(data2) //当key存在时，则修改 data2[&quot;sven&quot;] = 299 fmt.Println(data2) data2[&quot;Arean&quot;] = 33 data2[&quot;bob&quot;] = 178 //map是无序的,遍历输出 for key, value := range data2 &#123; fmt.Println(&quot;key: &quot;, key, &quot;value: &quot;, value) &#125; 上面的代码遍历map，打印结果为 123key: bob value: 178key: sven value: 299key: Arean value: 33 可以实现一个函数，将map中的key存到slice中，然后排序，之后根据排好顺序的slice遍历得到的就是排序后的结果 123456789101112131415func sortprintmap(data map[string]int) &#123; slice := make([]string, 0) for k, _ := range data &#123; slice = append(slice, k) &#125; sort.Strings(slice) for _, s := range slice &#123; d, e := data[s] if !e &#123; continue &#125; fmt.Println(&quot;key is &quot;, s, &quot;value is &quot;, d) &#125;&#125; 在main函数调用sortprintmap(data2)，结果如下 123key is Arean value is 33key is bob value is 178key is sven value is 299 二维map二维map操作和之前类似，只是声明时value还是一个map 12//二维map var usrdata map[string]map[string]int 二维map同样遵循使用前先make初始化原则，并且在二层map要使用前仍然需要make 123456789//使用前需要初始化 usrdata = make(map[string]map[string]int) usrdata[&quot;sven&quot;] = make(map[string]int) usrdata[&quot;sven&quot;][&quot;age&quot;] = 21 usrdata[&quot;sven&quot;][&quot;id&quot;] = 1024 usrdata[&quot;susan&quot;] = make(map[string]int) usrdata[&quot;susan&quot;][&quot;age&quot;] = 19 usrdata[&quot;susan&quot;][&quot;id&quot;] = 1000 二维map遍历 123456//二维map 遍历 for k, v := range usrdata &#123; for k2, v2 := range v &#123; fmt.Println(k, &quot; &quot;, k2, &quot; &quot;, v2) &#125; &#125; slice 中存储map1234567//slice of map slicem := make([]map[string]int, 5) for i := 0; i &lt; len(slicem); i++ &#123; slicem[i] = make(map[string]int) &#125; fmt.Println(slicem) 本着golang所有引用类型,如chan，map，slice，interface，使用前都需要make初始化。上面代码先初始化slicem，然后再遍历slice，为每个元素初始化map类型 map 反转1234567//map 反转 rvmap := make(map[int]string) for k, v := range data2 &#123; rvmap[v] = k &#125; fmt.Println(rvmap) fmt.Println(data2) 其实就是构造一个和原map 的key value相反的map，然后为该map初始化并且插入元素。 上述所有源码下载地址源码下载地址谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go(05)slice知识介绍和使用","date":"2019-05-08T08:22:50.000Z","path":"2019/05/08/golang05/","text":"golang 的引用类型和内置类型变量golang 中变量类型分为引用类型和值类型(也叫作内置类型) 1.值类型：变量直接存储值，内存通常在栈中分配。值类型：基本数据类型int、float、bool、string以及数组和struct 2.引用类型：变量存储的是一个地址，这个地址存储最终的值。内存通常在 堆上分配。通过GC回收。引用类型：指针、slice、map、chan等都是引用类型。这类型变量需要通过make构造 golang中函数传参只有一种方式golang中函数传递参数，只有值传递一种，也就是实参内容按照值copy方式传递给形参。当函数的形参变量类型为指针,slice,map,chan等类型时，虽然实参和形参地址不同，但是内部指向了同一个地址，所以可以达到修改指定空间数据的目的。不要着急，接下来我会写一写小demo帮助大家理解。 数组先把这段代码写一遍看看结果 1234567891011121314151617//数组声明方法 var bytearray [8]byte //长度为8的数组 fmt.Println(bytearray) var pointarray [4]*float64 //指针数组 fmt.Println(pointarray) var mularray [3][5]int fmt.Println(mularray) fmt.Printf(&quot; pointarray len is %v\\n&quot;, len(pointarray)) //数组遍历 for i := 0; i &lt; len(pointarray); i++ &#123; fmt.Println(&quot;Element&quot;, i, &quot;of array is&quot;, pointarray[i]) &#125; //采用range遍历 for i, v := range pointarray &#123; fmt.Println(&quot;Array element [&quot;, i, &quot;]=&quot;, v) &#125; 上边提供了数组的声明方式 var 数组名 [数组长度] 元素类型，同时给出了两种数组遍历方式：1 len(数组名) 可以获取数组大小，然后遍历2 采用range遍历，第一个返回值是索引，第二个返回值是对应的内容int 类型数组初始值为0，指针类型数组初始值为nil结果如下: 123456789101112[0 0 0 0 0 0 0 0][&lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;][[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] pointarray len is 4Element 0 of array is &lt;nil&gt;Element 1 of array is &lt;nil&gt;Element 2 of array is &lt;nil&gt;Element 3 of array is &lt;nil&gt;Array element [ 0 ]= &lt;nil&gt;Array element [ 1 ]= &lt;nil&gt;Array element [ 2 ]= &lt;nil&gt;Array element [ 3 ]= &lt;nil&gt; 前文说过数组是值类型变量，我们写个函数，在函数内部修改形参数组的变量内容，看是否会对实参影响 12345678910func modify(array [5]int) &#123; array[0] = 200 fmt.Println(&quot;In modify(), array values:&quot;, array)&#125;func main()&#123; array := [5]int&#123;1, 2, 3, 4, 5&#125; modify(array) fmt.Println(&quot;In main(), array values:&quot;, array)&#125; 结果如下 12In modify(), array values: [200 2 3 4 5]In main(), array values: [1 2 3 4 5] 说明实参没有被函数修改。那么既然golang传递变量的方式都是值传递，是不是就没办法通过函数修改外部变量了呢？肯定不是的，可以通过引用类型变量修改，比如指针，slice，map，chan等都可以在函数体内修改，从而影响外部实参的内容。下面通过slice说明这一点 slice切片先看代码 1234567891011121314151617181920212223242526272829303132array := [5]int&#123;1, 2, 3, 4, 5&#125;//根据数组生成切片//切片 var mySlice []int = array[:3] fmt.Println(&quot;Elements of array&quot;) for _, v := range array &#123; fmt.Print(v, &quot; &quot;) &#125; fmt.Println(&quot;\\nElements of mySlice: &quot;) for _, v := range mySlice &#123; fmt.Print(v, &quot; &quot;) &#125; //直接创建元素个数为5的数组切片 mkslice := make([]int, 5) fmt.Println(&quot;\\n&quot;, mkslice) //创建初始元素个数为5的切片，元素都为0，且预留10个元素存储空间 mkslice2 := make([]int, 5, 10) fmt.Println(&quot;\\n&quot;, mkslice2) mkslice3 := []int&#123;1, 2, 3, 4, 5&#125; fmt.Println(&quot;\\n&quot;, mkslice3) //元素遍历 for i := 0; i &lt; len(mkslice3); i++ &#123; fmt.Println(&quot;mkslice3[&quot;, i, &quot;] =&quot;, mkslice3[i]) &#125; //range 遍历 for i, v := range mkslice3 &#123; fmt.Println(&quot;mkslice3[&quot;, i, &quot;] =&quot;, v) &#125; 生成切片有三种方式1 通过数组或者切片截取生成新的切片2 通过make生成 如mkslice := make([]int, 5)3 直接初始化 如mkslice3 := []int{1, 2, 3, 4, 5}切片遍历和数组遍历类似，上面结果如下 1234567891011121314151617181920Elements of array1 2 3 4 5Elements of mySlice:1 2 3 [0 0 0 0 0] [0 0 0 0 0] [1 2 3 4 5]mkslice3[ 0 ] = 1mkslice3[ 1 ] = 2mkslice3[ 2 ] = 3mkslice3[ 3 ] = 4mkslice3[ 4 ] = 5mkslice3[ 0 ] = 1mkslice3[ 1 ] = 2mkslice3[ 2 ] = 3mkslice3[ 3 ] = 4mkslice3[ 4 ] = 5 获取切片大小和容量1234//获取size和capacity mkslice4 := make([]int, 5, 10) fmt.Println(&quot;len(mkslice4):&quot;, len(mkslice4)) fmt.Println(&quot;cap(mkslice4):&quot;, cap(mkslice4)) 获取大小采用len,获取实际开辟的容量用cap 切片添加和删除123456//末尾添加三个元素 mkslice4 = append(mkslice4, 1, 2, 3) fmt.Println(&quot;mkslice4 is : &quot;, mkslice4) mkslice4 = append(mkslice4, mkslice3...) fmt.Println(&quot;mkslice4 is : &quot;, mkslice4) 采用append 方式可以添加切片数据，但是要注意将append赋值给要存储结果的sliceappend有两种用法，第一种是多个参数，第一个参数是slice，后边是要加的多个元素。第二种是第一个参数为slice，第二个参数为slice展开，slice…表示把slice中元素一个个展开加入。切片的删除较为麻烦，比如说删除第n个元素，就是截取n-1之前的序列和n之后的序列进行拼接。 1234567891011 mkslice4 := make([]int, 0)//末尾添加三个元素mkslice4 = append(mkslice4, 1, 2, 3)fmt.Println(&quot;mkslice4 is : &quot;, mkslice4)mkslice3 := []int&#123;1, 2, 3, 4, 5&#125;mkslice4 = append(mkslice4, mkslice3...)fmt.Println(&quot;mkslice4 is : &quot;, mkslice4)mkslice4 = append(mkslice4[:4-1], mkslice4[4:]...)fmt.Println(&quot;mkslice4 is : &quot;, mkslice4) 切片的copycopy函数提供了切片的深层复制，而赋值操作(=)紧紧是浅拷贝。看看赋值操作，我们修改slice内部元素数据，其他slice是否会受到影响 12345678910 oldslice := []int&#123;1, 2, 3, 4, 5&#125;newslice := oldslice[:3]newslice2 := oldslicefmt.Println(&quot;newslice is :&quot;, newslice)fmt.Println(&quot;newslice2 is :&quot;, newslice2)fmt.Printf(&quot;newslice addr is : %p \\n&quot;, &amp;newslice)fmt.Printf(&quot;newslice2 addr is: %p \\n&quot;, &amp;newslice2)oldslice[0] = 1024fmt.Println(&quot;newslice is :&quot;, newslice)fmt.Println(&quot;newslice2 is :&quot;, newslice2) 输出一下 123456newslice is : [1 2 3]newslice2 is : [1 2 3 4 5]newslice addr is : 0xc00005a400newslice2 addr is: 0xc00005a420newslice is : [1024 2 3]newslice2 is : [1024 2 3 4 5] 可以看到oldslice修改后，newslice和newslice2都受到影响了，即便他们地址不同。为什么呢?这要追溯到slice内部实现 12345type Slice struct &#123; ptr unsafe.Pointer // Array pointer len int // slice length cap int // slice capacity&#125; Slice 内部其实存放了一个指针ptr，这个ptr指向的地址就是存放数据连续空间的首地址，len表示空间当前长度，cap表示空间实际开辟了多大。如下图那如何深copy元素到另一个slice呢？就是copy函数了 12345678910111213141516 slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1)fmt.Println(&quot;after copy.....&quot;)fmt.Println(&quot;slice1: &quot;, slice1)fmt.Println(&quot;slice2: &quot;, slice2)slice2[0] = 1024slice2[1] = 999slice2[2] = 1099fmt.Println(&quot;after change element slice2...&quot;)fmt.Println(&quot;slice1: &quot;, slice1)fmt.Println(&quot;slice2: &quot;, slice2)copy(slice1, slice2)fmt.Println(&quot;after copy.....&quot;)fmt.Println(&quot;slice1: &quot;, slice1)fmt.Println(&quot;slice2: &quot;, slice2) 结果如下 123456789after copy.....slice1: [1 2 3 4 5]slice2: [1 2 3]after change element slice2..slice1: [1 2 3 4 5]slice2: [1024 999 1099]after copy.....slice1: [1024 999 1099 4 5]slice2: [1024 999 1099] 可以看到copy(destslice,srcslice)，当destslice 大小&lt; srcslice时，只拷贝destslice大小的数据。也就是说copy的大小取决于destslice和srcslice最小值另外copy后，修改slice2元素，slice1也不会受到影响，是深copy。感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go(04)Cobra命令行参数库的使用","date":"2019-04-29T08:33:54.000Z","path":"2019/04/29/golang04/","text":"下载和安装Cobra是golang的命令行参数库，可以配置命令启动，读取参数等。将cobra下载到 $GOPATH，用命令： 1go get -v github.com/spf13/cobra/cobra 然后使用 go install github.com/spf13/cobra/cobra, 安装后在 $GOBIN 下出现了cobra 可执行程序。cobra程序只能在GOPATH之下使用，所以首先你需要进入到GOPATH的src目录之下，在该目录下，输入: 1cobra init demo $GOPATH目录下生成了demo文件夹,其组织形式如下 12345demo├── cmd │ └── root.go├── LICENSE└── main.go 进去该文件夹，运行: 1go run main.go 控制台输出如下 12345A longer description that spans multiple lines and likely contains examples and usage of using your application. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application. 如果你并不想运行cobra的可执行命令生成示例代码，只想在项目使用其库代码，则上面的内容可以忽略。 添加子命令在$GOPATH下执行 1cobra add test 完成后demo结构如下 12345├── cmd│ ├── root.go│ └── test.go├── LICENSE└── main.go 在cmd目录下，已经生成了一个与我们命令同名的go文件，你也许已经猜测到，与该命令有关的操作也正是在此处实现。现在执行这个子命令: 1go run main.go test 命令行将会打印输出test called,因为在test.go的run函数里输出test called其实添加自命令也可以通过修改对应的go文件，比如添加test.go命令下的自命令,我们建立一个文件subtest.go,将test.go内容复制给test.go，然后做如下修改 12345678910111213var subtestCmd = &amp;cobra.Command&#123; Use: &quot;subtest&quot;, Short: &quot;A brief description of your command&quot;, Long: `A longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(&quot;subtest called&quot;) &#125;,&#125; 将cobra.Command定义的变量改为subtestCmd,然后将Use和Run说明改下,接着修改init函数，将subtestcmd加入到testcmd中，因为二者都属于cmd包，所以可以直接访问使用 123func init() &#123; testCmd.AddCommand(subtestCmd)&#125; 现在在命令行运行: 1go run main.go test subtest 如果结果为subtest called则调用自命令成功 添加参数在test.go的init函数中，添加如下内容: 12testCmd.PersistentFlags().String(&quot;foo&quot;, &quot;&quot;, &quot;A help for foo&quot;)testCmd.Flags().String(&quot;foolocal&quot;, &quot;&quot;, &quot;A help for foo&quot;) 运行go run main.go test会看到如下结果 1234567891011121314151617181920Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo test [flags] demo test [command]Available Commands: subtest A brief description of your commandFlags: --foo string A help for foo -h, --help help for test -t, --toggle Help message for toggleGlobal Flags: --config string config file (default is $HOME/.demo.yaml)Use &quot;demo test [command] --help&quot; for more information about a command. 接着让我们再运行 go run main.go test subtest -h会看到如下结果 12345678910111213Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo test subtest [flags]Flags: -h, --help help for subtestGlobal Flags: --config string config file (default is $HOME/.demo.yaml) --foo string A help for foo 仔细对比发现subtest的Flags里没有-t，在Global Flags里多了–foo 选项。说明数作为persistent flag存在时，如注释所言，在其所有的子命令之下该参数都是可见的。而local flag则只能在该命令调用时执行 获取参数值修改test.go run函数，获取参数并打印 12345Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(&quot;test called&quot;) fmt.Println(cmd.Flags().GetString(&quot;foo&quot;)) fmt.Println(cmd.Flags().GetBool(&quot;toggle&quot;)) &#125;, 运行go run main.go test –foo “hello” -t false结果如下 123test calledhello &lt;nil&gt;true &lt;nil&gt; 通过cobra库可以很方便的启动多个命令行程序，目前就介绍这些。源码下载地址感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"Go(03)golang 基本变量和demo","date":"2019-04-27T12:08:37.000Z","path":"2019/04/27/golang03/","text":"本文介绍基本的golang变量和简单的demo，该系列博文由浅入深，带领大家初入golang。 golang 基本类型1234567891011121314var v1 int //整形var v2 string //字符串var v3 [10]int //数组var v4 []int //切片var v5 struct&#123; //结构体 f int&#125;var v6 * int //指针var v7 map[string]int //map，key为string,value为intvar v8 func(a int) int //函数对象var( v9 int v10 string) 如注释所说，上面就是以后会用到的基本类型，切片可以理解为C++的vector，python的list。可以用括号把两个变量括起来一起定义。 一个简单的golang程序12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;func main()&#123; //整形 var v1 int //字符串 var v2 string //变量赋值 v1 = 10 v2 := &quot;hello&quot; fmt.Println(&quot;v2:&quot;,v2) //变量初始化 v11 := &quot;day02&quot; fmt.Println(&quot;v11:&quot;,v11) //第二种初始化方式 var v12 int = 13 //变量交换 v1, v12 = v12, v1 fmt.Printf(&quot;v11:%v, v12:%v\\n&quot;,v1,v12) _, _, nickName := GetName() fmt.Printf(&quot;nickName : %v\\n&quot;, nickName) //常量 const Pi float64 = 3.141592653 const zero = 0.0 const ( size int64 = 1024 eof = -1 ) const u, v float32 = 0,3 const a, b, c = 3, 4, &quot;foo&quot;&#125; 下面说下各行含义package main 表示该代码属于main包，其他文件引用该文件函数或变量需要引入包名mainimport “fmt” 引入fmt包，这样就可以用fmt包里的打印函数fmt.Println了。var v1 int 定义了一个int类型的v1变量v1 = 10 将v1赋值为10，同样v2:=”hello”也是将v2赋值为”hello”fmt.Println是fmt包定义的打印函数，这里用来打印变量v11 := “day02”，由于没有定义v11，所以:=直接定义并初始化v11var v12 int = 13 也是初始化的方式，定义并初始化了v12golang允许交换两个变量，不需要写额外的变量缓存转换，v1,v12 = v12,v1 常量定义变量用var,定义常量用const，同样可以将常量放在()里一起定义或初始化。golang里有iota变量，第一次为0，以后每次出现加1，如下所示 1234567891011121314151617181920212223242526//iota 表示初始化常量为0，之后每次出现iota，iota自增1 const ( // iota被重设为0 c0 = iota // c0 == 0 c1 = iota // c1 == 1 c2 = iota // c2 == 2 ) const ( a1 = 1 &lt;&lt; iota //1左移0位 b2 = 1 &lt;&lt; iota //1左移1位 c3 = 1 &lt;&lt; iota //1左移2位 ) fmt.Printf(&quot;a1 : %v, b2 : %v, c3 : %v\\n&quot;, a1, b2, c3) const ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday numberOfDays // 这个常量没有导出 ) //同Go语言的其他符号（symbol）一样，以大写字母开头的常量在包外可见 bool类型12345//bool 类型var bvar bool bvar = truebvar2 := (1==2) //bvar 被推导为bool类型fmt.Printf(&quot;bvar: %v, bvar2: %v\\n&quot;,bvar, bvar2) 字符串12345678910111213141516171819//字符串 var str string str = &quot;Hello world&quot; ch := str[0] fmt.Printf(&quot;The length of \\&quot;%s\\&quot; is %d \\n &quot;, str, len(str)) fmt.Printf(&quot;The first character of \\&quot;%s\\&quot; is %c.\\n &quot;,str, ch) str2 := &quot;,I&#x27;m mooncoder&quot; fmt.Println(str+str2) hellos := &quot;Hello,我是中国人&quot; //字符串遍历,utf-8编码遍历,每个字符byte类型，8字节 for i:=0; i &lt; len(hellos); i++&#123; fmt.Printf(&quot;%c&quot;, hellos[i]) &#125; //unicode 遍历,每个字符rune类型，变长 for i, ch := range hellos&#123; fmt.Printf(&quot;%c\\t&quot;,ch) fmt.Printf(&quot;%d\\n&quot;,i) &#125; 上面的例子可以自己写一遍，提供了两种遍历方式，第一种是根据hellos字符串长度遍历，每次取字节中的内容打印，由于有汉字所以会乱码。采用range遍历，实际上是按照unicode变长遍历，打印出每个变长字节内容，不会乱码。今天介绍到此为止，下一期介绍slice,map等复杂类型。源码下载地址感谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"eos源码剖析之controller","date":"2019-04-09T03:01:39.000Z","path":"2019/04/09/eos9/","text":"controller::block_status，区块状态枚举类，包括：irreversible = 0，该区块已经被当前节点应用，并且被认为是不可逆的。validated = 1，这是由一个有效生产者签名的完整区块，并且之前已经被当前节点应用，因此该区块已被验证但未成为不可逆。complete = 2，这是一个由有效生产者签名的完整区块，但是还没有成为不可逆，也没有被当前节点应用。incomplete = 3，这是一个未完成的区块，未被生产者签名也没有被某个节点生产。实际上块的状态就是，1未签名未应用 2已签名未应用 3 已签名和应用，未变成不可逆 4 变成不可逆 controller的私有成员：apply_context,应用上下文，处理节点应用区块的上下文环境，其中包含了迭代器缓存iterator_cachetransaction_context，事务上下文环境。包括controller，db的session，signed_transaction等。mutable_db()，返回一个chainbase::database的引用controller_impl结构体的实例的唯一指针my。controller核心功能都是通过impl实现调用的。 12345678910111213141516struct controller_impl &#123; controller&amp; self; chainbase::database db; // 用于存储已执行的区块，这些区块可以回滚，一旦提交就成了不可逆的区块 chainbase::database reversible_blocks; ///&lt; a special database to persist blocks that have successfully been applied but are still reversible block_log blog; optional&lt;pending_state&gt; pending; // 尚未出的块 block_state_ptr head; // 当前区块的状态 fork_database fork_db; // 用于存储可分叉区块的数据库，可分叉的区块都放到这里 wasm_interface wasmif; // wasm虚拟机的runtime resource_limits_manager resource_limits; // 资源管理 authorization_manager authorization; // 权限管理 controller::config conf; chain_id_type chain_id; bool replaying = false; bool in_trx_requiring_checks = false; ///&lt; if true, checks that are normally skipped on replay (e.g. auth checks) cannot be skipped&#125; controller_impl 几个重要的成员db用于存储已执行的区块，这些区块可以回滚，一旦提交就不可逆reversible_blocks用于存储已执行，但是这些区块是可逆的pending用于存放当前正在生产或者验证（收到）的区块fork_db用于存放所有区块（包括自己生产和收到的），这些区块链是可分叉的 controller的信号controller 包括了以下几个信号：signal&lt;void(const signed_block_ptr&amp;)&gt; pre_accepted_block; // 预承认区块(承认其他节点广播过来的区块是正确的)signal&lt;void(const block_state_ptr&amp;)&gt; accepted_block_header; // 承认区块头(对区块头做过校验)signal&lt;void(const block_state_ptr&amp;)&gt; accepted_block; // 承认区块signal&lt;void(const block_state_ptr&amp;)&gt; irreversible_block; // 不可逆区块signal&lt;void(const transaction_metadata_ptr&amp;)&gt; accepted_transaction; // 承认事务signal&lt;void(const transaction_trace_ptr&amp;)&gt; applied_transaction; // 应用事务(承认其他节点数据要先校验，通过以后可以应用在本地节点)signal&lt;void(const header_confirmation&amp;)&gt; accepted_confirmation; // 承认确认signal&lt;void(const int&amp;)&gt; bad_alloc; // 内存分配错误信号所有信号的发射时机都是在controller中。分别介绍每个信号发射和接收时机 pre_accepted_block发射时机：push_block函数，在producer_plugin中 on_incoming_block中会对已签区块校验，包括不能有pending块，不能push空块，区块状态不能是incomplete。通过校验后，调用push_block会发射该信号，携带该区块。on_incoming_block函数123456789101112131415161718192021222324252627void producer_plugin::on_incoming_block(const signed_block_ptr&amp; block) &#123; //判断是否在fork_db中 auto existing = chain.fetch_block_by_id( id ); if( existing ) &#123; return; &#125; // 开始创建一个blockstate auto bsf = chain.create_block_state_future( block ); // 清除 pending状态，将交易放到unappliedtrx map中 chain.abort_block(); // 当抛出异常时，重启loop auto ensure = fc::make_scoped_exit([this]()&#123; schedule_production_loop(); &#125;); // push the new block bool except = false; try &#123; chain.push_block( bsf ); &#125; catch ( const guard_exception&amp; e ) &#123; chain_plug-&gt;handle_guard_exception(e); return; &#125; catch( const fc::exception&amp; e ) &#123; elog((e.to_detail_string())); except = true; &#125; catch ( boost::interprocess::bad_alloc&amp; ) &#123; chain_plugin::handle_db_exhaustion(); return; &#125; on_incoming_block做了这样几个事，1 判断forkdb是否有该新来的块，2 其次根据该块投递到线程池生成blockstate，3 清除之前的pending状态，pending中的交易取出放到unapplied map中.(以后会通过schedule_production_loop调用producer_plugin::start_block处理unapplied map,内部调用controller::start_block重新组织pending)4 为防止producer异常退出，设置schedule_production_loop重启。5 调用controller的push_block12345678910111213141516171819202122232425void controller::push_block( std::future&lt;block_state_ptr&gt;&amp; block_state_future ) &#123; controller::block_status s = controller::block_status::complete; EOS_ASSERT(!pending, block_validate_exception, &quot;it is not valid to push a block when there is a pending block&quot;); auto reset_prod_light_validation = fc::make_scoped_exit([old_value=trusted_producer_light_validation, this]() &#123; trusted_producer_light_validation = old_value; &#125;); try &#123; block_state_ptr new_header_state = block_state_future.get(); auto&amp; b = new_header_state-&gt;block; emit( self.pre_accepted_block, b ); fork_db.add( new_header_state, false ); if (conf.trusted_producers.count(b-&gt;producer)) &#123; trusted_producer_light_validation = true; &#125;; emit( self.accepted_block_header, new_header_state ); if ( read_mode != db_read_mode::IRREVERSIBLE ) &#123; maybe_switch_forks( s ); &#125; &#125; FC_LOG_AND_RETHROW( ) &#125; 在push_block中发送了pre_accepted_block信号插件捕捉处理： chain_plugin连接该信号，在plugin_initialize中绑定了信号的处理但是该channel没有订阅者。12345678910111213// relay signals to channels my-&gt;pre_accepted_block_connection = my-&gt;chain-&gt;pre_accepted_block.connect([this](const signed_block_ptr&amp; blk) &#123; auto itr = my-&gt;loaded_checkpoints.find( blk-&gt;block_num() ); if( itr != my-&gt;loaded_checkpoints.end() ) &#123; auto id = blk-&gt;id(); EOS_ASSERT( itr-&gt;second == id, checkpoint_exception, &quot;Checkpoint does not match for block number $&#123;num&#125;: expected: $&#123;expected&#125; actual: $&#123;actual&#125;&quot;, (&quot;num&quot;, blk-&gt;block_num())(&quot;expected&quot;, itr-&gt;second)(&quot;actual&quot;, id) ); &#125; my-&gt;pre_accepted_block_channel.publish(priority::medium, blk); &#125;); accepted_block_header 发射时机1： commit_block函数， 123456789void commit_block( bool add_to_fork_db ) &#123; if (add_to_fork_db) &#123; pending-&gt;_pending_block_state-&gt;validated = true; auto new_bsp = fork_db.add(pending-&gt;_pending_block_state, true); emit(self.accepted_block_header, pending-&gt;_pending_block_state); head = fork_db.head(); EOS_ASSERT(new_bsp == head, fork_database_exception, &quot;committed block did not become the new head in fork database&quot;); &#125; &#125; add_to_fork_db为true,将_pending_block_state-&gt;validated设置为true,_pending_block_state放入fork_db,然后发送accepted_block_header 发射时机2： push_block函数，获取区块的可信状态,发射完pre_accepted_block以后，添加可信状态至fork_db，然后发射accepted_block_header信号，携带fork_db添加成功后返回的状态区块。 插件捕捉处理： chain_plugin连接该信号， 123456void chain_plugin::plugin_initialize(const variables_map&amp; options) &#123;my-&gt;accepted_block_header_connection = my-&gt;chain-&gt;accepted_block_header.connect( [this]( const block_state_ptr&amp; blk ) &#123; my-&gt;accepted_block_header_channel.publish( priority::medium, blk ); &#125; );&#125; 由信号槽转播到channel，accepted_block_header_channel发布该区块,bnet_plugin订阅该channel 123456void bnet_plugin::plugin_startup() &#123; my-&gt;_on_accepted_block_header_handle = app().get_channel&lt;channels::accepted_block_header&gt;() .subscribe( [this]( block_state_ptr s )&#123; my-&gt;on_accepted_block_header(s); &#125;);&#125; 绑定了回调函数，回调函数内部调用bnet_plugin_impl的on_accepted_block_header(s); 12345678910111213141516void on_accepted_block_header( const block_state_ptr&amp; s ) &#123; ... const auto&amp; id = s-&gt;id; if( fc::time_point::now() - s-&gt;block-&gt;timestamp &lt; fc::seconds(6) ) &#123; auto itr = _block_status.find( id ); //_remote_request_irreversible_only(对端请求可逆)且(之前状态集合中没有该块或没收到过该块) if( !_remote_request_irreversible_only &amp;&amp; ( itr == _block_status.end() || !itr-&gt;received_from_peer ) ) &#123; //加入通知集合，通知对方防止对方重复发送区块头 _block_header_notices.insert( id ); &#125; //加入状态集合 if( itr == _block_status.end() ) &#123; _block_status.insert( block_status(id, false, false) ); &#125; &#125; &#125; accepted_block发射时机: commit_block函数，fork_db以及重播的处理结束后，发射承认区块的信号，携带pending状态区块数据。插件捕捉处理1 net_plugin连接该信号，绑定处理函数，打印日志的同时调用dispatch_manager::bcast_block，传入区块数据。send_all向所有连接发送广播2 chain_plugin连接该信号，由信号槽转播到channel，accepted_block_channel发布该区块12345void chain_plugin::plugin_initialize(const variables_map&amp; options) &#123; my-&gt;accepted_block_connection = my-&gt;chain-&gt;accepted_block.connect( [this]( const block_state_ptr&amp; blk ) &#123; my-&gt;accepted_block_channel.publish( priority::high, blk ); &#125; );&#125; bnet_plugin订阅该channel123456void bnet_plugin::plugin_startup() &#123; my-&gt;_on_accepted_block_handle = app().get_channel&lt;channels::accepted_block&gt;() .subscribe( [this]( block_state_ptr s )&#123; my-&gt;on_accepted_block(s); &#125;);&#125; 1234567891011121314151617181920212223242526void on_accepted_block( const block_state_ptr&amp; s ) &#123; verify_strand_in_this_thread(_strand, __func__, __LINE__); const auto&amp; id = s-&gt;id; _local_head_block_id = id; _local_head_block_num = block_header::num_from_id(id); if( _local_head_block_num &lt; _last_sent_block_num ) &#123; _last_sent_block_num = _local_lib; _last_sent_block_id = _local_lib_id; &#125; purge_transaction_cache(); for( const auto&amp; receipt : s-&gt;block-&gt;transactions ) &#123; if( receipt.trx.which() == 1 ) &#123; const auto&amp; pt = receipt.trx.get&lt;packed_transaction&gt;(); const auto&amp; tid = pt.id(); auto itr = _transaction_status.find( tid ); if( itr != _transaction_status.end() ) _transaction_status.erase(itr); &#125; &#125; maybe_send_next_message(); /// attempt to send if we are idle &#125; on_accepted_block函数，删除缓存中的所有事务，遍历接收到的区块的事务receipt，获得事务的打包对象，事务id，在多索引表_transaction_status中查找该id，如果找到了则删除。接下来如果在空闲状态下，尝试发送下一条pingpong心跳连接信息。3 mongo_db_plugin连接该信号，绑定其mongo_db_plugin_impl::accepted_block函数，传入区块内容。 123my-&gt;accepted_block_connection.emplace( chain.accepted_block.connect( [&amp;]( const chain::block_state_ptr&amp; bs ) &#123; my-&gt;accepted_block( bs ); &#125; )); accepted_block_connection.emplace 插入信号连接器，当accepted_block从controller发出后，mongodb同样捕获到该信号，调用my-&gt;accepted_block( bs ); 插件捕捉处理④： producer_plugin连接该信号，执行其on_block函数，传入区块数据。 1my-&gt;_accepted_block_connection.emplace(chain.accepted_block.connect( [this]( const auto&amp; bsp )&#123; my-&gt;on_block( bsp ); &#125; )); on_block该函数主要是函数首先做了校验，包括时间是否大于最后签名区块的时间以及大于当前时间，还有区块号是否大于最后签名区块号。校验通过以后，活跃生产者账户集合active_producers开辟新空间，插入计划出块生产者。接下来利用set_intersection取本地生产者与集合active_producers的交集(如果结果为空，说明本地生产者没有出块权利不属于活跃生产者的一份子)。将结果存入一个迭代器，迭代执行内部函数，如果交集生产者不等于接收区块的生产者，说明是校验别人生产的区块，如果是相等的不必做特殊处理。校验别人生产的区块，首先要在活跃生产者的key中找到匹配的key(本地生产者账户公钥)，否则说明该区块不是合法生产者签名抛弃不处理。接下来，获取本地生产者私钥，组装生产确认数据字段，包括区块id，区块摘要，生产者，签名。更新producer插件本地标志位_last_signed_block_time和_last_signed_block_num。最后发射信号confirmed_block，携带以上组装好的数据。但经过搜索，项目中目前没有对该信号设置槽connection。在区块创建之前要为该区块的生产者设置水印用来标示该区块的生产者是谁。 irreversible_block发射时机on_irreversible函数，更改区块状态为irreversible的函数，操作成功最后发射该信号。插件捕捉处理 123my-&gt;irreversible_block_connection = my-&gt;chain-&gt;irreversible_block.connect( [this]( const block_state_ptr&amp; blk ) &#123; my-&gt;irreversible_block_channel.publish( priority::low, blk ); &#125; ); chain_plugin连接该信号，由信号槽转播到channel,irreversible_block_channel发布该区块。bnet_plugin订阅该channel， 1234my-&gt;_on_irb_handle = app().get_channel&lt;channels::irreversible_block&gt;() .subscribe( [this]( block_state_ptr s )&#123; my-&gt;on_irreversible_block(s); &#125;); 依然线程池遍历会话，执行on_new_lib函数，当本地库领先时可以清除历史直到满足当前库，或者直到最后一个被远端节点所知道的区块。最后如果空闲，尝试发送下一条pingpong心跳连接信息。3 mongo_db_plugin连接该信号，执行applied_irreversible_block函数，仍旧参照mongo配置项的值决定是否储存区块、状态区块以及事务数据，然后将区块数据塞入队列等待消费。4 producer_plugin连接该信号，绑定执行函数on_irreversible_block，设置producer成员_irreversible_block_time的值为区块的时间。 accepted_transaction 发射时机：1 push_scheduled_transaction函数，推送计划事务时，将事务体经过一系列转型以及校验，接着发射该信号，承认事务。2 push_transaction函数，新事务到大状态区块，要经过身份认证以及决定是否现在执行还是延期执行，最后要插入到pending区块的receipt接收事务中去。当检查事务未被承认时，发射一次该信号。最后全部函数处理完毕，再次发射该信号。插件捕捉处理1 chain_plugin连接该信号，由信号槽转播到channel，accepted_transaction_channel发布该事务。 1234my-&gt;accepted_transaction_connection = my-&gt;chain-&gt;accepted_transaction.connect( [this]( const transaction_metadata_ptr&amp; meta ) &#123; my-&gt;accepted_transaction_channel.publish( priority::low, meta ); &#125; ); bnet_plugin订阅该channel，线程池遍历会话，执行函数on_accepted_transaction。 1234my-&gt;_on_appled_trx_handle = app().get_channel&lt;channels::accepted_transaction&gt;() .subscribe( [this]( transaction_metadata_ptr t )&#123; my-&gt;on_accepted_transaction(t); &#125;); 123456789101112131415161718192021222324void on_accepted_transaction( transaction_metadata_ptr t ) &#123; auto itr = _transaction_status.find( t-&gt;id ); if( itr != _transaction_status.end() ) &#123; if( !itr-&gt;known_by_peer() ) &#123; //对端未接受过该交易，修改过期时间 _transaction_status.modify( itr, [&amp;]( auto&amp; stat ) &#123; stat.expired = std::min&lt;fc::time_point&gt;( fc::time_point::now() + fc::seconds(5), t-&gt;packed_trx-&gt;expiration() ); &#125;); &#125; return; &#125; transaction_status stat; stat.received = fc::time_point::now(); //每一次事务被“accepted”，都会延时5秒钟。 //每次一个区块被应用，所有超过5秒未被应用的但被承认的事务都将被清除。 stat.expired = stat.received + fc::seconds(5); stat.id = t-&gt;id; stat.trx = t; //添加到multiindex中，用于判断是否发送过该交易，防止重复发送 _transaction_status.insert( stat ); maybe_send_next_message(); &#125; 2 mongo_db_plugin连接该信号，执行函数accepted_transaction，校验加入队列待消费。 applied_transaction 发射时机1 push_scheduled_transaction函数，事务过期时间小于pending区块时间处理后发射该信号。反之大于等于处理后发射该信号。当事务的sender发送者不为空且没有主观失败的处理后发射该信号。基于生产和校验的主观修改，主观处理后发射该信号，非主观处理发射该信号。2 push_transaction函数，发射两次该信号，逻辑较多，这段包括以上那个函数的可读性很差，注释几乎没有。插件捕捉处理1 net_plugin连接该信号，绑定函数applied_transaction，打印日志。2 chain_plugin连接该信号，由信号槽转播到channel，原理基本同上，不再重复。3 mongo_db_plugin同上。 accepted_confirmation 发射时机：1 push_confirmation函数，推送确认信息，在此阶段不允许有pending区块存在，接着fork_db添加确认信息，发射该信号。插件捕捉处理2 net_plugin连接该信号，绑定函数accepted_confirmation，打印日志。插件捕捉处理1： chain_plugin连接该信号，由信号槽转播到channel，基本同上。","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"Go(02)windows环境搭建和vscode配置","date":"2019-04-01T09:08:35.000Z","path":"2019/04/01/golang02/","text":"之前讲述过linux环境下Go语言开发环境搭建，这次简述下windows的搭建以及vscode配置 windows环境搭建同样去https://studygolang.com/dl下载windows环境go安装包直接下载msi安装 双击安装，选择安装位置。Golang在安装完成后会在系统变量中自动添加一个GOROOT变量，这个变量就是Golang的安装目录。还会在 Path变量中自动添加一个 D:\\Go\\bin 变量，这是Golang的安装目录下的bin目录在D盘新建文件夹github\\golang-(读者可以根据喜好自己创建文件夹)，在golang-中在新建三个子目录：src(此目录用来存放项目源代码)pkg(此目录用来存放项目编译后的生成文件)bin(此目录用来存放编译后生成的可执行文件)在回到系统环境变量中，手动添加 GOPATH 变量，值为：D:\\github\\golang-在找到Path变量，然后点击编辑按钮，添加D:\\github\\golang-\\bin打开命令行（windows键+R，输入cmd点击确定），输入命令 go version后显示出golang的版本则配置成功在src下创建一个hello.go文件，代码如下 12345package mainimport &quot;fmt&quot;func main() &#123;fmt.Println(&quot;Hello Wolrd&quot;)&#125; 运行该文件，可以看到效果到此为止windows环境搭建好了。 vscode 环境搭建由于vscode编译go需要一些目录和包，自动点击运行或者点击F5提示缺少安装包，vscode自动安装，但是安装仍然失败解决办法，在自己的项目目录(我的目录)D:\\github\\golang-\\src下创建golang.org，在golang.org内创建x，在D:\\github\\golang-\\src\\golang.org\\x内执行git命令 12git clone https://github.com/golang/tools.git toolsgit clone https://github.com/golang/lint.git lint 接下来进入vscode，点击hello.go文件，运行F5，就可以看到效果了设置缩进格式和空格缩进 command + shift + p ，然后输入indent usingspace 并可以修改 sapce 大小，将tab替换为space的大小可以修改设置里的 tabSize 参数 有时候为了方便，可能要在src下建立个单独的文件夹，文件夹内再建立go文件如下图的variables.go,是在src/day02目录下。直接运行F5是无法通过的，需要修改launch.json，将program配置为${workspaceRoot}/src/day02即可。workspaceRoot表示打开的文件夹，我这里是D:\\github\\golang-。launch.json配置如下 123456789101112131415&#123;&quot;version&quot;: &quot;0.2.0&quot;,&quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Launch&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;auto&quot;, //&quot;program&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/src/day02&quot;, &quot;env&quot;: &#123;&#125;, &quot;args&quot;: [] &#125; ]&#125; 这样再次运行就可以了。谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"golang(01) linux环境搭建和编码","date":"2019-03-20T07:12:51.000Z","path":"2019/03/20/golang01/","text":"1 在自己的工作目录下建立一个goproject文件夹/home/secondtonone/goproject 2 在文件夹下建立如下三个文件bin pkg srcbin 保存执行go install 源码目录后生成的可执行文件pkg 文件夹是存在go编译生成的文件src存放的是我们的go源代码，不同工程项目的代码以包名区分 3 安装go去国内的网站下载https://studygolang.com/dl 根据不同的平台选择对应的安装包然后将压缩包解压到 /usr/local/sudo tar -C /usr/local/ -xzvf go1.10.2.linux-amd64.tar.gz 4 配置环境变量可以配置/etc/profile对所有用户起作用,也可以配置/.profile 只对当前用户起作用我配置/.profilevim ~/.profile打开后，添加如下代码 12345export GOROOT=/usr/local/goexport GOPATH=/home/secondtonone/goProject export GOBIN=$GOPATH/binexport PATH=$PATH:$GOROOT/binexport PATH=$PATH:$GOPATH/bin 保存后执行 source ~/.profile 刷新下配置执行go version 可以看到配置好了go版本简单说下上述配置GOROOT表示你golang的安装目录GOPATH 表示 你工程的路径GOBIN目录是执行 go install 后生成可执行文件的目录然后将两个路径导入到PATH中。 5 编写代码测试在goProject下src文件夹里，创建两个文件夹，分别是calcsrc和simplemath，在calcsrc中创建calc.go文件，源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport &quot;os&quot;// 用于获得命令行参数os.Argsimport &quot;fmt&quot;import &quot;simplemath&quot;import &quot;strconv&quot;var Usage = func() &#123; fmt.Println(&quot;USAGE: calc command [arguments] ...&quot;) fmt.Println(&quot;\\nThe commands are:\\n\\tadd\\tAddition of two values.\\n\\tsqrt\\tSquare root of a non-negative value.&quot;)&#125;func main() &#123; args := os.Args if args == nil || len(args) &lt; 2 &#123; Usage() return &#125; switch args[1] &#123; case &quot;add&quot;: if len(args) != 4 &#123; fmt.Println(&quot;USAGE: calc add &lt;integer1&gt;&lt;integer2&gt;&quot;) return &#125; v1, err1 := strconv.Atoi(args[2]) v2, err2 := strconv.Atoi(args[3]) if err1 != nil || err2 != nil &#123; fmt.Println(&quot;USAGE: calc add &lt;integer1&gt;&lt;integer2&gt;&quot;) return &#125; ret := simplemath.Add(v1, v2) fmt.Println(&quot;Result: &quot;, ret) case &quot;sqrt&quot;: if len(args) != 3 &#123; fmt.Println(&quot;USAGE: calc sqrt &lt;integer&gt;&quot;) return &#125; v, err := strconv.Atoi(args[2]) if err != nil &#123; fmt.Println(&quot;USAGE: calc sqrt &lt;integer&gt;&quot;) return &#125; ret := simplemath.Sqrt(v) fmt.Println(&quot;Result: &quot;, ret) default: Usage() &#125;&#125; 在simplemath文件加下分别创建add.go和sqrt.goadd.go 1234package simplemathfunc Add(a int, b int) int &#123; return a + b&#125; sqrt.go 123456package simplemathimport &quot;math&quot;func Sqrt(i int) int &#123; v := math.Sqrt(float64(i)) return int(v)&#125; 6 编译并运行程序可以在/home/secondtonone/goproject/src/calcsrc文件夹下执行go build calc.go，该文件夹下生成calc可执行文件，然后运行./calc add 2 3 可以看到结果也可以在/home/secondtonone/goproject/src 下执行go install calcsrc,在/home/secondtonone/goproject/bin下生成 calc可执行程序然后运行./calc add 3 2 也可以看到结果 到此为止环境搭建和基本的demo写完了，后续会不断更新golang学习笔记谢谢关注我的公众号","categories":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.limerence2017.com/tags/golang/"}]},{"title":"eocs跨链合约区块数据结构设计与实现","date":"2019-03-15T04:01:47.000Z","path":"2019/03/15/eos8/","text":"核心数据结构分析123456struct block_header &#123; block_timestamp_type timestamp; account_name producer; //省略部分结构...... static uint32_t num_from_id(const block_id_type&amp; id);&#125; 结构体中timestamp是块打包好的时间戳，previous是前一个块的id，transaction_mroot表示所有交易的merkle root， action_root表示 action的merkle root。num_from_id通过blockid找到blocknum。 1234struct signed_block_header : block_header &#123; signature producer_signature; EOSLIB_SERIALIZE_DERIVED(signed_block_header, block_header, (producer_signature))&#125;; struct signed_block_header :该结构体继承了block_header，内部包含了producer_signature，提供了生产者的签名struct block_header_state：包括块基本的信息，blockid，blocknum，以及signed_block_header签名头信息。 struct block_header_with_merkle_path：包括block_header_state 类型的block_header，以及由id序列构成的merkle_path，这个merkle_path中的blockid需要一个链接一个，不能间断，此外最后一个blockid需要指向block_header的前一个id。 struct action_receipt :表示一个action的收据，包括接受者，摘要信息，授权顺序，接受顺序，编码顺序等。用UML图表示上述各类之间关系: 核心api解析1234uint32_t block_header::num_from_id(const block_id_type&amp; id)&#123; return endian_reverse_u32(uint32_t(*reinterpret_cast&lt;const uint64_t*&gt;(id.hash)));&#125; 取出id的hash值，然后将高32位反转获得blocknum 123456checksum256 block_header::id() const &#123;auto result = sha256(*this);*reinterpret_cast&lt;uint64_t*&gt;(result.hash) &amp;= 0xffffffff00000000;*reinterpret_cast&lt;uint64_t*&gt;(result.hash) += endian_reverse_u32(block_num());return result;&#125; 计算id时，将自身256hash值去高32位，与之前获得的blocknum()高32位反转后相加，得到id号。 123digest_type block_header::digest() const &#123;return sha256(*this);&#125; 获取摘要，就是将自己进行256hash得到摘要。 1234567template &lt;typename T&gt;checksum256 sha256(const T&amp; value) &#123;auto digest = pack(value);checksum256 hash;::sha256(digest.data(), uint32_t(digest.size()), &amp;hash);return hash;&#125; sha256是我们eocs团队自己封装的基于万能类型模板实现的hash函数，首先将value打包，然后将hash结果保存在变量hash中，返回此结果作为digest。 123456void block_header_state::validate() const &#123;auto d = sig_digest();assert_recover_key(&amp;d, (const char*)(header.producer_signature.data), 66, (const char*)(block_signing_key.data), 34);eosio_assert(header.id() == id, &quot;invalid block id&quot;); // TODO: necessary?&#125; 该函数先计算摘要，然后根据摘要去除header的生产者签名信息和块签名key值。接下来判断header的id是否和自己的id匹配。 123456producer_key block_header_state::get_scheduled_producer(block_timestamp_type t)const &#123;// TODO: block_interval_ms/block_timestamp_epoch configurable?auto index = t.slot % (active_schedule.producers.size() * producer_repetitions);index /= producer_repetitions;return active_schedule.producers[index];&#125; 该函数获取轮询的生产者，producer_repetitions为重复的生产者数量，index除以该数量获取轮询的次数，进而根据轮询表里index索引取出对应的生产者。 1234567891011uint32_t block_header_state::calc_dpos_last_irreversible()const &#123;vector&lt;uint32_t&gt; blocknums;blocknums.reserve(producer_to_last_implied_irb.size());for (auto&amp; i : producer_to_last_implied_irb) &#123;blocknums.push_back(i.second);&#125;if (blocknums.size() == 0) return 0;std::sort(blocknums.begin(), blocknums.end());return blocknums[(blocknums.size() - 1) / 3];&#125; 该函数计算最后一个不可逆区块num，首先定义了blocknums的序列，然后根据producer_to_last_implied_irb(包含不可逆区块的生产者map)，将对应的区块nums放入blocknums序列，之后，根据序列大小-1再除以三得到区块索引，就是最后的不可逆区块号。 到此为止","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"python学习(28) 浅谈可变对象的单例模式设计","date":"2019-03-13T02:42:07.000Z","path":"2019/03/13/python28/","text":"python开发，有时候需要设计单例模式保证操作的唯一性和安全性。理论上python语言底层实现和C/C++不同，python采取的是引用模式，当一个对象是可变对象，对其修改不会更改引用的指向，当一个对象是不可修改对象，对其修改会改变引用指向。 可变对象和不可变对象不可变对象该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。 可变对象该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。 python 中的可变对象和不可变对象Python中，数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set,以及开发人员自己定义的类是可变类型 python 和C/C++ 内存分配差异123456a = 2b = 2c = a + 0 c += 0print(id(a), id(b), id(2)) # id都相同print(c is b) #True python 中变量a,b,c都是常量2的引用，所以他们的地址空间都相同。在C/C++中,a,b,c是三个变量，每个变量地址都不一样，这一点大家在学习语言时要注意，这算是python的特性吧。同样的道理，字符串也是一样的 12345astr = &#x27;good&#x27;bstr = &#x27;good&#x27;cstr = astr + &#x27;&#x27;print(cstr is bstr) # Trueprint(id(astr), id(bstr), id(&#x27;good&#x27;)) # 三个id相同 字符串也是不可变对象，所以astr,bstr,cstr指向的都’good’所在空间如果修改astr,则astr指向改变了 1234astr = &#x27;good&#x27;print(id(astr))astr += &#x27;aa&#x27;print(id(astr)) # id和上面的不一样 因为str是不可变对象，当修改它的值后变为’goodaa’，那么astr指向的地址也改变为’goodaa’所在地址。id(astr)和之前的不一样了。 12345lis = [1, 2, 3]lis2 = [1, 2, 3]# 虽然它们的内容一样，但是它们指向的是不同的内存地址print(lis is lis2)print(id(lis), id(lis2), id([1, 2, 3])) # 三个id都不同 虽然lis和lis2内容一样，但是可变对象都会单独开辟空间，所以上边三个id打印结果都不一样。 12345678alist = [1, 2, 3]# alist实际上是对对象的引用，blist = alist即引用的传递，现在两个引用都指向了同一个对象（地址）blist = alistprint(id(alist), id(blist)) # id一样# 所以其中一个变化，会影响到另外一个blist.append(4)print(alist) # 改变blist, alist也变成了[1 ,2 ,3 4]print(id(alist), id(blist)) # id一样，和上面值没有改变时候的id也一样 blist赋值为alist，这两个指向同一个地址，当修改blist时，alist也改变了，所以打印两个id都是一样的。一般我们自己定义的类也是可变对象，我们想做的是通过设计一个单例类实现统一的控制，这样便于管理，比如网络模块，比如数据库处理模块等等。下面浅谈三种单例模式设计 python 单例模式设计方法一：使用装饰器装饰器维护一个字典对象instances，缓存了所有单例类，只要单例不存在则创建，已经存在直接返回该实例对象。 1234567891011121314def singleton(cls): instances = &#123;&#125; def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass Foo(object): passfoo1 = Foo()foo2 = Foo()print foo1 is foo2 singleton函数中定义了instances字典，当使用它作为装饰器装饰Foo后instances也会被缓存在闭包环境中，第一次使用Foo()后，instances就回被设置为instances[Foo]=Foo(),这样根据类名就可以区分是否被初始化过，从而实现单例模式 方法二：使用基类__new__是真正创建实例对象的方法，所以重写基类的__new__方法，以此来保证创建对象的时候只生成一个实例 1234567891011121314class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, &#x27;_instance&#x27;): cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instanceclass Foo(Singleton): passfoo1 = Foo()foo2 = Foo()print foo1 is foo2 # True __new__在一个类构造实例对象时会调用，所以通过判断hasattr，是否含有某个属性，即可实现单例模式。super(Singleton,cls)调用的是Singleton的基类。我目前用的是这种方式实现的单例，用作网络和数据库管理。 方法三：使用元类元类（参考：深刻理解Python中的元类）是用于创建类对象的类，类对象创建实例对象时一定会调用__call__方法，因此在调用__call__时候保证始终只创建一个实例即可，type是python中的一个元类 123456789101112131415class Singleton(type): def __call__(cls, *args, **kwargs): if not hasattr(cls, &#x27;_instance&#x27;): cls._instance = super(Singleton, cls).__call__(*args, **kwargs) return cls._instanceclass Foo(object): __metaclass__ = Singletonfoo1 = Foo()foo2 = Foo()print foo1 is foo2 # True 这种方式和new类似，都是通过系统级的函数__call__进行控制。通过在类中设置元类从而实现单例控制。 到目前为止，单例模式介绍完毕，感谢关注我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"EOCS中继网络源码剖析","date":"2019-02-17T12:47:03.000Z","path":"2019/02/17/eos7/","text":"EOCS中继网络实现了两种模式，分别是eoc模式和icp模式，今天先介绍eoc模式。 eoc_relay_plugin 源码剖析 在eoc_relay_plugin.cpp中 1static appbase::abstract_plugin&amp; _eoc_relay_plugin = app().register_plugin&lt;eoc_relay_plugin&gt;(); 向appbase中注册了eoc_relay_plugin插件。 1void eoc_relay_plugin::set_program_options(options_description&amp;, options_description&amp; cfg); 该函数将config中配置的参数设置导入eoc_relay_plugin中，内部调用了plugin_initialize和init_eoc_relay_plugin函数，设置eoc_relay_plugin必备的参数。接着调用 123456789101112131415161718192021222324252627void eoc_relay_plugin::plugin_startup() &#123; ilog(&quot;starting eoc_relay_plugin&quot;); //sendstartaction(); auto &amp;chain = app().get_plugin&lt;chain_plugin&gt;().chain(); FC_ASSERT(chain.get_read_mode() != chain::db_read_mode::IRREVERSIBLE, &quot;icp is not compatible with \\&quot;irreversible\\&quot; read_mode&quot;); relay_-&gt;start(); chain::controller &amp;cc = relay_-&gt;chain_plug-&gt;chain(); &#123; cc.applied_transaction.connect(boost::bind(&amp;eoc_icp::relay::on_applied_transaction, relay_.get(), _1)); cc.accepted_block_with_action_digests.connect(boost::bind(&amp;eoc_icp::relay::on_accepted_block, relay_.get(), _1)); cc.irreversible_block.connect(boost::bind(&amp;eoc_icp::relay::on_irreversible_block, relay_.get(), _1)); &#125; relay_-&gt;start_monitors(); for (auto seed_node : relay_-&gt;connect_to_peers_) &#123; connect(seed_node); &#125; if (fc::get_logger_map().find(icp_logger_name) != fc::get_logger_map().end()) icp_logger = fc::get_logger_map()[icp_logger_name]; // Make the magic happen &#125; 该函数主要是实现插件的启动，内部绑定了controller的applied_transaction,accepted_block_with_action_digests,irreversible_block信号，当收到这些信号，就会自动调用relay的三个函数。上面就是eoc_relay_plugin的核心通信代码，内部的网络消息流程和net_plugin类似，通过icp_relay类完成网络消息的控制，以及回调函数的逻辑处理。 12345void relay::start_monitors( )&#123; connector_check.reset(new boost::asio::steady_timer( app().get_io_service())); start_conn_timer(connector_period, std::weak_ptr&lt;icp_connection&gt;());&#125; 该函数设置了定时器，检测连接是否成功，不成功则定时重连。 1234567891011121314151617181920212223void relay::start() &#123; ioc_ = std::make_unique&lt;boost::asio::io_context&gt;(num_threads_); timer_ = std::make_shared&lt;boost::asio::deadline_timer&gt;(app().get_io_service()); auto address = boost::asio::ip::make_address(endpoint_address_); update_local_head(); if( acceptor ) &#123; acceptor-&gt;open(listen_endpoint.protocol()); acceptor-&gt;set_option(tcp::acceptor::reuse_address(true)); try &#123; acceptor-&gt;bind(listen_endpoint); &#125; catch (const std::exception&amp; e) &#123; ilog(&quot;eoc_relay_plugin::plugin_startup failed to bind to port $&#123;port&#125;&quot;, (&quot;port&quot;, listen_endpoint.port())); throw e; &#125; acceptor-&gt;listen(); ilog(&quot;starting listener, max clients is $&#123;mc&#125;&quot;,(&quot;mc&quot;,max_client_count)); start_listen_loop(); &#125;&#125; 该函数启动了eoc插件的网络监听事件，start_listen_loop就是控制的网络事件循环监听。 123456789void relay::send_icp_net_msg(const icp_net_message&amp; msg) &#123; send_icp_notice_msg(icp_notice_message&#123;local_head_&#125;); for( const auto&amp; c : connections ) &#123; c-&gt;send_icp_net_msg(msg); &#125; &#125; 中继间通信是通过网络tcp点对点发送的，该函数就是封装了icp_net_message发送的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041void relay::on_applied_transaction(const transaction_trace_ptr&amp; t) &#123; //ilog(&quot;on applied transaction&quot;); //...... for (auto&amp; action: t-&gt;action_traces) &#123; if (action.receipt.receiver != action.act.account) &#123; ilog(&quot;action.receipt.receiver != action.act.account&quot;); continue; &#125; if (action.act.account != local_contract_ or action.act.name == ACTION_DUMMY) &#123; // thirdparty contract call or icp contract dummy call //ilog(&quot;on applied transaction action dumy!!!&quot;); for (auto&amp; in: action.inline_traces) &#123; if (in.receipt.receiver != in.act.account) continue; if (in.act.account == local_contract_ and in.act.name == ACTION_SENDACTION) &#123; for (auto &amp;inin: in.inline_traces) &#123; if (inin.receipt.receiver != inin.act.account) continue; if (inin.act.name == ACTION_ISPACKET) &#123; auto seq = icp_packet::get_seq(inin.act.data, st.start_packet_seq); st.packet_actions[seq] = send_transaction_internal&#123;ACTION_ONPACKET, inin.act, inin.receipt&#125;; &#125; &#125; &#125; &#125; &#125; else if (action.act.account == local_contract_) &#123; if (action.act.name == ACTION_ADDBLOCKS or action.act.name == ACTION_OPENCHANNEL) &#123; ilog( &quot;on_applied_transaction ,action name is $&#123;p&#125;&quot;,(&quot;p&quot;, action.act.name) ); app().get_io_service().post([this] &#123; update_local_head(); &#125;); &#125; else &#123; //.... &#125; &#125; if (st.empty()) return; //send_transactions_.insert(st); update_send_transaction_index(st);&#125; 该函数是跨链交易处理的核心逻辑，分别处理了不同类型的action，如ACTION_ADDBLOCKS，ACTION_OPENCHANNEL等。同样，由于eoc_relay既要发送消息，也要接收消息，所以封装了几个消息处理函数如 1234567891011121314151617void relay::handle_message( icp_connection_ptr c, const icp_notice_message &amp; msg) &#123; ilog(&quot;received icp_notice_message&quot;); if (not msg.local_head_.valid()) return; app().get_io_service().post([=, self=shared_from_this()] &#123; if (not peer_head_.valid()) &#123; clear_cache_block_state(); &#125; peer_head_ = msg.local_head_; &#125;); // TODO: check validity icp_peer_ilog(c, &quot;received icp_notice_message&quot;); ilog(&quot;received icp_notice_message&quot;); &#125; 该函数处理icp_notice_message。详细细节，读者可以下载源码仔细读一读，eoc_relay_plugin核心代码剖析就介绍这些了。","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"EOCS跨链核心技术内幕","date":"2019-02-11T14:16:36.000Z","path":"2019/02/11/eos6/","text":"EOCS跨链技术的核心就是ICP模块，ICP即Inter Chain Protocol(跨链交互协议)，下面着重介绍ICP工作原理和实现细节。 Inter Chain Protocol(ICP)ICP Overview建立于EOSIO软件堆栈之上的ICP跨链基础设施，可应用于EOSIO兼容的同构区块链的跨链通信。ICP设计之初，就考虑怎样以一种无侵入、可安全验证、去中心化的方式来实现EOS多链并行的同构跨链网络。经过对业界最前沿的跨链技术的研究（包括BTC Relay、Cosmos、Polkadot等），并结合对EOSIO软件实现细节的差异化剖析，ICP采取了比较现实的跨链方案： 实现类似于轻节点的跨链基础合约，对对端区块链进行区块头跟随和验证，使用Merkle树根和路径验证跨链交易的真实性，依赖全局一致的顺序来保证跨链交易同时遵循两条链的共识。实现无需信任、去中心化的跨链中继，尽最大可能地向对端传递区块头和跨链交易，并对丢失、重复、超时、伪造的跨链消息进行合适的处理。 整体框架图 ICP RelayICP中继作为nodeos的插件，可随nodeos节点部署。部署模式上有几点需要说明：不需要每个nodeos都开启ICP中继插件。尽量多的nodeos开启ICP中继插件，将有助于保证跨链中继工作的不中断。如果所有中继均瘫痪，将中断后续跨链交易进行，但不会影响已经发生的跨链交易；中继恢复后，将造成中断期某些跨链交易超时，但不会影响后续跨链交易的安全验证（这类似于所有nodeos节点瘫痪也会造成EOS区块链暂停）。本端ICP中继可以连接对端多个ICP中继。本端开启了ICP中继的nodeos之间可链内P2P互连(net_plugin/bnet_plugin)，但不可ICP P2P互连(icp_relay_plugin)。本端ICP中继插件负责向本端跨链合约查询或发送交易，但不能直接向对端跨链合约查询或发送交易，而只能借助于与对端ICP中继的P2P通信。ICP 通信和工作流程 ICP Network基于EOSIO的两条同构区块链，需对称部署一对跨链中继和跨链合约。那么要达成多条区块链之间的ICP跨链通信，可在每两条链之间都这样部署。其实，从ICP基础设施的角度来说，ICP只负责两条区块链之间的跨链通信。如果要建立无感知的平滑跨越数条区块链的跨链通信网络，可在ICP基础合约之上编写合约构建跨链网络协议(Inter Chain Network Protocol)。ICP 跨链网络通信原理 ICP 插件在eos基础上新增了icp_plugin和eoc_plugin, 该功能为可扩充性增加，支持迭代更新，和eos核心功能零耦合。eos网络启动方式分为bnet_plugin和net_plugin模式，所以eocs实现了icp_plugin(对应icp_plugin模式)和eoc_plugin(对应net_plugin模式)这两种插件之后会详细解析源码。 ICP 合约底层实现ICP合约底层实现分为types,merkle,icp,fork四个模块，分别为数据消息类型管理，merkle控制类，icp核心关系，fork类。具体实现细节之后会详细讲解目前为止EOCS核心跨链内幕已经初步介绍完毕，源码解析和思想设计后续不断更新谢谢关注我的公众号","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"EOCS框架概述和剖析","date":"2019-02-10T04:28:52.000Z","path":"2019/02/10/eos5/","text":"什么是EOCS？EOCS(Enterprise Operation Cross System),是一个基于eosio底层框架实现的企业级跨链操作系统，旨在实现和EOS主链通信的并行链，是真正意义的跨链，支持高效稳定的跨链交易，为跨链生态建设提供更稳定和安全的平台。作为可与EOS主链交互操作的第一条并行链，EOCS Chain力图实现安全可靠、快捷便利的跨链资产转移、跨链智能合约调用。任何人都可以在EOCS Chain并行链上开发或使用跨链DAPP。 为什么选择EOCS？互操作性EOCS Chain并行链允许EOS主链与主流公有链、联盟链、私有链互相通信和价值交换。 可扩展性通过多链互联互操作，EOCS Chain可帮助EOS实现史无前例的无限扩展。 开发友好性EOCS Chain延续了EOS软件堆栈的WebAssembly机制，可以非常轻松地开发DAPP。 EOCS发展路径 EOCS核心竞争力EOCS Chain并行链与EOS主链之间的同构跨链，涉及以下组件：同构跨链协议（Isomorphic Inter-Chain Protocol, ICP） 同构跨链合约，在并行链和主链上同时部署，支持跨链协议包的解析，证明的验证和存储，以及EOS原生币（EOS）、EOCS Chain原生币（EOCS）、EOS代币的跨链资产转移 同构跨链通道，通过逻辑证明确保通道建立的稳定性和安全性。 中继者，将跨链协议包在并行链和主链之间安全快速地传输 EOCS Chain异构跨链尝试与探索我们相信未来的区块链不仅在去中心化社区中得到商业落地前景，千万中小企业同样需要区块链作为价值传递的基础服务，未来不仅是公有链、联盟链还是企业内部的私有链，都需要在一个公用网络中进行价值传递和证明。 作为第一条EOS同构并行链，我们将在开发EOCS Chain的基础上，继续探索和研究异构链的跨链协议，不仅要为EOS生态做出支持百万TPS的并行链体系，更要为整个EOS体系连接异构链做出创造性的贡献，作为连接EOS主链及整个EOS跨链群体系与其他区块链链的纽带，为所有异构区块链公链、联盟链、私有链实现安全、快捷、无限扩展的区块链生态体系! EOCS整体框架简图 如何使用EOCS编译和部署EOCS 支持多种Linux操作系统，mac，centos，ubuntu等等，可以去github下载源码并编译，源码下载地址，https://github.com/eocschain/eocs。在自己的工作目录(可自己设定)执行命令 git clone https://github.com/eocschain/eocs 更新下载源码。下载后文件组织结构如下在该目录下执行eosio_build.sh,会生成build目录，执行成功会提示build success!!! 填写配置在~/.local/share/eosio目录下有config和data文件夹，修改config.ini即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# Override default WASM runtime (eosio::chain_plugin)wasm-runtime = wabt# print contract&#x27;s output to console (eosio::chain_plugin)# 方便观察跨链合约打印信息contracts-console = true# The local IP and port to listen for incoming http connections; set blank to disable. (eosio::http_plugin)# 链1为127.0.0.1:8888，链2为127.0.0.1:8889http-server-address = 127.0.0.1:8888 # 或 127.0.0.1:8889# The endpoint upon which to listen for incoming connections (eosio::icp_relay_plugin)# 链1为0.0.0.0:8765，链2为0.0.0.0:8766icp-relay-endpoint = 0.0.0.0:8765 # 或 0.0.0.0:8766# The number of threads to use to process network messages (eosio::icp_relay_plugin)# icp-relay-threads = # Remote endpoint of other node to connect to (may specify multiple times) (eosio::icp_relay_plugin)# 链1为127.0.0.1:8766，链2为127.0.0.1:8765；其实只要填一个，使得两条链的ICP插件能够连接上icp-relay-connect = 127.0.0.1:8766 # 或 127.0.0.1:8765# The chain id of icp peer (eosio::icp_relay_plugin)# 链1填写链2的chain id，链2填写链1的chain id，可参考后文获取方式后再填写icp-relay-peer-chain-id = 630f427c3007b42929032bc02e5d6fded325b3e2caf592f963070381b2787a9d# The peer icp contract account name (eosio::icp_relay_plugin)# 对端ICP合约账户名；链1填写链2上跨链合约账户名，链2填写链1上跨链合约账户名icp-relay-peer-contract = eocseosioicp# The local icp contract account name (eosio::icp_relay_plugin)# 本端ICP合约账户名；链1填写链1上跨链合约账户名，链2填写链2上跨链合约账户名icp-relay-local-contract = eocseosioicp# The account and permission level to authorize icp transactions on local icp contract, as in &#x27;account@permission&#x27; (eosio::icp_relay_plugin)# ICP插件向本端ICP合约发送交易时使用的账户名icp-relay-signer = eocseosrelay@active# The actual host:port used to listen for incoming p2p connections. (eosio::net_plugin)# 链1为0.0.0.0:9876，链2为0.0.0.0:9877p2p-listen-endpoint = 0.0.0.0:9876 # 或 0.0.0.0:9877# Limits the maximum time (in milliseconds) that is allowed a pushed transaction&#x27;s code to execute before being considered invalid (eosio::producer_plugin)# 设置足够大的最大交易执行时间，可参看ICP Challenges中关于计算量的说明max-transaction-time = 300# ID of producer controlled by this node (e.g. inita; may specify multiple times) (eosio::producer_plugin)# 这里测试链仅使用生产者eosioproducer-name = eosio# 填写账户eosio的公私钥，这里使用了默认值signature-provider = EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV=KEY:5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3# 插件plugin = eosio::chain_api_plugin 启动节点进入build/programs/nodes,执行nodes,启动节点到此为止，EOCS概述和节点启动简介完毕，下一篇为大家带来EOCS的跨链设计和源码剖析","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"eos交易同步过程和区块生产过程源码分析","date":"2019-01-30T02:29:25.000Z","path":"2019/01/30/eos4/","text":"交易同步过程1 通过命令cleos调用 cleos transfer ${from_account} ${to_account} ${quantity} 发起交易2 eos调用chain_plugin 的push_transaction,内部调用注册好的方法。 1app().get_method&lt;incoming::methods::transaction_async&gt;(); 代码截图如下在producer_plugin插件的plugin_initialize函数中提前注册了incoming::methods::transaction_async。所以实际调用了producer_plugin_impl的on_incoming_transaction_async(trx, persist_until_expired, next )函数,传递的参数分别是pretty_input,true,和一个lambda匿名函数 12345678910111213141516171819app().get_method&lt;incoming::methods::transaction_async&gt;()(pretty_input, true, [this, next](const fc::static_variant&lt;fc::exception_ptr, transaction_trace_ptr&gt;&amp; result) -&gt; void&#123; if (result.contains&lt;fc::exception_ptr&gt;()) &#123; next(result.get&lt;fc::exception_ptr&gt;()); &#125; else &#123; auto trx_trace_ptr = result.get&lt;transaction_trace_ptr&gt;(); try &#123; chain::transaction_id_type id = trx_trace_ptr-&gt;id; fc::variant output; try &#123; output = db.to_variant_with_abi( *trx_trace_ptr, abi_serializer_max_time ); &#125; catch( chain::abi_exception&amp; ) &#123; output = *trx_trace_ptr; &#125; next(read_write::push_transaction_results&#123;id, output&#125;); &#125; CATCH_AND_CALL(next); &#125; &#125;); 3 在producer_plugin_impl的on_incoming_transaction_async中调用controller的 push_transaction，并执行trx。将交易插入_pending_incoming_transactions中接下来调用了controller的push_transaction函数4 controller的push_transaction函数中发送消息accepted_transaction，而目前常用的网络插件为bnet_plugin,net_plugin目前已作为备用,由于在bnet_plugin的startup函数中绑定了消息回调函数 1234my-&gt;_on_appled_trx_handle = app().get_channel&lt;channels::accepted_transaction&gt;() .subscribe( [this]( transaction_metadata_ptr t )&#123; my-&gt;on_accepted_transaction(t); &#125;); 通过app().get_channel将channels::accepted_transaction信号和lambda表达式绑定起来，所以当controller发送信号accepted_transaction就会调用这个lambda表达式传递参数，从而调用bnet_plugin_impl中on_accepted_transaction函数。5 bnet_plugin_impl通过on_accepted_transaction将消息广播到其他节点 1234void on_accepted_transaction( transaction_metadata_ptr trx ) &#123; if( trx-&gt;implicit || trx-&gt;scheduled ) return; for_each_session( [trx]( auto ses )&#123; ses-&gt;on_accepted_transaction( trx ); &#125; ); &#125; 6 其他节点收到消息后，进入on处理流程，发送transction消息bnet_plugin处理消息函数transaction消息处理通过 1app().get_channel&lt;incoming::channels::transaction&gt;().publish(p); 发送transaction消息。7 producer_plugin绑定了消息处理的回调函数收到消息后，调用on_incoming_transaction_async，调用controller的 push_transaction，并执行trx。以上就是eos交易同步过程。 区块生产过程整体的区块生产流程1 检查自己是否是生产者，一个生产者500ms出一次块，共出12次之后切换生产者。2 对上次确认的区块到本次的区块做BFT签名，涉及函数set_confirmed和maybe_promote_pending,具体可以参看controller中start_block函数3 等待一个出块周期500ms4 计算action的merkle root5 计算transaction的merkle root6 对区块签名7 提交区块到DB8 递归调用schedule_production_loop区块生产流程图 区块同步过程1 参考区块生产过程，producer_plugin循环生产区块，先start_block处理BFT签名并确定不可逆的区块数，之后produce_block调用controller2 controller使用finalize_block计算merkle root，使用commit_block提交到fork database中，只截取commit_block部分代码 123456789101112131415161718void commit_block( bool add_to_fork_db ) &#123; try &#123; //判断是否加入fork_db中 if (add_to_fork_db) &#123; pending-&gt;_pending_block_state-&gt;validated = true; auto new_bsp = fork_db.add(pending-&gt;_pending_block_state, true); emit(self.accepted_block_header, pending-&gt;_pending_block_state); head = fork_db.head(); EOS_ASSERT(new_bsp == head, fork_database_exception, &quot;committed block did not become the new head in fork database&quot;); &#125; emit( self.accepted_block, pending-&gt;_pending_block_state ); emit( self.accepted_block_with_action_digests, std::make_shared&lt;block_state_with_action_digests&gt;(pending-&gt;_pending_block_state, pending-&gt;_action_digests) ); &#125; catch (...) &#123; //.... &#125; &#125; 实际上controller的commit_block做了几件事 12341 设置pending_block_state为有效的2 调用fork_db 的add函数，携带pending_block_state并通过引用返回，函数返回值为一个新的block_state_ptr3 发送accepted_block_header信号4 发送accepted_block 和 accepted_block_with_action_digests信号 下面展开fork_db的add函数 12345678910block_state_ptr fork_database::add( const block_state_ptr&amp; n, bool skip_validate_previous ) &#123; //取出不可逆头 my-&gt;head = *my-&gt;index.get&lt;by_lib_block_num&gt;().begin(); auto lib = my-&gt;head-&gt;dpos_irreversible_blocknum; auto oldest = *my-&gt;index.get&lt;by_block_num&gt;().begin(); if( oldest-&gt;block_num &lt; lib ) &#123; prune( oldest ); &#125; return n; &#125; fork db会依据start_block中计算的不可逆区块数，将不可逆的区块删除(调用prune)， 12345678910111213141516void fork_database::prune( const block_state_ptr&amp; h ) &#123; auto itr = my-&gt;index.find( h-&gt;id ); if( itr != my-&gt;index.end() ) &#123; //发送不可逆信号，controller绑定了回调处理 irreversible(*itr); my-&gt;index.erase(itr); &#125; auto&amp; numidx = my-&gt;index.get&lt;by_block_num&gt;(); auto nitr = numidx.lower_bound( num ); while( nitr != numidx.end() &amp;&amp; (*nitr)-&gt;block_num == num ) &#123; auto itr_to_remove = nitr; ++nitr; auto id = (*itr_to_remove)-&gt;id; remove( id ); &#125; &#125; 并发送irreversible消息,controller绑定了该消息处理的回调函数 123fork_db.irreversible.connect( [&amp;]( auto b ) &#123; on_irreversible(b); &#125;); 3 controller收到消息后，调用on_irreversible处理发送irreversible_block消息。bnet注册了该消息处理的回调函数 1234my-&gt;_on_irb_handle = app().get_channel&lt;channels::irreversible_block&gt;() .subscribe( [this]( block_state_ptr s )&#123; my-&gt;on_irreversible_block(s); &#125;); 4 bnet_plugin 收到消息后，调用on_irreversible_block处理。并广播给其他节点。5 controller发送accepted_block_header和accepted_block消息。6 producer_plugin收到消息后， 调用on_block，calc_dpos_last_irreversible计算不可逆块。7 bnet_plugin/net_plugin 收到之后广播到其他节点。8 其他节点的bnet_plugin/net_plugin收到P2P消息后，发送block消息 123456789101112131415void on( const signed_block_ptr&amp; b ) &#123; peer_ilog(this, &quot;received signed_block_ptr&quot;); if (!b) &#123; peer_elog(this, &quot;bad signed_block_ptr : null pointer&quot;); EOS_THROW(block_validate_exception, &quot;bad block&quot; ); &#125; status( &quot;received block &quot; + std::to_string(b-&gt;block_num()) ); //ilog( &quot;recv block $&#123;n&#125;&quot;, (&quot;n&quot;, b-&gt;block_num()) ); auto id = b-&gt;id(); mark_block_status( id, true, true ); app().get_channel&lt;incoming::channels::block&gt;().publish(b); mark_block_transactions_known_by_peer( b ); &#125; 9 Producer_plugin收到block消息后调用controller的push_block函数10 Controller调用apply_block判断如果新收到的block比原有的链长，则切换到新链上11 Controller调用finalize_block计算merkle root，使用commit_block提交到DB以上就是区块同步过程。区块同步流程图感谢关注我的公众号","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"eos 源码net_plugin分析","date":"2019-01-25T09:08:26.000Z","path":"2019/01/25/eos3/","text":"1 net_plugin_impl::connect(connection_ptr c) 函数用于解析地址，内部异步回调async_resolve async_resolve 传递了lambda表达式，如果err为零，则调用connect连接指定的地址2 void net_plugin_impl::connect( connection_ptr c, tcp::resolver::iterator endpoint_itr ) 该函数将connection连接指定地址内部调用async_connect进行异步连接，如果连接成功，回调lambda表达式。lambda表达式中取出connection的weak_ptr，这么做为防止shared_ptr互相引用导致内存无法释放。如果连接失败关闭socket连接，如果地址错误关闭socket重新连接。连接成功后，调用start_session，开始监听该描述符的读事件，并且开始发送握手消息send_handshake() 3 bool net_plugin_impl::start_session( connection_ptr con )开始连接，内部调用start_read_message()，并且增加连接会话数量。4 void net_plugin_impl::start_read_message( connection_ptr conn ) 读取消息函数，内部较为复杂。内部将shared_ptr connection_ptr 赋值给connection_wptr(weak_ptr)类型变量weak_conn,也是为了防止互相引用shared_ptr造成内存无法回收，minimum_read为要读取的字节数，如果conn-&gt;outstanding_read_bytes 非0,则等于conn-&gt;outstanding_read_bytes，否则等于消息头大小。同时判断是否设置低水位标记，如果设置了低水位标记，则将低水位大小设置为取minimum_read和固定的max_socket_read_watermark的最小值。同时实现lambda表达式赋值给completion_handler，completion_handler主要功能判断传输字节是否全部传输完成。未完成，则返回差值。 5 接着 void net_plugin_impl::start_read_message( connection_ptr conn )内部调用了async_read，设置异步读取数据，有消息到来会触发回调lambada表达式。当completion_handler返回0停止读取。lambda函数内部，conn-&gt;outstanding_read_bytes.reset()重置请求等状态，conn-&gt;pending_message_buffer.bytes_to_write()表示pending_message_buffer剩余空间，还可读取多少数据。conn-&gt;pending_message_buffer.conn-&gt;pending_message_buffer.bytes_to_read() 表示pending_message_buffer已经读取多少 字节，用户需要从pending_message_buffer中读取多少。conn-&gt;outstanding_read_bytes表示buffer还有多少字节没有读取。 判断bytes_transferred &gt; conn-&gt;pending_message_buffer.bytes_to_write(),视为异常，因为可用空间不足了 ，没办法接收。conn-&gt;pending_message_buffer.advance_write_ptr(bytes_transferred); 将写指针向后推进bytes_transferred字节。write_ptr指向了pending_message_buffer的可用空间。bytes_to_write()返回可用字节数。如果conn-&gt;pending_message_buffer.bytes_to_read() &gt; 0，则会一直循环，直到读完buffer中所有数据。如果bytes_in_buffer &lt; message_header_size，则将头部未读取的数据放入outstanding_read_bytes中。否则说明读完包头数据，pending_message_buffer.peek，读取4字节数据写入message_lenghth,确定数据大小。auto total_message_bytes = message_length + message_header_size;为整个数据包大小，bytes_in_buffer &gt;= total_message_bytes 说明此时buffer已经接受完数据，调用 conn-&gt;process_next_message()处理。否则，就将剩余未读完的数据放入outstanding_read_bytes中，available_buffer_bytes表示可用字节数，如果可用字节数不足，则扩充pending_message_buffer大小。 6 bool connection::process_next_message(net_plugin_impl&amp; impl, uint32_t message_length)处理消息。位移代码没看明白，注释的意思是保存序列化前的原始信息。之后，blk_buffer.resize(message_length);重新设置大小为message_length长度，auto index = pending_message_buffer.read_index();找到当前的读索引，peek函数将message_length长度的数据读入blk_buffer中。之后创建datastream ds用来反序列化。将消息写入net_message中。接着定义了msgHandler 对象m，构造函数中传入net_plugin_impl和connection共享指针，调用msg.visit(m)。msgHandler的定义和实现msgHandler重载了()运算符，当类msgHandler对象传参(msg)时会调用impl.handle_message(c,msg)。如msgHandler h(msg)实际调用的impl.handle_message(c,msg)。net_message为static_variant类型，static_variant类中实现了visit函数visit内部调用apply函数，apply函数内部调用了visitor对象传参data，visitor就是上一层的msgHandler。net_plugin_impl::handle_message 根据参数传入不同，实现了不同的函数调用。这就是所说的visitor模式。通过net_message(static_variant类型)调用封装的visit函数，visit内部调用了visitor对象的传参，只要重载()(param)就可以实现调用。msgHandler重载operator()(const T&amp; msg)，所以调用impl.handle_message(c,msg)，而msg为不同类型，所以可实现上面的不同调用。","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"eos节点启动源码分析","date":"2019-01-22T06:02:07.000Z","path":"2019/01/22/eos2/","text":"在eos源码目录中programs/nodeos/main.cpp文件里，为节点启动的主函数main函数内部做了两件事1 初始化 application 12if(!app().initialize&lt;chain_plugin, http_plugin, net_plugin, producer_plugin&gt;(argc, argv))return INITIALIZE_FAIL; 2 application启动和插件启动 12app().startup();app().exec(); application类先说application的基本实现和常用接口，application 定义了注册插件的函数，获取插件，查找插件等功能，根据模板动态绑定的同样定义了一些私有函数和变量application 构造函数为私有的，方便实现单例模式，plugins为存储各类注册插件的map，key为插件名，value为独占的基类指针，不可copy。io_serv为boost库提供的io_service的shared_ptr，网络通信和事件注册派发会用到。initialized_plugins为已经初始化的插件vector，running_plugins为已经runing的插件vector。erased_method_ptr和erased_channel_ptr分别在method.hpp和channel.hpp中实现了定义，以后用到再分析。application类protected部分包含三个函数initialize_impl 根据配置初始化插件。plugin_initialized 将插件放入初始化vectorplugin_started 将插件放入runing vector下面是application实现的单例模式，定义全局函数app(),内部调用application类静态函数instance()application的start函数内部调用了各个插件的startup，出现异常shutdownexec()内部注册了SIGINT,SIGTERM,SIGPIPE信号，当进程收到这几个信号会导致ioservice-&gt;stop()，否则io_ser-&gt;run()一直监听等待就绪事件 plugin类abstract_plugin为所有插件继承的纯虚类，不同插件会实现各自特有的功能plugin.hpp中定义了BOOST_PP_SEQ_FOR_EACH为boost定义的宏，按照参数PLUGINS依次展开，将lambda函数l和每个PLUGIN传入APPBASE_PLUGIN_REQUIRES_VISIT，比如net_api_plugin展开展开后 1234void plugin_requires( Lambda&amp;&amp; l ) &#123; l(appbase::app().register_plugin&lt;net_plugin&gt;())l(appbase::app().register_plugin&lt;http_plugin&gt;()) &#125; 就是采用注册的lambda表达式依次调用，并且将各个插件注册到application中。plugin 继承了abstract_plugin类Impl是模板类型，不同的插件会传入不同的模板类型，initialize，startup，shutdown为虚函数，重写了基类abstract_plugin的功能。内部通过static_cast&lt;Impl*&gt;(this)转化为对应的不同模板类型的plugin，进而实现特定功能的绑定，初始化，启动，停止等。举例：net_plugin 继承了plugin，并且模板类型为net_plugin，这样当plugin调用initialize、startup、shutdown、函数，内部展开如下： 1234static_cast&lt;net_plugin*&gt;(this)-&gt;plugin_requires([&amp;](auto&amp; plug)&#123; plug.initialize(options); &#125;);static_cast&lt;net_plugin*&gt;(this)-&gt;plugin_initialize(options);static_cast&lt;net_plugin*&gt;(this)-&gt;plugin_startup();static_cast&lt;net_plugin*&gt;(this)-&gt;plugin_shutdown(); APPBASE_PLUGIN_REQUIRES((chain_plugin))展开 123void plugin_requires( Lambda&amp;&amp; l ) &#123; l(appbase::app().register_plugin&lt;chain_plugin&gt;()&#125; 所以static_cast&lt;net_plugin*&gt;(this)-&gt;plugin_requires([&amp;](auto&amp; plug){ plug.initialize(options); });实际继续展开内部调用appbase::app().register_plugin().initialize(options);完成网络部分的初始化。startup，shutdown也是一样的道理。","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"python学习(27) 利用selenium 抓取淘宝内衣秀","date":"2019-01-04T09:52:48.000Z","path":"2019/01/04/python27/","text":"selenium 是Web应用测试工具，可以利用selenium和python，以及chromedriver等工具实现一些动态加密网站的抓取。本文利用这些工具抓取淘宝内衣评价买家秀图片。 准备工作下面先安装selenium，在命令行输入python，然后输入安装命令 1pip install selenium 安装chromedriver和chrome，二者版本需要对应各版本下载地址下载完成后解压，将exe放到你的python安装目录下的scripts目录下即可。接下来分析网站，并且模拟登陆爬取数据，登陆淘宝，F12检测浏览器请求，F5刷新下，在network栏找到可以分析的几个网络请求，找到cookie 分析和编码先根据cookie登陆淘宝这段代码初始化了ChromeDriver的参数，然后根据cookie设置chrome选项，成功后刷新下页面，并且初始化reuests session，用于维持会话初始化cookie代码初始化session代码这样利用cookie就能成功登陆淘宝了利用chromedriver打开了一个新窗口，然后访问指定的商品页面,接下来要做的都是点击累计评价，然后点击图片评价选择框。累计评价的标签元素xpath在network中找到，可以通过find_element_by_xpath函数访问该标签，然后调用click函数就完成了点击,当然也可以通过presence_of_element_located超时等待查询，查不到指定标签就返回超时异常。相关接口调用比较简单，可以看看selenium基础查询和操作python selenium api代码功能是先点击评论，然后滚动1000像素位置，抓取找到评论区元素，根据评论区的图片元素找到资源地址，同时代码实现了自动点击下一页和判断末页功能。代码找到了评论列表，然后将评论列表传给getPhoto函数，抓取每个评论图片,下面是抓取图片的核心代码。 12345678910111213141516171819202122232425262728293031323334353637383940def getPhoto(self,*comentlist): try: for comments in comentlist: #print(len(comentlist)) #print(type(comments)) desc=comments.find_element_by_class_name(&#x27;tm-rate-fulltxt&#x27;).text if len(desc) == 0: desc=&#x27;abcdef&#x27; dirfix=desc[0:6] dirname=os.path.join(self.path,dirfix) if os.path.exists(dirname) == False: os.makedirs(dirname) txtname=os.path.join(dirname,desc[0:6]+&#x27;.txt&#x27;) if os.path.exists(txtname) == False: with open (txtname,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as file: file.write(desc) photos=comments.find_element_by_class_name(&#x27;tm-m-photos&#x27;) photos=photos.find_element_by_class_name(&#x27;tm-m-photos-thumb&#x27;) photos=photos.find_elements_by_tag_name(&#x27;li&#x27;) for ph in photos: phaddr=ph.get_attribute(&#x27;data-src&#x27;) print(phaddr) bigph=phaddr.split(&#x27;_4&#x27;)[0] print(bigph) imgname= os.path.join(dirname ,bigph.split(&#x27;/&#x27;)[-1]) if os.path.exists(imgname) : continue img=self.session_.get(&#x27;http:&#x27;+bigph,headers=self.headers_,cookies=self.cookiejar_).content print(&#x27;正在爬取%s&#x27; %(bigph)) with open (imgname,&#x27;wb&#x27;) as imgfile: imgfile.write(img) print(&#x27;爬取成功%s&#x27; %(bigph)) time.sleep(2) except NoSuchElementException: print(&#x27;No Element&#x27;) except TimeoutException : print(&#x27;TimeoutException&#x27;) except: print(&#x27;getPhoto exception&#x27;) pass 效果展示源码下载地址https://github.com/secondtonone1/python-我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(26) 分析Ajax爬取今日头条cosplay美女","date":"2018-12-16T10:59:58.000Z","path":"2018/12/16/python26/","text":"分析ajax请求格式，模拟发送http请求，从而获取网页代码，进而分析取出需要的数据和图片。这里分析ajax请求，获取cosplay美女图片。 登陆今日头条，点击搜索，输入cosplay 下面查看浏览器F12，点击XHR，这里能截取ajax请求，由于已经请求过该页面，所以点击F5，刷新，如下图下面我们点击name下的链接，查看headers看到请求信息可以看到请求的url为https://www.toutiao.com/search_content/?offset=0&amp;format=json&amp;keyword=cosplay&amp;autoload=true&amp;count=20&amp;cur_tab=1&amp;from=search_tab&amp;pd=synthesisoffset为0，表示当前页面的偏移量，我试着向下滑动页面，name下加载出很多连接，offset每次递增20，keyword为cosplay，是我们搜索的关键词，count表示图集的数量，其他的都不变。所以我们可以构造一个http请求，包含上面的格式。接下来看看preview的内容data就是页面加载出来的图片文章列表点击其中一个data，查看可以看得出图片列表和large图片相差的就是list和large的区别，如“http://p1-tt.bytecdn.cn/list/97e000601ee89d997af&quot;为缩略图“http://p1-tt.bytecdn.cn/large/97e000601ee89d997af&quot;为大图所以只需将list替换为larg即可。之后发送http请求，获取对应的图片即可。下面为完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import requestsimport reimport timefrom pyquery import PyQuery as pqfrom urllib.parse import urlencodeimport osUSER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;COOKIES = r&#x27;UM_distinctid=167005cc741184-02d14e2fd49b05-10724c6f-1fa400-167005cc74263a; uuid=&quot;w:5a4841d5dda248c389f83e5b9c57608a&quot;; sso_uid_tt=45b83f6c549dabd4248c611aa98222d3; toutiao_sso_user=4853db5c812f7bcb367cdcbef0967d06; sso_login_status=1; login_flag=54c7da4daac99058f7b6e4b8975cca01; sessionid=5e86f286970804ed8fd11abf0bf328e4; uid_tt=dd5e177a1cbf9746eb634307d64afd22; sid_tt=5e86f286970804ed8fd11abf0bf328e4; sid_guard=&quot;5e86f286970804ed8fd11abf0bf328e4|1541899310|15552000|Fri\\054 10-May-2019 01:21:50 GMT&quot;; tt_webid=6622406673465067021; WEATHER_CITY=%E5%8C%97%E4%BA%AC; cp=5BE7386A29798E1; tt_webid=75478811657; __tasessionId=qwly22e8r1541906736076; CNZZDATA1259612802=1520919144-1541896080-https%253A%252F%252Fwww.baidu.com%252F%7C1541901480; csrftoken=b970f054ea259eb162e572217e6756ca&#x27;REFER = &#x27;https://www.toutiao.com/search/?keyword=cosplay&#x27;class AjaxScrapy(object): def __init__(self,pages=1): try: self.m_session = requests.Session() self.m_headers = &#123;&#x27;User-Agent&#x27;:USER_AGENT, &#x27;referer&#x27;:REFER, &#125; self.m_cookiejar = requests.cookies.RequestsCookieJar() self.dirpath = os.path.split(os.path.abspath(__file__))[0] for cookie in COOKIES.split(&#x27;;&#x27;): key,value = cookie.split(&#x27;=&#x27;,1) self.m_cookiejar.set(key,value) except: print(&#x27;init error!!!&#x27;) def getOffset(self,index=0): try: params = &#123; &#x27;offset&#x27;:str(20*index), &#x27;format&#x27;:&#x27;json&#x27;, &#x27;keyword&#x27;:&#x27;cosplay&#x27;, &#x27;autoload&#x27;:&#x27;true&#x27;, &#x27;count&#x27;:&#x27;20&#x27;, &#x27;cur_tab&#x27;:&#x27;3&#x27;, &#x27;from&#x27;:&#x27;gallery&#x27;, &#125; httpaddr = &#x27;https://www.toutiao.com/search_content/?&#x27;+urlencode(params) req = self.m_session.get(httpaddr,headers=self.m_headers, cookies=self.m_cookiejar, timeout=5) if req.status_code != 200: return None res = req.json() if(&#x27;data&#x27; not in res.keys()): return None for item in res.get(&#x27;data&#x27;): if(&#x27;title&#x27; not in item.keys()): continue if(&#x27;image_list&#x27; not in item.keys()): continue titlenamelist=item[&#x27;title&#x27;].split(&#x27;/&#x27;) titlename = titlenamelist[-1] savedir=os.path.join(self.dirpath,titlename) print(&#x27;正在抓取&#x27;+titlename+&#x27;.........&#x27;) if(os.path.exists(savedir) == False): os.makedirs(savedir) imagelist = item.get(&#x27;image_list&#x27;) for imag in imagelist: if &#x27;url&#x27; not in imag.keys(): continue #print(imag[&#x27;url&#x27;]) image1,image2=imag[&#x27;url&#x27;].split(&#x27;list&#x27;) image3=imag[&#x27;url&#x27;].split(&#x27;/&#x27;)[-1] imagepath=os.path.join(savedir,image3+&#x27;.jpg&#x27;) if(os.path.exists(imagepath)): continue imageaddr = &#x27;http:&#x27;+image1+&#x27;large&#x27;+image2 imagedata=self.m_session.get(imageaddr,timeout=5) with open (imagepath,&#x27;wb&#x27;)as f: f.write(imagedata.content) print(&#x27;抓取&#x27;+titlename+&#x27;成功!!!.........&#x27;) time.sleep(1) return req.json() except: print(&#x27;get over view error&#x27;) return Noneif __name__ == &quot;__main__&quot;: try: asscrapy = AjaxScrapy() for i in range(0,5): res = asscrapy.getOffset(i) if(res == None): continue #print(type(res)) except: print(&#x27;scrapy exception!&#x27;) pass 更多源码下载;https://github.com/secondtonone1/python-/tree/master/pythoncookie个人博客https://www.limerence2017.com谢谢关注我的公总号:","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(24) 使用Xpath解析并抓取美女图片","date":"2018-11-18T11:42:13.000Z","path":"2018/11/18/python24/","text":"Xpath最初用来处理XML解析，同样适用于HTML文档处理。相比正则表达式更方便一些 Xpath基本规则123456nodename 表示选取nodename 节点的所有子节点/ 表示当前节点的直接子节点// 表示当前节点的子节点和孙子节点. 表示当前节点.. 当前节点的父节点@ 选取属性 下面举例使用下 1234567891011121314151617181920212223text = &#x27;&#x27;&#x27;&lt;div class=&quot;bus_vtem&quot;&gt; &lt;a href=&quot;https://www.aisinei.org/thread-17826-1-1.html&quot; title=&quot;XINGYAN星颜社 2018.11.09 VOL.096 唐思琪 [47+1P]&quot; class=&quot;preview&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;https://i.asnpic.win/block/74/74eab64cfa4229d58c19a64970368178.jpg&quot; width=&quot;250&quot; height=&quot;375&quot; alt=&quot;XINGYAN星颜社 2018.11.09 VOL.096 唐思琪 [47+1P]&quot;/&gt; &lt;span class=&quot;bus_listag&quot;&gt;XINGYAN星颜社&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;https://www.aisinei.org/thread-17826-1-1.html&quot; title=&quot;XINGYAN星颜社 2018.11.09 VOL.096 唐思琪 [47+1P]&quot; target=&quot;_blank&quot;&gt; &lt;div class=&quot;lv-face&quot;&gt;&lt;img src=&quot;https://www.aisinei.org/uc_server/avatar.php?uid=2&amp;size=small&quot; alt=&quot;发布组小乐&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;t&quot;&gt;XINGYAN星颜社 2018.11.09 VOL.096 唐思琪 &lt;/div&gt; &lt;div class=&quot;i&quot;&gt;&lt;span&gt;&lt;i class=&quot;bus_showicon bus_showicon_v&quot;&gt;&lt;/i&gt;5401&lt;/span&gt;&lt;span&gt;&lt;i class=&quot;bus_showicon bus_showicon_r&quot;&gt;&lt;/i&gt;1&lt;/span&gt;&lt;/div&gt; &lt;/a&gt; &lt;/div&gt;&#x27;&#x27;&#x27;from lxml import etreehtml = etree.HTML(text)result = etree.tostring(html)#打印lxml生成的字符串，如果html格式不全，会自动补全print(result.decode(&#x27;utf-8&#x27;))# 打印根节点下所有子孙节点result2 = html.xpath(&#x27;//*&#x27;)print(result2)result3 = html.xpath(&#x27;//a[@class=&quot;preview&quot;]&#x27;)print(result3) result.decode(‘utf-8’) 可以补全缺失的html格式字符串html.xpath(‘//*’)查找根节点下所有子孙节点html.xpath(‘//a[@class=”preview”]’) 在根节点所有子孙节点中找到属性class为preview的a节点。 lxml同样可以读取文件12from lxml import etreehtml = etree.parse(&#x27;./test.html&#x27;,etree.HTMLParser()) lxml 操作子节点123from lxml import etreehtml = etree.HTML(text)result = html.xpath(&#x27;//bus/a&#x27;) text 还是上面的字符串，这样可以取到bus节点下的所有子节点a 操作父节点1234from lxml import etreehtml = etree.HTML(text)result = html.xpath(&#x27;//a[@class=&quot;preview&quot;]/../@class&#x27;)print(result) 先找到class属性为preview的a节点，然后找到其父节点，接着筛选父节点的class属性，打印结果为[‘bus_vtem’] 属性匹配上面已经写过了格式为： 节点名[@属性名=”属性值”] 属性获取上面已经谢过了，格式为: 节点名/@属性名，注意这里没有[] 多属性值匹配上面的节点bus 属性class 只有一个值bus_vtem,如果新增一个值mtest，那么属性匹配要更换为contains，不然会报错 12345678910from lxml import etreetext2 = &#x27;&#x27;&#x27; &lt;div class=&quot;bus_vtem mtest&quot;&gt; hurricane! &lt;/div&gt; &#x27;&#x27;&#x27;html2 = etree.HTML(text2) result5 = html2.xpath(&#x27;//*[contains(@class, &quot;mtest&quot;)]&#x27;)# 错误用法#result5 = html.xpath(&#x27;//*[@class=&quot;mtest&quot;]&#x27;)print(result5) 多属性匹配多属性匹配用于筛选一个节点时非常方便，各个属性的判断可以用 and or != == 等操作 12345678910from lxml import etreetext3 = &#x27;&#x27;&#x27; &lt;div class=&quot;bus_vtem mtest&quot; name=&quot;hurricane&quot;&gt; hurricane! &lt;/div&gt; &lt;div class=&quot;bus_vtem mtest&quot; name = &quot;tornado&quot;&gt; tornado! &lt;/div&gt; &#x27;&#x27;&#x27;html3 = etree.HTML(text3) result6 = html3.xpath(&#x27;//*[contains(@class, &quot;mtest&quot;) and @name=&quot;hurricane&quot;]/text()&#x27;)print(result6) 文本获取在节点后加/text()即可，如result6 = html3.xpath(‘//*[contains(@class, “mtest”) and @name=”hurricane”]/text()’) 下面结合前边讲述的request，cookie，以及今天的lxml知识，实战爬取艾丝新发布的美女图片地址，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport reimport timefrom lxml import etreeUSER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;COOKIES = r&#x27;__cfduid=d78f862232687ba4aae00f617c0fd1ca81537854419; bg5D_2132_saltkey=jh7xllgK; bg5D_2132_lastvisit=1540536781; bg5D_2132_auth=479fTpQgthFjwwD6V1Xq8ky8wI2dzxJkPeJHEZyv3eqJqdTQOQWE74ttW1HchIUZpgsyN5Y9r1jtby9AwfRN1R89; bg5D_2132_lastcheckfeed=7469%7C1541145866; bg5D_2132_st_p=7469%7C1541642338%7Cda8e3f530a609251e7b04bfc94edecec; bg5D_2132_visitedfid=52; bg5D_2132_viewid=tid_14993; bg5D_2132_ulastactivity=caf0lAnOBNI8j%2FNwQJnPGXdw6EH%2Fj6DrvJqB%2Fvv6bVWR7kjOuehk; bg5D_2132_smile=1D1; bg5D_2132_seccode=22485.58c095bd095d57b101; bg5D_2132_lip=36.102.208.214%2C1541659184; bg5D_2132_sid=mElHBZ; Hm_lvt_b8d70b1e8d60fba1e9c8bd5d6b035f4c=1540540375,1540955353,1541145834,1541562930; Hm_lpvt_b8d70b1e8d60fba1e9c8bd5d6b035f4c=1541659189; bg5D_2132_sendmail=1; bg5D_2132_checkpm=1; bg5D_2132_lastact=1541659204%09misc.php%09patch&#x27;class AsScrapy(object): def __init__(self,pages=1): try: self.m_session = requests.Session() self.m_headers = &#123;&#x27;User-Agent&#x27;:USER_AGENT, #&#x27;referer&#x27;:&#x27;https://www.aisinei.org/&#x27;, &#125; self.m_cookiejar = requests.cookies.RequestsCookieJar() for cookie in COOKIES.split(&#x27;;&#x27;): key,value = cookie.split(&#x27;=&#x27;,1) self.m_cookiejar.set(key,value) except: print(&#x27;init error!!!&#x27;) def getOverView(self): try: req = self.m_session.get(&#x27;https://www.aisinei.org/portal.php&#x27;,headers=self.m_headers, cookies=self.m_cookiejar, timeout=5) html = etree.HTML(req.content.decode(&#x27;utf-8&#x27;)) #result=html.xpath(&#x27;//div[@class=&quot;bus_vtem&quot;]/a[@title!=&quot;紧急通知！紧急通知！紧急通知！&quot;]/attribute::*&#x27;) #print(result) htmllist = html.xpath(&#x27;//div[@class=&quot;bus_vtem&quot;]/a[@title!=&quot;紧急通知！紧急通知！紧急通知！&quot; and @class=&quot;preview&quot;]/@href&#x27;) titlelist = html.xpath(&#x27;//div[@class=&quot;bus_vtem&quot;]/a[@title!=&quot;紧急通知！紧急通知！紧急通知！&quot; and @class=&quot;preview&quot;]/@title&#x27;) print(htmllist) print(titlelist) print(len(htmllist)) print(len(titlelist)) time.sleep(1) pass except: print(&#x27;get over view error&#x27;)if __name__ == &quot;__main__&quot;: asscrapy = AsScrapy() asscrapy.getOverView() 通过lxml分析，可以摘取资源地址接下来爬取图片，读者可以发送request请求即可，留作课后题吧。源码下载地址https://github.com/secondtonone1/python-谢谢关注我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(25) BeautifulSoup介绍和实战","date":"2018-11-18T11:42:13.000Z","path":"2018/11/18/python25/","text":"BeautifulSoup是python的html解析库，处理html非常方便 BeautifulSoup 安装pip install beautifulsoup4 BeautifulSoup 配合的解析器123456# python标准库BeautifulSoup(html,&#x27;html.parser&#x27;)#lxml HTML 解析器BeautifulSoup(html,&#x27;lxml)#html5libBeautifulSoup(html,&#x27;html5lib&#x27;) python 标准库解析器不需要第三方库，处理效率一般，lxml比较快，需要C语言库支持，html5lib不依赖第三方库，但是效率比较低，容错好。 导入BeautifulSoup并使用12345678from bs4 import BeautifulSouphtml = &#x27;&#x27;&#x27;div id=&quot;sslct_menu&quot; class=&quot;cl p_pop&quot; style=&quot;display: none;&quot;&gt;&lt;span class=&quot;sslct_btn&quot; onClick=&quot;extstyle(&#x27;&#x27;)&quot; title=&quot;默认&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;&lt;ul id=&quot;myitem_menu&quot; class=&quot;p_pop&quot; style=&quot;display: none;&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://www.aisinei.org/forum.php?mod=guide&amp;amp;view=my&quot;&gt;帖子&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.aisinei.org/home.php?mod=space&amp;amp;do=favorite&amp;amp;view=me&quot;&gt;收藏&lt;/a&gt;&lt;/li&gt;&#x27;&#x27;&#x27;bs = BeautifulSoup(html)print(bs.prettify()) bs.prettify为格式化输出，效果如下同样可以用本地的html文本创建，也可以添加解析器lxml 12s =BeautifulSoup(&#x27;test.html&#x27;,&#x27;lxml&#x27;)print(s.prettify()) 效果是一样的 BeautifulSoup属性选择和处理处理节点tag123456789101112131415161718 html2 = &#x27;&#x27;&#x27; &lt;li class=&quot;bus_postbd item masonry_brick&quot;&gt;&lt;div class=&quot;bus_vtem&quot;&gt; &lt;a href=&quot;https://www.aisinei.org/thread-17846-1-1.html&quot; title=&quot;XIUREN秀人网 2018.11.13 NO.1228 猫宝 [50+1P]&quot; class=&quot;preview&quot; target=&quot;_blank&quot;&gt; &quot;hello world&quot; &lt;img src=&quot;https://i.asnpic.win/block/a4/a42e6c63ef1ae20a914699f183d5204b.jpg&quot; width=&quot;250&quot; height=&quot;375&quot; alt=&quot;XIUREN秀人网 2018.11.13 NO.1228 猫宝 [50+1P]&quot;/&gt; &lt;span class=&quot;bus_listag&quot;&gt;XIUREN秀人网&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;https://www.aisinei.org/thread-17846-1-1.html&quot; title=&quot;XIUREN秀人网 2018.11.13 NO.1228 猫宝 [50+1P]&quot; target=&quot;_blank&quot;&gt; &lt;div class=&quot;lv-face&quot;&gt;&lt;img src=&quot;https://www.aisinei.org/uc_server/avatar.php?uid=2&amp;size=small&quot; alt=&quot;发布组小乐&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;t&quot;&gt;XIUREN秀人网 2018.11.13 NO.1228 猫宝 [50&lt;/div&gt; &lt;div class=&quot;i&quot;&gt;&lt;span&gt;&lt;i class=&quot;bus_showicon bus_showicon_v&quot;&gt;&lt;/i&gt;6402&lt;/span&gt;&lt;span&gt;&lt;i class=&quot;bus_showicon bus_showicon_r&quot;&gt;&lt;/i&gt;1&lt;/span&gt;&lt;/div&gt; &lt;/a&gt;&lt;/div&gt;&lt;/li&gt; &#x27;&#x27;&#x27; s2 = BeautifulSoup(html2,&#x27;lxml&#x27;) print(s2.a) print(s2.a.name) print(s2.a.attrs) 节点tag 就是li,a,div这类，可以看出通过属性访问，选择出第一个匹配的结果。节点Tag也有名字，通过.name访问。通过.attrs获取节点的属性。获取节点文本通过.string即可,获取节点的子孙节点的文本可以通过text 12print(s2.a.string)print(s2.a.text) 节点的子孙节点获取节点的子节点，可以用.contents,也可以用.children, .contents返回列表形式的直接子节点, .contents返回的是一个可迭代对象。 12345print(s2.div.contents)print(s2.div.children)print(s2.div.contents[0])for i in s2.div.children: print(i) 前两个输出一样，后边的分别取第一个节点，以及遍历每一个节点。同样的道理，子孙节点，父节点，祖父节点，兄弟节点都采用这种方式获取 12345678910#孙子节点print(s2.div.descendants)#祖先节点print(s2.div.parents)#直接父节点print(s2.div.parent)#下一个兄弟节点print(s2.a.next_sibling)#前一个兄弟节点print(s2.a.previous_sibling) 节点的属性获取12print(s2.a[&quot;href&quot;])print(s2.a.get(&quot;href&quot;)) 如上两种方式都能获取属性 方法选择常用的筛选函数有find_all和find,findall返回所有匹配的结果,find返回匹配结果的 1234print(s2.find(&#x27;a&#x27;))print(s2.find_all(&#x27;a&#x27;))print(s2.find_all(re.compile(&quot;^div&quot;)))print(s2.find_all([&quot;div&quot;,&quot;li&quot;])) 可以看出findall传递参数可以是字符串，正则表达式，列表等等，其他的方法类似属性访问一样，有find_parents(),find_next_siblings()等等，用的时候再查吧。 BeautifulSoup 支持CSS选择器如果你熟悉css选择器的语法，BeautifulSoup同样支持，而且非常便利。 123456#查找节点为div的数据print(s2.select(&#x27;a&#x27;))#查找class为bus_vtem的节点print(s2.select(&#x27;.bus_vtem&#x27;))#查找id为ps的节点print(s2.select(&#x27;#ps&#x27;)) 到目前为止基本的BeautifulSoup已经介绍完，下面实战抓取一段html，并用BeautifulSoup解析提取我们需要的数据，这里解析一段美女图更新首页，提取其中的资源地址。 123456789101112131415161718192021222324252627282930313233343536373839404142#-*-coding:utf-8-*-import requestsimport reimport timefrom lxml import etreefrom bs4 import BeautifulSoupUSER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;COOKIES = &#x27;__cfduid=d78f862232687ba4aae00f617c0fd1ca81537854419; bg5D_2132_saltkey=jh7xllgK; bg5D_2132_lastvisit=1540536781; bg5D_2132_auth=479fTpQgthFjwwD6V1Xq8ky8wI2dzxJkPeJHEZyv3eqJqdTQOQWE74ttW1HchIUZpgsyN5Y9r1jtby9AwfRN1R89; bg5D_2132_lastcheckfeed=7469%7C1541145866; bg5D_2132_ulastactivity=2bbfoTOtWWimnqaXyLbTv%2Buq4ens5zcXIiEAhobA%2FsWLyvpXVM9d; bg5D_2132_sid=wF3g17; Hm_lvt_b8d70b1e8d60fba1e9c8bd5d6b035f4c=1540540375,1540955353,1541145834,1541562930; Hm_lpvt_b8d70b1e8d60fba1e9c8bd5d6b035f4c=1541562973; bg5D_2132_lastact=1541562986%09home.php%09spacecp&#x27;class AsScrapy(object): def __init__(self,pages=1): try: self.m_session = requests.Session() self.m_headers = &#123;&#x27;User-Agent&#x27;:USER_AGENT, #&#x27;referer&#x27;:&#x27;https://www.aisinei.org/&#x27;, &#125; self.m_cookiejar = requests.cookies.RequestsCookieJar() for cookie in COOKIES.split(&#x27;;&#x27;): key,value = cookie.split(&#x27;=&#x27;,1) self.m_cookiejar.set(key,value) except: print(&#x27;init error!!!&#x27;) def getOverView(self): try: req = self.m_session.get(&#x27;https://www.aisinei.org/portal.php&#x27;,headers=self.m_headers, cookies=self.m_cookiejar, timeout=5) classattrs=&#123;&#x27;class&#x27;:&#x27;bus_vtem&#x27;&#125; soup = BeautifulSoup(req.content.decode(&#x27;utf-8&#x27;),&#x27;lxml&#x27;) buslist = soup.find_all(attrs=classattrs) #print(len(buslist)) for item in buslist: if(item.a.attrs[&#x27;title&#x27;] == &quot;紧急通知！紧急通知！紧急通知！&quot;): continue print(item.a.attrs[&#x27;title&#x27;]) print(item.a.attrs[&#x27;href&#x27;]) time.sleep(1) pass except: print(&#x27;get over view error&#x27;)if __name__ == &quot;__main__&quot;: asscrapy = AsScrapy() asscrapy.getOverView() 抓取并分析出地址如下下一篇讲如何利用ajax分析动态网址，实战抓取今日头条的cosplay图片谢谢关注我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(23)requests库爬取猫眼电影","date":"2018-11-11T12:26:35.000Z","path":"2018/11/11/python23/","text":"本文介绍如何结合前面讲解的基本知识，采用requests，正则表达式，cookies结合起来，做一次实战，抓取猫眼电影排名信息。 用requests写一个基本的爬虫排行信息大致如下图 网址链接为http://maoyan.com/board/4?offset=0我们通过点击查看源文件，可以看到网页信息每一个电影的html信息都是下边的这种结构 123456789101112&lt;i class=&quot;board-index board-index-3&quot;&gt;3&lt;/i&gt; &lt;a href=&quot;/films/2641&quot; title=&quot;罗马假日&quot; class=&quot;image-link&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;&#123;movieId:2641&#125;&quot;&gt; &lt;img src=&quot;//ms0.meituan.net/mywww/image/loading_2.e3d934bf.png&quot; alt=&quot;&quot; class=&quot;poster-default&quot; /&gt; &lt;img data-src=&quot;http://p0.meituan.net/movie/54617769d96807e4d81804284ffe2a27239007.jpg@160w_220h_1e_1c&quot; alt=&quot;罗马假日&quot; class=&quot;board-img&quot; /&gt; &lt;/a&gt; &lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/2641&quot; title=&quot;罗马假日&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;&#123;movieId:2641&#125;&quot;&gt;罗马假日&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;star&quot;&gt; 主演：格利高里·派克,奥黛丽·赫本,埃迪·艾伯特 &lt;/p&gt; 其实对我们有用的就是 img src(图片地址) title 电影名 star 主演。所以根据前边介绍过的正则表达式写法，可以推导出正则表达式 12compilestr = r&#x27;&#x27;&#x27;&lt;dd&gt;.*?&lt;i class=&quot;board-index.*?&lt;img data-src=&quot;(.*?)@.*?title=&quot;(.*?)&quot;.*?&lt;p class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&lt;p class=&quot;releasetime&quot;&gt;.*?(.*?)&lt;/p&#x27;&#x27;&#x27; ‘.’表示匹配任意字符，如果正则表达式用re.S模式，.还可以匹配换行符，’‘表示匹配前一个字符0到n个，’？’表示非贪婪匹配，所以’.?’可以理解为匹配任意字符。接下来写代码打印我们匹配的条目 1234567891011121314151617181920212223#-*-coding:utf-8-*-import requestsimport reUSER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;if __name__ == &quot;__main__&quot;: headers=&#123;&#x27;User-Agent&#x27;:USER_AGENT, &#125; session = requests.Session() req = session.get(&#x27;http://maoyan.com/board/4?offset=0&#x27;,headers = headers, timeout = 5) compilestr = r&#x27;&lt;dd&gt;.*?&lt;i class=&quot;board-index.*?&lt;img data-src=&quot;(.*?)@.*?title=&quot;(.*?)&quot;.*?&lt;p class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&lt;p class=&quot;releasetime&quot;&gt;.*?(.*?)&lt;/p&#x27; #print(req.content) pattern = re.compile(compilestr,re.S) #print(req.content.decode(&#x27;utf-8&#x27;)) lists = re.findall(pattern,req.content.decode(&#x27;utf-8&#x27;)) for item in lists: #print(item) print(item[0].strip()) print(item[1].strip()) print(item[2].strip()) print(item[3].strip()) print(&#x27;\\n&#x27;) 运行一下，结果如下看来我们抓取到数据了，我们只爬取了这一页的信息，接下来我们分析第二页，第三页的规律，点击第二页，网址变为’http://maoyan.com/board/4?offset=10&#39;,点击第三页网址变为&#39;http://maoyan.com/board/4?offset=20&#39;，所以每一页的offset偏移量为20，这样我们可以计算偏移量达到抓取不同页码的数据，将上一个程序稍作修改，变为可以爬取n页数据的程序 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-import requestsimport reimport timeUSER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;class MaoYanScrapy(object): def __init__(self,pages=1): self.m_session = requests.Session() self.m_headers = &#123;&#x27;User-Agent&#x27;:USER_AGENT,&#125; self.m_compilestr = r&#x27;&lt;dd&gt;.*?&lt;i class=&quot;board-index.*?&lt;img data-src=&quot;(.*?)@.*?title=&quot;(.*?)&quot;.*?&lt;p class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&lt;p class=&quot;releasetime&quot;&gt;.*?(.*?)&lt;/p&#x27; self.m_pattern = re.compile(self.m_compilestr,re.S) self.m_pages = pages def getPageData(self): try: for i in range(self.m_pages): httpstr = &#x27;http://maoyan.com/board/4?offset=&#x27;+str(i) req = self.m_session.get(httpstr,headers=self.m_headers,timeout=5) lists = re.findall(self.m_pattern,req.content.decode(&#x27;utf-8&#x27;)) time.sleep(1) for item in lists: img = item[0] print(img.strip()+&#x27;\\n&#x27;) name = item[1] print(name.strip()+&#x27;\\n&#x27;) actor = item[2] print(actor.strip()+&#x27;\\n&#x27;) fiemtime = item[3] print(fiemtime.strip()+&#x27;\\n&#x27;) except: print(&#x27;get error&#x27;)if __name__ == &quot;__main__&quot;: maoyanscrapy = MaoYanScrapy() maoyanscrapy.getPageData() 运行下，效果和之前一样，只是支持了页码的传参了。下面继续完善下程序，把每个电影的图片抓取并保存下来，这里面用到了创建文件夹，路径拼接，文件保存的基础知识，综合运用如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#-*-coding:utf-8-*-import requestsimport reimport timeimport osUSER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;class MaoYanScrapy(object): def __init__(self,pages=1): self.m_session = requests.Session() self.m_headers = &#123;&#x27;User-Agent&#x27;:USER_AGENT,&#125; self.m_compilestr = r&#x27;&lt;dd&gt;.*?&lt;i class=&quot;board-index.*?&lt;img data-src=&quot;(.*?)@.*?title=&quot;(.*?)&quot;.*?&lt;p class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&lt;p class=&quot;releasetime&quot;&gt;.*?(.*?)&lt;/p&#x27; self.m_pattern = re.compile(self.m_compilestr,re.S) self.m_pages = pages self.dirpath = os.path.split(os.path.abspath(__file__))[0] def getPageData(self): try: for i in range(self.m_pages): httpstr = &#x27;http://maoyan.com/board/4?offset=&#x27;+str(i) req = self.m_session.get(httpstr,headers=self.m_headers,timeout=5) lists = re.findall(self.m_pattern,req.content.decode(&#x27;utf-8&#x27;)) time.sleep(1) for item in lists: img = item[0] print(img.strip()+&#x27;\\n&#x27;) name = item[1] dirpath = os.path.join(self.dirpath,name) if(os.path.exists(dirpath)==False): os.makedirs(dirpath) print(name.strip()+&#x27;\\n&#x27;) actor = item[2] print(actor.strip()+&#x27;\\n&#x27;) fiemtime = item[3] print(fiemtime.strip()+&#x27;\\n&#x27;) txtname = name+&#x27;.txt&#x27; txtname = os.path.join(dirpath,txtname) if(os.path.exists(txtname)==True): os.remove(txtname) with open (txtname,&#x27;w&#x27;) as f: f.write(img.strip()+&#x27;\\n&#x27;) f.write(name.strip()+&#x27;\\n&#x27;) f.write(actor.strip()+&#x27;\\n&#x27;) f.write(fiemtime.strip()+&#x27;\\n&#x27;) picname=os.path.join(dirpath,name+&#x27;.&#x27;+img.split(&#x27;.&#x27;)[-1]) if(os.path.exists(picname)): os.remove(picname) req=self.m_session.get(img,headers=self.m_headers,timeout=5) time.sleep(1) with open(picname,&#x27;wb&#x27;) as f: f.write(req.content) except: print(&#x27;get error&#x27;)if __name__ == &quot;__main__&quot;: maoyanscrapy = MaoYanScrapy() maoyanscrapy.getPageData() 运行一下，可以看到在文件的目录里多了几个文件夹点击一个文件夹，看到里边有我们保存的图片和信息好了，到此为止，正则表达式和requests结合，做的爬虫实战完成。谢谢关注我的公众号：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"eos源码分析和应用(一) 调试环境搭建","date":"2018-09-02T00:28:43.000Z","path":"2018/09/02/eos1/","text":"eos基于区块链技术实现的开源引擎，开发人员可以基于该引擎开发DAPP(分布式应用)。下面搭建在windows环境下的虚拟机，并且安装eos引擎，以及配合vscode实现断点调试。 创建vmware虚拟机安装ubuntu系统去下载vmware虚拟机，然后安装。vmware虚拟机链接地址ubuntu系统下载16.04版本以上的，下载地址ubuntu下载地址下面创建虚拟机，选择创建一个新的虚拟机选择自定义选择稍后安装系统镜像操作系统选择linux安装位置自己设定设置处理器数量，根据自己机器酌情设置内存设置，eos编译要求至少7G内存，我设置8G，如果机器内存不够，可以设置小一点，之后改eos_build.sh中的设置就可以。网络设置走默认就行存储空间我设置了80G，根据自己机器设置，至少40G空间虚拟机数据存放位置虚拟机安装好了点击编辑虚拟机设置，点击cd/dvd ，选择使用ISO映像文件确定后，点击运行虚拟机，自动安装ubuntu，ubuntu具体安装选择不做赘述。 编译eos，运行eos1 进入自己用户目录，创建文件夹，然后clone 代码git clone https://github.com/EOSIO/eos--recursive2 下载后进入eos目录，执行eosio_build.sh脚本，出现如下显示，则编译成功。我输入sudo ./eosio_build.sh, 等待编译完成如果出现boost ,mongodb等下载失败，无法执行成功，那么修改eos/scripts/eosio_build_ubuntu.sh，注释掉connect下载等操作，然后手动下载放入eos查找的目录即可。同样的道理，内存不足7G，空间不足40G，eosio_build_ubuntu.sh脚本会exit，注释掉exit代码即可继续编译。编译成功后，可以执行以下命令运行节点,当前目录为eos 12cd ./build/programs/nodeos./nodeos -e -p eosio --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugi 那另起一个shell终端，执行cleos查看当前网络信息 12cd build/programs/cleos./cleos get info eos 根目录在~/.local/share/eosio/,~/.local/share/eosio/nodeos/config/目录下有config.ini 和genesis.json两个文件，通过配置config.ini，可以直接运行节点，不需要带参数。config.ini 配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748genesis-json = ./genesis.jsonblock-log-dir = blocksreadonly = 0send-whole-blocks = trueenable-stale-production = truehttp-server-address = 127.0.0.1:8888p2p-listen-endpoint = 0.0.0.0:9876p2p-server-address = localhost:9876allowed-connection = any#p2p-peer-address = 47.105.111.1:7771p2p-peer-address = 192.168.1.59:7771#p2p-peer-address = localhost:9877required-participation = 33 #Private key: 5JZ5Wwb8uQbi3A7DmMsD2zevcKCYw1pxmitij1x4xCjU8gv7ucj#Public key: EOS6a5pr4DS4CksCQSHqTdKMPbAdCyrE4b7QExDwTuCxH1vbkYMqG # key for eosio #producer-name = eosioprivate-key = [&quot;EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;,&quot;5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3&quot;] # actinve key for bp.aproducer-name = p1private-key = [&quot;EOS6a5pr4DS4CksCQSHqTdKMPbAdCyrE4b7QExDwTuCxH1vbkYMqG&quot;,&quot;5JZ5Wwb8uQbi3A7DmMsD2zevcKCYw1pxmitij1x4xCjU8gv7ucj&quot;] # actinve key for bp.bproducer-name = p2private-key = [&quot;EOS5NiFNF4bG7T49S6f7qVXMAt4RN2WM211s77UZrwD4cz2Xu6gw9&quot;,&quot;5JKkei9CFtawsvnHt728DUQaahcjHm5nqJsNgZzna9XZKq8eA5c&quot;] # actinve key for bp.cproducer-name = p3private-key = [&quot;EOS59rjXxZLjRnUEdErjtCEN8fihQnMmdsWYSz7jaeruPEoSeyCHz&quot;,&quot;5JBDtjPbUeV2Hte6ZuFE5ny9RtuUujWEKG1u2yYPw2jmkCR7A4Y&quot;] # actinve key for bp.dproducer-name = p4private-key = [&quot;EOS5psRxWMGyQS4HPNY8fa4PDhgP53vD4AZ6w24Z9HUCTxXKEH7Ey&quot;,&quot;5JQPYAtWxdzGsJkBpHyWBV18N2rzFtMjcBwxvfndS3KXe4oQu3L&quot;] #plugin = eosio::producer_pluginplugin = eosio::chain_api_plugin#plugin = eosio::account_history_api_plugin#plugin = eosio::wallet_plugin#plugin = eosio::wallet_api_pluginplugin = eosio::http_pluginplugin = eosio::net_pluginplugin = eosio::net_api_plugin genesis.json 123456789101112131415161718192021222324&#123; &quot;initial_timestamp&quot;: &quot;2018-06-08T08:08:08.888&quot;, &quot;initial_key&quot;: &quot;EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;, &quot;initial_configuration&quot;: &#123; &quot;max_block_net_usage&quot;: 1048576, &quot;target_block_net_usage_pct&quot;: 1000, &quot;max_transaction_net_usage&quot;: 524288, &quot;base_per_transaction_net_usage&quot;: 12, &quot;net_usage_leeway&quot;: 500, &quot;context_free_discount_net_usage_num&quot;: 20, &quot;context_free_discount_net_usage_den&quot;: 100, &quot;max_block_cpu_usage&quot;: 200000, &quot;target_block_cpu_usage_pct&quot;: 1000, &quot;max_transaction_cpu_usage&quot;: 150000, &quot;min_transaction_cpu_usage&quot;: 100, &quot;max_transaction_lifetime&quot;: 3600, &quot;deferred_trx_expiration_window&quot;: 600, &quot;max_transaction_delay&quot;: 3888000, &quot;max_inline_action_size&quot;: 4096, &quot;max_inline_action_depth&quot;: 4, &quot;max_authority_depth&quot;: 6 &#125;&#125; 这样直接执行就可以了 12cd ./build/programs/nodeos./nodeos 配置vscode，设置断点调试eosio_build.sh脚本，把第51行CMAKE_BUILD_TYPE=Release修改成CMAKE_BUILD_TYPE=Debug，执行./eosio_build.sh,这样生成debug版本才可以断点调试。ubuntu 软件中心下载visualstudio code， 进入软件界面，导入eos项目。1 配置任务，如图所示菜单路径：任务-&gt;配置任务,选择使用模板创建tasks.json文件，MSBuild执行生成目标。在eos工程目录下创建一个tasks.json文件，并打开，如下所示按照如下修改配置 1234567891011121314151617&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;eosio_build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;cd build &amp;&amp; make nodeos -j4&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: [] &#125; ]&#125; 2 菜单：调试-&gt;添加配置..vscode会在eos工程目录下创建launch.json文件，如下图修改launch.json文件 123456789101112131415161718192021&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/programs/nodeos/nodeos&quot;, //&quot;args&quot;: [&quot;--genesis-json&quot;,&quot;/home/secondtonone1/.local/share/eosio/nodeos/config/genesis.json&quot;], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot; &#125; ]&#125; mac 系统请设置MIMode成lldb形式3 任务-&gt;运行任务，选择eosio_build，vscode会执行一次代码编译，以后修改代码后，可以直接在vs中修改代码编译在main函数处设置断点4 菜单：调试-&gt;启动调试或F5程序运行到断点处暂停，可以F10单步调试，也可以F5跳过继续运行下一个节点，左侧Debug目录点击，可以看到调用的堆栈信息和变量信息。到此为止，eos编译运行，以及调试环境搭建完了。下一篇源码分析，eos整个流程运行机制。谢谢关注我的公众号","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链eos","slug":"区块链eos","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BEeos/"}]},{"title":"区块链学习（1）","date":"2018-04-30T13:10:53.000Z","path":"2018/04/30/blockchain1/","text":"从事C++服务器开发六年多了，主要是做并发服务器和游戏相关开发，区块链技术新兴起，自己也是很感兴趣，我是零基础学区块链的，给自己设定了一个规划，先读一读区块链相关的基础和概念，以及基本算法，然后用成熟的引擎做一个demo，接下来不断深入学习。 什么是区块链？一两句话很难解释清楚，至少我自己还不能概括的很全面。我自己的理解是区块链技术包含了很多功能，如点对点传输，分布式数据存储，利用加密和共识算法实现数据的统一。区块链是多个技术的合理应用和创新，我觉得应该在以后的学习中不断去理解。 什么是比特币？比特币是区块链比较成熟的应用，比特币依赖于区块链技术。 区块链的基本构成区块链由一个个区块按照规律链接构成，每个区块中包含了很多交易。区块链的形成过程：交易是签过名的数据结构，该数据结构会在区块链网络中广播，并且被收集到区块中，然后区块会在区块链网络中广播，一个区块引用上一个区块从而形成区块链。区块链包括成千上万个区块， 而一个区块内又包含一个或多个交易， 上下关联的交易组成了一个交易链， 一个交易链内部可能又包含了多个交易。 4 比特币地址比特币地址通常代表收款方，代表一对公钥和私钥的所有者，也可以代表其他。比特币地址是由数字和字母组成的字符串，由公钥生成的比特币地址以数字“1”开头。比特币地址有公钥经过Hash函数生成 交易的原理交易实质上是包含一组输入列表和输出列表的数据结构，交易包含的结构如下：一个交易的输入和输出样式：Input表示交易的输入，一个交易的输入引用的是另一个交易的输出，该交易的输入从交易f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd04470b9a6的0号输出中导入了50个比特币， 然后该输出发送50个比特币到一个比特币地址的公钥Hash值，404371705fa9bd789a2fcd52d2c580b65d35549d。同样道理，如果接受者想花掉50比特币，需要用output作为自己交易的输入。输入是对其他交易的输出的引用，一个交易可能有很多输入，Previous tx是以前交易的Hash值，Index是被引用交易的特定输出号，ScriptSig是脚本的签名， Scriptpubkey是脚本的公钥，公钥属于交易输出的收款人， 并且表明交易创建者允许收款人获得的输出金额； 另一个部分是ECDSA签名， 是通过对交易的Hash值进行ECDSA签名而得到的。 签名和公钥一起， 证明原地址的真正所有者创建了该支付交易。Value表示支付的金额，1BTC=100000000聪。 找零问题当需要支付的金额小于可用余额时， 在交易信息中必须告诉比特币网络零钱将要被发送至哪个地址，即“找零地址”。 找零地址可能是也可能不是原先的发送地址。地址A发起付款到地址B， 但此时将找零地址更改为新生成的地址C，此时能保证交易的安全性。如果找零地址不是C而是A，很多情况会被人追踪到一笔交易的流程。上图中交易流程很难被推断出来。 区块和区块链数据会以文件的形式被永久记录， 我们称这些文件为区块。 一个区块是一些或所有最新比特币交易的记录集， 且未被其他先前的区块记录。 新区块会被加入到记录的最后， 一旦写上， 就再也不能改变或删除。区块结构： 区块头包含6个数据，如下 hashPrevBlock值为前一个块的256位Hash值，也就是前一个块的hashMerkleRoot。该字段使得各个区块之间可以连接起来，形成一个巨大的“链条”。 每个区块都必须要指向前一个区块， 否则无法通过验证。 这个区块链条会一直追溯到源头， 也就是指向创世区块。 创世区块的hashPrevBlock的值为零或为空。 在区块头中， 随机数Nonce对每个块唯一。求Nonce没有固定的算法，Nonce有很多值，找到一个满足条件即可。所以要求不断尝试找到合适的Nonce为止，这个过程就是挖矿。区块内包含许多交易， 它们通过Merkle根节点间接被散列， 以保证矿工能及时追踪一个正在打包的区块内交易的变化情况。 一旦生成Merkle根节点， 那么对包含一个交易的区块做散列所花的时间，对包含1万个交易的区块做散列所花的时间是一样的。目标Hash值的压缩格式是一个特殊的浮点编码类型， 首字节是指数 ， 后3个字节是尾数， 它能表示256位的数值。一个区块头的SHA-256（一种单向函数的算法， 可形成长度为256位的串） 值必定要小于或等于目标Hash值， 该区块才能被网络所接受。 目标Hash值越低， 产生一个新区块的难度就越大。Merkle树是Hash的二叉树。 在比特币中会两次使用SHA-256算法来生成Merkle树， 如果叶子个数为奇数， 则要重复计算最后一个叶子的两次SHA-256值， 以达到偶数叶子节点的要求。想象有3个交易， a、 b、 c， 那么Merkle根的生成过程如下所示：计算a交易的hash值 d1 = dhash（a）d2 = dhash（b）d3 = dhash（c）由于只有3个元素， 是奇数， 因而将最后一个元素重算一次d4 = dhash（c）接下来将上面产生的hash值两两计算d5 = dhash（d1 concat d2）d6 = dhash（d3 concat d4）d7 = dhash（d5 concat d6） 这里的d7就是以上三个交易的Merkle根。 需要注意的是， Merkle树的Hash值是小头位序。 区块链原理和分叉对于区块链中的任何区块来说， 只有一条通向创世块的路径。 然而， 从创世块出发， 却可能有分叉。 当两个区块产生的时间仅相差几秒时， 可能会产生包含一个区块的分叉。 当出现以上现象时， 矿工节点会根据收到区块的时间， 在先收到的区块的基础上继续挖矿。 哪个区块的后续区块先出现， 那么这个区块就会被包括进主链， 因为这条块链更长。短区块链（或有效区块链） 中的区块没有作用， 当比特币客户端转向另一个长区块链时， 短区块链中所有有效的交易都将被重新加入到交易队列池中， 并被包括到另一个区块中。 短区块链中的区块收益不会在长链中出现， 因而这些收益实际上是丢失了， 这就是比特币网络设定100个区块成熟时间的原因。 挖矿原理比特币的挖矿和节点软件是基于对等网络、 数字签名来发起和验证交易的。 节点向网络广播交易， 这些广播出来的交易需要经过矿工的验证， 矿工们会用自己的工作证明结果来表达确认， 确认后的交易会被打包到数据块中， 数据块会串起来形成连续的数据块链。每一个比特币的节点都会收集所有尚未确认的交易， 并且会将其归集到一个数据块中， 这个数据块将和前面一个数据块集成在一起。 矿工节点会附加一个随机调整数， 并计算前一个数据块的SHA-256 Hash运算值。 挖矿节点不断进行重复尝试， 直到它找到的随机调整数使得产生的Hash值低于某个特定的目标为止。 由于Hash运算是不可逆的， 因此寻找到符合要求的随机调整数将会非常困难， 因此需要一个可以预计总次数的不断试错的过程。 这时， 工作量证明机制就发挥作用了。 当一个节点找到了符合要求的解， 那么它就可以向全网广播自己的结果。 其他节点就可以接收这个新解出来的数据块， 并检验其是否符合规则。 只要其他节点通过计算Hash值发现其确实满足要求（比特币要求的运算目标） ，那么该数据块就是有效的， 其他的节点就会接受该数据块， 并将其附加在自己已有的链条之后. Nonce随机数通常都不会相同， 但是它以严格的线性方式在增长，从0开始， 每次执行散列时都会增长， 当Nonce溢出时（此事经常发生） ， 挖矿交易的extraNonce项就会增长， 其将改变Merkle树的根节点. 挖矿难度挖矿难度是对挖矿困难程度的度量， 即指计算符合给定目标的一个Hash值的困难程度。 比特币网络有一个全局的区块难度， 有效的区域必须有一个Hash值， 该Hash值必须小于给定的目标Hash值。 难度计算公式如下：diff = diff_1_target / target目标值是一个很大的数字，这里出现了一个 diff_1_target，这是常数，是一个很大的数字，这个数字也被称作是矿池难度，即矿池挖矿时的最大难度。这个最大难度值是标记为0x1d00ffff的数，这个标记是压缩标记，它的实际值是： 10x00ffff * 2**(8*(0x1d - 3)) = 0x00000000FFFF00000000000000000000000000000000000000000000000000。 计算时，后面三个字节作为底，前面一个字节1d表示的是次方数，最终得出上面这个数字，挖矿时矿池也可以保留的尾数，即0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 而比特币的挖矿难度，根据上面的公式可知，它和diff_1_target及当前网络目标值(target)有关，将diff_1_target值代入，得到：diff = 0x1d00ffff / target在调整难度的时候，只需要调整target大小即可，target越小，难度越大，反之，难度越小。矿池一般用后面全是FF的值来代表diff_1_target，计算出来的难度就叫做矿池难度pdiff，如果用后面全是00的值来代表diff_1_target，那么计算出来的难度值是比特币客户端难度bdiff。这里只是说明，它们有两个值，代表不同计算方式，实际上，它们计算出来的难度并不会相差很远。网络调整难度的目的，是为了调整出块的速度保持在平均10分钟1个块，每2016个块作为一个周期调整，这样刚好2周作为一个周期，如果这2016个块中，平均出块速率快过10分钟1个块，那么难度将会增大到，维持这个难度的情况下，满足10分钟出一个块的水平。什么时候调整难度呢？由于2016的周期从来没有变过，那么该周期内还剩余的区块数量是可以计算出来的：该周期剩余区块数量 = 2016 - （当前区块高度 % 2016）以当前最新一个块 482017 为例当前高度 % 2016 = 482017 % 2016 = 193该周期剩余区块数量 = 2016 - 193 = 1823也即该周期内才出193个区块，得等到1823个块以后才会调整难度，对于BCC来说，也是一样的。 挖矿收益计算挖矿时，计算出来的区块哈希值，是要小于当前target值的，这个哈希值是一个范围很大的值（从0到(2^256)-1），只有靠矿机的暴力破解，才能算出这个值。diff_1_target，即0x00000000FFFF0000000000000000000000000000000000000000000000000000 , FFFF后面有26个字节， 123456789101112131415161718192021222324即8*26 = 208位，所以diff_1_target又可以写成 0xffff*(2**208)。如果当前难度是D的话，那么根据上面我们讲过的公式diff = diff_1_target / target那么target = (0xffff * (2 ** 208)) / D需要要搜索出这个target值，需要计算的哈希次数是2 ** 256 / target将D移到左边，得到D * (2 ** 256) / (0xffff * (2 ** 208))将2 ** 208移到左边，得到D * (2 ** 256) / (2 ** 208) / 0xffff化简得到D * (2 ** 48) / 0xffff也即10分钟(600秒)内要计算这么多次，才能得到一个块，那么平均每秒就是：D * (2 ** 48) / 0xffff / 600将0xffff写成十进制是2 ** 16D * (2 ** 48) / (2 ** 16) / 600化简得到D * (2 ** 32) / 600假设现在全网难度是888171856257，那么平均要计算 6357781793085713285次哈希运算才能得到一个块。我们不妨用现在的算力验证一下，现在的全网算力是5.68 EH/s, 大概接近这个值。难度和算力的关系我们已经看出来了，难度越大，需要的算力就越大。那么以单位为1Th/s的云合约标准算力来计算，一天的收益能够达到多少呢？一天能够计算的哈希次数 = 1T * 86400假设当前难度为D，那么收益 = 1T * 86400 / D / ( 2 * 32) * 600* 块收益 脚本系统脚本操作码很多，自己去查查吧。下面简述下脚本工作原理。以下为三个交易的关系图，一个交易的输出是下一个交易的输入。交易的关系数据图：交易a hash值为交易b hash值为交易a的输出脚本， 若干个脚本指令和转账接收方的公钥Hash交易b的输入脚本， 这么一长串只是两个元素， 签名和公钥首先执行的是输入脚本。 因为脚本是从左向右执行的， 那么先入栈的是签名， 随后是公钥。 接着， 执行的是输出脚本。 从左向右执行， 第一个指令是OP_DUP——复制栈顶元素OP_HASH160用于计算栈顶元素Hash， 得到pubkeyhash然后将输出脚本中的公钥Hash入栈， 为了与前面计算中所得到的Hash区别开来， 这里称它为pubkeyhash’OP_EQUALVERIFY则会检查栈顶前两个元素是否相等， 如果相等则继续执行， 否则中断执行， 返回失败OP_CHECKSIG使用栈顶前两个元素执行签名校验操作， 如果相等， 则返回成功， 否则返回失败没看懂？再来一遍以著名的Pizza Transaction为例，来验证一个交易是否是有效的在交易cca75078…4d79中，唯一的TxIn输入提供的sigScript是： 12345678b4830450221009908144ca6539e09512b9295c8a27050d478fbb96f8addbc3d075544dc41328702201aa528be2b907d316d2da068dd9eb1e23243d97e444d59290d2fddf25269ee0e0141042e930f39ba62c6534ee98ed20ca98959d34aa9e057cda01cfd422c6bab3667b76426529382c23f42b9b08d7832d4fee1d6b437a8526e59667ce9c4e9dcebcabb 该sigScript实际上由两部分构成：签名：30450221…ee0e01（71字节+1字节签名类型），实际签名是去掉最后一个字节01的30450221…ee0e，签名类型是SIGHASH_ALL（0x01）。公钥：042e930f…cabb（65字节）为了验证该交易是否有效，我们首先要根据TxIn所声明的Previous Output Hash：a1075db5…d48d和索引0找到上一笔交易的输出a1075db5…d48d。这笔交易输出的脚本是：1976a91446af3fb481837fadbb421727f9959c2d32a3682988ac比特币的脚本由一系列指令和数据构成，每个指令占用一个字节，数据由数据头部的长度决定。上述二进制脚本翻译后的比特币指令如下OP_DUP OP_HASH160 46af3fb4…6829 OP_EQUALVERIFY OP_CHECKSIG现在，我们有了签名，公钥和脚本：sig: 30450221…ee0e01pubkey: 042e930f…cabbscript: OP_DUP OP_HASH160 46af3fb4…6829 OP_EQUALVERIFY OP_CHECKSIG就可以运行这个脚本来验证交易是否有效。比特币脚本被设计成以栈来运行的虚拟机指令，它只有有限的几种指令，并且故意被设计成没有循环、条件跳转，所以，比特币脚本不是图灵完备的语言。比特币脚本的执行非常简单。我们首先要准备一个空栈，然后把签名和公钥入栈：紧接着，我们就可以执行TxOut的脚本：OP_DUP OP_HASH160 46af3fb4…6829 OP_EQUALVERIFY OP_CHECKSIG首先执行OP_DUP，这条指令把栈顶的元素复制一份，所以结果变成：紧接着执行OP_HASH160，它对栈顶元素计算SHA256/RipeMD160，实际上是计算公钥Hash，所以运行结果变成接下来的指令实际上是一个数据，我们直接把数据入栈：然后，执行OP_EQUALVERIFY，这条指令会比较栈顶的两个元素是否相等，如果不等，整个脚本就执行失败了，如果相等，脚本会继续执行，所以运行结果变成最后，执行指令OP_CHECKSIG，这条指令会验证签名.其实脚本的验证过程就是根据自己的输入将签名和公钥入栈，根据上一个交易的输出脚本指令依次执行，判断结果是否和上一个交易要求的公钥地址匹配。换言之，谁能根据我输出脚本的规则计算出符合我要求的公钥地址，谁就能使用这笔交易。 由于引入了脚本，我们可以看到，比特币实际上通过编程脚本实现了一个严格以计算机程序验证为基础的数字货币所有权的转移机制。由于计算机程序的可扩展性，比特币支付其实并不限定在必须支付给某一个公钥地址。利用脚本，我们可以构造出各种支付条件，例如，多重签名验证条件： 2 3 OP_CHECKMULTISIGN这种提供多个公钥地址，并且需要多个签名验证的多重签名脚本，允许在M个签名种至少给出N个签名即可使用。上述脚本允许提供3个公钥地址中的任意两个有效签名。 当我们把比特币托管在某个第三方的在线钱包中时，就可以使用多重签名来保证只有自己和第三方钱包共同签名后才可动用输出，这样保证了黑客在攻击了第三方钱包后也无法花掉用户的比特币。 通过OP_CHECKLOCKTIMEVERIFY，我们可以指定一个交易的锁定时间，在此之前，该交易输出无法被花掉。这个指令其实实现了支付宝的7天资金锁定然后再支付给卖家的功能。 还有一些交易并没有指定一个公钥Hash，例如，这个交易的脚本如下： OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL它的意思是说，谁能够提供一个数据，它的SHA256是6fe28c0a…0000，谁就可以花费这笔交易 我的公众号：","categories":[{"name":"区块链","slug":"blockchain","permalink":"http://www.limerence2017.com/categories/blockchain/"}],"tags":[{"name":"区块链技术","slug":"区块链技术","permalink":"http://www.limerence2017.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"}]},{"title":"grep命令学习和总结","date":"2018-04-02T14:36:12.000Z","path":"2018/04/02/greplearn/","text":"总结grep命令知识grep主要功能是返回指定文件中包含符合规则的文本行。 1 在指定文件file_name中查找包含match_pattern 的文本行1grep &quot;match_pattern&quot; file_name 2 在多文件中查找包含file_name的文本行1grep &quot;match_pattern&quot; file_name1 file_name2 file_name3 3反向查找，输出不匹配file_name的文本行1grep -v &quot;match_pattern&quot; file_name 标记匹配颜色1greap &quot;match_pattern&quot; file_name --color=auto 使用正则表达式-E选项1grep -E &quot;[1-9]+&quot; 1egrep &quot;[1-9]+&quot; 只输出文件中匹配的部分1echo this is a test line.|grep -E &quot;[a-z]+\\.&quot; 统计文本中或文件中包含匹配字段的行个数1grep -c &quot;matchtest&quot; file_name 输出包含匹配字符串的行行号1grep -n &quot;matchtest&quot; file_name 打印包含匹配字符串位于该行的字节偏移1echo i&#x27;m not girl | grep -b -o &quot;not&quot; 列出包含符合匹配字符串的文件名1grep -l &quot;matchtest&quot; file1 file2 file3 在多级目录中递归搜索1grep &quot;text&quot; . -r -n 忽略匹配样式中的字符大小写1echo &quot;hello world&quot; | grep -i &quot;HELLO&quot; 多个匹配字段1echo this is text test | grep -e &quot;is&quot; -e &quot;line&quot; -o 根据文件匹配123cat textfileaaabbb 1echo aaa bbb ccc ddd eee | grep -f textfile -o 显示匹配某个结果之后的3行，使用 -A 选项1seq 10 | grep &quot;5&quot; -A 3 显示匹配某个结果之后的3行，使用 -B 选项1seq 10 | grep &quot;5&quot; -B 3 显示匹配某个结果的前三行和后三行，使用 -C 选项：12seq 10 | grep &quot;5&quot; -C 3","categories":[{"name":"Linux","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://www.limerence2017.com/tags/shell/"}]},{"title":"python学习(22)访问数据库","date":"2018-01-11T10:23:02.000Z","path":"2018/01/11/python22/","text":"本文介绍python如何使用数据库方面的知识。 SQLiteSQLite是一种嵌入式数据库，本身是*.db的文件。通过python操作数据库的步骤：1 连接数据库返回connection连接2 通过connection连接获取cursor，cursor即游标3 通过cursor执行语句4 通过cursor查询结果，如fetchall5 关闭游标cursor6 提交事务7 关闭连接 下边的例子说明了如何使用SQLite 1234567891011121314151617import sqlite3#连接数据库test.db文件，如果不存在则创建conn = sqlite3.connect(&#x27;test.db&#x27;)#获取游标cursor = conn.cursor()#通过游标创建表cursor.execute(&#x27;create table user (id varchar(20) primary key, name varchar(20) )&#x27;)#通过游标插入数据cursor.execute(&#x27;insert into user(id, name) values(\\&#x27;1\\&#x27;,\\&#x27;Bob\\&#x27;)&#x27;)#打印新增的行数print(cursor.rowcount)#关闭cursorcursor.close()#提交事务conn.commit()#关闭连接conn.close() MYSQLMysql是使用广泛的数据库，通过python同样可以访问mysql数据库。步骤和之前的一样。但是要提前安装mysql数据库，同时推荐安装navicat可视化处理工具。安装完数据库后，需要安装python访问mysql的库，推荐安装2.1.4版本，其他版本可能会需要安装其他支持的库。命令行下执行：pip install mysql-connector==2.1.4这些安装好后，可以写代码访问数据。 12345678910111213141516171819import mysql.connectorconn = mysql.connector.connect(user=&#x27;root&#x27;,password=&#x27;123456&#x27;,database=&#x27;test&#x27;)cursor = conn.cursor()#创建user表cursor.execute(&#x27;create table user(id varchar(20) primary key, name varchar(20))&#x27;)cursor.execute(&#x27;insert into user(id, name) values(%s,%s)&#x27;,[&#x27;1&#x27;,&#x27;Michael&#x27;])print(cursor.rowcount)cursor.close()conn.commit()cursor = conn.cursor()cursor.execute(&#x27;select * from user where id = %s&#x27;,(&#x27;1&#x27;,))#获取结果集values = cursor.fetchall()print(values)# 关闭Cursor和Connection:cursor.close()conn.close() SQLAlchemySQLAlchemy是python的一个库，可以支持把关系型数据库的表结构映射到类的对象上，通过操作对象从而达到操作数据库的目的，这就是ORM技术，Object-Relational Mapping在使用SQLAlchemy之前，需要先安装pip install sqlalchemy下面的例子说明了如何使用sqlalchemy 123456789101112131415161718192021222324252627282930313233343536373839404142from sqlalchemy import Column, String, create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_base# 创建对象的基类:Base = declarative_base()# 定义User对象:class User(Base): #表的名字： __tablename__ = &#x27;user&#x27; #表的结构： id = Column(String(20), primary_key = True) name = Column(String(20))# 初始化数据库连接:engine = create_engine(&#x27;mysql+mysqlconnector://root:123456@localhost:3306/test&#x27;)# 创建DBSession类型:DBSession = sessionmaker(bind=engine)# 创建session对象:session = DBSession()# 创建新User对象:new_user = User(id=&#x27;5&#x27;, name=&#x27;Bob&#x27;)# 添加到session:session.add(new_user)# 提交即保存到数据库:session.commit()# 关闭session:session.close()# 创建Session:session = DBSession()# 创建Query查询，user = session.query(User).filter(User.id==&#x27;5&#x27;).one()# 打印类型和对象的name属性:print(&#x27;type:&#x27;, type(user))print(&#x27;name:&#x27;, user.name)# 关闭Session:session.close() 使用sqlalchemy分几个步骤：1 用sqlalchemy创建一个基类Base2 基于Base类实现自己定义的表结构类3 通过create_engine初始化数据库连接返回引擎engine，格式为 ‘数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名’ 所以我的写成’mysql+mysqlconnector://root:123456@localhost:3306/test’4 通过engine创建DBSession类，并通过DBSession类创建session(会话控制)对象。5 接下来可以定义一些对象，把对象加入到session中，通过commit到数据库6 也可以通过session查询用户，返回一个或几个结果。7 操作完记得关闭session。 以上就是python使用数据库的基本知识。","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(21) smtp发送邮件","date":"2018-01-06T02:07:23.000Z","path":"2018/01/06/python21/","text":"本文介绍python发送邮件模块smtplib以及相关MIME模块。smtplib用于生成邮件发送的代理，发送邮件前需要通过MIMEText构造邮件内容。 发送纯文本邮件下面是个发送纯文本邮件的例子。 1234567891011121314151617181920212223import smtplibfrom email.mime.text import MIMETextmsg_from=&#x27;XXXXX@163.com&#x27; passwd=&#x27;XXXXX&#x27; msg_to=&#x27;XXXXX@qq.com&#x27; subject=&quot;python邮件测试&quot; content=&quot;这是我使用python smtplib及email模块发送的邮件&quot;msg = MIMEText(content)msg[&#x27;Subject&#x27;] = subjectmsg[&#x27;From&#x27;] = msg_frommsg[&#x27;To&#x27;] = msg_totry: #s = smtplib.SMTP_SSL(&quot;smtp.163.com&quot;,465) s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, msg_to, msg.as_string()) print (&quot;发送成功&quot;)except smtplib.SMTPException as e: print (&quot;发送失败&quot;)finally: s.quit() MIMEText实例化一个邮件对象，内容为content，对于邮件标题Subject，发件人From，以及收件人To需要以字典形式指出，或者通过add_header(下文会给出)添加，否则对方看不到这些信息。想要通过smtp发送邮件，需要打开指定邮箱的smtp协议，以及设置smtp授权密码。我设置的是163邮箱的。设置好密码后，将上述代码中的passwd改为你的密码，msg_from改为你的邮箱。smtplib可以通过SMTP_SSL发送，也可以采用普通形式直接初始化，对应的两个参数分别是授权的smtp服务器地址和端口号，因为我设置的是163的，所以使用smtp.163.com服务器地址，端口号和服务器地址读者可以自己去查。通过生成的smtp实例，一次调用login，sendemail就可以发送了。最后记得调用quit退出。发送一封纯文本邮件，看一下效果我们发现发件人标题显示的只有邮箱地址，没有昵称，可以采用parseaddr和formataddr对发件人信息完善。 1234567891011121314151617181920212223242526272829303132def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))import smtplibfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrmsg_from=&#x27;XXXXX@163.com&#x27; passwd=&#x27;XXXXX&#x27; msg_to=&#x27;XXXXX@qq.com&#x27;receivers = [&#x27;XXXXX@qq.com&#x27;] subject=&quot;python邮件测试&quot; content=&quot;这是我使用python smtplib及email模块发送的邮件&quot;msg = MIMEText(content,&#x27;plain&#x27;,&#x27;utf-8&#x27;)msg[&#x27;Subject&#x27;] = Header(subject,&#x27;utf-8&#x27;).encode()msg[&#x27;From&#x27;] = _format_addr(&#x27;恋恋风辰 &lt;%s&gt;&#x27; %msg_from)msg[&#x27;To&#x27;] = msg_totry: #s = smtplib.SMTP_SSL(&quot;smtp.163.com&quot;,465) s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, receivers, msg.as_string()) print (&quot;发送成功&quot;)except smtplib.SMTPException as e: print (&quot;发送失败&quot;)finally: s.quit() 这样可以看到发件人的昵称了。我设置的是恋恋风辰。Header函数的作用是防止中文乱码。Header对字符串按照utf-8方式编码。MIMEText中参数plain表示纯文本，utf-8表示纯文本的编码方式。 发送html邮件发送html邮件和之前发送纯文本类似，只需要将plain变为html，即可。 123456789101112131415161718192021222324252627282930def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))import smtplibfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrmsg_from = &#x27;XXXXXX@163.com&#x27;passwd = &#x27;XXXXX&#x27;msg_to=&#x27;XXXXXX@qq.com&#x27;receivers = [&#x27;XXXXXX@qq.com&#x27;]subject = &#x27;python邮件测试html&#x27;content = &#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#x27; +\\ &#x27;&lt;p&gt;send by &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&#x27;msg = MIMEText(content, &#x27;html&#x27;, &#x27;utf-8&#x27;)msg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;).encode()msg[&#x27;From&#x27;] = _format_addr(&#x27;恋恋风辰 &lt;%s&gt;&#x27; %msg_from)msg[&#x27;To&#x27;] = msg_totry: s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, receivers, msg.as_string()) print(&#x27;发送成功&#x27;)except smtplib.SMTPException as e: print(&#x27;发送失败&#x27;)finally: s.quit() 看看效果： 发送带附件的邮件发送带附件的邮件，和之前不同，需要通过MIMEMultipart创建邮件实例，然后将文本，附件等通过attach方法绑定到邮件实例上，然后一起发送。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import smtplibimport emailfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipart from email.utils import parseaddr, formataddrfrom email.mime.base import MIMEBasedef _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))msg_from = &#x27;XXXXX@163.com&#x27;passwd = &#x27;XXXXX&#x27;msg_to=&#x27;XXXXXX@qq.com&#x27;receivers = [&#x27;XXXX@qq.com&#x27;]subject = &#x27;python邮件测试附件&#x27;content = &#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#x27; +\\ &#x27;&lt;p&gt;send by &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&#x27;#附件邮件对象msg = MIMEMultipart()msg[&#x27;From&#x27;] = _format_addr(&#x27;恋恋风辰 &lt;%s&gt;&#x27; %msg_from)msg[&#x27;To&#x27;] = msg_tomsg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;).encode()#添加正文text = MIMEText(content, &#x27;html&#x27;,&#x27;utf-8&#x27;)msg.attach(text)#添加附件就是创建一个MIMEBase对象，然后attach到msg上。with open(&#x27;./email.jpg&#x27;,&#x27;rb&#x27;) as f: #设置附件名字 mime = MIMEBase(&#x27;image&#x27;, &#x27;jpg&#x27;, filename=&#x27;text.jpg&#x27;) #加上头信息 mime.add_header(&#x27;Content-Disposition&#x27;,&#x27;attachment&#x27;,filename=&#x27;test.jpg&#x27;) mime.add_header(&#x27;Content-ID&#x27;,&#x27;&lt;0&gt;&#x27;) mime.add_header(&#x27;X-Attachment-Id&#x27;,&#x27;0&#x27;) #读取内容放入附件 mime.set_payload(f.read()) #用Base64编码 email.encoders.encode_base64(mime) #添加到MIMEMultipart中 msg.attach(mime)try: s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, receivers, msg.as_string()) print(&#x27;发送成功&#x27;)except smtplib.SMTPException as e: print(&#x27;发送失败&#x27;)finally: s.quit() MIMEMultipart创建邮件实例msg，将收件人，发件人，主题设置到msg上。然后通过MIMEText创建html文本内容，调用msg.attach方法将文本内容绑定到邮件上。同样的道理，打开一个图片，通过MIMEBase创建一个附件实例，设置文件名，文件类型，绑定的id等等，最后通过set_payload加载到附件，然后msg.attach绑定到邮件实例上。后面的发送流程和之前一样。看看效果： 发送带图片的html邮件想要在html中添加图片，并且在邮件正文中显示，只需要在html文本中引用图片id即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import smtplibfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipart from email.utils import parseaddr, formataddrfrom email.mime.base import MIMEBasefrom email.mime.image import MIMEImagedef _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))msg_from = &#x27;XXXXXXXXXXXX@163.com&#x27;passwd = &#x27;XXXXX&#x27;msg_to=&#x27;XXXXXXXXX@qq.com&#x27;receivers = [&#x27;XXXXXXXXXX@qq.com&#x27;]subject = &#x27;python邮件测试附件&#x27;content = &#x27;&lt;b&gt;Some &lt;i&gt;HTML&lt;/i&gt; text&lt;/b&gt; and an image.&lt;br&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;br&gt;good!&#x27;#附件邮件对象msg = MIMEMultipart()msg[&#x27;From&#x27;] = _format_addr(&#x27;恋恋风辰 &lt;%s&gt;&#x27; %msg_from)msg[&#x27;To&#x27;] = msg_tomsg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;).encode()#添加正文text = MIMEText(content, &#x27;html&#x27;,&#x27;utf-8&#x27;)msg.attach(text)#添加附件就是创建一个MIMEBase对象，然后attach到msg上。with open(&#x27;./email.jpg&#x27;,&#x27;rb&#x27;) as f: #设置附件名字 mime = MIMEImage(f.read()) #加上头信息 mime.add_header(&#x27;Content-Disposition&#x27;,&#x27;attachment&#x27;,filename=&#x27;test.jpg&#x27;) mime.add_header(&#x27;Content-ID&#x27;,&#x27;`&lt;image1&gt;`&#x27;) #添加到MIMEMultipart中 msg.attach(mime)try: s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, receivers, msg.as_string()) print(&#x27;发送成功&#x27;)except smtplib.SMTPException as e: print(&#x27;发送失败&#x27;)finally: s.quit() mime.add_header(‘Content-ID’,&#39;&lt;image1&gt;&#39;) 设置图片id为image1， 在html中引用image1就可以在邮件中文中显示图片了。 通过&lt;img src=&quot;cid:image1&quot;&gt;方式进行引用。 Messge类的继承和派生关系 1234567 Message+- MIMEBase +- MIMEMultipart +- MIMENonMultipart +- MIMEMessage +- MIMEText +- MIMEImage MIMEBase继承于Message,MIMEMultipart继承于MIMEBase。 用MIMEText发送多种附件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartfrom email.utils import parseaddr, formataddrimport osdef _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))msg_from = &#x27;XXXXXXXXX@163.com&#x27;passwd = &#x27;XXXXXXXXXXX&#x27;msg_to=&#x27;XXXXXXXXX@qq.com&#x27;receivers = [&#x27;XXXXXXXXXXX@qq.com&#x27;]subject = &#x27;python邮件测试附件&#x27;content = &#x27;多种附件&#x27;#附件邮件对象msg = MIMEMultipart()msg[&#x27;From&#x27;] = _format_addr(&#x27;恋恋风辰 &lt;%s&gt;&#x27; %msg_from)msg[&#x27;To&#x27;] = msg_tomsg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;).encode()#添加正文text = MIMEText(content, &#x27;html&#x27;,&#x27;utf-8&#x27;)msg.attach(text)os.chdir(&#x27;./res&#x27;) dir = os.getcwd()for fn in os.listdir(dir): print(fn) with open(fn,&#x27;rb&#x27;) as f: mime = MIMEText(f.read(), &#x27;base64&#x27;, &#x27;utf-8&#x27;) mime.add_header(&#x27;Content-Disposition&#x27;,&#x27;attachment&#x27;,filename = fn) mime.add_header(&#x27;Content-Type&#x27;, &#x27;application/octet-stream&#x27;) msg.attach(mime)try: s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, receivers, msg.as_string()) print(&#x27;发送成功&#x27;)except smtplib.SMTPException as e: print(&#x27;发送失败&#x27;)finally: s.quit() 大体原理和之前一样，通过MIMEText可以实现多种附件的发送。注意格式改为base64，编码用utf-8，可以实现多种附件发送。效果如下： 通过MIMEApplication发送多种附件同样可以通过MIMEApplication发送多种附件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import smtplibfrom email.mime.text import MIMETextfrom email.mime.application import MIMEApplicationfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartfrom email.utils import parseaddr, formataddrimport osdef _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))msg_from = &#x27;xxxxxxxxx@163.com&#x27;passwd = &#x27;xxxxxxxxxx&#x27;msg_to=&#x27;xxxxxxxxxxx@qq.com&#x27;receivers = [&#x27;xxxxxxxxx@qq.com&#x27;]subject = &#x27;python邮件测试附件&#x27;content = &#x27;多种附件&#x27;#附件邮件对象msg = MIMEMultipart()msg[&#x27;From&#x27;] = _format_addr(&#x27;恋恋风辰 &lt;%s&gt;&#x27; %msg_from)msg[&#x27;To&#x27;] = msg_tomsg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;).encode()#添加正文text = MIMEText(content, &#x27;html&#x27;,&#x27;utf-8&#x27;)msg.attach(text)os.chdir(&#x27;./res&#x27;) dir = os.getcwd()for fn in os.listdir(dir): print(fn) with open(fn,&#x27;rb&#x27;) as f: mime = MIMEApplication(f.read()) mime.add_header(&#x27;Content-Disposition&#x27;,&#x27;attachment&#x27;,filename = fn) mime.add_header(&#x27;Content-Type&#x27;, &#x27;application/octet-stream&#x27;) msg.attach(mime)try: s = smtplib.SMTP(&quot;smtp.163.com&quot;,25) s.login(msg_from, passwd) s.sendmail(msg_from, receivers, msg.as_string()) print(&#x27;发送成功&#x27;)except smtplib.SMTPException as e: print(&#x27;发送失败&#x27;)finally: s.quit() 效果和之前的一样，这就是python中利用smtplib和MIME构造邮件发送的案例。我的公众号：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(20) 网络编程","date":"2018-01-02T08:57:42.000Z","path":"2018/01/02/python20/","text":"python 网络编程和基本的C语言编程一样，效率不是很高，如果为了封装通信库建议采用C/C++做底层封装，采用epoll、poll、iocp等网络模型封装，编译成网络库供其他模块使用。这里在python学习过程中介绍一下 TCP 编程 服务器端1 创建套接字s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)AF_INET表示网络通信，SOCK_STRAM表示面向字节流TCP方式通信。2 绑定端口和地址s.bind((‘127.0.0.1’,9999))3 监听套接字s.listen(5)5,表示监听队列最大多长。4 接收客户端连接sock, addr = s.accept()s为生成的socket，accept接收客户端连接，返回对端描述符和地址5 接收数据data = sock.recv(1024)sock为对端socket，recv接收数据，最多接收10246 发送数据sock.send((‘Hello, %s’ %data.decode(‘utf-8’)).encode(‘utf-8’))7 关闭描述符sock.close() TCP客户端编程1 创建一个sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)2 建立连接、s.connect((‘127.0.0.1’, 9999))3 接收消息和发送消息s.send(data)s.recv(1024).decode(‘utf-8’)4 关闭描述符s.close() 服务端案例： 12345678910111213141516171819202122232425262728293031323334353637import socketimport threadingimport time#线程处理函数def tcplink(sock, addr): print(&#x27;Accept new connection from %s:%s...&#x27; % addr) sock.send(b&#x27;Welcome!&#x27;) while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode(&#x27;utf-8&#x27;)==&#x27;exit&#x27;: break sock.send((&#x27;Hello, %s&#x27; %data.decode(&#x27;utf-8&#x27;)).encode(&#x27;utf-8&#x27;)) sock.close() print(&#x27;Connection from %s:%s closed.&#x27;%addr)#服务器tcp编程流程#创建套接字s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#绑定套接字s.bind((&#x27;127.0.0.1&#x27;,9999))#监听套接字s.listen(5)print(&#x27;Waiting for connection...&#x27;)# 调用accept接受连接while True: # 接收新的连接 sock, addr = s.accept() # 创建新的线程处理TCP t = threading.Thread(target=tcplink,args=(sock,addr)) t.start() 客户端： 1234567891011121314import socket#创建一个sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&#x27;127.0.0.1&#x27;, 9999))# 接收欢迎消息:print(s.recv(1024).decode(&#x27;utf-8&#x27;))for data in [b&#x27;Michael&#x27;, b&#x27;Tracy&#x27;, b&#x27;Sarah&#x27;]: # 发送数据: s.send(data) print(s.recv(1024).decode(&#x27;utf-8&#x27;))s.send(b&#x27;exit&#x27;)s.close() UDP通信udp通信和tcp通信不一样，很简单。服务器端不需要监听和accept，客户端也不需要connect。服务端 示例： 12345678910111213import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind((&#x27;127.0.0.1&#x27;, 9999))print(&#x27;Bind UDP on 9999...&#x27;)while True: # 接收数据: data, addr = s.recvfrom(1024) print(&#x27;Received from %s:%s.&#x27; % addr) s.sendto(b&#x27;Hello, %s!&#x27; % data, addr) 服务器端绑定好端口和地址后，调用recvfrom返回数据和对端地址客户端 示例： 123456789import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b&#x27;Michael&#x27;, b&#x27;Tracy&#x27;, b&#x27;Sarah&#x27;]: # 发送数据: s.sendto(data, (&#x27;127.0.0.1&#x27;, 9999)) # 接收数据: print(s.recv(1024).decode(&#x27;utf-8&#x27;))s.close() 客户端发送数据和接收数据和之前一样，仅仅是不需要调用connect连接服务器了。 谢谢关注我的公众号：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(十九)常见的第三方库","date":"2017-12-28T03:00:37.000Z","path":"2017/12/28/python19/","text":"介绍几个python中常见的第三方库. PillowPillow简称PIL，是python中常用的图形图像处理模块。写一个简单的例子 123456789101112131415161718192021222324from PIL import Image, ImageFilter# 打开一个jpg图像文件，注意是当前路径:im = Image.open(&#x27;test.jpg&#x27;)#获取图片大小w,h = im.sizeprint(&#x27;Original image size : width:%d height: %d&#x27; %(w,h))#图片缩放im.thumbnail((w//2, h//2))print(&#x27;Resize image to: %dx%d&#x27; % (w//2, h//2))# 把缩放后的图像用jpeg格式保存:im.save(&#x27;test2.jpg&#x27;, &#x27;jpeg&#x27;)# 打开一个jpg图像文件，注意是当前路径:im = Image.open(&#x27;test.jpg&#x27;)# 应用模糊滤镜:im2 = im.filter(ImageFilter.BLUR)im2.save(&#x27;blur.jpg&#x27;, &#x27;jpeg&#x27;)im2 = im.filter(ImageFilter.CONTOUR)im2.save(&#x27;contour.jpg&#x27;,&#x27;jpeg&#x27;) Image.open函数打开一张图片，然后调用thumbnail进行缩放，调用save进行存储。filter函数为滤镜函数，可以匹配不同的滤镜模式，如模糊，边界效果等等。原图：通过滤镜模糊模式：通过滤镜边界模式： 下面利用PIL库实现一个生成验证码的小程序 1234567891011121314151617181920212223242526272829303132333435from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random#随机大写字母：def rndChar(): return chr(random.randint(65,90))#随机颜色1:def rndColor(): return(random.randint(64,255), random.randint(64,255), random.randint(64,255))#随机颜色2：def rndColor2(): return(random.randint(32,127), random.randint(32,127), random.randint(32,127))#240*60width = 60*4height = 60#Image.new(mode, size, color=None)image = Image.new(&#x27;RGB&#x27;,(width,height), (255,255,255))#创建Font对象font = ImageFont.truetype(&#x27;C:\\\\WINDOWS\\\\Fonts\\\\SIMYOU.TTF&#x27;,36)# 创建draw对象并和image绑定#用于以后绘制像素点和文本draw = ImageDraw.Draw(image)#通过像素点绘制填充图片for x in range(width): for y in range(height): draw.point((x,y),fill=rndColor())#绘制字母for t in range(4): draw.text((60*t+10,10),rndChar(),font=font, fill=rndColor2())#模糊处理#image = image.filter(ImageFilter.BLUR)image.save(&#x27;code.jpg&#x27;,&#x27;jpeg&#x27;) chardet检测编码123456789101112import chardetrs = chardet.detect(b&#x27;Hello, world!&#x27;)print(rs)data = &#x27;江船火独明&#x27;.encode(&#x27;gb2312&#x27;)rs = chardet.detect(data)print(rs)data2 = &#x27;此情可待成追忆&#x27;.encode(&#x27;utf-8&#x27;)rs2 = chardet.detect(data2)print(rs2) 用chardet可以判断编码方式，在不知道字节是按照什么格式编码时可以采用chardet。 tkinter 制作GUI界面12345678910111213141516171819from tkinter import *class Application(Frame): def __init__(self, master = None): Frame.__init__(self,master) self.pack() self.createWidgets() def createWidgets(self): self.helloLabel = Label(self, text=&#x27;Hello, world!&#x27;) self.helloLabel.pack() self.quitButton = Button(self, text = &#x27;Quit&#x27;, command=self.quit) self.quitButton.pack()app = Application()# 设置窗口标题:app.master.title(&#x27;Hello World&#x27;)# 主消息循环:app.mainloop() pack()方法是将Widgets对象加载到父容器中。具体的API读者可以查看手册。这些第三方库用到的时候再具体学习即可。","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(十八)爬虫中加入cookie","date":"2017-12-25T03:00:37.000Z","path":"2017/12/25/python18/","text":"前几篇文章介绍了urllib库基本使用和爬虫的简单应用，本文介绍如何通过post信息给网站，保存登陆后cookie，并用于请求有权限的操作。保存cookie需要用到cookiejar类，可以输出cookie信息查看下 12345678910111213141516import http.cookiejarimport urllib.request#声明一个CookieJar对象实例来保存cookiecookie = http.cookiejar.CookieJar()#HTTPCookieProcessor对象来创建cookie处理器handler = urllib.request.HTTPCookieProcessor(cookie)#通过handler来构建openeropener = urllib.request.build_opner(handler)#通过opner访问网址response = opner.open(&#x27;http://www.baidu.com&#x27;)#访问cookie中的数据for item in cookie: print(&#x27;Name = &#x27;+ item.name) print(&#x27;Value = &#x27;+ item.value) 1 通过http.cookiejar.CookieJar()创建一个cookiejar对象，用来保存上网留下的cookie。2 为了处理cookie，需要创建cookie处理器，通过urllib.request.HTTPCookieProcessor(cookie)根据cookie创建cookie处理器。3 接下来根据cookie处理器，建立opener， urllib.request.build_opener(handler)创建opener4 通过openr访问cookie中的数据 可以保存cookie，用于以后访问有权限的网页。下面将cookie写入文件 123456789101112#定义文件名filename = &#x27;cookie.txt&#x27;#定义MozillaCookieJar对象保存cookie,并且cookie关联上filename文件cookie = http.cookiejar.MozillaCookieJar(filename)#创建cookie处理器handler = request.HTTPCookieProcessor(cookie)#通过handler构建openeropener = request.build_opener(handler)#利用opener请求网页response = opener.open(&#x27;http://www.baidu.com&#x27;)#保存cookie到文件cookie.save(ignore_discard = True, ignore_expires = True) 1 传入文件名，调用http.cookiejar.MozillaCookieJar创建cookie，cookie和文件名绑定了。2 根据cookie创建处理器, request.HTTPCookieProcessor创建handler3 根据Cookie处理器创建opener4 用opener访问网站，生成cookie5 cookie.save保存到filename文件中，ignore_discard表示忽略是否过期，及时被丢弃也保存。ignore_expires表示文件存在则覆盖写入。 对于保存好的cookie文件，可以提取并访问其他网页。 123456789101112filename = &#x27;cookie.txt&#x27;#创建MozillaCookieJar对象cookie = http.cookiejar.MozillaCookieJar()#从文件中读取cookie内容到变量cookie.load(filename, ignore_discard = True, ignore_expires = True)#生成cookie处理器handler = request.HTTPCookieProcessor(cookie)#创建openeropener = request.build_opener(handler)#用opener打开网页response = opener.open(&#x27;http://www.baidu.com&#x27;)print(response.read().decode(&#x27;utf-8&#x27;)) 1 用MozillaCookieJar创建cookie2 调用cookie.load加载文件内容到cookie中3 根据cookie创建HTTPCookieProcessor4 根据handler创建opener5 利用opener打开网页，返回response 下面综合应用上面的知识，用爬虫模拟登陆，然后获取有权限的网页和信息。通过浏览器审查元素的方式可以查看访问网站的request和response，用fiddler更方便一些，用fidder监控浏览器数据，然后模拟浏览器发送登录请求。随便找一个需要登陆的网站http://www.lesmao.cc/forum.php找到登陆按钮，点击登陆，查看fiddler监控的数据。可以在fiddler中看到这个request请求post数据给网站。通过webform这一选项看到我们投递的消息有些网页是需要登陆才能访问的，如http://www.lesmao.cc/home.php?mod=space&amp;do=notice&amp;view=system 下面先模拟登陆，获取cookie，然后利用cookie访问个人信息网页。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758if __name__ == &#x27;__main__&#x27;: #登陆地址 login_url = &#x27;http://www.lesmao.cc/member.php?mod=logging&amp;action=login&amp;referer=&#x27; #User-Agent信息 user_agent = r&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27; #Headers信息 head = &#123;&#x27;User-Agnet&#x27;: user_agent, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;&#125; #登陆Form_Data信息 Login_Data = &#123;&#125; Login_Data[&#x27;formhash&#x27;] = &#x27;5ea0f6e4&#x27; Login_Data[&#x27;referer&#x27;] = &#x27;http://www.lesmao.cc/./&#x27; Login_Data[&#x27;loginfield&#x27;] = &#x27;username&#x27; Login_Data[&#x27;username&#x27;] = &#x27;secondtonone1&#x27; Login_Data[&#x27;password&#x27;] = &#x27;18301152001&#x27; Login_Data[&#x27;loginsubmit&#x27;] = &#x27;true&#x27; Login_Data[&#x27;questionid&#x27;] = &#x27;0&#x27; Login_Data[&#x27;answer&#x27;] = &#x27;&#x27; #使用urlencode方法转换标准格式 logingpostdata = parse.urlencode(Login_Data).encode(&#x27;utf-8&#x27;) #声明一个CookieJar对象实例来保存cookie cookie = cookiejar.CookieJar() #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler cookie_support = request.HTTPCookieProcessor(cookie) #通过CookieHandler创建opener opener = request.build_opener(cookie_support) #创建Request对象 req1 = request.Request(url=login_url, data=logingpostdata, headers=head) #面向对象地址 date_url = &#x27;http://www.lesmao.cc/home.php?mod=space&amp;do=notice&amp;view=system&#x27; req2 = request.Request(url=date_url, headers=head) try: #使用自己创建的opener的open方法 response1 = opener.open(req1) #print(response1.read().decode(&#x27;utf-8&#x27;)) print(&#x27;.................................&#x27;) response2 = opener.open(req2) html = response2.read().decode(&#x27;utf-8&#x27;) #打印查询结果 print(html) except error.URLError as e: if hasattr(e, &#x27;code&#x27;): print(&quot;URLError:%d&quot; % e.code) if hasattr(e, &#x27;reason&#x27;): print(&quot;URLError:%s&quot; % e.reason) except error.HTTPError as e: if hasattr(e, &#x27;code&#x27;): print(&quot;URLError:%d&quot; % e.code) if hasattr(e, &#x27;reason&#x27;): print(&quot;URLError:%s&quot; % e.reason) except Exception as e: print(&#x27;Exception is : &#x27;, e) 打印出的html信息和登陆后点击的信息是一致的，所以用cookie登陆并访问其它权限网页成功了。源码下载地址：源码下载我的公众号：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"利用urllib库爬取MM图片","date":"2017-12-22T04:54:49.000Z","path":"2017/12/22/python17/","text":"这一篇巩固前几篇文章的学到的技术，利用urllib库爬取美女图片，其中采用了多线程，文件读写，目录匹配，正则表达式解析，字符串拼接等知识，这些都是前文提到的，综合运用一下，写个爬虫示例爬取美女图片。先定义几个匹配规则和User_Agent 1234567USER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;PATTERN1 = r&#x27;&lt;div id=&quot;content&quot;&gt;.*?&lt;h2&gt;(.*?)&lt;/h2&gt;&#x27; PATTERN2 = r&#x27;&lt;p&gt;&lt;img src=&quot;(.*?)&quot;&#x27;PATTERN2 = r&#x27;&lt;p&gt;&lt;img class=&quot;.*?src=&quot;(.*?)&quot;&#x27;PATTERN3 = r&#x27;&#x27;&#x27;&lt;li class=&#x27;next-page&#x27;&gt;&lt;a target=&quot;_blank&quot; href=&#x27;(.*?)&#x27;&gt;下一页&#x27;&#x27;&#x27;PATTERN4 = r&#x27;^(.*)/&#x27;PATTERN5 = r&#x27;^.*/(.*?)$&#x27; 读者可以根据不同网站的代码去修改这些规则，达到匹配一些网站的目的。 1定义抓图类123456789class GetMMPic(object): def __init__(self,path,httpstr): # 去除首位空格 path = path.strip() # 去除尾部 \\ 符号 path = path.rstrip(&#x27;\\\\&#x27;) self.path = path self.url = httpstr self.user_agent = USER_AGENT 初始化构造函数中设置了路径和网络地址，以及请求的user_agent。 2封装信息请求和读取函数12345678910111213141516171819def requestData(self,url, user_agent): try: req = request.Request(url) req.add_header(&#x27;User-Agent&#x27;, user_agent) response = request.urlopen(req,timeout = 8) #bytes变为字符串 content = response.read().decode(&#x27;utf-8&#x27;) return content except error.URLError as e: if hasattr(e,&#x27;code&#x27;): print (e.code) if hasattr(e,&#x27;reason&#x27;): print (e.reason) except error.HTTPError as e: if hasattr(e,&#x27;code&#x27;): print(e.code) if hasattr(e,&#x27;reason&#x27;): print(e.reason) print(&#x27;HTTPError!!!&#x27;) 这个函数功能主要是请求url网络地址，加上user_agent后，获取数据，并且采用utf-8编码方式解析。 3封装创建目录函数1234567891011def makedir(self,dirname): joinpath = os.path.join(self.path,dirname) print(joinpath) isExists = os.path.exists(joinpath) if isExists: print(&#x27;目录已经存在\\n&#x27;) return None else: os.makedirs(joinpath) print(&#x27;创建成功\\n&#x27;) return joinpath 该函数主要是完成在GMMPic类配置的路径下(默认是./)，生成子目录，子目录的名字由参数决定。简单地说就是要在当前目录下生成文件名对应的文件夹，保存不同的图片。 4 获取当前页面信息保存图片1234567891011121314151617181920212223242526272829303132333435363738394041424344def getPageData(self,httpstr): content = self.requestData(self.url, self.user_agent) namepattern = re.compile(PATTERN1,re.S) nameresult = re.search(namepattern, content) namestr = nameresult.group(1) dirpath = self.makedir(namestr) if not dirpath: print(&#x27;目录已存在&#x27;) return picpattern = re.compile(PATTERN2,re.S) lastpattern = re.compile(PATTERN5, re.S) while(1): print(&#x27;正在爬取%s........&#x27;%(namestr)) picitems = re.findall(picpattern,content) for item in picitems: picrs = re.search(lastpattern, item) picname = picrs.group(1) filedir = os.path.join(dirpath,picname) url = quote(item, safe = string.printable) try: req = request.Request(url) req.add_header(&#x27;User-Agent&#x27;,USER_AGENT) response = request.urlopen(req) picdata =response.read() with open(filedir,&#x27;wb&#x27;) as file: file.write(picdata) except error.URLError as e: if hasattr(e,&#x27;code&#x27;): print (e.code) if hasattr(e,&#x27;reason&#x27;): print (e.reason) except error.HTTPError as e: if hasattr(e,&#x27;code&#x27;): print (e.code) if hasattr(e,&#x27;reason&#x27;): print (e.reason) print(&#x27;\\n%s爬取成功.......&#x27;%(namestr)) break getPageData()函数根据PATTERN2匹配页面符合条件的图片资源，根据PATTERN5取出图片名字(不含类型),通过for循环一个一个保存。 运行程序，提示输入网址，这里输入男人装某篇文章的地址，效果如下： 5 采用多线程提高并发能力编写线程回调函数 workthread， 每个线程去爬不同的文章 123456789101112131415161718192021def workthread(item, user_agent,path): strurl = &#x27;http://yxpjw.club&#x27;+item[0] picname = item[1] print(&#x27;正在爬取%s...........................\\n&#x27; %(picname)) content = requestData(strurl,user_agent) strurl2 = re.search(r&#x27;^(.*)/&#x27;,strurl).group(0) print(&#x27;https headers...............%s&#x27;%(strurl2)) #destname = os.path.join(path,picname+&#x27;.txt&#x27;) #with open(destname, &#x27;w&#x27;,encoding=&#x27;gbk&#x27;) as file: #file.write(content) destdir = os.path.join(path,picname) os.makedirs(destdir) page = 1 while(1): content = getpagedata(content,destdir,page,strurl2) if not content: break page = page + 1 print(&#x27;%s数据爬取成功！！！\\n&#x27;%(picname)) 开辟多个线程，去爬首页各个分栏，实现自动化抓图 1234567891011121314151617181920def getDetailList(self,content): s2 = r&#x27;&lt;h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&#x27; pattern =re.compile(s2 , re.S ) result = re.findall(pattern, content) with open(&#x27;file.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;gbk&#x27;) as f: f.write(content) if not result: print(&#x27;匹配规则不适配..............&#x27;) threadsList=[] for item in result: t = threading.Thread(target = workthread, args=(item, self.user_agent, self.path)) threadsList.append(t) t.start() for threadid in threadsList: threadid.join() 用修改后的多线程程序爬取宅福利首页各模块图片效果如下： 源码下载地址：https://github.com/secondtonone1/python-谢谢关注我的公众号：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(十六)写爬虫获取糗事百科段子","date":"2017-12-19T11:04:33.000Z","path":"2017/12/19/python16/","text":"利用前面学到的文件、正则表达式、urllib的知识，综合运用，爬取糗事百科的段子先用urllib库获取糗事百科热帖第一页的数据。并打开文件进行保存，正好可以熟悉一下之前学过的文件知识。 123456789101112131415161718192021222324from urllib import request, parsefrom urllib import errorpage = 1url = &#x27;https://www.qiushibaike.com/hot/page/&#x27;+str(page)user_agent = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;try: req = request.Request(url) req.add_header(&#x27;User-Agent&#x27;, user_agent) response = request.urlopen(req) #bytes变为字符串 content = response.read().decode(&#x27;utf-8&#x27;) print(type(content)) #uf-8编码方式打开 file = open(&#x27;file.txt&#x27;, &#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) file.write(content) except error.URLError as e: if hasattr(e,&#x27;code&#x27;): print (e.code) if hasattr(e,&#x27;reason&#x27;): print (e.reason)finally: file.close() 打开文件可以看到如下内容：div class=”article block untagged mb15 typs_long” id=’qiushi_tag_119848276’表示一个文章的开始，id为文章对应的id，h2 之间的是发布者的姓名‘高老庄福帅猪刚鬣’，span与/span之间的是正文， i class=”number”与/i，635表示赞的个数，同样也可以获取评论的个数。 下面要用到学过的正则表达式的知识，过滤掉没有用的信息，只获取评论数，作者，正文，以及点赞的数量。 1234567891011121314import rewith open(&#x27;file.txt&#x27;,&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: data = f.read()pattern = re.compile(r&#x27;&lt;div.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?number&quot;&gt;(.*?)&lt;/i&gt;.*?&#x27;+ r&#x27;&quot;number&quot;&gt;(.*?)&lt;/i&gt;&#x27;, re.S )result = re.search(pattern, data)#print(result)#print(result.group())print(result.group(1))print(result.group(2))print(result.group(3))print(result.group(4)) re.compile(),参数re.S表示将.的作用扩充为任意字符，因为前几篇文章讲述过.在一般情况下匹配除/n之外的所有字符。正则表达式中.*?连起来匹配任意字符，且为非贪婪模式。因为.表示任意字符，*表示匹配前一个字符0个或多个，.*表示匹配任意多个字符，而加上？表示非贪婪模式。re.search是搜索匹配正则表达式规则的条目，search讲述过可以从内容的任意位置查找。这样就可以找到一个符合这种规则的段子。如果找到所有符合规则的段子可以用re.findall进行查找。 下面一气呵成，将网站上的段子按照正则表达式匹配，并将匹配后的段子写入文件，同时在终端显示。 123456789101112131415161718192021222324252627282930313233343536from urllib import request, parsefrom urllib import errorpage = 1url = &#x27;https://www.qiushibaike.com/hot/page/&#x27;+str(page)user_agent = &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;try: req = request.Request(url) req.add_header(&#x27;User-Agent&#x27;, user_agent) response = request.urlopen(req) #bytes变为字符串 content = response.read().decode(&#x27;utf-8&#x27;) pattern = re.compile(r&#x27;&lt;div.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?number&quot;&gt;(.*?)&lt;/i&gt;.*?&#x27;+ r&#x27;&quot;number&quot;&gt;(.*?)&lt;/i&gt;&#x27;, re.S ) result = re.findall(pattern, content) files = open(&#x27;findfile.txt&#x27;,&#x27;w+&#x27;, encoding=&#x27;utf-8&#x27;) for item in result: author = item[0] contant = item[1] vote = &#x27;赞：&#x27;+item[2] commit = &#x27;评论数：&#x27;+item[3] infos = vote +&#x27; &#x27;+commit+&#x27; &#x27;+&#x27;\\n\\n&#x27; print(author) print(contant) print(infos) files.write(author) files.write(contant) files.write(infos) except error.URLError as e: if hasattr(e,&#x27;code&#x27;): print (e.code) if hasattr(e,&#x27;reason&#x27;): print (e.reason)finally: files.close() 效果如下：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(十五)内建模块","date":"2017-12-19T02:42:20.000Z","path":"2017/12/19/python15/","text":"介绍python的几个內建模块 1 python的时间模块datetime取现在时间 1234from datetime import datetimenow = datetime.now()print(now)print(type(now)) 将指定日期转化为时间戳 1234from datetime import datetimedt = datetime(2017,12,13,13,7)# 把datetime转换为timestampprint( dt.timestamp() ) 将时间戳转化为日期 123from datetime import datetimet = 1429417200.0print(datetime.fromtimestamp(t)) 根据时间戳转化为本地时间和utc时间 123456from datetime import datetimet = 1429417200.0# 本地时间print(datetime.fromtimestamp(t))# UTC时间 print(datetime.utcfromtimestamp(t)) 将字符串转化为时间 123from datetime import datetimecday = datetime.strptime(&#x27;2017-6-1 18:22:22&#x27;,&#x27;%Y-%m-%d %H:%M:%S&#x27;)print(day) 将时间戳转化为字符串 123from datetime import datetimenow = datetime.now()print(now.strftime(&#x27;%a,%b %d %H:%M&#x27;)) 时间加减 123456from datetime import datetime , timedeltanow = datetime.now()print( now )print(now + timedelta(hours = 10))print(now + timedelta(days = 1))print(now + timedelta(days = 2, hours = 12)) 设置时区 123456789from datetime import datetime, timedelta, timezone# 创建时区UTC+8:00timezone_8 = timezone(timedelta(hours = 8) )now = datetime.now()print(now)# 强制设置为UTC+8:00dt = now.replace(tzinfo=timezone_8)print(dt) 获取utc时区和时间，并且转化为别的时区的时间 12345678910111213from datetime import datetime, timedelta, timezone# 拿到UTC时间，并强制设置时区为UTC+0:00:utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)print(utc_dt)bj_dt = utc_dt.astimezone(timezone(timedelta(hours = 8) ))print(bj_dt)tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours = 9) ) )print(tokyo_dt)tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours = 9) ) )print(tokyo_dt2) 2命名tuple123456789101112131415161718#可命名tuplefrom collections import namedtuplePoint = namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;,&#x27;y&#x27;])p = Point(1,2)print(p.x)from collections import dequeq = deque([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])q.append(&#x27;x&#x27;)q.appendleft(&#x27;y&#x27;)print(q)from collections import defaultdictdd = defaultdict(lambda:&#x27;N/A&#x27;)dd[&#x27;key1&#x27;]=&#x27;abc&#x27;print(dd[&#x27;key1&#x27;])print(dd[&#x27;key2&#x27;]) 3顺序字典12345678from collections import OrderedDictd = dict([ [&#x27;a&#x27;,1], [&#x27;b&#x27;,2],[&#x27;c&#x27;,3]])print(d)od = OrderedDict([(&#x27;a&#x27;,1),(&#x27;b&#x27;,2),(&#x27;c&#x27;,3)])print(od)od2 = OrderedDict([[&#x27;Bob&#x27;,90],[&#x27;Jim&#x27;,20],[&#x27;Seve&#x27;,22]])print(od2) 4计数器12345from collections import Counterc = Counter()for ch in &#x27;programming&#x27;: c[ch]=c[ch]+1 5 itertools从一开始生成自然数 12345#itertools.count(start , step)import itertoolsnatuals = itertools.count(1)for n in natuals: print(n) 在生成的可迭代序列中按规则筛选 1234natuals = itertools.count(1)ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)print(ns)print(list(ns) ) 将两个字符串生成一个序列 1234for c in itertools.chain(&#x27;ABC&#x27;,&#x27;XYZ&#x27;): print(c)print(list(itertools.chain(&#x27;ABC&#x27;,&#x27;XYZ&#x27;)) ) 迭代器把连续的字母放在一起分组 123456for key, group in itertools.groupby(&#x27;AAABBBCCAAA&#x27;): print(key, list(group)) print(key, group)for key, group in itertools.groupby(&#x27;AaaBBbcCAAa&#x27;, lambda c: c.upper() ): print(key,list(group)) 6 contextmanageropen 返回的对象才可用with，或者在类中实现__enter__和__exit__可以使该类对象支持with用法 123456789101112131415161718192021class Query(object): def __init__(self, name): self.name = name def __enter__(self): print(&#x27;Begin&#x27;) return self def __exit__(self, exc_type, exc_value, traceback): if exc_type: print(&#x27;Error&#x27;) else: print(&#x27;End&#x27;) def query(self): print(&#x27;Query info about %s...&#x27; %self.name) with Query(&#x27;BBBB&#x27;) as q: if q: q.query() 简单介绍下原理 123456with EXPR as VAR:实现原理:在with语句中, EXPR必须是一个包含__enter__()和__exit__()方法的对象(Context Manager)。调用EXPR的__enter__()方法申请资源并将结果赋值给VAR变量。通过try/except确保代码块BLOCK正确调用，否则调用EXPR的__exit__()方法退出并释放资源。在代码块BLOCK正确执行后，最终执行EXPR的__exit__()方法释放资源。 通过python提供的装饰器contextmanager，作用在生成器函数，可以达到with操作的目的 123456789101112131415161718from contextlib import contextmanagerclass Query(object): def __init__(self, name): self.name = name def query(self): print(&#x27;Query info about %s ...&#x27; %self.name)@contextmanagerdef create_query(name): print(&#x27;Begin&#x27;) q = Query(name) yield q print(&#x27;End&#x27;)with create_query(&#x27;aaa&#x27;) as q: if q: print(q.query()) 可以看看contextmanager源码，了解下 12345678910111213141516171819202122232425262728293031323334353637383940class GeneratorContextManager(object): def __init__(self, gen): self.gen = gen def __enter__(self): try: return self.gen.next() except StopIteration: raise RuntimeError(&quot;generator didn&#x27;t yield&quot;)​ def __exit__(self, type, value, traceback): if type is None: try: self.gen.next() except StopIteration: return else: raise RuntimeError(&quot;generator didn&#x27;t stop&quot;) else: try: self.gen.throw(type, value, traceback) raise RuntimeError(&quot;generator didn&#x27;t stop after throw()&quot;) except StopIteration: return True except: # only re-raise if it&#x27;s *not* the exception that was # passed to throw(), because __exit__() must not raise # an exception unless __exit__() itself failed. But # throw() has to raise the exception to signal # propagation, so this fixes the impedance mismatch # between the throw() protocol and the __exit__() # protocol. # if sys.exc_info()[1] is not value: raise​def contextmanager(func): def helper(*args, **kwds): return GeneratorContextManager(func(*args, **kwds)) return helper 也可以采用closing用法作用在一个对象上支持with open操作 123456from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&#x27;https://www.python.org&#x27;)) as page: for line in page: print(line) 介绍下closing 实现原理 123456@contextmanagerdef closing(thing): try: yield thing finally: thing.close() 同样可以用contextmanager实现打印指定标签的上下文对象 123456789@contextmanagerdef tag(name): print(&quot;&lt;%s&gt;&quot; % name) yield print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;): print(&quot;hello&quot;) print(&quot;world&quot;) 上述代码执行结果为： 123456789&lt;h1&gt;helloworld&lt;/h1&gt;代码的执行顺序是：with语句首先执行yield之前的语句，因此打印出&lt;h1&gt;；yield调用会执行with语句内部的所有语句，因此打印出hello和world；最后执行yield之后的语句，打印出&lt;/h1&gt;。 7 urllib库这是个非常重要的库，做爬虫会用到 采用urllib get网页信息 1234567from urllib import request with request.urlopen(&#x27;http://www.limerence2017.com/&#x27;) as f: data = f.read() print(&#x27;Status:&#x27;, f.status, f.reason) for k, v in f.getheaders(): print(&#x27;%s: %s&#x27; %(k,v)) print(&#x27;Data:&#x27;, data.decode(&#x27;utf-8&#x27;) ) 在request中添加信息头模拟浏览器发送请求 123456789101112131415161718192021222324from urllib import requestreq = request.Request(&#x27;http://www.douban.com/&#x27;)req.add_header(&#x27;User-Agent&#x27;, &#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;)with request.urlopen(req) as f: print(&#x27;Status:&#x27;, f.status, f.reason) for k, v in f.getheaders(): print(&#x27;%s: %s&#x27; %(k,v)) print(&#x27;Data:&#x27;, f.read().decode(&#x27;utf-8&#x27;))from urllib import request, parseprint(&#x27;Login to weibo.cn...&#x27;)email = input(&#x27;Email: &#x27;)passwd = input(&#x27;Password: &#x27;)login_data = parse.urlencode([ (&#x27;username&#x27;, email), (&#x27;password&#x27;, passwd), (&#x27;entry&#x27;, &#x27;mweibo&#x27;), (&#x27;client_id&#x27;, &#x27;&#x27;), (&#x27;savestate&#x27;, &#x27;1&#x27;), (&#x27;ec&#x27;, &#x27;&#x27;), (&#x27;pagerefer&#x27;, &#x27;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)]) 采用post方式获取信息, request.urlopen()，参数可以携带data发送给网址 123456789101112131415161718192021222324print(&#x27;Login to weibo.cn...&#x27;)email = input(&#x27;Email: &#x27;)passwd = input(&#x27;Password: &#x27;)login_data = parse.urlencode([ (&#x27;username&#x27;, email), (&#x27;password&#x27;, passwd), (&#x27;entry&#x27;, &#x27;mweibo&#x27;), (&#x27;client_id&#x27;, &#x27;&#x27;), (&#x27;savestate&#x27;, &#x27;1&#x27;), (&#x27;ec&#x27;, &#x27;&#x27;), (&#x27;pagerefer&#x27;, &#x27;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)])req = request.Request(&#x27;https://passport.weibo.cn/sso/login&#x27;)req.add_header(&#x27;Origin&#x27;, &#x27;https://passport.weibo.cn&#x27;)req.add_header(&#x27;User-Agent&#x27;, &#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;)req.add_header(&#x27;Referer&#x27;, &#x27;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)with request.urlopen(req, data=login_data.encode(&#x27;utf-8&#x27;)) as f: print(&#x27;Status:&#x27;, f.status, f.reason) for k, v in f.getheaders(): print(&#x27;%s:%s&#x27; %(k,v)) print(&#x27;Data: &#x27;, f.read().decode(&#x27;utf-8&#x27;)) 采用代理方式获取网页信息 12345678910111213proxy_handler = urllib.request.ProxyHandler(&#123;&#x27;http&#x27;: &#x27;http://www.example.com:3128/&#x27;&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password(&#x27;realm&#x27;, &#x27;host&#x27;, &#x27;username&#x27;, &#x27;password&#x27;)opener = urllib.request.bulid_opener(proxy_handler, proxy_auth_handler)with opener.open(&#x27;http://www.example.com/login.html&#x27;) as f: passproxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password(&#x27;realm&#x27;, &#x27;host&#x27;, &#x27;username&#x27;, &#x27;password&#x27;)opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open(&#x27;http://www.example.com/login.html&#x27;) as f: pass","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(十四) 正则表达式","date":"2017-12-12T08:45:18.000Z","path":"2017/12/12/rematch/","text":"什么是正则表达式正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑 正则表达式规则 正则表达式注意问题数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。*表示匹配前一个字符0个或多个，加上?后匹配前一个字符0个或1个，使匹配规则变为非贪婪。 转义问题由于字符串中出现特殊字符要采取转义，采用’&#39;可以进行转义。如果字符串中出现’&#39;,需要采用’\\‘才可以转义为’&#39;,Python里的原生字符串很好地解决了这个问题，在字符串前加上r，表示原生字符串，不用考虑转义问题。看下面的例子： 12345import res = &#x27;AB\\\\-001&#x27;print(s)s = r&#x27;AB\\-001&#x27;print(s) 使用原生字符串不用写转义的’&#39;了。 正则表达式的应用举例1 可以re模块中的match函数实现基本的匹配 12345import reresult = re.match(r&#x27;^\\d&#123;3&#125;\\-\\d&#123;3,8&#125;$&#x27;,&#x27;010-12345&#x27;)print(result)result2 = re.match(r&#x27;^\\d&#123;3&#125;\\-\\d&#123;3,8&#125;$&#x27;,&#x27;010 12345&#x27;)print(result2) 2 可以实现split切割字符串 1234567#切串s1 = &#x27;a b c&#x27;print(s1.split(&#x27; &#x27;) )s2 = re.split(r&#x27;\\s+&#x27;, s1)print(s2)s3 = re.split(r&#x27;[\\s\\:\\,]+&#x27;,&#x27;a,b c::d e, f&#x27;)print(s3) 1234pattern = re.compile(r&#x27;\\d+&#x27;)splitrs = re.split(pattern, &#x27;one1two2three3four45six797five&#x27;)if sr: print(splitrs) 3 对匹配规则进行分组 123456m = re.match(r&#x27;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x27;,&#x27;010-12345&#x27;)print(m)print(m.group(0))print(m.group(1))print(m.group(2))print(m.groups()) 4 贪婪匹配和非贪婪匹配 1234r1 = re.match(r&#x27;^(\\d+)(0*)$&#x27;,&#x27;102300&#x27;).groups()print(r1)r2 = re.match(r&#x27;^(\\d+?)(0*)$&#x27;,&#x27;102300&#x27;).groups()print(r2) 5 编译生成pattern再匹配 12345re_telephone = re.compile(r&#x27;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x27;)r3 = re_telephone.match(&#x27;010-12345&#x27;).groups()print(r3)r4 = re_telephone.match(&#x27;043-12345&#x27;).groups()print(r4) match 的另一种写法是这样的 12345678910111213141516171819202122232425pattern = re.compile(r&#x27;hello&#x27;)result1 = re.match(pattern, &#x27;hello&#x27;)result2 = re.match(pattern, &#x27;helloo, aaa&#x27;)result3 = re.match(pattern, &#x27;helo AAB&#x27;)result4 = re.match(pattern, &#x27;helloww&#x27;)if result1: print(result1 )else: print(&#x27;failed!!!&#x27;)if result2: print(result2.group() )else: print(&#x27;failed!!!&#x27;)if result3: print(result3.group() )else: print(&#x27;failed!!!&#x27;)if result4: print(result4.group() )else: print(&#x27;failed!!!&#x27;) re.compile返回值包含如下属性和函数：属性：1.string: 匹配时使用的文本。2.re: 匹配时使用的Pattern对象。3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。函数：1.group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串； 不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。2.groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。3.groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。4.start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。5.end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。6.span([group]): 返回(start(group), end(group))。7.expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的； 但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。 下面的例子将上述属性和函数打印出来，读者可以打印看看结果 1234567891011121314151617#匹配：单词+空格+单词+任意字符m = re.match(r&#x27;(\\w+) (\\w+)(?P&lt;sign&gt;.*)&#x27;,&#x27;hello world!&#x27;)print(&#x27;m.string is %s&#x27; %(m.string) )print(&#x27;m.re: %s&#x27; %(m.re) )print(&#x27;m.pos: %d&#x27; %(m.pos))print(&#x27;m.endpos: %d&#x27; %(m.endpos))print(&#x27;m.lastindex: %d&#x27; %(m.lastindex))print(&#x27;m.lastgroup: %s&#x27; %(m.lastgroup))print(&#x27;m.groups: &#x27; , m.groups())print(&#x27;m.group: &#x27; , m.group())print(&#x27;m.group(1,2): &#x27; , m.group(1,2))print(&#x27;m.groupdict():&#x27;, m.groupdict())print(&#x27;m.start(2):&#x27;,m.start(2))print(&#x27;m.end(2):&#x27;,m.end(2))print(&#x27;m.span(2):&#x27;,m.span(2))print(&quot;m.expand(r&#x27;\\g \\g\\g&#x27;):&quot;, m.expand(r&#x27;\\2 \\1\\3&#x27;) ) 除此之外还有其他的几个函数 6 re.search(pattern, string[, flags])search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配 12345import repattern = re.compile(r&#x27;world&#x27;)sr = re.search(pattern, &#x27;hello world!&#x27;)if sr: print(sr.group()) 7 re.findall(pattern, string[, flags])搜索string，以列表形式返回全部能匹配的子串。 1234pattern = re.compile(r&#x27;\\d+&#x27;)find = re.findall(pattern, &#x27;one1two2three3four45six797five&#x27;)if find: print(find) 8 re.finditer(pattern, string[, flags])搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 123456pattern = re.compile(r&#x27;\\d+&#x27;)finditer = re.finditer(pattern, &#x27;one1two2three3four45six797five&#x27;)if(finditer): print(finditer) for m in finditer: print(m.group()) 9 re.sub(pattern, repl, string[, count])使用repl替换string中每一个匹配的子串后返回替换后的字符串,首先根据pattern在string中匹配，找到子串返回列表，然后根据repl规则，替换列表中的字符串。 123456789pattern = re.compile(r&#x27;(\\w+) (\\w+)&#x27;)s = &#x27;i say, hello world&#x27;print(re.sub(pattern,r&#x27;\\2 \\1&#x27;, s))def func(m): return m.group(1).title() + &#x27; &#x27;+ m.group(2).title()sub = re.sub(pattern, func, s)print(sub) 10 re.subn(pattern, repl, string[, count])返回 一个tuple，tuple两个元素，第一个为re.sub(pattern, repl, string[, count])的结果，第二个为匹配的子串个数。 123456789pattern = re.compile(r&#x27;(\\w+) (\\w+)&#x27;)s = &#x27;i say, hello world&#x27;print(re.subn(pattern,r&#x27;\\2 \\1&#x27;, s))def func(m): return m.group(1).title() + &#x27; &#x27;+ m.group(2).title()sub = re.subn(pattern, func, s)print(sub) 到目前为止正则表达式基本知识介绍完毕，谢谢关注我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"冬日清晨不愿起","date":"2017-12-11T09:49:29.000Z","path":"2017/12/11/qcbyq/","text":"《冬日清晨不愿起》 冬日多寒意， 朦胧不愿起， 妻子劝我披冬衣。 铁锅炖鹅肉， 清晨一杯酒， 恨不能与天同寿。","categories":[{"name":"生活感悟","slug":"news","permalink":"http://www.limerence2017.com/categories/news/"}],"tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://www.limerence2017.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"}]},{"title":"学习资料整理","date":"2017-12-11T08:37:54.000Z","path":"2017/12/11/codesrc/","text":"C++ 教程网大并发服务器：链接: 大并发服务器 密码: 6edt陈硕网络编程实践：链接: 陈硕网络编程实践 密码: 7x1d达内C++学习：链接: 达内C++学习 密码: bwj7轩辕LinuxC：链接: 轩辕LinuxC 密码: 62nt自己总结的python源码和demo：链接：python例子和源码精品电子书链接: 精品电子书 密码: 7bd5python3.6爬虫最细教程链接: python3.6爬虫最细教程 密码: ct27区块链2018教程链接: 区块链2018教程 密码: dqk5基于epoll，select模型封装的服务器模型链接: 基于epoll，select模型封装的服务器模型基于libevent网络库封装的服务器模型链接: 基于libevent网络库封装的服务器模型基于boost::asio 封装的异步通信网络模型链接: 基于boost::asio 封装的异步通信网络模型Go 封装的tcp框架，同时集成了websocket，http等。链接: golang实现的tcp框架wentbyGo 基于wentby框架封装的游戏服务器wentserver链接: golang实现游戏服务器wentserver 更多资源请关注微信公众号：","categories":[{"name":"资源共享","slug":"share","permalink":"http://www.limerence2017.com/categories/share/"}],"tags":[{"name":"学习资料","slug":"学习资料","permalink":"http://www.limerence2017.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"}]},{"title":"python学习(十三)进程和线程","date":"2017-11-29T10:22:25.000Z","path":"2017/11/29/processthread/","text":"python多进程 12345678910111213from multiprocessing import Processimport osdef processFunc(name): print(&quot;child process is %s, pid is %s&quot; %(name, os.getpid() ) ) returnif __name__ == &#x27;__main__&#x27;: print(&quot;Parent process is %s.&quot; %(os.getpid() )) p = Process(target = processFunc, args = (&#x27;test&#x27;, )) print(&#x27;Child will start &#x27;) p.start() p.join() print(&quot;Child stop&quot;) 进程池 1234567891011121314151617181920from multiprocessing import Poolimport os , time, randomdef long_time_task(name): print(&#x27;run task name is %s&#x27; %(name)) start = time.time() time.sleep(random.random()*3) end = time.time() print(&#x27;Task %s runs %0.2f seconds.&#x27; %(name, (end - start )) )if __name__ == &#x27;__main__&#x27;: print(&#x27;Parent pid is %s&#x27; %(os.getpid() )) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args = (str(i) ,) ) print(&quot;Waiting all processes!!!&quot;) p.close() p.join() print(&quot;All subprocess done&quot;) 启动进程，并调用命令行 12345import subprocessprint(&#x27;$ nslookup www.python.org&#x27;)r = subprocess.call([&#x27;nslookup&#x27;, &#x27;www.python.org&#x27;])print(&#x27;Exit code:&#x27;, r) 队列Queue可实现两个进程间通信 1234567891011121314151617181920212223from multiprocessing import Process, Queueimport os, time, randomdef write(q): print(&#x27;Process to Write pid is %s&#x27; %(os.getpid() ) ) for i in [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]: q.put(i) time.sleep(random.random())def read(q): print(&#x27;Process to Read pid is %s&#x27; %(os.getpid() ) ) while(True): value = q.get(True) print(&#x27;Get %s from queue &#x27; %(value))if __name__ == &#x27;__main__&#x27;: q = Queue() pw = Process(target=write, args = (q,)) pr = Process(target = read , args = (q,) ) pw.start() pr.start() pw.join() pr.terminate() python多线程 12345678910111213141516import threading , timedef loop(): print(&#x27;thread %s is running ...&#x27; % threading.current_thread().name) n = 0 while n &lt; 5: n = n+ 1 print(&#x27;thread %s &gt;&gt;&gt; %s&#x27; %(threading.current_thread().name, n)) time.sleep(1) print(&#x27;thread %s ended. &#x27; %(threading.current_thread().name ) )if __name__ == &#x27;__main__&#x27;: print(&#x27;Thread %s is running...&#x27; % threading.current_thread().name) t = threading.Thread(target = loop, name = &#x27;LoopThread&#x27;) t.start() t.join() print(&#x27;Thread %s ended.&#x27; % threading.current_thread().name) 多线程访问全局变量，记得加锁 12345678910111213141516171819202122232425262728import time, threading# 假定这是你的银行存款:balance = 0lock = threading.Lock()def change_it(n): # 先存后取，结果应该为0: global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(100000): lock.acquire() try: change_it(n) finally: lock.release() t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance) 避免枷锁带来的效率衰退，可使用线程本地变量 123456789101112131415161718192021import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print(&#x27;Hello, %s in thread %s&#x27; %(std, threading.current_thread().name ))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()if __name__ == &#x27;__main__&#x27;: t1 = threading.Thread(target = process_thread, args=(&#x27;Alice&#x27;,), name = &#x27;Thread-A&#x27;) t2 = threading.Thread(target= process_thread, args=(&#x27;Bob&#x27;,), name=&#x27;Thread-B&#x27;) t1.start() t2.start() t1.join() t2.join() 分布式进程，用于不同机器通信，采用BaseManager，在masterprocess.py中实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445import random, time, queuefrom multiprocessing.managers import BaseManagertask_queue = queue.Queue()result_queue = queue.Queue()def taskqueuefunc(): global task_queue return task_queuedef resultqueuefunc(): global result_queue return result_queueclass QueueManager(BaseManager): passdef ServerStart(): QueueManager.register(&#x27;get_task_queue&#x27;, callable = taskqueuefunc) QueueManager.register(&#x27;get_result_queue&#x27;, callable = resultqueuefunc) manager = QueueManager(address=(&#x27;127.0.0.1&#x27;, 5000), authkey=b&#x27;abc&#x27;) manager.start() task = manager.get_task_queue() result = manager.get_result_queue() for i in range(10): n = random.randint(0,10000) print(&#x27;Put task %d...&#x27; %n) task.put(n) # 从result队列读取结果: print(&#x27;Try get results...&#x27;) for i in range(10): r = result.get(timeout=10) print(&#x27;Result: %s&#x27; % r) # 关闭: manager.shutdown() print(&#x27;master exit.&#x27;)if __name__ == &#x27;__main__&#x27;: ServerStart() 在另一个文件workprocess.py中实现另一个进程处理数据 12345678910111213141516171819202122232425import time,sys,queuefrom multiprocessing.managers import BaseManagerclass QueueManager(BaseManager): passQueueManager.register(&#x27;get_task_queue&#x27;)QueueManager.register(&#x27;get_result_queue&#x27;)server_addr = &#x27;127.0.0.1&#x27;print(&#x27;Connect to server %s...&#x27; % server_addr)m = QueueManager(address=(server_addr,5000),authkey=b&#x27;abc&#x27;)m.connect()task = m.get_task_queue()result = m.get_result_queue()for i in range(10): try: n = task.get(timeout=1) print(&#x27;run task %d %d...&#x27; % (n,n)) r = &#x27;%d %d = %d&#x27; % (n,n,n*n) time.sleep(1) result.put(r) except queue.Empty: print(&#x27;task queue is empty.&#x27;)print(&#x27;worker exit.&#x27;) 先启动masterprocess.py，然后启动workprocess.py，可以看到效果谢谢关注我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python文件读写和序列化","date":"2017-11-14T07:47:51.000Z","path":"2017/11/14/pythonio/","text":"python 文件读写和序列化学习。 python文件读写1 打开并且读取文件 123f = open(&#x27;openfile.txt&#x27;,&#x27;r&#x27;)print(f.read())f.close() 2 打开并且读取一行文件 123f = open(&#x27;openfile.txt&#x27;,&#x27;r&#x27;)print(f.readline())f.close() 3 打开并以二进制形式读取文件 123f = open(&#x27;./openfile.txt&#x27;,&#x27;rb&#x27;)print(f.read())f.close() 4 打开并自动关闭文件 12with open(&#x27;openfile.txt&#x27;,&#x27;r&#x27;) as f: print(f.read()) 5 读取所有行 1234f = open(&#x27;openfile.txt&#x27;,&#x27;r&#x27;)for line in f.readlines(): print(line.strip())f.close() 6 以gbk方式读取文件 123f = open(&#x27;openfiles.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;gbk&#x27; )print(f.read())f.close() 7 以追加方式写 123with open(&#x27;openfile.txt&#x27;, &#x27;a&#x27;) as f: f.write(&#x27;\\n&#x27;) f.write(&#x27;Hello World!!!&#x27;) python IO操作1 StringIO 写字符串 123456from io import StringIOf = StringIO()f.write(&#x27;hello&#x27;)f.write(&#x27; &#x27;)f.write(&#x27;world !&#x27;)print(f.getvalue() ) 2 StringIO 读取字符串 1234567from io import StringIOf = StringIO(&quot;Hello\\nWorld\\nGoodBye!!&quot;)while True: s = f.readline() if(s==&#x27;&#x27;): break print(s.strip()) 3 BytesIO 读写二进制字符 12345678from io import BytesIOf = BytesIO()f.write(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;) )print(f.getvalue())from io import BytesIOf = BytesIO(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)f.read() python环境变量和目录1 打印系统的名字和环境变量 123import osprint(os.name)print(os.environ) 2 获取指定key值得环境变量 1print(os.environ.get(&#x27;PATH&#x27;)) 3 相对路径转化绝对路径 1print(os.path.abspath(&#x27;.&#x27;)) 4 在某个目录下创建一个新的目录 123456#首先把新目录的完整路径表示出来print(os.path.join(&#x27;/Users/michael&#x27;,&#x27;testdir&#x27;) )# 然后创建一个目录:#print(os.mkdir(&#x27;/Users/michael/testdir&#x27;) )# 删掉一个目录:#print(os.rmdir(&#x27;/Users/michael/testdir&#x27;) ) 5 路径切割 12print(os.path.split(&#x27;/path/to/file.txt&#x27;) )print(os.path.splitext(&#x27;/path/to/file.txt&#x27;) ) 6 文件重命名和删除 12#print(os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;) )#print(os.remove(&#x27;test.py&#x27;)) 7 列举当前目录下所有目录和py文件 12print([x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x) ])print([x for x in os.listdir(&#x27;.&#x27;) if os.path.isfile(x) and os.path.splitext(x)[1] == &#x27;.py&#x27;]) python序列化1 序列化为二进制 123import pickled = dict(name=&#x27;Bob&#x27;, age=20, score=88)print(pickle.dumps(d)) 2 序列化写入文件 123f = open(&#x27;openfile3.txt&#x27;,&#x27;wb&#x27;)print(pickle.dump(d, f) )f.close() 3 反序列化读取文件 1234f = open(&#x27;openfile3.txt&#x27;,&#x27;rb&#x27;)d = pickle.load(f)f.close()print(d) 4 序列化为json 123456789101112131415161718import jsonclass Student(object): def __init__(self, name, age, score): self.name = name self.age = age self.score = scoredef convertFunc(std): return &#123;&#x27;name&#x27;:std.name, &#x27;age&#x27;:std.age, &#x27;score&#x27;:std.score&#125;s = Student(&#x27;Bob&#x27;, 20, 88)print(json.dumps(s,default=convertFunc))print(json.dumps(s,default=lambda obj:obj.__dict__)) 5 反序列化 123456def revert(std): return Student(std[&#x27;name&#x27;], std[&#x27;age&#x27;], std[&#x27;score&#x27;])json_str = &#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;print(json.loads(json_str, object_hook=revert ) )","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"红黑树的原理和实现","date":"2017-10-18T07:01:35.000Z","path":"2017/10/18/rbtree/","text":"红黑树是高效查找和插入删除的数据结构，用途很广泛，如epoll的消息注册机制，stl中的map都采用了红黑树。 红黑树的主要特性：（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 定理：一棵含有n个节点的红黑树的高度至多为2log(n+1)。 定义节点为TreeNode，TreeNode类内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TreeNode&#123;public: TreeNode():m_pParent(NULL), m_pLeftChild(NULL), m_pRightChild(NULL), m_nData(0), m_nColor(RED)&#123;&#125; TreeNode(const TreeNode &amp; tree)&#123; this-&gt;m_nData = tree.m_nData; this-&gt;m_pParent = NULL; this-&gt;m_pLeftChild = NULL; this-&gt;m_pRightChild = NULL; m_nColor = tree.m_nColor; &#125; TreeNode(int data):m_nData(data), m_pRightChild(NULL), m_pLeftChild(NULL), m_pParent(NULL),m_nColor(RED)&#123;&#125; ~TreeNode()&#123; this-&gt;m_nData = 0; this-&gt;m_pLeftChild = NULL; this-&gt;m_pParent = NULL; this-&gt;m_pRightChild = NULL; &#125; TreeNode&amp; operator =(const TreeNode&amp; treeNode)//赋值运算符 &#123; if (this != &amp;treeNode) &#123; this-&gt;m_pParent = treeNode.m_pParent; this-&gt;m_pLeftChild = treeNode.m_pLeftChild; this-&gt;m_pRightChild = treeNode.m_pRightChild; this-&gt;m_nData = treeNode.m_nData; this-&gt;m_nColor = treeNode.m_nColor; &#125; return *this; &#125; friend ostream &amp; operator&lt;&lt;(ostream &amp;out, TreeNode &amp;obj) &#123; out &lt;&lt; &quot; &quot; &lt;&lt; obj.m_nData &lt;&lt;&quot; &quot;; return out; &#125; TreeNode * m_pParent; TreeNode * m_pLeftChild; TreeNode * m_pRightChild; int m_nData; int m_nColor;&#125;; 树的左旋和右旋左旋：用C++实现左旋 1234567891011121314151617181920212223242526272829303132333435363738394041//节点X左旋void TreeClass::leftRotate(TreeNode * x)&#123; if(x-&gt;m_pRightChild == NULL) &#123; return; &#125; //取X的右孩子为y TreeNode * y = x-&gt;m_pRightChild; //判断y是否有左孩子 if(y-&gt;m_pLeftChild) &#123; x-&gt;m_pRightChild = y-&gt;m_pLeftChild; y-&gt;m_pLeftChild-&gt;m_pParent = x; &#125; //x的父节点赋值为y的父节点 y-&gt;m_pParent = x-&gt;m_pParent; if(x-&gt;m_pParent == NULL) &#123; //X为root节点，将y设置为root节点 m_pRoot = y; &#125; else if(x == x-&gt;m_pParent-&gt;m_pLeftChild) &#123; //X为其父节点的左孩子，将y设置为其父节点的左孩子 x-&gt;m_pParent-&gt;m_pLeftChild = y; &#125; else &#123; //X为其父节点的右孩子，将y设置为其父节点的右孩子 x-&gt;m_pParent-&gt;m_pRightChild = y; &#125; //将X设置为y的左孩子 y-&gt;m_pLeftChild = x; x-&gt;m_pParent = y;&#125; 如下图为左旋40节点右旋：用C++实现y节点右旋 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************** y x / \\ / \\ x m ===&gt; z y / \\ / \\ z h h m****************/void TreeClass::rightRotate(TreeNode * y)&#123; TreeNode * x = y-&gt;m_pLeftChild; if(x == NULL) &#123; return; &#125; if(x-&gt;m_pRightChild) &#123; // 将 “y” 设为 “x的右孩子的父亲” x-&gt;m_pRightChild-&gt;m_pParent = y; // 将 “x的右孩子” 设为 “y的左孩子” y-&gt;m_pLeftChild = x-&gt;m_pRightChild; &#125; else &#123; y-&gt;m_pLeftChild = NULL; &#125; x-&gt;m_pParent = y-&gt;m_pParent ; if(y-&gt;m_pParent == NULL) &#123; // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点 m_pRoot = x; &#125; else if(y == y-&gt;m_pParent-&gt;m_pRightChild) &#123; //如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子” y-&gt;m_pParent-&gt;m_pRightChild = x; &#125; else &#123; //(y是它父节点的左孩子) 将x设为“y的父节点的左孩子” y-&gt;m_pParent-&gt;m_pLeftChild = x; &#125; //y设置为x的右孩子 x-&gt;m_pRightChild = y; y-&gt;m_pParent = x; &#125; 右旋示意图 红黑树的插入红黑树的插入分三步：1.将红黑树当作一颗二叉查找树，将节点插入2.将插入的节点着色为&quot;红色&quot;3.通过一系列的旋转或着色等操作，使之重新成为一颗红黑树将节点插入后着色为红色可能会导致红黑树特性失效，有可能使特性(4)失效：如果一个节点是红色的，则它的子节点必须是黑色的。前面将结果二叉搜索树的插入，这里和之前类似，不再赘述，C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void TreeClass::rbInsertNode(TreeNode * z)&#123; //定义一个节点的指针 TreeNode * y = NULL; TreeNode * x = m_pRoot; //循环查找节点z插入的位置，指导找到叶子结点 while(x) &#123; y = x; if(z-&gt;m_nData &lt; x-&gt;m_nData) &#123; x = x-&gt;m_pLeftChild; &#125; else &#123; x = x-&gt;m_pRightChild; &#125; &#125; //循环结束时，x指向某个叶子结点，y指向x的父亲 //设置z的父节点为y z-&gt;m_pParent = y; //如果y为NULL，设置z为root节点 if(y == NULL) &#123; m_pRoot = z; &#125; else if(z-&gt;m_nData &lt; y-&gt;m_nData) &#123; y-&gt;m_pLeftChild = z; &#125; else &#123; y-&gt;m_pRightChild = z; &#125; // z的左孩子设为空 z-&gt;m_pLeftChild = NULL; // z的右孩子设为空 z-&gt;m_pRightChild = NULL; // 将z着色为“红色” z-&gt;m_nColor = RED; //通过rbInsertFixUp(z)对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树 rbInsertFixUp(z); &#125; 根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。① 情况说明：被插入的节点是根节点。 处理方法：直接把此节点涂为黑色。② 情况说明：被插入的节点的父节点是黑色。 处理方法：什么也不需要做。节点被插入后，仍然是红黑树。③ 情况说明：被插入的节点的父节点是红色。 处理方法：那么，该情况与红黑树的“特性(4)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。 case1 当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。处理策略(01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。 这么做的目的是保持黑色节点数量一致，并且将红色节点上移，直到其为根，将根节点设置为红色。如下图为case1： case2 当前节点的父节点是红色，当前节点的叔叔节点为黑色。分为四种情况。在case2中只讨论前两种，后面两种归类为case3case 2.1 当前节点父节点是其祖父节点的左孩子，当前节点是其父节点的右孩子，那么以当前节点的父节点为 支点进行左旋，如下图：case 2.1 当前节点父节点是其祖父节点的右孩子，当前节点是其父节点的左孩子，那么以当前节点的父节点为 支点进行右旋，如下图：综上所述：case2的两种情况就是将父节点和子节点通过旋转放置在一侧。 case3 当前节点的父节点是红色，当前节点的叔叔节点是黑色，和case2两种情况不同的是case3.1 当前节点父节点是其祖父节点的左孩子，当前节点是其父节点的左孩子，那么将父节点设置为黑色，祖父节点设置为红色， 以祖父节点为支点右旋，如下图：case3.2 当前节点父节点是其祖父节点的右孩子，且当前节点是其父节点的右孩子，那么将父节点设置为黑色，祖父节点设置为红色， 以祖父节点为支点进行左旋，同上例子，不再赘述，只是左右不同。将上述着色和旋转过程完善，封装为rbInsertFixUp()函数如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//重新着色和旋转void TreeClass::rbInsertFixUp(TreeNode * z)&#123; //z为root节点，那么只需要设置z颜色为黑色即可。 if(z-&gt;m_pParent == NULL) &#123; m_pRoot-&gt;m_nColor = BLACK; return ; &#125; //若当前节点z的父节点为红色，需要一直调色和旋转，直到z为黑色为止 while(z-&gt;m_pParent-&gt;m_nColor == RED) &#123; // 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。 if(z-&gt;m_pParent-&gt;m_pParent-&gt;m_pLeftChild == z-&gt;m_pParent) &#123; // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)” TreeNode * y = z-&gt;m_pParent-&gt;m_pParent-&gt;m_pRightChild; // Case 1条件：叔叔是红色 if(y-&gt;m_nColor == RED) &#123; // (01) 将“父节点”设为黑色 z-&gt;m_pParent-&gt;m_nColor = BLACK; // (02) 将“叔叔节点”设为黑色 y-&gt;m_nColor = BLACK; // (03)将“祖父节点”设为“红色” z-&gt;m_pParent-&gt;m_pParent-&gt;m_nColor = RED; // (04) 将“祖父节点”设为“当前节点”(红色节点) z = z-&gt;m_pParent-&gt;m_pParent; &#125;//if(y-&gt;m_nColor == RED) else &#123; // Case 2条件：叔叔是黑色，且当前节点是右孩子 if(z == z-&gt;m_pParent-&gt;m_pRightChild) &#123; // (01) 将“父节点”作为“新的当前节点” z = z-&gt;m_pParent; // (02) 以“新的当前节点”为支点进行左旋 leftRotate(z); &#125; // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。 z-&gt;m_pParent-&gt;m_nColor = BLACK; // (02) 将“祖父节点”设为“红色”。 z-&gt;m_pParent-&gt;m_pParent-&gt;m_nColor = RED; // (03) 以“祖父节点”为支点进行右旋。 rightRotate(z-&gt;m_pParent-&gt;m_pParent); &#125; &#125;//if(z-&gt;m_pParent-&gt;m_pParent-&gt;m_pLeftChild == z-&gt;m_pParent) else &#123; // 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。 TreeNode * y = z-&gt;m_pParent-&gt;m_pParent-&gt;m_pLeftChild; // Case 1条件：叔叔是红色 if(y-&gt;m_nColor == RED) &#123; // (01) 将“父节点”设为黑色 z-&gt;m_pParent-&gt;m_nColor = BLACK; // (02) 将“叔叔节点”设为黑色 y-&gt;m_nColor = BLACK; // (03)将“祖父节点”设为“红色” z-&gt;m_pParent-&gt;m_pParent-&gt;m_nColor = RED; // (04) 将“祖父节点”设为“当前节点”(红色节点) z = z-&gt;m_pParent-&gt;m_pParent; &#125;//if(y-&gt;m_nColor == RED) else &#123; // Case 2条件：叔叔是黑色，且当前节点是左孩子 if(z == z-&gt;m_pParent-&gt;m_pLeftChild) &#123; // (01) 将“父节点”作为“新的当前节点” z = z-&gt;m_pParent; // (02) 以“新的当前节点”为支点进行右旋 rightRotate(z); &#125; // Case 3条件：叔叔是黑色，且当前节点是右孩子。(01) 将“父节点”设为“黑色”。 z-&gt;m_pParent-&gt;m_nColor = BLACK; // (02) 将“祖父节点”设为“红色”。 z-&gt;m_pParent-&gt;m_pParent-&gt;m_nColor = RED; // (03) 以“祖父节点”为支点进行右旋。 leftRotate(z-&gt;m_pParent-&gt;m_pParent); &#125; &#125; &#125; //最后将root节点设置为黑色 m_pRoot-&gt;m_nColor = BLACK;&#125; 读者可以反复推敲上面代码，下面介绍红黑树的删除。红黑树的删除和普通的二叉搜索树一样，只是删除后多增加一些旋转和调节颜色的手段。先删除节点z，然后在旋转和着色。如果节点z仅有一个孩子或者没有孩子，直接删除，并用子节点替代它即可。如果z有两个孩子，那么找到后继节点，将z替换为后继节点的数值，并且删除后继节点，再对后继节点的孩子进行旋转和着色即可。下面是红黑树删除的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758TreeNode * TreeClass::rbDeleteNode(TreeNode * z)&#123; TreeNode * y = NULL; TreeNode * x = NULL; //z只有一个孩子或者没有孩子，那么删除z，将孩子连接到父节点即可 if(z-&gt;m_pLeftChild == NULL || z-&gt;m_pRightChild == NULL) &#123; y = z; &#125; else &#123; //z有两个孩子，那么将z的后继节点替换z的数值，删除后继节点即可。 y = findNextNode(z); &#125; //找到节点y的子树，节点y的子树为空或者只有一支，不存在双子树情况。 //因为如果z只有一个孩子或者没有孩子，那么y==z，如果z有两个孩子，那么y==z的后继节点， //z的后继节点一定只有一个孩子或者没有孩子。 if(y-&gt;m_pLeftChild) &#123; x = y-&gt;m_pLeftChild; &#125; else &#123; x = y-&gt;m_pRightChild; &#125; if(x) &#123; x-&gt;m_pParent = y-&gt;m_pParent; &#125; if(y-&gt;m_pParent == NULL) &#123; m_pRoot = x; &#125; else if(y == y-&gt;m_pParent-&gt;m_pLeftChild) &#123; y-&gt;m_pParent-&gt;m_pLeftChild = x; &#125; else &#123; y-&gt;m_pParent-&gt;m_pRightChild = x; &#125; if(y != z) &#123; // 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色 z-&gt;m_nData = y-&gt;m_nData; &#125; if(y-&gt;m_nColor == BLACK) &#123; rbDeleteFixUp(x); &#125; return y; &#125; 对于删除的旋转和颜色变换是有规律的，由于红黑树是由2-3树变化而来，所以想了解红黑树删除原理需要进一步了解2-3树即可。我只是根据算法导论和红黑树原理进行总结。对于节点X旋转和着色可以概括为3种情况。① 情况说明：x是红色节点。 处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。② 情况说明：x是黑节点，且x是根。 处理方法：什么都不做，结束。此时红黑树性质全部恢复。③ 情况说明：x是黑节点，且x不是根。红黑树的删除分如下四种情况：Case 1 x是黑节点，x的兄弟节点是红色Case 1.1 如果x是其父节点的左孩子， 将x的兄弟节点设为黑色，将x的父节点设为红色，对x的父节点进行左旋， 左旋后重新设置x的兄弟节点 Case 1.2 如果x是其父节点的右孩子， 将x的兄弟节点设为黑色，将x的父节点设为红色，对x的父节点进行右旋， 左旋后重新设置x的兄弟节点 如下图所示 Case 2 x是黑节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色,将x的兄弟节点设为红色, 设置x的父节点为新的x节点。处理结果如下图：Case 3 x是黑节点，x的兄弟节点是黑色；Case 3.1 x是其父节点的左孩子，X的兄弟节点的左孩子是红色，右孩子是黑色的,解决策略如下：(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。(04) 右旋后，重新设置x的兄弟节点。Case 3.2 x是其父节点的右孩子，x的兄弟节点的右孩子是红色，左孩子是黑色的,解决策略如下：(01) 将x兄弟节点的右孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行左旋。(04) 左旋后，重新设置x的兄弟节点。 Case 4 x是黑节点，x的兄弟节点是黑色； Case 4.1 x是其父节点的左孩子，x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色 (01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。Case 4.2 x是其父节点的右孩子，x的兄弟节点的左孩子是红色的，x的兄弟节点的右孩子任意颜色`(01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的左孩子设为“黑色”。(04) 对x的父节点进行右旋。(05) 设置“x”为“根节点”。用C++实现上述旋转和着色过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114void TreeClass::rbDeleteFixUp(TreeNode * x)&#123; while(x != m_pRoot &amp;&amp; x-&gt;m_nColor == BLACK) &#123; if(x-&gt;m_pParent-&gt;m_pLeftChild == x) &#123; TreeNode * w = x-&gt;m_pParent-&gt;m_pRightChild; // Case 1: x是黑节点，x的兄弟节点是红色。 if(w-&gt;m_nColor == RED) &#123; // (01) 将x的兄弟节点设为“黑色”。 w-&gt;m_nColor = BLACK; // (02) 将x的父节点设为“红色”。 x-&gt;m_pParent-&gt;m_nColor = RED; // (03) 对x的父节点进行左旋。 leftRotate(x-&gt;m_pParent); // (04) 左旋后，重新设置x的兄弟节点。 w = x-&gt;m_pParent-&gt;m_pRightChild; &#125; // Case 2: x是黑节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。 if(w-&gt;m_pLeftChild-&gt;m_nColor == BLACK &amp;&amp; w-&gt;m_pRightChild-&gt;m_nColor == BLACK) &#123; // (01) 将x的兄弟节点设为“红色” w-&gt;m_nColor = RED; // (02) 设置“x的父节点”为“新的x节点”。 x = x-&gt;m_pParent; &#125; else &#123; // Case 3: x是黑节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的 if(w-&gt;m_pRightChild-&gt;m_nColor == BLACK) &#123; // (01) 将x兄弟节点的左孩子设为“黑色” w-&gt;m_pLeftChild-&gt;m_nColor = BLACK; // (02) 将x兄弟节点设为“红色” w-&gt;m_nColor = RED; // (03) 对x的兄弟节点进行右旋 rightRotate(w); // (04) 右旋后，重新设置x的兄弟节点。 w = x-&gt;m_pParent-&gt;m_pRightChild; &#125; // Case 4: x是黑节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。 //(01) 将x父节点颜色 赋值给 x的兄弟节点。 w-&gt;m_nColor = x-&gt;m_pParent-&gt;m_nColor; // (02) 将x父节点设为“黑色” x-&gt;m_pParent-&gt;m_nColor = BLACK; // (03) 将x兄弟节点的右子节设为“黑色”。 x-&gt;m_pRightChild-&gt;m_nColor = BLACK; // (04) 对x的父节点进行左旋。 leftRotate(x-&gt;m_pParent); x = m_pRoot; &#125; &#125;//if(x-&gt;m_pParent-&gt;m_pLeftChild == x) else &#123; // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行 TreeNode * w = x-&gt;m_pParent-&gt;m_pLeftChild; // Case 1: x是黑节点，x的兄弟节点是红色。 if(w-&gt;m_nColor == RED) &#123; // (01) 将x的兄弟节点设为“黑色”。 w-&gt;m_nColor = BLACK; // (02) 将x的父节点设为“红色”。 x-&gt;m_pParent-&gt;m_nColor = RED; // (03) 对x的父节点进行右旋。 rightRotate(x-&gt;m_pParent); // (04) 右旋后，重新设置x的兄弟节点。 w = x-&gt;m_pParent-&gt;m_pLeftChild; &#125; // Case 2: x是黑节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。 if(w-&gt;m_pLeftChild-&gt;m_nColor == BLACK &amp;&amp; w-&gt;m_pRightChild-&gt;m_nColor == BLACK) &#123; // (01) 将x的兄弟节点设为“红色” w-&gt;m_nColor = RED; // (02) 设置“x的父节点”为“新的x节点”。 x = x-&gt;m_pParent; &#125; else &#123; // Case 3: x是黑节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是黑色，右孩子是红色的 if(w-&gt;m_pLeftChild-&gt;m_nColor == BLACK) &#123; // (01) 将x兄弟节点的右孩子设为“黑色” w-&gt;m_pRightChild-&gt;m_nColor = BLACK; // (02) 将x兄弟节点设为“红色” w-&gt;m_nColor = RED; // (03) 对x的兄弟节点进行左旋 leftRotate(w); // (04) 左旋后，重新设置x的兄弟节点。 w = x-&gt;m_pParent-&gt;m_pLeftChild; &#125; // Case 4: x是黑节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色的。 //(01) 将x父节点颜色 赋值给 x的兄弟节点。 w-&gt;m_nColor = x-&gt;m_pParent-&gt;m_nColor; // (02) 将x父节点设为“黑色” x-&gt;m_pParent-&gt;m_nColor = BLACK; // (03) 将x兄弟节点的左子节设为“黑色”。 x-&gt;m_pLeftChild-&gt;m_nColor = BLACK; // (04) 对x的父节点进行右旋。 rightRotate(x-&gt;m_pParent); x = m_pRoot; &#125; &#125; //else &#125; x-&gt;m_nColor = BLACK;&#125; 到此为止红黑树的实现和原理介绍完毕，读者熟悉后可以利用红黑树做一些排序和高效的数据处理。源码下载：https://github.com/secondtonone1/RBTree","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"二叉搜索树","date":"2017-10-09T02:01:43.000Z","path":"2017/10/09/searchtree/","text":"最近复习了二叉搜索树的基础知识，总结下，然后用C++实现二叉搜索树的插入，删除，查找等，也是为了实现红黑树做铺垫。一个二叉搜索树结构如下，父节点做子树都比父节点小，右子树都比父节点大。插入节点12后，如下 删除的情况，删除节点A，判断节点A是否为叶子节点，如果是叶子结点直接删除即可。如果叶子A有且仅有一个子节点B，那么用B替代节点A。如果节点A有两个子节点，找到前驱节点B，用前驱节点B(或者后继节点)替代节点A。有一种特殊的情况，就是前驱节点有左孩子，或者后继节点有右孩子，这种情况需要仔细考虑。仅拿前驱节点举例子，前驱节点的父节点为C，前驱节点的左孩子为D，那么将D的父节点间设置为C，C的子节点设置为D。如果前驱节点B有右孩子怎么办？B是不可能有右孩子的，否则他的右孩子就是节点A的前驱节点。因为对于一个双子树的节点，他的前驱节点必然为左子树最大节点。在这里再叙述一下如何查看一个节点的前驱节点和后继几点：前驱节点：1 如果节点A有左子树，那么他的前驱节点为左子树中最大的节点。2 如果节点A没有左子树，需要考察节点A的父节点，如果节点A是其父节点的右孩子，那么父节点为前驱节点，否则将父节点设置为当前节点A，继续向上查找，直到找到某个节点为其父节点的右孩子，这个父节点就是要找的前驱节点。后继节点：1 如果节点A有右子树，那么他的后继节点为其右子树的最小节点。2 如果节点A没有右子树，那么同样遍历其父节点，找到某个节点是其父节点的左孩子，那么这个父节点就是要找的后继节点。如图节点10的后继节点为12，为其右子树中最小的节点。节点10的前驱节点为6，为其左子树中最大的节点。节点12的前驱节点为10，因为节点12没有左子树，父节点为13,12不是13的右节点，需要继续向上查找，找到节点10,13是10的右节点，节点10为12的前驱节点。节点6的后继节点为10，同样是向父节点找，直到找到某个节点是其父节点的左子树，5是10的左子树，所以10为6的后继节点。节点5的前驱节点为NULL，因为节点5没有左子树，所以向上查找，直到找到根节点也不满足右节点的规则，所以节点5的前驱节点为NULL删除节点10，找到前驱节点6替换10，如果节点6有左子树，那么将左子树挂接到节点5的右节点。如下图：下面用代码实现上述插入，删除以及中序遍历的逻辑。先实现树的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class TreeNode&#123;public: TreeNode():m_pParent(NULL), m_pLeftChild(NULL), m_pRightChild(NULL), m_nData(0)&#123;&#125; TreeNode(const TreeNode &amp; tree)&#123; this-&gt;m_nData = tree.m_nData; this-&gt;m_pParent = NULL; this-&gt;m_pLeftChild = NULL; this-&gt;m_pRightChild = NULL; &#125; TreeNode(int data):m_nData(data), m_pRightChild(NULL), m_pLeftChild(NULL), m_pParent(NULL)&#123;&#125; ~TreeNode()&#123; this-&gt;m_nData = 0; this-&gt;m_pLeftChild = NULL; this-&gt;m_pParent = NULL; this-&gt;m_pRightChild = NULL; &#125; TreeNode&amp; operator =(const TreeNode&amp; treeNode)//赋值运算符 &#123; if (this != &amp;treeNode) &#123; this-&gt;m_pParent = treeNode.m_pParent; this-&gt;m_pLeftChild = treeNode.m_pLeftChild; this-&gt;m_pRightChild = treeNode.m_pRightChild; this-&gt;m_nData = treeNode.m_nData; &#125; return *this; &#125; friend ostream &amp; operator&lt;&lt;(ostream &amp;out, TreeNode &amp;obj) &#123; out &lt;&lt; &quot; &quot; &lt;&lt; obj.m_nData &lt;&lt;&quot; &quot;; return out; &#125; TreeNode * m_pParent; TreeNode * m_pLeftChild; TreeNode * m_pRightChild; int m_nData; &#125;; 实现树类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class TreeClass&#123;public: TreeClass():m_pRoot(NULL)&#123;&#125; ~TreeClass()&#123; if(!m_pRoot) &#123; return; &#125; //找到树的最小节点 TreeNode * treeNodeTemp = findMinNode(m_pRoot); vector&lt;TreeNode *&gt; treenodeVec; while(treeNodeTemp) &#123; treenodeVec.push_back(treeNodeTemp); treeNodeTemp = findNextNode(treeNodeTemp); &#125; for(int i = 0; i &lt; treenodeVec.size(); i++) &#123; delete(treenodeVec[i]); &#125; treenodeVec.clear(); m_pRoot = NULL; &#125; void initial( list&lt;int&gt;&amp; data); void visitTree(); //搜索前继节点 TreeNode *findPreNode(TreeNode * treeNode); //搜索后继节点 TreeNode * findNextNode(TreeNode * treeNode); //寻找一个子树最小节点 TreeNode * findMinNode(TreeNode * root); //寻找一个子树最大节点 TreeNode * findMaxNode(TreeNode * root); //删除一个节点 void deleteTreeNode(TreeNode* treeNode); //删除的节点没有子节点 void deleteNoChildNode(TreeNode * treeNode); //删除的节点有一个子节点 void deleteOneChildNode(TreeNode * treeNode, TreeNode * childNode); //删除节点有两个孩子,找到后继节点或者前驱节点替换即可，这里选择前驱节点 void deleteTwoChildNode(TreeNode * treeNode); //用前驱节点替换当前节点 void preupdateNode(TreeNode * preNode, TreeNode * treeNode); void eraseNode(int i); TreeNode * findTreeNode(int i); TreeNode * m_pRoot;&#125;; 有几个函数需要着重说明一下:初始化函数，通过列表初始化为一棵树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void TreeClass::initial( list&lt;int&gt;&amp; data)&#123; for( list&lt;int&gt;::iterator listIter = data.begin(); listIter != data.end(); listIter++) &#123; TreeNode * treeNode = m_pRoot; if(!treeNode) &#123; m_pRoot = new TreeNode(*listIter); continue; &#125; TreeNode * nodeParent = NULL; bool findflag = true; while(treeNode) &#123; if(treeNode-&gt;m_nData &lt; *listIter) &#123; nodeParent = treeNode; treeNode = treeNode-&gt;m_pRightChild; &#125; else if(treeNode-&gt;m_nData &gt; *listIter) &#123; nodeParent = treeNode; treeNode = treeNode-&gt;m_pLeftChild; &#125; else &#123; //找到树中有相等的节点，那么不插入，也可以完善为次数+1 findflag = false; break; &#125; &#125; if(findflag) &#123; if(nodeParent-&gt;m_nData &lt;*listIter ) &#123; TreeNode * treeNodeTemp =new TreeNode(*listIter); nodeParent-&gt;m_pRightChild = treeNodeTemp; treeNodeTemp-&gt;m_pParent = nodeParent; &#125; else &#123; TreeNode * treeNodeTemp =new TreeNode(*listIter); nodeParent-&gt;m_pLeftChild = treeNodeTemp; treeNodeTemp-&gt;m_pParent = nodeParent; &#125; &#125; &#125;&#125; 中序遍历： 12345678910111213141516171819//中序遍历void TreeClass::visitTree()&#123; if(!m_pRoot) &#123; cout &lt;&lt; &quot;empty tree!!!&quot;; &#125; //找到树的最小节点 TreeNode * treeNodeTemp = findMinNode(m_pRoot); while(treeNodeTemp) &#123; cout &lt;&lt; (*treeNodeTemp); treeNodeTemp = findNextNode(treeNodeTemp); &#125; &#125; 查找一个子树中最小节点 123456789101112131415//寻找一个子树最小节点TreeNode * TreeClass::findMinNode(TreeNode * root)&#123; if(!root) &#123; return NULL; &#125; TreeNode * treeNode = root; while(treeNode-&gt;m_pLeftChild) &#123; treeNode = treeNode-&gt;m_pLeftChild; &#125; return treeNode;&#125; 查找一个子树中最大节点 1234567891011121314TreeNode * TreeClass::findMaxNode(TreeNode * root)&#123; if(!root) &#123; return NULL; &#125; TreeNode * treeNode = root; while(treeNode-&gt;m_pRightChild) &#123; treeNode = treeNode-&gt;m_pRightChild; &#125; return treeNode;&#125; 查找一个节点前驱节点 12345678910111213141516171819202122232425//搜索前驱节点TreeNode* TreeClass::findPreNode(TreeNode * treeNode)&#123; //左子树不为空，找到左子树中最大节点 if( treeNode-&gt;m_pLeftChild ) &#123; TreeNode * treeNodeTemp = findMaxNode( treeNode-&gt;m_pLeftChild); return treeNodeTemp; &#125; //左子树为空 //找到父节点，如果该节点是父节点的右孩子，那么父节点为前驱节点。 //如果不满足，则将父节点设为该节点，继续向上找，知道满足条件或者父节点为空 TreeNode * treeNodeTemp = treeNode-&gt;m_pParent; while(treeNodeTemp &amp;&amp; treeNode != treeNodeTemp-&gt;m_pRightChild) &#123; treeNode = treeNodeTemp; treeNodeTemp = treeNodeTemp -&gt;m_pParent; &#125; return treeNodeTemp;&#125; 查找一个节点的后继节点 123456789101112131415161718192021222324252627//搜索后继节点TreeNode * TreeClass::findNextNode(TreeNode * treeNode)&#123; //右子树不为空，找到右子树中最小节点 if( treeNode-&gt;m_pRightChild ) &#123; TreeNode * treeNodeTemp = findMinNode( treeNode-&gt;m_pRightChild); return treeNodeTemp; &#125; //右子树为空 //找到父节点，如果该节点是父节点的左孩子，那么父节点为后继节点。 //如果不满足，则将父节点设为该节点，继续向上找，直到满足条件或者父节点为空 TreeNode * treeNodeTemp = treeNode-&gt;m_pParent; while(treeNodeTemp &amp;&amp; treeNode != treeNodeTemp-&gt;m_pLeftChild) &#123; treeNode = treeNodeTemp; treeNodeTemp = treeNodeTemp -&gt;m_pParent; &#125; return treeNodeTemp;&#125; 根据数据查找某个节点 123456789101112131415161718192021TreeNode * TreeClass::findTreeNode(int i)&#123; TreeNode *treeNode = m_pRoot; while(treeNode) &#123; if(treeNode-&gt;m_nData &gt; i) &#123; treeNode = treeNode-&gt;m_pLeftChild; &#125; else if(treeNode-&gt;m_nData &lt; i) &#123; treeNode = treeNode-&gt;m_pRightChild; &#125; else &#123; return treeNode; &#125; &#125; return treeNode;&#125; 某个节点有两棵子树，删除这个节点，函数如下： 123456789101112void TreeClass::deleteTwoChildNode(TreeNode * treeNode)&#123; //找到前驱节点 TreeNode* preNode = findPreNode(treeNode); preupdateNode(preNode, treeNode); delete(treeNode);&#125; 详细的实现细节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void TreeClass::preupdateNode(TreeNode * preNode, TreeNode * treeNode)&#123; preNode-&gt;m_pRightChild = treeNode-&gt;m_pRightChild; treeNode-&gt;m_pRightChild-&gt;m_pParent = preNode; //判断前驱节点是否为该节点的左孩子 if(treeNode-&gt;m_pLeftChild != preNode) &#123; TreeNode * prechild = NULL; if(preNode-&gt;m_pLeftChild) &#123; prechild = preNode-&gt;m_pLeftChild; &#125; preNode-&gt;m_pLeftChild = treeNode-&gt;m_pLeftChild; treeNode-&gt;m_pLeftChild-&gt;m_pParent = preNode; if(preNode-&gt;m_pParent-&gt;m_pLeftChild == preNode) &#123; preNode-&gt;m_pParent-&gt;m_pLeftChild =prechild; if(prechild) &#123; prechild-&gt;m_pParent = preNode-&gt;m_pParent; &#125; &#125; else &#123; preNode-&gt;m_pParent-&gt;m_pRightChild =prechild; if(prechild) &#123; prechild-&gt;m_pParent = preNode-&gt;m_pParent; &#125; &#125; &#125; if(treeNode-&gt;m_pParent == NULL) &#123; preNode-&gt;m_pParent = NULL; m_pRoot = preNode; return; &#125; //节点有父节点，需要将父节点和前驱节点绑定 preNode-&gt;m_pParent = treeNode-&gt;m_pParent; if(treeNode-&gt;m_pParent-&gt;m_pLeftChild == treeNode) &#123; treeNode-&gt;m_pParent-&gt;m_pLeftChild = preNode; &#125; else &#123; treeNode-&gt;m_pParent-&gt;m_pRightChild = preNode; &#125;&#125; 如果节点没有子树，那么直接删除，如果节点有一颗子树，那么用该子树替代这个节点即可。代码下载地址：https://github.com/secondtonone1/searchtree测试代码： 123456789101112131415161718192021222324252627282930313233343536373839int array[6]=&#123;7,4,2,5,3,8&#125;;list&lt;int&gt; mylist;mylist.insert(mylist.end() , array ,array+6);TreeClass treeClass;treeClass.initial(mylist);treeClass.visitTree();cout &lt;&lt; endl;treeClass.eraseNode(7);treeClass.visitTree();cout &lt;&lt; endl;treeClass.eraseNode(4);treeClass.visitTree();cout &lt;&lt; endl;int array2[5]=&#123;7,4,2,5,8&#125;;list&lt;int&gt; mylist2;mylist2.insert(mylist2.end() , array2 ,array2+5);TreeClass treeClass2;treeClass2.initial(mylist2);treeClass2.visitTree();cout &lt;&lt; endl;treeClass2.eraseNode(4);treeClass2.visitTree();cout &lt;&lt; endl;int array3[6]=&#123;7,4,2,6,5,8&#125;;list&lt;int&gt; mylist3;mylist3.insert(mylist3.end() , array3 ,array3+6);TreeClass treeClass3;treeClass3.initial(mylist3);treeClass3.visitTree();cout &lt;&lt; endl;treeClass3.eraseNode(7);treeClass3.visitTree();cout &lt;&lt; endl;getchar();return 0; 打印输出：","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"python学习(十一)异常处理和测试","date":"2017-09-20T08:35:11.000Z","path":"2017/09/20/python11/","text":"最近学习了python的错误处理和几种测试方法 try except可以通过try except方式捕捉异常 123456789try: print(&#x27;try...&#x27;) r = 10/0 print(&#x27;result is :&#x27;, r)except ZeroDiversionError as e: print(&#x27;except is :&#x27;, e)finally: print(&#x27;finally ...&#x27;)print(&#x27;END&#x27;) 可以捕捉不同类型的错误，编写多个except 1234567891011try: print(&#x27;try...&#x27;) r = 10/int(&#x27;a&#x27;) print(&#x27;result is: &#x27;, r)except ValueError as e: print(&#x27;ValueError : &#x27;, e)except ZeroDiversionError as e: print(&#x27;ZeroDivisionError is : &#x27;, e)finally: print(&#x27;finally ...&#x27;)print(&#x27;END&#x27;) try except同样支持else结构 12345678910111213try: print(&#x27;try... &#x27;) r = 10/int(&#x27;2&#x27;) print(&#x27;result is : &#x27;, r)except ValueError as e: print(&#x27;ValueError : &#x27;, e)except ZeroDivisionError as e: print(&#x27;ZeroDivisionError is : &#x27;, e)else: print(&#x27;no error&#x27;)finally: print(&#x27;finally ...&#x27;)print(&#x27;END&#x27;) 某个函数调用出现异常，在上层同样可以捕获到 12345678910111213def foo(s): return 10/int(s)def bar(s): return foo(s) * 2def main(): try: bar(&#x27;0&#x27;) except Exception as e: print(&#x27;Exception is : &#x27;, e) finally: print(&#x27;finally...&#x27;)main() loggingpython 提供打日志方式输出异常，并且不会因为出现异常导致程序中断 12345678910111213import loggingdef foo(s): return 10/int(s)def bar(s): return foo(s) * 2def main(): try: bar(&#x27;0&#x27;) except Exception as e: logging.exception(e)main()print(&#x27;END&#x27;) 如果想要将异常处理的更细致，可以自定义一个异常类，继承于几种错误类，如ValueError等，在可能出现问题的地方将错误抛出来 12345678class FooError(ValueError): passdef foo(s): n = int(s) if n == 0: raise FooError(&#x27;invalid error is : %s&#x27; %s) return 10/nfoo(&#x27;0&#x27;) 错误可以一层一层向上抛，直到有上层能处理这个错误为止 1234567891011121314def foo(s): n = int(s) if n==0: raise ValueError(&#x27;invalid error is: %s&#x27; %s) return 10/ndef bar(): try: foo(&#x27;0&#x27;) except ValueError as e: print(&#x27;ValueError&#x27;) raisebar() logging可以设置不同的级别,通过basicConfig可以设置 1234567891011import logging logging.basicConfig(level=logging.INFO)def foo(s): n = int(s) return 10/ndef main(): m = foo(&#x27;0&#x27;) logging.info(&#x27;n is : %d&#x27; %m)main() 断言assert大部分语言都支持assert，python也一样，在可能出错的地方写assert，会在异常出现时使程序终止 123456789def foo(s): n = int(s) assert n != 0 ,&#x27;n is zero&#x27; return 10/ndef main(): foo(&#x27;0&#x27;)main() pdb调试和set_tracepdb调试用 python -m pdb 文件名.py, 单步执行敲n,退出为qpython 可以在代码里设置断点，在程序自动执行到断点位置暂停,暂停在set_trace的代码行 12345678import pdbdef foo(s): n = int(s) pdb.set_trace() return 10/ndef main(): m = foo(&#x27;0&#x27;)main() 单元测试先实现一个自己定义的Dict类，将文件保存为mydict.py 12345678910class Dict(dict): def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except Exception as e: raise AttributeError(&#x27;AttributeError is :%s&#x27;, e) def __setattr__(self, key, value): self[key] = value python 提供了单元测试的类，开发者可以继承unittest.Test实现特定的测试类,下面实现Dict的单元测试类，保存为unittestdict.py 1234567891011121314151617181920212223242526272829303132333435363738import unittestfrom mydict import Dictclass TestDict(unittest.TestCase): def setUp(self): print(&#x27;setUp...&#x27;) def tearDown(self): print(&#x27;tear Down...&#x27;) def test_init(self): d = Dict(a=&#x27;testa&#x27;, b = 1) self.assertEqual(d.a, &#x27;testa&#x27;) self.assertEqual(d.b, 1) self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d[&#x27;name&#x27;] = &#x27;hmm&#x27; self.assertEqual(d.name, &#x27;hmm&#x27;) def test_attr(self): d = Dict() d.name = &#x27;hmm&#x27; self.assertEqual(d[&#x27;name&#x27;], &#x27;hmm&#x27;) self.assertTrue(&#x27;name&#x27; in d) def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty def test_keyerror(self): d = Dict() with self.assertRaises(AttributeError): value = d[&#x27;empty&#x27;] if __name__ == &#x27;__main__&#x27;: unittest.main() 运行unittest.py可以检测mydict中Dict类是否有错误 文档测试文档测试在代码中按照特定格式编写python输入和期待的输出，通过python提供的文档测试类，实现测试代码的目的 1234567891011121314151617181920212223242526272829class Dict(dict): &#x27;&#x27;&#x27; &gt;&gt;&gt; d1 = Dict() &gt;&gt;&gt; d1[&#x27;x&#x27;] = 100 &gt;&gt;&gt; d1.x 100 &gt;&gt;&gt; d1.y = 200 &gt;&gt;&gt; d1[&#x27;y&#x27;] 200 &gt;&gt;&gt; d2=Dict(a=1,b=2,c=&#x27;m&#x27;) &gt;&gt;&gt; d2.c &#x27;m&#x27; &#x27;&#x27;&#x27; def __init__(self, **kw): super(Dict,self).__init__(**kw) def __getattr__(self,key): try: return self[key] except KeyError: raise AttributeError(&#x27;AttributeError key is %s&#x27; %key) def __setattr__(self,key,value): self[key] = valueif __name__ == &#x27;__main__&#x27;: import doctest doctest.testmod()","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(十)元类学习和应用","date":"2017-09-07T07:33:37.000Z","path":"2017/09/07/python10/","text":"python 可以通过type函数创建类,也可通过type判断数据类型 12345678910111213141516import socketfrom io import StringIOimport sysclass TypeClass(object): def typeprint(self, name = &#x27;typeclass&#x27;): print(&#x27;class name is %s&#x27; %(name))typeclasses = TypeClass()print(type(TypeClass))print(type(typeclasses))def printHW(self): print(&#x27;Hello world!!!&#x27;)TypeClass2 = type(&#x27;TypeClass2&#x27;, (object,), dict(typeprinthw = printHW))typeclass2 = TypeClass2()typeclass2.typeprinthw() type创建类格式为type(‘类名’,(基类1,基类2…), dict(成员函数名=函数名))第一个参数为类名，第二个参数为一个tuple,如果继承的基类只有一个，要注意tuple写法(基类,),第三个参数为dict构造的类成员函数除了可以用type创建类之外，可以用metaclass限制类的行为 使用metaclass需要先定义一个特定功能的元类，这个元类一般按照功能名字命名，末尾以Metaclass结束，表示一个特定功能的元类,这个元类必须继承于type类,内部必须实现__new__借口完成类的限定。__new__的调用先于__init__，在对象构造之前调用。 1234567891011121314class DictMetaclass(type): def __new__(cls, name, bases, attrs): def insertfunc(self, key, value): self[key]=value attrs[&#x27;insert&#x27;] = insertfunc return type.__new__(cls,name,bases,attrs)class MyDict(dict, metaclass = DictMetaclass): passmydict = MyDict()mydict.insert(&#x27;nice&#x27;, 3)print(mydict[&#x27;nice&#x27;]) 定义了一个DictMetaclass元类，继承于type类，内部实现了__new__方法，__new__方法四个参数分别为准备创建的类对象，类名字，该类的基类集合，类的方法集合。并且__new__内部调用了type类的__new__函数，完成了新功能属性的绑定。下面同样实现一个list类的扩展 123456789101112class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&#x27;insert&#x27;] = lambda self, value: self.append(value) return type.__new__(cls,name,bases,attrs)class Mylist(list,metaclass = ListMetaclass): passmylist = Mylist()mylist.insert(&#x27;name&#x27;)mylist.insert(&#x27;age&#x27;)print(mylist) 下面为在廖雪峰官网学习的ORM框架例子ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。让我们来尝试编写一个ORM框架。先实现Field类和其派生类 1234567891011121314class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return &#x27;&lt;%s%s&gt;&#x27; %(self.__class__.__name__, self.name)class IntegerField(Field): def __init__(self, name): super(IntegerField,self).__init__(name, &#x27;bigint&#x27;)class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name,&#x27;varchar(100)&#x27;) Field类用来管理数据库的字段和字段类型实现ModelMetaclass这个元类，用于限制User类 123456789101112131415class ModelMetaclass(type): def __new__(cls,name,bases,attrs): if name == &#x27;Model&#x27;: return type.__new__(cls, name, bases, attrs) print(&#x27;Founc model: %s&#x27; % name) mappings = dict() for k, v in attrs.items(): if isinstance(v,Field): print(&#x27;Found mapping: %s ==&gt; %s&#x27; %(k,v)) mappings[k] = v for k in mappings.keys(): attrs.pop(k) attrs[&#x27;__mappings__&#x27;] = mappings attrs[&#x27;__table__&#x27;] = name return type.__new__(cls, name, bases, attrs) ModelMetaclass类中过滤了Model类的处理，将其他类的属性删除，将映射关系存储至__mappings__属性字段，并且__table__字段用来存储类名。下面实现Model类 12345678910111213141516171819202122class Model(dict , metaclass=ModelMetaclass): def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27; &quot; %key) def __setattr__(self, key, value): self[key]=value def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) params.append(&#x27;?&#x27;) args.append(getattr(self, k, None)) sql = &#x27;insert into %s (%s) values (%s)&#x27; % (self.__table__, &#x27;,&#x27;.join(fields), &#x27;,&#x27;.join(params)) print(&#x27;SQL: %s&#x27; % sql) print(&#x27;ARGS: %s&#x27; % str(args)) Model 类继承了dict, 实现save函数，save函数将__mappings__属性值内容取出来，就是在ModelMetaclass中构造的mappings,其他类继承Model，调用save函数可以动态调用sql语句。定义User类并且调用save 123456789class User(Model): # 定义类的属性到列的映射： id = IntegerField(&#x27;id&#x27;) name = StringField(&#x27;username&#x27;) email = StringField(&#x27;email&#x27;) password = StringField(&#x27;password&#x27;)u = User(id=12345, name=&#x27;Michael&#x27;, email=&#x27;test@orm.org&#x27;, password=&#x27;my-pwd&#x27;)u.save() 输出如下：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(九)网络编程学习--简易网站服务器","date":"2017-09-05T07:39:49.000Z","path":"2017/09/05/python9/","text":"python 网络编程和其他语言都是一样的，服务器这块步骤为：1. 创建套接字2. 绑定地址3. 监听该描述符的所有请求4. 有新的请求到了调用accept处理请求 Python Web服务器网关接口（Python Web Server Gateway Interface，简称“WSGI”），可以保证同一个服务器响应不同应用框架的请求，WSGI的出现，让开发者可以将网络框架与网络服务器的选择分隔开来，例如，你可以使用Gunicorn或Nginx/uWSGI或Waitress服务器来运行Django、Flask或Pyramid应用。下面简单实现一个机遇WSGI协议的服务器。 1234567891011121314151617181920212223242526272829import socketfrom io import StringIOimport sysclass WSGIServer(object): address_family = socket.AF_INET socket_type = socket.SOCK_STREAM request_queue_size = 1 def __init__(self, server_address): # Create a listening socket self.listen_socket = listen_socket = socket.socket( self.address_family, self.socket_type ) # Allow to reuse the same address listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Bind listen_socket.bind(server_address) # Activate listen_socket.listen(self.request_queue_size) # Get server host name and port host, port = self.listen_socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port # Return headers set by Web framework/Web application self.headers_set = [] 定义了一个WSGIServer类，并且在类的init函数完成了套接字的创建、绑定、监听等。下面实现WSGIServer的轮询检测新的连接并处理连接： 1234567891011def set_app(self, application): self.application = applicationdef serve_forever(self): listen_socket = self.listen_socket while True: # New client connection self.client_connection, client_address = listen_socket.accept() # Handle one request and close the client connection. Then # loop over to wait for another client connection self.handle_one_request() 实现处理请求的函数 12345678910111213141516171819def handle_one_request(self): self.request_data = request_data = self.client_connection.recv(1024) # Print formatted request data a la &#x27;curl -v&#x27; print(&#x27;&#x27;.join( &#x27;&lt; &#123;line&#125;\\n&#x27;.format(line=line) for line in request_data.splitlines() )) self.parse_request(request_data) # Construct environment dictionary using request data env = self.get_environ() # It&#x27;s time to call our application callable and get # back a result that will become HTTP response body result = self.application(env, self.start_response) # Construct a response and send it back to the client self.finish_response(result) 解析请求 12345678def parse_request(self, text): request_line = text.splitlines()[0] request_line = request_line.rstrip(&#x27;\\r\\n&#x27;) # Break down the request line into components (self.request_method, # GET self.path, # /hello self.request_version # HTTP/1.1 ) = request_line.split() 返回当前服务器wsgi版本等信息 1234567891011121314151617181920def get_environ(self): env = &#123;&#125; # The following code snippet does not follow PEP8 conventions # but it&#x27;s formatted the way it is for demonstration purposes # to emphasize the required variables and their values # # Required WSGI variables env[&#x27;wsgi.version&#x27;] = (1, 0) env[&#x27;wsgi.url_scheme&#x27;] = &#x27;http&#x27; env[&#x27;wsgi.input&#x27;] = StringIO.StringIO(self.request_data) env[&#x27;wsgi.errors&#x27;] = sys.stderr env[&#x27;wsgi.multithread&#x27;] = False env[&#x27;wsgi.multiprocess&#x27;] = False env[&#x27;wsgi.run_once&#x27;] = False # Required CGI variables env[&#x27;REQUEST_METHOD&#x27;] = self.request_method # GET env[&#x27;PATH_INFO&#x27;] = self.path # /hello env[&#x27;SERVER_NAME&#x27;] = self.server_name # localhost env[&#x27;SERVER_PORT&#x27;] = str(self.server_port) # 8888 return env 填写app所需的回调函数 1234567891011def start_response(self, status, response_headers, exc_info=None): # Add necessary server headers server_headers = [ (&#x27;Date&#x27;, &#x27;Tue, 31 Mar 2015 12:54:48 GMT&#x27;), (&#x27;Server&#x27;, &#x27;WSGIServer 0.2&#x27;), ] self.headers_set = [status, response_headers + server_headers] # To adhere to WSGI specification the start_response must return # a &#x27;write&#x27; callable. We simplicity&#x27;s sake we&#x27;ll ignore that detail # for now. # return self.finish_response 发送数据并且关闭连接 1234567891011121314151617def finish_response(self, result): try: status, response_headers = self.headers_set response = &#x27;HTTP/1.1 &#123;status&#125;\\r\\n&#x27;.format(status=status) for header in response_headers: response += &#x27;&#123;0&#125;: &#123;1&#125;\\r\\n&#x27;.format(*header) response += &#x27;\\r\\n&#x27; for data in result: response += data # Print formatted response data a la &#x27;curl -v&#x27; print(&#x27;&#x27;.join( &#x27;&gt; &#123;line&#125;\\n&#x27;.format(line=line) for line in response.splitlines() )) self.client_connection.sendall(response) finally: self.client_connection.close() 主函数和参数解析，创建服务器 12345678910111213141516171819SERVER_ADDRESS = (HOST, PORT) = &#x27;&#x27;, 8888def make_server(server_address, application): server = WSGIServer(server_address) server.set_app(application) return serverif __name__ == &#x27;__main__&#x27;: if len(sys.argv) &lt; 2: sys.exit(&#x27;Provide a WSGI application object as module:callable&#x27;) app_path = sys.argv[1] module, application = app_path.split(&#x27;:&#x27;) module = __import__(module) application = getattr(module, application) httpd = make_server(SERVER_ADDRESS, application) print(&#x27;WSGIServer: Serving HTTP on port &#123;port&#125; ...\\n&#x27;.format(port=PORT)) httpd.serve_forever() 将上面的文件保存为webserver.py下面搭建虚拟环境，并且安装Pyramid、Flask和Django等框架开发的网络应用。 12345678910$ [sudo] pip install virtualenv$ mkdir ~/envs$ virtualenv ~/envs/lsbaws/$ cd ~/envs/lsbaws/$ lsbin include lib$ source bin/activate(lsbaws) $ pip install pyramid(lsbaws) $ pip install flask(lsbaws) $ pip install django 编写pyramidapp.py，主要是调用pyramidapp接口生成app 1234567891011121314from pyramid.config import Configuratorfrom pyramid.response import Responsedef hello_world(request): return Response( &#x27;Hello world from Pyramid!\\n&#x27;, content_type=&#x27;text/plain&#x27;, )config = Configurator()config.add_route(&#x27;hello&#x27;, &#x27;/hello&#x27;)config.add_view(hello_world, route_name=&#x27;hello&#x27;)app = config.make_wsgi_app() 可以通过自己开发的网络服务器来启动上面的Pyramid应用。python webserver.py pyramidapp:app 同样可以创建Flask应用 12345678910111213from flask import Flaskfrom flask import Responseflask_app = Flask(&#x27;flaskapp&#x27;)@flask_app.route(&#x27;/hello&#x27;)def hello_world(): return Response( &#x27;Hello world from Flask!\\n&#x27;, mimetype=&#x27;text/plain&#x27; )app = flask_app.wsgi_app 上述代码的工作原理： 1 网络框架提供一个命名为application的可调用对象。2 服务器每次从HTTP客户端接收请求之后，调用application。它会向可调用对象传递一个名叫environ的字典作为参数，其中包含了WSGI/CGI的诸多变量，以及一个名为start_response的可调用对象。3 框架/应用生成HTTP状态码以及HTTP响应报头（HTTP response headers），然后将二者传递至start_response，等待服务器保存。此外，框架/应用还将返回响应的正文。 服务器将状态码、响应报头和响应正文组合成HTTP响应，并返回给客户端。 可以采用多进程的方式处理多个客户端请求,将上述代码稍作修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import errnoimport osimport signalimport socketSERVER_ADDRESS = (HOST, PORT) = &#x27;&#x27;, 8888REQUEST_QUEUE_SIZE = 1024def grim_reaper(signum, frame): while True: try: pid, status = os.waitpid( -1, # Wait for any child process os.WNOHANG # Do not block and return EWOULDBLOCK error ) except OSError: return if pid == 0: # no more zombies returndef handle_request(client_connection): request = client_connection.recv(1024) print(request.decode()) http_response = b&quot;&quot;&quot;\\HTTP/1.1 200 OKHello, World!&quot;&quot;&quot; client_connection.sendall(http_response)def serve_forever(): listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listen_socket.bind(SERVER_ADDRESS) listen_socket.listen(REQUEST_QUEUE_SIZE) print(&#x27;Serving HTTP on port &#123;port&#125; ...&#x27;.format(port=PORT)) signal.signal(signal.SIGCHLD, grim_reaper) while True: try: client_connection, client_address = listen_socket.accept() except IOError as e: code, msg = e.args # restart &#x27;accept&#x27; if it was interrupted if code == errno.EINTR: continue else: raise pid = os.fork() if pid == 0: # child listen_socket.close() # close child copy handle_request(client_connection) client_connection.close() os._exit(0) else: # parent client_connection.close() # close parent copy and loop overif __name__ == &#x27;__main__&#x27;: serve_forever() grim_reaper 函数为捕捉子进程退出的回调函数，父进程等待所有子进程退出后再退出，避免僵尸进程。由于子进程退出父进程捕获到消息，调用grim_reaper处理，由于父进程之前阻塞在accept上，捕获子进程销毁消息后，父进程accept失败，所以增加了errno.EINTR错误判断，如果是由于信号中断导致accept失败，就让父进程继续调用accept即可。 谢谢关注我的微信公众平台：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习(八)定制类和枚举","date":"2017-08-31T07:39:49.000Z","path":"2017/08/31/python8/","text":"定制类python定制类主要是实现特定功能，通过在类中定义特定的函数完成特定的功能。 123456class Student(object): def __init__(self, name): self.name =namestudent = Student(&quot;lilei&quot;)print(student) __str__用法12345678class Student(object): def __init__(self, name): self.name = name def __str__(self): return (&quot;self name is %s&quot; %(self.name))student2 = Student(&quot;hanmeimei&quot;)print(student2) 实现__str__函数，可以在print类对象时打印指定信息 通过实现__iter__和__next__同样可以使类对象产生可迭代序列，下面实现了斐波那契数列 12345678910class Fib(object): def __init__(self): self.a , self.b = 0,1 def __iter__(self): return self def __next__(self): self.a, self.b = self.b, self.a+ self.b if self.a &gt; 30: raise StopIteration() return self.a __iter__返回一个可迭代对象，这里我们返回了Fib自己的对象。__next__是根据迭代器返回每一个迭代的序列，这里实现了运算规则，返回对象的a成员。打印输出 12for n in Fib(): print(n) __getitem__用法可以实现__getitem__函数,这样就可以按照索引访问类对象中迭代元素了。 12345678910111213141516class OddNum(object): def __init__(self): self.num = -1 def __iter__(self): return self def __next__(self): self.num = self.num +2 if self.num &gt; 10: raise StopIteration() return self.num def __getitem__(self,n): temp = 1 for i in range(n): temp += 2 return temp 12345for n in OddNum(): print(n)oddnum = OddNum()print(oddnum[3]) 可以进一步完善OddNum类的__getitem__函数，使其支持切片处理 123456789101112131415161718def __getitem__(self, n): if isinstance(n ,int): temp =1 for i in range(n): temp +=2 return temp if isinstance(n, slice): start = n.start end = n.stop if start is None: start = 0 tempList = [] temp = 1 for i in range(end): if i &gt;= start: temp += 2 tempList.append(temp) return tempList 可通过如下方式调用print(oddnum[1:4]) __getattr__用法通过实现__getattr__函数，可以在类对象中没有某个属性时，自动调用__getattr__函数实现__call__函数，可以实现类对象的函数式调用 12345678910111213141516171819def __getattr__(self,attr): if attr == &#x27;name&#x27;: return &#x27;OddNum&#x27; if attr == &#x27;data&#x27;: return lambda:self.num raise AttributeError(&#x27;\\&#x27;OddNum\\&#x27; object has no attribute \\&#x27;%s\\&#x27;&#x27; %attr)def __call__(self): return &quot;My name is OddNum!!&quot;``` 只有在没有找到属性的情况下，才调用`__getattr__`，已有的属性不会在`__getattr__`中查找。``` pythonprint(oddnum.name)print(oddnum.data)#没有func函数会抛出异常#print(oddnum.func)#可以直接通过oddnum()函数式调用print(oddnum()) 定制类案例下面是一个链式转化例子，用到了这些特定函数 1234567891011class Chain(object): def __init__(self, path=&#x27;&#x27;): self.path = path def __getattr__(self,attr): return Chain(&#x27;%s/%s&#x27;%(self.path, attr)) def users(self, users): return Chain(&#x27;%s/users/%s&#x27; %(self.path, users)) def __str__(self): return self.path __repr__ = __str__print(Chain().users(&#x27;michael&#x27;).repos) __repr__表示一个对象的字符串显示，当我们打印这个对象时，如果没有实现__str__函数，则会调用__repr__函数。另外，当我们打印datetime对象时，可以看到__repr__相比__str__目标更具有准确性，__str__目标在于可读性。另外，在迭代器迭代打印的时候默认调用的是对象的__repr__函数。所以在我们实现了__str__方法后，基本也会将其赋值给__repr__函数。具体的参考连接https://www.cnblogs.com/miaoning/p/11399575.html因为我们定义了__getattr__函数，所以当属性不存在时就会构造一个新的对象返回，返回的对象拼接了之前的path信息和attr属性。我们定义了users函数，这样可以调用users函数了。但是我们可以用更简洁的办法实现各种函数的调用而不用定义他们，就是通过实现__call__函数，这样就可以实现链式调用。 123456789101112class Chain(object): def __init__(self, path=&#x27;&#x27;): self.path = path def __getattr__(self,attr): return Chain(&#x27;%s/%s&#x27;%(self.path, attr)) def __call__(self, param): return Chain(&#x27;%s/%s&#x27;%(self.path, param)) def __str__(self): return self.path __repr__ = __str__print(Chain().get.users(&#x27;michael&#x27;).group(&#x27;doctor&#x27;).repos) 当调用users(‘michael’)时，因为没有定义users函数，所以会调用__getattr__函数，进而构造一个新的Chain对象。因为实现了__call__函数，所以这个对象可以被当作函数来使用，也就是Chain(‘michael’)的方式。 enum枚举python同样支持枚举操作 123456789101112131415161718from enum import EnumMonth = Enum(&#x27;Month&#x27;, (&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;) )for name, member in Month.__members__.items(): print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value)from enum import unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6for name , member in Weekday.__members__.items(): print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value)","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"使用hexo搭建个人博客","date":"2017-08-24T02:46:54.000Z","path":"2017/08/24/hexoblogs/","text":"本文讲述如何用hexo搭建个人博客，并托管到github。不需要租赁服务器，可完成网站博客的搭建。 安装Hexo安装hexo之前，要先下载安装Node.js和Git，百度搜索找到下载即可。Git下载地址Node.js下载地址在本地建立一个文件夹，我的文件夹为D:github/hexotest。接下来可以进入这个文件夹右键Git Bash 或者通过命令号cmd进入这个文件夹输入如下命令： 12345678npm install hexo-cli -g #初始化网站 hexo init npm install#生成或 hexo generate hexo g#启动本地服务器 hexo s 效果如下所示： 通过http://localhost:4000 查看效果如果无法显示，那么可能是端口被占用hexo server -p 6666指定端口启动，可看到网页了默认主题为landscape，比较简陋，可以自己下载喜欢的主题，将下载的主题放到themes文件夹下，并且修改_config.yml可以实现主题的替换。重启: 12hexo ghexo s 可以看到效果 创建文章和页面创建文章 1hexo new &quot;文章名&quot; 创建页面 1hexo new page &quot;页面名&quot; 命令常用简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 目前就可以写一写文章，并且启动hexo生成和运行，本地博客搭建完成了。下面将github和本地的hexo部署联合起来，实现远程的访问和托管。 github建立博客仓库和配置在Github首页右上角点击 New repositor创建一个仓库. 注意仓库名字要为:你的用户名.github.io 开启github pages服务仓库创建完后可以点击settings设置开启pages服务设置pages点击选择主题 choose themes目前博客github仓库的创建和配置完成，如果以后购买了域名，可以将github pages 地址绑定为购买的域名即可。 将hexo 和github 关联起来还是编辑根目录下_config.yml文件 12345678deploy: type: git repo: git@github.com:secondtonone1/secondtonone1.github.io.git #这里的网址填你自己的 branch: master``` 保存后需要提前安装一个扩展：``` cmdnpm install hexo-deployer-git --save 安装该扩展主要是为了支持hexo d 命令。 接下来就是将Hexo部署到我们的Github仓库上:命令行输入 hexo d 会自动将当前的博文生成html并且发布到github进行托管，在浏览器输入 secondtonone1.github.io (secondtonone1用户名替换为你自己的)即可浏览自己的博客了。这样就完成了github和hexo的关联部署。值得改进的地方是，每次调用hexo d 上传到github，都会提示输入github的用户名和密码，非常不方便可以通过SSH keys的设置，达到不输入密码直接发布的目的。 SSH keys的配置在Git 命令行输入如下命令： 1$ ssh-keygen -t rsa -C &quot;secondtonone1@163.com&quot; &#115;&#x65;&#x63;&#x6f;&#x6e;&#100;&#116;&#x6f;&#110;&#x6f;&#x6e;&#101;&#x31;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109; 替换为你的github邮件地址Git显示： 123$ ssh-keygen -t rsa -C &quot;secondtonone1@163.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车&gt; 系统会要求你输入密码，这里设置的密码主要是在你提交Git时弹出密码认证，不想输入直接回车 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 配置ssh和github仓库找到id_rsa.pub 并复制文件内容id_rsa.pub文件一般位于电脑用户配置文件夹下的一个.ssh文件下C:Users你的用户名.ssh登录Github并添加密钥进入github首页在右上角选择settings设置。 测试通过git bash链接到Git链接Git 1$ ssh -T git@github.com 提示如下： 1234567yesThe authenticity of host &#x27;github.com (207.65.227.44)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:42:18:60:1d:7b:13:d2:b5:c4:20:7e:56:86:d8:71:f3Are you sure you want to continue connecting (yes/no)?以下为成功链接到GitHi XXXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 以后每次提交博文到github就不需要输入密码了，很方便。配置好后清除之前的记录，重新生成并提交，可以登录自己的github仓库地址(&#x73;&#101;&#99;&#111;&#x6e;&#100;&#116;&#x6f;&#x6e;&#x6f;&#x6e;&#x65;&#x31;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#109;)查看博文了 123hexo cleanhexo ghexo d 配置域名和github的关联我在阿里云购买的域名，进入控制台，在域名管理添加如下两条记录151.101.73.147为我的github地址，可以通过如下命令获取：ping secondtonone1.github.io名字换为你自己的github仓库 登录github，选择博客仓库，点击settings选项，浏览到pages这部分，将Custom domain填写为你的域名 这样会在博客仓库中生成CNAME文件，文件中记录的是我的域名。这样，在浏览器输入我的域名www.limerence2017.com就可以浏览我的博客了。这么做还有个地方要完善，就是每次执行hexo d 命令后， CNAME文件被rush掉了。需要在博客目录下的sources文件夹下建立一个CNAME文件，写上自己的域名，这样每次提交CNAME文件就会生成在github中，避免了上述问题。 让你的博文添加图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件 3 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 通过branch实现博客的备份和发布可以通过github 的branch进行数据备份，master 用来发布。 为你的hexo添加css插件和一些扩充插件123$ npm install hexo-renderer-sass --save $ npm install hexo-generator-json-content --save $ npm install hexo-generator-feed --save 其他的一些扩充功能，比如留言板，访客记录，赞赏之类的自己去扩充和学习吧。 我的博客地址为：www.limerence2017.com 刚刚建立不到一个月，写了一些文章，以后可以修改和完善。 我的公众号，谢谢关注：","categories":[{"name":"资源共享","slug":"share","permalink":"http://www.limerence2017.com/categories/share/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.limerence2017.com/tags/hexo/"}]},{"title":"python学习笔记(七) 类和pygame实现打飞机游戏","date":"2017-08-22T03:33:08.000Z","path":"2017/08/22/python7/","text":"python中类声明如下： 123456class Student(object): def __init__(self, name, score): self.name = name self.score = score def printinfo(self): print(&#x27;name is %s, score is %d&#x27;%(self.name, self.score)) Student类有两个成员变量，name和score，类的成员函数第一个参数都为self，用来实现成员变量的赋值，__init__是类的初始化函数，初始化成员变量。 类的使用： 123456789s1 = Student(&#x27;niuniu&#x27;,78)print(s1.name)print(s1.score)s1.printinfo()s2 = Student(&#x27;gg&#x27;,100)s2.printinfo()s2.age = 100print(&#x27;s2 age is %s&#x27;%(s2.age)) 定义s2对象，并且通过s2.age=100，定义了s2的成员变量age，并且初始化为100 类的成员变量有两种方式定义，一个是在__init__函数中，一个是通过类的对象初始化。 类的权限设置： 1234567891011class Student2(object): def __init__(self, name, score): self.__name = name self.__score = score def getname(self): return self.__name def getscore(self): return self.__score def printinfo(self): print(&#x27;name is %s, score is %d&#x27; %(self.__name, self.__score)) __name通过在变量名前边加上__表示该变量为私有变量，python没有严格的权限限制，只不过通过重命名将__name变为其他的名字了，这样在外部就访问不到这个变量了。 通过添加getname和getscore函数获取成员变量。 123456789s3 = Student2(&#x27;s3&#x27;,99)s3.printinfo()name = s3.getname()print(name)s3.__name = &#x27;iloveu&#x27;print(s3.__name)name = s3.getname()print(name)s3.printinfo() 虽然通过s3.__name = ‘iloveu’赋值后，并没有改变类的私有变量__name的数值，因为类的私有变量__name的名称被改为其他的名字，用户无法知道。所以打印出的名字和s3.__name数值不同。 python类同样支持继承 1234567891011121314151617181920212223class Peaple(object): def __init__(self, name): self.__name = name def job(self): passclass Worker(Peaple): def job(self): print(&quot;worker&quot;)class Student(Peaple): def job(self): print(&quot;student&quot;)s1 = Student(&#x27;student&#x27;)s1.jobw1 = Worker(&#x27;worker&#x27;)w1.jobp = Peaple(&quot;abc&quot;)w = Worker(&quot;abc&quot;)s = Student(&quot;abc&quot;) 可以通过isinstance判断类对象是否是一个类型的实例 12345print(isinstance(p, Peaple))print(isinstance(w,Peaple))print(isinstance(s,Peaple))print(isinstance(s,Worker))print(isinstance(p,Student)) 子类对象是基类类型的实例，而基类对象不一定是子类类型的实例。比如Student继承于Peaple，学生是人，但是人不一定是学生。 类的属性控制： 12345678class Designer(Worker): def __init__(self,name,age): self.__name = name self.age = age def job(self): print(&quot;Designer&quot;)designer = Designer(&#x27;David&#x27;,18) 获取属性，设置属性，判断是否含有某个属性 12345678910111213#判断类中是否有某个实例print(hasattr(designer, &#x27;age&#x27;) )print(hasattr(designer,&#x27;job&#x27;))print(hasattr(designer,&#x27;name&#x27;))#设置sex属性，属性值为&#x27;female&#x27;setattr(designer, &#x27;sex&#x27;, &#x27;female&#x27;)print(designer.sex)#获取job属性，返回值为job函数对象fn = getattr(designer, &#x27;job&#x27;)#调用fn函数fn() 类的公有属性，为所有对象共有，类似于C++的static成员变量 123456789101112131415161718192021#通过self变量或者实例自身可以实现实例属性绑定#在类中直接定义一个变量，这个属性归类所有，类似于C++的static变量。class Temple(object): staticmember = 1000temp1 = Temple()#temp1没有自身属性成员staticmember，#而Temple类含有共享属性#下面这种方式打印的是类的共有属性print(temp1.staticmember)#为实例temp1绑定其自身的成员staticmember#并且设置数值为2048temp1.staticmember = 2048#打印实例temp1的成员staticmemberprint(temp1.staticmember)#打印类的共享成员print(Temple.staticmember)#删除实例的属性staticmemberdel temp1.staticmember#打印出类共享的属性print(temp1.staticmember) 可以为类绑定成员函数，也可以只为类的一个实例绑定成员函数 1234567891011121314151617181920212223def setage(self, age): self.__age = agedef getage(self): return self.__age###给实例绑定方法temp1.setage = MethodType(setage, temp1)temp1.getage = MethodType(getage,temp1)temp1.setage(125)print(temp1.getage())def setname(self, name): self.__name = namedef getname(self): return self.__name#给类绑定方法Temple.setname= setnameTemple.getname = getnametemp2 = Temple()temp2.setname(&#x27;name&#x27;)print(temp2.getname()) 可以通过@property的方式，通过属性访问的方式就可以调用函数 12345678910111213141516171819202122class Definetion(object): def __init__(self, member): self.__member = member @property def member(self): print(&quot;call getter&quot;) return self.__member @member.setter def member(self, member): print(&quot;call setter&quot;) if not isinstance(member,int): raise TypeError(&quot;member must be int type&quot;) self.__member = member @member.deleter def member(self): print(&quot;call deleter&quot;) raise AttributeError(&quot;Cann&#x27;t delete member&quot;)definetioner = Definetion(3)print(definetioner.member)definetioner.member = 1024print(definetioner.member) 将member分别实现为返回属性__member，设置__member，以及删除__member的函数。在每个member上添加对应格式的@property，@member.setter， @member.deleter。 通过属性访问的方式就可以调用对应的函数， definetioner.member返回__member值, definetioner__member = 1024调用设置__member的函数。deleter definetioner.member调用的是删除函数。 实战：用pygame库做一个打飞机的小游戏pygame是python的一个做游戏的库，安装方法自行百度。 实现子弹类 123456789101112131415# 设置游戏屏幕大小SCREEN_WIDTH = 480SCREEN_HEIGHT = 800# 子弹类class Bullet(pygame.sprite.Sprite): def __init__(self, bullet_img, init_pos): pygame.sprite.Sprite.__init__(self) self.image = bullet_img self.rect = self.image.get_rect() self.rect.midbottom = init_pos self.speed = 10 def move(self): self.rect.top -= self.speed 写玩家的飞机类 12345678910111213# 玩家飞机类class Player(pygame.sprite.Sprite): def __init__(self, plane_img, player_rect, init_pos): pygame.sprite.Sprite.__init__(self) self.image = [] # 用来存储玩家飞机图片的列表 for i in range(len(player_rect)): self.image.append(plane_img.subsurface(player_rect[i]).convert_alpha()) self.rect = player_rect[0] # 初始化图片所在的矩形 self.rect.topleft = init_pos # 初始化矩形的左上角坐标 self.speed = 8 # 初始化玩家飞机速度，这里是一个确定的值 self.bullets = pygame.sprite.Group() # 玩家飞机所发射的子弹的集合 self.img_index = 0 # 玩家飞机图片索引 self.is_hit = False # 玩家是否被击中 实现飞机类的几个功能函数 1234567891011121314151617181920212223242526272829303132# 发射子弹 def shoot(self, bullet_img): bullet = Bullet(bullet_img, self.rect.midtop) self.bullets.add(bullet) # 向上移动，需要判断边界 def moveUp(self): if self.rect.top &lt;= 0: self.rect.top = 0 else: self.rect.top -= self.speed # 向下移动，需要判断边界 def moveDown(self): if self.rect.top &gt;= SCREEN_HEIGHT - self.rect.height: self.rect.top = SCREEN_HEIGHT - self.rect.height else: self.rect.top += self.speed # 向左移动，需要判断边界 def moveLeft(self): if self.rect.left &lt;= 0: self.rect.left = 0 else: self.rect.left -= self.speed # 向右移动，需要判断边界 def moveRight(self): if self.rect.left &gt;= SCREEN_WIDTH - self.rect.width: self.rect.left = SCREEN_WIDTH - self.rect.width else: self.rect.left += self.speed 实现敌方飞机类 1234567891011121314# 敌机类class Enemy(pygame.sprite.Sprite): def __init__(self, enemy_img, enemy_down_imgs, init_pos): pygame.sprite.Sprite.__init__(self) self.image = enemy_img self.rect = self.image.get_rect() self.rect.topleft = init_pos self.down_imgs = enemy_down_imgs self.speed = 2 self.down_index = 0 # 敌机移动，边界判断及删除在游戏主循环里处理 def move(self): self.rect.top += self.speed 实现游戏主逻辑 123456789101112131415161718# 初始化 pygamepygame.init()# 设置游戏界面大小、背景图片及标题# 游戏界面像素大小screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))# 游戏界面标题pygame.display.set_caption(&#x27;飞机大战&#x27;)# 背景图background = pygame.image.load(&#x27;resources/image/background.png&#x27;).convert()# Game Over 的背景图game_over = pygame.image.load(&#x27;resources/image/gameover.png&#x27;)# 飞机及子弹图片集合plane_img = pygame.image.load(&#x27;resources/image/shoot.png&#x27;) 由于资源采用大图的方式，敌机和飞机，子弹都绘制在一站图片上，需要裁剪，pygame提供裁剪函数 1234567891011121314151617181920212223# 设置玩家飞机不同状态的图片列表，多张图片展示为动画效果player_rect = []player_rect.append(pygame.Rect(0, 99, 102, 126)) # 玩家飞机图片player_rect.append(pygame.Rect(165, 360, 102, 126))player_rect.append(pygame.Rect(165, 234, 102, 126)) # 玩家爆炸图片player_rect.append(pygame.Rect(330, 624, 102, 126))player_rect.append(pygame.Rect(330, 498, 102, 126))player_rect.append(pygame.Rect(432, 624, 102, 126))player_pos = [200, 600]player = Player(plane_img, player_rect, player_pos)# 子弹图片bullet_rect = pygame.Rect(1004, 987, 9, 21)bullet_img = plane_img.subsurface(bullet_rect)# 敌机不同状态的图片列表，多张图片展示为动画效果enemy1_rect = pygame.Rect(534, 612, 57, 43)enemy1_img = plane_img.subsurface(enemy1_rect)enemy1_down_imgs = []enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(267, 347, 57, 43)))enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(873, 697, 57, 43)))enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(267, 296, 57, 43)))enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(930, 697, 57, 43))) 管理敌机和敌机被击中的等对象 123456789101112131415161718192021#存储敌机，管理多个对象enemies1 = pygame.sprite.Group()# 存储被击毁的飞机，用来渲染击毁动画enemies_down = pygame.sprite.Group()# 初始化射击及敌机移动频率shoot_frequency = 0enemy_frequency = 0# 玩家飞机被击中后的效果处理player_down_index = 16# 初始化分数score = 0# 游戏循环帧率设置clock = pygame.time.Clock()# 判断游戏循环退出的参数running = True 通过循环控制游戏逻辑，不断生成敌机和子弹，刷新场景等。 给大家个建议，也是忠告，pygame实现的游戏循环体中一定要捕捉事件消息，不然会因为死循环而一直卡顿，甚至崩溃。先实现循环体中事件捕捉 1234567891011121314151617181920212223242526# 游戏主循环while running: # 控制游戏最大帧率为 60 clock.tick(60)# 更新屏幕 pygame.display.update() # 处理游戏退出 for event in pygame.event.get(): if event.type == pygame.QUIT: pygame.quit() exit() # 获取键盘事件（上下左右按键） key_pressed = pygame.key.get_pressed() # 处理键盘事件（移动飞机的位置） if key_pressed[K_w] or key_pressed[K_UP]: player.moveUp() if key_pressed[K_s] or key_pressed[K_DOWN]: player.moveDown() if key_pressed[K_a] or key_pressed[K_LEFT]: player.moveLeft() if key_pressed[K_d] or key_pressed[K_RIGHT]: player.moveRight() 在while running循环中添加子弹和敌机生成逻辑 1234567891011121314151617# 生成子弹，需要控制发射频率 # 首先判断玩家飞机没有被击中 if not player.is_hit: if shoot_frequency % 15 == 0: player.shoot(bullet_img) shoot_frequency += 1 if shoot_frequency &gt;= 15: shoot_frequency = 0 # 生成敌机，需要控制生成频率 if enemy_frequency % 50 == 0: enemy1_pos = [random.randint(0, SCREEN_WIDTH - enemy1_rect.width), 0] enemy1 = Enemy(enemy1_img, enemy1_down_imgs, enemy1_pos) enemies1.add(enemy1) enemy_frequency += 1 if enemy_frequency &gt;= 100: enemy_frequency = 0 在while running循环中子弹和敌机移动逻辑 12345678910111213141516171819202122232425for bullet in player.bullets: # 以固定速度移动子弹 bullet.move() # 移动出屏幕后删除子弹 if bullet.rect.bottom &lt; 0: player.bullets.remove(bullet) for enemy in enemies1: #2. 移动敌机 enemy.move() #3. 敌机与玩家飞机碰撞效果处理 if pygame.sprite.collide_circle(enemy, player): enemies_down.add(enemy) enemies1.remove(enemy) player.is_hit = True break #4. 移动出屏幕后删除飞机 if enemy.rect.top &lt; 0: enemies1.remove(enemy) #敌机被子弹击中效果处理 # 将被击中的敌机对象添加到击毁敌机 Group 中，用来渲染击毁动画 enemies1_down = pygame.sprite.groupcollide(enemies1, player.bullets, 1, 1) for enemy_down in enemies1_down: enemies_down.add(enemy_down) 在while running循环中添加自己飞机动态逻辑 123456789101112131415161718192021222324# 绘制玩家飞机 if not player.is_hit: screen.blit(player.image[player.img_index], player.rect) # 更换图片索引使飞机有动画效果 player.img_index = shoot_frequency // 8 else: # 玩家飞机被击中后的效果处理 player.img_index = player_down_index // 8 screen.blit(player.image[player.img_index], player.rect) player_down_index += 1 if player_down_index &gt; 47: # 击中效果处理完成后游戏结束 running = False # 敌机被子弹击中效果显示 for enemy_down in enemies_down: if enemy_down.down_index == 0: pass if enemy_down.down_index &gt; 7: enemies_down.remove(enemy_down) score += 1000 continue screen.blit(enemy_down.down_imgs[enemy_down.down_index // 2], enemy_down.rect) enemy_down.down_index += 1 效果显示：源码下载地址：打飞机小游戏python 谢谢关注我的公众号：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习笔记(六) 函数式编程","date":"2017-08-22T02:45:54.000Z","path":"2017/08/22/python6/","text":"一 函数对象函数同样可以作为对象复制给一个变量，如下： 123456789f = abs;print(f(-10))f = &#x27;abs&#x27;;print(f)def add(a,b,f): return f(a) + f(b)print(add(-1,2,f)) map 函数，map函数接受一个函数变量，第二个参数为一个可迭代对象，最后返回一个迭代器，由于迭代器的惰性，需要用list()函数返回所有元素。 12345def squart(n): return n* n;print(map(squart,range(1,11) ) )print(list(map(squart,range(1,11) ) )) reduce函数， reduce函数接受两个参数，第一个参数同样是函数对象f，f必须接受两个参数，并且返回和参数同类型的数据。第二个参数为一个可迭代序列。 12345678def func(a, b): return a + bprint(reduce(func, range(1,11))) reduce和map函数不一样，reduce返回的是一个最终值reduce(f,[x1, x2, x3, x4]) = f(f(f(x1,x2),x3),x4) 可以通过reduce和map函数搭配，将一个字符串转化为整数 12345678def str2int(str): def char2int(c): return &#123;&#x27;0&#x27;:0,&#x27;1&#x27;:1,&#x27;2&#x27;:2,&#x27;3&#x27;:3,&#x27;4&#x27;:4,&#x27;5&#x27;:5,&#x27;6&#x27;:6,&#x27;7&#x27;:7,&#x27;8&#x27;:8,&#x27;9&#x27;:9&#125; def convertnum(a,b): return a*10 + b return reduce(convertnum, map(char2int, str))print(str2int(&quot;123456789&quot;)) filter 函数，filter函数同样有两个参数，第一个参数为函数对象，返回值为bool类型，第二个参数为可迭代序列，返回值为迭代器， 同样需要list()转化为序列。下面用filter和生成器实现一个素数生成器函数 12345678910111213141516171819# 构造奇数序列的生成器def odd_generater(): n = 1 while True: n = n+2 yield ndef primer_generater(): yield 2 #返回生成器地址 it = odd_generater() print(&quot;it is &quot;, it) while(True): #依次取出生成器的元素 n = next(it) print(&quot;it2 is &quot;, it) yield n #去掉可以被自己整除的元素返回新的生成器 it = filter(lambda x:x%n &gt; 0, it) 打印测试： 12345for i in primer_generater(): if(i &lt; 100): print (i) else: break sorted 函数，第一个接受一个list，第二个为比较的规则，可以不写 12345print(sorted([&quot;Abert&quot;,&quot;cn&quot;,&quot;broom&quot;,&quot;Dog&quot;]) )print(sorted([&quot;Abert&quot;,&quot;cn&quot;,&quot;broom&quot;,&quot;Dog&quot;], key = str.lower))print(sorted([&quot;Abert&quot;,&quot;cn&quot;,&quot;broom&quot;,&quot;Dog&quot;], key = str.lower, reverse = True)) 二 函数封装和返回12345678910def lazy_sum(*arg): def sum(): x = 0 for i in arg: x = x +i return x return sumf = lazy_sum(2,3,1,6,8)print(f()) 定义了一个lazy_sum函数，函数返回内部定义的sum函数。可以在函数A内部定义函数B，调用A返回函数B，从而达到函数B延时调用。 闭包： 在函数A内部定义函数B，函数B内使用了函数A定义的局部变量或参数，这种情况就是闭包。 使用闭包需要注意，在函数B中修改了函数A 定义的局部变量，那么需要使用nonlocal关键字。如果在函数B中修改了全局变量，那么需要使用global关键字。 1234567891011121314def lazy_sum(*arg): sums = 0 def sum(): for i in arg: nonlocal sums sums = sums + i return sums return sumf1 = lazy_sum(1,3,5,7,9)f2 = lazy_sum(1,3,5,7,9)print(f1 == f2)print(f1() )print(f2() ) 匿名函数：lambda， lambda后面跟函数的参数，然后用：隔开，写运算规则作为返回值 1234567it = map(lambda x:x*x, (1,3,5,7,9))print(list(it))def lazy_squart(): return lambda x:x*xf = lazy_squart()print(f(3) ) 装饰器： 装饰器实际就是函数A中定义了函数B，并且返回函数B，为了实现特殊功能，如写日志，计算时间等等。 先看个返回函数，并且调用的例子 123456789101112def decoratorfunc(func): def wrapperfunc(): print(&#x27;func name is: %s&#x27;%(func.__name__)) func() return wrapperfuncdef helloworld(): print(&#x27;Helloworld !!!&#x27;)helloworld = decoratorfunc(helloworld)helloworld() 以后每次调用helloword，不仅会打印Helloworld，还会打印函数名字。 python提供装饰器的功能，可以简化上面代码，并且实现每次调用helloworld函数都会打印函数名字。 1234567891011121314def decoratorfunc(func): def wrapperfunc(*args, **kw): time1 = time.time() func(*args, **kw) time2 = time.time() print(&#x27;cost %d secondes&#x27;%(time2-time1)) return wrapperfunc@decoratorfuncdef output(str): print(str) time.sleep(2)output(&#x27;hello world!!!&#x27;) 如果函数带参数，实现装饰器可以内部定义万能参数的函数 1234567891011121314def decoratorfunc(func): def wrapperfunc(*args, **kw): time1 = time.time() func(*args, **kw) time2 = time.time() print(&#x27;cost %d secondes&#x27;%(time2-time1)) return wrapperfunc@decoratorfuncdef output(str): print(str) time.sleep(2)output(&#x27;hello world!!!&#x27;) 装饰器执行@decoratorfunc相当于 output = decoratorfunc(output)output(‘hello world!!!’) 如果装饰器需要传入参数，那么可以增加多一层的函数定义，完成装饰器参数传入和调用。 1234567891011121314def decoratorfunc(param): def decoratorfunc(func): def wrapperfunc(*arg, **kw): print(&#x27;%s %s&#x27; %(param, func.__name__)) func(*arg, **kw) return wrapperfunc return decoratorfunc@decoratorfunc(&#x27;execute&#x27;)def output(str): print(str)output(&#x27;nice to meet u&#x27;)print(output.__name__) #实际执行过程 1234decorator = decoratorfunc(&#x27;execute&#x27;)output = decorator(now)output(&#x27;nice to meet u&#x27;) 执行print(output.name)发现打印出的函数名字不是output而是wrapperfunc，这对以后的代码会有影响。 可以通过python提供的装饰器@functools.wraps(func) 完成函数名称的绑定 1234567891011121314def decoratorfunc(param): def decoratorfunc(func): @functools.wraps(func) def wrapperfunc(*arg, **kw): print(&#x27;%s %s&#x27; %(param, func.__name__)) func(*arg, **kw) return wrapperfunc return decoratorfunc@decoratorfunc(&#x27;execute&#x27;)def output(str): print(str)print(output.__name__) print(output.name)显示为output，这符合我们需要的逻辑。 三 偏函数如函数 int(a, base = 2) 可以实现一个字符串根据base提供的进制，转化成对应进制的数字。 可以通过偏函数，实现指定参数的固定，并且生成新的函数 12intnew = functools.partial(int, base = 2)print(intnew(&#x27;100&#x27;)) 也可以自己定义函数： 123456789def add(a,b): return a+bprint(add(3,7))addnew = functools.partial(add, 3)print(addnew(7))addnew2 = functools.partial(add, b = 7)print(addnew2(3)) 函数部分介绍到此为止，我的公众号，谢谢关注：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习笔记(五) 200行实现2048小游戏","date":"2017-08-21T03:31:28.000Z","path":"2017/08/21/python5/","text":"用前文提到的基础知识，和网上流行的2048源码，用python实现该游戏。 先将用户操作和游戏逻辑绑定。 WASD分别对应移动方向上、左、下、右 然后实现矩阵的转置和逆置，这样只要实现一个方向的移动，通过转置和逆置就可以得到其他方向的移动。 基本的函数声明完成了，下面定义GameField类，主要实现游戏逻辑和状态转换。 GameField类和其中包含的一些函数。先看构造函数。构造棋盘并且刷新棋盘，作为初次游戏的布局spawn函数为随机某个位置设置随机值。移动函数，这个函数比较复杂，代码也比较多。move函数内部先定义了左移的函数move_row_left，move_row_left内部定义了tighten和merge函数。 tighten函数作用是先将一行中非0的元素移动到左边排列，剩余的0元素放在右边，可以理解为压缩。 如[0,2,2,4]经过tighten调用后就变为[2,2,4,0]。merge函数的功能是将相邻的相等的元素进行合并， 比如[2,2,8,0]经过merge后变为[0,4,8,0]，[0,4,8,0]经过再次tighten调用后变为[4,8,0,0] 所以move_row_left内部实现的就是先对一个队列tighten，然后merge再次tighten达到左侧都是非0，右侧都是0。 move函数最后定义了一个dict，dict的key为方向，value为二维list。这个二维list是通过lambda表达式调用 左移函数以及矩阵逆置和转置等操作生成的。 举例说明右移：通过右移要达到的效果是[2,2,4,4]=&gt;[0,0,4,8]，为达到该目的，通过逆置矩阵，左移，再次逆置矩阵即可。先逆转矩阵[2,2,4,4]=&gt;[4,4,2,2]再执行左移函数[4,4,2,2]=&gt;[8,4,0,0]再执行矩阵逆置[8,4,0,0]=&gt;[0,0,4,8]达到最初效果上移和下移都是类似。 move函数最后通过判断传入direction是否符合标准，如果符合再次判断元素是否可以移动，如果可以移动则取出dict中方向key对应 的value，即二维list，从而得出移动后的棋盘界面。如果所有元素都不能移动，那么判断失败。 判断某个方向是否有元素可以移动，定义了如下函数。同样是先判断是否可以左移，其他方向能否移动可以通过左移操作和矩阵的转置，逆置判断。 row_is_left_movable是判断是否可以左移操作的函数，内部定义了change函数， change函数的功能为判断有左右相邻元素可以合并，或者该行有含有0的元素，则返回true，表示该行可以左移。 反之为不可左移，返回false。any函数判断该行所有元素，如果都没有可移动的元素，返回false。 同样是通过check这个dict，结合逆转和转置判断其他方向是否可以移动。如果某个方向所有行都不能移动， 表示矩阵中所有元素不能按照该方向移动了。 下面是判断输赢的函数。到此为止GameField类介绍完了，下面是main函数。定义了几个状态，通过状态机的方式运行游戏。 curses.wrapper模块。这个函数做了一些初始化的工作，包括上面提到的和颜色的初始化。 然后再执行main函数，最后重置。 源码下载地址： python打飞机游戏 运行上述代码效果如下：我的公众号，谢谢关注","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习笔记(四) 思考和准备","date":"2017-08-21T02:46:53.000Z","path":"2017/08/21/python4/","text":"一、zip的坑zip()函数接收多个可迭代数列，将数列中的元素重新组合，在3.0中返回迭代器指向 数列首地址，在3.0以下版本返回List类型的列表数列。我用的是3.5版本python， 所以zip返回的是指向地址。 先看几个例子 结果：可见，在3.0以上版本，对zip函数返回的结果采用list函数可以转化为列表。 通过列表生成式同样可以将zip结果化为列表。结果： 当zip操作的对象为一个列表，那么生成的列表中每个元素(元祖)中为(n,)形式。当zip操作的多个列表长度不一样，那么zip返回生成的列表中元素个数为最短列表长度。 list函数可以将一个元祖转化为列表。下面可以将zip返回的数据转化为我们方便操作的列表元素.结果：这样将zip函数返回的数据通过list和迭代，生成了二维List，方便以后操作。下边这段代码在3.0版本以上和3.0版本以下会有不同结果。 2.7版本结果3.0版本结果 之前提起过zip在3.0以上版本返回迭代器指向内存地址。3.0以下版本返回的为列表，所以在3.0版本一下输出是符合最初目的。 但是3.0版本python最后一行输出却为空列表[]。这个原因主要是迭代器在被循环迭代或者访问后，会自动移动指针，指向下一个要迭代的元素。这和C++是不同的， C++/C语言需要用户自己控制迭代器移位。那么肯定有人会说第一句和第三句打印的list1的值相同，是不是list1迭代器指向的空间没有移动呢？ 不是的，只要list1被循环迭代，内部指向空间的地址就会变化，只是调用print打印list1时，python只返回迭代器指向空间的首地址，而不会告诉具体指向的地址空间。 修改下代码，看看是不是上文所述那样：结果： 可见，输出list1指向地址内容的时候出现StopIteration异常，这个异常前几篇介绍过，是因为迭代器已经指向空间的末尾了，再调用就会出现该异常，所以对于迭代器当遍历迭 代后一定要注意迭代器指向地址变化的问题。 二、迭代器的坑迭代器的问题就在于被迭代使用后，内部指向的地址空间变化了，但是打印迭代器，返回的是迭代器最初指向的内存空间首地址。结果：每次打印g返回结果都一样，但是g指向的位置确实变了。说实话，这种隐藏性的问题应该让别人知道。 三、矩阵的转置和左右逆置通过zip函数可以实现矩阵的转置和逆置，将矩阵按照每一行存储在一个list中，这些list再组合成一个大的list，构成二维list表示矩阵。 矩阵的转置： 下边的例子可以看效果：结果： 同样的道理，矩阵的左右逆置 结果： 四、format函数介绍format函数通过{}替代%，实现字符串的动态匹配。 结果： 五、defaultdict函数介绍实现一个统计字符串个数的功能。 1strings = (&#x27;puppy&#x27;, &#x27;kitten&#x27;, &#x27;puppy&#x27;, &#x27;puppy&#x27;,&#x27;weasel&#x27;, &#x27;puppy&#x27;, &#x27;kitten&#x27;, &#x27;puppy&#x27;) 如果用下边的代码实现统计功能当counts中不存在某个单词，第一次调用counts[kw]+=1会提示报错。所以有几种方式实现该功能。这种方式先判断counts中是否含有关键字，没有就先赋值。这种方式通过设置counts中关键字对应的默认值，当counts中不存在某个关键字， 那么该关键字对应的value为0，然后该值+1，表示第一次统计。 如果counts中存在该关键字，那么就不执行setdefault函数，关键字对应的value值加1。 这种方式引用了collections的defaultdict，difaultdict接收一个函数，该函数 返回dict中元素的默认值。 六、any函数介绍any函数接收一个可迭代对象，一般为list或者tuple，list或者tuple中有一个 元素满足条件any函数就返回true，当所有元素都不满足条件，any返回false 结果：这是后一篇制作2048游戏的准备，下一篇制作2048小游戏 谢谢关注我的公众号","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python学习笔记(三)高级特性","date":"2017-08-17T08:15:12.000Z","path":"2017/08/17/python3/","text":"一、切片list、tuple常常截取某一段元素，截取某一段元素的操作很常用 ，所以python提供了切片功能。 123456789101112131415L=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;]#取索引0，到索引3的元素，不包括索引3print(L[0:3])#开始索引为0可以省略print(L[:3])#下标1到3print(L[1:3])#取最后一个元素print(L[-1])#取倒数后两个元素print(L[-2:])#取前四个数，每两个取一个print(L[:4:2])#所有数，每两个取一个print(L[::2]) 二、迭代除了list、tuple可以迭代外，python中的dict类型变量也可以迭代。 12345678910dictor = &#123;&#x27;name&#x27;:&#x27;Jul&#x27;,&#x27;age&#x27;:17,&#x27;femail&#x27;:1&#125;#迭代keyfor key in dictor: print(key) #迭代valuefor value in dictor.values(): print(value)#迭代key,valuefor k,v in dictor.items(): print(k,v) 可以将list变为索引元素对的形式 1234567891011121314for x,y in [(1,2),(3,4),(5,6)]: print(x,y)#变为索引元素对for i,value in enumerate([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]): print(i,value) 同时可以判断一个对象是否可以迭代for x,y in [(1,2),(3,4),(5,6)]: print(x,y)#变为索引元素对for i,value in enumerate([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]): print(i,value) 三、列表生成式list函数可以将一组对象组合为列表，[]操作也可以。[]操作的方式称作列表生成式 print([x for x in range(1,11)])print(list(range(1,11)))在列表生成式中可以加入一些运算规则，使生成的列表具备运算规则。 12345678910111213#变为索引元素对for i,value in enumerate([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]): print(i,value)#平方print([x*x for x in range(1,11)])#偶数平方print([x*x for x in range(1,11) if x%2 ])#k:v形式的列表strdic=&#123;&#x27;a&#x27;:&#x27;a1&#x27;,&#x27;b&#x27;:&#x27;b1&#x27;,&#x27;c&#x27;:&#x27;c1&#x27;&#125;print([k+&#x27;:&#x27;+v for k,v in strdic.items()])#将列表中字符串换为小写L = [&#x27;Hello&#x27;, &#x27;World&#x27;, 18, &#x27;Apple&#x27;, None]print([s.lower() for s in L if(isinstance(s,str)) ]) 四、生成器python提供生成器的功能，生成器根据函数或运算规则产生一系列数据， 通过对返回值g调用next(g)可以依次取出生成的数据。 123g = (x*2 for x in range(1,11))print(g)print(next(g)) 可以一直调用next(g)，直到产生StopIteration异常。 当然也可以通过函数构造生成器，将函数return的关键字换为yield即可。 12345678#菲波那切数列def fib(max): a,b,n = 0,1,0 while n &lt; max: yield b a,b=b,a+b n = n+ 1 return &quot;exit&quot; 通过下面方式next取出数列中的元素，第三次调用会抛出StopIteration异常。 12345g=fib(2)print(g)print(next(g))print(next(g))#print(next(g)) 上面代码中g为迭代器，通过对g不断调用next取出数列中元素。 可以通过检测异常的方式完成遍历，避免程序崩溃。 123456789g2 = fib(6)while True: try: value = next(g2) print(&quot;value: &quot;, value) except StopIteration as e: print(&quot;Generator return value is: &quot;, e) break 可以用生成器实现杨辉三角，生成器函数为triangles()。 生成器函数triangles()实现如下： 123456789101112131415def triangles(): yield [1] yield [1,1] lists = [1,1] while True: i = 1 n = len(lists) newlists = [1] while i &lt; n: newlists.append(lists[i-1] + lists[i]) i = i+1 newlists.append(1) lists = newlists yield newlists 五、迭代器python提供生成器的功能，生成器根据函数或运算规则产生一系列数据， 通过对返回值g调用next(g)可以依次取出生成的数据。g就是迭代器。 有的对象可以迭代但是不是迭代器，只有可以被next调用的对象才是迭代器。 同样可以通过isinstance函数判断迭代器。 12345678910111213141516171819202122232425from collections.abc import Iterablefrom collections.abc import Iteratorb1 = isinstance([], Iterable)b2 = isinstance([], Iterator)print(&#x27;[] is Iteralbe&#x27;, b1)print(&#x27;[] is Iterator&#x27;, b2)b1 = isinstance(&#123;&#125;,Iterable)b2 = isinstance(&#123;&#125;,Iterator)print(&#x27;[] is Iteralbe&#x27;, b1)print(&#x27;[] is Iterator&#x27;, b2)b1 = isinstance((x*x for x in range(10)), Iterable)b2 = isinstance((x*x for x in range(10)), Iterator)print(&#x27;x*x for x in range(10) isIterable&#x27;, b1)print(&#x27;x*x for x in range(10) isIterator&#x27;, b2)#可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iteratorb1 = isinstance(triangles(),Iterable)b2 = isinstance(triangles(),Iterator)print(&#x27;triangles()&#x27;, b1)print(&#x27;triangles()&#x27;, b2)","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python自学笔记(二)","date":"2017-08-17T07:07:01.000Z","path":"2017/08/17/python2/","text":"通过前文介绍，大体上可以用学过的知识做一些东西了。 这里简单介绍下python参数解析argparse命令。 使用argparse需要引用 import argparse 然后调用 parser = argparse.ArgumentParser() ArgumentParser()函数可以传一些参数 parser = argparse.ArgumentParser(description=&#39;This is a PyMOTW sample program&#39;) 参数有很多种类型，读者自己查阅，参考资料的链接： https://blog.ixxoo.me/argparse.html 接下来添加参数 parser.add_argument(&#39;file&#39;) parser.add_argument(&#39;-o&#39;, &#39;--output&#39;) 添加参数 -表示可选参数,用于一个字符，表示缩写 --也是可选参数，用于两个或以上的字符 最后是参数解析 parser.parse_args([&#39;-o&#39;, &#39;output.txt&#39;]) parse_args()运行时，会用&#39;-&#39;来认证可选参数，剩下的即为位置参数。 位置参数不可缺少，可选参数可提供默认值 如果python程序运行，parse_args()会依次处理传入参数，第一个参数为该python程序的文件名，其余的依次为传入参数。 这些文字看不懂不要紧，试着看看下边的程序和运行结果 12345678910111213141516171819202122232425#-*-coding:utf-8-*-import argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument(&#x27;file&#x27;) #输入文件parser.add_argument(&#x27;-o&#x27;, &#x27;--output&#x27;) #输出文件parser.add_argument(&#x27;--width&#x27;, type = int, default = 50) #输出字符画宽parser.add_argument(&#x27;--height&#x27;, type = int, default = 30) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputprint(&quot;IMG is %s&quot; %(IMG))print(&quot;WIDTH is %d&quot; %(WIDTH))print(&quot;HEIGHT is %d&quot; %(HEIGHT))print(&quot;OUTPUT is %s&quot; %(OUTPUT)) 这个程序就是解析命令行参数，然后将输入的参数打印出来 如果不输入参数直接python test.py 试试？提示缺少位置参数file 试试python test.py test.png四个命令行参数打印出来了 –height 可选参数为默认值30 –width 可选参数为默认值50 file 位置参数为test.png -o 为–output的缩写为None，因为没提供默认值。我也没输入-o参数 所以为None 输入python test.py test.png –width 30 – height 50 -o output.txt用全称–output录入也可以 python test.py test.png –width 30 – height 50 –output output.txt这个过了就可以往下做了，下面安装PIL库，PIL为python处理图形图像的基本库 windows安装的方式为： http://jingyan.baidu.com/article/ff42efa929e6c8c19f220254.html Linux安装方式为： 安装方式 下面编写图片转字符画程序： 将文件命名为print.py 1 包含库和函数，定义基本的字符序列 1234567891011121314151617181920from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument(&#x27;file&#x27;) #输入文件parser.add_argument(&#x27;-o&#x27;, &#x27;--output&#x27;) #输出文件parser.add_argument(&#x27;--width&#x27;, type = int, default = 50) #输出字符画宽parser.add_argument(&#x27;--height&#x27;, type = int, default = 30) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^`&#x27;. &quot;) 2 编写转换函数 123456789# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return &#x27; &#x27; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] 0.2126 * r + 0.7152 * g + 0.0722 * b为官方提供的 灰度计算公式，unit表示一个单元占多少灰度， gray/unit可以找到对应的单元，从而转换为字符。 3 调用get_char完成转换 123456789101112131415161718192021if __name__ == &#x27;__main__&#x27;: im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = &quot;&quot; for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &#x27;\\n&#x27; print (txt) #字符画输出到文件 if OUTPUT: with open(OUTPUT,&#x27;w&#x27;) as f: f.write(txt) else: with open(&quot;output.txt&quot;,&#x27;w&#x27;) as f: f.write(txt) Image为PIL提供的类，可以看看 Image基本功能 im.getpixel((j,i)) 通过传入横纵坐标，返回tuple tuple中数据依次为r,g,b,alpha 之前讲过可以通过*() 或*[]实现逐个元素传入。 get_char(*im.getpixel((j,i)))将参数传入返回字符。 之后分别将字符打印出来，并写入文件。源码下载地址： python图片转字符画 效果如下：","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"python自学笔记(一)","date":"2017-08-16T08:09:08.000Z","path":"2017/08/16/python1/","text":"我没学过python，通过网上和一些图书资料，自学并且记下笔记。 很多细节留作以后自己做项目时再研究，这样能更高效一些。 python基础自学笔记 一、基本输入和输出pthon3.0用input提示用户输入，用print提示用户输出，格式为print(“…”) 如果格式化输出，那么格式为print(&quot;%d&quot; %(变量名)), %d可以替换为%s等其他格式符，以后用到什么格式自己查，这样学起来高效。 简单的例子： 12345#-*-coding:utf-8-*-name = input(&quot;What&#x27;s your name ? &gt;&quot;)age = input(&quot;How old are you ? &gt;&quot;)print (&quot;your name is %s, your age is %d&quot; %(name, int(age)))print (&quot;你的名字是 %s, 你的年龄是 %d&quot; %(name,int(age))) 运行结果： 二、基本数据结构1 列表 列表和C++里边的list差不多,插入方式为: list.insert(1,‘小草’); 1为要插入元素放在下标为1的位置，‘小草’为要插入的元素,移除元素的方式为：list.pop(3); 指定取出下标为3的元素 list中元素是按照从下标为0开始计算的。如果要计算列表中元素个数可以通过len(list)计算。 下面是个小例子： 1234567891011121314151617181920animals = [&quot;大象&quot;,&quot;猴子&quot;,&quot;蚂蚁&quot;,&quot;豪猪&quot;]print (&quot;动物园有这些动物:&quot;, animals)lion = &quot;狮子&quot;print (&quot;新来了&quot;, lion)animals.insert(1,lion)print (&quot;动物园有这些动物:&quot;, animals)animals.pop(3)print (&quot;蚂蚁灭绝了&quot;)print (&quot;动物园有这些动物:&quot;, animals)print (&quot;老虎和狮子交配生了两个小宝宝&quot;)babies = [&quot;小宝宝1号&quot;, &quot;小宝宝2号&quot;]animals.insert(2,babies);print (&quot;动物园有这些动物:&quot;, animals)print(&quot;饲养员给两个小宝宝取了名字&quot;)animals[2][0]=&quot;小毛&quot;animals[2][1]=&quot;大毛&quot;print (&quot;动物园有这些动物:&quot;,animals)print(&quot;列表中有%d个元素&quot; %len(animals))print(&quot;第三个元素包含%d个元素&quot; %len(animals[2])) 试着用python 运行上面这个程序 2 tuple（元组） tuple定义之后不可修改，理解为不可修改的列表就行了 试着运行下面这个程序，看看结果： 1234567#-*-coding:utf-8-*-nums = (0,1)print(&quot;nums are&quot;, nums)another = (0,1,[3,4])print(&quot;nums are&quot;, another)another[2][0] = 5print(&quot;nums are&quot;, another); 为什么another能被修改？因为another[2]指向的是list，接着将list的第一个元素，下表为0的元素赋值为5，这是允许的。 3 dict（字典） 字典和C++map很相似，但是不完全相同，字典dict可以包含不同类型的key和value,字典的插入方式很简单d[‘韩梅梅’]=23 d为字典定义的变量名，key为‘韩梅梅’, value为23 当字典d中没有‘韩梅梅’这个key，那么就会将key和value插入d 如果调用d[‘韩梅梅’]=22，那么‘韩梅梅’对应的value就为22了 如果字典d中没有‘李磊’这个key，那么调用print(d[‘李磊’])就会提示出错。 所以取元素的时候要记得判断字典中是否有该key对应的value 可以通过get和in判断，下边代码有使用方法。 字典同样调用pop移除元素 d.pop(‘韩梅梅’) 下面这段代码综合了dict使用方式 1234567891011infos = &#123;&quot;李明&quot;:23, &quot;豆豆&quot;:22,&quot;老李&quot;:55&#125;print(&quot;李明的年龄为%d&quot; %(infos[&quot;李明&quot;]))infos[&quot;王立冬&quot;]=32print (infos)#print (infos[&quot;梁田&quot;])if not (&quot;梁田&quot; in infos): print(&quot;梁田不在记录&quot;)print(infos.get(&quot;梁田&quot;))print(infos.get(&quot;梁田&quot;,&quot;梁田不在记录&quot;))infos.pop(&quot;王立冬&quot;)print (infos) 用python调用上边代码，看看效果。 4 set（集合） 集合中允许存在多个重复的值 集合添加元素用add，删除用remove操作 下边的代码为集合操作 1234567891011numset = set([1,3,5,7,9])print(numset)numset.add(4)print(numset)numset.add(4)print(numset)numset.remove(3)print(numset)numset2 = set([2,4,6,8,10])print(numset&amp;numset2)print(numset|numset2) 三、循环和控制这部分和C++差不多，就是基本写法不一样 12345678910111213141516171819202122232425262728nums = (0,100,34,50,179,130,27,22)print(&quot;nums are:&quot;, nums)bigernums =[]smallnums = []for num in nums: if num &gt; 50: bigernums.append(num)print(&quot;大于50的数字有:&quot;, bigernums)for num in nums: if num &lt; 50: smallnums.append(num)print(&quot;小于50的数字有:&quot;, smallnums)print(range(5))print(list(range(5)))#1~10数字求和sum = 0for num in list(range(11)): sum += numprint(&quot;1到10数字求和结果为:%d&quot; %sum)#错误输出#print(&quot;1到10数字求和结果为:%d&quot;, sum)#换一种方式求和,while循环注意别写成死循环i = 0sum = 0while i &lt; 11: sum += i i=i+1#i++不行，习惯了C++print(&quot;1到10数字求和结果为:%d&quot; %sum) python通过缩进和：控制模块。 四、函数 1 定义函数 12345def judgeint(x): if not isinstance(x,(int)): raise TypeError(&#x27;类型不匹配&#x27;) else: return x 是通过def 函数名(参数):方式来定义函数。上面这个函数定义在func.py文件中，我再写一个文件使用这个函数 1234567from func import judgeintnumlist = [1,3,5]strlist =[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]for i in numlist: print(judgeint(i))for j in strlist: print(strlist(j)) 结果为：可见strlist中字符串类型被函数识别并终止程序运行了。 想用到某个.py文件的函数可以用from 文件名(不包含.py) import 函数名 如果想用文件中所有的接口 from 文件名(不包含.py) import * 其他的引用方式我也不会，以后遇到了再去查。 也可以去写一个空函数 1234#空函数def emptyfun(x): pass pass表示什么都不做。 当然函数可以返回许多值，这些值其实是通过tuple返回的 定义函数 123#多个返回值def getposition(x,y): return x, y 调用这个函数 123456from func import *num1 = 0; num2 = 0num1, num2 = getposition(1,3)print(&#x27;num1 is %d, num2 is %d&#x27; %(num1,num2))print(&#x27;result is: &#x27;, getposition(1,3) ) 结果为： 2 函数参数分类和使用 1 位置参数 位置参数是普通的参数 如下： 12def power(x): return x*x 2 默认参数 默认参数提供了参数的默认赋值 1234567#默认参数def power(x,n = 2): imul =1 while(n &gt; 0): imul = x*imul n = n-1 return imul 值得注意的是默认参数要指向不可变对象，否则函数重复调用默认参数会被修改def getList(L=[]): L.append(“end”) return L重复调用看看结果如何： 12345#-*-coding:utf-8-*-from func import *L=[]print(getList(L))print(getList(L)) 结果可以看出默认参数随着函数调用被修改了，所以尽量不要让默认参数指向可变对象，list就是可变对象。3 可变参数 可变参数使用和定义都非常方便 定义： 12345def calsum(*nums): sum = 0 for i in nums: sum = sum+ i return sum 使用： 12345#-*-coding:utf-8-*-from func import *L=[1,3,5,7,9]print(calsum(*L))print(calsum(*range(0,101))) 定义可变参数前边加*,使用时可以传入list，tuple等，实参前也加*即可。 4 关键字参数 其实和可变参数类似，关键字参数可以直接传入字典 定义： 123456789def getinfo2(name, age, **info): print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;其他信息:&quot;, info)def getinfo3(name,age,**info): if &#x27;city&#x27; in info: print(&quot;有城市信息&quot;) if &#x27;job&#x27; in info: print(&quot;有工作记录&quot;) print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;其他信息:&quot;, info) 定义关键字参数在形参前边加** 使用：在实参前加**表示取出字典中所有内容依次传递给函数 12345from func import *info =&#123;&#x27;性别&#x27;:&#x27;女&#x27;,&#x27;job&#x27;:&#x27;学生&#x27;,&#x27;city&#x27;:&#x27;上海&#x27;&#125;info2 =&#123;&#x27;性别&#x27;:&#x27;男&#x27;,&#x27;job&#x27;:&#x27;工人&#x27;,&#x27;city&#x27;:&#x27;北京&#x27;&#125;getinfo2(&#x27;韩梅梅&#x27;, 23, **info)getinfo3(&#x27;李雷&#x27;,25,**info2) 结果5 命名关键字参数 命名关键字参数就是传入命名的关键字，如指定传入的关键字参数的key为‘city’，‘type’等等。 举例： 1234def getinfo8(name, age, *,city, job): print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;城市:&quot;, city, &quot;工作：&quot;, job)def getinfo7(name, age, *infolist, city, job): print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;城市:&quot;, city, &quot;工作：&quot;, job, &quot;其他信息:&quot;, infolist) 可以看出命名关键字参数格式为(*,指定名称1，指定名称2…)的格式 当命名关键字参数之前的参数为可变参数时，那么不需要*，只需指明指定的几个名成即可 格式为:(*可变参数,指定名称1,指定名称2…) 试着写个代码用一下： 12345678from func import *info =&#123;&#x27;性别&#x27;:&#x27;女&#x27;,&#x27;job&#x27;:&#x27;学生&#x27;,&#x27;city&#x27;:&#x27;上海&#x27;&#125;info2 =&#123;&#x27;性别&#x27;:&#x27;男&#x27;,&#x27;job&#x27;:&#x27;工人&#x27;,&#x27;city&#x27;:&#x27;北京&#x27;&#125;getinfo2(&#x27;韩梅梅&#x27;, 23, **info)getinfo3(&#x27;李雷&#x27;,25,**info2)getinfo8(&#x27;王麻子&#x27;,70, city =&#x27;南京&#x27;, job = &#x27;裁缝&#x27;)infolist = [&#x27;有犯罪记录&#x27;,&#x27;酗酒&#x27;]getinfo7(&#x27;张三&#x27;,50,*infolist,city =&#x27;翰林&#x27;,job =&#x27;无业游民&#x27;) 读者自己打印下，看看结果当然命名关键字参数可以提供默认值 12def getinfo4(name, age,*,city=&#x27;沈阳&#x27;,job): print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;城市:&quot;, city, &quot;工作：&quot;, job) 6 参数混合使用 当参数列表包含位置参数，默认参数，可变参数，关键字参数和明明关键字参数时， 从左到右的顺序为 位置参数，默认参数，可变参数，命名关键字参数，关键字参数 读者可以自己考虑下为什么这么规定 下面定义两个函数： 123456def getinfo5(name,age,city=&#x27;沈阳&#x27;,**info): print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;城市:&quot;, city, &quot;其他信息:&quot;, info)def getinfo6(name,age,city=&#x27;沈阳&#x27;,*infolist ,health = &#x27;良好&#x27;, job,**otherinfo): print(&quot;姓名：&quot;, name, &quot;年龄：&quot;, age, &quot;城市:&quot;, city, &#x27;工作信息：&#x27;,job,&#x27;\\n&#x27;, &quot;身体状况&quot;, health, &quot;个人备注&quot;,infolist,&#x27;\\n&#x27;, &quot;其他信息:&quot;, otherinfo) 使用这一系列定义的函数 123456info5 =&#123;&#x27;性别&#x27;:&#x27;男&#x27;,&#x27;job&#x27;:&#x27;工人&#x27;,&#x27;兴趣&#x27;:&#x27;修自行车&#x27;&#125;baselist=(&#x27;Linkn&#x27;,28,&#x27;上海&#x27;,&#x27;喜欢喝冰啤酒&#x27;,&#x27;爱打麻将&#x27;)getinfo6(*baselist,**info5)getinfo5(&#x27;Linkn&#x27;,28,&#x27;上海&#x27;,**info5); 函数调用传入实参都可以通过*arg,**dict格式，提高了开发效率7 递归函数 递归函数和C++一样，先实现一个阶乘的函数 1234567#递归计算阶乘函数def imul2(num=1): if num ==1: return num else: return num * imul2(num-1) print(imul2(3)) #看看结果同样去实现汉诺塔 编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量， 然后打印出把所有盘子从A借助B移动到C的方法，计算n==3时，移动方法 读者试着自己完成，我是这样实现的 12345678def move(n,A,B,C): if n==1: print(&quot;%s --&gt; %s&quot; %(A,C)) return else: move(n-1,A,C,B) move(1,A,B,C) move(n-1,B,A,C) 调用 move(3,’A’,’B’,’C’) 结果为用递归很简单实现了复杂的逻辑，但是递归有一个问题就是当递归次数过大容易造成栈溢出。 基础先记到这里，下一篇会记录python的特性和函数编程。","categories":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.limerence2017.com/tags/python/"}]},{"title":"汇编基础最后一篇--机器语言指令","date":"2017-08-15T09:14:16.000Z","path":"2017/08/15/asmend/","text":"这是汇编语言基础最后一篇，以后还会更新更高级的汇编知识，并且这部分知识会应用到逆向编程的环节，这一章介绍汇编基础–机器指令。 一个16比特位的汇编指令：opcode操作码占用3个比特位，可以表示2的3次方为8种操作 寄存器占用2个比特位，可表示2的2次方为4种可用寄存器 地址空间为2的11次方为2048个可能的内存单元地址可用。 inc 指令和dec指令 从图中可以看出这些指令长度仅为一字节，因为每个指令地址相差为1字节。 inc eax 这条指令的机器码为40, 40为16进制表示，转为二进制为 0100 0000 inc ecx 这条指令机器码为41,41位16进制表示，转换为二进制为0100 0001 依次展开会发现机器码的规律，开头都为01000XXX,而XXX实际就是寄存器在机器中表示的二进制机器码。 下面是各个寄存器的机器码： 下面看下dec 寄存器指令图：dec 寄存器指令的格式可以总结为 01001xxx， xxx为寄存器二进制指令格式。 mov 指令mov eax, reg指令图每个指令长度为2字节，从地址偏移可以看出。 将上面指令机器码转为二进制mov ecx, eax 十六进制为8B C8，二进制表示第二个字节 1100 1000 mov ecx, ecx 十六进制为 8B C9，二进制表示第二个字节为 1100 1001 通过对比二进制，发现第一个字节都为8B，第二个字节分别为 C0,C1,C2,C3…C9 mov reg, reg 指令格式为 10001011 11XXXYYY XXX为目的寄存器， YYY为源寄存器 mov reg, imm 即将一个立即数移动到寄存器中指令的机器码会是什么样呢？ 下图为将立即数移动到寄存器的图示：mov eax, 1 指令机器码为 B8 00000001 mov ecx, 10 指令机器码为 B9 0000000A 两条指令地址相差5个字节，每个字节8bit，可计算出每条指令为40bit长度。 即10个十六进制数表示。而 B8 00000001 和 B9 0000000A 恰巧为10个16进制数字组成。 机器码B8 00000001 从左向右数，去掉B8占用的一个字节，剩下的四个字节可以看出用来表示 立即数 1。同样的道理，可以看出 B9 0000000A也是这个原理。 如果移动的为负数，怎么表示呢？mov edx, -1 这个指令我们分析一下 -1在机器中的表现形式 负数在机器中以补码的形式表现，-1 的补码计算规则为： 1的源码为 0000 0000 0000 0000 0000 0000 0000 0001 按位取反 为 1111 1111 1111 1111 1111 1111 1111 1110 末尾+1 位 1111 1111 1111 1111 1111 1111 1111 1111 转换为十六进制为 F F F F F F F F 恰好就是 机器码的最后三个字节表示。 同样的道理适用于mov ebx, -10 下面分析前两个字节 BA, BB, B8， B9 分别有什么关联。同步对比可以看出 前几个比特位是一样的，都为 10111 后三个比特位分别为 000， 001， 010， 011，这四个二进制码恰好为 几个寄存器的二进制表示方法。所以 mov reg, imm 机器指令为 10111XXX YYYYYYYY YYYYYYYY YYYYYYYY YYYYYYYY mov reg, mem 将内存数据移动到寄存器中 的机器指令怎么表示？ mov mem, reg 将寄存器中的数据移动到内存中，机器指令如何表示？下图定义了变量num1, num2, num3num1 地址为 0000 0000 num2 地址为 0000 0004 num3 地址为 0000 0008 下图为指令对应的机器码： 除去A1，A3开始的一个字节，剩下的4个字节分别为 十六进制4 和十六进制8，分别为num2的地址 和num3 的地址。 下面分析第一个字节A1和A3 规律：可以得出结论，无论将内存数据移动到eax中，还是将eax中的数据移动到内存中， 最后的4个字节表示的都是内存的地址，第一个字节表示的不同，用来表示两种移动方式的区别。 总结规律如下：mov eax, mem 10100001 YYYYYYYY YYYYYYYY YYYYYYYY YYYYYYYY mov mem , eax 10100011 YYYYYYYY YYYYYYYY YYYYYYYY YYYYYYYY下面图表表示了ebx,ecx,edx三种寄存器和内存数据移动指令 可以看出其他寄存器(eax, ecx, edx)和内存之间移动数据的操作指令大小为6字节，多出的为第二字节， 0D,15，1D。 第一字节8B表示从内存移动数据到寄存器，89表示从寄存器移动到内存，如下图所示：第二个字节图表如下：通过二进制可以看出 前两位都为 00， 中间三位为 001 ，010， 011 分别表示ecx, edx, ebx 最后三位为101， 其实这个字节不仅仅用于表示移动，还可以表示很多操作，因为ecx为循环控制， ebx为基址寄存器， edx可用于存余数等等，所以 前两位为00，且最后三位为101，这个组合表示移动 操作。中间三位表示操作的寄存器是什么。 该字节概括为如下图所示：mod 字段为00， 且r/m字段值为101，它表示地址模式数据置换，也就是指向内存地址模式add 指令 sub 指令 add指令很简单，给出图表读者自己分析。 字节转为二进制可以看出从右往左数第3到1位为第二个操作的寄存器， 从右往左数第6到4位表示第一个操作的寄存器， 两个寄存器操作模式为 第7~16位所表示。 movoffset 指令 lea 指令num2 的值为5， 地址为 00000004， 分别将num2 的内容移动到esi和edi，再通过lea指令将num2地址放入esi和edi通过对比可以看出后四个字节都为 0000 0004 ， 但是前两个字节是不一样的。将前两个字节展开为二进制由于mov esi, num2 是将num2数据存入esi，而 lea esi, num2 是将num2地址放入esi，所以 第一个字节的倒数第二位不同，第一个字节分别为10001011 ， 10001101，mov和lea第二个字节是相同的。 下面对比两个lea指令前两个字节 ，第一个字节是相同的，第二个字节为 00 110 101 和 00 111 101 第二个字节中间三位不同，分别为110(esi), 111(edi)表示寄存器。 所以可以总结一下， mov 指令和 lea指令区别在于第一个字节，计算机用第一个字节区别mov和lea指令。 计算机用第二个字节中间三位区别lea指令操作的不同寄存器。 第二个字节和我们上面说过的：mod 字段为00， 且r/m字段值为101，它表示地址模式数据置换，也就是指向内存地址模式。下面看一下 mov esi, offset mem 和 mov edi, offset mem两条指令。可以看出mov offset指令为5个字节，比 mov 和lea指令少了一个字节，因为mov offset仅仅在编译的时候加载地址， 所以不需要lea的第二个字节表示 数据移动操作。 mov offset是静态的。 mov offset 指令esi和 edi区别仅仅在第一个字节，展开后可以看到：第一个字节的后三位 分别为 110(esi), 111(edi)。 可以得出结论mov offset 的指令第一个字节后三位区别esi还是edi，其余不变。jmp指令 看一则jmp指令操作jmp 指令 机器码为EB + 相对偏移地址 ，如 jmp around 为EB 04 ，通知计算机跳转到当前指令指针位置+4字节的位置，需要普及一个知识，当程序运行的时候，指令指针或者CPU中的指令指针指向下一条将要取到CPU中被后续执行的指令。当运行到 jump around时，指令指针实际指向了 地址000000D8，指令 above：nop的位置，EB 04指向 为 000 000 DB 加上4个字节地址即为 000 000 DC， 恰好是 around：nop指令地址。 符合逻辑。 下面看下 jump above指令会跳转到哪里。 EB FC 指令 FC 为 1111 1100 ， 该数值为某个负数的补码，负数补码的计算规则为符号位不变，其他位按位取反末位+1。 同样的道理，负数补码转为原码，符号位不变，按位取反末位+1 1111 1100 符号位不变，按位取反 1000 0011， 末位+1， 变为 1000 0100 表示-4. jmp above 机器指令 EB FC 跳转到 指令指针地址向前移动四个字节的位置。 jmp above 指令运行时，指令指针指向下一条将要取出的指令位置，即 000 000 DC， 000 000 DC - 4 为 000 000 08，即 above：nop 的位置。 到此为止机器指令的知识介绍完毕，以后会介绍高级汇编和反汇编的知识，汇编基础介绍告一段落。 我的微信公众号，谢谢关注。","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"汇编语言学习笔记(六)","date":"2017-08-15T08:08:33.000Z","path":"2017/08/15/asm6/","text":"十八、字符串处理 前文介绍过字符串的处理，字符串是byte类型 的数组，现在实现一段代码，将字符串string1数据copy到字符串string2中 代码如下 1234567891011 .datastring1 byte &quot;Hello World!&quot;, 0string2 byte 12 dup(?), 0 .codemov ecx, 12mov ebx,0.repeatmov al, string1[ebx]mov string2[ebx], alinc ebx.untilcxz 通过ecx递减，将字符串string1每个字符一次copy给string2中，其中用到了ebx基址寄存器。 也可以通过esi和edi寄存器 12345678910111213.datastring1 byte &quot;Hello World!&quot;stirng2 byte 12 dup(?), 0 .codemov ecx,12lea esi, string1lea edi, string2.repeatmov al,[esi]mov [edi],alinc ediinc esi.untilcxz 这些代码可以通过字符串操作的其他指令替代，使代码更简洁 1 movsb指令 movsb是字符串移动指令，将esi指向的字符移动到edi指向的空间，并且将ecx减1，寄存器esi和edi内容增加1或者减少1 如果仅仅使用movsb指令作用不大，配合循环使用，功能很强大。cld指令表示方向标志值清0，调用movsb会使esi和edi内容增加1 std指令表示设置方向标志值，调用movsb会使esi和edi内容减少1 还是上面的需求，这次使用movsb完成目标 12345678mov ecx,12 ; 字符串大小为12mov esi, offset string1 ; esi指向string1起始位置mov edi, offset string2 ; edi指向string2起始位置cld ; cld指令调用后 ，调用movsb会使esi和edi分别加1.repeatmovsb ; 先将esi指向的空间数据拷贝到edi指向的空间 ; 然后esi和edi分别加1，并且ecx值减少1.untilcxz 和movsb配合使用的几个前缀： rep 重复操作，等于循环，直到ecx为0退出循环 repe 如果相等，则重复操作，如果不等，那么退出循环，或者ecx为0退出循环 repne 不相等，则重复操作，相等则退出循环，或者ecx为0退出循环 上面的代码可以使用 rep movsb更改，完成同样的目的 12345mov ecx, 12lea esi, string1lea edi, string2cldrep movsb ;循环直到ecx为0结束 2 scasb指令 scasb指令用于在edi寄存器指定的空间中搜寻al所存储的字符。 scasb指令操作流程为： 将要查询的字符放入al寄存器中，如果要在字符串string中查找匹配的字符，那么将edi存储string的首地址，调用scasb进行匹配，scasb指令调用后会将edi 存储数值加1，并且ecx值-1，为了完成字符串string中逐个字符匹配，需要在scasb前面加上repne指令，这样在不相等时继续 查找，直到查找到指定字符退出循环。此时edi指向的位置为字符串string中匹配字符位置的下一个位置。 举例实现： 12345678.dataname1 byte &quot;Abe Lincoln&quot;.codemov al, &#x27; &#x27; ; 在al寄存器中存储空格，为了在name1中查找该空格mov ecx, lengthof name1 ;ecx存储name1字符串长度，为11lea edi, name1 ;edi指向name1首地址repne scasb ;匹配edi指向空间的字符和空格是否相等，不相等则edi加1 ;ecx减1，直到相等或者ecx为0退出循环 运行后ecx为7，edi执行字符L的位置 效果图如下： 3 stosb指令 stosb用于把寄存器al存储的数据放入寄存器edi所指向的空间,指令完成后edi增加1 stosb等价于： 12mov [edi],alinc edi 4 lodsb指令 lodsb用于把寄存器esi所指向的空间数据存储到al寄存器中，指令完成后esi增加1 lodsb等价于： 12mov al, [esi]inc esi 下面实现将字符串姓名倒置功能，并将名字和姓中间添加字符“ ”和“,” 如“Abe Lincoln”变为“Lincoln, Abe” 12345678910111213141516171819202122 .dataname1 byte &quot;Abe Lincoln&quot;name2 byte 12 dup (?) .codemov al, &#x27;&#x27;mov ecx, lengthof name1lea edi, name1repne scasbpush ecxmov esi, edilea edi, name2rep movsbmov al, &#x27; &#x27;stosb mov al, &#x27; &#x27;stosbmov ecx, lengthof name2pop eaxsub ecx, eaxdec ecxlea esi , name1rep movsb 5 cmpsb指令 字符串比较指令，该指令和movsb差不多，比较edi和esi指向空间数据大小，并且edi和esi增加1或者减少1， 可通过cld或std设置，并且ecx减少1 比较“James” 和 “James” 代码如下： 123456789.dataname1 byte &quot;James&quot;name2 byte &quot;James&quot;.codemov ecx, lengthof name1lea esi, name1lea edi, name2cldrepe cmpsb 相等情况下ecx为0，edi和esi都指向字符串最后一个字符的下一个位置 如果比较的字符为“James”和“Jamie”,那么效果如下： 如果比较字符为“Marci”和“Marcy”，那么上述代码就没办法区分是否相等了，因为此时ecx也为0 如果ecx大于0，那么两个字符串肯定不相等的，如果ecx为0，那么将esi和edi都-1，得到最后一个元素， 再将esi和edi指向空间的数据比较即可。 下面将上述代码完善一下，比较两个长度相等的字符串name1和name2 1234567891011121314151617mov ecx, lengthof name1lea esi, name1lea edi, name2cld repe cmpsb.if ecx &gt; 0;输出不相等.else dec esi dec edi mov al, [esi] .if al != [edi] ; 输出不相等 .else ;输出相等 .endif.endif 十九、字符串总结 1 movsb 指令将寄存器esi指向的字节类型字符串的内容移动到寄存器edi指向的位置，通过cld或std设置esi和edi增加还是减少 2 cmpsb 指令对寄存器的esi指向的字符串中的一个字符和edi所指向的一个字符进行比较，通过cld或std设置esi和edi增加还是减少 3 movsb指令前边的rep前缀会让该指令重复执行，循环次数等于ecx的值，每一次循环ecx的值减1，直到为0停止。 4 cmpsb指令前面的repe前缀的作用类似于rep前缀，当ecx为0是，停止执行指令。或者当esi和edi所指向的两个空间的字节内容不同，循环也会停止。 `repne当esi和edi所指向的两个空间的字节内容相同时，停止`。 5 scasb指令将一个字符串进行搜索，查找字符串中是否存在寄存器al中所存储的字符。如果找到该字符，那么edi指向的地址比该字符的地址靠后一个字节。 `stosb将al寄存器的内容存储在edi所指向的内存空间的位置中。lodsb指令将把寄存器esi所指向的内存空间位置中的字符复制到al寄存器中`。 我的微信公众号，谢谢关注：","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"汇编语言学习笔记(五)","date":"2017-08-15T07:39:31.000Z","path":"2017/08/15/asm5/","text":"十六、数组数组的基本表示方法 numary sdword 2,5,7 numary数组中有三个元素，为sdword类型，分别为2,5,7 empary sdword ?, ?,? empary数组为sdword类型元素，未初始化。 如果数组元素很多可通过 zeroary sdword 100 dup(0) zeroary数组中有100个0 empary sdword 3 dup(?) empary 数组中有3个未初始化的sdword类型数据 mov eax, numary+8; 表示把数组numary第3个元素放入eax中 sdword为四字节，numary+0表示numary首地址，也是第一个元素地址，以此类推，numary+8为第三个元素首地址。 mov numary+0, eax; 将eax内容放入数组第一个元素中。 除了采用数组首地址+偏移地址方式，可以采用ebx基址寄存器进行数组索引。 访问numary第三个元素 mov ebx, 8;ebx存储8 mov eax, numary[ebx];访问numary偏移8字节的元素，也就是第三个元素，放入eax中。 举个例子C语言： 12345sum = 0for(i = 0; i &lt; 3; i++)&#123; sum +=numary[i];&#125; 汇编语言： 12345678mov sum, 0mov ecx ,3mov ebx, 0.repeatmov eax, numary[ebx]add sum, eaxadd ebx,4.untilcxz 除了使用基址寄存器ebx，还可以使用寄存器esi和寄存器edi进行索引, esi为源索引寄存器，edi为目的索引寄存器。 第一种方法 123mov ebx,4mov eax,numary[ebx] 第二种方法 123mov esi, offset numary+4mov eax,[esi] 第二种方法先将numary+4的地址放入esi中，然后[esi]取出esi指向的地址空间的数据，也就是numary+4地址空间里的数据将数据放入eax中。 两种方法的效果图： 除了上述两种方法，还有第三种方法 123lea esi, memory+4mov eax, [esi] lea 和offset的区别： offset 是在编译时将地址写入esi lea是动态写入，每次运行时将地址写入esi中。 去实现如下代码： 12345678j=n-1;for(i=0; i &lt; n/2; i++)&#123; temp=numary[i]; numary[i] = numary[j]; numary[j] = temp; j--;&#125; 通过汇编实现： 123456789101112131415mov ecx,nsar ecx,1lea esi,numary+0mov edi, esimov eax,ndec eaxsal eax,2add edi, eax.repeatmov eax, [esi]xchg eax, [edi]mov [esi], eaxadd esi,4sub edi,4.untilcxz 数组还有两个指令，lengthof表示数组元素的个数 sizeof表示数组总共占用多少字节。 前面的代码可以通过这两个指令修改 1234567891011121314mov ecx, lengthof numarysar ecx,1lea esi, numary+0mov edi, esimov eax, sizeof numarysub eax,4add edi, eax.repeatmov eax,[esi]xchg eax, [edi]mov [esi], eaxadd esi, 4sub edi,4.untilcxz 十七、数组总结1 esi 为源索引寄存器，主要用于从esi指向地址空间取出数据 2 edi为目的索引寄存器，主要用于向edi指向地址空间写入数据 3 esi和edi存储的为地址，[esi]和[edi]为他们指向的地址空间存储的数据 4 可以通过mov edi, esi将esi寄存器存储的地址放入edi中，因为两个操作数都是寄存器 5 不可以使用mov [edi],[esi];因为两个操作数都为内存，这是汇编指令mov不允许的。 6 寄存器ebx为基址寄存器，可通过数组名[ebx]取出数组首地址偏移ebx存储的字节数的元素。 7 offset操作符的mov指令，如mov eax, offset sumary+4是将sumary首地址偏移4字节地址写入eax，此时eax存储的是第二个元素首地址,他是静态的获取地址，而lea是动态的获取地址 8 lengthof用于计算数组元素数量，sizeof用于计算数组总共占用多少字节。 数组的介绍到此为止，下一篇是字符串的介绍 我的公众号：","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"汇编语言学习笔记(四)","date":"2017-08-14T03:12:30.000Z","path":"2017/08/14/asm4/","text":"十三 过程汇编语言的过程可以被理解为方法，过程调用采取如下形式 call pname pname为过程名，call为调用指令 pname过程的格式为 1234pname proc ; 过程体 retpname endp proc 告知编译程序过程pname的开始，endp告诉编译程序过程pname的结束。ret指令表明何时返回到调用程序中，ret和高级语言return不一样，ret不返回任何值给调用程序。ret是过程中必不可少的调用指令。 举个过程的实例： 12345678sample proc .if eax == 0 mov eax, 1 .else mov edx, 0 .endif retsample endp 如果过程中使用到ecx，eax，ebx, edx等通用寄存器，而不确定外界是否也用到这些通用寄存器，那么在过程中需要将外界用到的寄存器数据保存，可以使用临时变量，也可以使用入栈。譬如ecx数据在调用程序中使用，同时过程mult中也用到ecx，那么使用ecx之前将ecx入栈。 12345678910111213mult proc push ecx mov eax, 0 .if x != 0 mov ecx, 1 .while ecx &lt;= y add eax, x inc ecx .endw .endif pop ecx retmult endp 出了过程中明显能从代码中看到一些寄存器会被修改，还有一些指令会导致寄存器数据被修改。 INVOKE指令会导致eax,ecx,edx内容被修改 imul会导致eax,edx被修改。所以可以通过pushad和popad指令保存和恢复这些寄存器的内容 举例 123456789blankln proc pushad .repeat INVOKE printf, ADDR blnkfmt dec ebx .until ebx &lt;= 0 popad retblacnkln endp 过程的声明都是放在main主程序之后。而且过程更看重的是节约空间。 十三 宏1 宏和过程都可以避免编写同样功能代码，宏的速度比过程快，但是倾向于浪费一些空间达到提高效率的目的。 宏的声明放在main函数之前。 宏的结构如下： mname macro ; 宏体 endm 宏的结构和过程的结构不同，宏内部没有ret，并且macro 表示宏的开始 macro前边为宏的名字。endm为宏的结束，但是endm之前没有宏的名字。另外宏的调用不需要使用call指令，直接写宏的名字即可。可以通过查看汇编列表文件看看宏扩展是什么，以及宏被插入到程序段是什么指令，下面为某段代码调用两次swap宏 展开后： 88 1D 00000046 表示指令mov ebx , num1，该指令在程序地址为00000000处。 另外需要注意的是宏扩展后，注释也会扩展在指令后边。虽然会占用一定内存，但是注释可以帮助程序人员排除逻辑错误。 如果想使用注释，仅仅在宏过程中可见那么采取;;替代;，这样注释不会出现在宏扩展中，用户可以通过宏的声明看到注释。 调用宏的时候，调用几次宏就在相应的调用位置扩展几次，而过程无论调用多少次，仅仅扩展一次。这就是过程节省空间的原因。 另外宏内部尽量不要使用寄存器，如果使用寄存器也不需要保存和恢复寄存器内容，这些操作放在调用宏的程序里，因为保存和恢复操作一则浪费空间，二则会减少宏执行的效率。 2 带参数的宏 12345swap macro p1, p2 mov ebx, p1 xchg ebx, p2 mov p1, ebx endm p1,p2为宏的参数，可以理解为高级语言宏的两个参数，调用程序调用swap时会将实参替代形参完成宏调用。 调用swap时会用num1替代p1,num2替代p2， 用x替代p1, y替代p2 如果开发人员只传入一个参数怎么办？ 比如 swap num1? 这样宏展开就出现问题。可以通过:REQ语句指明参数是必须传入不可缺少的。 12345swap macro p1:REQ, p2:REQ mov ebx,p1 xchg ebx, p2 mov p1, ebx endm 这样要求调用swap必须传入两个参数，缺少参数则提示报错。 考虑这样一个问题，如果调用程序调用swap num1,1怎么办？ xchg ebx,1出错。 另外如果 swap ebx, ebx 怎么办？这种没必要调用swap，虽然调用swap不会出错， 但是造成了空间的浪费。这些问题都可以通过条件汇编解决。 十四 条件汇编条件汇编和条件指令不同，条件汇编控制编译程序，而不是控制程序的执行，条件汇编根据不同的条件将不同的指令或代码包含到程序中。 条件汇编指令if if和之前介绍的高级汇编指令.if不一样，if后边的参数为 eq, ne, lt, le, gt, ge, or, and等。 举例： 12345 if num eq 3;该条件满足将指令插入程序 endif 除此之外 ifb 判断如果为空，则执行if下边的逻辑。 ifnb 判断如果不为空 ifidn 判断如果相同 ifidni 不区分大小写，如果相同 ifdif 如果不相同 ifdifi 不区分大小写，如果不同 这类指令后边要用&lt;参数形式&gt; 举例： 1234567addacc macro parm ifb &lt;parm&gt; inc eax else add eax, parm endif endm 在程序中通过几种方式调用addacc![4.jpg] .lst文件内容如下所示，根据不同条件扩展为不同的宏![5.jpg] 根据不同的条件生成了不同的机器指令，达到了节约空间和控制编译的目的。 仅仅在一部分地址和机器指令行包含了汇编指令，其余没有机器指令和地址的汇编代码不会被包含在程序中。 使用条件汇编将之前的swap设计的更完善 1234567891011swap macro p1:REQ, p2:REQ ifidni &lt;ebx&gt;,&lt;p2&gt; xchg p1, ebx elseifidni &lt;p1&gt;, &lt;ebx&gt; xchg ebx, p2 else mov ebx, p1 xchg ebx, p2 mov p1, ebx endif endm 通过条件汇编，使swap功能更健全和高效。 十五 过程和宏对比和总结1 过程在被调用的时候只有一份程序副本出现，而宏在被调用的时候，每一次对宏的调用都会出现一次宏代码的副本。 2 过程通常会保存和恢复寄存器的内容，而宏通常不会去保存和恢复寄存器的内容。 3 过程倾向于节省内存空间，而宏倾向于节省运行时间 4 调用过程的时候，使用call指令，后面跟着过程的名字，而调用宏的时候直接写宏的名字。 5 过程中必须包含ret指令，但是宏中一定不能写ret 6 把过程名字放到endp语句之前的标记字段，但是endm之前的标记字段不需要写宏的名字。 7 如果要求调用宏必须传入参数，可在参数后加:REQ 8 条件编译if在使用or或and逻辑时需要将两个参数用括号括起来，如if(x lt 0)or(y gt 1) 我的微信公众号：","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"汇编语言学习笔记(三)","date":"2017-08-12T07:59:01.000Z","path":"2017/08/12/asm3/","text":"八、逻辑运算指令数字在计算机中以二进制存储，每个位数字为0或者1，当两个二进制数字进行逻辑按位&amp;，逻辑按位|，逻辑异或^操作， 可以采用汇编语言提供的逻辑运算指令and,or, xor,not等指令。 and指令： C语言&amp;操作，将0110&amp;1101得出结果为0100 C语言代码为 12if(flag &amp; maskit) count++; 汇编语言高级指令可实现： 1234mov eax, flag.if eax &amp; maskitinc count.endif 不采用高级指令的情况下可采用如下代码： 12345if01: mov eax, flag and eax, flag jz endif01then01: inc countendif01: nop and指令和cmp指令一样，and运算执行后，eflags寄存器的响应比特位会被设置。 同样xor，not， or等指令也会设置eflags相应比特位。 jz 指令之前介绍过，当eflags寄存器相应比特位被设置为0后该指令将逻辑跳转到指定位置。 同样ZERO?也可以判断eflags寄存器相应比特位是否被设置为0，为零则为真，反之为假 12345mov eax, flagand eax, maskit.if !ZERO?inc count.endif or指令: or指令和and指令用法一样 1234;flag = flag | maskitmov eax, flagor eax, maskitmov flag, eax xor指令： 1234;flag = flag ^ maskit;mov eax, flagxor eax, maskitmov flag, eax 三种指令的两个参数类型限制是一样的 123456789and mem, immand mem, regand reg, regand reg, immand reg, mem or， xor参数类型和上面and一样，三种命令都不可以直接操作两个内存变量。 九、逻辑移位指令shl reg, cl 将reg中数据向左移动cl寄存器中数值大小的位数。 shl reg, imm 将reg中数据向左移动imm立即数大小的位数。 举例： 1234mov cl , 3shl reg, cl;也可以采取立即数shl reg, 3 `上述代码都是将reg中数值向左移动三位，那为什么采用cl寄存器呢？因为在老式的8086/8088处理器上，操作数中能使用的唯一立即数为1，如果调用shl reg,3 会出问题，所以通常的做法是mov cl, 3先将3移动到cl寄存器中，再调用shl reg, cl可完成reg数值向左移动3位`。 shl 的参数除去reg，还可以是mem内存 shl mem, cl shl mem, imm 同样shr为向右移动，参数形式和shl一样。 如果10101010调用shl向左移动一位，那么所有比特位的数字依次左移，第0个位置比特位数字填充0，第7个比特位数字1向左移动到CF进位标记里。 数字变为01010100。 同理，shr逻辑右移也是移动后第7个比特位补充0，第0个比特位数字放入CF标记中。 写一段代码测试每个比特位数字为1的位数。 123456789101112mov count, 0mov ecx, 8mov temp , al.repeatmov ah, aland ah, 00000001b.if !ZERO?inc count.endifshr al, 1.untilcxzmov al, temp 由于and指令会导致第一个参数数值被修改，所以将al数值每次and操作前都copy到ah中。最后处理完所有比特位，将temp数据copy回al中。 test命令可以避免and修改第一个参数数值的问题，同样test命令使用后eflags寄存器相应的比特位也会被设置。 1234567891011mov count, 0mov ecx, 8mov temp, al.repeattest al, 00000001b.if !ZERO?inc count.endifshr al, 1.untilcxzmov al, temp 十、算术移位指令算数左移 sal reg, cl sal reg, imm sal, mem, cl sal reg, cl 参数和shl一样。移动效果和shl一样，都是将低比特位依次移动到高比特位，最高比特位移动到CF标记里，空位补0。 移动示意图： 如果符号位为0，那么左移操作和shl一样，没什么问题。 如果符号位也就是第七个比特位为1，如1111 0000，向左移动一位那么数据为1110 0000，左移操作后数值为原数值乘以2，负数在计算机中以补码形式存储。 整数的补码为原码，负数的补码为正数原码按位取反末尾加1, 1111 0000-1为1110 1111，按位取反后为0001 0000，该数值为十进制16，所以1111 0000为 -16，-16乘以2，也就是左移操作，为-32，那么-32在二进制中如何表示呢？ 32用8位二进制表示为0010 0000，负数为正数原码按位取反末尾+1,0010 0000取反后为1101 1111，末尾+1为1110 0000, 1110 0000恰好为1111 0000左移一位得到的数字。 考虑这样一个问题，如果是图中所示数字10101010左移会造成数字变为0101 0100，这样 最高位变为0怎么办？ 这就是所谓的左移溢出，8位二进制能表示的二进制数为0111 11111~1111 1111 。 0111 1111 表示十进制127 1111 1111 表示十进制-1 1000 0000 是某负数补码， 该数-1取反后得到1000 0000 该数值为128原码 所以1000 0000 表示-128，(也可以1000 0000 按位取反末尾+1得到128) 那么8位二进制能表示的十进制数为127~-128 10101010表示的负数为-86，超过-64了。 凡是超过-64都会引起左移位溢出，负数补码除去符号位，最高位为0，此时逻辑左移会导致数据溢出。 算数右移 算数右移保持符号位不变，其余比特位依次向右移动，空出的比特位补零，最右边的比特位移除后进入CF标记。 计算product = num * 8；可通过移位指令完成，速度更快 1234;product = num1 * 8;mov eax, num1sal eax, 3mov product , eax 乘以8，不是sal eax, 8，这样是乘以256，应该为移动三位。 answer = amount /4 ; 1234;answer = amount/4;mov eax, amountshr eax, 2mov answer, eax 十一、循环移位指令循环移位将末尾移除来的数据放入另一端空缺的比特位。 循环左移位 rol reg, cl rol reg, imm rol mem, cl rol mem, imm 循环右移位 ror reg, cl ror reg, imm ror mem, cl ror mem, imm 循环右移位 循环左移位 之前检测一个8位二进制数中比特位数字为1的比特位个数程序可通过循环右移完成，因为循环右移8位后，移位的结果和初始数值一样。 123456789mov count , 0mov ecx, 8.repeattest al, 0000 0001b.if !ZERO?inc count.endifror al, 1.untilcxz 十一、堆栈操作push 指令 push reg push mem push imm push指令为入栈指令，参数可以为寄存器reg， 内存mem， 立即数imm。 pop指令 pop mem pop reg pop出栈指令，参数只能为内存和寄存器。 将监测比特位数值为1的比特位数程序和栈操作指令结合 12345678910111213push eaxpush almov count, 0mov ecx, 8.repeattest al, 0000 0001b.if !ZERO?inc count.endifshr al,1.untilcxzpop alpop eax 十二、xchg交换指令xchg交换指令用于交换两个地址空间数据，xchg参数可以为以下几种 xchg reg, reg xchg reg, mem xchg mem, reg 同样不可以操作两个内存。 实现两个数交换 123temp = num1;num1 = num2;num2 = temp; 用mov指令实现为： 1234mov edx, num1mov eax, num2mov num1, eaxmov num2, edx 用push， pop指令实现为 1234push num1push num2pop num1pop num2 用xchg指令实现为 123mov eax, num1xchg eax, num2mov num1, eax 三种办法的效率比较为mov指令最快，其次xchg指令，最后为push pop指令。 这一篇就介绍这里，下一篇讲述宏和过程。 我的公众号：","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"汇编语言学习笔记(二)","date":"2017-08-12T04:04:04.000Z","path":"2017/08/12/asm2/","text":"六、选择结构if-then结构 C语言版本 12345if(count == 10)&#123; count --; i++;&#125; MASM汇编 1234.if count==10dec countinc i.endif cmp指令，该指令用于比较两个参数大小 cmp mem, imm 比较内存mem和立即数imm大小 cmp reg, imm 比较寄存器reg和立即数imm大小 cmp reg, mem 比较寄存器reg和内存mem大小 cmp mem, reg 比较内存mem和寄存器reg大小 cmp imm, reg 比较立即数和寄存器reg大小 cmp imm, mem比较立即数和内存mem大小 cmp reg, reg比较两个寄存器数据大小 .if 内部是通过cmp实现的，.if和cmp都不能比较两个内存中数据大小 条件跳转指令 je 相等时跳转 jne 不相等时跳转 je 和jne可以用于无符号数比较跳转，也可用于符号数比较跳转 符号数据跳转指令 jg 大于时跳转 jge 大于或等于时跳转 jl 小于是跳转 jle 小于或等于时跳转 jnle 不小于且不等于时跳转，即大于时跳转 jnl 不小于时跳转 jnge 不大于且不等于时跳转 jng 不大于时跳转 这类指令可用上面的jg，jge，jl，jle替代，尽量不要使用，不容易理解。 .if-.end汇编指令可用上面的cmp指令和条件跳转指令替代 如 123.if number == 0dec number.endif 用条件跳转指令实现为： 1234if01: cmp number, 0 jne endif01then01: dec numberendif01: nop if-then-else结构 汇编指令的结构为 123456789.if 条件 ;执行语句.else ;执行语句.endif 举例说明，C语言 1234if (x&gt;=y) x--;else y--; 汇编语言 1234567if01: mov eax,x cmp eax,y jl else01then03: dec x jmp endif01else01: dec yendif01: nop 采用汇编指令 123456mov eax , x.if eax &gt;= y dec x.else dec y.endif 嵌套if结构 C语言 1234567if(x &lt; 50) y++;else if(x &lt;= 100) y = 0; else y--; 汇编语言 采用汇编指令 1234567.if x &lt; 50 inc y.elseif x &lt;= 100 mov y, 0.else dec y.endif 通过跳转指令实现上述步骤 1234567891011if01: cmp eax, 50 jge else01then01: inc y jmp endif01else01: nopif02: cmp x, 100 jg else02then02: mov y,0 jmp endif01else02: dec yendif01: nop case 结构 C语言 12345678910switch(w)&#123; case 1: x++; break case 2: case 3: y++; break; default: z++;&#125; 汇编语言中没有case switch对应的汇编指令，但是可以通过cmp指令和跳转指令实现 12345678910111213switch01: cmp w, 1 je case1 cmp w,2 je case2 cmp w,3 je case2 jmp default01case1: inc x jmp endswitch01case2: inc y jmp endswitch01default01 : inc zendswitch01: nop 无符号跳转指令 ja 高于跳转 jae 高于或等于跳转 jb 低于跳转 12345i = 1;while(i &lt;= 3)&#123; i++;&#125; jbe 低于或等于时跳转 逻辑运算符综合实现 123.if w==1 || x==2&amp;&amp;y == 3 inc z.endif条件跳转指令实现上述逻辑 12345678if01: cmp w,1 jne or01or01: cmp x, 2 jne endif01 cmp y, 3 jne endif01then01: inc zendif01: nop 七、迭代结构1 前置循环结构whileC语言 12345i = 1; while(i &lt;= 3)&#123; i++; &#125; 汇编指令实现 1234mov i, 1.while (i &lt;= 3) inc i.endw 条件跳转指令实现 123456mov i, 1while01: cmp i, 3 jg endw01 inc i jmp while01endw01: nop 2 后置循环结构 do whileC语言 123456i = 1;do&#123; i++;&#125;while(i &lt;= 3); 汇编指令 .repeat .until 1234mov i, 1.repeat inc i.until i &gt; 3 .repeat-.until和C语言do -while一样，第一次先执行循环体内容，do-while是在每次运行循环体后判断条件不满足跳出循环 .repeat-.until 是判断条件不满足则一直循环，直到.until后面条件成立则跳出循环 通过汇编跳转指令实现 123456mov i, 1repeat01: nop inc i cmp i, 3 jle repeat01endrpt01: nop 3 固定循环结构 for12345for(i=1; i &lt;= 3; i++)&#123; //循环体&#125; 汇编语言 1234mov ecx, 3.repeat ; 循环体.untilcxz .repeat-.untilcxz 对应C语言的for循环固定循环结构，它和.repeat-.until都是后置循环结构。 都要先执行一次循环体，然后.untilcxz会将ecx中的数据值减1，接着判断ecx是否为0，ecx为0则跳出循环 ecx大于0则继续执行循环。所以执行.repeat-.untilcxz这个循环前保证ecx大于0 .repeat-.untilcxz 内部是loop实现的，所以同样可以通过loop实现该循环 12345mov ecx, 3for01 : nop ; 循环体 loop for01endfor01: nop loop 和.untilcxz一样，都会将ecx中的值减1，然后判断ecx是否为0，为0则终止循环，大于0则继续循环。 loop指令最多只能向前跳转128字节处，也就是循环体内容不得超过128字节。同样.repeat-.untilcxz循环体也不得超过128字节。 与.if高级汇编指令一样，.while-end高级汇编指令和.repeat-.until高级汇编指令都基于cmp，不可直接比较两个内存变量。 `使用loop指令和.repeat-untilcxz指令前，需要保证ecx大于0，在循环体中尽量不要更改ecx数值，如果需要更改则将ecx 数据先保存在内存中，执行完相关操作后将ecx数值还原，保证.untilcxz和loop操作ecx的准确性。` 下面用汇编语言实现斐波那契数列 if n= 0, then 0 if n = 1, then 1 if n = 2, then 0+ 1 = 1 if n = 3, then 1+ 1 = 2 if n = 4, then 1+2 = 3 n 为任意非负数，计算n对应的数值sum。 用.while循环实现如下 1234567891011121314.if n==0mov sum, 0.endif.if n==1mov sum, 1.endifmov ecx, nmov eax, 0mov sum, 1.while (ecx &lt;= n) mov ebx, sum add sum, eax mov eax, ebx.endwhile 到目前为止，循环和条件判断就介绍到这里，下一期介绍堆栈位移之类的指令。 我的公众号：","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"汇编语言学习笔记(一)","date":"2017-08-12T03:18:46.000Z","path":"2017/08/12/asm1/","text":"一：变量类型汇编语言变量基本类型如下： sdword ：表示32位整数 dword：表示32位无符号整数 sword：表示16位整数 word：表示16位无符号整数 sbyte：表示8位整数 byte：用于表示字节，大小为8位 变量的表示和定义： C语言中 1int num3 = 5； 汇编中 1num3 sdword 5； C语言中 123char name1；char name2=‘A’； 汇编中： 123name1 byte ？name2 byte ‘A’； C语言中： 1char name[] = &quot;iloveu&quot;; 汇编中： 1name byte ‘iloveu’，0 ;字符串结汇通常带有二进制的0，占用一个字节。 二：立即数的存储在汇编语言中将一个常量存储在内存空间需要通过mov操作，立即数为一个常量。 将5存储在变量num1中 num1 sdword ？; mov num1 5; mov操作后面两个参数为内存或寄存器，mov两个参数可以为以下关系： mov mem , imm 将立即数存储到内存中 mov reg, mem 将内存单元的数据存储到寄存器中 mov mem, reg 将寄存器中的内容存储到内存单元中 mov reg, imm 将立即数存储在寄存器单元中 mov reg, reg 将第二个寄存器中的内容存储到第一个寄存器中 但是不能mov mem, mem， 不能将一个内存中的内容存储到另一个内存中 需要通过mov reg， mem1； mov mem2 reg；可达到目的。 三：寄存器数据不能直接从一个内存单元中移动到另一个内存单元中，需通过寄存器做中转。 内存单元数据放在随机存储器(RAM)中，RAM将内存单元中的数据拷贝到CPU的寄存器中，然后将CPU的寄存器中的数据copy到另一个存储单元中。 将内存单元的内容复制到寄存器中的动作成为装载，将cpu中寄存器的数据copy到内存中成为存储。 不是所有的寄存器都可以被开发者使用，提供给程序员的寄存器为通用寄存器。 16位通用寄存器为ax,bx,cx,dx 32位通用寄存器为eax,ebx,ecx,edx 以eax举例，eax低16位为ax寄存器，ax寄存器低8位为al寄存器，高8位为ah寄存器。如图所示： eax为累加器，主要用于参与算术逻辑 ebx为基址寄存器，用于处理数组 ecx为计数器，用于循环操作 edx为数据寄存器，用于算术指令。 除此之外还有eflags表示状态的寄存器，esp堆栈指针指向栈顶部，ebp基址指针指向栈底部。 四：输入输出字符串的输出 C语言版： 123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%s\\n&quot;,&quot; Hello World!&quot;); return 0;&#125; 用汇编实现为： 12345678910111213 .386 .model flat ,c .stack 100hprintf PROTO arg1:Ptr Byte, printlist:VARARG .datamsg1fmt byte &quot;%s&quot;, 0Ah, 0msg1 byte &quot;Hello World&quot;, 0 .codemain proc INVOKE printf, ADDR msg1fmt, ADDR msg1 retmain endp end .386是一个汇编指令，它指明程序可以被汇编为在Intel386系列或更高级的计算机运行， .model flat表明程序使用保护模式，.model flat ,c表示该程序可以与C或C++程序进行连接，且需要运行在Visual C++环境中。 .stack 100h 表示堆栈的大小应该达到十六进制100个字节 printf 名称后面的 PROTO表示printf为函数原型， arg1表示printf第一个参数为指向Byte类型的Ptr指针。 第二个参数为VARARG类型可变参数printlist .data表示数据段，.code表示代码段。 msg1fmt 为byte类型的字符串,0Ah为16进制表示\\n,0表示字符串结尾\\0 msg1为byte类型的字符串，“Hello World” proc汇编指令表示一个过程，过程名称为main INVOKE 为汇编指令，调用函数printf完成输出， 格式为 INVOKE 函数名， 参数一，参数二 这里为msg1fmt字符串的首地址，以及msg1的首地址。 ADDR为取地址操作。 ret表示返回和C语言return 0一样。 main endp表示main proc结束 end表示整个汇编程序结束。 整数的输出和字符串类似，下面通过输入输出程序介绍汇编语言的输入和输出 123456789101112131415161718192021222324 .386 .model flat c .stack 100hprintf PROTO arg1:Ptr Byte, printlist:VARARGscanf PROTO arg2:Ptr Byte, inputlist:VARARG .datain1fmt byte &quot;%d&quot;, 0msg0fmt byte 0Ah, &quot;%s&quot;, 0msg1fmt byte 0Ah, &quot;%s%d&quot;, 0Ah, 0Ah, 0msg0 byte &quot;Enter an integer for num1: &quot;, 0msg1 byte &quot;The integer in num2 is: &quot;,0num1 sdword ?num2 sdword ? .codemain proc INVOKE printf, ADDR msg0fmt, ADDR msg0 INVOKE scanf, ADDR in1fmt, ADDR num1 mov eax, num1 mov num2, eax INVOKE printf, ADDR msg1fmt, ADDR msg1, num2 retmain endp end 输入和输出类似，C语言中输入函数为scanf 汇编程序通过 scanf PROTO arg2:Ptr Byte, inputlist:VARARGPROTO表示scanf为函数原型， 第一个参数为指向Byte的指针,第二个参数为可变参数scanf输入整数num1，需要取地址，所以会采用ADDR num1 将上述汇编转译为C语言 1234567891011#include&lt;stdio.h&gt;int main()&#123; int num1, num2; printf(&quot;\\n%s&quot;, &quot;Enter an integer for num1: &quot;); scanf(&quot;%d&quot;, &amp;num1); num2 = num1; printf(&quot;\\n%s%d\\n\\n&quot;, &quot;The integer in num2 is: &quot;, num2); return 0;&#125; 五：算数指令加法指令 add mem, imm 将立即数imm和内存单元mem中数值相加存储在mem中 add reg, mem 将内存mem中的数值和寄存器reg中的数值相加，结果存储在reg中 add reg, imm 将立即数imm和寄存器reg中数据相加存储在reg中 add mem, reg 将寄存器中的数据和内存单元mem中数据相加存储在mem中 add reg, reg 将寄存器中的数据和寄存器相加，最后存储在第一个reg中 注意：不可add mem, mem 也不可 add imm, imm 两个立即数没法相加结果也没办法存储 两个内存单元也没办法相加，和mov mem, mem是一样的，都不可以直接操纵两个内存。 减法指令 sub mem, imm 将内存单元mem中数据减去立即数imm存储在mem中 sub reg, mem 将寄存器reg中数据减去mem中的数据，存储在reg中。 sub mem, reg 将内存单元mem中数据减去寄存器reg中数据，结果存储在mem中 sub reg ,imm 将寄存器reg中的数据减去立即数imm，将结果存储在reg中 sub reg, reg 将第一个reg数据减去第二个reg数据，最后结果存储在第一个reg中 `注意：不可sub mem, mem 也不可 add imm, imm 两个立即数没法相减结果也没办法存储 两个内存单元也没办法相减，和mov mem, mem是一样的，都不可以直接操纵两个内存。` 乘法指令imul imul mem 将内存单元mem中的数据和寄存器eax中的数据相乘，结果存储在edx:eax中 imul reg 将寄存器reg中的数据和寄存器eax中的数据相乘，结果存储在edx:eax中 注意：imul 只有一个参数，这个参数只能为内存单元或者寄存器，不能是imm立即数 由于乘法指令imul可能会造成乘积位数大于乘数和被乘数的位数，所以将结果存储在edx:eax中 imul为有符号的乘法指令， mul为无符号的乘法指令， imul和mul参数只能为mem或reg，如果 想计算num = mem* 3；mem为内存单元数据，3为立即数 imul实现为 12345mov eax, 3imul memmov num, eax 除法指令idiv 和乘法指令类似，idiv 为有符号除法， div为无符号除法 进行除法操作前将被除数放入edx:eax中，除法操作后edx存储的为余数，eax存储的为商。 举例 num = 13/,5; 汇编语言实现过程先将13放入eax中，调用cdq 可以将eax内容扩展到edx:eax寄存器对中，将5放入内存单元或寄存器中，调用idiv最终edx存储为3，eax存储为2 汇编语言实现如下： 12345mov eax， 13mov ebx，5cdqidiv ebxmov num , eax cbw 指令可将字节转换为字，一个字为两个字节，即将al内容扩展到寄存器ax中 cwd 字转换为双字， 即将ax中的内容扩展到eax中 cdq 双字转换为4个字， 即将eax中内容扩充为edx:eax中。 只有cdq允许有符号位，所以进行idiv和div操作前执行cdq将eax中内容扩充到edx:eax中。 注意：idiv和div 只有一个参数，这个参数只能为内存单元或者寄存器，不能是imm立即数 自增自减指令 dec reg reg中的数据自减 dec mem mem中的数据自减 inc reg reg中数据自增 inc mem mem中数据自增。 注意：dec 和inc 只有一个参数，这个参数只能为内存单元或者寄存器，不能是imm立即数 取反指令，也就是求一个数的补码 neg mem neg imm 注意：neg 只有一个参数，这个参数只能为内存单元或者寄存器，不能是imm立即数 下面两个例子是综合计算 123456789101112131415; v = -w + m * 3 - y/(z-4) ;w,v,m,y, z分别为内存单元mov ebx, wneg ebxmov eax,3imul madd eax, ebxmov v ,eaxmov ebx, zsub ebx, 4mov eax, ycdqidiv ebxsub v, eax 汇编语言基础第一部分记录到此为止，下一篇跟进记录","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"win7 64位环境下配置汇编环境和程序设计","date":"2017-08-12T03:08:17.000Z","path":"2017/08/12/asmset/","text":"下载dosbox，并解压安装 下载地址： http://pan.baidu.com/s/1eRJbJAq 默认安装到C:\\Program Files (x86)\\DOSBox-0.74 安装成功后，双击该目录下DOSBox 0.74 Options.bat文件，弹出配置选项文本文档， 找到[autoexec]选项，在下面添加如下字段： 12MOUNT C D:\\masmpro set PATH=$PATH$;D:\\masmpro D：\\masmpro是我创建的汇编程序目录，这样每次启动dosbox，自动挂载到我自己的项目目录里。 当然也可以手动设置，启动dosbox，手动输入MOUNT C D:\\masmpro 然后回车 效果如下： 接下来输入C: 切换到C：目录下，此时输入dir可以看到D：\\masmpro里的文件下面配置masmpro，下载地址：http://pan.baidu.com/s/1jI4WENk 解压即可，将文件夹MASM内的内容拷贝到D：masmpro里，这其中包括之后再masmpro文件夹下建立一个hello.asm的汇编程序 123456789101112131415161718data segment ;数据段hello db &#x27;Hello,World!$&#x27;,0data endscode segment ;代码段 assume cs:code,ds:datastart: ;入口 mov ax,data mov ds,ax lea dx,hello mov ah,9h int 21h mov ah,4ch int 21hcode endsend start ;标志入口点 打开dosbox，输入masm hello.asm接着输入link hello链接目标文件最后运行hello.exe，输入hello直接运行到此为止windows 7 64位环境下汇编环境搭建成功，并且可以开始汇编语言的学习了。 我的公众号","categories":[{"name":"汇编","slug":"binary","permalink":"http://www.limerence2017.com/categories/binary/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.limerence2017.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"makefile学习笔记","date":"2017-08-12T02:54:02.000Z","path":"2017/08/12/makefile/","text":"之前都是手动编译的，最近也学了下makefile相关的知识，文件结构是这样的在server文件夹里有eventloop.h,eventloop.cpp, networking.h, networking.cpp, api_epoll.h, api_epoll.cpp,以及文件夹main,在main文件夹里有一个main.cpp文件。 先写一个简单的makefile 1234567891011121314151617./server: eventloop.o api_epoll.o networking.o main.o g++ -o ./server eventloop.o api_epoll.o networking.o main.omain.o: ./main/main.cpp eventloop.h api_epoll.h networking.h g++ -c ./main/main.cpp -o main.o eventloop.o: eventloop.cpp eventloop.h api_epoll.h g++ -c eventloop.cpp -o eventloop.oapi_epoll.o: api_epoll.cpp api_epoll.h eventloop.h g++ -c api_epoll.cpp -o api_epoll.onetworking.o: networking.cpp networking.h eventloop.h g++ -c networking.cpp -o networking.oclean: rm -f $(OBJS) $(TARGET) makefile基本写法是 目标:依赖项 command command表示编译规则，就是g++/gcc编译语句，：左边表示目标，右边表示依赖项要生成目标文件，必须找到对应的依赖项。 上述makefile要生成./server需要eventloop.o networking.o api_epoll.o.如果不存在就先生成这三个.o文件。或者这三个.o文件比./server新，那么就需要重新 生成./server。同理，要生成这些.o文件，需要依赖一些.h和.cpp，那么如果.h或者.cpp有改动，就需要重新生成.o文件，从而生成最新的./server文件。这是最直白的makefile。 对于一些编译规则和目标文件，依赖文件，我们可以采用变量的形式来替代，可以节省时间。 先了解下变量 CC表示用gcc编译 CXX表示用g++编译 INC_DIR表示包含的路径 CFLAGS表示C语言编译的选项：-c表示编译.c/.cpp文件成为.o文件 -Wall表示编译显示警告 -g表示允许gdb调试 -I表示包含路径 CXXFLAGS表示g++的编译选项 CPPFLAGS表示C语言预编译选项 HEADS 表示头文件 SOURCES表示源文件 OBJS 表示objs文件集合,所有.o文件 TARGET表示目标文件，最重要生成的文件 all 表示最终的目标 clean 是个为目标，make并不产生作用。 调用make clean 可以执行下面的命令行 rm -f $(OBJS) $(TARGET) 为了能读懂makefile，还需要了解一些makefile用到的函数 $(SOURCES:.cpp=.o)表示将SOURCES中的cpp文件全部替换为.o为后缀的文件，这样可以达到不用一个一个去写.o文件的作用。 $(wilcard ./*.cpp)表示在目录./*.cpp下的所有文件，包含路径显示出来。 patsubst函数格式 $(patsubst pattern, replacement, text) 用法如下 $(patsubst %.c, %.o, $(wildcard *.c)) 将当前目录下.c结尾的文件替换为.o结尾的文件除此之外，还需要了解的就是一些自动变量 $&lt; 表示依赖项中第一个依赖项的名字 $@ 表示目标项中目标的名称 $^ 依赖性中所有不重复的依赖项文件，中间用空格区分 从而我们有了一个改良版本 123456789101112131415161718192021222324252627282930313233CC = gccCXX = g++INC_DIR = ./CFLAGS = -c -WallCFLAGS += -gCFLAGS += -I$(INC_DIR)CXXFLAGS = $(CFLAGS)HEADS = $(wildcard $(INC_DIR)/*.h)SOURCES = $(wildcard ./*.cpp)OBJS = $(SOURCES:.cpp=.o)TARGET = ./serverall:$(TARGET)$(TARGET): $(OBJS) $(CXX) -o $@ $(OBJS) ./main/main.cppeventloop.o: eventloop.cpp eventloop.h api_epoll.h $(CXX) $(CXXFLAGS) $&lt; -o $@api_epoll.o: api_epoll.cpp api_epoll.h eventloop.h $(CXX) $(CXXFLAGS) $&lt; -o $@networking.o: networking.cpp networking.h eventloop.h $(CXX) $(CXXFLAGS) $&lt; -o $@clean: rm -f $(OBJS) $(TARGET) makefile有个自动推导规则，那就是会根据目标文件.o推导出对应名称的.c依赖项，连command编译规则也会自动生成。 举个例子 123eventloop.o:eventloop.cpp eventloop.h api_epoll.h $(CXX) $(CXXFLAGS) $&lt; -o $@ makefile 会自动搜寻eventloop.cpp 自动执行$(CXX) $(CXXFLAGS) $&lt; -o $@ 所以上面两句可以简化为 eventloop.o: eventloop.h api_epoll.h从而生成了一个我们简化的自动推导版本 123456789101112131415161718192021222324252627282930CC = gccCXX = g++INC_DIR = ./CFLAGS = -c -WallCFLAGS += -gCFLAGS += -I$(INC_DIR)CXXFLAGS = $(CFLAGS)HEADS = $(wildcard $(INC_DIR)/*.h)SOURCES = $(wildcard ./*.cpp)OBJS = $(SOURCES:.cpp=.o)TARGET = ./serverall:$(TARGET)$(TARGET): $(OBJS) $(CXX) -o $@ $(OBJS) ./main/main.cppeventloop.o: eventloop.h api_epoll.hapi_epoll.o: api_epoll.h eventloop.hnetworking.o: networking.h eventloop.hclean: rm -f $(OBJS) $(TARGET) 下面是静态规则 makefile有个静态规则，也相当于推导规则 格式如下 123&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt; ... `targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。` `target-parrtern是指明了targets的模式，也就是的目标集模式。` `prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义` 举个例子 12$(OBJS):%.o:%.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@ OBJS中.o文件是目标的模式， %.c是依赖项的模式 在OBJS中找到eventloop.o，那么推断出eventloop.cpp为对应的依赖文件,从而采取$(CXX) $(CXXFLAGS) $&lt; -o $@编译 下面是根据静态模式写的makefile 12345678910111213141516171819202122232425262728CC = gccCXX = g++INC_DIR = ./CFLAGS = -c -WallCFLAGS += -gCFLAGS += -I$(INC_DIR)CXXFLAGS = $(CFLAGS)HEADS = $(wildcard $(INC_DIR)/*.h)SOURCES = $(wildcard ./*.cpp)OBJECTS = $(SOURCES:.cpp=.o)TARGET = ./serverall:$(TARGET)$(TARGET): $(OBJECTS) $(SOURCES) $(HEADS) $(CXX) -o $@ $(OBJECTS) ./main/main.cpp$(OBJECTS):%.o:%.cpp $(HEADS) $(CXX) $(CXXFLAGS) $&lt; -o $@clean: rm -f $(OBJECTS) $(TARGET) 至此，makefile我就了解了这么多，也可以写一些中小型项目makefile了我的公众号，谢谢关注","categories":[{"name":"Linux","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Linux环境编译动态库和静态库总结","date":"2017-08-08T13:08:58.000Z","path":"2017/08/08/linuxso/","text":"对Linux环境动态库和静态库的一些基础知识做一些总结， 首先总结静态库的编译步骤。1 先基于.cpp或者.c文件生成对应的.o文件 2将几个.o文件 使用ar -cr命令 生成libname.a文件 libname.a 为静态库， name 为静态库的名字， 可以根据模块功能命名。 举个例子 在当前目录下，有一个mymethod.h文件 在mymethod.cpp里实现这两个函数 在当前目录下有一个main.cpp文件 为了方便使用，将mymethod.cpp封装成静态库和动态库 首先将mymethod.cpp 编译成目标文件 g++ -c mymethod.cpp -o mymethod.o然后根据目标文件生成静态库 ar -cr libmymethod.a mymethod.oar命令可以用来创建、修改库，也可以从库中提出单个模块 -c 选项表示 创建一个库。不管库是否存在，都将创建 -r 选项表示 将模块插入库，如果库中有对应的模块，那么进行更新 如果把多个.o文件插入库.a里,只需要在后面用空格分开写出来 格式 ar -cr 静态库libname.a name1.o name2.o 静态库的命名有规则,格式为lib+库名+.a 生成静态库libmymethod.a后， 编译main.cpp 连接静态库生成可执行文件main g++ main.cpp -o main -I ./ -L ./ -lmymethod-I选项表示头文件路径 -L表示静态库或者动态库的路径 链接静态库写成 -l库名即可：-lmymethod 运行./main 可以输出结果 下面是动态库的编译动态库的命名是lib+库名+.so 动态库需要使用-shared 选项以及-fPIC选项 g++ -c -fPIC mymethod.cpp -o mymethod.o-fPIC表示代码是和地址无关的，不需要被不同模块重定位 然后根据目标文件生成动态库.so文件 g++ -shared -o libmymethodso.so mymethod.o-shared 选项表示生成的是.so动态库文件 下一步是链接动态库 g++ main.cpp -o main -I ./ -L ./ -lmymethodso此时不能直接运行./main否则会提示找不到对应的动态库 上面的步骤可以直接写成一句话 g++ -shared -fPIC mymethod.cpp -o libmymethodso.so 我们现在有几种方式配置动态库的路径 第一种 export LD_LIBRARY_PATH=&quot;./:$LD_LIBRARY_PATH&quot;这种方式将动态库路径配置到LD_LIBRARY_PATH,只是暂时生效 第二种 使用 ldconfig 机制（需 root 权限）：● 首先，在 /etc/ld.so.conf.d/ 下创建一个 .conf 文件，如 libmymethod.conf ，内容为共享库所在目录的绝对路径● 然后，运行 ldconfig 第一种比较简单，配置好后可以直接运行./main 第二种按照操作进入/etc/ld.so.conf.d/, 然后创建mymethod.conf用vi打开mymethod.conf，添加动态库的绝对路径 /home/secondtonone/soando最后运行ldconfig, 即可生效了。 这样就可以运行./main 现在对动态库路径配置做一个总结 解决共享库路径问题 gcc/g++ 编译期 :● 使用 ­L 选项指定所需链接的共享库所在目录（如果共享库或其连接文件位于 /usr/lib 、 /usr/local/lib 或由 LD_LIBRARY_PATH 指定的目录下，则不需指定该选项）● 使用 ­l 选项指定所需链接的共享库名称（无前缀、后缀） 程序运行期：● 使用 LD_LIBRARY_PATH 环境变量来指定所需引用的共享库所在目录 ( 临时指定或永久性写入相关文件，普遍适用于 UNIX 世界 )● 使用 ldconfig 机制（需 root 权限）：● 首先，在 /etc/ld.so.conf.d/ 下创建一个 .conf 文件，如 libmymethod.conf ，内容为共享库所在目录的绝对路径● 然后，运行 ldconfig 我的公众号，谢谢关注下。","categories":[{"name":"Linux","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"pthread_cond_wait学习笔记","date":"2017-08-08T12:49:06.000Z","path":"2017/08/08/pthreadwait/","text":"近期学习了线程等待和激活的相关知识。 先介绍几个api： pthread_cond_t表示多线程的条件变量，用于控制线程等待和就绪的条件。 一：条件变量的初始化：条件变量和互斥锁一样，都有静态动态两种创建方式， 静态方式使用PTHREAD_COND_INITIALIZER常量初始化。 pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 动态方式初始化： 1 首先要new或者malloc一个pthread_cond_t类型变量，用完后记得delete或者free掉。 2动态方式调用pthread_cond_init()函数，API定义如下： int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr); 二：条件变量的销毁注销一个条件变量需要调用pthread_cond_destroy()，只有在没有线程在该条件变量上等待的时候才能注销这个条件变量，否则返回EBUSY。因为Linux实现的条件变量没有分配什么资源，所以注销动作只包括检查是否有等待线程。API定义如下：int pthread_cond_destroy(pthread_cond_t *cond) new开辟的pthread_cond_t记得在调用pthread_cond_destroy()后调用delete或者free销毁掉。 三：等待和触发 1条件等待int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex); 2时间等待int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime); 其中计时等待方式如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待，其中abstime以与time()系统调用相同意义的绝对时间形式出现，0表示格林尼治时间1970年1月1日0时0分0秒。 无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。 使用pthread_cond_wait方式如下： `pthread _mutex_lock(&amp;mutex)` `while或if(线程执行的条件不成立)` `pthread_cond_wait(&amp;cond, &amp;mutex);` `线程执行` `pthread_mutex_unlock(&amp;mutex);` 3激发条件有两种形式pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。 上面就是多线程条件变量的基础知识，下面着重阐述下为什么调用pthread_cond_wait之前要加锁，以及pthread_cond_wait内部调用了什么。首先解释为什么在等待前加锁，因为线程隶属于进程，线程共享进程的资源，如果不进行加锁，就会造成多个线程同时（相对意义的同时， 可能一个线程在函数A中更改此共享资源，此时函数A没结束，另一个线程也访问了这个共享资源）访问这块共享的资源，如果对临界区的内容进行更改，那么两个线程就会造成数据的不准确。所以在更改临界资源的时候要枷锁。而调用pthread_cond_wait之前要加锁也是为了避免多个线程竞争一个条件，造成共享的资源被多个线程更改。所以需要互斥的访问共有资源，那么在pthread_cond_wait之前需要加锁，避免别的线程更改共有资源。接下来思考pthread_cond_wait内部做了哪些操作。在pthread_cond_wait调用之前，线程调用pthread_mutex_lock,设置锁，如果条件不满足，那么该线程处于阻塞等待的状态。别的线程 发现条件满足后会调用pthread_cond_signal或pthread_cond_broadcast通知他。那么问题出来了，如果该线程不解锁，别的线程是没办法更改共享资源的，也就没办法设置条件变量使其满足该线程的等待条件，出现死锁。所以，pthread_cond_wait会在内部进行解锁操作。别的线程可以访问共享资源，更改条件触发该线程，是该线程从阻塞状态变为就绪。慢一点，还有一个重要的步骤，pthread_cond_wait会将该线程放到线程等待队列里，那么是在放到等待队列之前解锁还是放到等待队列之后才解锁呢？对于这点apue给出的解释：The mutex passed to pthread_cond_wait protects the condition.The caller passes it locked to the function, which then atomically places the calling thread on the list of threads waiting for the condition and unlocks the mutex. This closes the window between the time that the condition is checked and the time that the thread goes to sleep waiting for the condition to change, so that the thread doesn’t miss a change in the condition. When pthread_cond_wait returns, the mutex is again locked. 这段话的意思是mutex传递给pthread_cond_wait 用于保护条件，调用者将mutex传递给pthread_cond_wait，pthread_cond_wait 会自动将调用该函数的线程放到线程等待队列上，等待条件并且解锁。这种做法关闭了一段间隙，这段间隙就是在我们检测条件的时刻和将线程放到等待队列休眠的时刻之间，这么做该线程不会错过条件的改变。而当pthread_cond_wait 返回时，mutex又被上锁了。所以，pthread_cond_wait内部的操作顺序是将线程放到等待队列，然后解锁，等条件满足时进行加锁，然后返回。整理下pthread_cond_wait内部操作1，线程放在等待队列上，解锁 2，等待 pthread_cond_signal或者pthread_cond_broadcast信号之后去竞争锁 3，若竞争到互斥锁则加锁。 使用流程 等待线程： pthread_mutex_lock(&amp;mutex); while或if(条件不满足) pthread_cond_wait(&amp;cond, &amp;mutex); //处理共享资源 pthread_mutex_unlock(&amp;mutex); 激活线程： pthread_mutex_lock(&amp;mutex); pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); 下面写了一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;iostream&gt;using namespace std;int count = 0;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //该函数增加count数值void * creator(void * arg)&#123; cout &lt;&lt; &quot;creator add lock&quot; &lt;&lt; endl; pthread_mutex_lock(&amp;mutex); count ++; cout &lt;&lt; &quot;in creator count is : &quot; &lt;&lt; count &lt;&lt; endl; //条件满足时发送信号 if(count &gt; 0) &#123; pthread_cond_signal(&amp;cond); &#125; cout &lt;&lt; &quot;creator release lock&quot; &lt;&lt; endl; pthread_mutex_unlock(&amp;mutex); return NULL;&#125;//该函数减少count数值void * consumer(void * arg)&#123; cout &lt;&lt; &quot;consumer add lock&quot; &lt;&lt; endl; pthread_mutex_lock(&amp;mutex); //当条件不满足时等待 while(count &lt;= 0) &#123; cout &lt;&lt; &quot;begin wait&quot; &lt;&lt; endl; pthread_cond_wait(&amp;cond,&amp;mutex); cout &lt;&lt; &quot;end wait&quot; &lt;&lt; endl; &#125; count --; cout &lt;&lt; &quot;in consumer count is &quot; &lt;&lt; count &lt;&lt; endl; pthread_mutex_unlock(&amp;mutex); cout &lt;&lt; &quot;consumer release lock&quot; &lt;&lt; endl; return NULL; &#125;int main()&#123; //两个线程，一个生产者线程一个消费者线程 pthread_t createthread,consumethread; pthread_create(&amp;consumethread, NULL, consumer, NULL); sleep(2); pthread_create(&amp;createthread, NULL, creator, NULL); //主进程等待两个线程结束 pthread_join(createthread, NULL); pthread_join(consumethread, NULL); return 0;&#125; 因为消费者线程先跑起来，会等待生产者增加count数量，所以打印输出结果如下 下面将消费者和生产者线程增加几个，creater和consumer内部用循环处理，这样就能看出效果了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192void * creator(void * arg)&#123; int i = 0; while(i&lt;300) &#123; i++; cout &lt;&lt; &quot;creator add lock&quot; &lt;&lt; endl; pthread_mutex_lock(&amp;mutex); count ++; cout &lt;&lt; &quot;in creator count is : &quot; &lt;&lt; count &lt;&lt; endl; if(count &gt; 0) &#123; pthread_cond_signal(&amp;cond); &#125; cout &lt;&lt; &quot;creator release lock&quot; &lt;&lt; endl; pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125;void * consumer(void * arg)&#123; int i = 0; while(i &lt; 100) &#123; i++; cout &lt;&lt; &quot;consumer add lock&quot; &lt;&lt; endl; pthread_mutex_lock(&amp;mutex); while(count &lt;= 0) &#123; cout &lt;&lt; &quot;begin wait&quot; &lt;&lt; endl; pthread_cond_wait(&amp;cond,&amp;mutex); cout &lt;&lt; &quot;end wait&quot; &lt;&lt; endl; &#125; count --; cout &lt;&lt; &quot;in consumer count is &quot; &lt;&lt; count &lt;&lt; endl; pthread_mutex_unlock(&amp;mutex); cout &lt;&lt; &quot;consumer release lock&quot; &lt;&lt; endl; &#125; return NULL; &#125;int main()&#123; pthread_t createthread[2],consumethread[3]; for(int i = 0; i &lt; 3; i++) &#123; pthread_create(&amp;consumethread[i], NULL, consumer, NULL); &#125; for(int i = 0; i &lt; 2; i++) &#123; pthread_create(&amp;createthread[i], NULL, creator, NULL); &#125; for(int i = 0; i &lt; 2; i++) &#123; pthread_join(createthread[i], NULL); &#125; for(int i = 0; i &lt; 3; i++) &#123; pthread_join(consumethread[i], NULL); &#125; return 0;&#125; 截取一部分结果截图，可以看出数字是连续变动的，而且加锁解锁内数字才变动，说明我们对锁和条件变量使用合理。 我的公众号，关注下吧。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Linux环境崩溃生成core文件以及调试","date":"2017-08-07T09:45:05.000Z","path":"2017/08/07/linuxcore/","text":"Windows环境崩溃问题可根据vs调试工具查看，Linux同样可以查看调用堆栈的信息，只是 需要更改Linux设置，使程序崩溃时候产生core文件。然后gdb调试即可。 1产生core文件方法产生coredump的条件，首先需要确认当前会话的ulimit –c，若为0，则不会产生对应的coredump，需要进行修改和设置。 ulimit -c unlimited (可以产生coredump且不受大小限制)，这种设置仅对当前生效，如果想永久生效 那么需要在 /etc/profile中加入以下一行，这将允许生成coredump文件 ulimit-c unlimited 2更改core dump生成路径因为core dump默认会生成在程序的工作目录，但是有些程序存在切换目录的情况，导致core dump生成的路径没有规律， 所以最好是自己建立一个文件夹，存放生成的core文件。 我建立一个 /data/coredump 文件夹，在根目录data里的coredump文件夹。 调用如下命令 echo /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern 将更改core文件生成路径，自动放在这个/data/coredump文件夹里。 %e表示程序名， %p表示进程id 3测试生成core文件以及调试12345678910111213141516171819#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;void core_test1()&#123; int i = 0; //below will call segmentfault scanf(&quot;%d&quot;, i); printf(%d, i); &#125;int main()&#123; core_test1(); return 0;&#125; 该程序在core_test1()内部scanf的时候回崩溃，i前面应该加上&amp; 编译的时候带上-g选项，这样才能用gdb调试core 运行后结果显示段错误 进入/data/coredump文件夹可以查看生成的core用gdb调试该core，命令为 gdb core.ctest.6408 ,显示如下 program terminated with signal 11 告诉我们信号中断了我们的程序 敲命令： bt 可以打印堆栈信息 这个一堆问号很多人遇到过，有人说是没加载符号表，有人说是标准glibc版本不一致， 可以通过如下命令调试： gdb 可执行程序exe 进入gdb环境后 core-file core的名字 敲命令bt可以查看准确信息。 示例： gdb ./ctest进入gdb环境后，敲core-file /data/coredump/core.ctest.6408敲bt命令，这是gdb查看back trace的命令 可以看到最近的栈中存储的是调用了IO操作，之前一步是scanf，再往前能看到是 ctest.cpp中第九行 core_test1()函数出错。 到此为止，就是core文件配置生成和调试方法 关注我的公众号：","categories":[{"name":"Linux","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"对于redis底层框架的理解(一)","date":"2017-08-07T09:35:13.000Z","path":"2017/08/07/redis1/","text":"近期学习了redis底层框架，好多东西之前都没听说过，算是大开眼界了。先梳理下redis正常的通讯流程吧首先服务器启动都有主函数main，这个main函数就在redis.c里 首先是initserverconfig()，在这里初始化了redisserver基本的配置信息， 接着调用loadServerConfig(char *filename) 对 server 全局变量重新初始化。 然后是调用daemonize()，实现守护进程，脱离了控制台，使这个进程成为独立的首领进程 接下来是initServer()，这个过程很重要，完成了事件驱动的注册和一些回调函数的绑定，回头仔细说这个函数里面的功能 初始化服务器过后aeSetBeforeSleepProc()，设置了服务器休眠之前会 调用beforeSleep函数,然后进入主要的事件轮询函数 aeMain(server.el)，在这里完成事件的派发 最后事件轮询过后我们调用aeDeleteEventLoop，释放之前开辟的内存， 结束进程。 中间略去一些琐碎的过程，我们总结一下 initserverconfig() ----&gt; loadServerConfig------&gt; daemonize()-------&gt; initServer()-----&gt; aeSetBeforeSleepProc()------&gt;aeMain()-----&gt;aeDeleteEventLoop 接下来详细说一下每一个步骤都做了什么。 看一下main()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int main(int argc, char **argv) &#123; //设置时间，一般都是设置事件poll等待多长时间返回 struct timeval tv; /* We need to initialize our libraries, and the server configuration. */ #ifdef INIT_SETPROCTITLE_REPLACEMENT //进程重命名 spt_init(argc, argv); #endif //好像是更改字符编码 setlocale(LC_COLLATE,&quot;&quot;); //设置多线程安全模式 zmalloc_enable_thread_safeness(); //注册内存使用过量报错的函数 zmalloc_set_oom_handler(redisOutOfMemoryHandler); srand(time(NULL)^getpid()); gettimeofday(&amp;tv,NULL); //哈希种子 dictSetHashFunctionSeed(tv.tv_sec^tv.tv_usec^getpid()); //服务器的启动模式：单机模式、Cluster模式、sentinel模式 server.sentinel_mode = checkForSentinelMode(argc,argv); initServerConfig(); loadServerConfig(configfile,options); 。。。 //创建守护进程 if (server.daemonize) daemonize(); //初始化服务器 initServer(); //设置服务器sleep之前的函数调用 aeSetBeforeSleepProc(server.el,beforeSleep); //主函数事件驱动 aeMain(server.el); //删除事件循环的结构，释放空间 aeDeleteEventLoop(server.el); return 0;&#125; 谢谢关注我的公众号：","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IO多路复用之epoll(一)讲解","date":"2017-08-07T09:25:29.000Z","path":"2017/08/07/epoll1/","text":"网络通信中socket有自己的内核发送缓冲区和内核接受缓冲区，好比是一个水池，当用户发送数据的时候会从用户缓冲区拷贝到socket的内核发送缓冲区，然后从 socket发送缓冲区发出去, 当用户要读取数据时，就是从socket内核读缓冲区读到用户缓冲区。所以TCP中recv, send, read, write等函数并不是真的直接读写 发送报文，而是将数据分别写到socket内核缓冲区，或者从socket内核缓冲区读到用户区。 对于读有两种状态，可读和不可读，当用户从socket中读取数据的时候，如果socket读缓冲区内容为空，那么读数据会失败，阻塞情况下会等待数据到来，非阻塞情况下 会返回一个EWOULDBLOCK 或者EAGAIN，反之如果读缓冲区内容不为空，那么就会返回读到的字节数。 对于用户向socket中写数据，存在可写和不可写，如果socket写缓冲区内容满了，此时向socket写缓冲区里写数据会失败，阻塞情况下会等待socket的写缓冲区非满(有空闲空间)，非阻塞情况下回返回-1，根据errono 为EWOULDBLOCK或者EAGAIN，判断写缓冲区满 反之，如果socket写缓冲区此时非满，那么写会成功，返回写入的字节数。 综上所述，对于读的情况，我们关注socket读缓冲区空还是非空，对于写的情况，我们关注 写缓冲区满还是非满。 讲述epoll 的几个参数含义 EPOLLIN：关联文件用来监听读事件EPOLLOUT:关联文件用来监听写事件 POLLRDNORM，有普通数据可读。POLLRDBAND，有优先数据可读。POLLPRI，有紧迫数据可读。 POLLWRNORM，写普通数据不会导致阻塞。POLLWRBAND，写优先数据不会导致阻塞。POLLMSG，SIGPOLL消息可用。此外，还可能返回下列事件：POLLER，指定的文件描述符发生错误。POLLHUP，指定的文件描述符挂起事件。POLLNVAL，指定的文件描述符非法。 EPOLL有两种模式LT（水平触发模式）ET（边缘触发模式） LT：水平触发 一直触发1 内核中的socket接受缓冲区不为空，那么有数据可读，一直出发读事件2 内核中的socket发送缓冲区不满，可以继续写入数据，写事件一直出发试想一下，如果一开始就关注EPOLLOUT，会是什么情况呢？对于LT模式，由于刚开始socket的发送缓冲区肯定是空的，那么由于socket的发送缓冲区可以一直写数据，所以写事件会一直触发。正确的做法是，我们向socket中写数据，当返回EAGAIN(socket发送缓冲区满了)的时候，这个时候如果关注EPOLLOUT，当socket发送缓冲区由满变为非满，会触发写事件。这个时候，就从应用缓冲区取出数据拷贝到内核缓冲区。如果应用缓冲区的数据已经全部拷贝到内核缓冲区，说明数据全部在socket的发送缓冲区，就取消EPOLLOUT的关注，如果应用缓冲区还有数据没拷贝完全，就不需要取消对EPOLLOUT的关注。 优点是对于read操作比较简单，只要有read事件就读，读多读少都可以。缺点是write相关操作较复杂， 由于socket在空闲状态发送缓冲区一定是不满的， 故若socket一直在epoll wait列表中，则epoll会一直通知write事件，所以必须保证没有数据要发送的时候，要把socket的write事件从epoll wait列表中删除。而在需要的时候在加入回去，这就是LT模式的最复杂部分。 ET：边沿触发模式由未就绪变为就绪状态才可触发，比如写事件由缓冲区满变为缓冲区非满，读事件由缓冲区空到非空才触发1.内核中socket接受缓冲区不为空，那么有数据可读，可以触发读事件，但是对于边缘模式，只触发一次例如，当listen一个文件描述符，当有很多新的连接连上来的时候，只触发一次。所以要在循环中accept，取出所以新连接上来的socket例如，当监听的socket有读事件，一定要读完所有的数据，否则之后到来的数据就会被漏掉。解决办法是在循环体内读取数据，直到读完或者读出的返回值为EAGIN（缓冲区为空）才可以。对于写事件，发送数据，直到发送完或者产生EAGIN（缓冲区为满）ET模式下，只有socket的状态发生变化时才会通知，也就是读取缓冲区由无数据到有数据时通知read事件，发送缓冲区由满变成未满通知write事件。 缺点是epoll read事件触发时，必须保证socket的读取缓冲区数据全部读完（事实上这个要求很容易达到）优点：对于write事件，发送缓冲区由满到未满时才会通知，若无数据可写，忽略该事件，若有数据可写，直接写。当向socket写数据，返回的值小于传入的buffer大小或者write系统调用返回EWouldBlock时，表示发送缓冲区已满。 平时大家使用 epoll 时都知道其事件触发模式有默认的 level-trigger 模式和通过 EPOLLET 启用的 edge-trigger 模式两种。从 epoll 发展历史来看，它刚诞生时只有 edge-trigger 模式，后来因容易产生 race-cond 且不易被开发者理解，又增加了 level-trigger 模式并作为默认处理方式。二者的差异在于 level-trigger 模式下只要某个 fd处于 readable/writable 状态，无论什么时候进行 epoll_wait 都会返回该 fd；而 edge-trigger 模式下只有某个 fd 从 unreadable 变为 readable 或从 unwritable 变为 writable 时，epoll_wait 才会返回该 fd。 然后我们来说说epoll几个函数epoll的接口非常简单，一共就三个函数：1 int epoll_create(int size);创建一个epoll句柄，size用来告诉内核这个监听的数目一共有多大。size为最大监听数量+1，因为创建好epoll句柄后，他就会占用一个fd值，在linux下如果查看/proc/进程/id/fd/，能看到这个fd，使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 2 int epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);epoll的事件注册函数，先注册想要监听的事件类型，第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示： EPOLL_CTL_ADD：注册新的fd到epfd中EPOLL_CTL_MOD:修改已经注册的fd的监听事件；EPOLL_CTL_DEL:从epfd中删除一个fd第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下： 1234567891011typedef union epoll_data &#123;void *ptr;int fd;__uint32_t u32;__uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123;__uint32_t events; /* Epoll events */epoll_data_t data; /* User data variable */&#125;; events可以是以下几个宏的集合：EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 3 int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int tiemout);等待事件产生，参数events用来从内核中得到事件的集合，maxevents告知内核这个events有多大，这个maxevents的值不能大于创建epoll_create()的size，参数timeout是超时时间，毫秒，0表示立即返回，-1会永久阻塞。该函数返回需要处理的事件数目，如果返回0，表示已超时。 下面我查阅相关资料，仿照别人写了一个类似的epoll demo代码，这个是LT的，下一篇写ET的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ERR_EXIT(m) \\do \\&#123; \\perror(m); \\exit(EXIT_FAILURE); \\&#125; while(0)//先定义一个类型，epoll_event连续的存储空间，可以是数组，也可以是vector//当然也可以malloc一块连续内存 (struct epoll_event *)malloc(n * sizeof(struct epoll_event));typedef std::vector&lt;struct epoll_event&gt; EventList;int main()&#123; //打开一个空的描述符 int idlefd = open(&quot;/dev/null&quot;,O_RDONLY|O_CLOEXEC); //生成listen描述符 int listenfd = socket(PF_INET, SOCK_CLOEXEC | SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP); if(listenfd &lt; 0) &#123; ERR_EXIT(&quot;socketfd&quot;); &#125; //初始化地址信息 struct sockaddr_in servaddr; memset(&amp;servaddr,0 ,sizeof(struct sockaddr_in)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(6666); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); int on = 1; if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0) ERR_EXIT(&quot;setsockopt&quot;); if(bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr))) ERR_EXIT(&quot;bindError&quot;); if (listen(listenfd, SOMAXCONN) &lt; 0) ERR_EXIT(&quot;listen&quot;); //记录客户端连接对应的socket std::vector&lt;int&gt; clients; //创建epollfd, 用于管理epoll事件表 int epollfd; epollfd = epoll_create1(EPOLL_CLOEXEC); struct epoll_event event; event.data.fd = listenfd; event.events = EPOLLIN; //将listenfd加入到epollfd管理的表里 epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &amp;event); //创建长度为16的epoll_event队列 EventList events(16); //用于接收新连接的客户端地址 struct sockaddr_in peeraddr; socklen_t peerlen; int connfd; int nready; while(1) &#123; nready = epoll_wait(epollfd, &amp;*events.begin(), static_cast&lt;int&gt;(events.size()), -1); if (nready == -1) &#123; if (errno == EINTR) continue; ERR_EXIT(&quot;epoll_wait&quot;); &#125; if (nready == 0) // nothing happended continue; //大小不够了就重新开辟 if ((size_t)nready == events.size()) events.resize(events.size()*2); for (int i = 0; i &lt; nready; ++i) &#123; //判断wait返回的events数组状态是否正常 if ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp; EPOLLIN))) &#123; fprintf (stderr, &quot;epoll error\\n&quot;); close (events[i].data.fd); continue; &#125; if (events[i].data.fd == listenfd) &#123; peerlen = sizeof(peeraddr); //LT模式accept不用放在while循环里 connfd = ::accept4(listenfd, (struct sockaddr*)&amp;peeraddr, &amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC); //accept失败，判断是否是文件描述符达到上限 if (connfd == -1) &#123; if (errno == EMFILE) &#123; //关闭之前打开的描述符，重新accept，然后关闭这个accept得到的描述符， //因为LT模式，如果socket读缓冲区有数据一直读取失败会造成busyloop close(idlefd); idlefd = accept(listenfd, NULL, NULL); close(idlefd); idlefd = open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC); continue; &#125; else ERR_EXIT(&quot;accept4&quot;); &#125; std::cout&lt;&lt;&quot;ip=&quot;&lt;&lt;inet_ntoa(peeraddr.sin_addr)&lt;&lt; &quot; port=&quot;&lt;&lt;ntohs(peeraddr.sin_port)&lt;&lt;std::endl; clients.push_back(connfd); //将connd加入epoll表里，关注读事件 event.data.fd = connfd; event.events = EPOLLIN ; epoll_ctl(epollfd, EPOLL_CTL_ADD, connfd, &amp;event); &#125; else if (events[i].events &amp; EPOLLIN) &#123; connfd = events[i].data.fd; if (connfd &lt; 0) continue; char buf[1024] = &#123;0&#125;; int ret = read(connfd, buf, 1024); if (ret == -1) //ERR_EXIT(&quot;read&quot;); &#123; if((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123; //由于内核缓冲区空了，下次再读， //这个是LT模式不需要重新加入EPOLLIN事件,下次还会通知 continue; &#125; ERR_EXIT(&quot;read&quot;); &#125; if (ret == 0) &#123; std::cout&lt;&lt;&quot;client close&quot;&lt;&lt;std::endl; close(connfd); event = events[i]; epoll_ctl(epollfd, EPOLL_CTL_DEL, connfd, &amp;event); clients.erase(std::remove(clients.begin(), clients.end(), connfd), clients.end()); continue; &#125; // std::cout&lt;&lt;buf; write(connfd, buf, strlen(buf)); &#125; else //写事件 if(events[i].events &amp; EPOLLOUT) &#123; connfd = events[i].data.fd; char buf[512]; int count = write(events[i].data.fd, buf, strlen(buf)); if(count == -1) &#123; if((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123; //由于内核缓冲区满了，下次再写， //这个是LT模式不需要重新加入EPOLLOUT事件 continue; &#125; ERR_EXIT(&quot;write&quot;); &#125; //写完要记得从epoll内核中删除，因为LT模式写缓冲区不满就会触发EPOLLOUT事件，防止busyloop event.data.fd = connfd; event.events = EPOLLOUT; epoll_ctl (epollfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;event); //close 操作会将events[i].data.fd从epoll表里删除，所以上面的操作可以不写 //close(events[i].data.fd); 此处是关闭了和客户端的连接，不关闭也可以，只和策划需求有关 &#125; &#125; &#125;return 0; &#125; 好了，这就是epoll 的LT模式，demo源代码下载地址 http://download.csdn.net/detail/secondtonone1/9484752。 谢谢关注我的公众号","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IO多路复用之epoll（二）","date":"2017-08-07T09:18:23.000Z","path":"2017/08/07/epoll2/","text":"前一篇介绍了epoll的LT模式，LT模式注意epollout事件在数据全部写成功后需要取消关注，或者更改为EPOLLIN。 而这次epoll的ET模式，要注意的是在读和写的过程中要在循环中写完或者读完所有数据，确保不要丢掉一些数据。 因为epoll ET模式只在两种边缘更改的时候触发，对于读事件只在内核缓冲区由空变为 非空通知一次用户，对于写事件，内核缓冲区只在由满变为非满的情况通知用户一次。 下面是代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310int main()&#123; int eventsize = 20; struct epoll_event * epoll_eventsList = (struct epoll_event *)malloc(sizeof(struct epoll_event) *eventsize); //打开一个空的描述符 int idlefd = open(&quot;/dev/null&quot;,O_RDONLY|O_CLOEXEC); cout &lt;&lt; &quot;idlefd&quot; &lt;&lt;idlefd &lt;&lt;endl; //生成listen描述符 int listenfd = socket(PF_INET, SOCK_CLOEXEC | SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP); if(listenfd &lt; 0) &#123; ERR_EXIT(&quot;socketfd&quot;); &#125; //初始化地址信息 struct sockaddr_in servaddr; memset(&amp;servaddr,0 ,sizeof(struct sockaddr_in)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(6667); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); int on = 1; if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0) ERR_EXIT(&quot;setsockopt&quot;); if(bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr))) ERR_EXIT(&quot;bindError&quot;); if (listen(listenfd, SOMAXCONN) &lt; 0) ERR_EXIT(&quot;listen&quot;); //记录客户端连接对应的socket std::vector&lt;int&gt; clients; //创建epollfd, 用于管理epoll事件表 int epollfd; epollfd = epoll_create1(EPOLL_CLOEXEC); struct epoll_event event; event.data.fd = listenfd; event.events = EPOLLIN|EPOLLET; //将listenfd加入到epollfd管理的表里 epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &amp;event); //用于接收新连接的客户端地址 struct sockaddr_in peeraddr; socklen_t peerlen; int connfd; //为了简单起见写了个很大的数组，根据文件描述符存储内容 //其实很多项目代码采epoll.data.ptr回调具体的读写 vector&lt;string&gt; recievebuf; for(int i = 0 ; i &lt; 22222; i++) &#123; recievebuf.push_back(&quot;&quot;); &#125; while(1) &#123; int nready = epoll_wait(epollfd, epoll_eventsList, eventsize, -1); if (nready == -1) &#123; if (errno == EINTR) continue; ERR_EXIT(&quot;epoll_wait&quot;); &#125; if (nready == 0) continue; //大小不够重新开辟 if ((size_t)nready == eventsize) &#123; if(eventsize * 2 &gt;= 22222) &#123; ERR_EXIT(&quot;too many fds&quot;); &#125; struct epoll_event * epoll_eventsList2 = (struct epoll_event *)malloc(sizeof(struct epoll_event) * eventsize *2); if(epoll_eventsList2) &#123; memcpy(epoll_eventsList2,epoll_eventsList,sizeof(struct epoll_event) * eventsize); eventsize = eventsize * 2; free(epoll_eventsList); epoll_eventsList = epoll_eventsList2; &#125; &#125; for (int i = 0; i &lt; nready; ++i) &#123; //判断wait返回的events数组状态是否正常 if ((epoll_eventsList[i].events &amp; EPOLLERR) || (epoll_eventsList[i].events &amp; EPOLLHUP)) &#123; fprintf (stderr, &quot;epoll error\\n&quot;); close (epoll_eventsList[i].data.fd); continue; &#125; if (epoll_eventsList[i].data.fd == listenfd) &#123; peerlen = sizeof(peeraddr); //ET模式accept放在while循环里 do &#123; connfd = ::accept4(listenfd, (struct sockaddr*)&amp;peeraddr, &amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC); if(connfd &lt;= 0) break; std::cout&lt;&lt;&quot;ip=&quot;&lt;&lt;inet_ntoa(peeraddr.sin_addr)&lt;&lt; &quot; port=&quot;&lt;&lt;ntohs(peeraddr.sin_port)&lt;&lt;std::endl; clients.push_back(connfd); //将connd加入epoll表里，关注读事件 event.data.fd = connfd; event.events = EPOLLIN |EPOLLET; epoll_ctl(epollfd, EPOLL_CTL_ADD, connfd, &amp;event); cout &lt;&lt; &quot;loop&quot; &lt;&lt;endl; cout &lt;&lt; &quot;loop&quot; &lt;&lt; connfd &lt;&lt; endl; &#125;while(1); //accept失败，判断是否接收全所有的fd cout &lt;&lt; connfd &lt;&lt; endl; if (connfd == -1)&#123; if (errno != EAGAIN &amp;&amp; errno != ECONNABORTED &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR) &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt;endl; ERR_EXIT(&quot;accept&quot;); &#125; &#125; //所有请求都处理完成 cout &lt;&lt; &quot;continue&quot;&lt;&lt;endl; continue; &#125;//endif else if(epoll_eventsList[i].events &amp; EPOLLIN) &#123; connfd = epoll_eventsList[i].data.fd; if(connfd &gt; 22222) &#123; close(connfd); event = epoll_eventsList[i]; epoll_ctl(epollfd, EPOLL_CTL_DEL, connfd, &amp;event); clients.erase(std::remove(clients.begin(), clients.end(), connfd), clients.end()); continue; &#125; char buf[1024] = &#123;0&#125;; if(connfd &lt; 0) continue; int ret = 0; int total = 0; std::string strtemp; while(1) &#123; cout &lt;&lt; &quot;begin read&quot; &lt;&lt;endl; ret = read(connfd, buf, 1024); if(ret &lt;= 0) &#123; break; &#125; strtemp += string(buf); total += ret; memset(buf, 0, 1024); if(ret &lt; 1024) &#123; break; &#125; &#125;//endwhile(1) cout &lt;&lt; &quot;end read&quot; &lt;&lt;endl; recievebuf[connfd] = strtemp.c_str(); cout &lt;&lt; &quot;buff data :&quot; &lt;&lt; recievebuf[connfd]&lt;&lt;endl; if(ret == -1) &#123; if((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123; //由于内核缓冲区空了，下次有数据到来是会触发epollin continue; &#125; ERR_EXIT(&quot;read&quot;); &#125;//endif ret == -1 //连接断开 if(ret == 0) &#123; std::cout&lt;&lt;&quot;client close&quot;&lt;&lt;std::endl; close(connfd); event = epoll_eventsList[i]; epoll_ctl(epollfd, EPOLL_CTL_DEL, connfd, &amp;event); clients.erase(std::remove(clients.begin(), clients.end(), connfd), clients.end()); continue; &#125; cout &lt;&lt; &quot;turn to write&quot; &lt;&lt; endl; //更改为写模式 event.data.fd = connfd; event.events = EPOLLOUT | EPOLLET; epoll_ctl(epollfd, EPOLL_CTL_MOD, connfd, &amp;event); cout &lt;&lt; &quot;epoll mod change success&quot; &lt;&lt; endl; &#125;//end elif else //写事件 &#123; if(epoll_eventsList[i].events &amp; EPOLLOUT) &#123; cout &lt;&lt; &quot;begin write&quot; &lt;&lt;endl; connfd = epoll_eventsList[i].data.fd; int count = 0; int totalsend = 0; char buf[1024]; strcpy(buf, recievebuf[connfd].c_str()); cout &lt;&lt; &quot;write buff&quot; &lt;&lt;buf&lt;&lt;endl; while(1) &#123; int totalcount = strlen(buf); int pos = 0; count = write(epoll_eventsList[i].data.fd, buf + pos, totalcount); cout &lt;&lt; &quot;write count:&quot; &lt;&lt; count; if(count &lt; 0) &#123; break; &#125; if(count &lt; totalcount) &#123; totalcount = totalcount - count; pos += count; &#125; else &#123; break; &#125; &#125;//end while if(count == -1) &#123; if((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123; //由于内核缓冲区满了 //于内核缓冲区满了 continue; &#125; ERR_EXIT(&quot;write&quot;); &#125; if(count == 0) &#123; std::cout&lt;&lt;&quot;client close&quot;&lt;&lt;std::endl; close(connfd); event = epoll_eventsList[i]; epoll_ctl(epollfd, EPOLL_CTL_DEL, connfd, &amp;event); clients.erase(std::remove(clients.begin(), clients.end(), connfd), clients.end()); continue; &#125; event.data.fd = connfd; event.events = EPOLLIN|EPOLLET; epoll_ctl(epollfd, EPOLL_CTL_MOD, connfd, &amp;event); &#125; &#125;//end eles 写事件 &#125; &#125; &#125; 源代码下载地址：http://download.csdn.net/detail/secondtonone1/9486222我的微信公众号：","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"基于epoll封装的事件回调miniserver","date":"2017-08-07T09:06:12.000Z","path":"2017/08/07/miniserver/","text":"epoll技术前两节已经阐述过了，目前主要做一下封装，很多epoll的服务器都是采用事件回调方式处理， 其实并没有什么复杂的，我慢慢给大家阐述下原理。 在networking.h和networking.cpp里，这两个文件主要实现了一些文件读写功能的回调函数 acceptCallBack 负责新的描述符连接上来进行回调， readCallBack 负责读操作回调 writeCallBack 负责写操作回调 initListenSocket 负责初始化描述符的基本信息 setNonblock负责设置描述符非阻塞 bindListenSocket负责绑定描述符 实现如下 这些回调函数会赋值给EventLoop 的proc里，实现绑定，因为以后要回调 creatEventLoop为了创建并且初始化一个eventLoop deleteEventLoop删除一个eventloop CreateFileEvent将一个fd绑定到对应的epoll事件中，并且绑定fd对应的FileEvent事件类型和回调函数 DeleteFileEvent将一个fd解绑epoll事件，并且解绑fd对应的fileEvent事件类型和回调函数 ProcessEvents，轮询处理所有epoll就绪事件，并且调用之前注册好的回调函数 实现如下 上一部分将文件描述符加入epoll监听队列，以及从监听队列删除对应fd，或者轮询就绪事件都被我封装在apiepoll.h和apiepoll.cpp里。 ApiState是基于epoll封装的结构体 epfd表示epoll create产生的句柄 events表示epoll监听的事件队列，这个大小可以自己开辟，一般都是 最大的客户端连接数+保留的一部分空间 ApiCreate表示创建epoll结构和句柄，将数据存储到eventLoop里 ApiResize重新开辟epoll序列大小 ApiFree释放epoll events ApiAddEvent 将事件类型添加到epoll监听序列里 ApiDelEvent 将事件类型从epoll监听序列里删除 ApiPoll，就是epoll调用epoll_wait，返回就绪事件队列 轮询处理，回调函数就可以了 源代码下载地址：http://download.csdn.net/detail/secondtonone1/9502252 关注我的公众号平台，定期推送技术总结","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"简单循环服务器","date":"2017-08-07T08:57:52.000Z","path":"2017/08/07/easyloopser/","text":"客户端部分： 比较简单 创建socket 然后connect服务器，进行通讯 发送数据，并且接收数据，然后关闭服务器部分：服务器要做的是创建socket，初始化地址信息，并且绑定socket，然后进行监听然互就是在循环里处理客户端连接上来的请求，并且接受信息，回发信息循环服务器比较简单，而且是阻塞的，这种模型只是用于理解socket基本原理，并不能满足生产的需求 源代码下载地址： http://download.csdn.net/detail/secondtonone1/9510567 感兴趣请关注我的微信公众号","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"简单的并发服务器（多个线程各自accept）","date":"2017-08-07T08:49:17.000Z","path":"2017/08/07/easymulser/","text":"基于之前讲述的简单循环服务器，做一个多个线程各自accept的服务器demo由于多个线程各自accept，容易造成数据错误，需要在accept前后枷锁先看下客户端客户端创建socket，初始化服务器地址信息，然后进行连接 连接成功后发送信息给服务器，并且接受服务器回传的信息服务器部分： 服务器静态的的初始化一个线程锁，然后去写一个处理连接请求的函数，在循环里accept客户端的连接，接受客户端的消息，并且发送给客户端事件，由于多个线程各自accept，所以要在accept处加锁，避免产生的socket有误处理连接，这个主要是服务器创建了几个线程，各自线程的回调函数是handle_request，参数是socket , pthread_join是等待线程安全退出后进程结束服务器的main函数这是个阻塞模式下的多线程accept，实际生产和项目中都采用非阻塞模型，只是用来理解socket通信 原理，并无太大用处。 源代码下载地址： http://download.csdn.net/detail/secondtonone1/9510570我的微信公众号，谢谢","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"对于redis框架的理解(三)","date":"2017-08-07T08:41:36.000Z","path":"2017/08/07/redis3/","text":"上一篇讲完了initServer的大体流程，其中aeCreateEventLoop（）,这个函数没有详细说明，我们在这一篇里讲述Ae.h和Ae.c, 这里面的api阐述了如何创建 eventLoop和添加文件读写事件等等。 ae.h中的解释 //文件读写事件回调函数typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask); //定时器回调函数typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);//事件结束回调函数，析构一些资源typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);//不是很清楚，应该是进程结束前做的回调函数typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop); 12345678910111213141516171819202122232425262728293031323334353637//文件事件回调函数 typedef struct aeFileEvent &#123; int mask; /* one of AE_(READABLE|WRITABLE) */ //文件事件类型 读/写 aeFileProc *rfileProc; aeFileProc *wfileProc; void *clientData; &#125; aeFileEvent; /* A fired event */ typedef struct aeFiredEvent &#123; int fd; ////已出现的事件的文件号对应的事件描述在aeEventLoop.events[]中的下标 int mask; //文件事件类型 AE_WRITABLE||AE_READABLE &#125; aeFiredEvent; typedef struct aeTimeEvent &#123; long long id; /* time event identifier. */ //由aeEventLoop.timeEventNextId进行管理 long when_sec; /* seconds */ long when_ms; /* milliseconds */ aeTimeProc *timeProc; aeEventFinalizerProc *finalizerProc; void *clientData; struct aeTimeEvent *next; &#125; aeTimeEvent; /* State of an event based program */ typedef struct aeEventLoop &#123; int maxfd; //监听的最大文件号 int setsize; //跟踪的文件描述符最大数量 long long timeEventNextId; //定时器事件的ID编号管理（分配ID号所用） time_t lastTime; /* Used to detect system clock skew */ aeFileEvent *events; //注册的文件事件，这些是需要进程关注的文件 aeFiredEvent *fired; //poll结果，待处理的文件事件的文件号和事件类型 aeTimeEvent *timeEventHead; //定时器时间链表 int stop; //时间轮询是否结束？ void *apidata; //polling API 特殊的数据 aeBeforeSleepProc *beforesleep; //休眠前的程序 &#125; aeEventLoop; /* Prototypes */ //创建eventLoop结构 aeEventLoop *aeCreateEventLoop(int setsize); //删除eventloop void aeDeleteEventLoop(aeEventLoop *eventLoop); //事件派发停止 void aeStop(aeEventLoop *eventLoop); //添加文件读写事件 int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData); //删除文件读写事件 void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask); //获取文件事件对应类型(读或写) int aeGetFileEvents(aeEventLoop *eventLoop, int fd);//创建定时器事件 long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc); //删除定时器事件 int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id); //派发事件 int aeProcessEvents(aeEventLoop *eventLoop, int flags); //等待millionseconds直到文件描述符可读或者可写 int aeWait(int fd, int mask, long long milliseconds); //ae事件轮询主函数 void aeMain(aeEventLoop *eventLoop); //获取当前网络模型 char *aeGetApiName(void); //进程休眠前回调函数 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep); //获取eventloop所有的事件个数 int aeGetSetSize(aeEventLoop *eventLoop); //重新设置eventloop事件个数 int aeResizeSetSize(aeEventLoop *eventLoop, int setsize); ae.cpp中，一个函数一个函数解析 123456789101112131415//定义了几个宏，根据不同的宏加载//不同的网络模型#ifdef HAVE_EVPORT#include &quot;ae_evport.c&quot;#else#ifdef HAVE_EPOLL#include &quot;ae_epoll.c&quot;#else#ifdef HAVE_KQUEUE#include &quot;ae_kqueue.c&quot;#else#include &quot;ae_select.c&quot;#endif#endif#endif aeCreateEventLoop,主要负责eventloop结构的创建和初始化，以及模型的初始化 12345678910111213141516171819202122232425262728293031323334353637aeEventLoop *aeCreateEventLoop(int setsize) &#123; aeEventLoop *eventLoop; int i; //创建eventloop if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err; //为进程要注册的文件开辟空间 eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize); //为激活的要处理的文件开辟空间 eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize); //开辟失败报错 if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err; //设置监听事件总数 eventLoop-&gt;setsize = setsize; //更新为当前时间 eventLoop-&gt;lastTime = time(NULL); eventLoop-&gt;timeEventHead = NULL; eventLoop-&gt;timeEventNextId = 0; eventLoop-&gt;stop = 0; eventLoop-&gt;maxfd = -1; eventLoop-&gt;beforesleep = NULL; //将不同模式的api注册到eventloop里 if (aeApiCreate(eventLoop) == -1) goto err; /* Events with mask == AE_NONE are not set. So let&#x27;s initialize the * vector with it. */ for (i = 0; i &lt; setsize; i++) //将所有文件事件类型初始为空 eventLoop-&gt;events[i].mask = AE_NONE; return eventLoop;err: if (eventLoop) &#123; zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); zfree(eventLoop); &#125; return NULL;&#125; 123456789101112131415161718192021222324252627//事件队列大小和重置 //获取eventloop事件队列大小int aeGetSetSize(aeEventLoop *eventLoop) &#123; return eventLoop-&gt;setsize;&#125;//重新设置大小int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) &#123; int i; if (setsize == eventLoop-&gt;setsize) return AE_OK; if (eventLoop-&gt;maxfd &gt;= setsize) return AE_ERR; //不同的网络模型调用不同的resize if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR; //重新开辟空间 eventLoop-&gt;events = zrealloc(eventLoop-&gt;events,sizeof(aeFileEvent)*setsize); eventLoop-&gt;fired = zrealloc(eventLoop-&gt;fired,sizeof(aeFiredEvent)*setsize); eventLoop-&gt;setsize = setsize; /* Make sure that if we created new slots, they are initialized with * an AE_NONE mask. */ //重新初始化事件类型 for (i = eventLoop-&gt;maxfd+1; i &lt; setsize; i++) eventLoop-&gt;events[i].mask = AE_NONE; return AE_OK;&#125; 删除eventloop和stop事件轮询 123456789101112//删除eventloop结构void aeDeleteEventLoop(aeEventLoop *eventLoop) &#123; aeApiFree(eventLoop); zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); zfree(eventLoop);&#125;//设置eventloop停止标记void aeStop(aeEventLoop *eventLoop) &#123; eventLoop-&gt;stop = 1;&#125; 创建监听事件 12345678910111213141516171819202122232425262728//创建监听事件int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)&#123; //判断fd大于eventloop设置的事件队列大小 if (fd &gt;= eventLoop-&gt;setsize) &#123; errno = ERANGE; return AE_ERR; &#125; //取出对应的aeFileEvent事件 aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; //添加读写事件到不同的模型 if (aeApiAddEvent(eventLoop, fd, mask) == -1) return AE_ERR; //文件类型按位或 fe-&gt;mask |= mask; //根据最终的类型设置读写回调函数 if (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc; if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc; //fe中读写操作的clientdata fe-&gt;clientData = clientData; //如果fd大于当前最大的eventLoop maxfdfd if (fd &gt; eventLoop-&gt;maxfd) eventLoop-&gt;maxfd = fd; return AE_OK;&#125; 删除监听事件 12345678910111213141516171819void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)&#123; if (fd &gt;= eventLoop-&gt;setsize) return; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; if (fe-&gt;mask == AE_NONE) return; //网络模型里删除对应的事件 aeApiDelEvent(eventLoop, fd, mask); //清除对应的类型标记 fe-&gt;mask = fe-&gt;mask &amp; (~mask); //如果删除的fd是maxfd，并且对应的事件为空，那么更新maxfd if (fd == eventLoop-&gt;maxfd &amp;&amp; fe-&gt;mask == AE_NONE) &#123; /* Update the max fd */ int j; for (j = eventLoop-&gt;maxfd-1; j &gt;= 0; j--) if (eventLoop-&gt;events[j].mask != AE_NONE) break; eventLoop-&gt;maxfd = j; &#125;&#125; 1234567//获取文件类型int aeGetFileEvents(aeEventLoop *eventLoop, int fd) &#123; if (fd &gt;= eventLoop-&gt;setsize) return 0; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; //返回对应的类型标记 return fe-&gt;mask;&#125; 事件派发函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//派发事件的函数int aeProcessEvents(aeEventLoop *eventLoop, int flags)&#123; int processed = 0, numevents; /* Nothing to do? return ASAP */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; //为了休眠，直到有时间事件触发，即便是没有文件事件处理，我们也会 //调用对应的事件时间 //这部分不是很清楚，知道大体意思是设置时间， //为了aeApiPoll设置等待的时间 if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123; int j; aeTimeEvent *shortest = NULL; struct timeval tv, *tvp; if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT)) shortest = aeSearchNearestTimer(eventLoop); if (shortest) &#123; long now_sec, now_ms; /* Calculate the time missing for the nearest * timer to fire. */ aeGetTime(&amp;now_sec, &amp;now_ms); tvp = &amp;tv; tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec; if (shortest-&gt;when_ms &lt; now_ms) &#123; tvp-&gt;tv_usec = ((shortest-&gt;when_ms+1000) - now_ms)*1000; tvp-&gt;tv_sec --; &#125; else &#123; tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*1000; &#125; if (tvp-&gt;tv_sec &lt; 0) tvp-&gt;tv_sec = 0; if (tvp-&gt;tv_usec &lt; 0) tvp-&gt;tv_usec = 0; &#125; else &#123; /* If we have to check for events but need to return * ASAP because of AE_DONT_WAIT we need to set the timeout * to zero */ if (flags &amp; AE_DONT_WAIT) &#123; tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; &#125; else &#123; /* Otherwise we can block */ tvp = NULL; /* wait forever */ &#125; &#125; //调用不同的网络模型poll事件 numevents = aeApiPoll(eventLoop, tvp); for (j = 0; j &lt; numevents; j++) &#123; //轮询处理就绪事件 aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd]; int mask = eventLoop-&gt;fired[j].mask; int fd = eventLoop-&gt;fired[j].fd; int rfired = 0; //可读就绪事件 if (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123; rfired = 1; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); &#125; //可写就绪事件 if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123; if (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc) fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); &#125; processed++; &#125; &#125; /* Check time events */ //处理所有定时器事件 if (flags &amp; AE_TIME_EVENTS) processed += processTimeEvents(eventLoop); return processed; /* return the number of processed file/time events */&#125; 1234567891011121314151617181920/等待millionseconds，直到有可读或者可写事件触发int aeWait(int fd, int mask, long long milliseconds) &#123; struct pollfd pfd; int retmask = 0, retval; memset(&amp;pfd, 0, sizeof(pfd)); pfd.fd = fd; if (mask &amp; AE_READABLE) pfd.events |= POLLIN; if (mask &amp; AE_WRITABLE) pfd.events |= POLLOUT; if ((retval = poll(&amp;pfd, 1, milliseconds))== 1) &#123; if (pfd.revents &amp; POLLIN) retmask |= AE_READABLE; if (pfd.revents &amp; POLLOUT) retmask |= AE_WRITABLE; if (pfd.revents &amp; POLLERR) retmask |= AE_WRITABLE; if (pfd.revents &amp; POLLHUP) retmask |= AE_WRITABLE; return retmask; &#125; else &#123; return retval; &#125;&#125; 12345678910111213141516171819202122//ae主函数void aeMain(aeEventLoop *eventLoop) &#123; //stop初始为0 eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) &#123; //调用beforesleep函数 if (eventLoop-&gt;beforesleep != NULL) eventLoop-&gt;beforesleep(eventLoop); //派发所有的事件 aeProcessEvents(eventLoop, AE_ALL_EVENTS); &#125;&#125;//获取api名字char *aeGetApiName(void) &#123; return aeApiName();&#125;//sleep之前的回调函数void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) &#123; eventLoop-&gt;beforesleep = beforesleep;&#125; 这就是ae文件里大体的几个api，其他的没理解的还在研究。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"对于redis框架的理解（二）","date":"2017-08-07T08:22:07.000Z","path":"2017/08/07/redis2/","text":"之前梳理过redis main函数主体流程 `大体是 initServerConfig() -&gt; loadServerConfig() -&gt; daemonize() -&gt; initServer() -&gt; aeSetBeforeSleepProc() -&gt;aeMain() -&gt; aeDeleteEventLoop(); initServerConfig() 初始化server的配置 loadServerConfig()会从配置文件里加载对应的配置 daemonize()创建守护进程 看一下daemonize的函数组成 12345678910111213141516171819202122232425262728293031void daemonize(void) &#123; int fd; if (fork() != 0) exit(0); /* parent exits */ //设置为首进程 //之前parent和child运行在同一个session里, //parent是会话（session）的领头进程, //parent进程作为会话的领头进程，如果exit结束执行的话， //那么子进程会成为孤儿进程，并被init收养。 //执行setsid()之后,child将重新获得一个新的会话(session)id。 setsid(); /* create a new session */ /* Every output goes to /dev/null. If Redis is daemonized but * the &#x27;logfile&#x27; is set to &#x27;stdout&#x27; in the configuration file * it will not log at all. */ // /dev/null相当于黑洞文件，所有写入他的数据都会消失， //从他里面读不出数据 if ((fd = open(&quot;/dev/null&quot;, O_RDWR, 0)) != -1) &#123; dup2(fd, STDIN_FILENO); //将标准输入重定向到fd dup2(fd, STDOUT_FILENO); //将标准输出重定向到fd dup2(fd, STDERR_FILENO); //将错误输出重定向到fd if (fd &gt; STDERR_FILENO) close(fd); &#125;&#125; 着重解释下dup2这个函数 int dup(int oldfd); 复制oldfd所指向的文件描述符，返回系统目前未使用的最小的文件描述符。 新的文件描述符和oldfd指向一个文件， 他们共享读写，枷锁等权限，当一个文件描述符操作lseek，另一个也会随着偏移。 但是他们不共享close-on-exec。 int dup2(int oldfd, int newfd); 复制oldfd到newfd，如果newfd指向的文件打开，那么会关闭该文件。 dup2失败后返回-1，成功则共享文件状态。 接下来看看initServer函数做了些什么 下面是initServer内部的几个步骤 //由于initserver是守护进程，忽略sighup//sighub在控制终端关闭的时候会发给session首进程//session首进程退出时，该信号被发送到该session中的前台进程组中的每一个进程signal(SIGHUP, SIG_IGN); //写管道发现读进程终止时产生sigpipe信号， //写已终止的SOCK_STREAM套接字同样会产生此信号signal(SIGPIPE, SIG_IGN); 123456789101112server.pid = getpid();server.current_client = NULL;server.clients = listCreate(); //创建客户队列server.clients_to_close = listCreate(); //创建关闭队列server.slaves = listCreate(); //创建从机队列server.monitors = listCreate(); //创建监控队列server.slaveseldb = -1; /* Force to emit the first SELECT command. */server.unblocked_clients = listCreate(); //创建非堵塞客户队列server.ready_keys = listCreate(); //创建可读键队列server.clients_waiting_acks = listCreate(); //客户等待回包队列server.get_ack_from_slaves = 0;server.clients_paused = 0; //创建别的模块公用的对象createSharedObjects(); //创建共享对象adjustOpenFilesLimit(); //改变可打开文件的最大数量 可以看看adjustOpenFilesLimit() 里边做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void adjustOpenFilesLimit(void) &#123; rlim_t maxfiles = server.maxclients+REDIS_MIN_RESERVED_FDS; struct rlimit limit; //获取每个进程能创建的各种系统资源的最大数量 if (getrlimit(RLIMIT_NOFILE,&amp;limit) == -1) &#123; redisLog(REDIS_WARNING,&quot;Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.&quot;, strerror(errno)); //1024 - 目前redis最小保留的用于其他功能的描述符 server.maxclients = 1024-REDIS_MIN_RESERVED_FDS; &#125; else &#123; //系统当前（软）限制 rlim_t oldlimit = limit.rlim_cur; /* Set the max number of files if the current limit is not enough * for our needs. */ if (oldlimit &lt; maxfiles) &#123; //最大软件限制 rlim_t bestlimit; int setrlimit_error = 0; /* Try to set the file limit to match &#x27;maxfiles&#x27; or at least * to the higher value supported less than maxfiles. */ //尝试设置限制数符合maxfiles或者最接近 bestlimit = maxfiles; //循环判断，如果最大的连接数大于当前系统能使用的最大软件限制 while(bestlimit &gt; oldlimit) &#123; //设置每次递减的数量 rlim_t decr_step = 16; //设置当前软件限制 limit.rlim_cur = bestlimit; limit.rlim_max = bestlimit; //设置成功则断开，不成功继续循环，找到最接近的最大限制 if (setrlimit(RLIMIT_NOFILE,&amp;limit) != -1) break; //设置限制错误码 setrlimit_error = errno; /* We failed to set file limit to &#x27;bestlimit&#x27;. Try with a * smaller limit decrementing by a few FDs per iteration. */ //最大限制递减，如果小于规定值那么退出循环 if (bestlimit &lt; decr_step) break; bestlimit -= decr_step; /* Assume that the limit we get initially is still valid if * our last try was even lower. */ //最大连接数小于当前系统允许的资源数量，那么扩充为系统允许的数量 if (bestlimit &lt; oldlimit) bestlimit = oldlimit; //这个条件用于处理最大连接数 if (bestlimit &lt; maxfiles) &#123; //保存当前服务器客户队列最大数量 int old_maxclients = server.maxclients; //服务器客户队列最大数量 server.maxclients = bestlimit-REDIS_MIN_RESERVED_FDS; if (server.maxclients &lt; 1) &#123; redisLog(REDIS_WARNING,&quot;Your current &#x27;ulimit -n&#x27; &quot; &quot;of %llu is not enough for Redis to start. &quot; &quot;Please increase your open file limit to at least &quot; &quot;%llu. Exiting.&quot;, (unsigned long long) oldlimit, (unsigned long long) maxfiles); exit(1); &#125; &#125; 回到initServer函数内部 adjustOpenFilesLimit()函数过后是调用 server.el = aeCreateEventLoop(server.maxclients+REDIS_EVENTLOOP_FDSET_INCR); 这个函数是创建基本的时间循环结构。这个api写在Ae.c中，这个文件主要负责创建事件轮询的结构，创建文件读写事件，删除文件读写事件，删除事件轮询结构，派发文件读写功能等，下一节再讲。 然后是创建了一个定时器回调函数 if(aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) &#123; redisPanic(&quot;Can&#39;t create the serverCron time event.&quot;); exit(1); &#125; 接着创建了 TCP的回调函数，主要用于有新的连接到来触发acceptTcpHandler for (j = 0; j &lt; server.ipfd_count; j++) &#123; if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) &#123; redisPanic( &quot;Unrecoverable error creating server.ipfd file event.&quot;); &#125; &#125; //然后添加了udp的回调if (server.sofd &gt; 0 &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE, acceptUnixHandler,NULL) == AE_ERR) redisPanic(&quot;Unrecoverable error creating server.sofd file event.&quot;); 这就是initServer大体的流程","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"对于redis框架的理解（四）","date":"2017-08-07T08:16:07.000Z","path":"2017/08/07/redis4/","text":"上一篇讲述了eventloop的结构和创建，添加文件事件删除文件事件，派发等等。 而eventloop主要就是调用不同网络模型完成事件监听和派发的。 这一篇主要讲述epoll网络模型，redis是如何封装和调用的 下面是epoll_event的结构 12345678910111213141516171819/* epoll_event 结构 struct epoll_event &#123; uint32_t events; //epoll_event 要注册的事件类型 epoll_data_t data; //User data //联合体用于存储用户要保存的数据 &#125; typedef union epoll_data &#123; void * ptr; uint32_t u32; uint64_t u64; int fd; //一般存储accept后生成的socketfd &#125;epoll_data_t */ Ae_epoll.c文件中回传的数据结构 123456#include &lt;sys/epoll.h&gt;//该结构用于回传eventLoop-&gt;apidatatypedef struct aeApiState &#123; int epfd; //管理epoll事件表的句柄 struct epoll_event *events; //epoll events的队列&#125; aeApiState; Ae_epoll.c中创建epoll句柄 1234567891011121314151617181920212223242526//epoll 创建epfd过程static int aeApiCreate(aeEventLoop *eventLoop) &#123; //开辟存储不同网络模型的数据块 aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; //开辟epoll_event * size 大小的空间，这段空间是连续的 state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); //开辟失败 if (!state-&gt;events) &#123; zfree(state); return -1; &#125; //创建epfd，最多关注1024个文件描述符 state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) &#123; zfree(state-&gt;events); zfree(state); return -1; &#125; // eventLoop-&gt;apidata数据回传 eventLoop-&gt;apidata = state; return 0;&#125; Ae_epoll.c重新设置events队列大小 1234567//重新设置aeApiState大小static int aeApiResize(aeEventLoop *eventLoop, int setsize) &#123; aeApiState *state = eventLoop-&gt;apidata; state-&gt;events = zrealloc(state-&gt;events, sizeof(struct epoll_event)*setsize); return 0;&#125; Ae_epoll.c中释放内存和回收 12345678910//释放aeApiState和 events 的内存static void aeApiFree(aeEventLoop *eventLoop) &#123; aeApiState *state = eventLoop-&gt;apidata; //关闭文件描述符 close(state-&gt;epfd); //释放events的内存 zfree(state-&gt;events); //释放aeApiState 的内存 zfree(state);&#125; Ae_epoll.c添加读写事件或者更改读写事件的函数 1234567891011121314151617181920212223242526//epoll 注册事件，读或者写static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123; //aeEventLopp 的数据域 aeApiState *state = eventLoop-&gt;apidata; //epoll_event 事件 struct epoll_event ee; //aeEventLoop 中注册的文件事件队列标志位如果不是AE_NONE，那么更改，否则添加 int op = eventLoop-&gt;events[fd].mask == AE_NONE ? EPOLL_CTL_ADD : EPOLL_CTL_MOD; //events读写事件清零 ee.events = 0; //aeEventLoop 中注册的文件事件标志位进行融合 mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */ //如果是读事件，那么将epoll_event 注册读事件 if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; //如果是写事件，那么将epoll_event 注册写事件 if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.u64 = 0; /* avoid valgrind warning */ //epoll_event 文件描述符 ee.data.fd = fd; //将epoll事件注册到epoll的事件表里 if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1; return 0;&#125; Ae_epoll.c中删除读写事件的函数 1234567891011121314151617181920212223242526static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) &#123; aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee; //这是创建的逆过程 //按位去反，按位&amp;,即去掉相应的标志位 int mask = eventLoop-&gt;events[fd].mask &amp; (~delmask); ee.events = 0; //判断此时文件事件是读 if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; //判断此时文件事件是写 if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.u64 = 0; /* avoid valgrind warning */ ee.data.fd = fd; if (mask != AE_NONE) &#123; //更改epoll_event的事件类型 epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee); &#125; else &#123; /* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for * EPOLL_CTL_DEL. */ //删除epoll_event 事件 epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee); &#125;&#125; 事件派发函数 123456789101112131415161718192021222324252627282930313233343536373839//epoll 事件派发static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123; aeApiState *state = eventLoop-&gt;apidata; int retval, numevents = 0; //epoll wait 返回就绪状态的文件描述符，后面的结构体如果为空，那么说明阻塞，不为空表示等待多少秒后返回 //下面是man手册的解释 //Specifying a timeout of -1 makesepoll_wait(2) wait indefinitely, while specifying //a timeout equal to zero makesepoll_wait(2) to return immediately //even if no events are available (return code equal to zero) retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize, tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec/1000) : -1); if (retval &gt; 0) &#123; int j; numevents = retval; //轮询处理已经就绪的文件描述符 for (j = 0; j &lt; numevents; j++) &#123; int mask = 0; //指针+j，表示每次便宜地址为j*epoll_event个字节 struct epoll_event *e = state-&gt;events+j; //可读事件 if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE; //可写事件 if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE; //处理错误发送给客户端 if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE; //对端正常关闭（程序里close()，shell下kill或ctr+c）， //触发EPOLLIN和EPOLLRDHUP，但是不触发EPOLLERR和EPOLLHUP。 if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE; //添加到aeApiState 的就绪事件队列里 eventLoop-&gt;fired[j].fd = e-&gt;data.fd; //就绪时间状态 eventLoop-&gt;fired[j].mask = mask; &#125; &#125; return numevents;&#125; 12345//网络模型名字static char *aeApiName(void) &#123; return &quot;epoll&quot;;&#125; 以上是封装的epoll结构和解释","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"libiop网络库数据结构和基础知识","date":"2017-08-07T08:00:54.000Z","path":"2017/08/07/libiopbase/","text":"最近朋友推荐，学习了libiop这个网络库，作者封装的很全面，代码很简洁 适合初学者学习基于事件驱动的网络io,先看看iop_def.h, 这里面定义了常用的数据结构 tag_iop_base_t 主要用于管理所有事件，每个事件是一个iop_t, maxio表示最大的文件描述符， free_list_head 表示可用的空闲列表头部id，一般用iops + free_list_head取出iop_t 的元素 同理free_list_tail，最后一个可用iop, iop_op_t 是封装了几个函数指针的结构体, 包括网络模型的名字，事件的添加，事件的删除，事件的更改，事件的派发 剩下的如注释所示 12345678910111213141516171819202122struct tag_iop_base_t&#123; iop_t *iops; /*所有iop*/ int maxio; /*最大并发io数,包括定时器在内*/ int maxbuf; /*单个发送或接收缓存的最大值*/ int free_list_head; /*可用iop列表*/ int free_list_tail; /*最后一个可用iop*/ int io_list_head; /*已用io类型的iop列表*/ int timer_list_head; /*已用timer类型的iop列表*/ int connect_list_head; /*异步连接的iop列表*/ volatile int exit_flag; /*退出标志*/ int dispatch_interval; /*高度的间隔时间*/ iop_op_t op_imp; /*事件模型的内部实现*/ void *model_data; /*事件模型特定的数据*/ iop_time_t cur_time; /*当前调度时间*/ iop_time_t last_time; /*上次调度时间*/ iop_time_t last_keepalive_time; /*上次检查keepalive的时间*/ _list_node_t * tcp_protocol_list_head; /*use for advance tcp server model.*/&#125;; 看一下iop_t结构体，id是从0开始到n的数,这个是在tag_iop_base_t 中初始化队列时做的，io_handle_t是这个结构存储的socket id, iop_type分三种0表示释放，1表示io读写，2表示定时器事件， iop_event_cb表示事件回调函数指针，每一个iop_t绑定了不同的回调函数， 比如accept，比如read，比如write，但是这些回调函数要封装成iop_event_cb类型，dbuf_t 是作者封装的一个管理发送和接受数据的结构 1234567891011121314151617181920/**tag_iop_t:iop结构，每一个iop对象都会对应一个tag_iop_t结构*/struct tag_iop_t&#123; int id; /*对应的id*/ io_handle_t handle; /*关联的句柄*/ int iop_type; /*对象类型：0：free,1:io,2:timer*/ int prev; /*上一个对象*/ int next; /*下一个对象*/ unsigned int events; /*关注的事件*/ int timeout; /*超时值*/ iop_event_cb evcb; /*事件回调*/ void *arg; /*用户指定的参数,由用户负责释放资源*/ void *sys_arg; /*系统指定的参数，系统自动释放资源*/ /*以下字段对定时器无用*/ dbuf_t *sbuf; /*发送缓存区*/ dbuf_t *rbuf; /*接收缓存区*/ iop_time_t last_dispatch_time; /*上次调度的时间*/&#125;; iop_event_cb 定义如下 /事件回调函数,返回-1代表要删除对象,返回0代表正常/typedef int (*iop_event_cb)(iop_base_t *,int,unsigned int,void *); dbuf_t结构如下 123456struct tag_dbuf&#123; unsigned int capacity; unsigned int size; void *data;&#125;; 至于dbuf_t如何开辟空间释放空间，读写偏移的都不做赘述,iop_base_t中iop_op_t 结构很重要，是事件调度的核心 结构如下 123456789101112struct tag_iop_op_t&#123; const char *name; //模型名称 void (*base_free)(iop_base_t *); //资源释放的接口 int (*base_dispatch)(iop_base_t *, int); //模型调度接口 //添加事件 int (*base_add)(iop_base_t *, int, io_handle_t, unsigned int); //删除事件 int (*base_del)(iop_base_t *, int,io_handle_t); //修改事件 int (*base_mod)(iop_base_t *, int, io_handle_t, unsigned int);&#125;; 因为对应不同的平台，我们要应用不同的网络模型，比如epoll,select,iocp等等。 但是对于异步通信IO我们采取事件回调机制，也就是说提前绑定好读事件，写事件等， 在循环中调用base_dispatch函数指针，就可以实现对于不同模型的派发。 上面就是libiop模型的基本结构和框架 我们看下epoll模型的封装 tag_epoll_data 是封装的epoll基本结构， 这个结构存在iop_base_t的model_data里 12345struct tag_epoll_data &#123; struct epoll_event *events; //监听的epoll_events 队列 int nevents; //epoll_events 事件大小 int epfd; //epoll_create 产生的epoll表句柄&#125;; 两个函数，iop_t应用层的读写宏 EV_TYPE_READ和EV_TYPE_WRITEepoll的读写宏EPOLLIN和EPOLLOUT互相转换 12345678910111213141516171819202122232425262728static uint32_t to_epoll_events(uint32_t what)&#123; uint32_t events=0; if(what &amp; EV_TYPE_READ) &#123; events = EPOLLIN; &#125; if(what &amp; EV_TYPE_WRITE) &#123; events |= EPOLLOUT; &#125; return events;&#125;static uint32_t from_epoll_events(uint32_t events)&#123; uint32_t what=0; if(events &amp; (EPOLLHUP|EPOLLERR)) &#123; what = EV_TYPE_READ | EV_TYPE_WRITE; &#125; else &#123; if(events &amp; EPOLLIN)&#123;what |= EV_TYPE_READ;&#125; if(events &amp; EPOLLOUT)&#123;what |= EV_TYPE_WRITE;&#125; &#125; return what; &#125; 初始化epoll结构和数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int iop_init_epoll(void *iop_base, int maxev)&#123; iop_base_t *base = (iop_base_t *)iop_base; //iop_base 事 件 操作结构体 //iop_base_t中op_imp取出模型抽象的结构体 iop_op_t *iop_op = &amp;(base-&gt;op_imp); //开辟epoll_data空间 iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(malloc(sizeof(iop_epoll_data_t))); if(!iop_data) &#123; return -1; &#125; //监听的队列大小为maxev iop_data-&gt;nevents = maxev; //为epll_data里监听事件队列开辟连续空间 iop_data-&gt;events = (struct epoll_event *)(malloc(sizeof(struct epoll_event) * maxev)); if(!iop_data) &#123; free(iop_data); return -1; &#125; //模型内部实现，不同模型不同的函数指针和名字 iop_op-&gt;name = &quot;epoll&quot;; iop_op-&gt;base_free = epoll_free; iop_op-&gt;base_dispatch = epoll_dispatch; iop_op-&gt;base_add = epoll_add; iop_op-&gt;base_del = epoll_del; iop_op-&gt;base_mod = epoll_mod; //1024 is not the max events limit. //创建epoll表句柄 int epfd = epoll_create(1024); if(epfd &lt; 0) &#123; free(iop_data-&gt;events); free(iop_data); free(iop_op); return -1; &#125; iop_data-&gt;epfd = epfd; //iop_epoll_data_t类型的数据存在base的model_data里 //方便回调 base-&gt;model_data = iop_data; return 0;&#125; 对应的释放epoll开辟的空间和数据 12345678910111213141516171819//epoll 释放static void epoll_free(iop_base_t *base)&#123; //model_data里存放了epoll数据的指针 iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data); if(!iop_data)&#123;return;&#125; //释放events队列 if(iop_data-&gt;events) &#123; free(iop_data-&gt;events); &#125; //关闭iop_data-&gt;epfd if(iop_data-&gt;epfd &gt;= 0) &#123; close(iop_data-&gt;epfd); &#125; free(iop_data); base-&gt;model_data = (void *)0;&#125; epoll 添加事件 123456789101112131415//epoll添加事件//base 为iop_base回传指针//id为iop的id//io_handle_t 为socket//events 为事件类型（EV_TYPE_READ或者EV_TYPE_WRITE）static int epoll_add(iop_base_t *base, int id, io_handle_t handle, unsigned int events)&#123; iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data); struct epoll_event ev; ev.data.u32 = id; //转换为EPOLLIN或者EPOLLOUT ev.events = to_epoll_events(events); //iop_set_nonblock(handle); return epoll_ctl(iop_data-&gt;epfd, EPOLL_CTL_ADD, (int)handle, &amp;ev); &#125; epoll删除事件 12345678910111213//epoll删除事件//base 为iop_base回传指针//id为iop的id//io_handle_t 为socketstatic int epoll_del(iop_base_t *base, int id,io_handle_t handle)&#123; iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data); struct epoll_event ev; ev.data.u32 = id; ev.events = 0; //ev回传进去，删除epoll_events中socket为handle的注册事件 return epoll_ctl(iop_data-&gt;epfd, EPOLL_CTL_DEL, (int)handle, &amp;ev); &#125; epoll事件更改 123456789//epoll 模式更改(读写更改)static int epoll_mod(iop_base_t *base, int id, io_handle_t handle, unsigned int events)&#123; iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data); struct epoll_event ev; ev.data.u32 = id; ev.events = to_epoll_events(events); return epoll_ctl(iop_data-&gt;epfd, EPOLL_CTL_MOD, (int)handle, &amp;ev); &#125; epoll事件派发 1234567891011121314151617181920212223242526//epoll 事件派发static int epoll_dispatch(iop_base_t * base, int timeout)&#123; int i; int id = 0; iop_t *iop = NULL; //iop_base中取出模型数据 iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data); int n = 0; do&#123; n = epoll_wait(iop_data-&gt;epfd, iop_data-&gt;events, iop_data-&gt;nevents, timeout); &#125;while((n &lt; 0) &amp;&amp; (errno == EINTR)); base-&gt;cur_time = time(NULL); for(i = 0; i &lt; n; i++) &#123; //取出iop的id id = (int)((iop_data-&gt;events)[i].data.u32); if(id &gt;= 0 &amp;&amp; id &lt; base-&gt;maxio) &#123; iop = (base-&gt;iops)+id; //这个宏是调用绑定在iop的事件回调函数（accept,read,write等） IOP_CB(base,iop,from_epoll_events(iop_data-&gt;events[i].events)); &#125; &#125; return n;&#125; 以上就是libiop事件驱动的核心结构和设计，做个简单的总结，如果我们要设计一个多路复用的事件驱动 基本结构是这样的 //eventEle是应用层管理的最小单元 int (*WRAFuc )(eventLoop* eventLoopP, int id, int mask, ...); //mask为应用层自己定义的读写标记 123456789101112131415struct eventEle&#123; int socket; //关联的socket WRAFuc mPfunc; //读写接受等功能回调的函数 //读写缓冲区可自己封装 char readBuf[]; //读缓冲区 char writeBuff[]; //写缓冲区&#125;; //事件轮询的基本结构 123456789101112131415struct eventLoop&#123; eventEle * eventList; int maxfd; int lastActiveTime; iop_op_t op_imp; /*事件模型的内部实现*/ void * model_data; /*void 指针指向开辟的不同模型的数据*/&#125;; 不同模型的操作进行封装成一个结构体， 结构体里面有添加，删除，更改，派发，释放的函数指针 123456789101112struct tag_iop_op_t&#123;const char *name; //模型名称void (*base_free)(iop_base_t *); //资源释放的接口int (*base_dispatch)(iop_base_t *, int); //模型调度接口//添加事件int (*base_add)(iop_base_t *, int, io_handle_t, unsigned int);//删除事件int (*base_del)(iop_base_t *, int,io_handle_t);//修改事件int (*base_mod)(iop_base_t *, int, io_handle_t, unsigned int);&#125;; 这就是设计一个基本的事件驱动网络库的基本思路， 源代码下载地址：http://download.csdn.net/detail/secondtonone1/9517689","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"libiop通讯流程和api讲解","date":"2017-08-07T04:51:49.000Z","path":"2017/08/07/libiop/","text":"上一篇讲到了libiop基本结构,这次根据libiop提供的test跟踪下消息和运行流程 1234567891011121314void echo_server_test()&#123; int keepalive_timeout = 60; iop_base_t *base = iop_base_new(10240); printf(&quot;create a new iop_base_t object.\\n&quot;); iop_add_tcp_server(base,&quot;0.0.0.0&quot;,7777, my_echo_parser,my_echo_processor, my_echo_on_connect,my_echo_on_destroy,my_echo_on_error, keepalive_timeout); printf(&quot;create a new tcp server on port 7777.\\n&quot;); printf(&quot;start iop run loop.\\n&quot;); iop_run(base); &#125; echo_server_test 函数内部添加了一个tcpserver,将函数一层一层展开,展开iop_add_tcp_server 12345678910111213141516171819202122232425262728293031323334int iop_add_tcp_server(iop_base_t *base, const char *host, unsigned short port, iop_parser parser, iop_processor processor, iop_cb on_connect,iop_cb on_destroy, iop_err_cb on_error, int keepalive_timeout)&#123; iop_tcp_server_arg_t *sarg = 0; io_handle_t h = INVALID_HANDLE; sarg = (iop_tcp_server_arg_t *)malloc(sizeof(iop_tcp_server_arg_t)); if(!sarg)&#123;return -1;&#125; memset(sarg,0,sizeof(iop_tcp_server_arg_t)); h = iop_tcp_server(host,port); if(h == INVALID_HANDLE)&#123;return -1;&#125; sarg = (iop_tcp_server_arg_t *)malloc(sizeof(struct tag_iop_tcp_server_arg_t)); if(!sarg) &#123; iop_close_handle(h); return -1; &#125;#ifdef WIN32 strcpy_s(sarg-&gt;host,sizeof(sarg-&gt;host)-1, host);#else strcpy(sarg-&gt;host,host);#endif sarg-&gt;port = port; sarg-&gt;timeout = keepalive_timeout; sarg-&gt;on_connect = on_connect; sarg-&gt;on_destroy = on_destroy; sarg-&gt;on_error = on_error; sarg-&gt;parser = parser; sarg-&gt;processor = processor; _list_add_before(base-&gt;tcp_protocol_list_head, _list_node_new(sarg)); return iop_add(base,h,EV_TYPE_READ,_iop_tcp_server_cb,(void *)sarg,-1);&#125; 解读iop_add_tcp_server,函数参数iop_base_t 是iop基本事件结构，前面有说过， 12345678910111213141516171819202122struct tag_iop_base_t&#123; iop_t *iops; /*所有iop*/ int maxio; /*最大并发io数,包括定时器在内*/ int maxbuf; /*单个发送或接收缓存的最大值*/ int free_list_head; /*可用iop列表*/ int free_list_tail; /*最后一个可用iop*/ int io_list_head; /*已用io类型的iop列表*/ int timer_list_head; /*已用timer类型的iop列表*/ int connect_list_head; /*异步连接的iop列表*/ volatile int exit_flag; /*退出标志*/ int dispatch_interval; /*高度的间隔时间*/ iop_op_t op_imp; /*事件模型的内部实现*/ void *model_data; /*事件模型特定的数据*/ iop_time_t cur_time; /*当前调度时间*/ iop_time_t last_time; /*上次调度时间*/ iop_time_t last_keepalive_time; /*上次检查keepalive的时间*/ _list_node_t * tcp_protocol_list_head; /*use for advance tcp server model.*/&#125;; 第二个参数host是主机地址，port是端口号，剩下的parser为解析函数指针,processor为处理函数指针，on_connect为连接的回调函数指针，`on_destroy,为 销毁功能函数指针，on_error为错误情况下函数指针，keepalive_timeout为超时时间` 这几个函数指针的类型如下，基本都类似的 1234567891011121314151617181920212223242526272829303132333435363738/*tcp连接事件回调函数*/typedef void (*iop_cb)(iop_base_t *,int,void *);void iop_default_cb(iop_base_t *base, int id, void *arg);/** 返回-1代表要删除事件,返回0代表不删除*/typedef int (*iop_err_cb)(iop_base_t *,int,int,void *);int iop_default_err_cb(iop_base_t *base, int id, int err, void *arg);/*************************************协议解析器，* parameters:* char *buf:数据* int len:数据长度*return:* 返回0代表还要收更多数据以代解析，-1代表协议错误，&gt;0代表解析成功一个数据包***********************************/typedef int (*iop_parser)(char *, int);int iop_default_parser(char *buf, int len);/**数据处理器*parameters:* base:iop_base_t 指针* id:iop对象的id* buf:数据包起始点* len:数据包长度* arg:自带的参数*return: -1: 代表要关闭连接,0代表正常*/typedef int (*iop_processor)(iop_base_t *,int,char *,int,void *); 回到iop_add_tcp_server函数里 开辟arg的空间 sarg = (iop_tcp_server_arg_t *)malloc(sizeof(iop_tcp_server_arg_t));绑定端口和地址 h = iop_tcp_server(host,port);对arg赋值 1234567sarg-&gt;port = port; sarg-&gt;timeout = keepalive_timeout; sarg-&gt;on_connect = on_connect; sarg-&gt;on_destroy = on_destroy; sarg-&gt;on_error = on_error; sarg-&gt;parser = parser; sarg-&gt;processor = processor; 下面这句代码最重要 iop_add(base,h,EV_TYPE_READ,_iop_tcp_server_cb,(void *)sarg,-1); 这句代码将socket h绑定了一个读事件，当有读事件就绪时会触发iop_tcp_server_cb这个函数。 如何将h和iop_tcp_server_cb绑定的，展开iop_add 1234567891011121314151617181920212223242526272829303132333435363738int iop_add(iop_base_t *base,io_handle_t handle,unsigned int events,iop_event_cb evcb,void *arg,int timeout)&#123; int r = 0; iop_t *iop = _iop_base_get_free_node(base); if(!iop)&#123;return -1;&#125; iop-&gt;handle = handle; iop-&gt;events = events; iop-&gt;timeout = timeout; iop-&gt;evcb = evcb; iop-&gt;last_dispatch_time = base-&gt;cur_time; iop-&gt;arg = arg; //io 事件 if(handle != INVALID_HANDLE) &#123; //LOG_DBG(&quot;iop_add io, id=%d.\\n&quot;, iop-&gt;id); iop-&gt;prev = -1; iop-&gt;next = base-&gt;io_list_head; base-&gt;io_list_head = iop-&gt;id; iop-&gt;iop_type = IOP_TYPE_IO; iop_set_nonblock(handle); r = (*(base-&gt;op_imp.base_add))(base, iop-&gt;id, handle, events); if(r != 0) &#123; iop_del(base,iop-&gt;id); return -1; &#125; &#125; else &#123; /*timer*/ //LOG_DBG(&quot;iop_add timer, id=%d.\\n&quot;, iop-&gt;id); iop-&gt;prev = -1; iop-&gt;next = base-&gt;timer_list_head; base-&gt;timer_list_head = iop-&gt;id; iop-&gt;iop_type = IOP_TYPE_TIMER; &#125; return iop-&gt;id; &#125; iop_add 形参不做解释，其中形参evcb也是函数指针 /*事件回调函数,返回-1代表要删除对象,返回0代表正常*/ typedef int (*iop_event_cb)(iop_base_t *,int,unsigned int,void *);在iop_add内部完成iop回调函数evcb的绑定和基本参数赋值,然后判断是io事件还是定时器事件,对于IO事件，要通知网络层(epoll,select等不同模型)进行绑定， 调用base中op_imp成员的base_add函数指针完成绑定。 r = (*(base-&gt;op_imp.base_add))(base, iop-&gt;id, handle, events);之所以能调用是因为之前op_imp.base_add被赋值了。回到 1234567891011121314151617181920212223242526void echo_server_test()&#123; int keepalive_timeout = 60; iop_base_t *base = iop_base_new(10240); ...&#125;iop_base_t* iop_base_new(int maxio)&#123;#ifdef _HAVE_EVENT_PORTS_#endif#ifdef _HAVE_WORKING_KQUEUE_#endif#ifdef _HAVE_EPOLL_ return iop_base_new_special(maxio,&quot;epoll&quot;);#endif#ifdef _HAVE_DEVPOLL_#endif#ifdef _HAVE_POLL_ return iop_base_new_special(maxio,&quot;poll&quot;);#endif#ifdef _HAVE_SELECT_ return iop_base_new_special(maxio,&quot;select&quot;);#endif return NULL;&#125; 一层一层看 1234567891011121314iop_base_t* iop_base_new_special(int maxio,const char *model)&#123; int r = -1; iop_base_t *base = NULL; if(strcmp(model,&quot;epoll&quot;)==0) &#123; base = _iop_base_new(maxio); if(base) &#123; r = iop_init_epoll(base, maxio); &#125; &#125; ...... &#125; 1234567891011121314151617181920int iop_init_epoll(void *iop_base, int maxev)&#123; ... //模型内部实现，不同模型不同的函数指针和名字 iop_op-&gt;name = &quot;epoll&quot;; iop_op-&gt;base_free = epoll_free; iop_op-&gt;base_dispatch = epoll_dispatch; iop_op-&gt;base_add = epoll_add; iop_op-&gt;base_del = epoll_del; iop_op-&gt;base_mod = epoll_mod; //1024 is not the max events limit. //创建epoll表句柄 ... //iop_epoll_data_t类型的数据存在base的model_data里 //方便回调 base-&gt;model_data = iop_data; return 0;&#125; 上面就是在new函数里实现的一层一层函数指针的绑定，所以之后才可以调用对应的函数指针。 在iop_add 函数绑定成功后，整个iop_add_tcp_server流程走完了。 我们下一步看看如何派发消息 12345678910void echo_server_test()&#123; int keepalive_timeout = 60; iop_base_t *base = iop_base_new(10240); ... iop_add_tcp_server(...,...); ... iop_run(base); &#125; iop_run函数完成消息轮询和派发 12345678void iop_run(iop_base_t *base)&#123; while(base-&gt;exit_flag == 0) &#123; iop_dispatch(base); &#125; iop_base_free(base);&#125; `iop_dispatch消息派发函数 iop_base_free iop_base释放` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int iop_dispatch(iop_base_t *base)&#123; int cur_id = 0; int next_id = 0; int r = 0; iop_t *iop = (iop_t *)0; //调用不同模型的函数指针实现消息派发 dispatch_imp_cb dispatch_cb = base-&gt;op_imp.base_dispatch; r = (*dispatch_cb)(base,base-&gt;dispatch_interval); if( r == -1) &#123; return -1; &#125; //检测定时器时间，定时调用 if(base-&gt;cur_time &gt; base-&gt;last_time) &#123; //check timers... cur_id = base-&gt;timer_list_head; while(cur_id != -1) &#123; iop = base-&gt;iops + cur_id; next_id = iop-&gt;next; if(base-&gt;cur_time &gt; iop-&gt;last_dispatch_time + iop-&gt;timeout) &#123; IOP_CB(base,iop,EV_TYPE_TIMER); &#125; cur_id = next_id; &#125; /*********check for connect list.*********************/ cur_id = base-&gt;connect_list_head; while(cur_id != -1) &#123; iop = base-&gt;iops + cur_id; next_id = iop-&gt;next; if(base-&gt;cur_time &gt; iop-&gt;last_dispatch_time + iop-&gt;timeout) &#123; IOP_CB(base,iop,EV_TYPE_TIMEOUT); &#125; cur_id = next_id; &#125; //超时检测 /*********clear keepalive, 60 seconds per times***********************/ if(base-&gt;cur_time &gt; base-&gt;last_keepalive_time+60) &#123; base-&gt;last_keepalive_time = base-&gt;cur_time; cur_id = base-&gt;io_list_head; while(cur_id != -1) &#123; iop = base-&gt;iops+cur_id; next_id = iop-&gt;next; if(iop-&gt;timeout &gt; 0 &amp;&amp; iop-&gt;last_dispatch_time + iop-&gt;timeout &lt; base-&gt;cur_time) &#123; IOP_CB(base,iop,EV_TYPE_TIMEOUT); &#125; cur_id = next_id; &#125; &#125; base-&gt;last_time = base-&gt;cur_time; &#125; return r;&#125; 这句代码是消息派发的关键 //调用不同模型的函数指针实现消息派发 dispatch_imp_cb dispatch_cb = base-&gt;op_imp.base_dispatch; r = (*dispatch_cb)(base,base-&gt;dispatch_interval); base-&gt;op_imp.base_dispatch之前在epoll_init里完成过初始化 其实调用的是epoll的dispatch 12345678910111213141516171819202122232425static int epoll_dispatch(iop_base_t * base, int timeout)&#123; int i; int id = 0; iop_t *iop = NULL; //iop_base中取出模型数据 iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data); int n = 0; do&#123; n = epoll_wait(iop_data-&gt;epfd, iop_data-&gt;events, iop_data-&gt;nevents, timeout); &#125;while((n &lt; 0) &amp;&amp; (errno == EINTR)); base-&gt;cur_time = time(NULL); for(i = 0; i &lt; n; i++) &#123; //取出iop的id id = (int)((iop_data-&gt;events)[i].data.u32); if(id &gt;= 0 &amp;&amp; id &lt; base-&gt;maxio) &#123; iop = (base-&gt;iops)+id; //这个宏是调用绑定在iop的事件回调函数（accept,read,write等） IOP_CB(base,iop,from_epoll_events(iop_data-&gt;events[i].events)); &#125; &#125; return n;&#125; 这句话完成绑定在iop的回调函数调用，基本功能就是accept，read或者write等 //这个宏是调用绑定在iop的事件回调函数（accept,read,write等）IOP_CB(base,iop,from_epoll_events(iop_data-&gt;events[i].events));这样就是整个libiop通讯流程和事件驱动机制","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"select网络模型知识总结","date":"2017-08-07T04:41:57.000Z","path":"2017/08/07/selectlearn/","text":"select模型支持IO多路复用，select函数如下 123456int select ( IN int nfds, //windows下无意义，linux有意义 IN OUT fd_set* readfds, //检查可读性 IN OUT fd_set* writefds, //检查可写性 IN OUT fd_set* exceptfds, //例外数据 IN const struct timeval* timeout); //函数的返回时间 逐个解释每个参数意义： nfds：一个整型变量，表示比最大文件描述符+1 readfds： 这个集合监测读事件的描述符，将要监听读事件的文件描述符放入readfds中，通过调用select，readfds中将没有就绪的读事件文件描述符清除，留下 就绪的读事件描述符，可以通过read或者recv来处理 writefds：这个集合监测写事件的描述符，将要监听的写事件的文件描述符放入writefds中，通过调用select，writefds中没有就绪的写事件文件描述符被清除，留下 就绪的写事件描述符，可以通过write或者send来处理。 execptfds：这个集合在调用select后会存有错误的文件描述符。根据Linux网络网络编程第二版中介绍，可以监视带外数据OOB，带外数据使用MSG_OOB标志发送 到套接字上，当select()函数返回的时候，readfds将清除其中的其他文件描述符，留下OOB数据 函数返回值： 当返回0时表示超时，-1表示有错误，大于0表示没有错误。 当监视文件集中有文件描述符符合要求，即读文件描述符集合中有文件可读，写文件描述符集合中有文件可写，或者错误文件描述符集合中有错误的描述符，都会返回大于0的数 123456timeval结构体解释struct timeval &#123; long tv_sec; //秒 long tv_usec; //毫秒&#125;; timeval指针为NULL，表示一直等待，直到有符合条件的描述符触发select返回 如果timeval中个参数均为0，表示立即返回，否则在select没有符合条件的描述符，等待对应的时间和，然后返回。另外需要了解一些select的操作宏函数 fd_set是一个SOCKET队列，以下宏可以对该队列进行操作：FD_CLR( s, fd_set *set) 从队列set删除句柄s;FD_ISSET( s,fd_set *set) 检查句柄s是否存在与队列set中;FD_SET( s, fd_set *set )把句柄s添加到队列set中;FD_ZERO( fd_set *set ) 把set队列初始化成空队列. 看一个select的使用示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//前面是服务器socket的创建，绑定和监听int listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // Bind local.sin_family = AF_INET; local.sin_addr.S_un.S_addr = htonl(INADDR_ANY); local.sin_port = htons(PORT); bind(listenSocket, (sockaddr*)&amp;local, sizeof(SOCKADDR_IN)); // Listen listen(listenSocket, 3); //设置非阻塞 fcntl(listenSocket, F_SETFL, O_NONBLOCK ); //这个使用来统计所有已经连接上来的文件描述符， //也可以用数组表示，只是遍历的时候要根据数据结构进行更改FD_SET socketSet; FD_SET writeSet; FD_SET readSet; //清空 socketSetFD_ZERO(&amp;socketSet);//将文件描述符放入 socketSet，//用于accept FD_SET(listenSocket,&amp;socketSet); //统计最大的socket int maxfd = listenSocket;int conNum = 1;//数组存储连接的socketint connectArray[1024]=&#123;0&#125;;while(true) &#123; //清空读写集合 FD_ZERO(&amp;readSet); FD_ZERO(&amp;writeSet); //读写都监听 readSet=socketSet; writeSet=socketSet; //同时检查套接字的可读可写性。 //为等待时间传入NULL，则永久等待。传入0立即返回。不要勿用。 int ret=select(maxfd,&amp;readSet,&amp;writeSet,NULL,NULL); if(ret==-1) &#123; return false; &#125; sockaddr_in addr; int len=sizeof(addr); //是否存在客户端的连接请求。 //在readset中会返回已经调用过listen的套接字 if(FD_ISSET(listenSocket,&amp;readSet)) &#123; acceptSocket=accept(listenSocket,(sockaddr*)&amp;addr,&amp;len); if(acceptSocket==INVALID_SOCKET) &#123; return false; &#125; else &#123; //大于我们最大的监听数量了 if(conNum &gt; 1024) &#123; return false; &#125; //更新数组 connectArray[conNum] = acceptSocket; //设置非阻塞 fcntl(connectArray[conNum], F_SETFL, O_NONBLOCK ); //加到socketset里，以后赋值给读写集合 FD_SET(connectArray[conNum],&amp;socketSet); if(acceptSocket &gt; maxfd) &#123; maxfd = acceptSocket; &#125; conNum++; &#125; &#125; for(int i=0;i&lt;conNum;i++) &#123; //判断是否有读事件 if(FD_ISSET(connectArray[i],&amp;readSet)) &#123; //调用recv，接收数据。 //判断recv结果，为0则客户端断开， //那么调用FD_CLR并关闭对应的socket &#125; //判断是否有写事件 if(FD_ISSET(connectArray[i],&amp;writeSet) &#123; //调用send，发送数据。 //判断send结果，为0客户端断开， //那么调用FD_CLR并关闭对应的socket &#125; &#125; &#125; 上面的例子结合了网上提供的一些demo，其实writeSet不一定要放入socket，当某个socket需要send内容时,再调用FD_SET(socket,&amp;writeSet),写成功后再调用FD_CLR(socket,&amp;writeSet);避免造成busyloop，因为当缓冲区非空时，写事件是一直就绪的。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"对于redis底层框架的理解（五）","date":"2017-08-07T04:25:11.000Z","path":"2017/08/07/redis5/","text":"之前总结了redis的通讯流程，基本框架，epoll的封装等等，这次介绍下redis对于select模型的封装 123456789//select 模型typedef struct aeApiState &#123; //读文件描述符集合，写文件描述符集合 fd_set rfds, wfds; /* We need to have a copy of the fd sets as it&#x27;s not safe to reuse * FD sets after select(). */ //读写集合的副本 fd_set _rfds, _wfds;&#125; aeApiState; _rfds和_wfds是读写结合的副本，因为select调用后会将读写集合中未就绪的文件描述符清除，所以每次用_rfds和_wfds传入，就不用担心原读写集合描述符被清除。 封装的基于select的初始化函数1234567891011static int aeApiCreate(aeEventLoop *eventLoop) &#123; //开辟aeApiState空间 aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; //读写集合清零 FD_ZERO(&amp;state-&gt;rfds); FD_ZERO(&amp;state-&gt;wfds); eventLoop-&gt;apidata = state; return 0;&#125; 函数将读写集合清零，并且将state回传给eventloop的apidata部分。 内存回收功能1234//释放空间static void aeApiFree(aeEventLoop *eventLoop) &#123; zfree(eventLoop-&gt;apidata);&#125; 封装的添加和删除事件12345678910111213141516//select 添加事件static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123; aeApiState *state = eventLoop-&gt;apidata; if (mask &amp; AE_READABLE) FD_SET(fd,&amp;state-&gt;rfds); if (mask &amp; AE_WRITABLE) FD_SET(fd,&amp;state-&gt;wfds); return 0;&#125;//select 删除事件static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) &#123; aeApiState *state = eventLoop-&gt;apidata; if (mask &amp; AE_READABLE) FD_CLR(fd,&amp;state-&gt;rfds); if (mask &amp; AE_WRITABLE) FD_CLR(fd,&amp;state-&gt;wfds);&#125; 添加事件函数将文件描述根据mask是读事件还是写事件放入不同的set 删除事件根据文件描述符mask是读事件还是写事件从不同的set中清除 下面是核心功能，事件派发12345678910111213141516171819202122232425262728293031323334353637//select 触发事件static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123; aeApiState *state = eventLoop-&gt;apidata; int retval, j, numevents = 0; //将select读集合的数据拷贝到_rfds memcpy(&amp;state-&gt;_rfds,&amp;state-&gt;rfds,sizeof(fd_set)); //将select写集合数据拷贝到_wfds memcpy(&amp;state-&gt;_wfds,&amp;state-&gt;wfds,sizeof(fd_set)); //从读和写的copy集合里选出就绪的文件描述符 retval = select(eventLoop-&gt;maxfd+1, &amp;state-&gt;_rfds,&amp;state-&gt;_wfds,NULL,tvp); //大于零表示有就绪的文件描述符 if (retval &gt; 0) &#123; //select的弊端所在，每次都要将所有的文件描述符轮询一遍 for (j = 0; j &lt;= eventLoop-&gt;maxfd; j++) &#123; int mask = 0; aeFileEvent *fe = &amp;eventLoop-&gt;events[j]; if (fe-&gt;mask == AE_NONE) continue; //aeFileEvent 事件可读 if (fe-&gt;mask &amp; AE_READABLE &amp;&amp; FD_ISSET(j,&amp;state-&gt;_rfds)) mask |= AE_READABLE; //aeFileEvent 事件可写 if (fe-&gt;mask &amp; AE_WRITABLE &amp;&amp; FD_ISSET(j,&amp;state-&gt;_wfds)) mask |= AE_WRITABLE; eventLoop-&gt;fired[numevents].fd = j; eventLoop-&gt;fired[numevents].mask = mask; numevents++; &#125; &#125; return numevents;&#125; 先将读写集合中的内容copy的_rfds和_wfds中，分别传入select函数中， 这样select后返回的_rfds中只有就绪的读socket,_wfds中只有就绪的写socket,通过FD_ISSET判断读写事件之后放到eventloop的fire队列里。 基本的封装就是这个样子，select模型相对容易理解","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"epoll的一些细节和注意事项","date":"2017-08-07T04:13:53.000Z","path":"2017/08/07/epollim/","text":"epoll_event结构 12345678910111213struct epoll_event&#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125; __attribute__ ((__packed__));typedef union epoll_data&#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t; epoll_data是一个联合体,有的网络库使用了fd字段，比如redis，有的使用了u32，比如libiop，个人认为在epoll_wait之后内核会自动移动epoll_event队列的内容。因为epoll_wait返回就绪的文件描述符数量，之后我们采用循环从0到n,从epoll_event队列中取出对应第i个 epoll_event结构，通过epoll_data中的fd或者u32回调找到用户自己封装的事件回调单元，调用对应的回调函数。 举一个例子假设epoll_event队列中有1000个文件描述符，第一次调用epoll_wait返回5，那么表示队列前五个元素就绪了，如果不处理第三个就绪事件，其他的都处理。第二次调用epoll_wait会返回8,那么这8个epoll_event也是按顺序排列的。所以认为epoll_wait这个函数做了内部的优化排序，返回给用户按顺序拍好的内存 看下epoll_wait 函数参数 1234567#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask); 第二个参数表示epoll_event那个队列的首地址，第三个参数表示epoll_event队列的大小。 我查看了下manpage对于epoll的说明 The epoll_wait() system call waits for events on the epoll(7) instance referred to by the file descriptor epfd. The memory area pointed to by events will contain the events that will be available for the caller. Up to maxevents are returned by epoll_wait(). The maxevents argument must be greater than zero.The timeout argument specifies the minimum number of milliseconds that epoll_wait() will block大体意思是epoll_wait 是系统等待处理 epfd所指向的 epoll实例。指向epoll_events的内存是可以被用户访问的。 epoll_wait最多返回maxevents大小。而且maxevents必须大于0。timeout 这个参数表示epoll_wait阻塞的最小毫秒数。 The data of each returned structure will contain the same data the user set with an epoll_ctl(2) (EPOLL_CTL_ADD,EPOLL_CTL_MOD) while the events member will contain the returned event bit field.可以通过EPOLL_CTL_ADD或者EPOLL_CTL_MOD更改event的事件属性。比如epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee);下面是对返回值的说明 When successful, epoll_wait() returns the number of file descriptors ready for the requested I/O, or zero if no file descriptor became ready during the requested timeout milliseconds. When an error occurs, epoll_wait() returns -1 and errno is set appropriately当成功时epoll_wait返回就绪的I/O描述符个数，0表示超时，-1表示出错。 查看man手册给我们的一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define MAX_EVENTS 10 struct epoll_event ev, events[MAX_EVENTS]; int listen_sock, conn_sock, nfds, epollfd; /* Code to set up listening socket, &#x27;listen_sock&#x27;, (socket(), bind(), listen()) omitted */ epollfd = epoll_create1(0); if (epollfd == -1) &#123; perror(&quot;epoll_create1&quot;); exit(EXIT_FAILURE); &#125; ev.events = EPOLLIN; ev.data.fd = listen_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123; perror(&quot;epoll_ctl: listen_sock&quot;); exit(EXIT_FAILURE); &#125; for (;;) &#123; nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1); if (nfds == -1) &#123; perror(&quot;epoll_wait&quot;); exit(EXIT_FAILURE); &#125; for (n = 0; n &lt; nfds; ++n) &#123; if (events[n].data.fd == listen_sock) &#123; conn_sock = accept(listen_sock, (struct sockaddr *) &amp;addr, &amp;addrlen); if (conn_sock == -1) &#123; perror(&quot;accept&quot;); exit(EXIT_FAILURE); &#125; setnonblocking(conn_sock); ev.events = EPOLLIN | EPOLLET; ev.data.fd = conn_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev) == -1) &#123; perror(&quot;epoll_ctl: conn_sock&quot;); exit(EXIT_FAILURE); &#125; &#125; else &#123; do_use_fd(events[n].data.fd); &#125; &#125; &#125; 同样是采用epoll_wait后返回的大小进行轮询，每次epoll_events回传，保证就绪的事件排在前边，这样比select效率高，因为select存在set传入和传出，epoll不需要传入，只需要用户开辟一段连续空间，并且将首地址告诉epoll_wait即可。并且需要轮询所有文件描述符，而不是只针对就绪的轮询。 对于网络库，常常会封装一个供用户使用的EventBase 结构，例如libiop中 1234567891011121314151617struct tag_iop_t&#123; int id; /*对应的id*/ io_handle_t handle; /*关联的句柄*/ int iop_type; /*对象类型：0：free,1:io,2:timer*/ int prev; /*上一个对象*/ int next; /*下一个对象*/ unsigned int events; /*关注的事件*/ int timeout; /*超时值*/ iop_event_cb evcb; /*事件回调*/ void *arg; /*用户指定的参数,由用户负责释放资源*/ void *sys_arg; /*系统指定的参数，系统自动释放资源*/ /*以下字段对定时器无用*/ dbuf_t *sbuf; /*发送缓存区*/ dbuf_t *rbuf; /*接收缓存区*/ iop_time_t last_dispatch_time; /*上次调度的时间*/&#125;; 例如redis中 123456typedef struct aeFileEvent &#123; int mask; /* one of AE_(READABLE|WRITABLE) */ //文件事件类型 读/写 aeFileProc *rfileProc; aeFileProc *wfileProc; void *clientData; &#125; aeFileEvent; 我们大都会开辟一段内存空间, 例如 tag_iop_t * ioplist = malloc(sizeof(struct tag_iop_t) * size ); 当调用epoll_wait成功之后会返回n个就绪事件,从0到n遍历,对于第i个epoll_events[i],怎么找到应用层的数据节点tag_iop_t呢？ 常用的做法就是将节点的标号存在epoll_data 的 u32字段，或者 将关联的socketfd存在epoll_data的 fd 字段 通过如下伪代码可以实现类似的调用 1234567891011121314151617int socketFd = epoll_events[i].epoll_data.fd;ioplist[socketFd].callBack;//或者根据节点回调int node = epoll_events[i].epoll_data.u32;ioplist[node].callBack;//至于采用何种方式回调//关键在于我们之前如何绑定iop的//用socket下标绑定回调函数ioplist[fd].callBack = ...;//用node 序号绑定//node是用户自己管理的从0到maxnum的数字ioplist[node].fd = fd;ioplist[node].callBack = ...; 这些都是读过一些网络库自己的理解，如果有什么好的建议请大家告诉我，一起进步吧。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"libevlearn","date":"2017-08-07T03:34:13.000Z","path":"2017/08/07/libevlearn/","text":"最近自学libevent事件驱动库，参考的资料为libevent2.2版本以及张亮提供的《Libevent源码深度剖析》，参考资料： http://blog.csdn.net/sparkliang/article/details/4957667, libevent好处之类的就不赘述了，libevent和libiop，redis等一样都是采用事件回调机制，这种模式被称作Reactor模式。正常事件处理流程是应用程序调用某个接口触发某个功能，而Reactor模式需要我们将这些接口和宿主指针（谁调用这些接口）注册在Reactor，在合适的时机Reactor使用宿主指针调用注册好的回调函数。 一： Reactor基本知识Reactor 模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：1）响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；3）可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；4）可复用性， reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性；Reactor模式框架 1） Handle 意思为句柄，在Linux表示文件描述符，在windows是socket或者handle。 2）EventDemultiplexer 表示事件多路分发机制，调用系统提供的I/O多路复用机制，比如select，epoll,程序先将关注的句柄注册到EventDemultiplexer上,当有关注的事件到来时，触发EventDemultiplexer通知程序，程序调用之前注册好的回调函数完成消息相应。对应到 libevent 中，依然是 select、 poll、 epoll 等，但是 libevent 使用结构体eventop进行了 封装，以统一的接口来支持这些 I/O 多路复用机制，达到了对外隐藏底层系统机制的目的。3）Reactor——反应器Reactor，是事件管理的接口，内部使用 event demultiplexer 注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到 libevent 中，就是 event_base 结构体。一个典型的Reactor声明方式 12345678class Reactor&#123;public:int register_handler(Event_Handler *pHandler, int event);int remove_handler(Event_Handler *pHandler, int event);void handle_events(timeval *ptv);// ...&#125;; 4） Event Handler——事件处理程序事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供 Reactor 在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。对应到 libevent 中，就是 event 结构体。下面是两种典型的 Event Handler 类声明方式， 二者互有优缺点。 123456789101112131415161718class Event_Handler&#123;public:virtual void handle_read() = 0;virtual void handle_write() = 0;virtual void handle_timeout() = 0;virtual void handle_close() = 0;virtual HANDLE get_handle() = 0;// ...&#125;;class Event_Handler&#123;public:// events maybe read/write/timeout/close .etcvirtual void handle_events(int events) = 0;virtual HANDLE get_handle() = 0;// ...&#125;; 二：如何使用libevent库提供的API1）首先初始化 libevent 库，并保存返回的指针struct event_base * base = event_init();实际上这一步相当于初始化一个 Reactor 实例；在初始化 libevent 后，就可以注册事件了。 2）设置event属性和回调函数 调用函数void event_set(struct event *ev, int fd, short event, void (*cb)(int,short, void *), void *arg); 每个参数的意义： ev：执行要初始化的 event 对象；fd：该 event 绑定的“句柄”，对于信号事件，它就是关注的信号；event：在该 fd 上关注的事件类型，它可以是 EV_READ, EV_WRITE, EV_SIGNAL；cb：这是一个函数指针，当 fd 上的事件 event 发生时，调用该函数执行处理，它有三个参数，分别是关注的fd, 关注的事件类型（读/写/信号），回调函数的参数void* arg，调用时由event_base 负责传入，按顺序，实际上就是 event_set 时的 fd, event 和 arg； arg：传递给 cb 函数指针的参数； 由于定时事件不需要 fd，并且定时事件是根据添加时（ event_add）的超时值设定的，因此这里 event 也不需要设置。这一步相当于初始化一个 event handler，在 libevent 中事件类型保存在 event 结构体中。注意： libevent 并不会管理 event 事件集合，这需要应用程序自行管理； 3）设置 event 从属的 event_baseevent_base_set(base, &amp;ev);这一步相当于指明 event 要注册到哪个 event_base 实例上； 4）将事件添加到事件队列里event_add(&amp;ev, timeout);基本信息都已设置完成，只要简单的调用 event_add()函数即可完成，其中 timeout 是定时值； 这一步相当于调用 Reactor::register_handler()函数注册事件。 5）程序进入无限循环，等待就绪事件并执行事件处理event_base_dispatch(base); 看一下libevent提供的sample 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970intmain(int argc, char **argv)&#123; struct event evfifo;#ifdef WIN32 HANDLE socket; /* Open a file. */ socket = CreateFileA(&quot;test.txt&quot;, /* open File */ GENERIC_READ, /* open for reading */ 0, /* do not share */ NULL, /* no security */ OPEN_EXISTING, /* existing file only */ FILE_ATTRIBUTE_NORMAL, /* normal file */ NULL); /* no attr. template */ if (socket == INVALID_HANDLE_VALUE) return 1;#else struct stat st; const char *fifo = &quot;event.fifo&quot;; int socket; if (lstat(fifo, &amp;st) == 0) &#123; if ((st.st_mode &amp; S_IFMT) == S_IFREG) &#123; errno = EEXIST; perror(&quot;lstat&quot;); exit(1); &#125; &#125; unlink(fifo); if (mkfifo(fifo, 0600) == -1) &#123; perror(&quot;mkfifo&quot;); exit(1); &#125; /* Linux pipes are broken, we need O_RDWR instead of O_RDONLY */#ifdef __linux socket = open(fifo, O_RDWR | O_NONBLOCK, 0);#else socket = open(fifo, O_RDONLY | O_NONBLOCK, 0);#endif if (socket == -1) &#123; perror(&quot;open&quot;); exit(1); &#125; fprintf(stderr, &quot;Write data to %s\\n&quot;, fifo);#endif /* Initalize the event library */ event_init(); /* Initalize one event */#ifdef WIN32 event_set(&amp;evfifo, (evutil_socket_t)socket, EV_READ, fifo_read, &amp;evfifo);#else event_set(&amp;evfifo, socket, EV_READ, fifo_read, &amp;evfifo);#endif /* Add it to the active events, without a timeout */ event_add(&amp;evfifo, NULL); event_dispatch();#ifdef WIN32 CloseHandle(socket);#endif return (0);&#125; main函数里调用event_init()初始化一个event_base,之后调用event_set对event设置了回调函数和读事件关注，event_add将此事件加入event队列里，超时设置为空最后调用event_dispatch()进行事件轮训派发。fifo_read是一个回调函数，格式就是之前说的cb格式 1234567891011121314151617181920212223242526272829303132333435363738394041static voidfifo_read(evutil_socket_t fd, short event, void *arg)&#123; char buf[255]; int len; struct event *ev = arg;#ifdef WIN32 DWORD dwBytesRead;#endif /* Reschedule this event */ event_add(ev, NULL); fprintf(stderr, &quot;fifo_read called with fd: %d, event: %d, arg: %p\\n&quot;, (int)fd, event, arg);#ifdef WIN32 len = ReadFile((HANDLE)fd, buf, sizeof(buf) - 1, &amp;dwBytesRead, NULL); /* Check for end of file. */ if (len &amp;&amp; dwBytesRead == 0) &#123; fprintf(stderr, &quot;End Of File&quot;); event_del(ev); return; &#125; buf[dwBytesRead] = &#x27;\\0&#x27;;#else len = read(fd, buf, sizeof(buf) - 1); if (len == -1) &#123; perror(&quot;read&quot;); return; &#125; else if (len == 0) &#123; fprintf(stderr, &quot;Connection closed\\n&quot;); return; &#125; buf[len] = &#x27;\\0&#x27;;#endif fprintf(stdout, &quot;Read: %s\\n&quot;, buf);&#125; 三：《libevent 代码深度剖析》中对文件组织进行了归类1）头文主要就是 event.h：事件宏定义、接口函数声明，主要结构体 event 的声明； 2）内部头文件xxx-internal.h：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；3） libevent 框架event.c： event 整体框架的代码实现；4）对系统 I/O 多路复用机制的封装epoll.c：对 epoll 的封装；select.c：对 select 的封装；devpoll.c：对 dev/poll 的封装;kqueue.c：对 kqueue 的封装；5）定时事件管理min-heap.h：其实就是一个以时间作为 key 的小根堆结构；6）信号管理signal.c：对信号事件的处理；7）辅助功能函数evutil.h 和 evutil.c：一些辅助功能函数，包括创建 socket pair 和一些时间操作函数：加、减和比较等。8）日志log.h 和 log.c： log 日志函数9）缓冲区管理evbuffer.c 和 buffer.c： libevent 对缓冲区的封装；10）基本数据结构compat\\sys 下的两个源文件： queue.h 是 libevent 基本数据结构的实现，包括链表，双向链表，队列等； _libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；11）实用网络库 http 和 evdns：是基于 libevent 实现的 http 服务器和异步 dns 查询库； 四：event结构知识下面着重看下event结构体，这是libevent核心结构 123456789101112131415161718192021222324252627282930313233343536373839struct event &#123; TAILQ_ENTRY(event) ev_active_next; TAILQ_ENTRY(event) ev_next; /* for managing timeouts */ union &#123; TAILQ_ENTRY(event) ev_next_with_common_timeout; int min_heap_idx; &#125; ev_timeout_pos; evutil_socket_t ev_fd; struct event_base *ev_base; union &#123; /* used for io events */ struct &#123; TAILQ_ENTRY(event) ev_io_next; struct timeval ev_timeout; &#125; ev_io; /* used by signal events */ struct &#123; TAILQ_ENTRY(event) ev_signal_next; short ev_ncalls; /* Allows deletes in callback */ short *ev_pncalls; &#125; ev_signal; &#125; _ev; short ev_events; short ev_res; /* result passed to event callback */ short ev_flags; ev_uint8_t ev_pri; /* smaller numbers are higher priority */ ev_uint8_t ev_closure; struct timeval ev_timeout; /* allows us to adopt for different types of events */ void (*ev_callback)(evutil_socket_t, short, void *arg); void *ev_arg;&#125;; ev_active_next： 表示就绪状态的事件链表指针，当关注的事件就绪后，会把 对应的event放入active的队列里。表示该事件在active队列里的位置 ev_next：表示所有事件队列链表的指针。表示该事件在所有时间列表的位置。 ev_timeout_pos：用于管理超时 ev_fd：event绑定的socket描述符 ev_events:event关注的事件类型，它可以是以下3种类型：I/O事件： EV_WRITE和EV_READ定时事件： EV_TIMEOUT信号： EV_SIGNAL辅助选项： EV_PERSIST，表明是一个永久事件 Libevent中的定义为： 12345#define EV_TIMEOUT 0x01#define EV_READ 0x02#define EV_WRITE 0x04#define EV_SIGNAL 0x08#define EV_PERSIST 0x10 /* Persistant event */ ev_res：记录了当前激活事件的类型； ev_flags： libevent 用于标记 event 信息的字段，表明其当前的状态，可能的值有： 123456#define EVLIST_TIMEOUT 0x01 // event在time堆中#define EVLIST_INSERTED 0x02 // event在已注册事件链表中#define EVLIST_SIGNAL 0x04 // 未见使用#define EVLIST_ACTIVE 0x08 // event在激活链表中#define EVLIST_INTERNAL 0x10 // 内部使用标记#define EVLIST_INIT 0x80 // event 已被初始化 ev_pri：当前事件的优先级 ev_timeout：超时时间设置 ev_callback：该事件对应的回调函数，和cb类型一样 ev_arg：回调函数用到参数 ev_ncalls：事件就绪执行时，调用 ev_callback 的次数，通常为 1；ev_pncalls：指针，通常指向 ev_ncalls 或者为 NULL； 五：libevent对于event的管理和使用对于event使用流程之前有讲过，需要设置event的属性和回调函数，然后将其加入event队列里。设置event属性和回调函数的api如下 12345678voidevent_set(struct event *ev, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg)&#123; int r; r = event_assign(ev, current_base, fd, events, callback, arg); EVUTIL_ASSERT(r == 0);&#125; ev：表示event指针 fd:event要关注的socket fd events:event关注的事件类型(读写I/O，信号，时间事件等) callback:event就绪后会调用的回调函数 arg：调用回调函数时，函数的参数 该函数内部调用了event_assign完成设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748intevent_assign(struct event *ev, struct event_base *base, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg)&#123; if (!base) base = current_base; _event_debug_assert_not_added(ev); ev-&gt;ev_base = base; ev-&gt;ev_callback = callback; ev-&gt;ev_arg = arg; ev-&gt;ev_fd = fd; ev-&gt;ev_events = events; ev-&gt;ev_res = 0; ev-&gt;ev_flags = EVLIST_INIT; ev-&gt;ev_ncalls = 0; ev-&gt;ev_pncalls = NULL; if (events &amp; EV_SIGNAL) &#123; if ((events &amp; (EV_READ|EV_WRITE)) != 0) &#123; event_warnx(&quot;%s: EV_SIGNAL is not compatible with &quot; &quot;EV_READ or EV_WRITE&quot;, __func__); return -1; &#125; //对于信号设置终止信号 ev-&gt;ev_closure = EV_CLOSURE_SIGNAL; &#125; else &#123; if (events &amp; EV_PERSIST) &#123; evutil_timerclear(&amp;ev-&gt;ev_io_timeout); //永久事件 ev-&gt;ev_closure = EV_CLOSURE_PERSIST; &#125; else &#123; ev-&gt;ev_closure = EV_CLOSURE_NONE; &#125; &#125; min_heap_elem_init(ev); if (base != NULL) &#123; /* by default, we put new events into the middle priority */ ev-&gt;ev_pri = base-&gt;nactivequeues / 2; &#125; _event_debug_note_setup(ev); return 0;&#125; 设置好event属性和回调函数后，需要将event设置到指定的event_base中，因为有可能存在很多event_base。调用如下函数 1234567891011121314intevent_base_set(struct event_base *base, struct event *ev)&#123; /* Only innocent events may be assigned to a different base */ if (ev-&gt;ev_flags != EVLIST_INIT) return (-1); _event_debug_assert_is_setup(ev); ev-&gt;ev_base = base; ev-&gt;ev_pri = base-&gt;nactivequeues/2; return (0);&#125; 该函数设置了优先级和隶属于哪个base另外还有一个设置优先级的函数 int event_priority_set(struct event *ev, int pri)设置event ev的优先级，没什么可说的，注意的一点就是：当ev正处于就绪状态时，不能设置，返回-1 六：event_base结构分析和使用event_base结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125struct event_base &#123; /** Function pointers and other data to describe this event_base&#x27;s * backend. */ const struct eventop *evsel; /** Pointer to backend-specific data. */ void *evbase; /** List of changes to tell backend about at next dispatch. Only used * by the O(1) backends. */ struct event_changelist changelist; /** Function pointers used to describe the backend that this event_base * uses for signals */ const struct eventop *evsigsel; /** Data to implement the common signal handelr code. */ struct evsig_info sig; /** Number of virtual events */ int virtual_event_count; /** Number of total events added to this event_base */ int event_count; /** Number of total events active in this event_base */ int event_count_active; /** Set if we should terminate the loop once we&#x27;re done processing * events. */ int event_gotterm; /** Set if we should terminate the loop immediately */ int event_break; /** Set if we should start a new instance of the loop immediately. */ int event_continue; /** The currently running priority of events */ int event_running_priority; /** Set if we&#x27;re running the event_base_loop function, to prevent * reentrant invocation. */ int running_loop; /* Active event management. */ /** An array of nactivequeues queues for active events (ones that * have triggered, and whose callbacks need to be called). Low * priority numbers are more important, and stall higher ones. */ struct event_list *activequeues; /** The length of the activequeues array */ int nactivequeues; /* common timeout logic */ /** An array of common_timeout_list* for all of the common timeout * values we know. */ struct common_timeout_list **common_timeout_queues; /** The number of entries used in common_timeout_queues */ int n_common_timeouts; /** The total size of common_timeout_queues. */ int n_common_timeouts_allocated; /** List of defered_cb that are active. We run these after the active * events. */ struct deferred_cb_queue defer_queue; /** Mapping from file descriptors to enabled (added) events */ struct event_io_map io; /** Mapping from signal numbers to enabled (added) events. */ struct event_signal_map sigmap; /** All events that have been enabled (added) in this event_base */ struct event_list eventqueue; /** Stored timeval; used to detect when time is running backwards. */ struct timeval event_tv; /** Priority queue of events with timeouts. */ struct min_heap timeheap; /** Stored timeval: used to avoid calling gettimeofday/clock_gettime * too often. */ struct timeval tv_cache;#if defined(_EVENT_HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC) /** Difference between internal time (maybe from clock_gettime) and * gettimeofday. */ struct timeval tv_clock_diff; /** Second in which we last updated tv_clock_diff, in monotonic time. */ time_t last_updated_clock_diff;#endif#ifndef _EVENT_DISABLE_THREAD_SUPPORT /* threading support */ /** The thread currently running the event_loop for this base */ unsigned long th_owner_id; /** A lock to prevent conflicting accesses to this event_base */ void *th_base_lock; /** The event whose callback is executing right now */ struct event *current_event; /** A condition that gets signalled when we&#x27;re done processing an * event with waiters on it. */ void *current_event_cond; /** Number of threads blocking on current_event_cond. */ int current_event_waiters;#endif#ifdef WIN32 /** IOCP support structure, if IOCP is enabled. */ struct event_iocp_port *iocp;#endif /** Flags that this base was configured with */ enum event_base_config_flag flags; /* Notify main thread to wake up break, etc. */ /** True if the base already has a pending notify, and we don&#x27;t need * to add any more. */ int is_notify_pending; /** A socketpair used by some th_notify functions to wake up the main * thread. */ evutil_socket_t th_notify_fd[2]; /** An event used by some th_notify functions to wake up the main * thread. */ struct event th_notify; /** A function used to wake up the main thread from another thread. */ int (*th_notify_fn)(struct event_base *base);&#125;; evsel：eventop类型的指针，针对不同的模型封装了同一套操作 evbase： 不同模型开辟的数据空间，放到event_base里。 evbase和evsel配套使用，eventop结构如下 1234567891011121314151617181920212223242526272829303132333435363738394041struct eventop &#123; /** The name of this backend. */ const char *name; /** Function to set up an event_base to use this backend. It should * create a new structure holding whatever information is needed to * run the backend, and return it. The returned pointer will get * stored by event_init into the event_base.evbase field. On failure, * this function should return NULL. */ void *(*init)(struct event_base *); /** Enable reading/writing on a given fd or signal. &#x27;events&#x27; will be * the events that we&#x27;re trying to enable: one or more of EV_READ, * EV_WRITE, EV_SIGNAL, and EV_ET. &#x27;old&#x27; will be those events that * were enabled on this fd previously. &#x27;fdinfo&#x27; will be a structure * associated with the fd by the evmap; its size is defined by the * fdinfo field below. It will be set to 0 the first time the fd is * added. The function should return 0 on success and -1 on error. */ int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo); /** As &quot;add&quot;, except &#x27;events&#x27; contains the events we mean to disable. */ int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo); /** Function to implement the core of an event loop. It must see which added events are ready, and cause event_active to be called for each active event (usually via event_io_active or such). It should return 0 on success and -1 on error. */ int (*dispatch)(struct event_base *, struct timeval *); /** Function to clean up and free our data from the event_base. */ void (*dealloc)(struct event_base *); /** Flag: set if we need to reinitialize the event base after we fork. */ int need_reinit; /** Bit-array of supported event_method_features that this backend can * provide. */ enum event_method_feature features; /** Length of the extra information we should record for each fd that has one or more active events. This information is recorded as part of the evmap entry for each fd, and passed as an argument to the add and del functions above. */ size_t fdinfo_len;&#125;; eventop封装了epoll, select 等不同网络模型的init，add，deldispatch等回调函数。 changelist：通知后端改变的列表。 evsigsel：告诉后台 eventbase用于处理signal事件的函数指针 event_count：eventbase中总共的event数量 event_count_active： eventbase中激活的event数量 event_gotterm：这个参数设置后，一旦我们对事件做了处理，就要终止循环。 event_break：立刻结束循环 event_continue：立刻开启一个新的循环实例 event_running_priority：当前事件队列的优先级。 activequeues：激活的事件队列，priority数字小的先触发。 struct event_io_map io： 用于管理io事件的描述符 struct event_signal_map sigmap： 用于管理signal的描述符 eventqueue：所有被加入event_base的事件组成的队列 event_tv：后台记录运行的时间 timeheap：用小根堆管理超时事件队列 其他的参数不是很了解，以后用到了再琢磨。 libevent提供如下两个函数可以生成eventbase实例 12345678910111213141516171819202122232425event_init(void)&#123; struct event_base *base = event_base_new_with_config(NULL); if (base == NULL) &#123; event_errx(1, &quot;%s: Unable to construct event_base&quot;, __func__); return NULL; &#125; current_base = base; return (base);&#125;struct event_base *event_base_new(void)&#123; struct event_base *base = NULL; struct event_config *cfg = event_config_new(); if (cfg) &#123; base = event_base_new_with_config(cfg); event_config_free(cfg); &#125; return base;&#125; 到此为止基本的结构介绍完了。 七libevent事件添加/删除/初始化/派发接口分析1 event_base初始化和模型初始化 先看下初始化，实际上初始化是在event_base_new_with_config函数中完成的。 12345678struct event_base *event_base_new_with_config(const struct event_config *cfg)&#123; ... base-&gt;evsel = eventops[i]; base-&gt;evbase = base-&gt;evsel-&gt;init(base); ...&#125; event_init和eventbase_new都会调用event_base_new_with_config这个函数. 而base-&gt;evsel是不同模型的指针，进而实现调用不同模型的init 2 事件添加注册函数 123456789101112131415161718intevent_add(struct event *ev, const struct timeval *tv)&#123; int res; if (EVUTIL_FAILURE_CHECK(!ev-&gt;ev_base)) &#123; event_warnx(&quot;%s: event has no event_base set.&quot;, __func__); return -1; &#125; EVBASE_ACQUIRE_LOCK(ev-&gt;ev_base, th_base_lock); res = event_add_internal(ev, tv, 0); EVBASE_RELEASE_LOCK(ev-&gt;ev_base, th_base_lock); return (res);&#125; 防止多线程访问出错，加了锁，并且调用了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static inline intevent_add_internal(struct event *ev, const struct timeval *tv, int tv_is_absolute)&#123; struct event_base *base = ev-&gt;ev_base; int res = 0; int notify = 0; ... /* * 新的timer事件，调用timer heap接口在堆上预留一个位置 *向系统I/O机制注册可能会失败，而当在堆上预留成功后， * 定时事件的添加将肯定不会失败； */ if (tv != NULL &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123; if (min_heap_reserve(&amp;base-&gt;timeheap, 1 + min_heap_size(&amp;base-&gt;timeheap)) == -1) return (-1); /* ENOMEM == errno */ &#125; //根据不同的事件（IO，信号，超时事件等将fd放入不同的map if ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_SIGNAL)) &amp;&amp; !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE))) &#123; if (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE)) res = evmap_io_add(base, ev-&gt;ev_fd, ev); else if (ev-&gt;ev_events &amp; EV_SIGNAL) res = evmap_signal_add(base, (int)ev-&gt;ev_fd, ev); if (res != -1) //将event放入事件队列 event_queue_insert(base, ev, EVLIST_INSERTED); if (res == 1) &#123; /* evmap says we need to notify the main thread. */ notify = 1; res = 0; &#125; &#125; /* EVLIST_TIMEOUT表明event已经在定时器堆中了，删除旧的 */ if (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT) &#123; /* XXX I believe this is needless. */ if (min_heap_elt_is_top(ev)) notify = 1; event_queue_remove(base, ev, EVLIST_TIMEOUT); &#125; /* // 如果事件已经是就绪状态则从激活链表中删除 */ if ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp; (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123; if (ev-&gt;ev_events &amp; EV_SIGNAL) &#123; /* See if we are just active executing * this event in a loop */ if (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123; /* Abort loop */ *ev-&gt;ev_pncalls = 0; &#125; &#125; event_queue_remove(base, ev, EVLIST_ACTIVE); &#125; gettime(base, &amp;now); ... // 计算时间，并插入到timer小根堆中 event_queue_insert(base, ev, EVLIST_TIMEOUT); return (res);&#125; 在evmap_io_add里完成了io事件对于不同网络模型(select/epoll等)的绑定 1234567891011121314intevmap_io_add(struct event_base *base, evutil_socket_t fd, struct event *ev)&#123; ... const struct eventop *evsel = base-&gt;evsel; struct event_io_map *io = &amp;base-&gt;io; ... //将event的fd和类型注册到不同的网络模型 if (evsel-&gt;add(base, ev-&gt;ev_fd, old, (ev-&gt;ev_events &amp; EV_ET) | res, extra) == -1) return (-1); ... &#125; event_queue_insert()负责将事件插入到对应的链表中；event_queue_remove()负责将事件从对应的链表中删除； 12345678910111213141516171819202122232425262728void event_queue_insert(struct event_base *base, struct event *ev,int queue)&#123; // ev可能已经在激活列表中了，避免重复插入 if (ev-&gt;ev_flags &amp; queue) &#123; if (queue &amp; EVLIST_ACTIVE) return; &#125; // // 记录queue标记 ev-&gt;ev_flags |= queue; switch (queue) &#123; // I/O或Signal事件，加入已注册事件链表 case EVLIST_INSERTED: TAILQ_INSERT_TAIL(&amp;base-&gt;eventqueue, ev, ev_next); break; // 就绪事件，加入激活链表 case EVLIST_ACTIVE: base-&gt;event_count_active++; TAILQ_INSERT_TAIL(base-&gt;activequeues[ev-&gt;ev_pri], ev, ev_active_next); break; // 定时事件，加入堆 case EVLIST_TIMEOUT: min_heap_push(&amp;base-&gt;timeheap, ev); break; &#125;&#125; 3删除事件 123456789101112131415161718intevent_del(struct event *ev)&#123; int res; if (EVUTIL_FAILURE_CHECK(!ev-&gt;ev_base)) &#123; event_warnx(&quot;%s: event has no event_base set.&quot;, __func__); return -1; &#125; EVBASE_ACQUIRE_LOCK(ev-&gt;ev_base, th_base_lock); res = event_del_internal(ev); EVBASE_RELEASE_LOCK(ev-&gt;ev_base, th_base_lock); return (res);&#125; 内部调用了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static inline intevent_del_internal(struct event *ev)&#123; struct event_base *base; int res = 0, notify = 0; event_debug((&quot;event_del: %p (fd &quot;EV_SOCK_FMT&quot;), callback %p&quot;, ev, EV_SOCK_ARG(ev-&gt;ev_fd), ev-&gt;ev_callback)); /* An event without a base has not been added */ if (ev-&gt;ev_base == NULL) return (-1); base = ev-&gt;ev_base; EVUTIL_ASSERT(!(ev-&gt;ev_flags &amp; ~EVLIST_ALL)); //根据不同flag从队列中移除 if (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT) &#123; /* NOTE: We never need to notify the main thread because of a * deleted timeout event: all that could happen if we don&#x27;t is * that the dispatch loop might wake up too early. But the * point of notifying the main thread _is_ to wake up the * dispatch loop early anyway, so we wouldn&#x27;t gain anything by * doing it. */ event_queue_remove(base, ev, EVLIST_TIMEOUT); &#125; if (ev-&gt;ev_flags &amp; EVLIST_ACTIVE) event_queue_remove(base, ev, EVLIST_ACTIVE); if (ev-&gt;ev_flags &amp; EVLIST_INSERTED) &#123; event_queue_remove(base, ev, EVLIST_INSERTED); if (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE)) //io事件从map中移除 res = evmap_io_del(base, ev-&gt;ev_fd, ev); else res = evmap_signal_del(base, (int)ev-&gt;ev_fd, ev); if (res == 1) &#123; /* evmap says we need to notify the main thread. */ notify = 1; res = 0; &#125; &#125;return (res);&#125; evmap_io_del 中完成了不同模型del函数调用 12345678intevmap_io_del(struct event_base *base, evutil_socket_t fd, struct event *ev)&#123; if (evsel-&gt;del(base, ev-&gt;ev_fd, old, res, extra) == -1) return (-1);&#125; 4 事件派发 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485intevent_base_loop(struct event_base *base, int flags)&#123; const struct eventop *evsel = base-&gt;evsel; struct timeval tv; struct timeval *tv_p; int res, done, retval = 0; while (!done) &#123; base-&gt;event_continue = 0; /* Terminate the loop if we have been asked to */ //设置了event_gotterm或者event_break都会导致break if (base-&gt;event_gotterm) &#123; break; &#125; if (base-&gt;event_break) &#123; break; &#125; //校正系统时间 timeout_correct(base, &amp;tv); // 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer //的最大等待时间 tv_p = &amp;tv; if (!N_ACTIVE_CALLBACKS(base) &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123; timeout_next(base, &amp;tv_p); &#125; else &#123; /* * 如果有激活的事件，我们立即处理，不用等待 */ evutil_timerclear(&amp;tv); &#125; /* If we have no events, we just exit */ if (!event_haveevents(base) &amp;&amp; !N_ACTIVE_CALLBACKS(base)) &#123; event_debug((&quot;%s: no events registered.&quot;, __func__)); retval = 1; goto done; &#125; /* update last old time */ gettime(base, &amp;base-&gt;event_tv); clear_time_cache(base); //完成事件的派发，将就绪的事件放倒active列表里 res = evsel-&gt;dispatch(base, tv_p); if (res == -1) &#123; event_debug((&quot;%s: dispatch returned unsuccessfully.&quot;, __func__)); retval = -1; goto done; &#125; update_time_cache(base); timeout_process(base); // 调用event_process_active()处理激活链表中的就绪event，调用其 //回调函数执行事件处理 // 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件 //链表， // 然后处理链表中的所有就绪事件； // 因此低优先级的就绪事件可能得不到及时处理； if (N_ACTIVE_CALLBACKS(base)) &#123; int n = event_process_active(base); if ((flags &amp; EVLOOP_ONCE) &amp;&amp; N_ACTIVE_CALLBACKS(base) == 0 &amp;&amp; n != 0) done = 1; &#125; else if (flags &amp; EVLOOP_NONBLOCK) done = 1; &#125; event_debug((&quot;%s: asked to terminate loop.&quot;, __func__));done: clear_time_cache(base); base-&gt;running_loop = 0; EVBASE_RELEASE_LOCK(base, th_base_lock); return (retval);&#125; 调用evsel-&gt;dispatch后将事件放入active队列,然后process_active处理激活队列里的事件 123456789101112131415161718192021222324252627static intevent_process_active(struct event_base *base)&#123; /* Caller must hold th_base_lock */ struct event_list *activeq = NULL; int i, c = 0; for (i = 0; i &lt; base-&gt;nactivequeues; ++i) &#123; if (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != NULL) &#123; base-&gt;event_running_priority = i; activeq = &amp;base-&gt;activequeues[i]; c = event_process_active_single_queue(base, activeq); if (c &lt; 0) &#123; base-&gt;event_running_priority = -1; return -1; &#125; else if (c &gt; 0) break; /* Processed a real event; do not * consider lower-priority events */ /* If we get here, all of the events we processed * were internal. Continue. */ &#125; &#125; event_process_deferred_callbacks(&amp;base-&gt;defer_queue,&amp;base-&gt;event_break); base-&gt;event_running_priority = -1; return c;&#125; 优先级数字base-&gt;nactivequeues 以下的会被先处理。到目前为止介绍了libevent库的基本api和流程。对于不同的网络模型libevent是如何封装的呢？ 八libevent对于网络模型的封装(epoll为例)epoll基本单元封装 12345struct epollop &#123; struct epoll_event *events; int nevents; int epfd;&#125;; epfd：epoll_create 返回的epoll表句柄 events: 表示epoll表监听的epoll_event 队列 nevents:epoll_event队列大小 在介绍epoll封装的一些接口前，先看以下两个结构体定义的对象 1234567891011static const struct eventop epollops_changelist = &#123; &quot;epoll (with changelist)&quot;, epoll_init, event_changelist_add, event_changelist_del, epoll_dispatch, epoll_dealloc, 1, /* need reinit */ EV_FEATURE_ET|EV_FEATURE_O1, EVENT_CHANGELIST_FDINFO_SIZE&#125;; 结构体对象封装了epoll操作的函数指针， event_changelist_add表示设置changlist标记位时将事件加入changelist event_changelist_del表示如果设置了changelist标记位事件从changelist中移除。 1234567891011const struct eventop epollops = &#123; &quot;epoll&quot;, epoll_init, epoll_nochangelist_add, epoll_nochangelist_del, epoll_dispatch, epoll_dealloc, 1, /* need reinit */ EV_FEATURE_ET|EV_FEATURE_O1, 0&#125;; 这个结构体对象对应的是没设置changelist标记位时epoll的操作接口接下来看下epoll_init函数 123456789101112131415161718192021222324252627282930313233343536373839404142epoll_init(struct event_base *base)&#123; int epfd; struct epollop *epollop; /* Initialize the kernel queue. (The size field is ignored since * 2.6.8.) */ if ((epfd = epoll_create(32000)) == -1) &#123; if (errno != ENOSYS) event_warn(&quot;epoll_create&quot;); return (NULL); &#125; evutil_make_socket_closeonexec(epfd); if (!(epollop = mm_calloc(1, sizeof(struct epollop)))) &#123; close(epfd); return (NULL); &#125; epollop-&gt;epfd = epfd; /* Initialize fields */ epollop-&gt;events = mm_calloc(INITIAL_NEVENT, sizeof(struct epoll_event)); if (epollop-&gt;events == NULL) &#123; mm_free(epollop); close(epfd); return (NULL); &#125; epollop-&gt;nevents = INITIAL_NEVENT; //如果设置了EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST //添加和删除事件的回调函数变为changelist_add 和changelist_del if ((base-&gt;flags &amp; EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST) != 0 || ((base-&gt;flags &amp; EVENT_BASE_FLAG_IGNORE_ENV) == 0 &amp;&amp; evutil_getenv(&quot;EVENT_EPOLL_USE_CHANGELIST&quot;) != NULL)) base-&gt;evsel = &amp;epollops_changelist; evsig_init(base); return (epollop);&#125; 接下来看下epoll封装的事件注册接口，只看epoll_nochangelist_add，epoll_changelist_add都是类似的。 1234567891011121314151617static intepoll_nochangelist_add(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)&#123; struct event_change ch; ch.fd = fd; ch.old_events = old; ch.read_change = ch.write_change = 0; if (events &amp; EV_WRITE) ch.write_change = EV_CHANGE_ADD | (events &amp; EV_ET); if (events &amp; EV_READ) ch.read_change = EV_CHANGE_ADD | (events &amp; EV_ET); return epoll_apply_one_change(base, base-&gt;evbase, &amp;ch);&#125; 在epoll_apply_one_change中完成事件添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130static intepoll_apply_one_change(struct event_base *base, struct epollop *epollop, const struct event_change *ch)&#123; struct epoll_event epev; int op, events = 0; if (1) &#123; if ((ch-&gt;read_change &amp; EV_CHANGE_ADD) || (ch-&gt;write_change &amp; EV_CHANGE_ADD)) &#123; events = 0; op = EPOLL_CTL_ADD; //关注读事件 if (ch-&gt;read_change &amp; EV_CHANGE_ADD) &#123; events |= EPOLLIN; &#125; else if (ch-&gt;read_change &amp; EV_CHANGE_DEL) &#123; ; &#125; else if (ch-&gt;old_events &amp; EV_READ) &#123; events |= EPOLLIN; &#125; //关注写事件 if (ch-&gt;write_change &amp; EV_CHANGE_ADD) &#123; events |= EPOLLOUT; &#125; else if (ch-&gt;write_change &amp; EV_CHANGE_DEL) &#123; ; &#125; else if (ch-&gt;old_events &amp; EV_WRITE) &#123; events |= EPOLLOUT; &#125; //设置et模型 if ((ch-&gt;read_change|ch-&gt;write_change) &amp; EV_ET) events |= EPOLLET; //之前有事件关注，将操作改为EPOLL_CTL_MOD if (ch-&gt;old_events) &#123; op = EPOLL_CTL_MOD; &#125; &#125; else if ((ch-&gt;read_change &amp; EV_CHANGE_DEL) || (ch-&gt;write_change &amp; EV_CHANGE_DEL)) &#123; op = EPOLL_CTL_DEL; //之前关注过删除该事件 if (ch-&gt;read_change &amp; EV_CHANGE_DEL) &#123; if (ch-&gt;write_change &amp; EV_CHANGE_DEL) &#123; //读写事件都设置删除标记 events = EPOLLIN|EPOLLOUT; &#125; else if (ch-&gt;old_events &amp; EV_WRITE) &#123; events = EPOLLOUT; //只有写事件要求删除，那么更改为读事件 op = EPOLL_CTL_MOD; &#125; else &#123; //只删除读事件 events = EPOLLIN; &#125; &#125; else if (ch-&gt;write_change &amp; EV_CHANGE_DEL) &#123; if (ch-&gt;old_events &amp; EV_READ) &#123; events = EPOLLIN; //更改为关注读事件 op = EPOLL_CTL_MOD; &#125; else &#123; //只删除写事件 events = EPOLLOUT; &#125; &#125; &#125; if (!events) return 0; memset(&amp;epev, 0, sizeof(epev)); epev.data.fd = ch-&gt;fd; epev.events = events; //调用epoll_ctl设置event进入epoll监听队列 if (epoll_ctl(epollop-&gt;epfd, op, ch-&gt;fd, &amp;epev) == -1) &#123; if (op == EPOLL_CTL_MOD &amp;&amp; errno == ENOENT) &#123; if (epoll_ctl(epollop-&gt;epfd, EPOLL_CTL_ADD, ch-&gt;fd, &amp;epev) == -1) &#123; event_warn(&quot;Epoll MOD(%d) on %d retried as ADD; that failed too&quot;, (int)epev.events, ch-&gt;fd); return -1; &#125; else &#123; event_debug((&quot;Epoll MOD(%d) on %d retried as ADD; succeeded.&quot;, (int)epev.events, ch-&gt;fd)); &#125; &#125; else if (op == EPOLL_CTL_ADD &amp;&amp; errno == EEXIST) &#123; if (epoll_ctl(epollop-&gt;epfd, EPOLL_CTL_MOD, ch-&gt;fd, &amp;epev) == -1) &#123; event_warn(&quot;Epoll ADD(%d) on %d retried as MOD; that failed too&quot;, (int)epev.events, ch-&gt;fd); return -1; &#125; else &#123; event_debug((&quot;Epoll ADD(%d) on %d retried as MOD; succeeded.&quot;, (int)epev.events, ch-&gt;fd)); &#125; &#125; else if (op == EPOLL_CTL_DEL &amp;&amp; (errno == ENOENT || errno == EBADF || errno == EPERM)) &#123; event_debug((&quot;Epoll DEL(%d) on fd %d gave %s: DEL was unnecessary.&quot;, (int)epev.events, ch-&gt;fd, strerror(errno))); &#125; else &#123; event_warn(&quot;Epoll %s(%d) on fd %d failed. Old events were %d; read change was %d (%s); write change was %d (%s)&quot;, epoll_op_to_string(op), (int)epev.events, ch-&gt;fd, ch-&gt;old_events, ch-&gt;read_change, change_to_string(ch-&gt;read_change), ch-&gt;write_change, change_to_string(ch-&gt;write_change)); return -1; &#125; &#125; else &#123; event_debug((&quot;Epoll %s(%d) on fd %d okay. [old events were %d; read change was %d; write change was %d]&quot;, epoll_op_to_string(op), (int)epev.events, (int)ch-&gt;fd, ch-&gt;old_events, ch-&gt;read_change, ch-&gt;write_change)); &#125; &#125; return 0;&#125; 删除事件也是类似的，内部调用epoll_apply_onechange知识将事件标记位EV_CHANGE_DEL,到函数内部解析为epoll_del或者epoll_mod 123456789101112131415static intepoll_nochangelist_del(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)&#123; struct event_change ch; ch.fd = fd; ch.old_events = old; ch.read_change = ch.write_change = 0; if (events &amp; EV_WRITE) ch.write_change = EV_CHANGE_DEL; if (events &amp; EV_READ) ch.read_change = EV_CHANGE_DEL; return epoll_apply_one_change(base, base-&gt;evbase, &amp;ch);&#125; 最后是事件派发 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static intepoll_dispatch(struct event_base *base, struct timeval *tv)&#123; struct epollop *epollop = base-&gt;evbase; struct epoll_event *events = epollop-&gt;events; int i, res; long timeout = -1; if (tv != NULL) &#123; timeout = evutil_tv_to_msec(tv); if (timeout &lt; 0 || timeout &gt; MAX_EPOLL_TIMEOUT_MSEC) &#123; /* Linux kernels can wait forever if the timeout is * too big; see comment on MAX_EPOLL_TIMEOUT_MSEC. */ timeout = MAX_EPOLL_TIMEOUT_MSEC; &#125; &#125; //处理changelis列表的所有事件 epoll_apply_changes(base); event_changelist_remove_all(&amp;base-&gt;changelist, base); EVBASE_RELEASE_LOCK(base, th_base_lock); //处理epoll_wait返回就绪描述符个数 res = epoll_wait(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout); EVBASE_ACQUIRE_LOCK(base, th_base_lock); if (res == -1) &#123; if (errno != EINTR) &#123; event_warn(&quot;epoll_wait&quot;); return (-1); &#125; return (0); &#125; event_debug((&quot;%s: epoll_wait reports %d&quot;, __func__, res)); EVUTIL_ASSERT(res &lt;= epollop-&gt;nevents); for (i = 0; i &lt; res; i++) &#123; int what = events[i].events; short ev = 0; if (what &amp; (EPOLLHUP|EPOLLERR)) &#123; ev = EV_READ | EV_WRITE; &#125; else &#123; if (what &amp; EPOLLIN) ev |= EV_READ; if (what &amp; EPOLLOUT) ev |= EV_WRITE; &#125; if (!ev) continue; //将event放入active队列中 evmap_io_active(base, events[i].data.fd, ev | EV_ET); &#125; //epoll就绪数量等于队列长度，额外开辟空间确保新的事件可以触发 if (res == epollop-&gt;nevents &amp;&amp; epollop-&gt;nevents &lt; MAX_NEVENT) &#123; /* We used all of the event space this time. We should be ready for more events next time. */ int new_nevents = epollop-&gt;nevents * 2; struct epoll_event *new_events; new_events = mm_realloc(epollop-&gt;events, new_nevents * sizeof(struct epoll_event)); if (new_events) &#123; epollop-&gt;events = new_events; epollop-&gt;nevents = new_nevents; &#125; &#125; return (0);&#125; 以上就是livevent对于epoll的基本封装。整个结构体对象epollops在event.c中被赋值给eventops[]的 123456789101112131415161718192021222324static const struct eventop *eventops[] = &#123;#ifdef _EVENT_HAVE_EVENT_PORTS &amp;evportops,#endif#ifdef _EVENT_HAVE_WORKING_KQUEUE &amp;kqops,#endif#ifdef _EVENT_HAVE_EPOLL &amp;epollops,#endif#ifdef _EVENT_HAVE_DEVPOLL &amp;devpollops,#endif#ifdef _EVENT_HAVE_POLL &amp;pollops,#endif#ifdef _EVENT_HAVE_SELECT &amp;selectops,#endif#ifdef WIN32 &amp;win32ops,#endif NULL&#125;; 之后在event_base_new_with_config中调用base-&gt;evsel = eventops[i];完成不同模型的结构体对象赋值给base的evsel指针的。 目前对于libevent的分析和理解先告一段落，以后会更新对libevent的更深刻认识。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"windows环境libevent搭建和demo分析","date":"2017-08-07T02:53:56.000Z","path":"2017/08/07/winlibevent/","text":"libevent框架之前有做过分析，这次是谈谈如何将libevent搭建在vs工作环境下，并且编写一个demo进行测试。测试过程中会再一次带大家分析消息是怎么传递的。我的libevent版本libevent-2.0.22-stable，用对应的vs命令工具进入该目录 我的是Visual Studio 2008版本的Command Prompt执行成功后在libevent目录下生成三个lib之后用vs创建控制台项目生成成功后在项目目录里创建Include和Lib两个文件夹分别进入libevent这两个目录里边将内部的所有文件拷贝到Include文件夹里，event内容重复可以合并我们项目目录Include文件夹下的内容为将libevent库中的三个lib拷贝到项目的Lib文件夹里下一步配置项目属性，完成编译1、配置头文件包含路径，C++/General/Additional Include Directories 配置为相对路径的Include（因配置的路径不同而异）2、配置代码生成C/C++ /Code Generation RuntimeLibrary 设置为MTD,因为库的生成是按照这个MTD模式生成的，所以要匹配3、配置 C/C++ /Advanced/Compile As Compile as C++ Code (/TP) （因为我的工程用到C++的函数所以配置这个）网上有人推荐配置成TC的也可以，自己根据项目需要4、配置库目录Linker/General/Additional Library Directories ..\\Lib(根据自己的Lib文件夹和项目相对位置填写)5配置 Linker\\Input\\AdditionalLibraries ws2_32.lib;wsock32.lib;libevent.lib;libevent_core.lib;libevent_extras.lib;6 配置忽略项，可以不配置 输入\\忽略特定默认库 libc.lib;msvcrt.lib;libcd.lib;libcmtd.lib;msvcrtd.lib;%(IgnoreSpecificDefaultLibraries)生成lib后，不带调试信息，无法单步进函数里，所以要修改脚本：Makefile.nmake第二行CFLAGS=$(CFLAGS) /Od /W3 /wd4996 /nologo /Zi到此为止项目配置好了，我们来写相关的demo代码 主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int main(int argc, char **argv)&#123; struct event_base *base; struct evconnlistener *listener; struct event *signal_event; struct sockaddr_in sin;#ifdef WIN32 WSADATA wsa_data; WSAStartup(0x0201, &amp;wsa_data);#endif //创建event_base base = event_base_new(); if (!base) &#123; fprintf(stderr, &quot;Could not initialize libevent!\\n&quot;); return 1; &#125; memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_port = htons(PORT); sin.sin_addr.s_addr = inet_addr(&quot;192.168.1.99&quot;); //std::string ipstr = inet_ntoa(sin.sin_addr); //std::cout &lt;&lt; ipstr.c_str(); //基于eventbase 生成listen描述符并绑定 //设置了listener_cb回调函数，当有新的连接登录的时候 //触发listener_cb listener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; fprintf(stderr, &quot;Could not create a listener!\\n&quot;); return 1; &#125; //设置终端信号，当程序收到SIGINT后调用signal_cb signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base); if (!signal_event || event_add(signal_event, NULL)&lt;0) &#123; fprintf(stderr, &quot;Could not create/add a signal event!\\n&quot;); return 1; &#125; //event_base消息派发 event_base_dispatch(base); //释放生成的evconnlistener evconnlistener_free(listener); //释放生成的信号事件 event_free(signal_event); //释放event_base event_base_free(base); printf(&quot;done\\n&quot;); return 0;&#125; listener回调函数 12345678910111213141516171819202122static void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data)&#123; struct event_base *base = (struct event_base *)user_data; struct bufferevent *bev; //生成一个bufferevent，用于读或者写 bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; fprintf(stderr, &quot;Error constructing bufferevent!&quot;); event_base_loopbreak(base); return; &#125; //设置了写回调函数和事件的回调函数 bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL); //bufferevent设置写事件回调 bufferevent_enable(bev, EV_WRITE); //bufferevent关闭读事件回调 bufferevent_disable(bev, EV_READ); //将MESSAGE字符串拷贝到outbuffer里 bufferevent_write(bev, MESSAGE, strlen(MESSAGE));&#125; 一些基本参数 static const char MESSAGE[] = “Hello, NewConnection!\\n”; static const int PORT = 9995;bufferevent的写回调函数 1234567891011static void conn_writecb(struct bufferevent *bev, void *user_data)&#123; //取出bufferevent 的output数据 struct evbuffer *output = bufferevent_get_output(bev); //长度为0，那么写完毕，释放空间 if (evbuffer_get_length(output) == 0) &#123; printf(&quot;flushed answer\\n&quot;); bufferevent_free(bev); &#125;&#125; bufferevent的事件回调函数 1234567891011121314151617//仅仅作为事件回调函数，写自己想要做的功能就行//最后记得释放buffevent空间static void conn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; printf(&quot;Connection closed.\\n&quot;); &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; printf(&quot;Got an error on the connection: %s\\n&quot;, strerror(errno));/*XXX win32*/ &#125; /* None of the other events can happen here, since we haven&#x27;t enabled * timeouts */ bufferevent_free(bev);&#125; 信号终止函数 12345678910//程序捕捉到信号后就让baseloop终止static void signal_cb(evutil_socket_t sig, short events, void *user_data)&#123; struct event_base *base = (struct event_base *)user_data; struct timeval delay = &#123; 2, 0 &#125;; printf(&quot;Caught an interrupt signal; exiting cleanly in two seconds.\\n&quot;); event_base_loopexit(base, &amp;delay);&#125; 整个demo完成了。 下面分析下libevent如何做的消息传递和回调注册函数从main函数中的evconnlistener_new_bind入手 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen)&#123; struct evconnlistener *listener; evutil_socket_t fd; int on = 1; int family = sa ? sa-&gt;sa_family : AF_UNSPEC; if (backlog == 0) return NULL; fd = socket(family, SOCK_STREAM, 0); if (fd == -1) return NULL; if (evutil_make_socket_nonblocking(fd) &lt; 0) &#123; evutil_closesocket(fd); return NULL; &#125; if (flags &amp; LEV_OPT_CLOSE_ON_EXEC) &#123; if (evutil_make_socket_closeonexec(fd) &lt; 0) &#123; evutil_closesocket(fd); return NULL; &#125; &#125; if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;on, sizeof(on))&lt;0) &#123; evutil_closesocket(fd); return NULL; &#125; if (flags &amp; LEV_OPT_REUSEABLE) &#123; if (evutil_make_listen_socket_reuseable(fd) &lt; 0) &#123; evutil_closesocket(fd); return NULL; &#125; &#125; if (sa) &#123; if (bind(fd, sa, socklen)&lt;0) &#123; evutil_closesocket(fd); return NULL; &#125; &#125; //cb = listener_cb, ptr = struct event_base *base; listener = evconnlistener_new(base, cb, ptr, flags, backlog, fd); if (!listener) &#123; evutil_closesocket(fd); return NULL; &#125; return listener;&#125; evconnlistener_new_bind 完成了socket生成和绑定，并且内部调用evconnlistener_new 生成了evconnlistener* listener,将listener和socket绑定在一起。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)&#123; struct evconnlistener_event *lev; if (backlog &gt; 0) &#123; if (listen(fd, backlog) &lt; 0) return NULL; &#125; else if (backlog &lt; 0) &#123; if (listen(fd, 128) &lt; 0) return NULL; &#125; //开辟evconnlistener_event大小区域 lev = mm_calloc(1, sizeof(struct evconnlistener_event)); if (!lev) return NULL; //lev -&gt; base 表示 evconnlistener //evconnlistener evconnlistener_ops 基本回调参数和回调函数结构体赋值 lev-&gt;base.ops = &amp;evconnlistener_event_ops; //evconnlistener_cb 设置为listener_cb lev-&gt;base.cb = cb; //ptr表示event_base 指针 lev-&gt;base.user_data = ptr; lev-&gt;base.flags = flags; lev-&gt;base.refcnt = 1; if (flags &amp; LEV_OPT_THREADSAFE) &#123; EVTHREAD_ALLOC_LOCK(lev-&gt;base.lock, EVTHREAD_LOCKTYPE_RECURSIVE); &#125; // lev is evconnlistener_event //lev-&gt;listener is event //为lev-&gt;listener设置读回调函数和读关注事件，仅进行设置并没加入event队列 event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST, listener_read_cb, lev); //实际调用了event_add将事件加入event队列 evconnlistener_enable(&amp;lev-&gt;base); return &amp;lev-&gt;base;&#125;lev = mm_calloc(1, sizeof(struct evconnlistener_event));开辟了一个evconnlistener_event* 空间，evconnlistener_event类型如下struct evconnlistener_event &#123; struct evconnlistener base; struct event listener;&#125;; 该结构包含一个evconnlistener和event事件结构体 evconnlistener结构如下 12345678910111213141516171819202122232425struct evconnlistener &#123; //listener基本操作封装成一个结构体 //结构体包含操作的函数指针 const struct evconnlistener_ops *ops; void *lock; //listener回调函数，有新的连接到来会触发 evconnlistener_cb cb; //listener有错误会触发这个函数 evconnlistener_errorcb errorcb; //存储一些回调函数用到的参数 void *user_data; unsigned flags; short refcnt; unsigned enabled : 1;&#125;;struct evconnlistener_ops &#123; int (*enable)(struct evconnlistener *); int (*disable)(struct evconnlistener *); void (*destroy)(struct evconnlistener *); void (*shutdown)(struct evconnlistener *); evutil_socket_t (*getfd)(struct evconnlistener *); struct event_base *(*getbase)(struct evconnlistener *);&#125;; lev-&gt;base.ops = &amp;evconnlistener_event_ops;这句就是对这个结构体指针赋值，evconnlistener_event_ops是一个实例化的结构体对象，里面包含定义好的操作函数 12345678static const struct evconnlistener_ops evconnlistener_event_ops = &#123; event_listener_enable, event_listener_disable, event_listener_destroy, NULL, /* shutdown */ event_listener_getfd, event_listener_getbase&#125;; 对lev-&gt;base其余参数的赋值就不一一解释了。接下来看一下event_assign函数内部实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; if (!base) base = current_base; _event_debug_assert_not_added(ev); //属于哪个event_base ev-&gt;ev_base = base; //事件回调函数 ev-&gt;ev_callback = callback; //回调函数的参数 ev-&gt;ev_arg = arg; //event关注哪个fd ev-&gt;ev_fd = fd; //event事件类型 ev-&gt;ev_events = events; ev-&gt;ev_res = 0; ev-&gt;ev_flags = EVLIST_INIT; //被调用过几次 ev-&gt;ev_ncalls = 0; ev-&gt;ev_pncalls = NULL; if (events &amp; EV_SIGNAL) &#123; if ((events &amp; (EV_READ|EV_WRITE)) != 0) &#123; event_warnx(&quot;%s: EV_SIGNAL is not compatible with &quot; &quot;EV_READ or EV_WRITE&quot;, __func__); return -1; &#125; ev-&gt;ev_closure = EV_CLOSURE_SIGNAL; &#125; else &#123; if (events &amp; EV_PERSIST) &#123; evutil_timerclear(&amp;ev-&gt;ev_io_timeout); ev-&gt;ev_closure = EV_CLOSURE_PERSIST; &#125; else &#123; ev-&gt;ev_closure = EV_CLOSURE_NONE; &#125; &#125; min_heap_elem_init(ev); if (base != NULL) &#123; /* by default, we put new events into the middle priority */ //优先级的设置 ev-&gt;ev_pri = base-&gt;nactivequeues / 2; &#125; _event_debug_note_setup(ev); return 0;&#125; event_assign内部实现可以看出该函数仅仅对event的属性进行设置 event_assign主要对event设置了listener_read_cb回调函数，这是 很重要的一个细节，我们看下listener_read_cb内部实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static voidlistener_read_cb(evutil_socket_t fd, short what, void *p)&#123; struct evconnlistener *lev = p; int err; evconnlistener_cb cb; evconnlistener_errorcb errorcb; void *user_data; LOCK(lev); while (1) &#123; struct sockaddr_storage ss;#ifdef WIN32 int socklen = sizeof(ss);#else socklen_t socklen = sizeof(ss);#endif //调用accept生成新的fd evutil_socket_t new_fd = accept(fd, (struct sockaddr*)&amp;ss, &amp;socklen); if (new_fd &lt; 0) break; if (socklen == 0) &#123; /* This can happen with some older linux kernels in * response to nmap. */ evutil_closesocket(new_fd); continue; &#125; //设置非阻塞 if (!(lev-&gt;flags &amp; LEV_OPT_LEAVE_SOCKETS_BLOCKING)) evutil_make_socket_nonblocking(new_fd); if (lev-&gt;cb == NULL) &#123; evutil_closesocket(new_fd); UNLOCK(lev); return; &#125; ++lev-&gt;refcnt; //cb 就 是 listener_cb cb = lev-&gt;cb; user_data = lev-&gt;user_data; UNLOCK(lev); //触发了listener_cb //完成了eventbuffer注册写和事件函数 cb(lev, new_fd, (struct sockaddr*)&amp;ss, (int)socklen, user_data); LOCK(lev); if (lev-&gt;refcnt == 1) &#123; int freed = listener_decref_and_unlock(lev); EVUTIL_ASSERT(freed); return; &#125; --lev-&gt;refcnt; &#125; 。。。。。。。。。&#125; 在evconnlistener_new中//evconnlistener_cb 设置为listener_cblev-&gt;base.cb = cb; lev-&gt;base就是evconnlistener对象 listener_read_cb内部回调用绑定在evconnlistener的listener_cb。 记得之前我所说的绑定么？evconnlistener_new这个函数里生成的lev， 之后对lev，这里的lev就是 evconnlistener_event对象，lev-&gt;listener是 event对象，通过调用event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST, listener_read_cb, lev); lev-&gt;listener绑定的就是listener_read_cb。也就是是说 listener_read_cb调用后，从而调用了绑定在evconnlistener的listener_cb。 那么我们只要知道lev-&gt;listener（event对象）的读事件是如何派发的就可以梳理此 流程了。 之前我们梳理过event_dispatch里进行的事件派发，调用不同模型的dispatch， 稍后再梳理一遍。因为调用event_assign仅仅对event设置了属性，还没有加到 事件队列里。 在evconnlistener_new函数里调用完event_assign，之后调用的是 evconnlistener_enable，evconnlistener_enable这个函数完成了事件 添加到事件队列的功能。 12345678910111213141516intevconnlistener_enable(struct evconnlistener *lev)&#123; int r; LOCK(lev); lev-&gt;enabled = 1; if (lev-&gt;cb) //调用evconnlistener 的ops的enable函数 //lev-&gt;ops 此时指向evconnlistener_event_ops //enable函数为 event_listener_enable r = lev-&gt;ops-&gt;enable(lev); else r = 0; UNLOCK(lev); return r;&#125; 上面有evconnlistener_event_ops结构体，那几个函数也列出来了。 我们看下event_listener_enable函数 123456789static intevent_listener_enable(struct evconnlistener *lev)&#123; //通过evconnlistener* 找到evconnlistener_event * struct evconnlistener_event *lev_e = EVUTIL_UPCAST(lev, struct evconnlistener_event, base); //将 return event_add(&amp;lev_e-&gt;listener, NULL);&#125; 里面调用了event_add 12345678910111213141516171819//添加事件操作intevent_add(struct event *ev, const struct timeval *tv)&#123; int res; if (EVUTIL_FAILURE_CHECK(!ev-&gt;ev_base)) &#123; event_warnx(&quot;%s: event has no event_base set.&quot;, __func__); return -1; &#125; EVBASE_ACQUIRE_LOCK(ev-&gt;ev_base, th_base_lock); //添加事件核心函数 res = event_add_internal(ev, tv, 0); EVBASE_RELEASE_LOCK(ev-&gt;ev_base, th_base_lock); return (res);&#125; 对于event_add内部判断是否枷锁，进行加锁，然后调用 event_add_internal完成事件添加 123456789101112131415161718192021222324252627282930static inline intevent_add_internal(struct event *ev, const struct timeval *tv, int tv_is_absolute)&#123; struct event_base *base = ev-&gt;ev_base; int res = 0; int notify = 0; //根据不同的事件类型将事件放到evmap里，调用不同模型的add函数 //将事件按照EV_READ或者EV_WRITE或者EV_SIGNAL放入evmap事件队列里 //将ev按照EVLIST_INSERTED放入用户的事件队列里 if ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_SIGNAL)) &amp;&amp; !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE))) &#123; if (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE)) //将事件按照读写 IO方式加入evmap里，并且调用不同网络模型的add完成事件添加 res = evmap_io_add(base, ev-&gt;ev_fd, ev); else if (ev-&gt;ev_events &amp; EV_SIGNAL) //将事件按照信号方式添加 res = evmap_signal_add(base, (int)ev-&gt;ev_fd, ev); //将事件插入轮询的事件队列里 if (res != -1) event_queue_insert(base, ev, EVLIST_INSERTED); if (res == 1) &#123; /* evmap says we need to notify the main thread. */ notify = 1; res = 0; &#125; &#125;&#125; 由于lev-&gt;listener（event）类型的事件是I/O 读事件，所以会进入evmap_io_add完成读事件的添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263intevmap_io_add(struct event_base *base, evutil_socket_t fd, struct event *ev)&#123; const struct eventop *evsel = base-&gt;evsel; struct event_io_map *io = &amp;base-&gt;io; struct evmap_io *ctx = NULL; int nread, nwrite, retval = 0; short res = 0, old = 0; struct event *old_ev; EVUTIL_ASSERT(fd == ev-&gt;ev_fd); if (fd &lt; 0) return 0;//windows情况下use a hashtable instead of an array#ifndef EVMAP_USE_HT if (fd &gt;= io-&gt;nentries) &#123; if (evmap_make_space(io, fd, sizeof(struct evmap_io *)) == -1) return (-1); &#125;#endif //从io中找到下标为fd的结构体数据 evmap_io * 赋值给ctx //如果没有找到就调用evmap_io_init初始化 GET_IO_SLOT_AND_CTOR(ctx, io, fd, evmap_io, evmap_io_init, evsel-&gt;fdinfo_len); nread = ctx-&gt;nread; nwrite = ctx-&gt;nwrite; if (nread) old |= EV_READ; if (nwrite) old |= EV_WRITE; if (ev-&gt;ev_events &amp; EV_READ) &#123; if (++nread == 1) res |= EV_READ; &#125; if (ev-&gt;ev_events &amp; EV_WRITE) &#123; if (++nwrite == 1) res |= EV_WRITE; &#125; ......if (res) &#123; void *extra = ((char*)ctx) + sizeof(struct evmap_io); /* XXX(niels): we cannot mix edge-triggered and * level-triggered, we should probably assert on * this. */ //这里就是调用了不同模型的demultiplexer的添加操作 //调用不同的网络模型add接口 if (evsel-&gt;add(base, ev-&gt;ev_fd, old, (ev-&gt;ev_events &amp; EV_ET) | res, extra) == -1) return (-1); retval = 1; &#125; ctx-&gt;nread = (ev_uint16_t) nread; ctx-&gt;nwrite = (ev_uint16_t) nwrite; //哈希表对应的event事件队列加入ev TAILQ_INSERT_TAIL(&amp;ctx-&gt;events, ev, ev_io_next); return (retval);&#125; 该函数内部的一些函数就不展开，挺好理解的。到此为止我们了解了listen描述符的回调函数和读事件的绑定。 回到main函数，看下event_base_dispatch就知道绑定在lev-&gt;listener（event）类型的读事件listener_read_cb 是如何派发的，进而在读事件里完成了evconnlistener的listener_cb的调用。 12345intevent_base_dispatch(struct event_base *event_base)&#123; return (event_base_loop(event_base, 0));&#125; int event_base_loop(struct event_base *base, int flags)这个函数内部 我们只看关键代码 1234567891011121314151617181920212223242526intevent_base_loop(struct event_base *base, int flags)&#123; const struct eventop *evsel = base-&gt;evsel; //不同模型的派发函数 //evsel就是指向ops数组的某一种模型 res = evsel-&gt;dispatch(base, tv_p); if (N_ACTIVE_CALLBACKS(base)) &#123; //处理激活队列中的事件 int n = event_process_active(base); if ((flags &amp; EVLOOP_ONCE) &amp;&amp; N_ACTIVE_CALLBACKS(base) == 0 &amp;&amp; n != 0) done = 1; &#125; else if (flags &amp; EVLOOP_NONBLOCK) done = 1;&#125; 之前有说过evsel初始化和模型选择的代码，这里重新梳理下const struct eventop *evsel; event_base_new或者event_init内部调用了event_base_new_with_config， event_base_new_with_config函数调用了base-&gt;evsel = eventops[i]; eventops属主封装了几种模型结构体的指针 123456789101112131415161718192021222324static const struct eventop *eventops[] = &#123;#ifdef _EVENT_HAVE_EVENT_PORTS &amp;evportops,#endif#ifdef _EVENT_HAVE_WORKING_KQUEUE &amp;kqops,#endif#ifdef _EVENT_HAVE_EPOLL &amp;epollops,#endif#ifdef _EVENT_HAVE_DEVPOLL &amp;devpollops,#endif#ifdef _EVENT_HAVE_POLL &amp;pollops,#endif#ifdef _EVENT_HAVE_SELECT &amp;selectops,#endif#ifdef WIN32 &amp;win32ops,#endif NULL&#125;; 举个例子，看下epollops 1234567891011const struct eventop epollops = &#123; &quot;epoll&quot;, epoll_init, epoll_nochangelist_add, epoll_nochangelist_del, epoll_dispatch, epoll_dealloc, 1, /* need reinit */ EV_FEATURE_ET|EV_FEATURE_O1, 0&#125;; eventop 类型 1234567891011121314151617181920struct eventop &#123; /** The name of this backend. */ const char *name; void *(*init)(struct event_base *); int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo); int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo); int (*dispatch)(struct event_base *, struct timeval *); /** Function to clean up and free our data from the event_base. */ void (*dealloc)(struct event_base *); int need_reinit; enum event_method_feature features; size_t fdinfo_len;&#125;; epollops是eventop类型的变量，实现了增加删除，初始化，销毁，派发等功能。 所以当模型选择epoll时,res = evsel-&gt;dispatch(base, tv_p);实际调用的是epoll的派发函数 1234567891011121314151617181920212223242526272829static int epoll_dispatch(struct event_base *base, struct timeval *tv)&#123; struct epollop *epollop = base-&gt;evbase; struct epoll_event *events = epollop-&gt;events; res = epoll_wait(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout); for (i = 0; i &lt; res; i++) &#123; int what = events[i].events; short ev = 0; if (what &amp; (EPOLLHUP|EPOLLERR)) &#123; ev = EV_READ | EV_WRITE; &#125; else &#123; if (what &amp; EPOLLIN) ev |= EV_READ; if (what &amp; EPOLLOUT) ev |= EV_WRITE; &#125; if (!ev) continue; //更新evmap，并且将事件放入active队列 evmap_io_active(base, events[i].data.fd, ev | EV_ET); &#125;&#125; `evmap_io_active函数内部调用event_active_nolock，event_active_nolock中调用 event_queue_insert(base, ev, EVLIST_ACTIVE);负责将event放入激活队列里， 并且更新event在evmap中的 标记状态。` 到目前为止我们了解了事件派发的流程，event_base_loop循环执行网络模型的dispatch，内核返回就绪事件，dispatch内部调用evmap_io_active将就绪事件放入激活队列里。 在event_base_loop中调用event_process_active处理就绪队列中的event。比如内核返回listen描述符读就绪事件，那么就会将listen的event放入就绪队列中， 在event_process_active处理event的读事件，调用了之前绑定的listener_read_cb回调函数。 下面看下 123456789101112131415161718192021222324static intevent_process_active(struct event_base *base)&#123; /* Caller must hold th_base_lock */ struct event_list *activeq = NULL; int i, c = 0; //循环处理就绪队列中的每一个就绪事件 for (i = 0; i &lt; base-&gt;nactivequeues; ++i) &#123; if (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != NULL) &#123; base-&gt;event_running_priority = i; activeq = &amp;base-&gt;activequeues[i]; c = event_process_active_single_queue(base, activeq); if (c &lt; 0) &#123; base-&gt;event_running_priority = -1; return -1; &#125; else if (c &gt; 0) break; &#125; &#125; //调用延时回调函数 event_process_deferred_callbacks(&amp;base-&gt;defer_queue,&amp;base-&gt;event_break); base-&gt;event_running_priority = -1; return c;&#125; 循环调用了event_process_active_single_queue 1234567891011121314switch (ev-&gt;ev_closure) &#123; case EV_CLOSURE_SIGNAL: event_signal_closure(base, ev); break; case EV_CLOSURE_PERSIST: event_persist_closure(base, ev); break; default: case EV_CLOSURE_NONE: EVBASE_RELEASE_LOCK(base, th_base_lock); (*ev-&gt;ev_callback)( ev-&gt;ev_fd, ev-&gt;ev_res, ev-&gt;ev_arg); break; &#125; (*ev-&gt;ev_callback)(ev-&gt;ev_fd, ev-&gt;ev_res, ev-&gt;ev_arg);就是调用绑定在event上的回调函数。比如绑定在lev-&gt;listener（event）类型的读事件listener_read_cb; 从而调用了绑定在evconnlistener的listener_cb。 这样整个流程就跑通了。最上面有listener_cb函数的实现，整个消息传递流程不跟踪了，读者可以模仿上面的方式去跟踪消息。 这里简单表述下在bufferevent创建的时候调用了这个函数 12345678910111213141516171819202122struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options)&#123; struct bufferevent_private *bufev_p; struct bufferevent *bufev; ... //设置bufferevent中 ev_read(event类型)回调函数 event_assign(&amp;bufev-&gt;ev_read, bufev-&gt;ev_base, fd, EV_READ|EV_PERSIST, bufferevent_readcb, bufev); //设置bufferevent中 ev_write(event类型)回调函数 event_assign(&amp;bufev-&gt;ev_write, bufev-&gt;ev_base, fd, EV_WRITE|EV_PERSIST, bufferevent_writecb, bufev); //为bufev-&gt;output(evbuffer类型)设置回调函数，回调函数内部将ev_write事件加入事件队列 evbuffer_add_cb(bufev-&gt;output, bufferevent_socket_outbuf_cb, bufev); ... return bufev;&#125; 函数内部为ev_read和ev_write 设置默认的回调函数bufferevent_readcb和bufferevent_writecb。接着为输出的 evbuffer绑定bufferevent_socket_outbuf_cb函数。 bufferevent_socket_outbuf_cb函数如果发现我们有可写的东西，并且没开始写，那么 将ev_ write事件加入event队列，跟上面的轮询一样，有可写就绪事件就会触发绑定在ev_write上的bufferevent-writecb函数。如果没有添加写的数据，就跳出函数。之后调用。由于这时处于bufferevent刚创建状态，那么说明没有数据写入bufferevent，所以这时是不会将ev_write加入event队列的。回到listener_cb函数。接着调用bufferevent_setcb 函数设置bufferevent的读，写，事件， 回调函数。 调用bufferevent_enable使写事件生效， 内部调用 bufev-&gt;be_ops-&gt;enable(bufev, impl_events)； bufferevent注册好的回调函数如下 12345678910const struct bufferevent_ops bufferevent_ops_socket = &#123; &quot;socket&quot;, evutil_offsetof(struct bufferevent_private, bev), be_socket_enable, be_socket_disable, be_socket_destruct, be_socket_adj_timeouts, be_socket_flush, be_socket_ctrl,&#125;; 12345678910111213static intbe_socket_enable(struct bufferevent *bufev, short event)&#123; if (event &amp; EV_READ) &#123; if (be_socket_add(&amp;bufev-&gt;ev_read,&amp;bufev-&gt;timeout_read) == -1) return -1; &#125; if (event &amp; EV_WRITE) &#123; if (be_socket_add(&amp;bufev-&gt;ev_write,&amp;bufev-&gt;timeout_write) == -1) return -1; &#125; return 0;&#125; eventbuffer读写事件加入到event队列里，此处为添加ev_write写事件，当写事件就绪， 轮询可以出发绑定的bufferevent_writecb回调函数。 当调用bufferevent_writecb这个函数时，我们把内部代码简化分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static voidbufferevent_writecb(evutil_socket_t fd, short event, void *arg)&#123;//计算bufferevent能写的最大数量 atmost = _bufferevent_get_write_max(bufev_p); if (bufev_p-&gt;write_suspended) goto done; if (evbuffer_get_length(bufev-&gt;output)) &#123; evbuffer_unfreeze(bufev-&gt;output, 1); //bufferevent调用写操作，将outbuffer中的内容发送出去 res = evbuffer_write_atmost(bufev-&gt;output, fd, atmost); evbuffer_freeze(bufev-&gt;output, 1); if (res == -1) &#123; int err = evutil_socket_geterror(fd); if (EVUTIL_ERR_RW_RETRIABLE(err)) goto reschedule; what |= BEV_EVENT_ERROR; &#125; else if (res == 0) &#123; /* eof case XXXX Actually, a 0 on write doesn&#x27;t indicate an EOF. An ECONNRESET might be more typical. */ what |= BEV_EVENT_EOF; &#125; if (res &lt;= 0) goto error; //bufferevent减少发送的大小，留下未发送的，下次再发送 _bufferevent_decrement_write_buckets(bufev_p, res); &#125; //计算是否将outbuf中的内容发送完，发完了就删除写事件 if (evbuffer_get_length(bufev-&gt;output) == 0) &#123; event_del(&amp;bufev-&gt;ev_write); &#125; /* * Invoke the user callback if our buffer is drained or below the * low watermark. */ //将buffer中的内容发完，或者低于low 水位，那么调用用户注册的写回调函数 if ((res || !connected) &amp;&amp; evbuffer_get_length(bufev-&gt;output) &lt;= bufev-&gt;wm_write.low) &#123; _bufferevent_run_writecb(bufev); &#125;&#125; _bufferevent_run_writecb内部调用了bufev-&gt;writecb(bufev, bufev-&gt;cbarg);也就是说我们自己实现的 123456789static voidconn_writecb(struct bufferevent *bev, void *user_data)&#123; struct evbuffer *output = bufferevent_get_output(bev); if (evbuffer_get_length(output) == 0) &#123; printf(&quot;flushed answer\\n&quot;); bufferevent_free(bev); &#125;&#125; 到此为止整个bufferevent消息走向梳理出来。最后有一点需要陈述，在listener_cb中最后调用bufferevent_write(bev, MESSAGE, strlen(MESSAGE)); `其内部调用evbuffer_add，该函数内部evbuffer_invoke_callbacks(buf);会调用bufferevent_socket_outbuf_cb，进而调用 bufferevent_write。` 所以我认为是调用evbuffer_add向outbuf中添加数据后，调用了evbuffer_invoke_callbacks,触发bufferevent_write， 或者ev_write先检测到写就绪事件，然后调用buffervent_write.这两者先后并不清楚。 整个流程就是这样，需要继续研究然后梳理。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"libevent文档学习(一)多线程接口和使用","date":"2017-08-07T02:44:51.000Z","path":"2017/08/07/libevent1/","text":"参考libevent官方提供的文档： http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html 这一篇主要翻译libevent多线程的使用接口和文档。 As you probably know if you’re writing multithreaded programs, it isn’t always safe to access the same data from multiple threads at the same time. Libevent structures can generally work three ways with multithreading. Some structures are inherently single-threaded: it is never safe to use them from more than one thread at the same time. Some structures are optionally locked: you can tell Libevent for each object whether you need to use it from multiple threads at once. Some structures are always locked: if Libevent is running with lock support, then they are always safe to use from multiple threads at once. 当你编写多线程程序的时候，多个线程访问同一块数据并不安全。对于多线程libevent通常采取以下三种方式工作， 1 一些结构内不是单线程的，多线程同时访问这个结构是不安全的。 2一些结构内部是选择性加锁的，你需要通知libevent，对于每个对象你是否采用多线程的方式使用它。 3一些结构总是加锁的，如果libevent设置了加锁的模式，采用多线程方式是安全的。 To get locking in Libevent, you must tell Libevent which locking functions to use. You need to do this before you call any Libevent function that allocates a structure that needs to be shared between threads. If you are using the pthreads library, or the native Windows threading code, you’re in luck. There are pre-defined functions that will set Libevent up to use the right pthreads or Windows functions for you. 如果要使用libevent多线程锁的功能，需要开辟一个线程共享的结构，如果您使用windows或者linux提供的pthread库，libevent已经定义好了。 12345678#ifdef WIN32int evthread_use_windows_threads(void);#define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED#endif#ifdef _EVENT_HAVE_PTHREADSint evthread_use_pthreads(void);#define EVTHREAD_USE_PTHREADS_IMPLEMENTED#endif libevent针对win32平台定义了evthread_use_windows_threads, libevent针对Linux thread库 定义了evthread_use_pthreads evthread_use_pthread函数是这样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546intevthread_use_pthreads(void)&#123; //pthread lock callback结构体对象 struct evthread_lock_callbacks cbs = &#123; //锁的版本 EVTHREAD_LOCK_API_VERSION, //锁的属性 EVTHREAD_LOCKTYPE_RECURSIVE, //创建锁 evthread_posix_lock_alloc, //回收锁 evthread_posix_lock_free, //加锁回调函数 evthread_posix_lock, //解锁回调函数 evthread_posix_unlock &#125;; //条件变量回调结构体对象 struct evthread_condition_callbacks cond_cbs = &#123; //条件变量的版本 EVTHREAD_CONDITION_API_VERSION, //创建条件变量 evthread_posix_cond_alloc, //回收条件变量 evthread_posix_cond_free, //激活条件的回调函数 evthread_posix_cond_signal, //条件不满足阻塞的回调函数 evthread_posix_cond_wait &#125;; //设置互斥锁的属性 /* Set ourselves up to get recursive locks. */ if (pthread_mutexattr_init(&amp;attr_recursive)) return -1; if (pthread_mutexattr_settype(&amp;attr_recursive, PTHREAD_MUTEX_RECURSIVE)) return -1; //将cbs的属性设置到全局变量中，分为调试和正常模式 evthread_set_lock_callbacks(&amp;cbs); //同样将cond_cbs设置到全局变量 evthread_set_condition_callbacks(&amp;cond_cbs); //设置线程id到全局变量 evthread_set_id_callback(evthread_posix_get_id); return 0;&#125; 这几个结构体如下 123456789101112131415161718192021222324252627282930313233#define EVTHREAD_WRITE 0x04#define EVTHREAD_READ 0x08#define EVTHREAD_TRY 0x10#define EVTHREAD_LOCKTYPE_RECURSIVE 1#define EVTHREAD_LOCKTYPE_READWRITE 2#define EVTHREAD_LOCK_API_VERSION 1struct evthread_lock_callbacks &#123; int lock_api_version; unsigned supported_locktypes; void *(*alloc)(unsigned locktype); void (*free)(void *lock, unsigned locktype); int (*lock)(unsigned mode, void *lock); int (*unlock)(unsigned mode, void *lock);&#125;;int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);void evthread_set_id_callback(unsigned long (*id_fn)(void));struct evthread_condition_callbacks &#123; int condition_api_version; void *(*alloc_condition)(unsigned condtype); void (*free_condition)(void *cond); int (*signal_condition)(void *cond, int broadcast); int (*wait_condition)(void *cond, void *lock, const struct timeval *timeout);&#125;;int evthread_set_condition_callbacks( const struct evthread_condition_callbacks *); The evthread_lock_callbacks structure describes your locking callbacks and their abilities. For the version described above, the lock_api_version field must be set to EVTHREAD_LOCK_API_VERSION. The supported_locktypes field must be set to a bitmask of the EVTHREAD_LOCKTYPE_* constants to describe which lock types you can support. (As of 2.0.4-alpha, EVTHREAD_LOCK_RECURSIVE is mandatory and EVTHREAD_LOCK_READWRITE is unused.) The alloc function must return a new lock of the specified type. The free function must release all resources held by a lock of the specified type. The lock function must try to acquire the lock in the specified mode, returning 0 on success and nonzero on failure. The unlock function must try to unlock the lock, returning 0 on success and nonzero on failure. 理解： evthread_lock_callbacks 包括了锁的回调函数和他们的功能，lock_api_version 要被设置为EVTHREAD_LOCK_API_VERSION， supported_locktypes 应该设置为自己需要的EVTHREAD_LOCKTYPE_开头的几个类型的bitmask按位或alloc 函数返回指定类型的锁，free 函数释放指定类型的锁的所有资源，lock 函数试图获取制定模式的锁，成功返回0，失败返回非0. unlock 解锁函数释放指定的锁，成功返回0，失败返回非0 Recognized lock types are: 0A regular, not-necessarily recursive lock. EVTHREAD_LOCKTYPE_RECURSIVEA lock that does not block a thread already holding it from requiring it again. Other threads can acquire the lock once the thread holding it has unlocked it as many times as it was initially locked. EVTHREAD_LOCKTYPE_READWRITEA lock that allows multiple threads to hold it at once for reading, but only one thread at a time to hold it for writing. A writer excludes all readers. 0表示常规锁，不可以被重复上锁 EVTHREAD_LOCKTYPE_RECURSIVE：这种锁当一个线程持有，该线程可以继续获取他而不被阻塞，其他线程需要等到该线程释放这个锁后可以获取到这个锁， 并且可以多次加锁。 EVTHREAD_LOCKTYPE_READWRITE：这种锁多线程可以在读的时候都获取到他，但是写操作时只允许一个线程持有。 Recognized lock modes are: EVTHREAD_READFor READWRITE locks only: acquire or release the lock for reading. EVTHREAD_WRITEFor READWRITE locks only: acquire or release the lock for writing. EVTHREAD_TRYFor locking only: acquire the lock only if the lock can be acquired immediately. EVTHREAD_READ和EVTHREAD_WRITE都是针对READWRITE 锁的获取和释放。 EVTHREAD_TRY：这个模式只在能立即获得锁的时候获取锁，否则不等待。 The id_fn argument must be a function returning an unsigned long identifying what thread is calling the function. It must always return the same number for the same thread, and must not ever return the same number for two different threads if they are both executing at the same time. id_fn函数返回一个unsigned long标识调用该函数的线程。不同线程的返回值不同，同一个线程的返回值相同。 The evthread_condition_callbacks structure describes callbacks related to condition variables. For the version described above, the lock_api_version field must be set to EVTHREAD_CONDITION_API_VERSION. The alloc_condition function must return a pointer to a new condition variable. It receives 0 as its argument. The free_condition function must release storage and resources held by a condition variable. The wait_condition function takes three arguments: a condition allocated by alloc_condition, a lock allocated by the evthread_lock_callbacks.alloc function you provided, and an optional timeout. The lock will be held whenever the function is called; the function must release the lock, and wait until the condition becomes signalled or until the (optional) timeout has elapsed. The wait_condition function should return -1 on an error, 0 if the condition is signalled, and 1 on a timeout. Before it returns, it should make sure it holds the lock again. Finally, the signal_condition function should cause one thread waiting on the condition to wake up (if its broadcast argument is false) and all threads currently waiting on the condition to wake up (if its broadcast argument is true). It will only be held while holding the lock associated with the condition. evthread_condition_callbacks 描述了几个跟条件变量相关的回调函数。lock_api_version 应该被设置为EVTHREAD_CONDITION_API_VERSION，alloc_condition 喊回一个指向新的环境变量的指针， free_condition 释放条件变量的资源，wait_condition 带有三个参数，分别是alloc_condition开辟的条件变量，evthread_lock_callbacks开辟的锁，以及一个可选的超时值，在调用这个函数时lock要提前加锁， 之后，函数内部必须释放锁，等待条件被唤醒或者超时，wait_condition 在错误时返回-1，超时返回1，被激活返回0.在该函数内部返回之前，他要自己上锁。signal_condition 激活单个线程，broadcast 参数设为true时 所有等待该条件的线程被激活。只有持有和条件相关的锁的时候线程才会被挂起。 libevent中开辟锁和释放等等的回调函数以及条件变量的相关函数实现比较简单，就不展开了，可以查看evthread_pthread.c文件。 下面看下系统是如何调用 evthread_set_condition_callbacks()和evthread_set_lock_callbacks()分别将条件回调的结构体对象和锁相关功能的结构体对象 赋值给全局变量 _evthread_cond_fns和_evthread_lock_fns, libevent封装了几个通过_evthread_cond_fns和 _evthread_lock_fns 调用锁和条件变量的接口， 都在evthread-internal.h文件里。 123456789101112131415EVTHREAD_ALLOC_LOCK(lockvar, locktype);EVTHREAD_FREE_LOCK(lockvar, locktype);EVLOCK_LOCK(lockvar,mode);EVLOCK_UNLOCK(lockvar,mode);EVTHREAD_ALLOC_COND(condvar);EVTHREAD_FREE_COND(cond);EVTHREAD_COND_SIGNAL(cond);EVTHREAD_COND_WAIT(cond, lock); 等等，就不展开了，读者自己阅读。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"libevent学习文档(二)eventbase相关接口和参数","date":"2017-08-07T02:40:02.000Z","path":"2017/08/07/libevent2/","text":"Setting up a default event_base The event_base_new() function allocates and returns a new event base with the default settings. It examines the environment variables and returns a pointer to a new event_base. If there is an error, it returns NULL. When choosing among methods, it picks the fastest method that the OS supports. event_base_new()创建默认event_base，他检测环境变量并且返回一个指向新的event_base的指针。 当调用方法时，选择操作系统支持的做快速的方法。 Interface struct event_base *event_base_new(void);Setting up a complicated event_base If you want more control over what kind of event_base you get, you need to use an event_config. An event_config is an opaque structure that holds information about your preferences for an event_base. When you want an event_base, you pass the event_config to event_base_new_with_config(). 想要创建指定类型的event_base，需要使用event_config，event_config是不透明的结构体，保存了您创建event_base时需要的特性。 用户调用event_base_new_with_config创建特殊类型的event_base Interface struct event_config *event_config_new(void);struct event_base *event_base_new_with_config(const struct event_config *cfg);void event_config_free(struct event_config *cfg); To allocate an event_base with these functions, you call event_config_new() to allocate a new event_config. Then, you call other functions on the event_config to tell it about your needs. Finally, you call event_base_new_with_config() to get a new event_base. When you are done, you can free the event_config with event_config_free(). 为了创造一个有特定功能的event_base，你需要调用event_config_new()创建event_config，只后调用event_base_new_with_config()，之后调用event_config_free释放。 Interface： 1234567891011121314151617181920int event_config_avoid_method(struct event_config *cfg, const char *method);enum event_method_feature &#123; EV_FEATURE_ET = 0x01, EV_FEATURE_O1 = 0x02, EV_FEATURE_FDS = 0x04,&#125;;int event_config_require_features(struct event_config *cfg, enum event_method_feature feature);enum event_base_config_flag &#123; EVENT_BASE_FLAG_NOLOCK = 0x01, EVENT_BASE_FLAG_IGNORE_ENV = 0x02, EVENT_BASE_FLAG_STARTUP_IOCP = 0x04, EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08, EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10, EVENT_BASE_FLAG_PRECISE_TIMER = 0x20&#125;;int event_config_set_flag(struct event_config *cfg, enum event_base_config_flag flag); Calling event_config_avoid_method tells Libevent to avoid a specific available backend by name. Calling event_config_require_feature() tells Libevent not to use any backend that cannot supply all of a set of features. Calling event_config_set_flag() tells Libevent to set one or more of the run-time flags below when constructing the event base. event_config_avoid_method 可以规避一些函数，通过传入函数的名字，event_config_require_feature告诉libevent不要使用不支持指定特性的功能。 event_config_set_flag告诉libevent设置一个或多个运行时标记，当你创建event base时。 特性的标记位如下： EV_FEATURE_ET：要求后端方法支持edge-triggered IO EV_FEATURE_O1：要求添加或者删除，或者激活某个事件的事件复杂度为O（1） EV_FEATURE_FDS：要求后端方法支持任意类型的文件描述符，不仅仅是socket EVENT_BASE_FLAG_NOLOCK：不为event_base设置锁，可以省去event_base加锁和释放锁的时间，但是对于多线程操作，并不安全。 EVENT_BASE_FLAG_IGNORE_ENV：当调用后端的方法时并不检查EVENT_*环境变量，用这个选项时注意，会导致程序和Libevent库之间调试麻烦 EVENT_BASE_FLAG_STARTUP_IOCP：仅对windows有效，通知Libevent在启动的时候就是用必要的IOCP 派发逻辑，而不是在需要时才用IOCP派发逻辑。 EVENT_BASE_FLAG_NO_CACHE_TIME：每次超时回调函数调用后检测当前时间，而不是准备调用超时回调函数前检测。 EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST：通知libevent，如果后台使用epoll模型，使用changelist是安全的， epoll-changelist 能够避免在两次派发之间如果同一个fd的状态有改变，多次不必要的系统调用。换句话说在派发消息中间，如果同一个fd多次改动，那么最终只调用一次系统 调用。如果后台不是epoll模型，那么这个选项是没什么影响。同样可以设置EVENT_EPOLL_USE_CHANGELIST 环境变量达到这个目的。 EVENT_BASE_FLAG_PRECISE_TIMER：libevent默认使用快速的定时器机制，设置这个选项后，如果有一个慢速的但是定时器精度高的机制，那么就会切换到这个机制。 如果没有这个机制，那么这个选项没什么影响。 下面几个例子说明了这些api用法 1234567891011121314151617181920212223242526static voidtest_base_features(void *arg)&#123; struct event_base *base = NULL; struct event_config *cfg = NULL; //创建一个event_config cfg = event_config_new(); //设置在epoll模型情况下支持et模式 tt_assert(0 == event_config_require_features(cfg, EV_FEATURE_ET)); //创建event_base base = event_base_new_with_config(cfg); if (base) &#123; tt_int_op(EV_FEATURE_ET, ==, event_base_get_features(base) &amp; EV_FEATURE_ET); &#125; else &#123; base = event_base_new(); tt_int_op(0, ==, event_base_get_features(base) &amp; EV_FEATURE_ET); &#125;end: //结束时要释放base和config if (base) event_base_free(base); if (cfg) event_config_free(cfg);&#125; 下面这个是测试方法的 12345678910111213141516171819202122232425262728293031323334353637383940static voidtest_methods(void *ptr)&#123; //获取event_base支持的方法 const char **methods = event_get_supported_methods(); struct event_config *cfg = NULL; struct event_base *base = NULL; const char *backend; int n_methods = 0; tt_assert(methods); backend = methods[0]; while (*methods != NULL) &#123; TT_BLATHER((&quot;Support method: %s&quot;, *methods)); ++methods; ++n_methods; &#125; cfg = event_config_new(); assert(cfg != NULL); //event_base屏蔽backend的方法 tt_int_op(event_config_avoid_method(cfg, backend), ==, 0); //并且设置了忽略ENV环境变量的选项 event_config_set_flag(cfg, EVENT_BASE_FLAG_IGNORE_ENV); //创建event_base base = event_base_new_with_config(cfg); if (n_methods &gt; 1) &#123; tt_assert(base); tt_str_op(backend, !=, event_base_get_method(base)); &#125; else &#123; tt_assert(base == NULL); &#125;end: if (base) event_base_free(base); if (cfg) event_config_free(cfg);&#125; 谢谢关注我的公众号：","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"libevent学习文档(三)working with event","date":"2017-08-04T10:23:33.000Z","path":"2017/08/04/libevent3/","text":"Events have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an event base, it becomes initialized. At this point, you can add, which makes it pending in the base. When the event is pending, if the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomesactive, and its (user-provided) callback function is run. If the event is configured persistent, it remains pending. If it is not persistent, it stops being pending when its callback runs. You can make a pending event non-pending by deleting it, and you can add a non-pending event to make it pending again. 事件有相似的生命周期，一旦你调用libevent函数设置event和event_base关联后，event被初始化了。add这个事件会使它阻塞，当事件阻塞时，有触发事件的条件出现，事件会激活，回调函数会被调用。如果事件被设置为永久，它保持阻塞。如果不是永久，当事件的回调函数调用的时候就不阻塞了。可以通过删除一个事件使它由阻塞变为非阻塞。通过添加使它由非阻塞变为阻塞。 1234567891011121314#define EV_TIMEOUT 0x01#define EV_READ 0x02#define EV_WRITE 0x04#define EV_SIGNAL 0x08#define EV_PERSIST 0x10#define EV_ET 0x20typedef void (*event_callback_fn)(evutil_socket_t, short, void *);struct event *event_new(struct event_base *base, evutil_socket_t fd, short what, event_callback_fn cb, void *arg);void event_free(struct event *event); 通过event_new创建事件，通过event_free释放。 参数base 表示event绑定在那个event_base上, fd表示event关联的描述符， what表示事件的类型，是一个bitfield, 上面那些宏按位或，cb是事件回调函数，事件就绪后可以触发。event_free释放event事件。 All new events are initialized and non-pending. To make an event pending, call event_add() (documented below). To deallocate an event, call event_free(). It is safe to call event_free() on an event that is pending or active: doing so makes the event non-pending and inactive before deallocating it. 所有新创建的事件都是初始化的，并且非阻塞，调用event_add可以让一个事件变为阻塞。调用event_free释放event，在事件阻塞或者激活状态下调用event_free是安全的，这个函数会在释放event之前将事件变为非阻塞并且非激活状态。 EV_TIMEOUT This flag indicates an event that becomes active after a timeout elapses. EV_READ This flag indicates an event that becomes active when the provided file descriptor is ready for reading. EV_WRITE This flag indicates an event that becomes active when the provided file descriptor is ready for writing. EV_SIGNAL Used to implement signal detection. See “Constructing signal events” below. EV_PERSIST Indicates that the event is persistent. See “About Event Persistence” below. EV_ET Indicates that the event should be edge-triggered, if the underlying event_base backend supports edge-triggered events. EV_TIMEOUT：表示过一段事件后event变为active。 EV_READ：当文件描述可读的时候变为就绪。 EV_WRITE：当文件描述符可写的时候变为就绪。 EV_SIGNAL：信号事件的标记 EV_PERSIST：永久事件，下面会介绍。 EV_ET：如果后端支持边缘触发事件，那么事件是边缘触发的。 About Event Persistence By default, whenever a pending event becomes active (because its fd is ready to read or write, or because its timeout expires), it becomes non-pending right before its callback is executed. Thus, if you want to make the event pending again, you can call event_add() on it again from inside the callback function. If the EV_PERSIST flag is set on an event, however, the event is persistent. This means that event remains pending even when its callback is activated. If you want to make it non-pending from within its callback, you can call event_del() on it. The timeout on a persistent event resets whenever the event’s callback runs. Thus, if you have an event with flags EV_READ|EV_PERSIST and a timeout of five seconds, the event will become active: Whenever the socket is ready for reading. Whenever five seconds have passed since the event last became active. 默认情况下，当一个阻塞事件变为active时，(读事件可读，写事件可写，超时间到期等)，在事件对应的回调函数调用前该事件就会变为非阻塞的。因此，如果想要将事件变为阻塞，需要在事件的回调函数里调用event_add() 如果设置了EV_PERSIST 标记位， 那么事件就变味永久的，这意味着事件在回调函数触发时任然保持pending，如果你想要在回调函数调用后该事件变为非阻塞，需要调用event_del()。 当事件回调函数调用后超时会被重置，因此，如果事件带有EV_READ|EV_PERSIST标记，并且有5秒的超时值，如下情况事件会变为active： 1当socket可读时 2从上次变为active之后过了5秒后事件会变为active。 当事件的回调函数需要用到自己作为参数时候，需要将参数传递为 void *event_self_cbarg(); 代码例子 123456789101112131415161718192021222324#include &lt;event2/event.h&gt;static int n_calls = 0;void cb_func(evutil_socket_t fd, short what, void *arg)&#123; struct event *me = arg; printf(&quot;cb_func called %d times so far.\\n&quot;, ++n_calls); if (n_calls &gt; 100) event_del(me);&#125;void run(struct event_base *base)&#123; struct timeval one_sec = &#123; 1, 0 &#125;; struct event *ev; /* We&#x27;re going to set up a repeating timer to get called called 100 times. */ ev = event_new(base, -1, EV_PERSIST, cb_func, event_self_cbarg()); event_add(ev, &amp;one_sec); event_base_dispatch(base);&#125; For performance and other reasons, some people like to allocate events as a part of a larger structure. For each use of the event, this saves them: The memory allocator overhead for allocating a small object on the heap. The time overhead for dereferencing the pointer to the struct event. The time overhead from a possible additional cache miss if the event is not already in the cache. 有时候开辟event作为一个较大结构体的一部分，可以节省在堆上开辟小对象的内存，也可以节省间接引用事件指针的事件和额外内存流失的处理。 文档的作者并不提倡用event_assign这个函数，推荐使用event_new，而且对于一些问题event_assign并不好调试 下面是使用event_assign的例子 12345678910111213141516struct event_pair &#123; evutil_socket_t fd; struct event read_event; struct event write_event;&#125;;void readcb(evutil_socket_t, short, void *);void writecb(evutil_socket_t, short, void *);struct event_pair *event_pair_new(struct event_base *base, evutil_socket_t fd)&#123; struct event_pair *p = malloc(sizeof(struct event_pair)); if (!p) return NULL; p-&gt;fd = fd; event_assign(&amp;p-&gt;read_event, base, fd, EV_READ|EV_PERSIST, readcb, p); event_assign(&amp;p-&gt;write_event, base, fd, EV_WRITE|EV_PERSIST, writecb, p); return p;&#125; WARNINGNever call event_assign() on an event that is already pending in an event base. Doing so can lead to extremely hard-to-diagnose errors. If the event is already initialized and pending, call event_del() on it before you call event_assign() on it again. event在event_base中阻塞时不要调用event_assign()，否则会造成很难查找分析的问题，如果一个事件已经初始化并且pending了，需要调用event_del()删除他，然后再次调用event_assign()。 evtimer_assign和evsignal_assign分别是定时器和信号的注册函数。 由于调用event_assign()可能会造成版本兼容的问题，调用如下函数，可以获取到event运行时大小。size_t event_get_struct_event_size(void); This function returns the number of bytes you need to set aside for a struct event. As before, you should only be using this function if you know that heap-allocation is actually a significant problem in your program, since it can make your code much harder to read and write. 这个函数返回event结构体旁边的偏移位置的字节数，只有在你觉得堆开辟确实是一个难题的时候才采用这个方法。因为这么做会是你的代码更难去读和写。 事件的添加：int event_add(struct event *ev, const struct timeval *tv);Calling event_add on a non-pending event makes it pending in its configured base. The function returns 0 on success, and -1 on failure. If tv is NULL, the event is added with no timeout. Otherwise, tv is the size of the timeout in seconds and microseconds. If you call event_add() on an event that is already pending, it will leave it pending, and reschedule it with the provided timeout. If the event is already pending, and you re-add it with the timeout NULL, event_add() will have no effect. 调用event_add会让一个event变得pending，返回0表示成功，-1表示失败。如果tv设置为NULL，表示没有超时检测。否则，tv表示超时的秒数和毫秒。如果在一个pending的event上调用add，会使它pengding，并且根据超时值重新计时。 事件的删除：int event_del(struct event *ev); 事件删除函数，会将一个阻塞或者激活的事件变为非阻塞和非激活的，如果事件是非阻塞的或者非激活的，调用这个函数并没有什么影响。同样，返回0表示成功，-1表示失败。 优先级设置：int event_priority_set(struct event *event, int priority); 每个event_base有priorities，event可以设置从0到这个值之间的一个数，0表示成功，-1表示失败。优先级高的先处理，优先级低的后处理。如果不设置优先级，默认值为event_base中队列大小除以2 1234567891011121314151617181920212223#include &lt;event2/event.h&gt;void read_cb(evutil_socket_t, short, void *);void write_cb(evutil_socket_t, short, void *);void main_loop(evutil_socket_t fd)&#123; struct event *important, *unimportant; struct event_base *base; base = event_base_new(); event_base_priority_init(base, 2); /* Now base has priority 0, and priority 1 */ important = event_new(base, fd, EV_WRITE|EV_PERSIST, write_cb, NULL); unimportant = event_new(base, fd, EV_READ|EV_PERSIST, read_cb, NULL); event_priority_set(important, 0); event_priority_set(unimportant, 1); /* Now, whenever the fd is ready for writing, the write callback will happen before the read callback. The read callback won&#x27;t happen at all until the write callback is no longer active. */&#125; 除此之外，libevent还为我们提供了一些接口访问当前event_base 和event属性。 1234567891011121314151617int event_pending(const struct event *ev, short what, struct timeval *tv_out);#define event_get_signal(ev) /* ... */evutil_socket_t event_get_fd(const struct event *ev);struct event_base *event_get_base(const struct event *ev);short event_get_events(const struct event *ev);event_callback_fn event_get_callback(const struct event *ev);void *event_get_callback_arg(const struct event *ev);int event_get_priority(const struct event *ev);void event_get_assignment(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out); event_pending 获取当前event对应的what属性事件是否pending或者被激活，If it is, and any of the flags EV_READ, EV_WRITE, EV_SIGNAL, and EV_TIMEOUT are set in the whatargument, the function returns all of the flags that the event is currently pending or active on 任类型都可以设置到what参数里，这个函数返回当前pending或者激活状态的标记按位或。event_get_signal和event_get_fd返回event关联的信号id和文件描述符id， event_get_base返回event绑定的event_base，event_get_events返回event监听的事件集合，event_get_callback返回event的回调函数，以及event_get_callback_arg返回回调函数参数，event_get_priority返回event的优先级event_get_assignment这个函数返回event所有绑定的信息到对应的指针域，如果形参为NULL，表示忽略。\\ 1234567891011121314151617181920212223242526272829303132#include &lt;event2/event.h&gt;#include &lt;stdio.h&gt;/* Change the callback and callback_arg of &#x27;ev&#x27;, which must not be * pending. */int replace_callback(struct event *ev, event_callback_fn new_callback, void *new_callback_arg)&#123; struct event_base *base; evutil_socket_t fd; short events; int pending; pending = event_pending(ev, EV_READ|EV_WRITE|EV_SIGNAL|EV_TIMEOUT, NULL); if (pending) &#123; /* We want to catch this here so that we do not re-assign a * pending event. That would be very very bad. */ fprintf(stderr, &quot;Error! replace_callback called on a pending event!\\n&quot;); return -1; &#125; event_get_assignment(ev, &amp;base, &amp;fd, &amp;events, NULL /* ignore old callback */ , NULL /* ignore old callback argument */); event_assign(ev, base, fd, events, new_callback, new_callback_arg); return 0;&#125; 还有个能只调用一次事件的创建接口 int event_base_once(struct event_base , evutil_socket_t, short, void ()(evutil_socket_t, short, void *), void *, const struct timeval *); 这个函数不支持EV_SIGNAL 和 EV_PERSIST ，这个事件也不支持手动删除和激活。当该事件对应的回调函数触发后，该事件会自动从event_base中移除，并且libevent会析构掉该event。 激活event的接口 void event_active(struct event *ev, int what, short ncalls); 这个函数可以根据what(EV_READ, EV_WRITE,EV_TIMER等)将event设置为active，调用函数前，event是否为pengding并不影响，并且激活它并且变为非阻塞状态。在同一个事件递归的调用event_active会导致内存耗尽。 下面是一个错误例子 1234567891011121314151617181920212223struct event *ev;static void cb(int sock, short which, void *arg) &#123; /* Whoops: Calling event_active on the same event unconditionally from within its callback means that no other events might not get run! */ event_active(ev, EV_WRITE, 0);&#125;int main(int argc, char **argv) &#123; struct event_base *base = event_base_new(); ev = event_new(base, -1, EV_PERSIST | EV_READ, cb, NULL); event_add(ev, NULL); event_active(ev, EV_WRITE, 0); event_base_loop(base, 0); return 0;&#125; 有两种改进的方式，一种是采用定时器，另一种是采用libevent提供的event_config_set_max_dispatch_interval 定时器的就是只调用一次loop，之后的回调函数cb会反复调用，因为cb内部发现event不是阻塞状态了，就要将event删除后再加入，loop内部检测到新的event，继续调用cb，反复调用cb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct event *ev;struct timeval tv;static void cb(int sock, short which, void *arg) &#123; if (!evtimer_pending(ev, NULL)) &#123; event_del(ev); evtimer_add(ev, &amp;tv); &#125;&#125;int main(int argc, char **argv) &#123; struct event_base *base = event_base_new(); tv.tv_sec = 0; tv.tv_usec = 0; ev = evtimer_new(base, cb, NULL); evtimer_add(ev, &amp;tv); event_base_loop(base, 0); return 0;&#125; event_config_set_max_dispatch_interval设置了dispatch的时间间隔，每个一段时间才派发就绪时间，这样就不会导致递归造成的资源耗尽了。struct event *ev;static void cb(int sock, short which, void *arg) &#123; event_active(ev, EV_WRITE, 0);&#125;int main(int argc, char **argv) &#123; struct event_config *cfg = event_config_new(); /* Run at most 16 callbacks before checking for other events. */ event_config_set_max_dispatch_interval(cfg, NULL, 16, 0); struct event_base *base = event_base_new_with_config(cfg); ev = event_new(base, -1, EV_PERSIST | EV_READ, cb, NULL); event_add(ev, NULL); event_active(ev, EV_WRITE, 0); event_base_loop(base, 0); return 0;&#125;","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Libevent学习笔记(四) bufferevent 的 concepts and basics","date":"2017-08-04T10:08:08.000Z","path":"2017/08/04/libevent4/","text":"Bufferevents and evbuffers Every bufferevent has an input buffer and an output buffer. These are of type “struct evbuffer”. When you have data to write on a bufferevent, you add it to the output buffer; when a bufferevent has data for you to read, you drain it from the input buffer. 每个bufferevents都会包含一个input的buffer和output的buffer,都是struct evbuffer类型， 如果你有数据想通过bufferevent发送，需要将数据放入output buffer里。如果要从bufferevent中读数据， 需要从input buffer里读取。 Callbacks and watermarks Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write “watermarks” of the bufferevent. 每一个bufferevent都有两个回调函数，一个读回调和一个写回调函数，默认情况下，只要从底层传输读取数据就回触发读回调函数，当output buffer中足够多的数据排出就会触发写回调函数。而我的理解是，这里的足够多，默认情况下是排空， 用户可以通过调整读写水位来达到控制这些函数触发。 下面是libevent源码中的一些注释 12345678910111213/** A read or write callback for a bufferevent. The read callback is triggered when new data arrives in the input buffer and the amount of readable data exceed the low watermark which is 0 by default. The write callback is triggered if the write buffer has been exhausted or fell below its low watermark. @param bev the bufferevent that triggered the callback @param ctx the user-specified context for this bufferevent */ 到此为止总结下，bufferevent实际上是libevent为我们准备的一个缓存结构，将接受的数据缓存到input buffer供用户从中读取，用户将发送的数据缓存到output buffer进行发送。bufferevent的input buffer中有数据到来并且可读数据达到或超过读数据的低水位就会触发读回调函数，读数据的低水位默认是0,写回调函数会在outbuffer中的数据低于写的低水位时会触发。bufferevent会自己讲output中的内容发送出去，将接收到的内容放到input中。 Read low-water markWhenever a read occurs that leaves the bufferevent’s input buffer at this level or higher, the bufferevent’s read callback is invoked. Defaults to 0, so that every read results in the read callback being invoked. 只要读事件让bufferevent超过或者到达这个Read low-water 水位或者更高，读回调会被触发。默认情况下 Read low-water 是0，所以每次bufferevent 读数据都会导致读回调触发。 Read high-water markIf the bufferevent’s input buffer ever gets to this level, the bufferevent stops reading until enough data is drained from the input buffer to take us below it again. Defaults to unlimited, so that we never stop reading because of the size of the input buffer. 如果bufferevent 的 input buffer达到Read high-water水平，那么bufferevent会停止读，直到有数据从input中被用户取出使input buffer的水位线低于Read high-water， 默认情况下Read high-water是无穷大的，因此我们不会因为input buffer不够停止读。 Write low-water markWhenever a write occurs that takes us to this level or below, we invoke the write callback. Defaults to 0, so that a write callback is not invoked unless the output buffer is emptied. 当bufferevent写数据导致数据大小低于 Write low-water水平线，就回触发写回调函数。默认这个Write low-water值为0，因此只有当output buffer数据为空时才会触发写回调函数。 Write high-water markNot used by a bufferevent directly, this watermark can have special meaning when a bufferevent is used as the underlying transport of another bufferevent. See notes on filtering bufferevents below. 这个参数不会直接使用，当一个bufferevent作为参数传递给另一个bufferevent时可以做为特殊意义。filtering bufferevents可能会用到。 A bufferevent also has an “error” or “event” callback that gets invoked to tell the application about non-data-oriented events, like when a connection is closed or an error occurs. The following event flags are defined: 一个bufferevent也会有类似错误或者特殊事件的回调函数，这类函数触发后通知应用程序一些和数据无关的事件，比如当有连接关闭，或者错误出现可以触发这类函数。 BEV_EVENT_READINGAn event occured during a read operation on the bufferevent. See the other flags for which event it was. 在bufferevent上进行读操作 BEV_EVENT_WRITINGAn event occured during a write operation on the bufferevent. See the other flags for which event it was. 在bufferevent上进行写操作 BEV_EVENT_ERRORAn error occurred during a bufferevent operation. For more information on what the error was, call EVUTIL_SOCKET_ERROR(). bufferevent操作产生错误，通过EVUTIL_SOCKET_ERROR可以详细查看错误源 BEV_EVENT_TIMEOUTA timeout expired on the bufferevent. 超时事件 BEV_EVENT_EOFWe got an end-of-file indication on the bufferevent. 读到文件结束符 BEV_EVENT_CONNECTEDWe finished a requested connection on the bufferevent. 完成连接 Deferred callbacks By default, a bufferevent callbacks are executed immediately when the corresponding condition happens. (This is true of evbuffer callbacks too; we’ll get to those later.) This immediate invocation can make trouble when dependencies get complex. For example, suppose that there is a callback that moves data into evbuffer A when it grows empty, and another callback that processes data out of evbuffer A when it grows full. Since these calls are all happening on the stack, you might risk a stack overflow if the dependency grows nasty enough. To solve this, you can tell a bufferevent (or an evbuffer) that its callbacks should be deferred. When the conditions are met for a deferred callback, rather than invoking it immediately, it is queued as part of the event_loop() call, and invoked after the regular events’ callbacks. (Deferred callbacks were introduced in Libevent 2.0.1-alpha.) 默认情况下，bufferevent回调函数在条件符合时会立即执行。当情况复杂时这种立即出发的方式可能会造成问题，例如，假设有一个回调函数功能是在evbuffer A变空时向evbuffer A中放入数据， 另一个回调函数是在evbuffer A数据满的时候从中取出数据，由于这些操作是在栈上进行，这种做法会造成造成栈溢出，解决方法就是将回调函数延迟触发，条件满足时，将回调函数作为event_loop的一个部分 通过有规律的事件回调触发。 Option flags for bufferevents You can use one or more flags when creating a bufferevent to alter its behavior. Recognized flags are: 创建bufferevent时可以选择如下选项进行个性化设置 BEV_OPT_CLOSE_ON_FREEWhen the bufferevent is freed, close the underlying transport. This will close an underlying socket, free an underlying bufferevent, etc. 当bufferevent被释放，关闭底层传输，这个将会关闭底层socket，释放底层的bufferevent等。 BEV_OPT_THREADSAFEAutomatically allocate locks for the bufferevent, so that it’s safe to use from multiple threads. 为bufferevent自动上锁，多线程模式会安全。 BEV_OPT_DEFER_CALLBACKSWhen this flag is set, the bufferevent defers all of its callbacks, as described above. 设置bufferevent的callback延迟处理。 BEV_OPT_UNLOCK_CALLBACKSBy default, when the bufferevent is set up to be threadsafe, the bufferevent’s locks are held whenever the any user-provided callback is invoked. Setting this option makes Libevent release the bufferevent’s lock when it’s invoking your callbacks. 如果设置了线程安全选项，设置这个选项会使得调用我们的回调函数时释放锁。 Working with socket-based bufferevents 1创建bufferevent，成功返回bufferevent的指针，失败返回空，options是上面提到的选项。 1234struct bufferevent *bufferevent_socket_new( struct event_base *base, evutil_socket_t fd, enum bufferevent_options options); 2连接函数 int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen); the address and addrlen arguments are as for the standard call connect(). If the bufferevent does not already have a socket set, calling this function allocates a new stream socket for it, and makes it nonblocking. If the bufferevent does have a socket already, calling bufferevent_socket_connect() tells Libevent that the socket is not connected, and no reads or writes should be done on the socket until the connect operation has succeeded. It is okay to add data to the output buffer before the connect is done. 如果bufferevent没有设置socket，调用这个函数会为它创建一个非阻塞socket 如果bufferevent有socket，调用这个函数会通知libevent在连接成功前不能调用读或者写。 在连接成功前可以向output buffer中添加数据。 下面是例子： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;event2/event.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;void eventcb(struct bufferevent *bev, short events, void *ptr)&#123; if (events &amp; BEV_EVENT_CONNECTED) &#123; /* We&#x27;re connected to 127.0.0.1:8080. Ordinarily we&#x27;d do something here, like start reading or writing. */ &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; /* An error occured while connecting. */ &#125;&#125;int main_loop(void)&#123; struct event_base *base; struct bufferevent *bev; struct sockaddr_in sin; base = event_base_new(); memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */ sin.sin_port = htons(8080); /* Port 8080 */ bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev, NULL, NULL, eventcb, NULL); if (bufferevent_socket_connect(bev, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) &#123; /* Error starting connection */ bufferevent_free(bev); return -1; &#125; event_base_dispatch(base); return 0;&#125; Note that you only get a BEV_EVENT_CONNECTED event if you launch the connect() attempt using bufferevent_socket_connect(). If you call connect() on your own, the connection gets reported as a write. If you want to call connect() yourself, but still get receive a BEV_EVENT_CONNECTED event when the connection succeeds, call bufferevent_socket_connect(bev, NULL, 0) after connect() returns -1 with errno equal to EAGAIN or EINPROGRESS. 如果通过bufferevent_socket_connect连接，那么返回的事件是BEV_EVENT_CONNECTED ， 如果通过connect连接，那么返回的是write事件。如果调用了connect，还想捕捉到BEV_EVENT_CONNECTED 事件，可以继续调用bufferevent_socket_connect(bev,NULL, 0),返回值为-1，errno为EAGAIN或者EINPROGRESS 3释放bufferevent void bufferevent_free(struct bufferevent *bev);This function frees a bufferevent. Bufferevents are internally reference-counted, so if the bufferevent has pending deferred callbacks when you free it, it won’t be deleted until the callbacks are done. The bufferevent_free() function does, however, try to free the bufferevent as soon as possible. If there is pending data to write on the bufferevent, it probably won’t be flushed before the bufferevent is freed. If the BEV_OPT_CLOSE_ON_FREE flag was set, and this bufferevent has a socket or underlying bufferevent associated with it as its transport, that transport is closed when you free the bufferevent. 当bufferevent有延迟回调函数没处理，调用bufferevent_free并不会立即释放bufferevent，bufferevent内部是引用计数的，他能做到的是尽快释放，如果bufferevent上存在阻塞的数据还没有写，这部分数据在bufferevent释放前是不会被释放的。 4 其他的一些设置函数 是指bufferevent回调函数，以及获取回调函数 12345678910111213typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx);void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg);void bufferevent_getcb(struct bufferevent *bufev, bufferevent_data_cb *readcb_ptr, bufferevent_data_cb *writecb_ptr, bufferevent_event_cb *eventcb_ptr, void **cbarg_ptr); 5 读写生效函数，读写失效函数 void bufferevent_enable(struct bufferevent *bufev, short events);void bufferevent_disable(struct bufferevent *bufev, short events); short bufferevent_get_enabled(struct bufferevent *bufev);You can enable or disable the events EV_READ, EV_WRITE, or EV_READ|EV_WRITE on a bufferevent. When reading or writing is not enabled, the bufferevent will not try to read or write data. There is no need to disable writing when the output buffer is empty: the bufferevent automatically stops writing, and restarts again when there is data to write. Similarly, there is no need to disable reading when the input buffer is up to its high-water mark: the bufferevent automatically stops reading, and restarts again when there is space to read. By default, a newly created bufferevent has writing enabled, but not reading. You can call bufferevent_get_enabled() to see which events are currently enabled on the bufferevent. 可以设置bufferevent 读，写，或者读和写生效，当读或者写失效，bufferevent将不会尝试读或者写数据。在output为空时没必要让写操作失效，bufferevent会自动停止写，当有数据可写时才再次执行写操作。 同样的，在input buffer超过高水位时，没必要设置读失效，bufferevent 会自动停止读，而等到有空间(其实是input缓冲区非满)再次开始接收数据。 默认情况下，新创建的 bufferevent是可写的不可读的。(因为如果设置可读选项，那么会出现busyloop，因为input一直非满) 用户可以通过bufferevent_get_enabled获取当前哪些事件类型是允许的。 6设置水位接口 void bufferevent_setwatermark(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark);The bufferevent_setwatermark() function adjusts the read watermarks, the write watermarks, or both, of a single bufferevent. (If EV_READ is set in the events field, the read watermarks are adjusted. If EV_WRITE is set in the events field, the write watermarks are adjusted.) A high-water mark of 0 is equivalent to “unlimited”. bufferevent_setwatermark函数调整读或者写的水位。 7获取读写缓冲区的内容 struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);struct evbuffer *bufferevent_get_output(struct bufferevent *bufev); 8向bufferevent中写数据 int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf); 调用bufferevent_write可以向bufev的output 的末尾追加写入。 bufferevent_write_buffer将buf中的数据移除，写入到bufevoutput中。 两个函数返回0表示成功，-1表示失败。 9从bufferevent中读数据 size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf); bufferevent_read 从bufev中input buffer 读取size大小数据，存在data中。 bufferevent_read_buffer从bufev的input buffer中将所有数据取出放入到buf中。 两个函数返回0表示成功，-1表示失败。 10设置读写事件的超时时间 void bufferevent_set_timeouts(struct bufferevent *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write); 11强制刷新读或者写 int bufferevent_flush(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode state); 强制从底层读取数据，或将数据写入底层。The iotype argument should be EV_READ, EV_WRITE, or EV_READ|EV_WRITE to indicate whether bytes being read, written, or both should be processed.","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Libevent学习笔记(五) 根据例子学习bufferevent","date":"2017-08-04T09:41:54.000Z","path":"2017/08/04/Libevent5/","text":"libevent中提供了一个Hello-world.c 的例子，从这个例子可以学习libevent是如何使用bufferevent的。这个例子在Sample中这个例子之前讲解过，这次主要看下bufferevent的使用。 第一步找到main函数main函数 1234567891011121314151617181920int main()&#123; //...listener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); //... event_base_dispatch(base); evconnlistener_free(listener); event_free(signal_event); event_base_free(base); printf(&quot;done\\n&quot;); return 0;&#125; main函数中调用evconnlistener_new_bind()创建了一个evconnlistener 类型的listener,然后拍发消息，之后释放各种资源。 第二步在evconnlistener_new_bind()中调用evconnlistener_new()完成listener属性设置。这个函数里对evconnlistener_event中base进行回调函数的绑定和参数设置，通过event_assign将evconnlistener_event的istener设置读事件的回调函数，并且通过evconnlistener_enable让读回调函数触发，也就是触发listener_read_cb。这里evconnlister_enable调用的也是结构体注册的enable具体看代码吧，调用的是r = lev-&gt;ops-&gt;enable(lev);等同于调用event_listener_enable，该函数内部完成event_add。 123456789101112131415161718192021222324252627282930313233struct evconnlistener_event &#123; struct evconnlistener base; struct event listener;&#125;;struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)&#123; struct evconnlistener_event *lev;//开辟evconnlistener_event大小区域 lev = mm_calloc(1, sizeof(struct evconnlistener_event)); if (!lev) return NULL; //lev -&gt; base 表示 evconnlistener //evconnlistener evconnlistener_ops 基本回调参数和回调函数结构体赋值 lev-&gt;base.ops = &amp;evconnlistener_event_ops; //evconnlistener_cb 设置为listener_cb lev-&gt;base.cb = cb; //ptr表示event_base 指针 lev-&gt;base.user_data = ptr; lev-&gt;base.flags = flags; lev-&gt;base.refcnt = 1;// lev is evconnlistener_event //lev-&gt;listener is event //为lev-&gt;listener设置读回调函数和读关注事件，仅进行设置并没加入event队列 event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST, listener_read_cb, lev); //实际调用了event_add将事件加入event队列 evconnlistener_enable(&amp;lev-&gt;base); return &amp;lev-&gt;base;&#125; 第三步listener_read_cb内部调用accept生成新的socket处理连接，调用listener_cb新的socket作为参数传递给evconnlistener_event中base的回调函数listener_cb 123456789101112131415161718192021222324252627282930static voidlistener_read_cb(evutil_socket_t fd, short what, void *p)&#123; struct evconnlistener *lev = p; int err; evconnlistener_cb cb; evconnlistener_errorcb errorcb; void *user_data; LOCK(lev); while (1) &#123; //...//cb 就 是 listener_cb cb = lev-&gt;cb; user_data = lev-&gt;user_data; UNLOCK(lev); //触发了listener_cb //完成了eventbuffer注册写和事件函数 cb(lev, new_fd, (struct sockaddr*)&amp;ss, (int)socklen, user_data); LOCK(lev); if (lev-&gt;refcnt == 1) &#123; int freed = listener_decref_and_unlock(lev); EVUTIL_ASSERT(freed); return; &#125; --lev-&gt;refcnt; &#125; //...&#125; 第四步listener_cb 调用bufferevent_socket_new 生成bufferevent，然后bufferevent_setcb设置读写水位触发的回调函数，bufferevent_enable将bufferevent的写事件加入监听，即开始检测写事件。关闭读事件，并且向outbuf中写入MSGbufferevent_socket_new内部绑定bufferevent的读写事件回调函数，读事件为bufev-&gt;ev_read，绑定了bufferevent_readcb回调函数，写事件为bufev-&gt;ev_write，绑定了bufferevent_writecb回调函数。这两个回调函数和bufferevent的readcb和writecb是不一样的，这两个函数在对应的读写事件激活时才触发。而readcb和writecb是基于水位线达到阈值才会触发。做好区分。bufferevent_socket_new内部还对bufev-&gt;output添加了对调函数bufferevent_socket_outbuf_cb，bufferevent_socket_outbuf_cb内部检测是否开启写事件，以及是否可写，如果可写，同样将写事件加入监听队列，也就是调用了event_add。bufferevent_socket_new内部解释完毕了。bufferevent_setcb设置的是读写水位达到阈值后的回调函数，bufferevent_enable内部也是调用了event_add，将读事件加入监听队列。bufferevent_enable内部调用bufev-&gt;be_ops-&gt;enable(bufev, impl_events)，等同于be_socket_enable，另外bufferevent_write函数内部调用evbuffer_add，evbuffer_add内部调用了evbuffer_invoke_callbacks，就会调用绑定在output buffer上的回调函数bufferevent_socket_outbuf_cb。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static voidlistener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data)&#123; struct event_base *base = user_data; struct bufferevent *bev; bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; fprintf(stderr, &quot;Error constructing bufferevent!&quot;); event_base_loopbreak(base); return; &#125; //设置写回调和事件回调 bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL); bufferevent_enable(bev, EV_WRITE); bufferevent_disable(bev, EV_READ); //将要发送的内容写入evbuffer结构 bufferevent_write(bev, MESSAGE, strlen(MESSAGE));&#125;``` cpp ``` cppstruct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options)&#123; struct bufferevent_private *bufev_p; struct bufferevent *bufev; //...//设置bufferevent中 ev_read(event类型)回调函数 event_assign(&amp;bufev-&gt;ev_read, bufev-&gt;ev_base, fd, EV_READ|EV_PERSIST, bufferevent_readcb, bufev); //设置bufferevent中 ev_write(event类型)回调函数 event_assign(&amp;bufev-&gt;ev_write, bufev-&gt;ev_base, fd, EV_WRITE|EV_PERSIST, bufferevent_writecb, bufev); //为bufev-&gt;output(evbuffer类型)设置回调函数，插入bufferevent-&gt;output的callback队列 //bufferevent_socket_outbuf_cb回调函数内部将ev_write事件加入事件队列 evbuffer_add_cb(bufev-&gt;output, bufferevent_socket_outbuf_cb, bufev); evbuffer_freeze(bufev-&gt;input, 0); evbuffer_freeze(bufev-&gt;output, 1); //... return bufev;&#125; 12345678910111213static intbe_socket_enable(struct bufferevent *bufev, short event)&#123; if (event &amp; EV_READ) &#123; if (be_socket_add(&amp;bufev-&gt;ev_read,&amp;bufev-&gt;timeout_read) == -1) return -1; &#125; if (event &amp; EV_WRITE) &#123; if (be_socket_add(&amp;bufev-&gt;ev_write,&amp;bufev-&gt;timeout_write) == -1) return -1; &#125; return 0;&#125; 第五步 bufferevent的output中写入MSG， 并且之前也已经将EV_WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev_write，调用绑定在ev_write上的函数bufferevent_writecb。这是bufferevent内部的写操作，我们可以详细看一下。之前也有讲过bufferevent会将接收到的数据放到inputbuffer中，将outputbuffer中的数据发送。所以之前讲过的接口bufferevent_write让我们将要发送的数据放到output中，bufferevent_read可以从input中读出bufferevent接收到的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128static voidbufferevent_writecb(evutil_socket_t fd, short event, void *arg)&#123; struct bufferevent *bufev = arg; struct bufferevent_private *bufev_p = EVUTIL_UPCAST(bufev, struct bufferevent_private, bev); int res = 0; short what = BEV_EVENT_WRITING; int connected = 0; ev_ssize_t atmost = -1; //对 bufferevent加锁，支持多线程安全模式 _bufferevent_incref_and_lock(bufev); //检测是否带有超时事件 if (event == EV_TIMEOUT) &#123; /* Note that we only check for event==EV_TIMEOUT. If * event==EV_TIMEOUT|EV_WRITE, we can safely ignore the * timeout, since a read has occurred */ what |= BEV_EVENT_TIMEOUT; goto error; &#125; //判断是否是连接事件 if (bufev_p-&gt;connecting) &#123; int c = evutil_socket_finished_connecting(fd); /* we need to fake the error if the connection was refused * immediately - usually connection to localhost on BSD */ if (bufev_p-&gt;connection_refused) &#123; bufev_p-&gt;connection_refused = 0; c = -1; &#125; if (c == 0) goto done; bufev_p-&gt;connecting = 0; //连接失败删除该事件 if (c &lt; 0) &#123; event_del(&amp;bufev-&gt;ev_write); event_del(&amp;bufev-&gt;ev_read); _bufferevent_run_eventcb(bufev, BEV_EVENT_ERROR); goto done; &#125; else &#123; connected = 1; //windows情况下直接运行事件回调函数，然后go done#ifdef WIN32 if (BEV_IS_ASYNC(bufev)) &#123; event_del(&amp;bufev-&gt;ev_write); bufferevent_async_set_connected(bufev); _bufferevent_run_eventcb(bufev, BEV_EVENT_CONNECTED); goto done; &#125;#endif //linux 下 运行事件回调函数 _bufferevent_run_eventcb(bufev, BEV_EVENT_CONNECTED); //检测是否可写，不可写删除该事件 if (!(bufev-&gt;enabled &amp; EV_WRITE) || bufev_p-&gt;write_suspended) &#123; event_del(&amp;bufev-&gt;ev_write); goto done; &#125; &#125; &#125; //计算bufferevent能写的最大数量 atmost = _bufferevent_get_write_max(bufev_p); //写事件挂起了，跳过。 if (bufev_p-&gt;write_suspended) goto done; //output非空 if (evbuffer_get_length(bufev-&gt;output)) &#123; //将output的头打开，从头部发送 evbuffer_unfreeze(bufev-&gt;output, 1); //bufferevent调用写操作，将outbuffer中的内容发送出去 res = evbuffer_write_atmost(bufev-&gt;output, fd, atmost); //将output的头部关闭 evbuffer_freeze(bufev-&gt;output, 1); if (res == -1) &#123; int err = evutil_socket_geterror(fd); if (EVUTIL_ERR_RW_RETRIABLE(err)) goto reschedule; what |= BEV_EVENT_ERROR; &#125; else if (res == 0) &#123; /* eof case XXXX Actually, a 0 on write doesn&#x27;t indicate an EOF. An ECONNRESET might be more typical. */ //写完了 what |= BEV_EVENT_EOF; &#125; if (res &lt;= 0) goto error; //bufferevent减少发送的大小，留下未发送的，下次再发送，因为是PERSIST|WRITE //所以会在下次检测到可写时候继续写 _bufferevent_decrement_write_buckets(bufev_p, res); &#125; //计算是否将outbuf中的内容发送完，发完了就删除写事件 if (evbuffer_get_length(bufev-&gt;output) == 0) &#123; event_del(&amp;bufev-&gt;ev_write); &#125; /* * Invoke the user callback if our buffer is drained or below the * low watermark. */ //将buffer中的内容发完，或者低于low 水位，那么调用用户注册的写回调函数 //之前注册在bufev-&gt;writecb中的回调函数 if ((res || !connected) &amp;&amp; evbuffer_get_length(bufev-&gt;output) &lt;= bufev-&gt;wm_write.low) &#123; _bufferevent_run_writecb(bufev); &#125; goto done; reschedule: if (evbuffer_get_length(bufev-&gt;output) == 0) &#123; event_del(&amp;bufev-&gt;ev_write); &#125; goto done; error: bufferevent_disable(bufev, EV_WRITE); _bufferevent_run_eventcb(bufev, what); done: _bufferevent_decref_and_unlock(bufev);&#125; 第六步：这个函数内部每次尽可能多的发送数据，没有发送完就下次轮询继续发送,直到水位低于或等于写数据的低水位，那么就会触发bufferevent低水位写回调函数。也就是conn_writecb， 在conn_writecb内部检测output buffer中数据为空，就释放该bufferevent。 123456789static voidconn_writecb(struct bufferevent *bev, void *user_data)&#123; struct evbuffer *output = bufferevent_get_output(bev); if (evbuffer_get_length(output) == 0) &#123; printf(&quot;flushed answer\\n&quot;); bufferevent_free(bev); &#125;&#125; 这就是整体流程，bufferevent内部的流畅看懂即可，我们只需要使用libevent提供的接口即可。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"网络编程的一些错误总结","date":"2017-08-04T09:28:12.000Z","path":"2017/08/04/neterror/","text":"最近自己在写一套服务器框架，期间遇到很多问题，对于Linux或者windows出错情况下可以通过错误码获取错误信息。为了测试服务器性能，我在客户端开了2000个线程，这样每个线程都创建socket和服务器通信，连接15个线程，再后来的客户端线程connect过程中会失败，我另起了一个客户端进程进行连接，还是能连接15个过后才出现问题，初步可以排除服务器并没有达到连接上限，之后在linux上打印该错误码为111，查询意思为服务器拒绝客户端连接。查询相关资料是监听队列设置为5，只能接受一部分剩余的由于监听队列满了就被拒绝了。之后查询libevent和redis库的一些监听队列大小，设置为128较为合适，这次同样会出现一部分客户端连接失败，因为监听队列总是有限的，尽管如此，极限的情况下一秒同时连接500多个客户端还是没问题。 这个监听队列的知识可以介绍下：这个图说明tcp是三次握手处理连接和四次握手处理断开。 listen函数将主动套接字转换为被动监控套接字，其第二个参数backlog决定了内核的连接缓存队列长度。对于一个给定的监听套接字，内核维护两个队列： ① 未就绪队列，存放没有完成三路握手的连接，监听套接字收到SYN并返回ACK+SYN，连接处于SYN_RECV状态，等待对端发送ACK。如果已完成队列非满，则接收ACK，连接握手完成，进入已完成队列；如果已完成队列满则丢弃ACK，对端重发ACK（对端看到的连接是ESTABLISED状态），若未就绪队列中的SYN_RECV等待直到超时还没进入已完成队列则丢弃连接（对端不知道，只有在读写套接字时才知道）。 ② 已完成队列，存放已经完成三路握手的连接（ESTABLISHED），等待accept取走连接。 backlog决定了两个队列的长度之和（并不是说两个队列之和等于backlog，而是存在个转换，依赖于具体实现）。 如果未就绪队列满则忽略新到来的SYN请求，对端重发，如果一直不能进入未就绪队列则对端connect失败返回。 除此之外，由于每个客户端进程我开辟了2000个线程，也会报错errorno为9，意为bad file discirp，错误的文件描述符。 因为linux限制每个进程最多开辟1024个线程。 这些都是实际开发中遇到的一些问题，总结出来以便更好地处理以后的问题。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"网络编程一些常见问题总结","date":"2017-08-04T09:19:14.000Z","path":"2017/08/04/newproblem/","text":"1 设置网络socket非阻塞：12u_long has = 1;ioctl(m_sock, FIONBIO , &amp;has); 这个函数很有可能返回success，却并没有设置成功。windows对此有优化，对于linux版本应采用fcntl设置。 总结如下： 123456789101112131415161718192021222324252627intmake_socket_nonblocking(sockfd fd)&#123;#ifdef WIN32 &#123; u_long nonblocking = 1; if (ioctlsocket(fd, FIONBIO, &amp;nonblocking) == SOCKET_ERROR) &#123; cout &lt;&lt; &quot;fcntl failed, fd is : &quot; &lt;&lt; fd; return -1; &#125; &#125;#else &#123; int flags; if ((flags = fcntl(fd, F_GETFL, NULL)) &lt; 0) &#123; cout &lt;&lt; &quot;fcntl failed, fd is : &quot; &lt;&lt; fd; return -1; &#125; if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) &#123; cout &lt;&lt; &quot;fcntl failed, fd is : &quot; &lt;&lt; fd; return -1; &#125; &#125;#endif return 0;&#125; 2 windows环境下查看错误123使用WSAGetLastError函数需要配置 lib,&quot;ws2_32.lib&quot; 3 EPOLLET这个宏是最小intEPOLLET这个宏的数值为-2147483648， 是能表示的最小int值。 4 make: 警告：检测到时钟错误。您的创建可能是不完整的。可以通过ls -l查看具体的是哪个文件的时间错了，就可以对症下药了，直接 “ touch 对应文件 “ 就可以解决这个问题。 或者读者可以用 “ touch * “ 来更新整个项目文件的时间,这也可以解决问题。 5 select fd_set 对于不同平台实现是不同的在windows平台实现 1234typedef struct fd_set &#123; u_int fd_count; /* how many are SET? */ SOCKET fd_array[FD_SETSIZE]; /* an array of SOCKETs */&#125; fd_set; 很明了，一个计数的fd_count，另一个就是SOCKET数组。其中，FD_SETSIZE是可以设置的。整个fd_set的过程实际上就是将对应的fd_count作为数组下标，数组元素存储的是对应socket fd。比如说当前读事件集合readset的fd_count 为7，当要监控socket fd为5 的读事件到来时，那么readset这个集合中下标为8的数组元素为5，fd_count = 8以此类推。当调用select时，会返回对应读，写集合所有的描述符数组，并且重置内部的fd_count数量，然后分别调用读写函数即可。 下面是fd_set在linux下的实现： 123456789101112typedef struct &#123; /* XPG4.2 requires this member name. Otherwise avoid the name from the global namespace. */#ifdef __USE_XOPEN __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;fds_bits)#else __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;__fds_bits)#endif &#125; fd_set; 根据UNIX网络编程对fd_set的介绍，fd_set是个整数数组，用每个bit位来表示fd的。比如，一个32位整数，则数组第一个整数表示0-31的fd，以此类推，第二个整数表示32-63查看linux的FD_SET、FD_CLR是用汇编实现的。根据说明可以知道，就是给bit置位。fd_set在不同平台实现的机制不一样，select第一个参数在linux环境下表示最大描述符数+1。windows无意义。 下面是我根据libevent早期版本实现的一套select模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323#include &quot;modelmanager.h&quot;#ifdef WIN32#include &quot;netmodeldef.h&quot;#define XFREE(ptr) do &#123; if (ptr) free(ptr); &#125; while (0)struct win_fd_set &#123; u_int fd_count; SOCKET fd_array[1];&#125;;struct win32op &#123; unsigned num_fds_in_fd_sets; int resize_out_sets; struct win_fd_set *readset_in; struct win_fd_set *writeset_in; struct win_fd_set *readset_out; struct win_fd_set *writeset_out; struct win_fd_set *exset_out; unsigned signals_are_broken : 1;&#125;;static void *win32_init(void *);static int win32_add(void *, sockfd, short old, short events, void *_idx);static int win32_del(void *, sockfd, short old, short events, void *_idx);static int win32_dispatch(void *base, struct timeval *);static void win32_dealloc(void *);struct ModelOp win32ops = &#123; &quot;win32&quot;, win32_init, win32_add, win32_del, win32_dispatch, win32_dealloc,&#125;;#define FD_SET_ALLOC_SIZE(n) ((sizeof(struct win_fd_set) + ((n)-1)*sizeof(SOCKET)))static intgrow_fd_sets(struct win32op *op, unsigned new_num_fds)&#123; size_t size; if( !(new_num_fds &gt;= op-&gt;readset_in-&gt;fd_count &amp;&amp; new_num_fds &gt;= op-&gt;writeset_in-&gt;fd_count) ) return -1; if( !(new_num_fds &gt;= 1) ) return -1; size = FD_SET_ALLOC_SIZE(new_num_fds); if (!(op-&gt;readset_in = (struct win_fd_set *)realloc(op-&gt;readset_in, size))) return (-1); if (!(op-&gt;writeset_in = (struct win_fd_set *)realloc(op-&gt;writeset_in, size))) return (-1); op-&gt;resize_out_sets = 1; op-&gt;num_fds_in_fd_sets = new_num_fds; return (0);&#125;static intdo_fd_set(struct win32op *op, struct SocketIndex *ent, SOCKET s, int read)&#123; struct win_fd_set *set = read ? op-&gt;readset_in : op-&gt;writeset_in; if (read) &#123; if (ent-&gt;read_pos_plus1 &gt; 0) return (0); &#125; else &#123; if (ent-&gt;write_pos_plus1 &gt; 0) return (0); &#125; if (set-&gt;fd_count == op-&gt;num_fds_in_fd_sets) &#123; if (grow_fd_sets(op, op-&gt;num_fds_in_fd_sets*2)) return (-1); // set pointer will have changed and needs reiniting! set = read ? op-&gt;readset_in : op-&gt;writeset_in; &#125; set-&gt;fd_array[set-&gt;fd_count] = s; if (read) ent-&gt;read_pos_plus1 = set-&gt;fd_count+1; else ent-&gt;write_pos_plus1 = set-&gt;fd_count+1; return (set-&gt;fd_count++);&#125;static intdo_fd_clear(void *base,struct win32op *op, struct SocketIndex *ent, int read)&#123; ModelManager* pDispatcher = (ModelManager*)base; int i; struct win_fd_set *set = read ? op-&gt;readset_in : op-&gt;writeset_in; if (read) &#123; i = ent-&gt;read_pos_plus1 - 1; ent-&gt;read_pos_plus1 = 0; &#125; else &#123; i = ent-&gt;write_pos_plus1 - 1; ent-&gt;write_pos_plus1 = 0; &#125; if (i &lt; 0) return (0); if (--set-&gt;fd_count != (unsigned)i) &#123; struct SocketIndex *ent2; SOCKET s2; s2 = set-&gt;fd_array[i] = set-&gt;fd_array[set-&gt;fd_count]; ent2 = pDispatcher-&gt;getSocketIndex( s2 ); if (!ent2) // This indicates a bug. return (0); if (read) ent2-&gt;read_pos_plus1 = i+1; else ent2-&gt;write_pos_plus1 = i+1; &#125; return (0);&#125;#define NEVENT 32void *win32_init(void *base)&#123; struct win32op *winop; size_t size; if (!(winop = (struct win32op*)malloc( sizeof(struct win32op)))) return NULL; winop-&gt;num_fds_in_fd_sets = NEVENT; size = FD_SET_ALLOC_SIZE(NEVENT); if (!(winop-&gt;readset_in = (struct win_fd_set *)malloc(size))) goto err; if (!(winop-&gt;writeset_in = (struct win_fd_set *)malloc(size))) goto err; if (!(winop-&gt;readset_out = (struct win_fd_set *)malloc(size))) goto err; if (!(winop-&gt;writeset_out = (struct win_fd_set *)malloc(size))) goto err; if (!(winop-&gt;exset_out = (struct win_fd_set *)malloc(size))) goto err; winop-&gt;readset_in-&gt;fd_count = winop-&gt;writeset_in-&gt;fd_count = 0; winop-&gt;readset_out-&gt;fd_count = winop-&gt;writeset_out-&gt;fd_count = winop-&gt;exset_out-&gt;fd_count = 0; winop-&gt;resize_out_sets = 0; return (winop);err: XFREE(winop-&gt;readset_in); XFREE(winop-&gt;writeset_in); XFREE(winop-&gt;readset_out); XFREE(winop-&gt;writeset_out); XFREE(winop-&gt;exset_out); XFREE(winop); return (NULL);&#125;intwin32_add(void *base, SOCKET fd, short old, short events, void *_idx)&#123; ModelManager* pDispatcher = (ModelManager*)base; struct win32op *winop = (struct win32op *)pDispatcher-&gt;getModelData(); struct SocketIndex *idx = (struct SocketIndex *)_idx; if (!(events &amp; (EV_READ|EV_WRITE))) return (0); //event_debug((&quot;%s: adding event for %d&quot;, __func__, (int)fd)); if (events &amp; EV_READ) &#123; if (do_fd_set(winop, idx, fd, 1)&lt;0) return (-1); &#125; if (events &amp; EV_WRITE) &#123; if (do_fd_set(winop, idx, fd, 0)&lt;0) return (-1); &#125; return (0);&#125;intwin32_del(void *base, SOCKET fd, short old, short events, void *_idx)&#123; ModelManager* pDispatcher = (ModelManager*)base; struct win32op *winop = (struct win32op *)pDispatcher-&gt;getModelData(); struct SocketIndex *idx = (struct SocketIndex *)_idx; //event_debug((&quot;%s: Removing event for &quot;EV_SOCK_FMT,__func__, EV_SOCK_ARG(fd))); if ( (old &amp; EV_READ) &amp;&amp; !(events &amp; EV_READ) ) do_fd_clear(base, winop, idx, 1); if ( (old &amp; EV_WRITE) &amp;&amp; !(events &amp; EV_WRITE) ) do_fd_clear(base, winop, idx, 0); return 0;&#125;static voidfd_set_copy(struct win_fd_set *out, const struct win_fd_set *in)&#123; out-&gt;fd_count = in-&gt;fd_count; memcpy(out-&gt;fd_array, in-&gt;fd_array, in-&gt;fd_count * (sizeof(SOCKET)));&#125;/*static void dump_fd_set(struct win_fd_set *s)&#123;unsigned int i;printf(&quot;[ &quot;);for(i=0;i&lt;s-&gt;fd_count;++i)printf(&quot;%d &quot;,(int)s-&gt;fd_array[i]);printf(&quot;]\\n&quot;);&#125;*/intwin32_dispatch(void *base, struct timeval *tv)&#123; ModelManager* pDispatcher = (ModelManager*)base; struct win32op *winop = (struct win32op *)pDispatcher-&gt;getModelData(); int res = 0; unsigned j, i; int fd_count; SOCKET s; if (winop-&gt;resize_out_sets) &#123; size_t size = FD_SET_ALLOC_SIZE(winop-&gt;num_fds_in_fd_sets); if (!(winop-&gt;readset_out = (struct win_fd_set *)realloc(winop-&gt;readset_out, size))) return (-1); if (!(winop-&gt;exset_out = (struct win_fd_set *)realloc(winop-&gt;exset_out, size))) return (-1); if (!(winop-&gt;writeset_out = (struct win_fd_set *)realloc(winop-&gt;writeset_out, size))) return (-1); winop-&gt;resize_out_sets = 0; &#125; fd_set_copy(winop-&gt;readset_out, winop-&gt;readset_in); fd_set_copy(winop-&gt;exset_out, winop-&gt;writeset_in); fd_set_copy(winop-&gt;writeset_out, winop-&gt;writeset_in); fd_count = (winop-&gt;readset_out-&gt;fd_count &gt; winop-&gt;writeset_out-&gt;fd_count) ? winop-&gt;readset_out-&gt;fd_count : winop-&gt;writeset_out-&gt;fd_count; if (!fd_count) &#123; Sleep(tv-&gt;tv_usec/1000); return (0); &#125; res = select(fd_count, (struct fd_set*)winop-&gt;readset_out, (struct fd_set*)winop-&gt;writeset_out, (struct fd_set*)winop-&gt;exset_out, tv); //event_debug((&quot;%s: select returned %d&quot;, __func__, res)); if (res &lt;= 0) &#123; if( res == -1 ) &#123; printf(&quot;error:%d\\n&quot;, getErrno() ); &#125; return res; &#125; if (winop-&gt;readset_out-&gt;fd_count) &#123; i = rand() % winop-&gt;readset_out-&gt;fd_count; for (j=0; j&lt;winop-&gt;readset_out-&gt;fd_count; ++j) &#123; if (++i &gt;= winop-&gt;readset_out-&gt;fd_count) i = 0; s = winop-&gt;readset_out-&gt;fd_array[i]; pDispatcher-&gt;insertActiveList( s, EV_READ); &#125; &#125; if (winop-&gt;exset_out-&gt;fd_count) &#123; i = rand() % winop-&gt;exset_out-&gt;fd_count; for (j=0; j&lt;winop-&gt;exset_out-&gt;fd_count; ++j) &#123; if (++i &gt;= winop-&gt;exset_out-&gt;fd_count) i = 0; s = winop-&gt;exset_out-&gt;fd_array[i]; pDispatcher-&gt;insertActiveList( s, EV_WRITE); &#125; &#125; if (winop-&gt;writeset_out-&gt;fd_count) &#123; SOCKET s; i = rand() % winop-&gt;writeset_out-&gt;fd_count; for (j=0; j&lt;winop-&gt;writeset_out-&gt;fd_count; ++j) &#123; if (++i &gt;= winop-&gt;writeset_out-&gt;fd_count) i = 0; s = winop-&gt;writeset_out-&gt;fd_array[i]; pDispatcher-&gt;insertActiveList( s, EV_WRITE); &#125; &#125; return (0);&#125;voidwin32_dealloc(void *base)&#123; ModelManager* pDispatcher = (ModelManager*)base; struct win32op *winop = (struct win32op *)pDispatcher-&gt;getModelData(); if (winop-&gt;readset_in) free(winop-&gt;readset_in); if (winop-&gt;writeset_in) free(winop-&gt;writeset_in); if (winop-&gt;readset_out) free(winop-&gt;readset_out); if (winop-&gt;writeset_out) free(winop-&gt;writeset_out); if (winop-&gt;exset_out) free(winop-&gt;exset_out); memset(winop, 0, sizeof(winop)); free(winop);&#125;#endif","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"ECONNRESET和WSAECONNRESET怎么产生的以及如何避免","date":"2017-08-04T09:02:28.000Z","path":"2017/08/04/econreset/","text":"ECONNRESET是linux环境网络编程产生的错误，错误码为104， WSAECONNRESET是windows环境网络编程产生的错误，错误码为10054 两者产生的原因都一样，分以下几种情况： 1接收端recv或者read， 对端已经关闭连接，recv/read返回该错误 2 对端重启连接，还未建立连接 3 发送端已经断开连接，但是调用send会触发这个错误 第二点第三点都可以通过判断返回值解决，第一点在一些看似正常情况下也会触发该错误。比如对端close(fd)，接收端调用recv并没有返回0，而是-1，打印错误码为104或 10054，按道理讲这种情况按照返回值为0处理是可以的，但是尽量将代码写的规范一些，避免不必要的错误。 为什么close(fd)会导致接收端读到复位RST，也就是收到错误的104呢？ 因为close(fd)只是将文件描述符关闭，并没有关闭tcp建立起来的连接，断开连接需要四次握手，倘若发送端发送缓冲区有数据未发送完或者接受缓冲区有数据未读完，调用close(fd)，那么连接并没有关闭，这样，接收端收到的就是所谓的104或10054错误了。如何避免这个错误呢，就需要我们判断发送端发送和接受操作是否进行完，也就是判断缓冲区是否有数据，如果有数据需要等待数据处理完毕在关闭，否则会出现上述错误。 有一个做法是通过调用shutdown(s,SHUT_WR);关闭发送端的写端，这样发送端不发送数据，然后调用close这次会发送关闭连接的FIN标志，接收端接收到FIN，那么recv或者read返回的就是0. int shutdown(int sockfd,int how); Sockfd是需要关闭的socket的描述符。参数 how允许为shutdown操作选择以下几种方式： SHUT_RD：关闭连接的读端。也就是该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被丢弃。 进程将不能对该套接字发出任何读操作。 对 TCP套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。 SHUT_WR:关闭连接的写端，进程不能在对此套接字发出写操作 SHUT_RDWR:相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR 下面摘用网上的一段话来说明二者的区别：close—–关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket idshutdown–则破坏了socket 链接，读的时候可能侦探到EOF结束符，写的时候可能会收到一个SIGPIPE信号，这个信号可能直到socket buffer被填充了才收到。 close(sockfd);使用close中止一个连接，但它只是减少描述符的参考数，并不直接关闭连接，只有当描述符的参考数为0时才关闭连接。 而且shutdown只是处理连接关闭，并不能回收描述符，所以最终还是要调用close(fd)才能回收描述符，在所有描述符引用次数为0时发送 FIN消息给对端。 出了采取shutdown的方式，还可以通过设置socket属性，调用close时，检测在socket完成缓冲区读写后，才关闭连接 1234567struct linger &#123; int l_onoff; /* 0 = off, nozero = on */ int l_linger; /* linger time */ &#125;; 有下列三种情况：1、设置 l_onoff为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close调用会立即返回给调用者，如果可能将会传输任何未发送的数据； 2、设置 l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态； 3、设置 l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。 下面是代码： 1234567891011int z; int s; struct linger so_linger; so_linger.l_onoff = 1 so_linger.l_linger = 30; z = setsockopt(s,SOL_SOCKET,SO_LINGER,&amp;so_linger, sizeof so_linger); if ( z ) perror(&quot;setsockopt(2)&quot;); close(s); 到目前为止，我觉得比较好的主动关闭方式是： 关闭端： 1确保发送缓存区没有数据未发送，调用shutdown(fd,SHUTWR); 2如果能接收到数据，继续接受，直到接收到对方的FIN，也就是 read返回0或者-1 3如果接收到关闭信号，那么调用close正常关闭。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Udp打洞原理和源代码。","date":"2017-08-04T08:52:04.000Z","path":"2017/08/04/udphole/","text":"所谓udp打洞就是指客户端A通过udp协议向服务器发送数据包，服务器收到后，获取数据包，并且可获取客户端A地址和端口号。同样在客户端B发送给服务器udp数据包后，服务器同样在收到B发送过来的数据包后获取B的地址和端口号，将A和B的地址与端口号分别发送给对方，这样双方可以继续用UDP协议通信。这么做有什么用呢？因为对于一些应用或者需求，需要两个客户端临时做一些通信，而这种通信不需要建立tcp就可以完成，所以才去udp打洞。 下面附上测试代码： 头文件 123456789101112131415161718192021222324252627282930313233// udphole.cpp : 定义控制台应用程序的入口点。#ifdef WIN32#include &quot;stdafx.h&quot;#include &lt;winsock2.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)typedef SOCKET socketfd;typedef SOCKADDR_IN sockaddr_in;#endif#ifdef __linux__ #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;iostream&gt; #include &lt;errno.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;pthread.h&gt;typedef int socketfd;#endif#include &lt;list&gt;#include &lt;map&gt;#include &lt;iostream&gt;using namespace std; 服务器端核心代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;list&gt;#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; #ifdef WIN32 std::list&lt;SOCKADDR_IN&gt; addrList; WSADATA wsaData = &#123;0&#125;; if (0 != WSAStartup(MAKEWORD(2,2), &amp;wsaData)) &#123; printf (&quot;WSAStartup failed. errno=[%d]\\n&quot;, WSAGetLastError()); return -1; &#125; #endif #ifdef __linux__ std::list&lt;sockaddr_in&gt; addrList; #endif //addrList 是地址列表，每次存放最新到来的。 socketfd sockServer = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if (-1 == sockServer) &#123; #ifdef WIN32 printf (&quot;socket server failed. errno=[%d]\\n&quot;, WSAGetLastError()); #endif #ifdef __linx__ printf(&quot;socket server failed. errno=[%d]\\n&quot;, errno); #endif return -2; &#125; sockaddr_in addrServer = &#123;0&#125;; addrServer.sin_family = AF_INET; addrServer.sin_addr.s_addr = INADDR_ANY;//inet_addr(&quot;192.168.1.2&quot;); addrServer.sin_port = htons(10000); if (0 != bind(sockServer, (sockaddr*)&amp;addrServer, sizeof(addrServer))) &#123; #ifdef WIN32 printf (&quot;bind server failed.errno=[%d]\\n&quot;, WSAGetLastError()); #endif #ifdef __linux__ printf(&quot;bind server failed.errno=[%d]\\n&quot;, errno); #endif return -3; &#125; cout &lt;&lt; &quot;okok6&quot;&lt;&lt;endl; while(1) &#123; char pcContent1[10240] = &#123;0&#125;; sockaddr_in addrUser1 = &#123;0&#125;; #ifdef WIN32 int nLen1 = sizeof(addrUser1); #endif #ifdef __linux__ socklen_t nLen1 = sizeof(addrUser1); #endif //服务器接收来自客户端的消息，并且用addrUser1保存地址和端口 if (-1 == recvfrom(sockServer, pcContent1, sizeof(pcContent1), 0, (sockaddr*)&amp;addrUser1, &amp;nLen1)) &#123; cout &lt;&lt; &quot;dfdfda&quot;&lt;&lt;endl; #ifdef WIN32 printf (&quot;recv user 1 failed.errno=[%d]&quot;, WSAGetLastError()); #endif #ifdef __linux__ printf (&quot;recv user 1 failed.errno=[%d]&quot;, errno); #endif return -4; &#125; else &#123; // printf (&quot;connect user ip=[%s] port=[%d]\\n&quot;, inet_ntoa(addrUser1.sin_addr), htons(addrUser1.sin_port)); //如果地址列表非空，那么取出列表中的地址，并且与最新到来的客户端通信 if(addrList.size()) &#123; sockaddr_in peerAddr = addrList.front(); int nLen2 = sizeof(peerAddr); printf (&quot;peer user ip=[%s] port=[%d]\\n&quot;, inet_ntoa(peerAddr.sin_addr), htons(peerAddr.sin_port)); if (-1 == sendto(sockServer, (char*)&amp;addrUser1, nLen1, 0, (sockaddr*)&amp;peerAddr, nLen2)) &#123; #ifdef WIN32 printf (&quot;send to peer user data failed.\\n&quot;, WSAGetLastError()); #endif #ifdef __linux__ printf (&quot;send to peer user data failed.\\n&quot;, errno); #endif return -6; &#125; if (-1 == sendto(sockServer, (char*)&amp;peerAddr, nLen2, 0, (sockaddr*)&amp;addrUser1, nLen1)) &#123; #ifdef WIN32 printf (&quot;send to connect user data failed.\\n&quot;, WSAGetLastError()); #endif #ifdef __linux__ printf (&quot;send to connect user data failed.\\n&quot;, errno); #endif return -6; &#125; addrList.pop_front(); &#125; else &#123; //如果列表为空，那么将该地址放入列表中。 addrList.push_back(addrUser1); &#125; &#125; &#125; #ifdef WIN32 Sleep(INFINITE); #endif #ifdef __linux__ //sleep(1000); #endif return 0;&#125; 下面是客户端发送消息的代码，比较简单。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;stdafx.h&quot;#include &lt;winsock2.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)int _tmain(int argc, _TCHAR* argv[])&#123; WSADATA wsaData = &#123;0&#125;; if (0 != WSAStartup(MAKEWORD(2,2), &amp;wsaData)) &#123; printf (&quot;WSAStartup failed. errno=[%d]\\n&quot;, WSAGetLastError()); return -1; &#125; SOCKET sockClient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if (SOCKET_ERROR == sockClient) &#123; printf (&quot;socket server failed. errno=[%d]\\n&quot;, WSAGetLastError()); return -2; &#125; char pcContent1[UCHAR_MAX] = &#123;0&#125;; SOCKADDR_IN addrServer = &#123;0&#125;; addrServer.sin_family = AF_INET; addrServer.sin_addr.s_addr = inet_addr(&quot;192.168.1.40&quot;); addrServer.sin_port = htons(10000); int nLen1 = sizeof(addrServer); //客户端发送自己的报文 if (SOCKET_ERROR == sendto(sockClient, pcContent1, 1, 0, (sockaddr*)&amp;addrServer, nLen1)) &#123; printf (&quot;recv user 1 failed.errno=[%d]&quot;, WSAGetLastError()); return -3; &#125; SOCKADDR_IN addrUser = &#123;0&#125;; char pcContent2[UCHAR_MAX] = &#123;0&#125;; //阻塞接收来自服务器的消息。 if (SOCKET_ERROR == recvfrom(sockClient, pcContent2, sizeof(pcContent2), 0, (sockaddr*)&amp;addrServer, &amp;nLen1)) &#123; printf (&quot;recv user 1 failed.errno=[%d]&quot;, WSAGetLastError()); return -5; &#125; else &#123; memcpy (&amp;addrUser, pcContent2, sizeof(addrUser)); sprintf (pcContent2, &quot;hello, user ip=[%s] port=[%d]\\n&quot;, inet_ntoa(addrUser.sin_addr), htons(addrUser.sin_port)); //解析服务器消息后发送消息给另一个客户端。 if (SOCKET_ERROR == sendto(sockClient, pcContent2, strlen(pcContent2), 0, (sockaddr*)&amp;addrUser, nLen1)) &#123; printf (&quot;recv user 1 failed.errno=[%d]&quot;, WSAGetLastError()); return -3; &#125; else &#123; //阻塞接收另一个客户端发送过来的消息 if (SOCKET_ERROR == recvfrom(sockClient, pcContent2, sizeof(pcContent2), 0, (sockaddr*)&amp;addrServer, &amp;nLen1)) &#123; printf (&quot;recv user 1 failed.errno=[%d]&quot;, WSAGetLastError()); return -5; &#125; printf (&quot;%s&quot;, pcContent2); &#125; &#125; Sleep(INFINITE); return 0;&#125; 效果如下，服务器收到来自客户端A和客户端B的报文后打印他们的信息，并且互相转发消息。客户端A和客户端B分别打印对方的地址和端口号到此为止，udp打洞的代码介绍完了。可以关注我的公众号，谢谢","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"网络编程学习方法和图书推荐","date":"2017-08-04T08:38:00.000Z","path":"2017/08/04/networkbook/","text":"从事网络编程有五年多了，写过自己的Server，读过大部分网络库libevent，redis,muduo等等，市面上的网络用书大多读过，给新人一些建议，主要是从事服务器网络编程后端的同学。如果你没写过网络编程的代码，也没有这方面的知识，那么该如何下手呢？这个时候不需要盲目看书，先培养一下自己的兴趣，了解TCP如何建立连接，TCP三次握手和四次握手的过程，有了这个，然后去了解socket方面编程的基本知识，socket的创建，绑定，连接，发送，接收，建立连接等api，学习完这些api，试着去写一个单线程阻塞通信 demo，客户端发送数据，服务器接收数据，然后将数据返回给客户端，客户端收到后继续发送，这样简单的echo服务器就写出来了。 这是我做的一个小demo，可以参考下，但是不是echo，读者可自己改为echo服务器。 http://www.cnblogs.com/secondtonone1/p/5460942.html 如果很多个客户端连接过来怎么处理呢？这时需要了解多线程模式的网络编程，你可以去了解accept原理，和线程创建处理新的连接。这样就可以做出一个多线程echo的Server了。这是我做的一个简单的accept多线程服务器，读者可自己改为echo模式 http://www.cnblogs.com/secondtonone1/p/5461120.html 有了这些基础知识，你就可以深入了解网络变成了，下一步要做的是了解TCP的socket缓存原理，阻塞原理，非阻塞的socket如何返回错误码，错误码的意义和如何处理，这些知识是你学习非阻塞多路复用的基础，学完这些，可以学多路复用的几种模型了，select，poll，epoll，iocp，kqueue等等，学的时候去补充自己不知道的一些TCP知识。多路复用学习后可以简单的去写一些多路复用服务器demo。 这是我之前讲过的epoll知识和自己写的epoll demo http://www.cnblogs.com/secondtonone1/p/5367495.html http://www.cnblogs.com/secondtonone1/p/5432453.html 会写多路复用服务器就可以了吗？这只是开始，下面就要阅读源码和高性能的框架了，我推荐去读一读redis和libevent这两个框架，对网络编程提升很大，其中的缓存思想也很重要。这个时候你需要的是从框架的角度搭建一个高性能的服务器，需要了解事件堆，Reactor模式，Proactor模式，将不同的多路复用封装为一个IOService，就像libevent的EventLoop，像boost asio的ioservice一样。 下面是我封装的一个服务器，上传到github了 https://github.com/secondtonone1/betternet 这些都会了，也就是我现在的水平了，我现在在看一些网络大神的思想和视频，从他们的设计角度感受如何架构一个优秀的框架，建议大家看看陈硕的muduo网络库和编程视频，能醍醐灌顶。我现在也在学一些其他的框架，主要是想触类旁通，同时看看优秀的框架代码，虽然自己写不出太优秀的框架，至少可以开阔眼界，作为积累。 下面是推荐大家的网络图书： 我推荐新手先看 Linux程序设计(第4版)Linux高性能服务器编程看过之后再看Richard的三本网络书这些都看过之后，需要实战，实战过程中可以看看以及陈硕的经验之谈，我现在在看的 这些都看过了，可以看看源码 libevent 源码下载地址：http://libevent.org/ redis源码下载地址：http://www.redis.cn/download.html boost asio 文档和下载：http://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html muduo网络库：http://code.csdn.net/openkb/p-muduo 这些源码都搞通了，就有了自己的方法和框架了，然后就自己闯荡吧。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"redis 配置和使用(C++)","date":"2017-08-04T08:17:47.000Z","path":"2017/08/04/redisset/","text":"一、Redis简介：Redis为非关系型数据库，Redis是一个Key-Value存储系统。它支持存储的value类型有：string(字符串),list(链表), set(无序集合),zset(sorted set有序集合)和hash，Redis支持各种不同方式的排序。数据都是缓存在内存中的，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并实现了master-slave(主从)同步。 二、Redis安装和使用：Redis下载地址，我下载的为最新版本： wget [http://download.redis.io/releases/redis-3.2.8.tar.gz](wget http://download.redis.io/releases/redis-3.2.8.tar.gz) 解压安装： 123$ tar xzf redis-3.2.8.tar.gz$ cd redis-3.2.8$ make make完后 redis-3.2.8目录下会出现redis-server和redis-cli下面在src目录下启动redis服务. 1$./redis-server 注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动. 1$ ./redis-server redis.conf redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了.下面为官方提供的案例：服务器启动： 1src/redis-server redis.conf 客户端读写： 123456$ src/redis-cliredis&gt; set foo barOKredis&gt; get foo&quot;bar&quot; redis.conf 为redis配置文件，有很多参数供用户修改，这里仅仅说明几个参数，其他的读者自行搜索。 port: 为redis启动的端口号，当需要启动多个redis服务器时修改该参数，可以启动多个服务。 bind ：绑定ip，设置后只接受自该ip的请求 databases ：设置数据库的个数，默认使用的数据库为0，redis有16个数据库，修改参数可写入不同的数据库。 requirepass ：设置登录时需要使用的密码。 下面修改requirepass 为 zjml123456&amp;&amp;REDIS,那么重启redis-server,放在后台运行。效果就是这样然后启动客户端使用密码登录并且查询数据使用密码命令为：auth 密码 设置key和value的命令为: set key value 取出key对应的value 为： get key 使用C++访问redis:使用redis接口之前需要将hireids.h 和libhiredis.a放到项目目录里，这两个文件在redis解压目录redis-3.2.8/deps/下,我这里写了一个demo，所以都放在demo的文件夹下了。 下面介绍redis提供的供C++访问的接口 主要包括如下四个方法 redisContext* redisConnect(const char *ip, int port) 该函数用来连接redis数据库， 两个参数分别是redis数据库的ip和端口，端口号一般为6379。 void *redisCommand(redisContext *c, const char *format…) 该函数用于执行redis数据库中的命令，第一个参数为连接数据库返回的redisContext，剩下的参数为变参，如同C语言中的prinf()函数。此函数的返回值为void*，但是一般会强制转换为redisReply类型，以便做进一步的处理。根据redisReply中的type变量类型判断命令执行情况 REDIS_REPLY_STATUS： 返回执行结果为状态的命令。比如set命令的返回值的类型是REDIS_REPLY_STATUS，然后只有当返回信息是”OK”时，才表示该命令执行成功。 可以通过reply-&gt;str得到文字信息，通过reply-&gt;len得到信息长度。 REDIS_REPLY_ERROR： 返回错误。错误信息可以通过reply-&gt;str得到文字信息，通过reply-&gt;len得到信息长度。 REDIS_REPLY_INTEGER： 返回整型标识。可以通过reply-&gt;integer变量得到类型为long long的值。 REDIS_REPLY_NIL: 返回nil对象，说明不存在要访问的数据。 REDIS_REPLY_STRING: 返回字符串标识。可以通过reply-&gt;str得到具体值，通过reply-&gt;len得到信息长度。 REDIS_REPLY_ARRAY: 返回数据集标识。数据集中元素的数目可以通过reply-&gt;elements获得，每个元素是个redisReply对象， 元素值可以通过reply-&gt;element[..index..].*形式获得，用在获取多个数据结果的操作。 void freeReplyObject(void *reply) 释放redisCommand执行后返回的的redisReply所占用的内存。 void redisFree(redisContext *c) 释放redisConnect()所产生的连接。 下面是我封装的一个C++访问redis的类 RedisManager.h 12345678910111213141516171819202122class RedisManager &#123; public: RedisManager(); virtual ~RedisManager(); //初始化函数 bool initial(); //释放函数 void release(); //封装的set接口 void set(std::string key, std::string value); //封装的get接口 std::string get(std::string key); private: //连接的缓存指针 redisContext* m_pConnect; //请求处理结果指针 redisReply* m_pReply; &#125;; RedisManager.cpp 分别介绍几个接口： 构造函数和析构函数没写代码，下面是初始化函数： 初始化函数： 123456789101112131415161718192021222324252627282930313233343536373839bool RedisManager::initial()&#123; //redis服务器ip const char* redisIp = &quot;192.168.1.40&quot;; //redis服务器端口 int redisPort = 6379; //连接redis服务器 m_pConnect = redisConnect(redisIp, redisPort); m_pReply = NULL; if(!m_pConnect) &#123; return false; &#125; if (m_pConnect != NULL &amp;&amp; m_pConnect-&gt;err) &#123; cout &lt;&lt; &quot; redis connect failed!!!!&quot; &lt;&lt; endl; return false; &#125; //根据密码登录 m_pReply =(redisReply*) redisCommand(m_pConnect, &quot;AUTH %s&quot;, mypass.c_str()); if(!m_pReply) &#123; cout &lt;&lt; &quot;redis exe failed!!&quot;&lt;&lt;endl; return false; &#125; if( !(m_pReply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcasecmp(m_pReply-&gt;str,&quot;OK&quot;)==0)) &#123; cout &lt;&lt; &quot; redis auth failed!!!!&quot; &lt;&lt; endl; freeReplyObject(m_pReply ); m_pReply = NULL; return false; &#125; freeReplyObject(this-&gt;m_pReply ); m_pReply = NULL; cout &lt;&lt; &quot; redis auth success!!!!&quot; &lt;&lt; endl; return true;&#125; 释放函数： 1234567void RedisManager::release()&#123; //释放连接 freeReplyObject(m_pConnect); m_pConnect = NULL; m_pReply = NULL;&#125; set函数： 123456789101112131415161718192021void RedisManager::set(std::string key, std::string value)&#123; //设置key和value关系，插入redis redisReply* r =(redisReply*)redisCommand(this-&gt;m_pConnect, &quot;SET %s %s&quot;, key.c_str(), value.c_str()); if(!r) &#123; cout &lt;&lt; &quot;set redis faliled&quot; &lt;&lt; endl; return; &#125; //执行失败 if( !(r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcasecmp(r-&gt;str,&quot;OK&quot;)==0)) &#123; cout &lt;&lt; &quot;set redis faliled&quot; &lt;&lt; endl; freeReplyObject(r ); return; &#125; cout &lt;&lt; &quot;set redis success&quot;&lt;&lt;endl; freeReplyObject(r );&#125; get函数： 123456789101112131415161718192021222324std::string RedisManager::get(std::string key)&#123; //根据key获取value m_pReply = (redisReply*)redisCommand(this-&gt;m_pConnect, &quot;GET %s&quot;, key.c_str()); if(!m_pReply) &#123; cout &lt;&lt; &quot;get value failed&quot; &lt;&lt; endl; return &quot;&quot;; &#125; //get成功返回结果为 REDIS_REPLY_STRING if( m_pReply-&gt;type != REDIS_REPLY_STRING ) &#123; cout &lt;&lt; &quot;get redis faliled&quot; &lt;&lt; endl; freeReplyObject(m_pReply ); m_pReply = NULL; return &quot;&quot;; &#125; cout &lt;&lt; &quot;get redis success&quot;&lt;&lt;endl; std::string valuestr = m_pReply-&gt;str; freeReplyObject(m_pReply ); m_pReply = NULL; return valuestr ;&#125; main 函数为： 123456789101112131415161718int main()&#123; RedisManager * redisManager = new RedisManager(); if(redisManager) &#123; redisManager-&gt;initial(); edisManager-&gt;set(&quot;test&quot;,&quot;nice to meet u!&quot;); std::string valueStr = redisManager-&gt;get(&quot;1sdfd&quot;); cout &lt;&lt; valueStr &lt;&lt; endl; redisManager-&gt;release(); delete redisManager; &#125; &#125; 源码下载地址： http://download.csdn.net/detail/secondtonone1/9826761","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"大并发服务器框架设计","date":"2017-08-04T07:38:23.000Z","path":"2017/08/04/ioservertype/","text":"简单谈一谈大并发服务器框架设计的基本思路基本的服务器框架都是C/S结构的，请求和相应流程是这样的： 这样的框架存在一个很严重的问题，当客户端大并发请求到来，服务器需要进行大量的数据库操作，假设数据库最大连接数为1000个，此时有10000个请求访问应用服务器，那么应用服务器只能处理1000个请求，剩下99000个等待1000个请求处理好后再进行访问数据库处理。可以在应用服务器和数据库服务器中间增加中间层DAL，DAL采用缓冲队列和连接池设计。DAL设计缓冲队列，存储等待的请求，并且DAL中设计数据库连接池，当数据库连接池中有空闲连接，那么从缓冲队列中取出一个请求处理，以此类推。这种做法有效的降低了服务器的压力，但是没有提高处理速度，仅仅保证了请求被缓存，处理效率仍受限于数据库的并发数。那么可以再增加一层缓存，将常用的数据加载如缓存，有请求到来时，应用服务器先从缓存中获取数据，如果缓存中有数据，那么不需要访问数据库，如果缓存中没有，在访问数据库取出数据，并更新缓存。缓存如何同步？ 有两种手段： 第一种方法： 缓存是具有时效的，在一定时间过后会超时timeout，如果缓存失效，那么重新去数据库查询，查询后更新缓存，这种方法不是实时的，实时性比较差。 第二种方法：当有请求修改数据时，更新缓存，并且将要修改的数据投入DAL层，当数据库有空闲连接时，再持久化存盘。 缓存的不足之处： 当缓存足够多时，需要将不活跃缓存数据换出内存，叫做缓存换页。缓存换出算法和操作系统换页算法类似，FIFO，LRU（least recently used），LFU（least frequently used）等。实际缓存的实现不需要自己去实现，有很多开源技术，nosql技术就是非关系型数据库的意思。非关系型数据库如redis，memcatched等。缓存可以跟应用服务器部署在同一台机器上，也可以部署在单独机器上。我推荐将缓存服务器部署在单独机器上，假设有两台应用服务器，如果将缓存部署在不同的应用服务器上，那么不同的应用服务器很难访问彼此的缓存，非常不方便。将缓存部署在单独服务器上，各个应用服务器都能访问该缓存服务器。如果有大量的业务请求到来，虽然设计了多个应用服务器，也架设了缓存服务器，完善了中间层的缓冲队列和数据库连接池，但是数据库服务器仍然会出现瓶颈。比如当有大量复杂的写操作数据库，很多读数据库的操作就被阻塞了，为解决这个问题可将数据库实现读写分离。由于数据库读操作会比写操作多，那么可以对数据库执行负载均衡。主流数据库都有replication机制，采用replication机制可以实现负载均衡。中间层的写数据库操作投递到master数据库中，读操作从slave数据库中读取，当master数据库中数据被修改后，数据库采用replication机制将数据同步给slave服务器。同样的道理，应用服务器也可以实现负载均衡，架设多个应用服务器，不同的请求分配给不同的应用服务器。可单独设计一个任务服务器监控各个应用服务器的负载情况，合理的分配任务给各个应用服务器。这种方式是任务服务器主动地分配任务给应用服务器，应用服务器被动的接受任务，这种方式在任务请求类型相近的情况下，分配方式非常合理。但是假设应用服务器A接受了3个任务，应用服务器B接受了5个任务，按照负载均衡的权重法或最小连接法，肯定会分配给A任务，但是如果这3个任务都是复杂的写操作，而B的5个任务都是简单的读操作，那么这就存在分配的不合理性，如何解决这个问题呢？可以换一种思路去解决这个问题，让应用服务器主动去请求任务服务器，主动获取任务处理，如果应用服务器处于忙碌状态就不需要请求新的任务，空闲的应用服务器会去请求任务服务器中的任务，这是最合理的负载均衡。如果所有应用服务器都处于忙碌状态，那么任务服务器将任务缓存至自己的任务队列，当应用服务器空闲时会来取任务。考虑这样一个问题，如果任务服务器出现故障怎么办？任务服务器需要有多台，并且实现failover机制，多台任务服务器之间实现心跳，如果检测不到对方心跳，则使自己成为主任务服务器。到目前为止，这个框架可以适用于大部分服务器逻辑。为保证数据库的响应速度和处理效率，可以对数据库进行分区。 数据库分区有两种形式(分库、分表) 分库：数据库可以按照一定的逻辑把表分散到不同的数据库。这叫做垂直分区，就是所每个库的表不同，功能不同。这样做不常见，因为很大情况下，数据库中各个表是关联的， 如果将不同的表分配到不同的数据库中，会存在很多不便。 分表：将一个表的不同数据分配到各个数据库，这样每个数据库的表结构是一样的，只是存储的用户数据不同而已，叫做水平分区。分表的方式很常见，如果数据库的压力增加， 我们就采取分表的方式减少数据库的压力。 另外服务器开发的几个性能杀手： 1 数据拷贝，数据从内核态copy到用户态，或者在用户态之间copy会造成性能损失，尽量采用缓存的方式解决。 2 环境切换 ，多线程上下文切换造成开销。如果服务器是单核的，那么采用状态机方式单线程效果最佳。如果是多核的， 合理采用多线程，可以提升性能。 3 内存分配，可以采用内存池，提前分配。 4 锁竞争，加锁解锁会造成一定的效率衰减。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"TCP/IP地址格式转换API","date":"2017-08-04T07:30:02.000Z","path":"2017/08/04/tcpapi/","text":"1、htonl ()和ntohl( ) ntohl( )—–网络顺序转换成主机顺序(长整型) u_long PASCAL FAR ntohl (u_long netlong); htonl ()—–主机顺序转换成网络顺序 (长整型) u_long PASCAL FAR htonl (u_long hostlong); 2、htons ()和ntohs( ) htons()——主机顺序转换成网络顺序(短整型) u_short PASCAL FAR htons (u_short hostshort); ntohs()——网络顺序转换成主机顺序(短整型) u_short PASCAL FAR ntohs (u_short netshort); 3、inet_addr( )和inet_ntoa ( ) unsigned long PASCAL FAR inet_addr (const char FAR * cp); char FAR * PASCAL FAR inet_ntoa (struct in_addr in); inet_addr函数需要一个字符串作为其参数，该字符串指定了以点分十进制格式表示的IP地址（例如：192.168.1.161）。而且inet_addr函数会返回一个适合分配给S_addr的u_long类型的数值。 1234567891011int sockfd; struct sockaddr_in my_addr; sockfd = socket(AF_INET, SOCK_STREAM, 0); my_addr.sin_family = AF_INET; /* 主机字节序 */ my_addr.sin_port = htons(9925); /* short, 网络字节序 */ my_addr.sin_addr.s_addr = inet_addr(&quot;192.168.0.1&quot;); bzero(&amp;(my_addr.sin_zero), 8); bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr)); inet_ntoa函数会完成相反的转换，它接受一个in_addr结构体类型的参数并返回一个以点分十进制格式表示的IP地址字符串。 服务器accept收到一个连接后，可以通过inet_ntoa找到对方ip，输出为字符串格式的点分十进制 123456789client = accept(serverSocket, (struct sockaddr *)&amp;clientAddr, (socklen_t *)&amp;addr_len); if (client &lt; 0) &#123; perror(&quot;accept&quot;); &#125; printf(&quot;\\nRecv client data...\\n&quot;); printf(&quot;IP is %s\\n&quot;, inet_ntoa(clientAddr.sin_addr)); sockaddr_in , sockaddr , in_addr区别 1234struct sockaddr &#123; unsigned short sa_family; char sa_data[14]; &#125;; 上面是通用的socket地址，具体到Internet socket，用下面的结构，二者可以进行类型转换 1234567struct sockaddr_in &#123; short int sin_family; unsigned short int sin_port; struct in_addr sin_addr; unsigned char sin_zero[8]; &#125;; struct in_addr就是32位IP地址。 123456789struct in_addr &#123; union &#123; struct &#123; u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b; struct &#123; u_short s_w1,s_w2; &#125; S_un_w; u_long S_addr; &#125; S_un; #define s_addr S_un.S_addr &#125;; inet_addr()是将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位IP地址(0xC0A80001)。 填值的时候使用sockaddr_in结构，而作为函数（如socket, listen, bind等）的参数传入的时候转换成sockaddr结构就行了，毕竟都是16个字符长。 名词解析： 主机字节序： 不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。最常见的有两种 1．Little endian：低字节存高地址，高字节存低地址 2．Big endian：低字节存低地址，高字节存高地址 网络字节序： 网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。 为了进行转换bsd socket提供了转换的函数，有下面四个网络与主机字节转换函数:htons ntohs htonl ntohl (s 就是short l是long h是host n是network) htons 把unsigned short类型从主机序转换到网络序，htonl 把unsigned long类型从主机序转换到网络序，ntohs 把unsigned short类型从网络序转换到主机序，ntohl 把unsigned long类型从网络序转换到主机序。 在使用little endian的系统中 这些函数会把字节序进行转换 在使用big endian类型的系统中这些函数会定义成空宏","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"柔性数组探索和应用","date":"2017-08-04T04:48:23.000Z","path":"2017/08/04/avilablearray/","text":"redis字符串可以实现通过地址偏移找到所在结构体的首地址，struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)))也就是通过buf地址可以找到sdshdr的地址，这个我一直不理解，写了代码测试下 地址一次间隔4，结构体总大小为8，最后一个buf是空数组，没大小。之前自己一直错误的认为buf的大小按照char *开辟，这次打印出来大小为0将结构体buf成员改为char 类型这次大小变为12了，也就是char 占用了四个字节 现在回到最初的结构 我尝试给buf开辟空间编译是不允许的，这是个零大小的数组，但是buf[lenth]这种方式可以访问，只是数组越界罢了。那就要一次给这个结构体开辟好空间，通过buf位移取出数据结果 &amp;buf和buf所指向的地址一个地址。因为它本身没有空间","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"弱点针对训练（函数指针）","date":"2017-08-04T04:40:26.000Z","path":"2017/08/04/weakeness/","text":"想着把每一个基础的知识点搞清，趁着早晨凉快就先写一些总结函数指针，基本结构是 函数返回类型（* 函数指针名字）（函数参数1，函数参数2，...）；这种指针用于指向一个函数的地址，可以通过函数指针回调同类型的不同函数，实现类似于事件回调机制的功能。先写一个简单的测试程序 编译后看看有什么结果pFunc1和pFunc2是没问题的，pFunc3 提示两个函数指针类型不匹配，因为pFunc3是 int（**）(int , int);pFunc4 其实是一个函数类型的对象，不予许赋值的。所以进行如下更改，并写出测试代码对于函数指针赋值的时候，可以直接用函数名字，也可以进行&amp;函数名赋值，综上所述，可以先定义一个函数类型typedef 函数返回类型 函数名 （函数形参1， 函数形参2，…）;之后用 函数名 * 函数指针;也可以 typedef 函数返回类型 (*函数指针类型名) （函数形参1，函数形参2,…）；之后用 函数指针类型名 函数指针；","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"stringstream使用方法","date":"2017-08-04T04:36:06.000Z","path":"2017/08/04/stringstream/","text":"C++ 有stringstream这个工具可以方便的进行数据类型的转换 使用时包含 #include &lt;sstream.h&gt; using namespace std; 当需要将一个整形的数转换为字符串 123456789stringstream mystream;int a = 100;mystream &lt;&lt; a;std::string numstr;mystream &gt;&gt; mumstr; 如果需要将一个字符串转化为整形数 再次使用mystream需要清除之前的状态位 调用 mystream.clear(); 并且字符串置空 mystream.str(“”); 这样就可以使用了。 1234567mystream.clear()mystream.str(&quot;&quot;);string strtest = &quot;1234&quot;;mystream &lt;&lt; strtest;int numconvert;mystream &gt;&gt; numconvert; 除此之外 stringstream可以连续将输入的内容输出到指定变量 123456789std::string str1 = &quot;1221&quot;;std::string str2 = &quot;12.34&quot;;std::string str3 = &quot;899&quot;;std::stringstream mystream;mystream &lt;&lt; str1 &lt;&lt; str2 &lt;&lt; str3;int num1, num3;double num2;mystream &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3; 大体上就是mystream常用的用法了。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"大根堆的原理与实现。","date":"2017-08-04T04:23:28.000Z","path":"2017/08/04/bigheap/","text":"大根堆的定义：1 大根堆是一个大根树2 大根堆是一个完全二叉树 所以大根堆用数组表示是连续的，不会出现空白字段。 对于大根堆的插入对于大根堆的插入，可以在排序前确定大根堆的形状，可以确定元素5从位置6插入，那么比较元素5和位置3的元素2， 元素5比元素2大，将2下移。接着比较元素5和元素20，一次类推，直到找到元素5的合理位置。 接着看一下如果插入的元素是21，怎么进行排序。 21比2大，所以将2下移，接着比较21和20，发现20比21小，20下移，最终21放到 根的位置。形成大根堆。 对于大根堆的删除大根堆删除根元素，那么可以确定删除后的形状。可以理解成将最后一个叶子节点放在 合理位置，首先比较叶子节点元素10和根节点的两个孩子15和2，选出两个节点中最大的 元素15,15比10大，所以15进行气泡。放到根节点。然后15所在的位置2,变为不确定的问号。 由于14比10大，那么14起泡放到位置2，根据大根堆的形状，最后将10放到左节点 将一个无序的完全二叉树变为大根堆将一个无序的完全二叉树变为大根堆(或者小根堆)，首先要找到最有一个叶子节点的父节点， 对该父节点为根节点的子树进行排序，生成一个大根堆(小根堆)。然后从节点位置依次 向前做同样的排序，将该节点到根节点的所有子树变为大根堆(小根堆)举例子：如上图所示，因为总共有6个节点，6/2 = 3,所以元素19的父节点是位置3的元素4， 将以4位根的子树变为大根堆。因为19比4大，所以19上移，4做叶子节点。依次类推， 从位置3到位置1的所有子树都按照这种逻辑处理，最终变成大根堆。 接着要处理位置2的子树，位置2的元素为1，两个节点为25和12，选最大的元素25，因为 25比1大，所以25进行上移，1变为叶子节点。这样位置2的子树就处理完了。 接着处理位置1，因为位置1的元素为6，两个节点分别为25和19，取最大节点元素25， 因为25比6大，所以25上移，而此时位置2还有两个节点元素1和元素12，需要比较元素6 和这两个节点中最大的，以确定大根堆。由于12比6大，所以12上移，6变为叶子节点。 最终用数组表示这个大根堆就是[25,12,19,1,6,4] 下面是代码实现和测试：大根堆的类结构：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;class T&gt;class maxHeap&#123;public: maxHeap(void) &#123; m_nHeapSize = 0; m_nHeapCapacity = 0; m_pHeapArray = NULL; &#125; maxHeap(const maxHeap&amp; tempHeap); maxHeap(T * heapArray, int arrayLen); ~maxHeap()&#123; if(m_pHeapArray) &#123; free(m_pHeapArray); &#125; m_pHeapArray = NULL; m_nHeapSize = 0; m_nHeapCapacity = 0; &#125; //插入节点 void insertNode(const T&amp; t); //pop堆顶元素 const T&amp; popRoot(); //打印自己的堆元素，用数组表示法输出 void printHeap(); //将一个无序的数组变为大根堆 void createMaxHeap(T * heapArray, int arrayLen); //销毁自己的堆元素 void deallocMaxHeap(); //打印数组的元素 void printHeap(T * heapArray, int arrayLen);private: //堆的数组元素，连续区间首地址 T* m_pHeapArray; //当前使用的大小 int m_nHeapSize; //堆的容量，实际开辟的大小 int m_nHeapCapacity;&#125;; 两个构造函数：1234567891011121314template &lt;class T&gt;maxHeap&lt;T&gt;::maxHeap(const maxHeap &amp;tempHeap)&#123; m_nHeapSize = tempHeap.m_nHeapSize; m_pHeapArray = malloc(sizeof(class maxHeap) *m_nHeapSize); m_nHeapCapacity = m_nHeapSize;&#125;template &lt;class T&gt;maxHeap&lt;T&gt;::maxHeap(T * heapArray, int arrayLen)&#123; m_nHeapSize = arrayLen; m_pHeapArray = malloc(sizeof(class maxHeap) * m_nHeapSize); m_nHeapCapacity = arrayLen;&#125; 插入节点1234567891011121314151617181920212223242526272829303132333435363738template &lt;class T&gt;void maxHeap&lt;T&gt;::insertNode(const T&amp; node)&#123; m_nHeapSize ++; if(m_nHeapSize &gt;= m_nHeapCapacity) &#123; m_pHeapArray = (T *)realloc(m_pHeapArray, sizeof(T) * m_nHeapSize *2); &#125; m_nHeapCapacity = m_nHeapSize*2; //当前节点所在位置 int currentIndex = m_nHeapSize; //该节点父节点所在位置 int parentIndex = currentIndex/2; //当前节点为根节点，跳出循环直接插入即可 while(currentIndex != 1) &#123; //父节点元素小于该node，因为是大根堆，所以父节点下移 if(m_pHeapArray[parentIndex -1] &lt; node) &#123; //父节点数据下移 m_pHeapArray[currentIndex - 1] = m_pHeapArray[parentIndex -1]; //更新当前节点位置，当前比较位置上移 currentIndex = currentIndex/2; //父节点位置同样上移 parentIndex = parentIndex/2; &#125; else &#123; break; &#125; &#125; //因为节点数是从1开始的，所以节点数-1表示数组中的位置 m_pHeapArray[currentIndex -1] = node; &#125; 打印元素123456789101112131415161718192021template &lt;class T&gt;void maxHeap&lt;T&gt;::printHeap()&#123; cout &lt;&lt;&quot;current max heap array is :&quot; &lt;&lt; endl; for(int i = 0; i &lt; m_nHeapSize; i++) &#123; cout &lt;&lt; m_pHeapArray[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;template &lt;class T&gt;void maxHeap&lt;T&gt;::printHeap(T * heapArray, int arrayLen)&#123; cout &lt;&lt;&quot;current max heap array is :&quot; &lt;&lt; endl; for(int i = 0; i &lt; arrayLen; i++) &#123; cout &lt;&lt; heapArray[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; pop堆顶的元素，取出最大值1234567891011121314151617181920212223242526272829303132333435363738394041template &lt;class T&gt;const T&amp; maxHeap&lt;T&gt;::popRoot()&#123; //先取出最后的叶子节点 const T&amp; lastEle = m_pHeapArray[m_nHeapSize-1]; //更新heapsize m_nHeapSize --; //删除时需要从根节点开始，找到最大值起泡 int currentIndex= 1; //当前节点的做孩子 int leftChild = currentIndex *2; //当前节点的孩子节点超过堆大小，说明该节点为叶子节点 while(leftChild &lt;= m_nHeapSize) &#123; int bigChild = leftChild; //取出两个孩子中大的孩子，然后将大的孩子节点数据上移 if(leftChild &lt; m_nHeapSize &amp;&amp; m_pHeapArray[leftChild-1] &lt; m_pHeapArray[leftChild]) &#123; //更新大孩子节点为右节点 bigChild = leftChild +1; &#125; //比较两个节点中大的孩子节点和取出的最后叶子节点，那个数值大 //如果最后的叶子节点数值大，那么可以跳出循环,因为找到了lastEle的合理位置 //剩余的树也是大根堆 if(m_pHeapArray[bigChild -1] &lt;= lastEle) &#123; break; &#125; //大节点数据上移 m_pHeapArray[currentIndex -1] = m_pHeapArray[bigChild-1]; //更新插入位置为当前大节点位置 currentIndex = bigChild; leftChild = currentIndex *2; &#125; m_pHeapArray[currentIndex-1] = lastEle; return lastEle;&#125; 将一个无序的数组元素，变为大根堆 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template &lt;class T&gt;void maxHeap&lt;T&gt;::createMaxHeap(T * heapArray, int arrayLen)&#123; //判断异常 if(arrayLen &lt;= 0 || heapArray == NULL) &#123; return ; &#125; //从最后一个叶子节点的父节点开始，依次从该位置到根节点 //例如该位置为3，那么位置3，位置2，位置1的根节点的子树依次处理为大根堆 int currentIndex = arrayLen; //父节点位置 int beginIndex = currentIndex/2; //依次处理，形成子树大根堆 for(int i = beginIndex; i &gt; 0; i--) &#123; int rootEle = heapArray[i-1]; int curNode = i; int leftChild = i *2; while(leftChild &lt;= arrayLen) &#123; int bigChild = leftChild; int rootElePrint = heapArray[leftChild-1]; int rightElePrint = heapArray[leftChild+1 -1] ; if(leftChild +1 &lt;= arrayLen &amp;&amp; heapArray[leftChild+1 -1] &gt; heapArray[leftChild-1]) &#123; bigChild = leftChild +1; &#125; if(heapArray[bigChild -1] &lt;= rootEle ) &#123; break; &#125; heapArray[curNode -1] = heapArray[bigChild -1]; curNode = bigChild; leftChild = curNode *2; &#125; heapArray[curNode -1] = rootEle; &#125; &#125; 源代码下载地址： http://download.csdn.net/detail/secondtonone1/9575112","categories":[{"name":"数据结构和算法","slug":"stl","permalink":"http://www.limerence2017.com/categories/stl/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++模板类注意事项","date":"2017-08-04T04:16:19.000Z","path":"2017/08/04/cpptemp/","text":"最近使用C++模板，虽然工作几年了，但是模板用的很少，确切的说自己实现的机会很小。 昨天写了一个代码maxheap.h 中实现了类模板的声明，我将实现写在maxheap.cpp中， 当在main.cpp中引用maxheap中的接口时，提示链接错误。网上提供了几个解决方案， 第一种方式是将maxheap.h和maxheap.cpp包含在某个.h文件中，这样在main函数中 包含这个.h即可。第二种方式叫分离模式，我没看，觉得没必要搞得那么复杂。第三种方式 是我最看好的方式，就是将模板类的实现也放在.h中。C++ stl模板就是在.h中实现的。 C++编译文件将.cpp编译为.o文件，在链接阶段将.o文件链接生成可执行文件。问题 就出现在模板实现的.cpp文件并不在编译时实例化，读者可以试着在模板实现的.cpp里 写一些错误的代码，编译器并没有监测到，`因为模板实现的cpp没有参与编译。他需要在特定类型 绑定后才会实例化，是延时的`。 编译器使用模板，通过更换模板参数来创建数据类型。这个过程就是模板实例化(Instantiation)。 从模板类创建得到的类型称之为特例(specialization)。 模板实例化取决于编译器能够找到可用代码来创建特例(称之为实例化要素， point of instantiation)。 要创建特例，编译器不但要看到模板的声明，还要看到模板的定义。 模板实例化过程是迟钝的，即只能用函数的定义来实现实例化。 `所以将类模板的实现文件放在.h里，main函数包含该.h文件，当main函数用到该模板的特例化时 通过该.h就可以找到所有模板的实例化了`。链接也没问题。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++ 局部静态变量，全局变量，全局静态变量，局部变量的区别和联系","date":"2017-08-04T04:07:00.000Z","path":"2017/08/04/cppvariable/","text":"C++变量根据定义位置的不同，具有不同的作用域，作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名作用域和文件作用域。 从作用域看： 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。 静态局部变量具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，即它的生命周期是程序运行就存在，程序结束就结束， 他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。也就是在别的函数访问这个变量是错误的。 局部变量也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。 生命周期在函数结束后就结束了，作用域也仅限于该函数。 静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。 这样即使两个不同的源文件都定义了相同的静态全局变量，他们也是不同的变量。 从分配内存空间看： 全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。 全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。 1、静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别，单例模式就是利用这个机制。 2、变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。 从以上分析可以看出，把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围， 因此static这个说明符在不同的地方起的作用是不同的。 TIPS： 1、若全局变量仅在单个文件中访问，则可以将这个变量修改为静态全局变量。 2、若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。 3、全局变量、静态局部变量、静态全局变量都存放在静态数据存储区。 4、函数中必须要使用static变量的情况：当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值， 因为他的生命周期是整个程序运行周期。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"TCP粘包处理","date":"2017-08-04T03:51:30.000Z","path":"2017/08/04/cpptcpnian/","text":"TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket， 因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块， 然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。 UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法， 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包， 在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 TCP粘包我总结了几种情况tcp发送端发送三个包过来，tcp接收缓存区收到了这三个包，而用户的读写缓存区比这三个包的总大小还大， 此时数据是接受完全的，用户缓存区读到三个包需要分开，这是比较好处理的。第二种情况是因为用户的接收缓存区比tcp接受缓存区大，或者比tcp目前接收到的总数据大，那么用户缓存区读到 的数据就是tcp接收缓存区的数据，这是第一种情况的特例，这种情况需要判断那些包接受完全，那些包没接受完全。第三种情况是用户的接受缓存区比tcp接受缓存区要小，导致用户缓存区读到的数据是tcp接收缓存区 的一部分，这其中有完整的包，也有残缺的包。第四种情况是第三种情况的一个特例，用户缓存区的数据是不完全的，只是tcp缓存区的一部分。 对应特别大的那种包。 我提倡的解决办法就是首先实现一套从tcp缓存区中读取数据的数据结构和算法，因为tcp是面向 字节流的，将tcp缓存区中的数据读到用户缓存区里，这里我简单叫做outstreambuffer和instreambuffer， 这两个结构一个用于向tcp写，一个用于从tcp读。把tcp缓存区的数据尽可能多的读出来，不要判断是否是 完整的包，保证tcp缓存区没数据，这样会减少tcp粘包几率。 第二部就是将读到的数据，也就是instreambuffer中的数据进行分割，我叫做切包，切出一个个完整的包， 剩余不完整的留着下次继续接收。 第三步服务器应用层接口从instreambuffer中读取切割好的完整的包进行逻辑处理。 所以为了处理粘包和切包，需要我们自己设计包头，我设计的包头是八字节的结构体， 包含四字节的包id和四字节的包长度，这个长度既可以表示包头+消息体的长度， 也可以表示后面消息体的长度。我设计的是表示后面消息体的长度。 而上面所说的instreambuffer和outstreambuffer用户可以自己设计实现，也可以 利用成熟的网络库，我用的是libevent中的bufferevent，bufferevent实现了类似 的instreambuffer和outstreambuffer。 我设计的服务器部分代码如下，感兴趣可以去git下载： https://github.com/secondtonone1/smartserver 简单列举下接收端处理读数据的过程。 1234void NetWorkSystem::tcpread_cb(struct bufferevent *bev, void *ctx)&#123; getSingleton().dealReadEvent(bev, ctx);&#125; networksystem是单例模式，处理读事件。因为静态函数tcpread_cb是libevent 设计格式的回调处理函数，在静态函数中调用非静态函数，我采用了单例调用。 1234567891011void NetWorkSystem::dealReadEvent(struct bufferevent *bev, void *ctx)&#123; // evutil_socket_t bufferfd = bufferevent_getfd(bev); std::map&lt;evutil_socket_t, TcpHandler *&gt;::iterator tcpHandlerIter = m_mapTcpHandlers.find(bufferfd); if(tcpHandlerIter != m_mapTcpHandlers.end()) &#123; tcpHandlerIter-&gt;second-&gt;dealReadEvent(); &#125;&#125; tcphandler是我设计的切包类，这里通过bufferfd找到对应的instream和outstream，从而处理里面的数据完成切包。 123456789101112131415161718192021222324252627282930313233343536373839404142//处理读事件void TcpHandler::dealReadEvent()&#123; evbuffer * inputBuf = bufferevent_get_input(m_pBufferevent); size_t inputLen = evbuffer_get_length(inputBuf); while(inputLen &gt; 0) &#123; //tcphandler第一次接收消息或者该node接收完消息，需要开辟新的node接受消息 if(!m_pLastNode || m_pLastNode-&gt;m_nMsgLen &lt;= m_pLastNode-&gt;m_nOffSet) &#123; //判断消息长度是否满足包头大小，不满足跳出 if(inputLen &lt; PACKETHEADLEN) &#123; break; &#125; char data[PACKETHEADLEN] = &#123;0&#125;; bufferevent_read(m_pBufferevent, data, PACKETHEADLEN); struct PacketHead packetHead; memcpy(&amp;packetHead, data, PACKETHEADLEN); cout &lt;&lt; &quot;packetId is : &quot; &lt;&lt;packetHead.packetID &lt;&lt; endl; cout &lt;&lt; &quot;packetLen is : &quot; &lt;&lt; packetHead.packetLen &lt;&lt; endl; insertNode(packetHead.packetID, packetHead.packetLen); inputLen -= PACKETHEADLEN; &#125; //考虑可能去包头后剩余的为0 if(inputLen &lt;= 0) &#123; break; &#125; //读取去除包头后剩余消息 tcpRead(inputLen); &#125;&#125; 这个函数判断是否读完一个消息，读完就开辟新的节点存储新来的消息，否则就将新来的消息放入没读完的节点里。 12345678910111213141516171819void TcpHandler::tcpRead(UInt32 &amp;inputLen)&#123; //node节点中的数据还有多少没读完 UInt32 remainLen = m_pLastNode-&gt;m_nMsgLen - m_pLastNode-&gt;m_nOffSet; UInt32 readLen = bufferevent_read(m_pBufferevent, m_pLastNode-&gt;m_pMsg + m_pLastNode-&gt;m_nOffSet, remainLen); //统计bufferevent 的inputbuffer中剩余的长度 inputLen -= readLen; //更改偏移标记 m_pLastNode-&gt;m_nOffSet += readLen; //判断读完 if(m_pLastNode-&gt;m_nOffSet &gt;= m_pLastNode-&gt;m_nMsgLen) &#123; m_pLastNode-&gt;m_pMsg[m_pLastNode-&gt;m_nMsgLen + 1] = &#x27;\\0&#x27;; cout &lt;&lt; &quot;receive msg is : &quot; &lt;&lt; m_pLastNode-&gt;m_pMsg &lt;&lt; endl; //cout &lt;&lt;&quot;read times is : &quot; &lt;&lt; ++readtimes&lt;&lt; endl; &#125;&#125; 我的服务器还在完善中，目前已经能处理连续收到1万个包的切包和大并发的问题了，最近在设计应用层的序列化 和应用层消息回调。感兴趣可以下载看看，下载地址：https://github.com/secondtonone1/smartserver","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++单例模式设计和实现","date":"2017-08-04T03:44:16.000Z","path":"2017/08/04/cppsingle/","text":"C++单例模式主要用途就是整个程序中只实例化一个对象，之后获取到的都是该对象本身进行处理问题。 单例模式一般都是在函数中采用局部静态变量完成的，因为局部的静态变量生命周期是随着程序的生命周期 一起结束，所以不用担心会失效。另外局部的静态变量作用域仅限于该函数内部，别的函数不会直接使用。 第三点就是局部的静态变量跟所有的静态变量一样，放在全局区(静态区)，只被初始化一次。 下面是我结合模板设计的单例类 1234567891011121314151617181920212223242526272829#ifndef _SINGLETON_CLASS_H_#define _SINGLETON_CLASS_H_template &lt;class Type&gt;class Singleton&#123;protected : Singleton()&#123;&#125;public: static Type &amp; getSingleton() &#123; return singleton; &#125;private: Singleton(const Singleton &amp; temp)&#123; singleton = temp.singleton; &#125;private: static Type singleton;&#125;;template &lt;class Type&gt;Type Singleton&lt;Type&gt;::singleton;#endif 其余的类继承就可以了。 需要注意类的静态成员变量，如果不是integer type，需要在类外完成初始化。 int属于integer type，在类内可以完成初始化。 其余的类继承该类： 1234567891011121314class NetWorkSystem : public Singleton&lt;NetWorkSystem&gt;&#123;public: NetWorkSystem():m_nListenfd(0),m_pEvent_base(NULL),m_nConnId(0)&#123;&#125; bool initial(); static void tcpread_cb(struct bufferevent *bev, void *ctx); static void tcpwrite_cb(struct bufferevent *bev, void *ctx); static void tcperror_cb(struct bufferevent *bev, short what, void *ctx); static void listener_read_cb(evutil_socket_t fd, short what, void *p); void run(); void release(); //... &#125;; 使用时使用getsinggleton这个函数即可。 这是我服务器中截取的代码，可以从github中下载该服务器源码。 下载地址：https://github.com/secondtonone1/smartserver 服务器自己做的，还在不断地完善之中。","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"Google protocol buffer的配置和使用(Linux&&Windows)","date":"2017-08-04T03:15:30.000Z","path":"2017/08/04/probuff/","text":"最近自己的服务器做到序列化这一步了，在网上看了下，序列化的工具有boost 和google的protocol buffer，protocol buffer的效率和使用程度更高效一些，就自己琢磨下把他加到自己的服务器里。所以这里我先弄一个小的demo去测试如何使用和配置protocol buffer。首先是windows 平台 windows下protocol buffer 配置： 下载protocol buffer， 去google官网或者其他渠道下载protocol buffer包 解压zip文件，进入vs文件夹编译protocol buffer，图示如下 工程下的几个项目都编译一遍，会生成几个lib在vs目录下的debug目录里能看到protoc.exe 和 libprotobuf.lib, libprotobuf-lite.lib , libprotoc.lib这几个lib是新生成的，先放一放，以后会用到。到此为止，google protocol buffer的配置和库已经生成，我们下一步设计自己的proto文件，并生成对应的pb.h和pb.cc 编写自己的proto 格式如下 123456789package smart;message test&#123; required string name = 1; required int32 age = 2; optional string email = 3; &#125; package 表示声明为包名，package smart;表示包名为smart, message test定义一个消息体，花括号结束不需要分号,括号内是成员变量，成员变量后面的数字默认从1开始，依次递增。 required表示这个字段必须有，optional表示字段可选，还有一些repeated表示可重复的值域，常用于数组。总结下：数据结构体： message message_name{message_body;} message_body格式： 例如 required int32 query = 1[defaut=10]; 形式为：rule type name = value[other_rule]; 规则： required表示必须具有该值域； optional表示可选的值域； repeated表示可重复的值域(即&gt;=0)； 其中requered/optional是常用rule，而repeated则不常用同时因为是历史遗留现使用repeated int32 samples=4[packed=true];形式； value值： value值最小为1，是底层编码时使用其中1-15占一位，&gt;15则会占多位； 不同的message中的value值互不干扰,常以1开始计数。 保存为包名.消息名.proto的形式，我保存为smart.msg.proto 接下来进行编译这个smart.msg.proto， protobuf提供了protoc命令 protoc –proto_path=(.proto文件路径) –cpp_out=(.cc .java生成文件路径) (.proto文件路径)/?.proto –proto_path 简化为: -I 其中可根据需要更改:cpp_out选项为java_out/python_out。 举例： protoc -I=./ –cpp_out=./ ./smart.msg.proto windows环境下打开cmd，进入到protocol buf vs目录里debug文件夹里调用protoc命令 我的proto放在D:\\win32projects\\protobuftest\\ProtoBuf目录，所以如下：进入D:\\win32projects\\protobuftest\\ProtoBuf下可看到新生成的文件到目前为止，准备工作都做完了，下一步建立自己的项目，使用这些.h和.cc 建立vs项目，我命名为protobuftest，在项目目录里建立Include和Lib，Protobuf 文件夹，将protobuff库的src文件夹拷贝到Include里，将libprotobuf.lib, libprotobuf-lite.lib , libprotoc.lib拷贝到Lib文件里，将smart.msg.proto拷贝到Protobuf中， 将protobuff库的那个debug也拷贝到Protobuf中，因为我想通过写一个批处理文件在该项目 里生成.h和.cc文件。 Lib文件夹: Include文件夹： Protobuf文件夹：bat如下： 123cd .\\Debugprotoc -I=..\\ --cpp_out=..\\ ..\\smart.msg.protopause 将ProtoBuf文件夹里的.h和.cc添加到项目里 配置项目属性C/C++ —-&gt; General —&gt; Additional Include Directories ..\\Include\\src Linker—&gt;General —-&gt; Additional Library Directories ..\\Lib 顺便把预编译也关了9. 项目配置好后写代码： 1234567891011121314151617181920212223242526272829303132#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &quot;../ProtoBuf/smart.msg.pb.h&quot;#pragma comment(lib, &quot;libprotobuf.lib&quot;) #pragma comment(lib, &quot;libprotoc.lib&quot;)int _tmain(int argc, _TCHAR* argv[])&#123; smart::test msg1; msg1.set_age(101); msg1.set_name(&quot;nice to meet you!&quot;); std::fstream out(&quot;User.pb&quot;, std::ios::out | std::ios::binary | std::ios::trunc); msg1.SerializeToOstream(&amp;out); out.close(); smart::test msg2; std::fstream in(&quot;User.pb&quot;, std::ios::in | std::ios::binary); if (!msg2.ParseFromIstream(&amp;in)) &#123; std::cerr &lt;&lt; &quot;Failed to parse User.pb.&quot; &lt;&lt; std::endl; exit(1); &#125; std::cout &lt;&lt; msg2.age() &lt;&lt; std::endl; std::cout &lt;&lt; msg2.name() &lt;&lt; std::endl; std::cout &lt;&lt; msg2.email() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;adfdf&quot; &lt;&lt;std::endl; getchar(); return 0;&#125; 测试输出到此为止windows环境配置和使用google protocol buffer已经解决。 Linux环境配置和使用： 解压编译配置，敲命令就可以了：123456unzip protobuf-2.6.1 cd protobuf-2.6.1 ./configure --prefix=/usr/local/protobuf-2.6.1 make make check make install 写proto文件和编译，跟上面的相同： 连带.cc文件一同编译，生成目标并执行，以后会写成makefile，这只是个测试程序，就简单测试下记得编译时带上-lpthread 和-lprotobuf如果运行时提示找不到libprotobuf9.so这个库，可以敲这个命令export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib到此为止就完成了google protobuf的 学习和配置","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"C++的一些注意事项","date":"2017-08-04T02:37:25.000Z","path":"2017/08/04/cppimportant/","text":"一. C++类的引用成员，类的常量成员，类的static成员的初始化方式类的引用成员和常量成员初始化放在初始化列表里，因为初始化只有一次，需要在构造函数之前进行初始化，写在类的构造函数会出错。类的static变量要放在类声明的外边定义，因为static变量属于整个类，而不是类对象，所以不能放在类的构造函数里。举个例子：一个类中既有常量成员也有引用成员 12345678910111213141516class MyClass&#123;public: MyClass(int value):a(1),b(a), m_nValue(value),c(m_nValue),d(m_nValue)&#123;&#125;public: const int a; const int &amp; b; int &amp; c; const int &amp;d; int m_nValue; static tms s; static double f;&#125;;tms MyClass::s;double MyClass::f = 0.33; 类的引用成员必须在类的初始化列表初始化，而且必须初始化，否则编译出错。类的static成员需要在类外定义，否则使用时会出错。类的常引用和引用的区别是 可以通过引用修改引用对象的数值，不可以通过常引用修改引用对象的数值 引用可以更改引用的对象，从而引用另一个变量，常引用是不能更改引用的对象的。 常引用可以引用非常量(变量)和常量以及右值，引用只能引用变量。 当常引用引用变量的时候，可以修改变量值，常引用的数值会随着改变，但是不能直接修改常引用。 下面是测试 二 类的常对象调用的接口必须都为常函数，很多人写法不注意编译会报错。代码示例为自己的一个项目，msgStream为常引用，那么他内部的列表返回的迭代器需要用const_iterator 12345678910111213MsgStream( const MsgStream &amp; msgStream)&#123; m_nCount = msgStream.m_nCount; msgStream.m_listConMsg.begin(); for(std::list&lt;ConMsgNode&gt;::const_iterator msgIter = msgStream.m_listConMsg.begin(); msgIter != msgStream.m_listConMsg.end(); msgIter++ ) &#123; m_listConMsg.push_back(*msgIter); &#125; &#125; msgStream 这个常引用也只能调用常量成员函数， 函数体后有const声明的函数 三析构函数的顺序，构造函数的顺序 当类子类中包含其他的类，构造的顺序是先构造基类对象，然后构造子类包含的类对象，最后构造子类对象。 当基类中包含其他的类，构造的顺序是先构造基类中包含的类对象，然后构造基类对象，最后构造子类对象。 当类子类中包含其他的类，析构的顺序是先构子类对象，然后析构子类包含的其他类对象，最后析构基类。 当基类中包含其他的类，析构的顺序是先析构子类对象，然后析构基类对象，最后析构基类中其他对象。 123456789101112131415161718192021222324252627282930class c&#123;public: c()&#123; printf(&quot;c\\n&quot;); &#125;protected:private:&#125;;class b &#123;public: b()&#123; printf(&quot;b\\n&quot;);&#125;protected: c C;private:&#125;;class a : public b&#123;public: a()&#123; printf(&quot;a\\n&quot;); &#125;protected:private:&#125;;int main()&#123; a A; getchar();&#125; 结果： 123456789101112131415161718192021222324252627282930class c&#123;public: c()&#123; printf(&quot;c\\n&quot;); &#125;protected:private:&#125;;class b &#123;public: b()&#123; printf(&quot;b\\n&quot;);&#125;protected:private:&#125;;class a : public b&#123;public: a()&#123; printf(&quot;a\\n&quot;); &#125;protected: c C;private:&#125;;int main()&#123; a A; getchar();&#125; 结果： 123456789101112131415161718192021222324252627282930313233class c&#123;public: c()&#123;&#125; ~c()&#123; printf(&quot;c\\n&quot;); &#125;protected:private:&#125;;class b &#123;public: b()&#123;&#125; ~b()&#123; printf(&quot;b\\n&quot;);&#125;protected:private:&#125;;class a : public b&#123;public: a()&#123;&#125; ~a()&#123; printf(&quot;a\\n&quot;); &#125;protected: c C;private:&#125;;int main()&#123; a A; return 0;&#125; 结果： 四 list 直接赋值给另外一个list，并不会导致list元素的深拷贝，两个list中的元素是同一份数据","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]},{"title":"windows多线程接口介绍和使用","date":"2017-08-03T12:47:18.000Z","path":"2017/08/03/winmulthread/","text":"一windows多线程接口：1 创建线程CreateThread 与 _beginthreadex都可以实现创建线程，两个函数的参数相同， 12345678 HANDLEWINAPICreateThread( LPSECURITY_ATTRIBUTESlpThreadAttributes, SIZE_TdwStackSize, LPTHREAD_START_ROUTINElpStartAddress, LPVOIDlpParameter, DWORDdwCreationFlags, LPDWORDlpThreadId); 函数说明： 第一个参数表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。 第二个参数表示线程栈空间大小。传入0表示使用默认大小（1MB）。 第三个参数表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。 第四个参数是传给线程函数的参数。 第五个参数指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。 第六个参数将返回线程的ID号，传入NULL表示不需要返回该线程ID号。 函数返回值： 成功返回新线程的句柄，失败返回NULL。 CreateThread 与 _beginthreadex的区别是_beginthreadex更安全一些，_beginthreadex会为每个线程分配一些独立的数据块，这个独立的数据块用于保存线程独有的信息，因 为在调用C的标准库时，有些函数是返回的是全局信息，这个全局信息容易被多线程干扰，_beginthreadex会规避这个问题。 2线程等待函数WaitForSingleObject，WaitForSingleObject这个函数使线程等待某个特定的对象，使线程进入等待状态，直到指定的内核对象被触发。 DWORDWINAPIWaitForSingleObject( HANDLEhHandle, DWORDdwMilliseconds); 函数说明： 第一个参数为要等待的内核对象。 第二个参数为最长等待的时间，以毫秒为单位，如传入5000就表示5秒，传入0就立即返回，传入INFINITE表示无限等待。 因为线程的句柄在线程运行时是未触发的，线程结束运行，句柄处于触发状态。所以可以用WaitForSingleObject()来等待一个线程结束运行。函数返回值：在指定的时间内对象被触发，函数返回WAIT_OBJECT_0。超过最长等待时间对象仍未被触发返回WAIT_TIMEOUT。传入参数有错误将返回WAIT_FAILED 具体的使用 可以从我自己做的服务器里截取一部分代码看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344void BaseThread::startup(UInt32 stackSize)&#123; assert(m_nId == 0); #if defined _WIN32 m_hThread =(HANDLE) _beginthreadex(NULL,0,threadFunc, this, 0, &amp;m_nId); //cout &lt;&lt; this &lt;&lt;endl; ::SetThreadPriority(::GetCurrentThread(), 2); //让线程跑起来后再退出函数 // Sleep(1000); #endif&#125;void BaseThread::join()&#123; #if defined _WIN32 DWORD exitCode; while(1) &#123; if(GetExitCodeThread(m_hThread, &amp;exitCode) != 0) &#123; if(exitCode != STILL_ACTIVE) &#123; break; &#125; else &#123; // wait之前， 需要唤起线程， 防止线程处于挂起状态导致死等 ResumeThread(m_hThread); WaitForSingleObject(m_hThread, INFINITE); &#125; &#125; else &#123; break; &#125; &#125; CloseHandle(m_hThread); #endif m_nId = 0;&#125;","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Windows互斥锁demo和分析","date":"2017-08-03T12:36:08.000Z","path":"2017/08/03/winmutexdemo/","text":"一：windows创建锁接口创建互斥锁的方法是调用函数CreateMutex 12345HANDLE CreateMutex(LPSECURITY_ATTRIBUTESlpMutexAttributes, // 指向安全属性的指针BOOLbInitialOwner, // 初始化互斥对象的所有者LPCTSTRlpName // 指向互斥对象名的指针); 第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例子： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr); 二：windows持有锁接口：DWORD WaitForSingleObject( HANDLE hHandle,DWORD dwMilliseconds); 这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。 三：释放锁BOOL WINAPI ReleaseMutex(HANDLE hMutex); 四：销毁BOOL CloseHandle(HANDLE hObject); 下面是网上的一个案例，根据我自己做服务器的需求，模仿者写了一个： ‘’’ cpp//各种类型的锁的基类class BaseLock{public: BaseLock(){} virtual ~BaseLock(){} virtual void lock() const = 0 ; virtual void unlock() const = 0 ;}; //互斥锁继承基类class Mutex :public BaseLock{public: Mutex(); ~Mutex(); virtual void lock() const; virtual void unlock() const;private:#if defined _WIN32 HANDLE m_hMutex;#endif}; //互斥锁实现文件： //在构造函数里创建锁Mutex::Mutex(){ #if defined _WIN32 m_hMutex = ::CreateMutex(NULL, FALSE, NULL); #endif} //析构函数里销毁锁Mutex::~ Mutex(){ #if defined _WIN32 ::CloseHandle(m_hMutex); #endif} //互斥锁上锁void Mutex::lock() const{ #if defined _WIN32 DWORD d = WaitForSingleObject(m_hMutex, INFINITE); #endif} //互斥锁解锁void Mutex::unlock() const{ #if defined _WIN32 ::ReleaseMutex(m_hMutex); #endif} class CLock{public: CLock(const BaseLock &amp; baseLock):m_cBaseLock(baseLock){ //构造函数里通过基类锁调用加锁函数(多态) m_cBaseLock.lock(); } ~CLock(){ //析构函数先解锁 m_cBaseLock.unlock(); }private: //常引用变量，需要在初始化列表初始 //多态机制 const BaseLock&amp; m_cBaseLock;};‘’’ CLock是留给外界使用的接口类，可以实现自动加锁和解锁。构造函数传入不同类型的锁，目前只实现了互斥锁，通过基类类型的引用成员可以实现多态调用不同的lock和unlock，而CLock析构函数因为会调用基类的unlock，从而实现不同类型的解锁。那么读者可能会有疑问互斥锁什么时候会销毁？互斥锁的销毁写在互斥锁类的析构函数里，当调用互斥锁的析构函数就会自动销毁这把锁了。什么时候调用互斥锁的析构函数呢？之前有介绍过，析构函数的调用顺序，先析构子类对象，然后析构子类对象中包含的其他类型的对象，最后析构基类对象，所以整个流程是先调用Mutex的构造函数，将Mutex构造的对象传入CLock的构造函数，这样实现自动加锁，当CLock析构的时候先析构CLock对象，之后析构CLock类里的BaseLock对象，因为是多态，会自动根据虚析构函数调用子类也就是MutexLock的析构函数，完成销毁锁的操作。 下面是我服务器中的一段代码截取，算是这个锁的示例 123456789void NetWorker::pushNodeInStream(TcpHandler * tcpHandler)&#123; //加锁处理消息加入到instream里 Mutex mutexlock; CLock mylock(mutexlock); list&lt;MsgNode *&gt; * msgList = tcpHandler-&gt;getListMsgs();&#125; 因为函数&#125;会释放局部变量，那么就会调用CLock析构函数，接着调用Mutex析构函数。依次完成解锁和销毁锁的操作。我的服务器还在制作当中，基本框架制作完毕会做一些服务器设计的研究。","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"windows环境利用semophore机制进行线程同步","date":"2017-08-03T10:23:28.000Z","path":"2017/08/03/winsemphore/","text":"semophore是信号量的意思，常用于PV操作，所谓PV操作就是pend(等待，直到有资源可用，并且消耗资源)V就是释放资源。semophore和mutex区别，mutex本意为互斥，用于线程独占资源，常用于临界区访问锁住mutex，当线程A对mutex加锁后，其他线程不能反问临界资源，也不能加锁，直到线程A解锁，其他线程才能访问。而semophore则可以在不同的线程之间进行pv操作，semophore可以设置最多有多少个信号量，以及初始的信号量，当调用V操作的时候信号量数量增加一个，调用P操作时候信号量数量减少一个，但是不能超过最多的信号量。信号量是一个非负数。打个比方，一辆车只有一把钥匙，mutex就是这把钥匙，谁有这把钥匙才能开车，开完车把钥匙归还或者给下一个等待的人。现在有一辆公交车，最多容纳二十个人，二十就是信号量的最大值，每个人就是一个信号量，当人满的时候其他的人就不能上车，直到有人下车，其他人才能上车。 semophore主要适用于windows环境下的同步 下面介绍下semophore1 创建信号量1234567891011HANDLE WINAPI CreateSemaphore( _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes _In_ LONG lInitialCount, _In_ LONG lMaximumCount, _In_opt_ LPCTSTR lpName ); 第一个参数：安全属性，如果为NULL则是默认安全属性 第二个参数：信号量的初始值，要&gt;=0且&lt;=第三个参数 第三个参数：信号量的最大值 第四个参数：信号量的名称 返回值：指向信号量的句柄，如果创建的信号量和已有的信号量重名，那么返回已经存在的信号量句柄 2打开其他进程中的信号量12345HANDLE WINAPI OpenSemaphore( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCTSTR lpName ); dwDesiredAccess：指定想要的访问权限，SEMAPHORE_ALL_ACCESS 请求对事件对象的完全访问，SEMAPHORE_MODIFY_STATE 修改状态权限，使用ReleaseSemaphore函数需要该权限；bInheritHandle：是否希望子进程继承信号量对象的句柄，一般设置为false；lpName：要打开的信号量对象的名称； 3等待信号量1234DWORD WINAPI WaitForSingleObject( _In_ HANDLE hHandle, _In_ DWORD dwMilliseconds ); hHandle：指向内核对象的句柄；dwMilliseconds：线程最大等待多长时间，直到该对象被触发。经常使用INFINITE，表示阻塞等待。WaitForSingleObject为等待资源的函数，等待内核对象被触发的通用函数，在这里用于等待信号量，我们之前说过信号量的资源数是非负整数，当信号量数量大于0，那么该函数会将信号量-1，并且返回，线程继续执行后续操作。如果信号量资源数为0，那么该线程处于等待状态，阻塞等待信号量被激活。 4 释放信号量12345BOOL WINAPI ReleaseSemaphore( _In_ HANDLE hSemaphore, _In_ LONG lReleaseCount, _Out_opt_ LPLONG lpPreviousCount ); hSemaphore：信号量内核对象的句柄；lReleaseCount：释放自己使用的资源数目，加到信号量的当前资源计数上，通常会传1，当然是根据线程使用的资源数目而定。lpPreviousCount：返回当前资源计数的原始值，应用程序很少会用到这个值，所以一般置为NULL；当一个线程使用完信号量对象控制的有限资源后，应该调用ReleaseSemaphore，释放使用的资源，使信号量对象的当前资源计数得到恢复。 5关闭内核对象的句柄123BOOL WINAPI CloseHandle( _In_ HANDLE hObject ); hObject：指向内核对象的句柄和其他内核对象一样，无论以什么方式创建内核对象，我们都必须通过调用CloseHandle向系统表明结束使用内核对象。如果传入的句柄有效，系统将获得内核对象数据结构的地址，并将结构中的使用计数减1，如果使用计数0，就会将内核对象销毁，从内存空间中擦除。下面写一个例子，三个线程，分别为如数1,2,3，要求每个线程输出10此，以1,2,3分别输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//先定义三个信号量句柄：HANDLE hsem1,hsem2,hsem3; //线程回调函数：unsigned __stdcall threadFunA(void *)&#123; for(int i = 0; i &lt; 10; i++)&#123; WaitForSingleObject(hsem1, INFINITE);//等待信号量 cout&lt;&lt;&quot;first thread function&quot;&lt;&lt;endl; ReleaseSemaphore(hsem2, 1, NULL);//释放信号量2 &#125; return 1;&#125;//该函数内部调用等待第一个信号量，如果获得资源，则打印日志，并且释放资源2//同样的道理，完成第二个，第三个线程回调函数unsigned __stdcall threadFunB(void *)&#123; for(int i = 0; i &lt; 10; i++)&#123; WaitForSingleObject(hsem2, INFINITE);//等待信号量 cout&lt;&lt;&quot;second thread function&quot;&lt;&lt;endl; ReleaseSemaphore(hsem3, 1, NULL);//释放信号量3 &#125; return 2;&#125; unsigned __stdcall threadFunC(void *) &#123; for(int i = 0; i &lt; 10; i++)&#123; WaitForSingleObject(hsem3, INFINITE);//等待信号量 cout&lt;&lt;&quot;third thread function&quot;&lt;&lt;endl; ReleaseSemaphore(hsem1, 1, NULL);//释放信号量 &#125; return 3; &#125;//接下来在主函数创建三个线程，并且初始化第一个信号量的初始资源数为1，//第二个和第三个信号量初始资源数都是0，他们的最大资源数为1.//创建信号量 hsem1 = CreateSemaphore(NULL, 1, 1, NULL); hsem2 = CreateSemaphore(NULL, 0, 1, NULL); hsem3 = CreateSemaphore(NULL, 0, 1, NULL); HANDLE hth1, hth2, hth3; //创建线程 hth1 = (HANDLE)_beginthreadex(NULL, 0, threadFunA, NULL, 0, NULL); hth2 = (HANDLE)_beginthreadex(NULL, 0, threadFunB, NULL, 0, NULL); hth3 = (HANDLE)_beginthreadex(NULL, 0, threadFunC, NULL, 0, NULL); //当线程调用完回调函数才能让主线程退出，linux系统对应的api为pthread_join()，//我们这里windows api为 WaitForSingleObject//等待子线程结束 WaitForSingleObject(hth1, INFINITE); WaitForSingleObject(hth2, INFINITE); WaitForSingleObject(hth3, INFINITE); //最后释放线程的句柄和信号量的句柄 //一定要记得关闭线程句柄 CloseHandle(hth1); CloseHandle(hth2); CloseHandle(hth3); CloseHandle(hsem1); CloseHandle(hsem2); CloseHandle(hsem3); 打印输出如下：结果显示三个线程是按顺序输出的。所以信号量常用来同步线程。源代码下载地址：semophore测试","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"windows环境下封装条件wait和signal","date":"2017-08-03T09:46:34.000Z","path":"2017/08/03/winsignal/","text":"linux 环境有提供好的pthread_cond_wait() 和 phread_signal()、pthread_broadcast()windows需要自己封装，利用semophore控制线程等待和释放，先简单谈一下设计好后api该如何使用。假设我们封装好条件变量等待函数名字叫做wait(Mutex&amp; mutex)，Mutex是之前我们封装的条件变量，文章最下边会给出这些文件的下载地址，在这里读者当做linux 的mutex即可。我们封装的释放函数为signal(),广播函数为broadcast。 判断等待条件变量和逻辑处理如下： 12345678910111213Lock(mutex);while(条件不满足)&#123; wait(mutex);&#125;todo...;UnLock(mutex); 激活条件变量如下： 123456789101112131415Lock(mutex); todo ...; if(条件满足) &#123; signal();/broadcast(); &#125; signal();UnLock(mutex); Condition 是我们封装的条件变量类这是封装好api后调用规则，那么先考虑wait内部的基本形式 1234567891011121314151617181920212223void Condition::wait(Mutex &amp;mutex)&#123; //1 Condition 类中表示阻塞线程数 mblocked ++; //2 解锁，释放互斥量 UnLock(mutex); //3 阻塞等待 mQueue为信号量 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); //4 做一些判断和逻辑处理 //5 加锁 Lock(mutex);&#125; wait内部记录一个阻塞的线程数mblocked，mblocked 是我们封装Condition类的成员变量，然后释放外部的互斥量，然后调用阻塞函数，等待signal唤醒。当WaitForSingleObject获取信号后会继续执行，做一些逻辑判断，最后将mutex锁住。这里用到的mQueue是一个信号量，用信号量可以接受多个唤醒和控制线程唤醒数量。下面是条件变量释放的函数，我们先做只是放一个条件变量的api 123456789101112131415161718192021222324void Condition::signal()&#123; //1阻塞的线程减少 mblocked --; //2将激活的信号个数设置为1 signals = 1; //3 if (signals) &#123; //释放信号量 res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;&#125; 先不要着急往下写，考虑下这么做真的合适么？首先之前设计过外部调用 1234567if(条件满足) &#123; signal();/broadcast(); &#125; 这个只要条件满足就可以激活，所以我们只用mblocked表示阻塞线程数是不够的，当信号量被激活很多没有被消耗的情况下就需要统计当前可用的资源数，那么就在Condition类添加mWait表示当前可用的信号量个数。除此之外，考虑这样一种情况，当条件不满足的时候 线程A调用void wait(Mutex &amp;mutex)函数，wait函数先解锁再阻塞，对应wait中第2,3步骤。而另一个线程B当条件满足时调用 signal函数激活之前阻塞的线程A，对应signal函数中第3步。原阻塞线程A因为捕获到信号量，所以一次走到wait中第4、5步。由于第4和第5步之间没有加锁保护，所以这一阶段用到的类的成员变量都是不安全的。所以在第3和第4之间加一个互斥锁，第5步之后释放这个互斥锁。同样的道理，为了避免此时signal内部调用类的成员变量造成数据不一致所以signal内部也需要加锁，在signal内部第1步之前加锁，第3步之后解锁，或者第3步之前解锁都可以。我觉得在第三步之前释放会好一些，在释放信号量之前解锁，避免死锁。所以添加一个成员变量mMutex用于部分代码互斥。那么改良后我们的函数如下： 12345678910111213141516171819202122232425262728voidCondition::wait(Mutex&amp; mutex)&#123; #ifndef WIN32 int ret = pthread_cond_wait(&amp;mId, mutex.getId()); ASSERT(ret == 0); #else //1 mBlocked++;&lt;br&gt; //2 mutex.unlock(); int res = 0;&lt;br&gt; //3 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); //用于暂时存储mWaiting的数值 unsigned wasWaiting = 0; //4 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); wasWaiting = mWaiting; //5 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //6 mutex.lock();#endif&#125; 步骤也做了相应的调整。 1234567891011121314151617181920212223242526272829303132333435363738394041424344voidCondition::signal ()&#123;#ifndef WIN32 int ret = pthread_cond_signal(&amp;mId); ASSERT(ret == 0);#else unsigned signals = 0; int res = 0; //1 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); //2 if (mWaiting != 0) &#123; if (mBlocked == 0) &#123; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); return; &#125; ++mWaiting; --mBlocked; signals = 1; &#125; else &#123; signals = mWaiting = 1; --mBlocked; &#125; //3 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //4 if (signals) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;#endif&#125; 改良后更新了步骤，注释的就是步骤，方便接下来讨论这两段代码的隐患，因为仅仅这些还不够。目前现总结下mMutex作用： 1 mMutex用于signal函数内部和wait函数 获取信号量之后的代码互斥，保护类的常用变量。 2 当不同的线程调用wait等待后获得激活时，mMutex保证获得信号量之后的操作是互斥的，安全的。 由于调用wait函数之前需要加外部的互斥锁，所以不同的线程调用wai函数时第一步的mBlocked++是互斥的，不会出错。 唯一有可能出错的是那种情况呢？ 就是当signal发出信号后，当前有一个因为调用wait阻塞的线程A捕获到该信号，进入第四步，修改或者访问mBlocked变量的值，与此同时有线程A调用wait函数，此时会进入wait内部第一步mBlocked++，多线程修改和读取mBlocked会造成数据混乱，所以此时需要在第一步之前加锁，第2步之前解锁，因此添加单个信号量mGate，用于控制当有线程处于解锁状态处理mBlocked等类成员时，其他线程进入wait修改mBlocked值。这个res = WaitForSingleObject(reinterpret_cast(mGate), INFINITE);可以放在wait函数第4步之后，当第4步获得互斥资源后，阻塞等待获取mGate信号，如果没获得需要等待别的线程释放mGate，如果此时mGate不被释放造成mMutex死锁。所以别的线程中先调用 WaitForSingleObject(reinterpret_cast(mGate), INFINITE);后调用WaitForSingleObject mMutex会造成死锁。需要特别注意。如果规避了这一点，那么就可以避免死锁。所有情况都对mGate互斥访问并不友好，出现之前讨论的情况只有一种：就是当前应用程序中至少有一个线程处于等待，而signal释放信号后，某一个等待的线程继续执行4后面的操作，外界有新的线程调用wait时修改mBlocked会出错。所以只需要在signal函数中判断当mWaiting数量为0时对mGate加锁，mWait根据不同情况进行对mGate进行释放。修改后的代码如下： 12345678910voidCondition::enterWait ()&#123; int res = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); ++mBlocked; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res);&#125; 对mBlocked起到保护作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647voidCondition::wait(Mutex&amp; mutex)&#123;#ifndef WIN32 int ret = pthread_cond_wait(&amp;mId, mutex.getId()); ASSERT(ret == 0);#else //1 enterWait(); //2 mutex.unlock(); int res = 0; //3 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); unsigned wasWaiting = 0; unsigned wasGone = 0; //4 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); wasWaiting = mWaiting; wasGone = mGone; //signal释放资源后，mWaiting 至少为1 if (wasWaiting != 0) &#123; //判断mWaiting 数量为1 if (--mWaiting == 0) &#123; //如果当前没有阻塞线程则释放mGate if (mBlocked != 0) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); // open mGate ASSERT(res); wasWaiting = 0; &#125; &#125; &#125; //5 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //6 mutex.lock();#endif&#125; 对应的signal函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960voidCondition::signal ()&#123;#ifndef WIN32 int ret = pthread_cond_signal(&amp;mId); ASSERT(ret == 0);#else unsigned signals = 0; int res = 0; //1 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); if (mWaiting != 0) &#123; //当前有空闲的信号量并且没由阻塞的线程 if (mBlocked == 0) &#123; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); return; &#125; //如果由阻塞的线程，那么阻塞数量-- ++mWaiting; --mBlocked; signals = 1; &#125; else &#123; //2当空闲的信号量为0时，互斥获得mGate res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); //3 if (mBlocked ) &#123; //如果当前有线程阻塞那么更新计数 signals = mWaiting = 1; --mBlocked; &#125; else &#123; //由于用户外部不判断条件是否成立多次调动signal，此处不处理直接释放mGate res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); &#125; &#125; //4 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //5 if (signals) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;#endif&#125; 到目前为止，对于共享对象的保护和同步都做的比较完善了，还要注意一个问题就是虚假唤醒。这是操作系统可能出现的一种情况，所以需要添加虚假唤醒的逻辑用mGone成员变量表示出错的或是虚假唤醒的线程数最终代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364voidCondition::wait(Mutex&amp; mutex)&#123;#ifndef WIN32 int ret = pthread_cond_wait(&amp;mId, mutex.getId()); ASSERT(ret == 0);#else enterWait(); mutex.unlock(); int res = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); unsigned wasWaiting = 0; unsigned wasGone = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); wasWaiting = mWaiting; wasGone = mGone; if (wasWaiting != 0) &#123; if (--mWaiting == 0) &#123; if (mBlocked != 0) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); // open mGate ASSERT(res); wasWaiting = 0; &#125; else if (mGone != 0) &#123; mGone = 0; &#125; &#125; &#125; else if (++mGone == (ULONG_MAX / 2)) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); mBlocked -= mGone; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); mGone = 0; &#125; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); if (wasWaiting == 1) &#123; for (; wasGone; --wasGone) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); &#125; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); &#125; mutex.lock();#endif&#125; wait部分添加了mGone的处理，当mWaiting数量为0进入res = WaitForSingleObject(reinterpret_cast(mMutex), INFINITE);需要对mGone++表示虚假唤醒的线程数量 123456789if (++mGone == (ULONG_MAX / 2)) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); mBlocked -= mGone; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); mGone = 0; &#125; 通过mGate对mBlocked保护起来，当唤醒的个数超过指定值会把多余的mblocked去掉并且把虚假唤醒数量置空。举个例子，当mBLocked为1时该线程被虚假唤醒，那么mGone变为1，由于是虚假唤醒，用户在外部调用wait函数时通过while循环判断条件不满足再次进入wait中enterGate函数对mBlocked自增，此时mBlocked数量为2，所以当冗余的mBlocked超过指定值，就回去掉这些mBlocked并将mGone置空。 12345678910if (wasWaiting == 1)&#123; for (; wasGone; --wasGone) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); &#125; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res);&#125; 该函数判断Condation类的mWating变量有1变为0，并且阻塞的线程数为0，因为如果用户没有在外边调用while判断条件导致虚假唤醒引起逻辑错误，所以为了起到保护作用对那些因为虚假唤醒错过的信号进行资源占用，直到信号量都被释放后才进入mGate释放。举一个例子如果外部调用 123456789Lock(mutex);if(条件不满足)&#123; wait(mutex); &#125;//逻辑处理 ...UnLock(mutex); 当wait执行退出后会执行逻辑，而没有while判断条件是否真的满足。所以我们要对信号量进行控制，保证信号量数量正确。并且和mBlocked，mWait,等一致。下面是signal函数最终版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657voidCondition::signal ()&#123;#ifndef WIN32 int ret = pthread_cond_signal(&amp;mId); ASSERT(ret == 0);#else unsigned signals = 0; int res = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); if (mWaiting != 0) &#123; if (mBlocked == 0) &#123; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); return; &#125; ++mWaiting; --mBlocked; signals = 1; &#125; else &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); if (mBlocked &gt; mGone) &#123; if (mGone != 0) &#123; mBlocked -= mGone; mGone = 0; &#125; signals = mWaiting = 1; --mBlocked; &#125; else &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); &#125; &#125; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); if (signals) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;#endif&#125; 同样的道理 12345678910if (mBlocked &gt; mGone) &#123; if (mGone != 0) &#123; mBlocked -= mGone; mGone = 0; &#125; signals = mWaiting = 1; --mBlocked;&#125; 这个逻辑就是处理当虚假唤醒的mBlocked和mGone等数据准确性。因为如果是虚假唤醒，用户通过while(条件不满足)这个方式继续调用wait会导致mBlocked++，假设就一个线程处于阻塞并且因为虚假唤醒通过while循环重新调用wait函数，而此时mGone比mBlocked小1，所以mBlocked - mGone就是更新差值给mBlocked，这是真正的处于阻塞的线程数量。 下面是代码下载地址：betternet 代码效果测试截图：","categories":[{"name":"网络编程","slug":"netprogram","permalink":"http://www.limerence2017.com/categories/netprogram/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"}]},{"title":"C++类成员空间分配和虚函数表","date":"2017-08-03T06:46:34.000Z","path":"2017/08/03/cppvirtual/","text":"最近在自学python，看到继承和类，就顺便复习了C++的类和继承等方面的知识。先看Base基类 123456789101112131415161718class Base &#123;private: virtual void display() &#123; cout&lt;&lt;&quot;Base display()&quot;&lt;&lt;endl; &#125; void say()&#123; cout&lt;&lt;&quot;Base say()&quot;&lt;&lt;endl; &#125;public: virtual void func()&#123;cout &lt;&lt; &quot;Base func()&quot; &lt;&lt; endl; &#125; void exec()&#123; display(); say(); &#125; void f1(string a) &#123; cout&lt;&lt;&quot;Base f1(string)&quot;&lt;&lt;endl; &#125; void f1(int a) &#123; cout&lt;&lt;&quot;Base f1(int)&quot;&lt;&lt;endl; &#125; //overload&#125;; Base类中定义私有的虚函数display， 普通成员函数say，公共的虚函数func， 普通的成员函数exec，重载了f1函数。下面是DeriveA类，继承于Base类 12345678910111213class DeriveA:public Base&#123;public: void display() &#123; cout&lt;&lt;&quot;DeriveA display()&quot;&lt;&lt;endl; &#125; //override void f1(int a,int b) &#123; cout&lt;&lt;&quot;DeriveA f1(int,int)&quot;&lt;&lt;endl; &#125; //redefining void say() &#123; cout&lt;&lt;&quot;DeriveA say()&quot;&lt;&lt;endl; &#125; //redefining virtual void func()&#123;cout &lt;&lt; &quot;DeriveA func()&quot; &lt;&lt; endl; &#125;&#125;; DeriveA类继承了Base类，重写(覆盖)了虚函数display和func，并且将display权限修改为public。重定义了f1函数和say函数，但是修改了f1的参数列表。下面是基础的几个测试 1234567DeriveA a;Base *b=&amp;a; b-&gt;func(); a.func(); b-&gt;f1(&quot;abc&quot;); b-&gt;f1(3); a.f1(3,5); 输出结果:func函数在Base类中为虚函数，DeriveA继承Base后，根据多态机制实现了动态调用。所谓多态机制就是用基类指针指向子类对象，基类指针调用虚函数func，会动态调用实际的子类对象的func函数。由于display函数在Base类中为虚函数，所以不可以通过b-&gt;display()调用。由于DeriveA重新定义(redefining)了f1函数，f1函数参数类型修改了，所以只能使用a.f1(int,int)这种调用，而采用a.f1(string)或者采用a.f1(int)这种调用都会出错，编译阶段就会出错。因为DeriveA类对f1重新定义了，基类的f1函数不可通过对象直接调用。同样的道理对于基类指针或对象，无论基类指针指向子类还是基类对象，调用f1只能调用基类定义的两个f1(int)， f1(string)两个函数，如果采用b-&gt;f1(3,5)，编译器在编译阶段就会提出错误。想实现子类对象调用基类的函数可在函数体内加上作用于Base::函数名(参数，…)DeriveA类修改f1函数，先调用基类的f1在调用自己的f1 123456789101112131415161718class DeriveA:public Base&#123;public: void display() &#123; cout&lt;&lt;&quot;DeriveA display()&quot;&lt;&lt;endl; &#125; //override void f1(int a,int b) &#123; Base::f1(2); Base::f1(&quot;test&quot;); cout&lt;&lt;&quot;DeriveA f1(int,int)&quot;&lt;&lt;endl; &#125; //redefining void say() &#123; cout&lt;&lt;&quot;DeriveA say()&quot;&lt;&lt;endl; &#125; //redefining virtual void func()&#123; cout &lt;&lt; &quot;DeriveA func()&quot; &lt;&lt; endl; &#125;&#125;; 打印输出a.f1(3,5);结果如下：先调用了基类的两个f1函数，之后调用DeriveA的f1函数下面调用如下函数b-&gt;exec();a.exec();结果如下：为什么两个结果一样呢？先看b-&gt;exec()；由于b是Base类型变量，那么调用的Base类的exec函数，exec函数内部调用Base类的display()和say() 函数。由于b为指向DeriveA类的基类指针，根据多态机制，调用Base类的display()函数时，会动态调用DeriveA类的display()函数。调用Base类的say()函数时，由于say()函数不是虚函数，所以不触发多态机制。因此b-&gt;exec()函数的结果为调用DeriveA的display，调用Base的say函数。由于DeriveA类继承于Base类，但是没有实现自己的exec()函数，即没有实现重定义，那么当执行a.exec()时，调用的时Base类的exec()函数，原理和上边一样，调用Base类中的display()函数和say()函数，由于display()函数为虚函数，a为DeriveA类对象，调用基类的虚函数display()，根据多态机制，实际调用的是DeriveA类的display()函数。执行下边代码a.say()结果如下：下面修改DeriveA类的内容，在DeriveA类内部实现自己的exec()函数 123456789101112131415161718class DeriveA:public Base&#123;public: void exec()&#123; display(); say(); &#125; void display() &#123; cout&lt;&lt;&quot;DeriveA display()&quot;&lt;&lt;endl; &#125; //override void f1(int a,int b) &#123; cout&lt;&lt;&quot;DeriveA f1(int,int)&quot;&lt;&lt;endl; &#125; //redefining void say() &#123; cout&lt;&lt;&quot;DeriveA say()&quot;&lt;&lt;endl; &#125; //redefining virtual void func()&#123; cout &lt;&lt; &quot;DeriveA func()&quot; &lt;&lt; endl; &#125;&#125;; 执行下边代码，b-&gt;exec()；a.exec():结果如下:因为DeriveA类重定义了exec函数，那么a.exec()函数调用的是DeriveA类的exec()函数，从而调用的都是DeriveA类的display()和say()函数。 继承类和基类成员函数调用规则总结：DeriveA a; Base *b=&a; 基类指针指向子类对象，该指针调用某个成员函数，先考虑该函数是否为虚函数，如果为虚函数，且子类有覆盖(重写)，会触发多态机制，动态调用子类的重写函数： 如 b-&gt;func()， 输出为DeriveA func() 基类指针指向子类对象，该指针调用某个成员函数，先考虑该函数是否为虚函数，如果为虚函数，子类没有覆盖(没有重写)，不会触发多态机制，调用基类的虚函数： 基类指针指向子类对象，该指针调用某个成员函数，如果该函数不为虚函数，无论该函数是否被子类重定义(redefined)，只调用基类的该成员函数。如DeriveA类内部不实现exec()函数，那么b-&gt;exec()调用的是Base类的exec()函数。 在第3条基础上，基类有成员函数exec()， 子类没有成员函数exec()，在基类的exec() 内部调用虚函数display()， 且子类覆盖了display()函数，那么根据多态机制，调用子类的display()。如果display()虚函数没有被重写，则调用基类的display()函数，同第2条。如果exec()内部调用普通函数say()， 无论子类是否重定义say()，都会调用基类的say()函数，同3 Base类中实现exec()函数，而子类DeriveA类内部不实现exec()函数，DeriveA类对象调用exec()函数，实际调用的为Base类内部的exec()函数。如果exec()内部调用虚函数或者普通成员函数，情况如同第4条。 Base类中实现exec()函数，而子类DeriveA类重定义exec()函数，那么DeriveA类对象调用的是DeriveA类的exec()函数。如果exec()函数内部调用DeriveA类的其他成员函数，那么调用的都是DeriveA类的成员函数。 子类重定义了基类的成员函数，那么子类对象调用该成员函数，要根据子类重定义的形参列表。如a.f1(3,5); 虚函数使用和定义规则: 非类的成员函数不能定义为虚函数，类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。实际上，优秀的程序员常常把基类的析构函数定义为虚函数。因为，将基类的析构函数定义为虚函数后，当利用delete删除一个指向派生类定义的对象指针时，系统会调用相应的类的析构函数。而不将析构函数定义为虚函数时，只调用基类的析构函数。 只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。 如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、参数类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种非虚的同名同返回值同参数个数同参数类型函数。 类的静态函数和构造函数不可以定义为虚函数: 静态函数的目的是通过类名+函数名访问类的static变量，或者通过对象调用staic函数实现对static成员变量的读写，要求内存中只有一份数据。而虚函数在子类中重写，并且通过多态机制实现动态调用，在内存中需要保存不同的重写版本。 构造函数的作用是构造对象，而虚函数的调用是在对象已经构造完成，并且通过调用时动态绑定。动态绑定是因为每个类对象内部都有一个指针，指向虚函数表的首地址。而且虚函数，类的成员函数，static成员函数都不是存储在类对象中，而是在内存中只保留一份。 知其然、知其所以然（虚函数表原理）：虚函数存储在虚函数表中，每个类对象都包含一个指向该虚函数表首地址的指针。定义Baseclass类 123456789class Baseclass &#123; public: Baseclass():a(1024)&#123;&#125; virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int a;&#125;; 从虚函数表中依次取出函数执行： 123456789101112131415161718Baseclass b; cout &lt;&lt;&quot;类对象大小&quot; &lt;&lt; sizeof(b) &lt;&lt; endl; int * p = (int *)(&amp;b) ; cout &lt;&lt; &quot;指向虚函数表的指针的地址&quot;&lt;&lt; p &lt;&lt; endl; cout &lt;&lt;&quot;成员a地址&quot;&lt;&lt; p+1 &lt;&lt; endl; cout &lt;&lt;&quot;成员a的数值&quot; &lt;&lt; *(p + 1) &lt;&lt; endl; cout &lt;&lt; &quot;虚函数表首地址&quot; &lt;&lt;(int *)(*p) &lt;&lt; endl; Func pFun =(Func) *(int *)(*p); pFun(); pFun =(Func) *((int *)(*p) + 1); pFun(); pFun =(Func) *((int *)(*p) + 2); pFun(); 输出结果如下:可见类对象大小为8字节，4字节正好是指向虚函数表指针的大小。剩余4字节为成员变量a的大小。画个图示意虚函数表结构：p指向的就是类对象的首地址，同时也是虚函数表指针(指向虚函数表的指针)的地址，*p指向虚函数表，由于指针是4字节，(int *)(*p)虚函数表首地址，也是第一个函数指针的地址。Derive类继承于Base类，但是没有覆盖(重写)Base类的虚函数，Derive d; 的虚函数表如下：Derive类继承于Base类，并且覆盖(重写)Base类的虚函数，Derive d; 的虚函数表如下：可以看到d的虚函数表中第一个单元为Derive::f()，覆盖了原有的Base::f()。Derive d;Base * p = &d;p指向d的首地址，其实就是d的虚函数表指针的地址，p-&gt;f()实际会调用虚函数表中的Derive::f()，从而实现多态。多重继承结构如下：虚函数表原理后可以篡改部分程序功能，其实很多外挂就是钩子函数回调注入的。 12345678910111213141516171819class Baseclass &#123; public: Baseclass():a(1024)&#123;&#125;private: virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int a;&#125;; class Deriveclass:public Baseclass&#123;public: Deriveclass():Baseclass()&#123;&#125;&#125;; 由于 Baseclass内部的虚函数是私有的，所以Deriveclass类变量是不能直接访问这些函数的。但是可以通过虚函数寻址，并且通过回调函数方式调用。 123Deriveclass d; Func pFunc = (Func)*((int *)(*(int *)(&amp;d))); pFunc(); 结果如下： C++类对象的大小为多大？一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。对象大小= vptr(可能不止一个) + 所有非静态数据成员大小 + Aligin字节大小（依赖于不同的编译器对齐和补齐）定义几个类，然后输出他们大小。 12345678910111213141516171819202122232425262728293031323334353637class A &#123; &#125;; class B &#123; char ch; void func() &#123; &#125; &#125;; class C &#123; char ch1; //占用1字节 char ch2; //占用1字节 virtual void func() &#123; &#125; &#125;; class D &#123; int in; virtual void func() &#123; &#125; &#125;; class E&#123; char m; virtual void func() &#123; &#125;&#125;; 输出大小： 12345678910A a; B b; C c; D d; E e; cout&lt;&lt;&quot;a对象大小： &quot;&lt;&lt; sizeof(a)&lt;&lt;endl; cout&lt;&lt;&quot;b对象大小： &quot;&lt;&lt; sizeof(b)&lt;&lt;endl; cout&lt;&lt;&quot;c对象大小： &quot; &lt;&lt;sizeof(c)&lt;&lt;endl; cout&lt;&lt;&quot;d对象大小： &quot;&lt;&lt; sizeof(d)&lt;&lt;endl; cout &lt;&lt;&quot;e对象大小： &quot; &lt;&lt;sizeof(e) &lt;&lt;endl; 结果如下： 类和结构体对象对齐和补齐原则？ 对齐：类(结构体)对象每个成员分配内存的起始地址为其所占空间的整数倍。补齐：类(结构体)对象所占用的总大小为其内部最大成员所占空间的整数倍。 空类定义的对象a 大小为1因为每个对象是独一无二的，编译器为了标识不同对象，要分配一字节的大小作为标识码。对象b 大小为1是因为成员函数在内存中只存储一份，不会存储在对象中。对象c大小为8， 是因为前四个字节存储虚函数表的指针，第5个字节存储成员变量ch1，第6个字节存储成员变量ch2，这样c的大小为6，根据补齐原则，需要补充2字节，使对象大小为8，8是最大字节4的整数倍。对象d大小为8，不需要补齐和对齐。对象e大小为8，前四个字节存储虚函数表指针，第5个字节存储成员m，需要补齐三个字节，总共八个字节，为4字节的倍数。看看下边这几个类 123456789101112131415class F&#123; static int num; &#125;; class G&#123; virtual void print()&#123;&#125; virtual void print1()&#123;&#125; &#125;; class H&#123; void print()&#123;&#125; static void print1()&#123;&#125; &#125;; 打印并输出大小: 123456F f;cout&lt;&lt;&quot;f 对象大小： &quot;&lt;&lt; sizeof(f)&lt;&lt;endl;G g;cout&lt;&lt;&quot;g 对象大小： &quot;&lt;&lt; sizeof(g)&lt;&lt;endl;H h;cout&lt;&lt;&quot;h 对象大小： &quot;&lt;&lt; sizeof(h)&lt;&lt;endl; 结果：静态成员变量，虚函数和static成员函数都不会占用对象的空间，f大小为1,是因为要开辟一个字节保存对象标识信息。g大小为4是开辟四字节给虚函数表指针。h大小为1字节也是开辟一个字节保存对象标识信息 什么要采取对齐和补齐分配策略？这个要从计算机CPU存取指令说起，每个字节单元为8bit，从地址0到地址3总共四个字节，为32bit。 class A{ char m; char b; }; A a; 对于a 将a.m分配在地址0开始的一个字节中，将a.b分配在地址1开始的额一个字节中。这样a的大小为2，cpu取数据可以执行一条指令就完成了。class B{ int m; char n; }; B b; 对于b将b.m分配在地址为0开始的四个字节(0~3)，对于b.n分配在开始地址为4的一字节空间。如果再定一个B b2;，不采取补齐策略，b2.m将被分起始地址为5的 4字节空间(58)，b2.n就被分在了起始地址为9的一字节空间。cpu取数据需要分3次，先取出03地址空间的数据(b.m)，再取出地址4~7数据(b.n和b2.m的前三个字节) 最后取出地址为8~11的数据(b2.m的最后一个字节以及b2.n)。取出数据后还要拆分和组合，极大地降低了效率。所以需要采取补齐策略。补齐策略数据分配如下： 地址03存储b.m， 地址47存储b.n，由于b.n只占用1个字节，地址5~7不存储数据，用于补齐。 地址811存储b2.m，地址1215存储b2.n，13~15同样不存储数据用于补齐。 这样cpu读取四次可以将数据读取出来，进行简单的组合不需要切割数据就可以完成快速处理。 class C{ char n; int m; } C c； c.n存储周期0开始的一个字节中，如果不采取对齐策略，那么c.m会存储在14字节中，这样cpu需要读去两次，并且需要进行切割(04地址中数据包含c.n和c.m的前三个字节)，以及组合地址4开始的一个字节(存储c.m的最后一个字节)。 如果采取对齐策略，那么地址03存储c.n，地址47存储c.m，cpu同样读取两次，但是仅需要组合就可以去除对象的所有数据。 这就是为什么存储数据需要采取对齐和补齐的策略。到此为止C++虚函数和类成员的存储知识复习完，谢谢关注我的公众号：","categories":[{"name":"C++","slug":"cpp","permalink":"http://www.limerence2017.com/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]}]