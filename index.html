<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="重剑无锋，大巧不工">
<meta property="og:type" content="website">
<meta property="og:title" content="恋恋风辰的个人博客">
<meta property="og:url" content="http://www.limerence2017.com/index.html">
<meta property="og:site_name" content="恋恋风辰的个人博客">
<meta property="og:description" content="重剑无锋，大巧不工">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="恋恋风辰">
<meta property="article:tag" content="C++ python 大并发网络 逆向">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.limerence2017.com/"/>





  <title>恋恋风辰的个人博客</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恋恋风辰的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2025/02/08/AI01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/08/AI01/" itemprop="url">DeepSeek-R1本地部署知识库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-02-08T20:08:17+08:00">
                2025-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index">
                    <span itemprop="name">AI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p>考虑大家看文档会比较吃力，可以参考我的视频教程</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GkNyeDEpK/?pop_share=1&vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9">https://www.bilibili.com/video/BV1GkNyeDEpK/?pop_share=1&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9</a></p>
<h2 id="DeepSeek简介"><a href="#DeepSeek简介" class="headerlink" title="DeepSeek简介"></a>DeepSeek简介</h2><p>深度求索人工智能基础技术研究有限公司(简称“深度求索”或“DeepSeek”)，成立于2023年，是一家专注于实现AGI的中国公司。</p>
<p>产品DeepSeek为一款AI工具，可以解析文本，生成代码，推理解析等。</p>
<h2 id="模型-amp-价格"><a href="#模型-amp-价格" class="headerlink" title="模型 &amp; 价格"></a>模型 &amp; 价格</h2><p>下表所列模型价格以“百万 tokens”为单位。Token 是模型用来表示自然语言文本的的最小单位，可以是一个词、一个数字或一个标点符号等。我们将根据模型输入和输出的总 token 数进行计量计费。</p>
<table>
<thead>
<tr>
<th>模型(1)</th>
<th>上下文长度</th>
<th>最大思维链长度(2)</th>
<th>最大输出长度(3)</th>
<th>百万tokens 输入价格 （缓存命中）(4)</th>
<th>百万tokens 输入价格 （缓存未命中）</th>
<th>百万tokens 输出价格 输出价格</th>
</tr>
</thead>
<tbody><tr>
<td>deepseek-chat</td>
<td>64K</td>
<td>-</td>
<td>8K</td>
<td>0.5元</td>
<td>2元</td>
<td>8元</td>
</tr>
<tr>
<td>deepseek-reasoner</td>
<td>64K</td>
<td>32K</td>
<td>8K</td>
<td>1元</td>
<td>4元</td>
<td>16元(5)</td>
</tr>
</tbody></table>
<ol>
<li><code>deepseek-chat</code> 模型已经升级为 <strong>DeepSeek-V3</strong>；<code>deepseek-reasoner</code> 模型为新模型 <strong>DeepSeek-R1</strong>。</li>
<li><strong>思维链</strong>为<code>deepseek-reasoner</code>模型在给出正式回答之前的思考过程，其原理详见<a target="_blank" rel="noopener" href="https://api-docs.deepseek.com/zh-cn/guides/reasoning_model">推理模型</a>。</li>
<li>如未指定 <code>max_tokens</code>，默认最大输出长度为 4K。请调整 <code>max_tokens</code> 以支持更长的输出。</li>
<li>关于上下文缓存的细节，请参考<a target="_blank" rel="noopener" href="https://api-docs.deepseek.com/zh-cn/news/news0802">DeepSeek 硬盘缓存</a>。</li>
<li><code>deepseek-reasoner</code>的输出 token 数包含了思维链和最终答案的所有 token，其计价相同。</li>
</ol>
<h2 id="性能对齐-OpenAI-o1-正式版"><a href="#性能对齐-OpenAI-o1-正式版" class="headerlink" title="性能对齐 OpenAI-o1 正式版"></a>性能对齐 OpenAI-o1 正式版</h2><p>DeepSeek-R1 在后训练阶段大规模使用了强化学习技术，在仅有极少标注数据的情况下，极大提升了模型推理能力。在数学、代码、自然语言推理等任务上，性能比肩 OpenAI o1 正式版。</p>
<p><img src="https://cdn.llfc.club/abbe5dcf3b85c33ded2d624fe84a2ec.png" alt="https://cdn.llfc.club/abbe5dcf3b85c33ded2d624fe84a2ec.png"></p>
<h2 id="蒸馏小模型超越-OpenAI-o1-mini"><a href="#蒸馏小模型超越-OpenAI-o1-mini" class="headerlink" title="蒸馏小模型超越 OpenAI o1-mini"></a>蒸馏小模型超越 OpenAI o1-mini</h2><p>在开源 DeepSeek-R1-Zero 和 DeepSeek-R1 两个 660B 模型的同时，通过 DeepSeek-R1 的输出，蒸馏了 6 个小模型开源给社区，其中 32B 和 70B 模型在多项能力上实现了对标 OpenAI o1-mini 的效果。</p>
<p><img src="https://dp-cdn-deepseek.obs.cn-east-3.myhuaweicloud.com/api-docs/deepseek_r1_benchmark_table.png" alt="img"></p>
<h2 id="API-及定价"><a href="#API-及定价" class="headerlink" title="API 及定价"></a>API 及定价</h2><p>DeepSeek-R1 API 服务定价为每百万输入 tokens 1 元（缓存命中）/ 4 元（缓存未命中），每百万输出 tokens 16 元。</p>
<p><img src="https://dp-cdn-deepseek.obs.cn-east-3.myhuaweicloud.com/api-docs/deepseek_r1_price.jpeg" alt="img"></p>
<p><img src="https://dp-cdn-deepseek.obs.cn-east-3.myhuaweicloud.com/api-docs/deepseek_r1_price_compare.png" alt="img"></p>
<p>详细的 API 调用指南请参考官方文档： <a target="_blank" rel="noopener" href="https://api-docs.deepseek.com/zh-cn/guides/reasoning_model">https://api-docs.deepseek.com/zh-cn/guides/reasoning_model</a></p>
<h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="Ollama-官方版：【点击前往】"><a href="#Ollama-官方版：【点击前往】" class="headerlink" title="Ollama 官方版：【点击前往】"></a><strong>Ollama 官方版：</strong>【<a target="_blank" rel="noopener" href="https://ollama.com/">点击前往</a>】</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209105510.png" alt="image-20250209105503303"></p>
<p>下载windows版本并安装</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209111710.png" alt="image-20250209111710518"></p>
<p>我在windows做测试，然后部署</p>
<p>安装命令</p>
<p><strong>1.5B Qwen DeepSeek R1(需4G显存)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure>

<p><strong>7B Qwen DeepSeek R1(4~12G显存)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:7b</span><br></pre></td></tr></table></figure>

<p><strong>8B Llama DeepSeek R1(4~12G显存)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:8b</span><br></pre></td></tr></table></figure>

<p><strong>14B Qwen DeepSeek R1(12~24G显存)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:14b</span><br></pre></td></tr></table></figure>

<p><strong>32B Qwen DeepSeek R1(24G显存)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:32b</span><br></pre></td></tr></table></figure>

<p><strong>70B Llama DeepSeek R1(32G显存以上)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:70b</span><br></pre></td></tr></table></figure>



<p>我们选择1.5b模型安装</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209112145.png" alt="image-20250209112145406"></p>
<p>安装成功<img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209114003.png" alt="image-20250209114003740"></p>
<h3 id="AnythingLLM-下载"><a href="#AnythingLLM-下载" class="headerlink" title="AnythingLLM 下载"></a><strong>AnythingLLM</strong> 下载</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209114426.png" alt="image-20250209114426088"></p>
<p><strong>1、Github 开源版 【<a target="_blank" rel="noopener" href="https://github.com/Mintplex-Labs/anything-llm">点击下载</a>】</strong></p>
<p><strong>2、官方版：【<a target="_blank" rel="noopener" href="https://anythingllm.com/">点击下载</a>】</strong></p>
<p>我们选择开源版下载，拉到最下面有markdown文档</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209114631.png" alt="image-20250209114631891"></p>
<p>点击DownloadNow, 选择x64版本下载</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209115524.png" alt="image-20250209115524398"></p>
<p>下载完成，安装</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209115437.png" alt="image-20250209115436788"></p>
<p>安装完成</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209121534.png" alt="image-20250209121534198"></p>
<p>点击完成自动运行</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209121713.png" alt="image-20250209121713655"></p>
<p>点击Get started，然后一路跳过</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209121816.png" alt="image-20250209121816605"></p>
<p>记得填写邮箱和使用目的</p>
<p>然后再填写工作区</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122112.png" alt="image-20250209122112515"></p>
<p>点击右侧箭头完成，进入使用界面，如果此时使用会出现模型未设置</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122226.png" alt="image-20250209122226640"></p>
<p>点击设置按钮，选择聊天选项，接下来选择模型</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122457.png" alt="image-20250209122457152"></p>
<p>设置模型为ollama</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122532.png" alt="image-20250209122532873"></p>
<p>设置后</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122828.png" alt="image-20250209122828156"></p>
<p>记得更新</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209122859.png" alt="image-20250209122859291"></p>
<p><strong>注意：本地部署也是支持开启联网搜索模式的</strong></p>
<p>点击设置按钮</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209123038.png" alt="image-20250209123038941"></p>
<p>只需在AnythingLLM的设置界面中，找到“代理技能”选项。 启用Web Search：在代理技能列表中找到 Web Search ，点击开启。 选择搜索引擎即可！</p>
<p>如下图所示:</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209123125.png" alt="image-20250209123125101"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试代码生成能力"><a href="#测试代码生成能力" class="headerlink" title="测试代码生成能力"></a>测试代码生成能力</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209124010.png" alt="image-20250209124009974"></p>
<h3 id="测试检索能力"><a href="#测试检索能力" class="headerlink" title="测试检索能力"></a>测试检索能力</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209124053.png" alt="image-20250209124053537"></p>
<h3 id="测试推理能力"><a href="#测试推理能力" class="headerlink" title="测试推理能力"></a>测试推理能力</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2025/02/09/20250209124127.png" alt="image-20250209124127054"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2025/01/29/cppbase31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/29/cppbase31/" itemprop="url">模板详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-01-29T20:43:45+08:00">
                2025-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模板基础"><a href="#模板基础" class="headerlink" title="模板基础"></a>模板基础</h2><p>C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板允许编写通用的函数，通过类型参数化，使其能够处理不同的数据类型。它通过模板参数定义与类型无关的函数。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">functionName</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例：最大值函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; std::endl;         <span class="comment">// int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3.14</span>, <span class="number">2.72</span>) &lt;&lt; std::endl;  <span class="comment">// double 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;    <span class="comment">// char 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">3.14</span><br><span class="line">z</span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li><strong>模板参数列表</strong>以 <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code> 开头，两者等价。</li>
<li><strong>类型推导</strong>：编译器根据函数参数自动推导模板参数类型。</li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板允许定义通用的类，通过类型参数化，实现不同类型的对象。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T memberVariable;</span><br><span class="line">    <span class="comment">// 构造函数、成员函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>示例：简单的 Pair 类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: 1, 2.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, std::string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Hello, World</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="string">&quot;Age&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Age, 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Pair: 1, 2.5</span></span><br><span class="line"><span class="section">Pair: Hello, World</span></span><br><span class="line"><span class="section">Pair: Age, 30</span></span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>类模板可以有多个类型参数。</li>
<li>模板参数可以被用于成员变量和成员函数中。</li>
<li>类模板实例化时指定具体类型，如 <code>Pair&lt;int, double&gt;</code>。</li>
</ul>
<hr>
<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>模板参数决定了模板的泛用性与灵活性。C++ 模板参数种类主要包括类型参数、非类型参数和模板模板参数。</p>
<h3 id="类型参数（Type-Parameters）"><a href="#类型参数（Type-Parameters）" class="headerlink" title="类型参数（Type Parameters）"></a>类型参数（Type Parameters）</h3><p>类型参数用于表示任意类型，在模板实例化时被具体的类型替代。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="非类型参数（Non-Type-Parameters）"><a href="#非类型参数（Non-Type-Parameters）" class="headerlink" title="非类型参数（Non-Type Parameters）"></a>非类型参数（Non-Type Parameters）</h3><p>非类型参数允许模板接受非类型的值，如整数、指针或引用。C++17 支持更多非类型参数类型，如 <code>auto</code>。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data[N];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>示例：固定大小的数组类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data[N];</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FixedArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    arr.<span class="built_in">print</span>(); <span class="comment">// 输出：0 10 20 30 40 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10 20 30 40 </span><br></pre></td></tr></table></figure>



<p><strong>注意事项：</strong></p>
<ul>
<li>非类型参数必须是编译期常量。</li>
<li>允许的类型包括整型、枚举、指针、引用等，但不包括浮点数和类类型。</li>
</ul>
<h3 id="模板模板参数（Template-Template-Parameters）"><a href="#模板模板参数（Template-Template-Parameters）" class="headerlink" title="模板模板参数（Template Template Parameters）"></a>模板模板参数（Template Template Parameters）</h3><p>模板模板参数允许模板接受另一个模板作为参数。这对于抽象容器和策略模式等场景非常有用。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>



<p><strong>示例：容器适配器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Container&lt;T, std::allocator&lt;T&gt;&gt;&amp; container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : container)</span><br><span class="line">            std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ContainerPrinter&lt;std::vector, <span class="type">int</span>&gt; vecPrinter;</span><br><span class="line">    vecPrinter.<span class="built_in">print</span>(vec); <span class="comment">// 输出：1 2 3 4 5 </span></span><br><span class="line"></span><br><span class="line">    ContainerPrinter&lt;std::list, <span class="type">int</span>&gt; listPrinter;</span><br><span class="line">    listPrinter.<span class="built_in">print</span>(lst); <span class="comment">// 输出：10 20 30 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">10 20 30 </span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>模板模板参数需要完全匹配被接受模板的参数列表。</li>
<li>可通过默认模板参数增强灵活性。</li>
</ul>
<hr>
<h2 id="模板特化（Template-Specialization）"><a href="#模板特化（Template-Specialization）" class="headerlink" title="模板特化（Template Specialization）"></a>模板特化（Template Specialization）</h2><p>模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持<strong>全特化（Full Specialization）**和**偏特化（Partial Specialization）**，但需要注意的是，</strong>函数模板不支持偏特化**，只能进行全特化。</p>
<h3 id="全特化（Full-Specialization）"><a href="#全特化（Full-Specialization）" class="headerlink" title="全特化（Full Specialization）"></a>全特化（Full Specialization）</h3><p>全特化是针对模板参数的完全特定类型组合。它提供了模板的一个特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;SpecificType&gt; &#123;</span><br><span class="line">    <span class="comment">// 针对 SpecificType 的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="示例：类模板全特化"><a href="#示例：类模板全特化" class="headerlink" title="示例：类模板全特化"></a>示例：类模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Printer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Printer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    intPrinter.<span class="built_in">print</span>(<span class="number">100</span>); <span class="comment">// 输出：General Printer: 100</span></span><br><span class="line"></span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    stringPrinter.<span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>); <span class="comment">// 输出：String Printer: Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">General Printer:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">String Printer:</span> <span class="string">Hello,</span> <span class="string">World!</span></span><br></pre></td></tr></table></figure>



<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li><strong>通用模板</strong>适用于所有类型，在<code>print</code>函数中以通用方式输出值。</li>
<li><strong>全特化模板</strong>针对<code>std::string</code>类型进行了专门化，实现了不同的<code>print</code>函数。</li>
<li>当实例化<code>Printer&lt;std::string&gt;</code>时，编译器选择全特化版本而非通用模板。</li>
</ul>
<h3 id="偏特化（Partial-Specialization）"><a href="#偏特化（Partial-Specialization）" class="headerlink" title="偏特化（Partial Specialization）"></a>偏特化（Partial Specialization）</h3><p>偏特化允许模板对部分参数进行特定类型的处理，同时保持其他参数的通用性。对于<strong>类模板</strong>而言，可以针对模板参数的某些特性进行偏特化；对于<strong>函数模板</strong>，则仅支持全特化，不支持偏特化。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：当 U 是指针类型时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, U*&gt; &#123;</span><br><span class="line">    <span class="comment">// 针对 U* 的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="示例：类模板偏特化"><a href="#示例：类模板偏特化" class="headerlink" title="示例：类模板偏特化"></a>示例：类模板偏特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用 Pair 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板偏特化：当第二个类型是指针时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U* second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U* b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair with pointer: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: 1, 2.5</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">3.14</span>;</span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">double</span>*&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Pi&quot;</span>, &amp;value)</span></span>;</span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair with pointer: Pi, 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Pair:</span> <span class="number">1</span>, <span class="number">2.5</span></span><br><span class="line">Pair <span class="keyword">with</span> pointer: Pi, <span class="number">3.14</span></span><br></pre></td></tr></table></figure>



<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul>
<li><strong>通用模板</strong>处理非指针类型对。</li>
<li><strong>偏特化模板</strong>处理第二个类型为指针的情况，打印指针指向的值。</li>
<li>使用偏特化提升了模板的灵活性，使其能够根据部分参数类型进行不同处理。</li>
</ul>
<h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>与类模板不同，<strong>函数模板不支持偏特化</strong>，只能进行全特化。当对函数模板进行全特化时，需要显式指定类型。</p>
<h4 id="示例：函数模板全特化"><a href="#示例：函数模板全特化" class="headerlink" title="示例：函数模板全特化"></a>示例：函数模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General print: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printValue</span>&lt;std::string&gt;(<span class="type">const</span> std::string&amp; value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized print for std::string: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>); <span class="comment">// 调用通用模板，输出：General print: 42</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">3.14</span>); <span class="comment">// 调用通用模板，输出：General print: 3.14</span></span><br><span class="line">    <span class="built_in">printValue</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 调用全特化模板，输出：Specialized print for std::string: Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">General <span class="built_in">print</span>: <span class="number">42</span></span><br><span class="line">General <span class="built_in">print</span>: <span class="number">3.14</span></span><br><span class="line">Specialized <span class="built_in">print</span> <span class="keyword">for</span> std::<span class="type">string</span>: Hello</span><br></pre></td></tr></table></figure>



<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><ul>
<li><strong>通用函数模板</strong>适用于所有类型，提供通用的<code>printValue</code>实现。</li>
<li><strong>全特化函数模板</strong>专门处理<code>std::string</code>类型，提供不同的输出格式。</li>
<li>调用<code>printValue</code>时，编译器根据实参类型选择适当的模板版本。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>优先级</strong>：全特化版本的优先级高于通用模板，因此当特化条件满足时，总是选择特化版本。</li>
<li><strong>显式指定类型</strong>：函数模板特化需要在调用时显式指定类型，或者确保类型推导可以正确匹配特化版本。</li>
<li><strong>不支持偏特化</strong>：无法通过偏特化对函数模板进行部分特化，需要通过其他方法（如重载）实现类似功能。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>全特化</strong>适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。</li>
<li><strong>偏特化</strong>仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。</li>
<li><strong>函数模板</strong>仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。</li>
<li><strong>特化模板</strong>提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。</li>
</ul>
<hr>
<h2 id="变参模板（Variadic-Templates）"><a href="#变参模板（Variadic-Templates）" class="headerlink" title="变参模板（Variadic Templates）"></a>变参模板（Variadic Templates）</h2><p>变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 <code>std::tuple</code>、<code>std::variant</code> 等模板库组件的基础。</p>
<h3 id="定义与语法"><a href="#定义与语法" class="headerlink" title="定义与语法"></a>定义与语法</h3><p>变参模板使用 <strong>参数包（Parameter Pack）</strong>，通过 <code>...</code> 语法来表示。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(T first, Args... args)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归与展开（Recursion-and-Expansion）"><a href="#递归与展开（Recursion-and-Expansion）" class="headerlink" title="递归与展开（Recursion and Expansion）"></a>递归与展开（Recursion and Expansion）</h3><p>变参模板通常与递归相结合，通过递归地处理参数包，或者使用 <strong>折叠表达式（Fold Expressions）</strong> 来展开发参数包。</p>
<p><strong>递归示例：打印所有参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况：无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归情况：至少一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(<span class="type">const</span> T&amp; first, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">printAll</span>(args...); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printAll</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 输出：1 2.5 Hello A </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2.5</span> Hello <span class="selector-tag">A</span> </span><br></pre></td></tr></table></figure>



<p><strong>折叠表达式版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用折叠表达式的printAll</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用左折叠展开参数包，并在每个参数之后输出一个空格</span></span><br><span class="line">    ((std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ...);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printAll</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 输出：1 2.5 Hello A </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>折叠表达式示例：计算总和</strong></p>
<p>C++17 引入了折叠表达式，简化了参数包的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> -&gt; <span class="title">decltype</span><span class="params">((args + ...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.0</span>) &lt;&lt; std::endl; <span class="comment">// 输出：7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure>



<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><p><strong>示例：日志记录器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况：无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归情况：至少一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg, <span class="type">const</span> T&amp; first, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;&quot;</span>, args...); <span class="comment">// 递归调用，省略消息前缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;Error&quot;</span>, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出：Error: 404 Not Found </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;Sum&quot;</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 输出：Sum: 10 20 30 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Error: 404 Not Found </span></span><br><span class="line"><span class="section">Sum: 10 20 30 </span></span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>变参模板极大地提升了模板的灵活性。</li>
<li>使用递归或折叠表达式处理参数包。</li>
<li>常用于实现通用函数、容器类和元编程工具。</li>
</ul>
<h2 id="模板折叠（Fold-Expressions）"><a href="#模板折叠（Fold-Expressions）" class="headerlink" title="模板折叠（Fold Expressions）"></a>模板折叠（Fold Expressions）</h2><h3 id="1-折叠表达式的概念与背景"><a href="#1-折叠表达式的概念与背景" class="headerlink" title="1. 折叠表达式的概念与背景"></a>1. 折叠表达式的概念与背景</h3><p>在C++中，<strong>可变参数模板</strong>允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。</p>
<p><strong>折叠表达式</strong>的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。</p>
<p><strong>折叠表达式</strong>可分为：</p>
<ul>
<li><strong>一元折叠表达式（Unary Fold）</strong>：对参数包中的每个参数应用一个一元操作符。</li>
<li><strong>二元折叠表达式（Binary Fold）</strong>：对参数包中的每个参数应用一个二元操作符。</li>
</ul>
<p>此外，<strong>二元折叠表达式</strong>可进一步细分为**左折叠（Left Fold）**和**右折叠（Right Fold）**，取决于操作符的结合方向。</p>
<h3 id="2-一元折叠表达式（Unary-Fold）"><a href="#2-一元折叠表达式（Unary-Fold）" class="headerlink" title="2. 一元折叠表达式（Unary Fold）"></a>2. 一元折叠表达式（Unary Fold）</h3><p><strong>一元折叠表达式</strong>用于在参数包的每个参数前或后应用一元操作符。语法形式如下：</p>
<p><strong>前置一元折叠（Unary Prefix Fold）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(op ... pack)</span><br></pre></td></tr></table></figure>



<p><strong>后置一元折叠（Unary Postfix Fold）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack ... op)</span><br></pre></td></tr></table></figure>



<p>其中，<code>op</code> 是一元操作符，如<code>!</code>（逻辑非）、<code>~</code>（按位取反）等。</p>
<p><strong>示例1：逻辑非操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个参数非操作，然后再将这些操作&amp;&amp;</span></span><br><span class="line"><span class="comment">//(!args &amp;&amp; ...) 相当于 !a &amp;&amp; !b &amp;&amp; ...</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allNot</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!args &amp;&amp; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-二元折叠表达式（Binary-Fold）"><a href="#3-二元折叠表达式（Binary-Fold）" class="headerlink" title="3. 二元折叠表达式（Binary Fold）"></a>3. 二元折叠表达式（Binary Fold）</h3><p><strong>二元折叠表达式</strong>用于在参数包的每个参数之间应用一个二元操作符。它们可以分为**二元左折叠（Binary Left Fold）**和**二元右折叠（Binary Right Fold）**，取决于操作符的结合方向。</p>
<p><strong>二元折叠表达式语法</strong></p>
<ul>
<li><p><strong>二元左折叠（Left Fold）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(init op ... op pack)</span><br></pre></td></tr></table></figure>

<p>或者简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack1 op ... op packN)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>二元右折叠（Right Fold）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack1 op ... op init op ...)</span><br></pre></td></tr></table></figure>

<p>或者简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack1 op ... op packN)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其中，<code>op</code> 是二元操作符，如<code>+</code>、<code>*</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;&lt;</code> 等。</p>
<p><strong>左折叠与右折叠的区别</strong></p>
<ul>
<li><strong>二元左折叠（Binary Left Fold）</strong>：操作符从左至右结合，等价于 <code>(((a op b) op c) op d)</code>。</li>
<li><strong>二元右折叠（Binary Right Fold）</strong>：操作符从右至左结合，等价于 <code>(a op (b op (c op d)))</code>。</li>
</ul>
<p><strong>示例1：求和（Binary Left Fold）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元左折叠：((arg1 + arg2) + arg3) + ... + argN</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumLeftFold</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sumLeftFold</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><strong><code>(args + ...)</code></strong> 是一个二元左折叠表达式。</li>
<li>它将<code>+</code>操作符逐个应用于参数，按照左折叠顺序。</li>
<li>即，<code>((1 + 2) + 3) + 4 = 10</code>。</li>
<li></li>
</ul>
<p><strong>示例2：乘积（Binary Right Fold）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元右折叠：arg1 * (arg2 * (arg3 * ... * argN))</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">productRightFold</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... * args); <span class="comment">// 右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">productRightFold</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><strong><code>(... \* args)</code></strong> 是一个二元右折叠表达式。</li>
<li>它将<code>*</code>操作符逐个应用于参数，按照右折叠顺序。</li>
<li>即，<code>2 * (3 * 4) = 2 * 12 = 24</code>。</li>
</ul>
<p><strong>示例3：逻辑与（Binary Left Fold）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; std::endl; <span class="comment">// 输出：false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><strong><code>(args &amp;&amp; ...)</code></strong> 是一个二元左折叠表达式。</li>
<li>用于检查所有参数是否为<code>true</code>。</li>
<li>类似于链式的逻辑与运算。</li>
</ul>
<hr>
<h3 id="4-左折叠与右折叠（Left-and-Right-Folds）"><a href="#4-左折叠与右折叠（Left-and-Right-Folds）" class="headerlink" title="4. 左折叠与右折叠（Left and Right Folds）"></a>4. 左折叠与右折叠（Left and Right Folds）</h3><p>了解<strong>左折叠</strong>和<strong>右折叠</strong>的区别，对于正确选择折叠表达式的形式至关重要。</p>
<p><strong>二元左折叠（Binary Left Fold）</strong></p>
<ul>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(args op ...)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>展开方式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((arg1 op arg2) op arg3) op ... op argN</span><br></pre></td></tr></table></figure></li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>当操作符是结合性的且从左侧开始累积操作时（如<code>+</code>、<code>*</code>）。</li>
<li>需要严格的顺序执行时，确保从左到右依次处理参数。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(args + ...) <span class="comment">// 左折叠求和</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>二元右折叠（Binary Right Fold）</strong></p>
<ul>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... op args)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>展开方式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">arg1 <span class="title">op</span> <span class="params">(arg2 op (arg3 op ... op argN))</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>当操作符是右结合的，或当需要从右侧开始累积操作时。</li>
<li>某些特定的逻辑和数据结构可能需要右侧先处理。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... + args) <span class="comment">// 右折叠求和</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>嵌套折叠表达式</strong></p>
<p>在某些复杂场景下，可能需要嵌套使用左折叠和右折叠，以达到特定的操作顺序。例如，结合多个不同的操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">complexFold</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先左折叠求和，然后右折叠求乘积</span></span><br><span class="line">    <span class="keyword">return</span> (args + ...) * (... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">complexFold</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// (1+2+3) * (1+2+3) = 6 * 6 = 36</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li>在此示例中，我们首先对参数进行左折叠求和，然后对参数进行右折叠求和，最后将两者相乘。</li>
<li>这种嵌套用途展示了折叠表达式的灵活性。</li>
</ul>
<hr>
<h3 id="5-op-在折叠表达式中的作用"><a href="#5-op-在折叠表达式中的作用" class="headerlink" title="5. op 在折叠表达式中的作用"></a>5. <code>op</code> 在折叠表达式中的作用</h3><p>在折叠表达式中，<code>op</code> 代表<strong>二元操作符</strong>，用于定义如何将参数包中的各个参数相互结合。<code>op</code> 可以是任何合法的二元操作符，包括但不限于：</p>
<ul>
<li><strong>算术操作符</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 等。</li>
<li><strong>逻辑操作符</strong>：<code>&amp;&amp;</code>、<code>||</code> 等。</li>
<li><strong>按位操作符</strong>：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code> 等。</li>
<li><strong>比较操作符</strong>：<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 等。</li>
<li><strong>自定义操作符</strong>：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。</li>
</ul>
<p><strong><code>op</code> 的选择直接影响折叠表达式的行为和结果</strong>。选择适当的操作符是实现特定功能的关键。</p>
<p><strong>示例1：使用加法操作符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">addAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 使用 &#x27;+&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">addAll</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：使用逻辑与操作符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...); <span class="comment">// 使用 &#x27;&amp;&amp;&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; std::endl; <span class="comment">// 输出：false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例3：使用左移操作符（流插入）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="comment">// 使用 &#x27;&lt;&lt;&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printAll</span>(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出：Hello, world!123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><p>在上述示例中，<code>op</code> 分别为 <code>+</code>、<code>&amp;&amp;</code>、<code>&lt;&lt;</code>。</p>
</li>
<li><p>每个操作符定义了如何将参数包中的元素相互结合。</p>
</li>
</ul>
<p><strong>示例4：使用自定义操作符</strong></p>
<p>假设有一个自定义类型<code>Point</code>，并重载了<code>+</code>操作符以支持点的相加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &#x27;+&#x27; 操作符</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point&#123; x + other.x, y + other.y &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元左折叠：((p1 + p2) + p3) + ... + pN</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">Point <span class="title">sumPoints</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 使用 &#x27;+&#x27; 进行左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, p2&#123;<span class="number">3</span>, <span class="number">4</span>&#125;, p3&#123;<span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Point result = <span class="built_in">sumPoints</span>(p1, p2, p3);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of Points: (&quot;</span> &lt;&lt; result.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; result.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>; <span class="comment">// 输出：(9, 12)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li>通过重载<code>+</code>操作符，<code>sumPoints</code>函数能够将多个<code>Point</code>对象相加，得到累积的结果。</li>
</ul>
<h3 id="6-示例代码与应用"><a href="#6-示例代码与应用" class="headerlink" title="6. 示例代码与应用"></a>6. 示例代码与应用</h3><p>为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。</p>
<p><strong>示例1：字符串拼接</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">concatenate</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::string&#123;&#125; + ... + args); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">concatenate</span>(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot; Have a nice day.&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出：Hello, world! Have a nice day.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：计算逻辑与</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">areAllTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">areAllTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;   <span class="comment">// 输出：true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">areAllTrue</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例3：计算最大值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">maxAll</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::max)(first, ... , args); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxAll</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出：9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：上述示例中的<code>(std::max)(first, ... , args)</code>是一个非标准用法，需要根据具体情况调整。通常，<code>std::max</code>不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用<code>std::initializer_list</code>或其他方法实现多参数的最大值计算。</p>
<p><strong>示例4：筛选逻辑</strong></p>
<p>假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyTrue</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args || ...); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">anyTrue</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl; <span class="comment">// 输出：true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">anyTrue</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>) &lt;&lt; std::endl; <span class="comment">// 输出：false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="7-注意事项与最佳实践"><a href="#7-注意事项与最佳实践" class="headerlink" title="7. 注意事项与最佳实践"></a>7. 注意事项与最佳实践</h3><p><strong>1. 操作符的选择</strong></p>
<p>选择合适的操作符（<code>op</code>）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。</p>
<p><strong>2. 操作符的结合性</strong></p>
<p>不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。</p>
<p><strong>3. 参数包的初始化</strong></p>
<p>在二元折叠表达式中，有时需要一个初始值（<code>init</code>）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumWithInit</span><span class="params">(<span class="type">int</span> init, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (init + ... + args); <span class="comment">// 左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sumWithInit</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出：16 (10 + 1 + 2 + 3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 参数包为空的情况</strong></p>
<p>如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和函数，如果参数包为空返回0</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args); <span class="comment">// 左折叠，初始值为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出：6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>() &lt;&lt; std::endl;        <span class="comment">// 输出：0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 与递归模板的比较</strong></p>
<p>折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。</p>
<p><strong>6. 编译器支持</strong></p>
<p>确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括：</p>
<ul>
<li><strong>GCC</strong>：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。</li>
<li><strong>Clang</strong>：从版本5开始支持C++17。</li>
<li><strong>MSVC（Visual Studio）</strong>：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。</li>
</ul>
<p><strong>7. 性能考虑</strong></p>
<p>折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。</p>
<hr>
<h2 id="SFINAE（Substitution-Failure-Is-Not-An-Error）"><a href="#SFINAE（Substitution-Failure-Is-Not-An-Error）" class="headerlink" title="SFINAE（Substitution Failure Is Not An Error）"></a>SFINAE（Substitution Failure Is Not An Error）</h2><h3 id="一、什么是SFINAE？"><a href="#一、什么是SFINAE？" class="headerlink" title="一、什么是SFINAE？"></a>一、什么是SFINAE？</h3><p><strong>SFINAE</strong> 是 “Substitution Failure Is Not An Error”（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。</p>
<h3 id="二、SFINAE的工作原理"><a href="#二、SFINAE的工作原理" class="headerlink" title="二、SFINAE的工作原理"></a>二、SFINAE的工作原理</h3><p>在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。</p>
<h3 id="三、SFINAE的应用场景"><a href="#三、SFINAE的应用场景" class="headerlink" title="三、SFINAE的应用场景"></a>三、SFINAE的应用场景</h3><ol>
<li><strong>函数重载选择</strong>：根据参数类型的不同选择不同的函数实现。</li>
<li><strong>类型特性检测</strong>：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。</li>
<li><strong>条件编译</strong>：根据模板参数的特性决定是否编译某些代码段。</li>
</ol>
<h3 id="四、SFINAE的基本用法"><a href="#四、SFINAE的基本用法" class="headerlink" title="四、SFINAE的基本用法"></a>四、SFINAE的基本用法</h3><p>SFINAE通常与<code>std::enable_if</code>、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。</p>
<p><strong>示例一：通过<code>std::enable_if</code>实现函数重载</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于整数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于浮点类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Floating point type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">10</span>);      <span class="comment">// 输出: Integral type: 10</span></span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">3.14</span>);    <span class="comment">// 输出: Floating point type: 3.14</span></span><br><span class="line">    <span class="comment">// print_type(&quot;Hello&quot;); // 编译错误，没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><code>std::enable_if</code> 根据条件 <code>std::is_integral&lt;T&gt;::value</code> 或 <code>std::is_floating_point&lt;T&gt;::value</code> 决定是否启用对应的函数模板。</li>
<li>当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。</li>
</ul>
<p><strong>示例二：检测类型是否具有特定成员</strong></p>
<p>假设我们需要实现一个函数，仅当类型 <code>T</code> 具有成员函数 <code>foo</code> 时才启用该函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助类型，检测是否存在成员函数 foo</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">has_foo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> yes[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> no[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="built_in">void</span> (U::*)()&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SFINAE</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> yes&amp; <span class="title">test</span><span class="params">(SFINAE&lt;U, &amp;U::foo&gt;*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> no&amp; <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="number">0</span>)) == <span class="built_in">sizeof</span>(yes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数仅在 T 有 foo() 成员时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_foo&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutFoo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf); <span class="comment">// 输出: WithFoo::foo() \n foo() called.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithoutFoo wf2;</span></span><br><span class="line">    <span class="comment">// call_foo(wf2); // 编译错误，没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><code>has_foo</code> 是一个类型萃取类，用于检测类型 <code>T</code> 是否具有成员函数 <code>foo</code>。</li>
<li><code>call_foo</code> 函数模板仅在 <code>T</code> 具有 <code>foo</code> 成员时启用。</li>
<li>对于不具有 <code>foo</code> 成员的类型，编译器会忽略 <code>call_foo</code>，从而避免编译错误。</li>
</ul>
<p><strong>示例三：通过模板特化实现不同的行为</strong></p>
<p>以下是完整的、正确实现 <code>TypePrinter</code> 的代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个 Trait 用于检测 T 是否有非 void 的 `value_type`</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_non_void_value_type : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当 T 有 `value_type` 且 `value_type` 不是 void 时，特化为 std::true_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_non_void_value_type</span>&lt;T, std::<span class="type">enable_if_t</span>&lt;!std::is_void_v&lt;<span class="keyword">typename</span> T::value_type&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义 TypePrinter 主模板，使用一个布尔参数控制特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> HasValueType = has_non_void_value_type&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> TypePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 特化：当 HasValueType 为 true 时，表示 T 有非 void 的 `value_type`</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypePrinter</span>&lt;T, <span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T has a member type &#x27;value_type&#x27;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化：当 HasValueType 为 false 时，表示 T 没有 `value_type` 或 `value_type` 是 void</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypePrinter</span>&lt;T, <span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world! T does not have a member type &#x27;value_type&#x27;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithValueType</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutValueType</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithVoidValueType</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypePrinter&lt;WithValueType&gt;::<span class="built_in">print</span>();        <span class="comment">// 输出: T has a member type &#x27;value_type&#x27;.</span></span><br><span class="line">    TypePrinter&lt;WithoutValueType&gt;::<span class="built_in">print</span>();     <span class="comment">// 输出: hello world! T does not have a member type &#x27;value_type&#x27;.</span></span><br><span class="line">    TypePrinter&lt;WithVoidValueType&gt;::<span class="built_in">print</span>();    <span class="comment">// 输出: hello world! T does not have a member type &#x27;value_type&#x27;.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>代码解释</strong></p>
<ol>
<li><strong>Trait <code>has_non_void_value_type</code></strong>:<ul>
<li><strong>主模板</strong>：默认情况下，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::false_type</code>，表示 <code>T</code> 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>。</li>
<li><strong>特化模板</strong>：仅当 <code>T</code> 有 <code>value_type</code> 且 <code>value_type</code> 不是 <code>void</code> 时，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::true_type</code>。</li>
</ul>
</li>
<li><strong><code>TypePrinter</code> 模板</strong>:<ul>
<li><strong>主模板</strong>：接受一个类型 <code>T</code> 和一个布尔模板参数 <code>HasValueType</code>，默认为 <code>has_non_void_value_type&lt;T&gt;::value</code>。</li>
<li>**特化版本 <code>TypePrinter&lt;T, true&gt;</code>**：当 <code>HasValueType</code> 为 <code>true</code> 时，表示 <code>T</code> 有非 <code>void</code> 的 <code>value_type</code>，提供相应的 <code>print</code> 实现。</li>
<li>**特化版本 <code>TypePrinter&lt;T, false&gt;</code>**：当 <code>HasValueType</code> 为 <code>false</code> 时，表示 <code>T</code> 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>，提供默认的 <code>print</code> 实现。</li>
</ul>
</li>
<li><strong>测试结构体</strong>：<ul>
<li><code>WithValueType</code>：有一个非 <code>void</code> 的 <code>value_type</code>。</li>
<li><code>WithoutValueType</code>：没有 <code>value_type</code>。</li>
<li><code>WithVoidValueType</code>：有一个 <code>value_type</code>，但它是 <code>void</code>。</li>
</ul>
</li>
<li><strong><code>main</code> 函数</strong>：<ul>
<li>分别测试了三种情况，验证 <code>TypePrinter</code> 的行为是否符合预期。</li>
</ul>
</li>
</ol>
<h3 id="五、SFINAE的优缺点"><a href="#五、SFINAE的优缺点" class="headerlink" title="五、SFINAE的优缺点"></a>五、SFINAE的优缺点</h3><p><strong>优点</strong>：</p>
<ol>
<li><strong>灵活性高</strong>：能够根据类型特性选择不同的实现，提升代码的泛化能力。</li>
<li><strong>类型安全</strong>：通过编译期检测，避免了运行时错误。</li>
<li><strong>无需额外的运行时开销</strong>：所有的类型筛选都在编译期完成。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>复杂性高</strong>：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。</li>
<li><strong>编译器错误信息难以理解</strong>：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。</li>
<li><strong>模板实例化深度限制</strong>：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。</li>
</ol>
<h3 id="六、现代C-中的替代方案"><a href="#六、现代C-中的替代方案" class="headerlink" title="六、现代C++中的替代方案"></a>六、现代C++中的替代方案</h3><p>随着C++11及后续标准的发展，引入了诸如<code>decltype</code>、<code>constexpr</code>、<code>if constexpr</code>、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的<strong>概念（Concepts）</strong>提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。</p>
<p><strong>示例：使用概念替代SFINAE</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个概念，要求类型 T 是整数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当 T 满足 Integral 概念时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_type</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_type</span>(<span class="number">42</span>);        <span class="comment">// 输出: Integral type: 42</span></span><br><span class="line">    <span class="comment">// print_type(3.14);   // 编译错误，不满足 Integral 概念</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li>使用概念<code>Integral</code>代替<code>std::enable_if</code>，语法更简洁，代码更易读。</li>
<li>当类型不满足概念时，编译器会给出明确的错误信息，便于调试。</li>
</ul>
<p>虽然上述方法经典且有效，但在C++11及以后版本，存在更简洁和易读的方式来实现相同的功能。例如，使用<code>std::void_t</code>和更现代的检测技巧，或者直接使用C++20的概念（Concepts），使代码更加清晰。</p>
<p><strong>示例：使用<code>std::void_t</code>简化<code>has_foo</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::void_t 简化 has_foo</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = std::<span class="type">void_t</span>&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> has_foo : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_foo</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">foo</span>())&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数仅在 T 有 foo() 成员时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;has_foo&lt;T&gt;::value, <span class="type">void</span>&gt;</span><br><span class="line"><span class="built_in">call_foo</span>(T&amp; obj) &#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutFoo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf); <span class="comment">// 输出: WithFoo::foo()</span></span><br><span class="line">                   <span class="comment">//      foo() called.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithoutFoo wf2;</span></span><br><span class="line">    <span class="comment">// call_foo(wf2); // 编译错误，没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li>利用<code>std::void_t</code>，<code>has_foo</code>结构更为简洁。</li>
<li><code>decltype(std::declval&lt;T&gt;().foo())</code>尝试在不实例化<code>T</code>对象的情况下检测<code>foo()</code>成员函数。</li>
<li>如果<code>foo()</code>存在，<code>has_foo&lt;T&gt;</code>继承自<code>std::true_type</code>，否则继承自<code>std::false_type</code>。</li>
</ul>
<p><strong>使用C++20概念</strong></p>
<p>如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个概念，要求类型 T 具有 void foo()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> HasFoo = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">    &#123; t.<span class="built_in">foo</span>() &#125; -&gt; std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当 T 满足 HasFoo 概念时启用</span></span><br><span class="line"><span class="keyword">template</span> &lt;HasFoo T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutFoo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf); <span class="comment">// 输出: WithFoo::foo()</span></span><br><span class="line">                   <span class="comment">//      foo() called.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithoutFoo wf2;</span></span><br><span class="line">    <span class="comment">// call_foo(wf2); // 编译错误，不满足 HasFoo 概念</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li><strong><code>HasFoo</code>概念</strong>：使用<code>requires</code>表达式检测类型<code>T</code>是否具有<code>void foo()</code>成员函数。</li>
<li><strong><code>call_foo</code>函数模板</strong>：仅当<code>T</code>满足<code>HasFoo</code>概念时，模板被启用。</li>
<li>这种方式更直观，易于理解和维护。</li>
</ul>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。</p>
<hr>
<h2 id="综合案例：结合模板特化与折叠表达式"><a href="#综合案例：结合模板特化与折叠表达式" class="headerlink" title="综合案例：结合模板特化与折叠表达式"></a>综合案例：结合模板特化与折叠表达式</h2><p>为了进一步巩固对模板特化和折叠表达式的理解，本节将通过一个综合案例展示如何将两者结合使用。</p>
<h3 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h3><p>实现一个通用的日志记录器<code>Logger</code>，能够处理任意数量和类型的参数，并根据不同的类型组合调整输出格式。具体需求包括：</p>
<ol>
<li>对于普通类型，使用通用的打印格式。</li>
<li>对于指针类型，打印指针地址或指向的值。</li>
<li>对于<code>std::string</code>类型，使用专门的格式。</li>
<li>支持可变数量的参数，通过折叠表达式实现参数的逐一打印。</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>**定义通用类模板<code>Logger</code>**，使用模板特化和偏特化处理不同类型。</li>
<li><strong>实现<code>log</code>函数</strong>，使用模板折叠表达式逐一打印参数。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Logger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">log</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Logger: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板偏特化：当 T 是指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;T, <span class="keyword">typename</span> std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板全特化：当 T 是 std::string</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Logger: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板，用于递归调用 Logger::log</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logOne</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    Logger&lt;T&gt;::<span class="built_in">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板折叠表达式实现多参数日志记录</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">logOne</span>(args), ...); <span class="comment">// 左折叠，调用 logOne 对每个参数进行日志记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;a;</span><br><span class="line">    <span class="type">double</span>* pNull = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Logger 类模板进行特化打印</span></span><br><span class="line">    Logger&lt;<span class="type">int</span>&gt;::<span class="built_in">log</span>(a);          <span class="comment">// 输出：General Logger: 10</span></span><br><span class="line">    Logger&lt;<span class="type">double</span>*&gt;::<span class="built_in">log</span>(pNull);  <span class="comment">// 输出：Pointer Logger: nullptr</span></span><br><span class="line">    Logger&lt;std::string&gt;::<span class="built_in">log</span>(s);  <span class="comment">// 输出：String Logger: &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nLogging multiple parameters:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">logAll</span>(a, b, s, ptr, pNull);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    General Logger: 10</span></span><br><span class="line"><span class="comment">    General Logger: 3.14</span></span><br><span class="line"><span class="comment">    String Logger: &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment">    Pointer Logger: 10</span></span><br><span class="line"><span class="comment">    Pointer Logger: nullptr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">General Logger:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Pointer Logger:</span> <span class="string">nullptr</span></span><br><span class="line"><span class="attr">String Logger:</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Logging multiple parameters:</span></span><br><span class="line"><span class="attr">General Logger:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">General Logger:</span> <span class="number">3.14</span></span><br><span class="line"><span class="attr">String Logger:</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="attr">Pointer Logger:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Pointer Logger:</span> <span class="string">nullptr</span></span><br></pre></td></tr></table></figure>



<h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><ol>
<li>**通用模板<code>Logger&lt;T, Enable&gt;</code>**：<ul>
<li>使用第二个模板参数<code>Enable</code>与SFINAE（Substitution Failure Is Not An Error）结合，控制模板特化。</li>
<li>对于非指针类型和非<code>std::string</code>类型，使用通用实现，打印<code>&quot;General Logger: value&quot;</code>。</li>
</ul>
</li>
<li>**类模板偏特化<code>Logger&lt;T, Enable&gt;</code>**：<ul>
<li>使用<code>std::enable_if</code>和<code>std::is_pointer</code>，当<code>T</code>是指针类型时，特化模板。</li>
<li>实现指针类型的特殊日志处理，打印指针指向的值或<code>nullptr</code>。</li>
</ul>
</li>
<li>**类模板全特化<code>Logger&lt;std::string&gt;</code>**：<ul>
<li>为<code>std::string</code>类型提供全特化版本，使用不同的输出格式。</li>
</ul>
</li>
<li><strong><code>logOne</code>函数模板</strong>：<ul>
<li>简化调用过程，调用相应的<code>Logger&lt;T&gt;::log</code>方法。</li>
</ul>
</li>
<li><strong><code>logAll</code>函数模板</strong>：<ul>
<li>使用模板折叠表达式<code>(logOne(args), ...)</code>，实现对所有参数的逐一日志记录。</li>
<li>通过左折叠的逗号表达式，确保每个<code>logOne</code>调用依次执行。</li>
</ul>
</li>
<li><strong><code>main</code>函数</strong>：<ul>
<li>测试不同类型的日志记录，包括普通类型、指针类型和<code>std::string</code>类型。</li>
<li>调用<code>logAll</code>函数，实现多参数的综合日志记录。</li>
</ul>
</li>
</ol>
<h2 id="模板元编程（Template-Metaprogramming）"><a href="#模板元编程（Template-Metaprogramming）" class="headerlink" title="模板元编程（Template Metaprogramming）"></a>模板元编程（Template Metaprogramming）</h2><ul>
<li><strong>什么是模板元编程</strong>：模板元编程（Template Metaprogramming）是一种在编译期通过模板机制进行代码生成和计算的编程技术。它利用编译器的模板实例化机制，在编译期间执行代码逻辑，以提高程序的性能和灵活性。</li>
<li><strong>模板元编程的优势</strong>：<ul>
<li>提高代码的可重用性和泛化能力。</li>
<li>在编译期进行复杂计算，减少运行时开销。</li>
<li>实现类型安全的高级抽象。</li>
</ul>
</li>
</ul>
<h3 id="模板元编程基础"><a href="#模板元编程基础" class="headerlink" title="模板元编程基础"></a>模板元编程基础</h3><ul>
<li><strong>模板特化（Template Specialization）</strong>：<ul>
<li><strong>全特化（Full Specialization）</strong>：为特定类型提供特定实现。</li>
<li><strong>偏特化（Partial Specialization）</strong>：为部分模板参数特定的情况提供实现。</li>
</ul>
</li>
<li><strong>递归模板（Recursive Templates）</strong>：利用模板的递归实例化机制，实现编译期计算。</li>
</ul>
<h3 id="编译期计算"><a href="#编译期计算" class="headerlink" title="编译期计算"></a>编译期计算</h3><p>模板元编程允许在编译时执行计算，如计算阶乘、斐波那契数列等。</p>
<p><strong>示例：编译期阶乘</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5! = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：5! = 120</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0! = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">0</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：0! = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br><span class="line">0! = 1</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong></p>
<ol>
<li><strong>基本模板</strong> <code>Factorial</code>定义了一个静态常量<code>value</code>，其值为<code>N * Factorial&lt;N - 1&gt;::value</code>，实现递归计算。</li>
<li><strong>特化模板</strong> <code>Factorial&lt;0&gt;</code>定义递归终止条件，当<code>N=0</code>时，<code>value</code>为1。</li>
<li>在<code>main</code>函数中，通过<code>Factorial&lt;5&gt;::value</code>获取5的阶乘结果，编译期即生成其值。</li>
</ol>
<p><strong>示例：编译期斐波那契数列</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci&lt;10&gt; = &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：Fibonacci&lt;10&gt; = 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci&lt;20&gt; = &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">20</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 输出：Fibonacci&lt;20&gt; = 6765</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fibonacci</span>&lt;10&gt; <span class="operator">=</span> <span class="number">55</span></span><br><span class="line"><span class="type">Fibonacci</span>&lt;20&gt; <span class="operator">=</span> <span class="number">6765</span></span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>模板元编程利用编译期计算提升程序性能。</li>
<li>需要理解模板递归与终止条件。</li>
<li>常与类型特性和模板特化结合使用。</li>
</ul>
<h3 id="类型计算与SFINAE"><a href="#类型计算与SFINAE" class="headerlink" title="类型计算与SFINAE"></a>类型计算与SFINAE</h3><ul>
<li><strong>类型计算</strong>：在编译期进行类型的推导和转换。</li>
<li><strong>SFINAE（Substitution Failure Is Not An Error）</strong>：模板实例化过程中，如果某个替换失败，编译器不会报错，而是忽略该模板，并尝试其他匹配。</li>
</ul>
<p><strong>示例：检测类型是否可加</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否可以对T类型进行加法操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> is_addable : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_addable</span>&lt;T, <span class="keyword">decltype</span>(<span class="built_in">void</span>(std::<span class="built_in">declval</span>&lt;T&gt;() + std::<span class="built_in">declval</span>&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">static_assert</span>(is_addable&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int should be addable&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_addable&lt;<span class="type">void</span>*&gt;::value, <span class="string">&quot;void* should not be addable&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>讲解：</strong></p>
<p><strong>1. <code>struct is_addable&lt;...&gt; : std::true_type &#123;&#125;</code></strong></p>
<ul>
<li><strong>目的</strong>：定义一个名为 <code>is_addable</code> 的结构体模板，它继承自 <code>std::true_type</code>。</li>
<li><strong>作用</strong>：当特定的模板参数满足条件时，这个特化版本将被选中，表示 <code>T</code> 类型是可加的，即支持 <code>+</code> 操作符。</li>
</ul>
<p><strong>2. 模板参数解释：<code>&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt;</code></strong></p>
<ul>
<li>**<code>T</code>**：这是要检查的类型。</li>
<li>**<code>std::declval&lt;T&gt;()</code>**：<ul>
<li>用途：<code>std::declval&lt;T&gt;()</code> 是一个用于在不实际创建 <code>T</code> 类型对象的情况下，生成一个 <code>T</code> 类型的右值引用。</li>
<li>作用：它允许我们在编译时模拟 <code>T</code> 类型的对象，以便用于表达式的检测。</li>
</ul>
</li>
<li>**<code>std::declval&lt;T&gt;() + std::declval&lt;T&gt;()</code>**：<ul>
<li>表达式：尝试对两个 <code>T</code> 类型的右值引用进行加法运算。</li>
<li>目的：检查 <code>T</code> 类型是否支持 <code>+</code> 操作符。</li>
</ul>
</li>
<li>**<code>void(...)</code>**：<ul>
<li>将加法表达式的结果转换为 <code>void</code> 类型。这是为了在 <code>decltype</code> 中仅关心表达式是否有效，而不关心其具体类型。</li>
</ul>
</li>
<li>**<code>decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))</code>**：<ul>
<li>作用：如果 <code>T</code> 类型支持加法运算，则该 <code>decltype</code> 表达式的类型为 <code>void</code>，否则会导致替换失败</li>
</ul>
</li>
</ul>
<h3 id="高级模板元编程技巧"><a href="#高级模板元编程技巧" class="headerlink" title="高级模板元编程技巧"></a>高级模板元编程技巧</h3><ul>
<li><strong>变参模板（Variadic Templates）</strong>：支持模板参数包，实现更加灵活的模板定义。</li>
</ul>
<p><strong>示例：求和模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本递归模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;N, Ns...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N + Sum&lt;Ns...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = Sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::value; <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解：</strong></p>
<ol>
<li><strong>基本模板</strong> <code>Sum</code>接受一个整数参数包<code>Ns...</code>。</li>
<li><strong>特化模板</strong> <code>Sum&lt;&gt;</code>定义递归终止条件，<code>value</code>为0。</li>
<li><strong>递归定义</strong> <code>Sum&lt;N, Ns...&gt;</code>将第一个参数<code>N</code>与剩余参数的和相加。</li>
<li>在<code>main</code>函数中，通过<code>Sum&lt;1, 2, 3, 4, 5&gt;::value</code>计算1+2+3+4+5=15。</li>
</ol>
<ul>
<li><strong>类型列表（Type Lists）</strong>：通过模板参数包管理类型的集合。</li>
</ul>
<p><strong>示例：类型列表和元素访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类型列表中第N个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, <span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = Head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> TypeAt&lt;TypeList&lt;Tail...&gt;, N - <span class="number">1</span>&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> list = TypeList&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> third_type = TypeAt&lt;list, <span class="number">2</span>&gt;::type; <span class="comment">// char</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解：</strong></p>
<ol>
<li>**<code>TypeList</code>**：定义一个包含多个类型的类型列表。</li>
<li><code>TypeAt</code>：通过递归模板，从<code>TypeList</code>中获取第N个类型。<ul>
<li>当N为0时，类型为<code>Head</code>。</li>
<li>否则，递归获取<code>Tail...</code>中第N-1个类型。</li>
</ul>
</li>
<li><strong>使用</strong>：定义<code>list</code>为<code>TypeList&lt;int, double, char&gt;</code>，<code>third_type</code>为第2个类型，即<code>char</code>。</li>
</ol>
<h3 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h3><p><strong>案例1：静态断言与类型检查</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_type</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = std::is_integral&lt;T&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">static_assert</span>(is_integral_type&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int is integral&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_integral_type&lt;<span class="type">float</span>&gt;::value, <span class="string">&quot;float is not integral&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>案例2：编译期字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要外部定义 <code>value</code></strong></p>
<p>在 C++ 中，静态成员变量与类的实例无关，它们存在于全局命名空间中。然而，静态成员变量的声明和定义是不同的：</p>
<ol>
<li><strong>声明</strong>：告诉编译器类中存在这个变量。</li>
<li><strong>定义</strong>：为这个变量分配存储空间。</li>
</ol>
<p>对于非 <code>inline</code> 的静态成员变量，即使是 <code>constexpr</code>，都需要在类外部进行定义。否则，链接器在处理多个翻译单元时会因为找不到变量的定义而报错。</p>
<p><strong>具体原因</strong></p>
<ol>
<li><strong>模板类的静态成员变量</strong>：<ul>
<li>每当模板实例化时，都会产生一个新的类类型，每个类类型都有自己的一组静态成员变量。</li>
<li>因此，编译器需要知道这些静态成员变量在所有翻译单元中都唯一对应一个定义。</li>
</ul>
</li>
<li><strong><code>constexpr</code> 静态成员变量</strong>：<ul>
<li>从 C++17 开始，<code>inline</code> 关键字引入，使得 <code>constexpr</code> 静态成员变量可以在类内定义，并且隐式地具有 <code>inline</code> 属性。这意味着不需要在类外定义它们，因为 <code>inline</code> 确保了在多个翻译单元中有同一份定义。</li>
<li>但在 C++17 之前或不使用 <code>inline</code> 的情况下，即使是 <code>constexpr</code>，仍需在类外定义。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>类内声明</strong>：<code>static constexpr char value[...]</code> 声明了 <code>value</code> 并给予了初始值。</li>
<li><strong>类外定义</strong>：<code>constexpr char String&lt;Cs...&gt;::value[...]</code> 为 <code>value</code> 分配了存储空间。</li>
</ul>
<p>如果省略类外定义，编译器会在链接阶段找不到 <code>value</code> 的定义，导致链接错误。这尤其适用于 C++14 及更早版本，以及 C++17 中未使用 <code>inline</code> 的情形。</p>
<p><strong>如何避免外部定义</strong></p>
<p>如果你使用的是 <strong>C++17</strong> 或更高版本，可以通过 <code>inline</code> 关键字将静态成员变量声明为 <code>inline</code>，从而在类内完成定义，无需再在外部定义。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>



<p>在这个版本中，<code>inline</code> 关键字告诉编译器这是一个内联变量，允许在多个翻译单元中存在同一份定义，而不会导致重复定义错误。因此，无需在类外再次定义 <code>value</code>。</p>
<p><strong>完整示例对比</strong></p>
<p><strong>不使用 <code>inline</code>（需要类外定义）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问 value</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; hello::value;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用 <code>inline</code>（无需类外定义，C++17 起）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123; Cs..., <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">using</span> hello = String&lt;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问 value</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; hello::value;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-20-Concepts"><a href="#C-20-Concepts" class="headerlink" title="C++20 Concepts"></a>C++20 Concepts</h2><p>C++20 引入了 <strong>Concepts</strong>，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。</p>
<h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><p><strong>定义一个 Concept</strong></p>
<p>Concepts 使用 <code>concept</code> 关键字定义，并作为函数或类模板的约束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Concept：要求类型必须是可输出到 std::ostream</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Printable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">    &#123; std::cout &lt;&lt; a &#125; -&gt; std::same_as&lt;std::ostream&amp;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>使用 Concept 约束模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Concepts 约束函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;Printable T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">42</span>);          <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// print(std::vector&lt;int&gt;&#123;1, 2, 3&#125;); // 编译错误，std::vector&lt;int&gt; 不满足 Printable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="限制与约束"><a href="#限制与约束" class="headerlink" title="限制与约束"></a>限制与约束</h3><p>Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。</p>
<p><strong>示例：排序函数中的 Concepts</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可比较的概念</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序函数，约束类型必须可比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortVector</span><span class="params">(std::vector&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sortVector</span>(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：1 2 3 4 </span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::vector&lt;std::vector&lt;int&gt;&gt; vecs;</span></span><br><span class="line">    <span class="comment">// sortVector(vecs); // 编译错误，std::vector&lt;int&gt; 不满足 Comparable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 </span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>Concepts 提供了模板参数的语义约束。</li>
<li>使用 Concepts 提高模板的可读性和可维护性。</li>
<li>生成更友好的编译错误信息，易于调试。</li>
</ul>
<hr>
<h2 id="模板实例化与编译器行为"><a href="#模板实例化与编译器行为" class="headerlink" title="模板实例化与编译器行为"></a>模板实例化与编译器行为</h2><p>理解模板实例化的过程有助于进行有效的模板设计与优化，尤其是在涉及链接和编译时间时。</p>
<h3 id="显式实例化（Explicit-Instantiation）"><a href="#显式实例化（Explicit-Instantiation）" class="headerlink" title="显式实例化（Explicit Instantiation）"></a>显式实例化（Explicit Instantiation）</h3><p>显式实例化告诉编译器生成特定类型下的模板代码，主要用于分离模板的声明与定义，减少编译时间。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明模板（通常在头文件中）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模板（通常在源文件中）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>



<p><strong>示例：分离类模板的声明与定义</strong></p>
<p><em>MyClass.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure>



<p><em>MyClass.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">doSomething</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something with &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure>



<p><em>main.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with i</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyClass&lt;char&gt; obj3; // 链接错误，因为 MyClass&lt;char&gt; 未实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing something <span class="keyword">with</span> i</span><br><span class="line">Doing something <span class="keyword">with</span> d</span><br></pre></td></tr></table></figure>



<p><strong>注意事项：</strong></p>
<ul>
<li>显式实例化需要在模板定义后进行。</li>
<li>只有显式实例化的类型在未实例化时可用于模板分离。</li>
<li>未显式实例化的类型可能导致链接错误。</li>
</ul>
<h3 id="隐式实例化（Implicit-Instantiation）"><a href="#隐式实例化（Implicit-Instantiation）" class="headerlink" title="隐式实例化（Implicit Instantiation）"></a>隐式实例化（Implicit Instantiation）</h3><p>隐式实例化是编译器在模板被实际使用时自动生成对应实例代码的过程。通常，模板定义与使用都在头文件中完成。</p>
<p><strong>示例：</strong></p>
<p><em>MyClass.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something with &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure>



<p><em>main.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with i</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with d</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">char</span>&gt; obj3;</span><br><span class="line">    obj3.<span class="built_in">doSomething</span>(); <span class="comment">// 输出：Doing something with c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Doing something <span class="keyword">with</span> i</span><br><span class="line">Doing something <span class="keyword">with</span> d</span><br><span class="line">Doing something <span class="keyword">with</span> c</span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>隐式实例化不需要显式声明或定义。</li>
<li>模板定义必须在使用前可见，通常通过头文件实现。</li>
<li>容易导致编译时间增加，尤其是大型模板库。</li>
</ul>
<h3 id="链接时问题与解决方案"><a href="#链接时问题与解决方案" class="headerlink" title="链接时问题与解决方案"></a>链接时问题与解决方案</h3><p>由于模板是在使用时被实例化，跨源文件使用模板可能导致链接时问题，如重复定义或未定义引用。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>内联实现</strong>：将模板的定义与声明一起放在头文件中，避免链接时重复定义。</li>
<li><strong>显式实例化</strong>：将常用的模板实例化放在源文件中，其他源文件通过 <code>extern</code> 或头文件引用已有实例。</li>
<li>**使用 <code>extern template</code>**：告知编译器某些模板实例已在其他源文件中显式实例化。</li>
</ol>
<p><strong>示例：使用 <code>extern template</code></strong></p>
<p><em>MyClass.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明模板实例，但不定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure>



<p><em>MyClass.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">doSomething</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something with &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure>



<p><em>main.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">doSomething</span>(); <span class="comment">// 使用已显式实例化的模板</span></span><br><span class="line"></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">doSomething</span>(); <span class="comment">// 使用已显式实例化的模板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyClass&lt;char&gt; obj3; // 链接错误，未实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>要点：</strong></p>
<ul>
<li>使用 <code>extern template</code> 声明已在其他源文件中实例化的模板。</li>
<li>减少编译时间和链接大小，防止重复定义。</li>
</ul>
<hr>
<h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><p>掌握模板的最佳实践有助于编写高效、可维护的代码，同时避免常见的陷阱和问题。</p>
<h3 id="模板定义与实现分离"><a href="#模板定义与实现分离" class="headerlink" title="模板定义与实现分离"></a>模板定义与实现分离</h3><p>对于类模板，通常将模板的声明和定义放在同一头文件中，以确保编译器在实例化模板时能够看到完整的定义。尽管可以尝试将模板定义分离到源文件，但需要结合显式实例化，这会增加复杂性，且不适用于广泛使用的模板。</p>
<p><strong>推荐做法：</strong></p>
<ul>
<li><strong>类模板</strong>：将声明和实现统一在头文件中。</li>
<li><strong>函数模板</strong>：同样将声明和实现统一在头文件中，或使用显式实例化。</li>
</ul>
<h3 id="避免过度模板化"><a href="#避免过度模板化" class="headerlink" title="避免过度模板化"></a>避免过度模板化</h3><p>虽然模板提供了极大的灵活性，但过度复杂的模板会导致代码难以理解、维护和编译时间增加。</p>
<p><strong>建议：</strong></p>
<ul>
<li>只在必要时使用模板。</li>
<li>保持模板的简单性和可读性，避免过度嵌套和复杂的特化。</li>
<li>合理使用类型特性和 Concepts 进行约束。</li>
</ul>
<h3 id="提高编译速度的方法"><a href="#提高编译速度的方法" class="headerlink" title="提高编译速度的方法"></a>提高编译速度的方法</h3><p>模板的广泛使用可能导致编译时间显著增加。以下方法有助于优化编译速度：</p>
<ol>
<li><strong>预编译头文件（Precompiled Headers）</strong>：将频繁使用的模板库放入预编译头中，加速编译。</li>
<li><strong>显式实例化</strong>：通过显式实例化减少模板的重复编译。</li>
<li><strong>模块化编程（C++20 Modules）</strong>：利用模块化将模板库进行编译和链接，减少编译时间。</li>
<li><strong>合理分割头文件</strong>：避免头文件中的模板定义过大，分割成较小的模块。</li>
</ol>
<h3 id="代码复用与库设计"><a href="#代码复用与库设计" class="headerlink" title="代码复用与库设计"></a>代码复用与库设计</h3><p>模板是实现高度复用库组件的有效手段，如标准库（<code>std::vector</code>、<code>std::map</code> 等）广泛使用模板。设计模板库时，需考虑以下因素：</p>
<ul>
<li><strong>接口的一致性</strong>：保持模板库的接口简洁、一致，便于使用者理解和使用。</li>
<li><strong>文档与示例</strong>：提供详细的文档和示例代码，帮助使用者理解模板库的用法。</li>
<li><strong>错误信息友好</strong>：通过 Concepts、SFINAE 等机制提供清晰的错误信息，降低使用门槛。</li>
<li><strong>性能优化</strong>：利用模板的编译期计算和内联等特性，提高库组件的性能。</li>
</ul>
<h3 id="避免模板错误的困惑"><a href="#避免模板错误的困惑" class="headerlink" title="避免模板错误的困惑"></a>避免模板错误的困惑</h3><p>模板错误通常复杂且难以理解，以下方法有助于减少模板错误的困惑：</p>
<ul>
<li><strong>逐步调试</strong>：从简单的模板开始，逐步增加复杂性，便于定位错误。</li>
<li><strong>使用编译器警告与工具</strong>：开启编译器的警告选项，使用静态分析工具检测模板代码中的问题。</li>
<li><strong>代码注释与文档</strong>：详细注释复杂的模板代码，提供文档说明其设计和用途。</li>
</ul>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C++ 模板机制是实现泛型编程的核心工具，通过类型参数化和编译期计算，极大地提升了代码的复用性、灵活性和性能。从基础的函数模板和类模板，到高级的模板特化、变参模板、模板元编程、SFINAE 和 Concepts，掌握模板的各个方面能够帮助开发者编写更高效、更加通用的 C++ 代码。</p>
<p>在实际应用中，合理运用模板不仅可以简化代码结构，还可以提高代码的可维护性和可扩展性。然而，模板的复杂性也要求开发者具备扎实的 C++ 基础和良好的编程习惯，以避免过度复杂化和难以调试的问题。</p>
<p>通过本教案的系统学习，相信您已经具备了全面理解和运用 C++ 模板的能力，能够在实际项目中高效地利用模板特性，编写出更为优秀的代码。</p>
<hr>
<h2 id="练习与习题"><a href="#练习与习题" class="headerlink" title="练习与习题"></a>练习与习题</h2><h3 id="练习-1：实现一个通用的-Swap-函数模板"><a href="#练习-1：实现一个通用的-Swap-函数模板" class="headerlink" title="练习 1：实现一个通用的 Swap 函数模板"></a>练习 1：实现一个通用的 Swap 函数模板</h3><p><strong>要求：</strong></p>
<ul>
<li>编写一个函数模板 <code>swapValues</code>，可以交换任意类型的两个变量。</li>
<li>在 <code>main</code> 函数中测试 <code>int</code>、<code>double</code>、<code>std::string</code> 类型的交换。</li>
</ul>
<p><strong>提示：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。"><a href="#练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。" class="headerlink" title="练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。"></a>练习 2：实现一个模板类 <code>Triple</code>，存储三个相同类型的值，并提供获取各个成员的函数。</h3><p><strong>要求：</strong></p>
<ul>
<li>模板参数为类型 <code>T</code>。</li>
<li>提供构造函数、成员变量及访问函数。</li>
<li>在 <code>main</code> 中实例化 <code>Triple&lt;int&gt;</code> 和 <code>Triple&lt;std::string&gt;</code>，进行测试。</li>
</ul>
<h3 id="练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。"><a href="#练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。" class="headerlink" title="练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。"></a>练习 3：使用模板特化，为类模板 <code>Printer</code> 提供针对 <code>bool</code> 类型的全特化，实现专门的输出格式。</h3><p><strong>要求：</strong></p>
<ul>
<li>通用模板类 <code>Printer</code>，具有 <code>print</code> 函数，输出 <code>General Printer: value</code>。</li>
<li>全特化 <code>Printer&lt;bool&gt;</code>，输出 <code>Boolean Printer: true</code> 或 <code>Boolean Printer: false</code>。</li>
</ul>
<h3 id="练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。"><a href="#练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。" class="headerlink" title="练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。"></a>练习 4：实现一个变参模板函数 <code>logMessages</code>，可以接受任意数量和类型的参数，并依次打印它们。</h3><p><strong>要求：</strong></p>
<ul>
<li>使用递归方法实现。</li>
<li>在 <code>main</code> 中测试不同参数组合的调用。</li>
</ul>
<h3 id="练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。"><a href="#练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。" class="headerlink" title="练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。"></a>练习 5：编写模板元编程结构 <code>IsPointer</code>, 用于在编译期判断一个类型是否为指针类型。</h3><p><strong>要求：</strong></p>
<ul>
<li>定义 <code>IsPointer&lt;T&gt;</code>，包含 <code>value</code> 静态常量成员，值为 <code>true</code> 或 <code>false</code>。</li>
<li>使用特化进行实现。</li>
<li>在 <code>main</code> 中使用 <code>static_assert</code> 进行测试。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsPointer&lt;<span class="type">int</span>*&gt;::value, <span class="string">&quot;int* is a pointer&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!IsPointer&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int is not a pointer&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。"><a href="#练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。" class="headerlink" title="练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。"></a>练习 6：使用 SFINAE，编写一个函数模板 <code>enableIfExample</code>，只有当类型 <code>T</code> 具有 <code>size()</code> 成员函数时才启用。</h3><p><strong>要求：</strong></p>
<ul>
<li>使用 <code>std::enable_if</code> 和类型特性检测 <code>size()</code> 成员。</li>
<li>在 <code>main</code> 中测试 <code>std::vector&lt;int&gt;</code>（应启用）和 <code>int</code>（不应启用）。</li>
</ul>
<p><strong>提示：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_size&lt;T&gt;::value, <span class="type">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">enableIfExample</span><span class="params">(<span class="type">const</span> T&amp; container)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Container has size: &quot;</span> &lt;&lt; container.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。"><a href="#练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。" class="headerlink" title="练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。"></a>练习 7：使用 C++20 Concepts，定义一个 Concept <code>Integral</code>，要求类型必须是整型，并使用该 Concept 约束一个函数模板 <code>isEven</code>，判断传入的整数是否为偶数。</h3><p><strong>要求：</strong></p>
<ul>
<li>定义 <code>Integral</code> Concept。</li>
<li>编写函数模板 <code>isEven(u)</code>，仅接受满足 <code>Integral</code> 的类型。</li>
<li>在 <code>main</code> 中测试不同类型的调用。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"><a href="#练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。" class="headerlink" title="练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"></a>练习 8：实现一个固定大小的栈（<code>FixedStack</code>）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。</h3><p><strong>要求：</strong></p>
<ul>
<li>模板参数为类型 <code>T</code> 和 <code>std::size_t N</code>。</li>
<li>提供 <code>push</code>, <code>pop</code>, <code>top</code> 等成员函数。</li>
<li>在 <code>main</code> 中测试 <code>FixedStack&lt;int, 5&gt;</code> 和 <code>FixedStack&lt;std::string, 3&gt;</code>。</li>
</ul>
<h3 id="练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。"><a href="#练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。" class="headerlink" title="练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。"></a>练习 9：实现一个模板类 <code>TypeIdentity</code>，其成员类型 <code>type</code> 等同于模板参数 <code>T</code>。并使用 <code>static_assert</code> 检查类型关系。</h3><p><strong>要求：</strong></p>
<ul>
<li>定义 <code>TypeIdentity&lt;T&gt;</code>，包含类型成员 <code>type</code>。</li>
<li>使用 <code>std::is_same</code> 与 <code>static_assert</code> 验证。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;TypeIdentity&lt;<span class="type">int</span>&gt;::type, <span class="type">int</span>&gt;::value, <span class="string">&quot;TypeIdentity&lt;int&gt; should be int&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。"><a href="#练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。" class="headerlink" title="练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。"></a>练习 10：编写一个模板元编程结构 <code>LengthOf</code>, 用于在编译期计算类型列表的长度。</h3><p><strong>要求：</strong></p>
<ul>
<li>使用 <code>TypeList</code> 模板定义类型列表。</li>
<li>定义 <code>LengthOf&lt;TypeList&lt;...&gt;&gt;::value</code> 表示类型列表的长度。</li>
<li>在 <code>main</code> 中使用 <code>static_assert</code> 进行测试。</li>
</ul>
<p><strong>提示：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>&lt;TypeList&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> value = <span class="keyword">sizeof</span>...(Ts);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<p>通过上述内容及练习，相信您已全面掌握了 C++ 模板的各个方面。从基础概念到高级技术，模板为 C++ 编程提供了强大的工具。持续练习与应用，将进一步巩固您的模板编程能力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2025/01/23/cppbase30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/23/cppbase30/" itemprop="url">运算符重载详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-01-23T19:57:06+08:00">
                2025-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="运算符重载概述"><a href="#运算符重载概述" class="headerlink" title="运算符重载概述"></a>运算符重载概述</h2><p><strong>运算符重载（Operator Overloading）</strong>允许开发者为自定义类型定义或重新定义运算符的行为，使得自定义类型的对象能够使用与内置类型相同的运算符进行操作。这不仅提高了代码的可读性，还增强了代码的表达能力。</p>
<h2 id="为什么需要运算符重载"><a href="#为什么需要运算符重载" class="headerlink" title="为什么需要运算符重载"></a>为什么需要运算符重载</h2><p>在面向对象编程中，我们经常需要定义自己的类来表示某些实体（如复数、向量、矩形等）。为了使这些类的对象能够与内置类型一样方便地进行操作，运算符重载显得尤为重要。例如：</p>
<ul>
<li>对于复数类，使用 <code>+</code> 运算符进行加法运算。</li>
<li>对于字符串类，使用 <code>&lt;&lt;</code> 运算符进行输出。</li>
<li>对于矩阵类，使用 <code>*</code> 运算符进行矩阵乘法。</li>
</ul>
<p>通过运算符重载，可以使代码更简洁、直观，类似于数学表达式。</p>
<h2 id="运算符重载的规则与限制"><a href="#运算符重载的规则与限制" class="headerlink" title="运算符重载的规则与限制"></a>运算符重载的规则与限制</h2><ol>
<li><strong>不能改变运算符的优先级和结合性</strong>：运算符的优先级和结合性在编译阶段就确定，不能通过重载来改变。</li>
<li><strong>不能创建新的运算符</strong>：仅能重载C++中已有的运算符，不能定义新的运算符。</li>
<li><strong>至少有一个操作数必须是用户定义的类型</strong>：不能对两个内置类型进行运算符重载。</li>
<li><strong>某些运算符不能重载</strong>：包括 <code>.</code>（成员选择运算符）、<code>.*</code>、<code>::</code>、<code>?:</code>（条件运算符）等。</li>
<li><strong>重载运算符的优先级和结合性不可改变</strong>。</li>
</ol>
<h2 id="运算符重载的方法"><a href="#运算符重载的方法" class="headerlink" title="运算符重载的方法"></a>运算符重载的方法</h2><p>在C++中，运算符可以通过成员函数或非成员函数（通常是友元函数）来重载。</p>
<h3 id="成员函数方式"><a href="#成员函数方式" class="headerlink" title="成员函数方式"></a>成员函数方式</h3><p>运算符作为类的成员函数进行重载时，左操作数是当前对象（<code>this</code>）。因此，对于需要修改左操作数的运算符，成员函数方式通常更直观。</p>
<p><strong>语法示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassName <span class="keyword">operator</span>+(<span class="type">const</span> ClassName&amp; other);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="非成员函数方式（友元函数）"><a href="#非成员函数方式（友元函数）" class="headerlink" title="非成员函数方式（友元函数）"></a>非成员函数方式（友元函数）</h3><p>当需要对两个不同类型的对象进行运算，或者左操作数不是当前类的对象时，通常使用非成员函数方式。为了访问类的私有成员，非成员函数通常被声明为类的友元函数。</p>
<p><strong>语法示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> ClassName <span class="keyword">operator</span>+(<span class="type">const</span> ClassName&amp; lhs, <span class="type">const</span> ClassName&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><h3 id="1-1-运算符"><a href="#1-1-运算符" class="headerlink" title="1.1 + 运算符"></a>1.1 <code>+</code> 运算符</h3><p><strong>作用</strong>：实现两个对象的加法操作。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real + other.real, <span class="keyword">this</span>-&gt;imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">    <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 + c2 = (<span class="number">4.5</span> + <span class="number">1.5i</span>)</span><br></pre></td></tr></table></figure>



<h3 id="1-2-运算符"><a href="#1-2-运算符" class="headerlink" title="1.2 - 运算符"></a>1.2 <code>-</code> 运算符</h3><p><strong>作用</strong>：实现两个对象的减法操作。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 - 运算符（成员函数）</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real - other.real, <span class="keyword">this</span>-&gt;imag - other.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.5</span>, <span class="number">-1.5</span>)</span></span>;</span><br><span class="line">    Complex c4 = c1 - c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span> &lt;&lt; c4 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 - c2 = (<span class="number">2.5</span> + <span class="number">7.5i</span>)</span><br></pre></td></tr></table></figure>



<h3 id="1-3-运算符"><a href="#1-3-运算符" class="headerlink" title="1.3 * 运算符"></a>1.3 <code>*</code> 运算符</h3><p><strong>作用</strong>：实现对象的乘法操作。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 * 运算符（成员函数）</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">    <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    Complex c5 = c1 * c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span> &lt;&lt; c5 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 * c2 = (<span class="number">13.5</span> + <span class="number">1i</span>)</span><br></pre></td></tr></table></figure>



<h3 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 / 运算符"></a>1.4 <code>/</code> 运算符</h3><p><strong>作用</strong>：实现对象的除法操作。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 / 运算符（成员函数）</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">    <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Complex c6 = c1 / c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span> &lt;&lt; c6 &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 / c2 = (<span class="number">-0.823529</span> + <span class="number">1.64706i</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2. 赋值运算符"></a>2. 赋值运算符</h2><h3 id="2-1-运算符"><a href="#2-1-运算符" class="headerlink" title="2.1 = 运算符"></a>2.1 <code>=</code> 运算符</h3><p><strong>作用</strong>：实现对象的赋值操作。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<p>C++编译器会自动生成默认的拷贝赋值运算符，但当类中包含动态分配内存或需要自定义行为时，需要自行重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符（成员函数）</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;real = other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">    <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    Complex c2;</span><br><span class="line">    c2 = c1; <span class="comment">// 使用拷贝赋值运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c2 = &quot;</span> &lt;&lt; c2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">c2</span> = (<span class="number">3</span> + <span class="number">4</span>i)</span><br></pre></td></tr></table></figure>



<h3 id="2-2-复合赋值运算符（-）"><a href="#2-2-复合赋值运算符（-）" class="headerlink" title="2.2 复合赋值运算符（+=, -=, *=, /=）"></a>2.2 复合赋值运算符（<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>）</h3><p><strong>作用</strong>：实现复合赋值操作，如 <code>+=</code>，<code>-=</code> 等。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 += 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real += other.real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag += other.imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 -= 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real -= other.real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag -= other.imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 *= 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">    <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 /= 运算符（成员函数）</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">    <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">    <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    c1 += c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 += c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    c1 -= c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 -= c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    c1 *= c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 *= c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c1 /= c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 /= c2: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 += c2: (<span class="number">4</span> + <span class="number">6i</span>)</span><br><span class="line">c1 -= c2: (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">c1 *= c2: (<span class="number">-5</span> + <span class="number">10i</span>)</span><br><span class="line">c1 /= c2: (<span class="number">2</span> + <span class="number">0i</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3. 比较运算符"></a>3. 比较运算符</h2><h3 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 == 运算符"></a>3.1 <code>==</code> 运算符</h3><p><strong>作用</strong>：判断两个对象是否相等。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 == 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 == 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="built_in">return</span> (lhs.real == rhs.real) &amp;&amp; (lhs.imag == rhs.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 == c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 和 c2 相等</span><br><span class="line">c1 和 c3 不相等</span><br></pre></td></tr></table></figure>



<h3 id="3-2-运算符"><a href="#3-2-运算符" class="headerlink" title="3.2 != 运算符"></a>3.2 <code>!=</code> 运算符</h3><p><strong>作用</strong>：判断两个对象是否不相等。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 != 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 != 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 != c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 != c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 和 c3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 和 c2 相等</span><br><span class="line">c1 和 c3 不相等</span><br></pre></td></tr></table></figure>



<h3 id="3-3-lt-gt-lt-gt-运算符"><a href="#3-3-lt-gt-lt-gt-运算符" class="headerlink" title="3.3 &lt;, &gt;, &lt;=, &gt;= 运算符"></a>3.3 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> 运算符</h3><p><strong>作用</strong>：实现对象之间的大小比较。对于复数来说，通常没有自然的大小顺序，但为了示例，可以定义复数的模长进行比较。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt; 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &gt; 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;= 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &gt;= 运算符（友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt; 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="type">double</span> lhs_mod = std::<span class="built_in">sqrt</span>(lhs.real * lhs.real + lhs.imag * lhs.imag);</span><br><span class="line">    <span class="type">double</span> rhs_mod = std::<span class="built_in">sqrt</span>(rhs.real * rhs.real + rhs.imag * rhs.imag);</span><br><span class="line">    <span class="keyword">return</span> lhs_mod &lt; rhs_mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &gt; 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs &lt; lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;= 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(rhs &lt; lhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &gt;= 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs &lt; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>; <span class="comment">// 模长 5</span></span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>; <span class="comment">// 模长 sqrt(5) ≈ 2.236</span></span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>; <span class="comment">// 模长 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &lt; c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长小于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长不小于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长不大于 c2 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &lt;= c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长小于或等于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt;= c3)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于或等于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长小于 c3 的模长&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 的模长不小于 c2 的模长</span><br><span class="line">c1 的模长大于 c2 的模长</span><br><span class="line">c1 的模长小于或等于 c3 的模长</span><br><span class="line">c1 的模长大于或等于 c3 的模长</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h2><h3 id="4-1-amp-amp-运算符"><a href="#4-1-amp-amp-运算符" class="headerlink" title="4.1 &amp;&amp;, ||, ! 运算符"></a>4.1 <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> 运算符</h3><p><strong>作用</strong>：实现逻辑操作。需要注意，C++ 中的 <code>&amp;&amp;</code> 和 <code>||</code> 运算符无法短路地重载，而且通常不建议重载它们，因为会改变其原有的逻辑语义。通常，建议使用类型转换或其他方法来实现逻辑判断。</p>
<p><strong>示例类</strong>：<code>Boolean</code> 类（用于示例）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boolean</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Boolean</span>(<span class="type">bool</span> val = <span class="literal">false</span>) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑非运算符（!）（成员函数）</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑与运算符（&amp;）（非短路）（成员函数）</span></span><br><span class="line">    Boolean <span class="keyword">operator</span>&amp;(<span class="type">const</span> Boolean&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="keyword">this</span>-&gt;value &amp; other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑或运算符（|）（非短路）（成员函数）</span></span><br><span class="line">    Boolean <span class="keyword">operator</span>|(<span class="type">const</span> Boolean&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="keyword">this</span>-&gt;value | other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Boolean&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Boolean&amp; b) &#123;</span><br><span class="line">    os &lt;&lt; (b.value ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Boolean <span class="title">b1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Boolean <span class="title">b2</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Boolean b3 = b1 &amp; b2;</span><br><span class="line">    Boolean b4 = b1 | b2;</span><br><span class="line">    Boolean b5 = !b1;</span><br><span class="line">    Boolean b6 = !b2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 &amp; b2 = &quot;</span> &lt;&lt; b3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 | b2 = &quot;</span> &lt;&lt; b4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!b1 = &quot;</span> &lt;&lt; b5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!b2 = &quot;</span> &lt;&lt; b6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b1</span> <span class="string">&amp;</span> <span class="string">b2</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"><span class="string">b1</span> <span class="string">|</span> <span class="string">b2</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="type">!b1</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"><span class="type">!b2</span> <span class="string">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li><strong>注意</strong>：在重载 <code>&amp;&amp;</code> 和 <code>||</code> 运算符时，要明白它们不会具有短路行为。因此，通常不建议重载这两个运算符。</li>
<li>本例中，使用 <code>&amp;</code> 和 <code>|</code> 运算符来模拟逻辑与、或操作。</li>
</ul>
<hr>
<h2 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h2><h3 id="5-1-amp-运算符"><a href="#5-1-amp-运算符" class="headerlink" title="5.1 &amp;, |, ^, ~ 运算符"></a>5.1 <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code> 运算符</h3><p><strong>作用</strong>：实现位级操作，如按位与、按位或、按位异或、按位取反。</p>
<p><strong>示例类</strong>：<code>Bitmask</code> 类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmask</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Bitmask</span>(<span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">0</span>) : <span class="built_in">bits</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &amp; 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>&amp;(<span class="type">const</span> Bitmask&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits &amp; other.bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 | 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>|(<span class="type">const</span> Bitmask&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits | other.bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 ^ 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>^(<span class="type">const</span> Bitmask&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits ^ other.bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 ~ 运算符（成员函数）</span></span><br><span class="line">    Bitmask <span class="keyword">operator</span>~() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Bitmask</span>(~<span class="keyword">this</span>-&gt;bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Bitmask&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Bitmask&amp; b) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; b.bits &lt;&lt; std::dec;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bitmask <span class="title">bm1</span><span class="params">(<span class="number">0b10101010</span>)</span></span>; <span class="comment">// 0xAA</span></span><br><span class="line">    <span class="function">Bitmask <span class="title">bm2</span><span class="params">(<span class="number">0b11001100</span>)</span></span>; <span class="comment">// 0xCC</span></span><br><span class="line"></span><br><span class="line">    Bitmask bm3 = bm1 &amp; bm2;</span><br><span class="line">    Bitmask bm4 = bm1 | bm2;</span><br><span class="line">    Bitmask bm5 = bm1 ^ bm2;</span><br><span class="line">    Bitmask bm6 = ~bm1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 &amp; bm2 = &quot;</span> &lt;&lt; bm3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 | bm2 = &quot;</span> &lt;&lt; bm4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 ^ bm2 = &quot;</span> &lt;&lt; bm5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~bm1 = &quot;</span> &lt;&lt; bm6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bm1 &amp; bm2 = 0x88</span><br><span class="line">bm1 | bm2 = 0xee</span><br><span class="line">bm1 ^ bm2 = 0x66</span><br><span class="line">~bm1 = 0xffffff55</span><br></pre></td></tr></table></figure>



<h3 id="5-2-lt-lt-gt-gt-位移运算符"><a href="#5-2-lt-lt-gt-gt-位移运算符" class="headerlink" title="5.2 &lt;&lt;, &gt;&gt; 位移运算符"></a>5.2 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> 位移运算符</h3><p><strong>作用</strong>：实现位移操作，如左移、右移。</p>
<p><strong>示例类</strong>：<code>Bitmask</code> 类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt; 运算符（左移，成员函数）</span></span><br><span class="line">Bitmask <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> shift) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits &lt;&lt; shift);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &gt;&gt; 运算符（右移，成员函数）</span></span><br><span class="line">Bitmask <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> shift) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Bitmask</span>(<span class="keyword">this</span>-&gt;bits &gt;&gt; shift);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bitmask <span class="title">bm1</span><span class="params">(<span class="number">0b0001</span>)</span></span>; <span class="comment">// 0x1</span></span><br><span class="line"></span><br><span class="line">    Bitmask bm2 = bm1 &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    Bitmask bm3 = bm1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 &lt;&lt; 3 = &quot;</span> &lt;&lt; bm2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bm1 &gt;&gt; 1 = &quot;</span> &lt;&lt; bm3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bm1 &lt;&lt; <span class="string">3 = 0x8</span></span><br><span class="line"><span class="string">bm1 &gt;&gt; 1 = 0x0</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li>重载位移运算符时，通常接受一个整型参数，表示位移的位数。</li>
</ul>
<hr>
<h2 id="6-自增自减运算符"><a href="#6-自增自减运算符" class="headerlink" title="6. 自增自减运算符"></a>6. 自增自减运算符</h2><h3 id="6-1-前置-和-运算符"><a href="#6-1-前置-和-运算符" class="headerlink" title="6.1 前置 ++ 和 -- 运算符"></a>6.1 前置 <code>++</code> 和 <code>--</code> 运算符</h3><p><strong>作用</strong>：实现对象的自增和自减操作。</p>
<p><strong>示例类</strong>：<code>Counter</code> 类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> c = <span class="number">0</span>) : <span class="built_in">count</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置 ++ 运算符（成员函数）</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置 -- 运算符（成员函数）</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Counter&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Counter&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; c.count;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;++c = &quot;</span> &lt;&lt; ++c &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--c = &quot;</span> &lt;&lt; --c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始值: 10</span><br><span class="line"><span class="addition">++c = 11</span></span><br><span class="line"><span class="deletion">--c = 10</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-后置-和-运算符"><a href="#6-2-后置-和-运算符" class="headerlink" title="6.2 后置 ++ 和 -- 运算符"></a>6.2 后置 <code>++</code> 和 <code>--</code> 运算符</h3><p><strong>作用</strong>：实现对象的后置自增和自减操作。</p>
<p><strong>示例类</strong>：<code>Counter</code> 类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...（与上面类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置 ++ 运算符（成员函数）</span></span><br><span class="line">Counter <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Counter temp = *<span class="keyword">this</span>;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置 -- 运算符（成员函数）</span></span><br><span class="line">Counter <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    Counter temp = *<span class="keyword">this</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c++ = &quot;</span> &lt;&lt; c++ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c-- = &quot;</span> &lt;&lt; c-- &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">初始值: 10</span></span><br><span class="line">c++ = 10</span><br><span class="line">c-- = 11</span><br><span class="line"><span class="section">当前值: 10</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li><strong>前置运算符</strong>：先修改对象，再返回引用。</li>
<li><strong>后置运算符</strong>：先保存原值，修改对象，再返回原值。</li>
</ul>
<hr>
<h2 id="7-下标运算符"><a href="#7-下标运算符" class="headerlink" title="7. 下标运算符 []"></a>7. 下标运算符 <code>[]</code></h2><p><strong>作用</strong>：实现对象的下标访问，如数组访问。</p>
<p><strong>示例类</strong>：<code>Vector</code> 类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; components;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; comps) : <span class="built_in">components</span>(comps) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 运算符（非 const）</span></span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= components.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> components[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 [] 运算符（const）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= components.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> components[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; v);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.components.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        os &lt;&lt; v.components[i];</span><br><span class="line">        <span class="keyword">if</span> (i != v.components.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v</span><span class="params">(&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始向量: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v[1] = &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">5.0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;修改后向量: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问越界</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v[3] = &quot;</span> &lt;&lt; v[<span class="number">3</span>] &lt;&lt; std::endl; <span class="comment">// 越界</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">初始向量: (1, 2, 3)</span></span><br><span class="line">v[1] = 2</span><br><span class="line"><span class="section">修改后向量: (1, 5, 3)</span></span><br><span class="line"><span class="section">错误: 下标越界！</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li>提供了 <code>const</code> 和 非 <code>const</code> 两种重载，以支持不同上下文中的访问。</li>
<li>在访问时进行了边界检查，确保安全性。</li>
</ul>
<hr>
<h2 id="8-函数调用运算符"><a href="#8-函数调用运算符" class="headerlink" title="8. 函数调用运算符 ()"></a>8. 函数调用运算符 <code>()</code></h2><p><strong>作用</strong>：使对象能够像函数一样被调用，常用于函数对象（functors）或仿函数。</p>
<p><strong>示例类</strong>：<code>Multiplier</code> 类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multiplier</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> factor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Multiplier</span>(<span class="type">double</span> f = <span class="number">1.0</span>) : <span class="built_in">factor</span>(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 () 运算符（成员函数）</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Multiplier <span class="title">double_it</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Multiplier <span class="title">triple_it</span><span class="params">(<span class="number">3.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_it(5) = &quot;</span> &lt;&lt; <span class="built_in">double_it</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;triple_it(5) = &quot;</span> &lt;&lt; <span class="built_in">triple_it</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double_it(5) = 10</span><br><span class="line">triple_it(5) = 15</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li>通过重载 <code>()</code> 运算符，<code>Multiplier</code> 对象可以像函数一样接受参数并进行操作。</li>
<li>常用于需要定制函数行为的场景，如排序时的比较函数。</li>
</ul>
<hr>
<h2 id="9-输入输出运算符-lt-lt-gt-gt"><a href="#9-输入输出运算符-lt-lt-gt-gt" class="headerlink" title="9. 输入输出运算符 &lt;&lt;, &gt;&gt;"></a>9. 输入输出运算符 <code>&lt;&lt;</code>, <code>&gt;&gt;</code></h2><p><strong>作用</strong>：实现对象与输入输出流之间的交互。</p>
<p><strong>示例类</strong>：<code>Complex</code>（复数类）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符（友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;&gt; 运算符（友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">    <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &gt;&gt; 运算符</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Complex&amp; c) &#123;</span><br><span class="line">    <span class="comment">// 假设输入格式为：real imag</span></span><br><span class="line">    is &gt;&gt; c.real &gt;&gt; c.imag;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入复数的实部和虚部，以空格分隔: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您输入的复数是: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例输入</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入复数的实部和虚部，以空格分隔: 3.5 -2.1</span></span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您输入的复数是: (<span class="number">3.5</span> - <span class="number">2.1i</span>)</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li><code>&lt;&lt;</code> 运算符用于输出对象到流中。</li>
<li><code>&gt;&gt;</code> 运算符用于从流中输入对象的数据。</li>
<li>一般将这些运算符重载为友元函数，以便访问类的私有成员。</li>
</ul>
<hr>
<h2 id="10-其他运算符"><a href="#10-其他运算符" class="headerlink" title="10. 其他运算符"></a>10. 其他运算符</h2><h3 id="10-1-成员访问运算符-gt-gt"><a href="#10-1-成员访问运算符-gt-gt" class="headerlink" title="10.1 成员访问运算符 -&gt;, -&gt;*"></a>10.1 成员访问运算符 <code>-&gt;</code>, <code>-&gt;*</code></h3><p><strong>说明</strong>：</p>
<ul>
<li>运算符 <code>-&gt;</code> 和 <code>-&gt;*</code> 通常用于代理模式或智能指针的实现，较为复杂。</li>
<li>其重载需要返回一个指针类型，以便进一步访问成员。</li>
<li>通常不建议普通类进行重载，除非有特定需求。</li>
</ul>
<p><strong>示例类</strong>：<code>Proxy</code> 类（代理模式）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;RealObject::display()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealObject* ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Proxy</span>(RealObject* p = <span class="literal">nullptr</span>) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -&gt; 运算符（成员函数）</span></span><br><span class="line">    RealObject* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RealObject real;</span><br><span class="line">    <span class="function">Proxy <span class="title">proxy</span><span class="params">(&amp;real)</span></span>;</span><br><span class="line"></span><br><span class="line">    proxy-&gt;<span class="built_in">display</span>(); <span class="comment">// 使用重载的 -&gt; 运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealObject::<span class="built_in">display</span>()</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li><code>Proxy</code> 类通过重载 <code>-&gt;</code> 运算符，将对 <code>Proxy</code> 对象的成员访问转发给其内部的 <code>RealObject</code> 对象。</li>
<li>这是实现代理模式或智能指针的常见方式。</li>
</ul>
<hr>
<h2 id="综合案例：复数（Complex）类中的所有运算符重载"><a href="#综合案例：复数（Complex）类中的所有运算符重载" class="headerlink" title="综合案例：复数（Complex）类中的所有运算符重载"></a>综合案例：复数（Complex）类中的所有运算符重载</h2><p>为了将上述所有运算符的重载整合在一个类中，以下是一个全面的 <code>Complex</code> 类示例，涵盖了大部分可重载的运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real = other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real + other.real, <span class="keyword">this</span>-&gt;imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 - 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real - other.real, <span class="keyword">this</span>-&gt;imag - other.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 * 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">        <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 / 运算符（成员函数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>/(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">        <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(r, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 += 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real += other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag += other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -= 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real -= other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag -= other.imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 *= 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="type">double</span> r = <span class="keyword">this</span>-&gt;real * other.real - <span class="keyword">this</span>-&gt;imag * other.imag;</span><br><span class="line">        <span class="type">double</span> i = <span class="keyword">this</span>-&gt;real * other.imag + <span class="keyword">this</span>-&gt;imag * other.real;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 /= 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="type">double</span> denominator = other.real * other.real + other.imag * other.imag;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;除数为零！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> r = (<span class="keyword">this</span>-&gt;real * other.real + <span class="keyword">this</span>-&gt;imag * other.imag) / denominator;</span><br><span class="line">        <span class="type">double</span> i = (<span class="keyword">this</span>-&gt;imag * other.real - <span class="keyword">this</span>-&gt;real * other.imag) / denominator;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 == 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="built_in">return</span> (lhs.real == rhs.real) &amp;&amp; (lhs.imag == rhs.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 != 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt; 运算符（基于模长）</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="type">double</span> lhs_mod = std::<span class="built_in">sqrt</span>(lhs.real * lhs.real + lhs.imag * lhs.imag);</span><br><span class="line">        <span class="type">double</span> rhs_mod = std::<span class="built_in">sqrt</span>(rhs.real * rhs.real + rhs.imag * rhs.imag);</span><br><span class="line">        <span class="keyword">return</span> lhs_mod &lt; rhs_mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> rhs &lt; lhs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;= 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rhs &lt; lhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;= 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex&amp; lhs, <span class="type">const</span> Complex&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(lhs &lt; rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real;</span><br><span class="line">        <span class="keyword">if</span> (c.imag &gt;= <span class="number">0</span>)</span><br><span class="line">            os &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            os &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; -c.imag &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;&gt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Complex&amp; c) &#123;</span><br><span class="line">        <span class="comment">// 简单输入格式：real imag</span></span><br><span class="line">        is &gt;&gt; c.real &gt;&gt; c.imag;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 ~ 运算符（取反复数）</span></span><br><span class="line">    Complex <span class="keyword">operator</span>~() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real, -<span class="keyword">this</span>-&gt;imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逻辑非运算符（!）</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;real == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;imag == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载下标运算符（如 c[0] 返回 real, c[1] 返回 imag）</span></span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> real;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> imag;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> real;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> imag;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++real;</span><br><span class="line">        ++imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后置 ++ 运符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        Complex temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++real;</span><br><span class="line">        ++imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前置 -- 运算符</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        --real;</span><br><span class="line">        --imag;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后置 -- 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        Complex temp = *<span class="keyword">this</span>;</span><br><span class="line">        --real;</span><br><span class="line">        --imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; part)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (part == <span class="string">&quot;real&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> real;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (part == <span class="string">&quot;imag&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> imag;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;参数错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1.5</span>, <span class="number">-2.5</span>)</span></span>;</span><br><span class="line">    Complex c3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算</span></span><br><span class="line">    c3 = c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c3 = &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    Complex c4 = c1 + c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c4 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    Complex c5 = c1 - c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span> &lt;&lt; c5 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    Complex c6 = c1 * c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span> &lt;&lt; c6 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Complex c7 = c1 / c2;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span> &lt;&lt; c7 &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较运算</span></span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; c2)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长大于 c2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 的模长不大于 c2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非运算</span></span><br><span class="line">    Complex c_zero;</span><br><span class="line">    <span class="keyword">if</span> (!c1)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1 不是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c_zero)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c_zero 是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c_zero 不是零复数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取反运算</span></span><br><span class="line">    Complex c_neg = ~c1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~c1 = &quot;</span> &lt;&lt; c_neg &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标运算</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1[0] (real) = &quot;</span> &lt;&lt; c1[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c1[1] (imag) = &quot;</span> &lt;&lt; c1[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;c1[2] = &quot; &lt;&lt; c1[2] &lt;&lt; std::endl; // 会抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增自减运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;++c1 = &quot;</span> &lt;&lt; ++c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1++ = &quot;</span> &lt;&lt; c1++ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--c1 = &quot;</span> &lt;&lt; --c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1-- = &quot;</span> &lt;&lt; c1-- &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 的实部: &quot;</span> &lt;&lt; <span class="built_in">c1</span>(<span class="string">&quot;real&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 的虚部: &quot;</span> &lt;&lt; <span class="built_in">c1</span>(<span class="string">&quot;imag&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入运算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个复数的实部和虚部，以空格分隔: &quot;</span>;</span><br><span class="line">    Complex c_input;</span><br><span class="line">    std::cin &gt;&gt; c_input;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您输入的复数是: &quot;</span> &lt;&lt; c_input &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例运行</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">c3 = (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">c1 + c2 = (<span class="number">4.5</span> + <span class="number">1.5i</span>)</span><br><span class="line">c1 - c2 = (<span class="number">1.5</span> + <span class="number">6.5i</span>)</span><br><span class="line">c1 * c2 = (<span class="number">13.5</span> + <span class="number">1i</span>)</span><br><span class="line">c1 / c2 = (<span class="number">-0.823529</span> + <span class="number">1.64706i</span>)</span><br><span class="line">c1 的模长大于 c2</span><br><span class="line">c1 不是零复数</span><br><span class="line">c_zero 是零复数</span><br><span class="line">~c1 = (<span class="number">3</span> - <span class="number">4i</span>)</span><br><span class="line">c1[<span class="number">0</span>] (<span class="built_in">real</span>) = <span class="number">3</span></span><br><span class="line">c1[<span class="number">1</span>] (<span class="built_in">imag</span>) = <span class="number">4</span></span><br><span class="line">c1 = (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">++c1 = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1++ = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1 = (<span class="number">5</span> + <span class="number">6i</span>)</span><br><span class="line">--c1 = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1-- = (<span class="number">4</span> + <span class="number">5i</span>)</span><br><span class="line">c1 = (<span class="number">3</span> + <span class="number">4i</span>)</span><br><span class="line">c1 的实部: <span class="number">3</span></span><br><span class="line">c1 的虚部: <span class="number">4</span></span><br><span class="line">请输入一个复数的实部和虚部，以空格分隔: <span class="number">2.5</span> <span class="number">-3.5</span></span><br><span class="line">您输入的复数是: (<span class="number">2.5</span> - <span class="number">3.5i</span>)</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li>该类集成了大部分可重载的运算符，包括算术、赋值、比较、逻辑、位运算、自增自减、下标、函数调用以及输入输出运算符。</li>
<li>某些运算符（如 <code>&amp;&amp;</code>, <code>||</code>, <code>-&gt;*</code>）未在此示例中体现，因为它们的重载较为复杂且不常见。</li>
<li>在实际开发中，应根据需求选择性地重载运算符，避免过度设计。</li>
</ul>
<hr>
<h2 id="11-其他可重载运算符"><a href="#11-其他可重载运算符" class="headerlink" title="11. 其他可重载运算符"></a>11. 其他可重载运算符</h2><h3 id="11-1-逗号运算符"><a href="#11-1-逗号运算符" class="headerlink" title="11.1 逗号运算符 ,"></a>11.1 逗号运算符 <code>,</code></h3><p><strong>作用</strong>：实现对象在逗号表达式中的行为。</p>
<p><strong>示例类</strong>：<code>Logger</code> 类（用于示例）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; msg = <span class="string">&quot;&quot;</span>) : <span class="built_in">message</span>(msg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载逗号运算符（成员函数）</span></span><br><span class="line">    Logger <span class="keyword">operator</span>,(<span class="type">const</span> Logger&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 简单示例：连接日志消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Logger</span>(<span class="keyword">this</span>-&gt;message + <span class="string">&quot;, &quot;</span> + other.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Logger&amp; l);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 &lt;&lt; 运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Logger&amp; l) &#123;</span><br><span class="line">    os &lt;&lt; l.message;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Logger <span class="title">log1</span><span class="params">(<span class="string">&quot;启动&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Logger <span class="title">log2</span><span class="params">(<span class="string">&quot;加载配置&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Logger <span class="title">log3</span><span class="params">(<span class="string">&quot;初始化&quot;</span>)</span></span>;</span><br><span class="line">    Logger combined = (log1, log2, log3);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;组合日志: &quot;</span> &lt;&lt; combined &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">组合日志: 启动, 加载配置, 初始化</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li>重载 <code>,</code> 运算符可以自定义逗号表达式的行为，但在实际应用中不常见，应谨慎使用。</li>
<li>多个逗号运算符的重载会按从左至右的顺序依次调用。</li>
</ul>
<hr>
<h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ol>
<li><strong>语义一致性</strong>：重载运算符后，其行为应与运算符的传统意义保持一致。例如，<code>+</code> 应表示加法，避免引起混淆。</li>
<li><strong>效率</strong>：尽量避免不必要的对象拷贝，可以通过返回引用或使用移动语义提升效率。</li>
<li><strong>异常安全</strong>：在实现运算符重载时，考虑并处理可能的异常情况，确保程序的健壮性。</li>
<li><strong>封装性</strong>：保持类的封装性，避免过度暴露内部细节。仅在必要时使用友元函数。</li>
<li><strong>返回类型</strong>：根据运算符的用途选择合适的返回类型。例如，算术运算符通常返回新对象，赋值运算符返回引用等。</li>
<li><strong>避免复杂的逻辑</strong>：运算符重载应简洁明了，不应包含过于复杂的逻辑，避免使代码难以理解和维护。</li>
<li><strong>可读性</strong>：使用适当的注释和文档说明运算符重载的行为，增强代码的可读性。</li>
</ol>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>运算符重载是C++中强大的特性，允许开发者为自定义类定义或重新定义运算符的行为，使对象的操作更加直观和符合逻辑。在设计和实现运算符重载时，应遵循语义一致性、效率和封装性等原则，避免滥用。通过本教案中的详细案例，学习者可以全面理解运算符重载的应用，并在实际编程中灵活运用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2025/01/14/cppbase29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/14/cppbase29/" itemprop="url">unorderedmap以及手写无序map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-01-14T16:18:11+08:00">
                2025-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="unordermap用法"><a href="#unordermap用法" class="headerlink" title="unordermap用法"></a>unordermap用法</h1><p><code>unordered_map</code> 是 C++ 标准库中的关联容器，提供了基于哈希表的键值对存储结构。与 <code>map</code> （基于红黑树实现）不同，<code>unordered_map</code> 提供的是平均常数时间复杂度的查找、插入和删除操作，但不保证元素的顺序。</p>
<p>以下是 <code>unordered_map</code> 的详细用法说明：</p>
<h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h2><p>要使用 <code>unordered_map</code>，需要包含头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="2-基本定义"><a href="#2-基本定义" class="headerlink" title="2. 基本定义"></a>2. 基本定义</h2><p><code>unordered_map</code> 的基本模板定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;KeyType, ValueType, Hash = std::hash&lt;KeyType&gt;, KeyEqual = std::equal_to&lt;KeyType&gt;, Allocator = std::allocator&lt;std::pair&lt;<span class="type">const</span> KeyType, ValueType&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="常用模板参数："><a href="#常用模板参数：" class="headerlink" title="常用模板参数："></a>常用模板参数：</h3><ul>
<li><strong>KeyType</strong>：键的类型，需要支持哈希运算和相等比较。</li>
<li><strong>ValueType</strong>：值的类型。</li>
<li><strong>Hash</strong>：哈希函数，默认为 <code>std::hash&lt;KeyType&gt;</code>。</li>
<li><strong>KeyEqual</strong>：键相等的比较函数，默认为 <code>std::equal_to&lt;KeyType&gt;</code>。</li>
<li><strong>Allocator</strong>：内存分配器，默认为 <code>std::allocator</code>。</li>
</ul>
<h2 id="3-常用操作"><a href="#3-常用操作" class="headerlink" title="3. 常用操作"></a>3. 常用操作</h2><h3 id="3-1-创建和初始化"><a href="#3-1-创建和初始化" class="headerlink" title="3.1 创建和初始化"></a>3.1 创建和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 unordered_map，键为 string，值为 int</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始化列表初始化</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; umap_init = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用其他容器范围初始化</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ordered_map = &#123;&#123;<span class="string">&quot;carrot&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;lettuce&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; <span class="title">umap_from_map</span><span class="params">(ordered_map.begin(), ordered_map.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-插入元素"><a href="#3-2-插入元素" class="headerlink" title="3.2 插入元素"></a>3.2 插入元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用下标操作符</span></span><br><span class="line">umap[<span class="string">&quot;grape&quot;</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用 insert</span></span><br><span class="line">umap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;melon&quot;</span>, <span class="number">6</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：使用 emplace，直接在容器内部构造元素</span></span><br><span class="line">umap.<span class="built_in">emplace</span>(<span class="string">&quot;kiwi&quot;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>



<h3 id="3-3-访问元素"><a href="#3-3-访问元素" class="headerlink" title="3.3 访问元素"></a>3.3 访问元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下标操作符访问或插入</span></span><br><span class="line"><span class="type">int</span> apple_count = umap[<span class="string">&quot;apple&quot;</span>]; <span class="comment">// 如果 &quot;apple&quot; 不存在，会插入一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法访问，不存在时会抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> banana_count = umap.<span class="built_in">at</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Key not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 find() 方法查找</span></span><br><span class="line"><span class="keyword">auto</span> it = umap.<span class="built_in">find</span>(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Orange count: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Orange not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-删除元素"><a href="#3-4-删除元素" class="headerlink" title="3.4 删除元素"></a>3.4 删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据键删除</span></span><br><span class="line">umap.<span class="built_in">erase</span>(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据迭代器删除</span></span><br><span class="line"><span class="keyword">auto</span> it = umap.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    umap.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空整个容器</span></span><br><span class="line">umap.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>



<h3 id="3-5-遍历元素"><a href="#3-5-遍历元素" class="headerlink" title="3.5 遍历元素"></a>3.5 遍历元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : umap) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = umap.<span class="built_in">begin</span>(); it != umap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-其他常用方法"><a href="#3-6-其他常用方法" class="headerlink" title="3.6 其他常用方法"></a>3.6 其他常用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取大小</span></span><br><span class="line"><span class="type">size_t</span> size = umap.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为空</span></span><br><span class="line"><span class="type">bool</span> is_empty = umap.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取桶的数量（用于哈希表内部结构）</span></span><br><span class="line"><span class="type">size_t</span> bucket_count = umap.<span class="built_in">bucket_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新哈希，调整桶的数量</span></span><br><span class="line">umap.<span class="built_in">rehash</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个容器中移交元素到另一个容器</span></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; umap2 = std::<span class="built_in">move</span>(umap);</span><br></pre></td></tr></table></figure>



<h2 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h2><h3 id="4-1-预分配桶数"><a href="#4-1-预分配桶数" class="headerlink" title="4.1 预分配桶数"></a>4.1 预分配桶数</h3><p>如果预先知道元素的大致数量，可以通过 <code>reserve</code> 预分配内存，以减少哈希表的重哈希开销：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umap.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 预分配足够容纳100个元素的桶</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2-自定义哈希函数"><a href="#4-2-自定义哈希函数" class="headerlink" title="4.2 自定义哈希函数"></a>4.2 自定义哈希函数</h3><p>如果键的类型是自定义类型或需要特殊的哈希策略，可以自定义哈希函数。例如，自定义结构体作为键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PointHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.x) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.y) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 unordered_map 使用自定义哈希函数</span></span><br><span class="line">std::unordered_map&lt;Point, std::string, PointHash&gt; point_map;</span><br><span class="line">point_map[&#123;<span class="number">1</span>, <span class="number">2</span>&#125;] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">point_map[&#123;<span class="number">3</span>, <span class="number">4</span>&#125;] = <span class="string">&quot;B&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-自定义键相等比较"><a href="#4-3-自定义键相等比较" class="headerlink" title="4.3 自定义键相等比较"></a>4.3 自定义键相等比较</h3><p>如果需要自定义键的比较逻辑，可以提供自定义的 <code>KeyEqual</code> 函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PointEqual</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a.x == b.x) &amp;&amp; (a.y == b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 unordered_map 使用自定义哈希和比较函数</span></span><br><span class="line">std::unordered_map&lt;Point, std::string, PointHash, PointEqual&gt; point_map;</span><br></pre></td></tr></table></figure>



<h2 id="5-与-map-的比较"><a href="#5-与-map-的比较" class="headerlink" title="5. 与 map 的比较"></a>5. 与 <code>map</code> 的比较</h2><ul>
<li><strong>底层实现</strong>：<code>unordered_map</code> 基于哈希表，实现的操作平均时间复杂度为常数级别；<code>map</code> 基于红黑树，实现的查找、插入、删除操作时间复杂度为对数级别。</li>
<li><strong>元素顺序</strong>：<code>unordered_map</code> 不保证元素的顺序；<code>map</code> 按键的顺序（通常是升序）存储元素。</li>
<li><strong>适用场景</strong>：当需要快速查找、插入和删除，且不关心元素顺序时，选择 <code>unordered_map</code>；当需要有序存储或按顺序遍历时，选择 <code>map</code>。</li>
</ul>
<h2 id="6-完整示例"><a href="#6-完整示例" class="headerlink" title="6. 完整示例"></a>6. 完整示例</h2><p>以下是一个使用 <code>unordered_map</code> 的完整示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; age == other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;std::string&gt;()(p.name) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.age) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unordered_map，键为 string，值为 int</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; fruit_count;</span><br><span class="line">    fruit_count[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    fruit_count[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    fruit_count.<span class="built_in">emplace</span>(<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Apple count: &quot;</span> &lt;&lt; fruit_count[<span class="string">&quot;apple&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : fruit_count) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义类型作为键</span></span><br><span class="line">    std::unordered_map&lt;Person, std::string, PersonHash&gt; person_map;</span><br><span class="line">    Person p1&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    Person p2&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    person_map[p1] = <span class="string">&quot;Engineer&quot;</span>;</span><br><span class="line">    person_map.<span class="built_in">emplace</span>(p2, <span class="string">&quot;Designer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问自定义类型键的值</span></span><br><span class="line">    Person p3&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s job: &quot;</span> &lt;&lt; person_map[p3] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Apple count:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">banana:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">orange:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">apple:</span> <span class="number">5</span></span><br><span class="line"><span class="string">Alice&#x27;s</span> <span class="attr">job:</span> <span class="string">Engineer</span></span><br></pre></td></tr></table></figure>

<h1 id="手写unordermap"><a href="#手写unordermap" class="headerlink" title="手写unordermap"></a>手写unordermap</h1><h2 id="1-哈希表的基本原理"><a href="#1-哈希表的基本原理" class="headerlink" title="1. 哈希表的基本原理"></a>1. 哈希表的基本原理</h2><p>哈希表是一种基于键值对的数据结构，通过<strong>哈希函数</strong>（Hash Function）将键映射到表中的一个索引位置，以实现快速的数据访问。哈希表的关键特性包括：</p>
<ul>
<li><strong>哈希函数</strong>：将键映射到表中一个特定的桶（Bucket）或槽（Slot）。</li>
<li><strong>冲突解决</strong>：当不同的键通过哈希函数映射到同一个桶时，需要一种机制来处理这些冲突。常见的方法有<strong>链地址法</strong>（Separate Chaining）和<strong>开放地址法</strong>（Open Addressing）。</li>
<li><strong>负载因子</strong>（Load Factor）：表示表中已存储元素的数量与表大小之间的比率。高负载因子可能导致更多的冲突，需要通过扩容来维持性能。</li>
</ul>
<p>在本实现中，我们将采用<strong>链地址法</strong>来处理哈希冲突，即每个桶存储一个链表（或其他动态数据结构）来存储具有相同哈希值的元素。</p>
<h2 id="2-数据结构设计"><a href="#2-数据结构设计" class="headerlink" title="2. 数据结构设计"></a>2. 数据结构设计</h2><h3 id="HashNode-结构"><a href="#HashNode-结构" class="headerlink" title="HashNode 结构"></a>HashNode 结构</h3><p><code>HashNode</code> 用于存储键值对及相关的指针，以构建链表。每个 <code>HashNode</code> 包含键、值和指向下一个节点的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::hash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// For iterator_traits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// For exceptions</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashNode 结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line">    std::pair&lt;<span class="type">const</span> Key, T&gt; data;</span><br><span class="line">    HashNode* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HashNode</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span><br><span class="line">        : <span class="built_in">data</span>(std::<span class="built_in">make_pair</span>(key, value)), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="MyHashMap-类定义"><a href="#MyHashMap-类定义" class="headerlink" title="MyHashMap 类定义"></a>MyHashMap 类定义</h3><p><code>MyHashMap</code> 是我们自定义的哈希表实现，支持基本的 <code>Map</code> 操作和迭代器功能。它使用一个向量（<code>std::vector</code>）来存储桶，每个桶是一个链表，用于处理冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 迭代器类前向声明</span></span><br><span class="line">    <span class="keyword">class</span> Iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型定义</span></span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> mapped_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数及析构函数</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(size_type initial_capacity = <span class="number">16</span>, <span class="type">double</span> max_load_factor = <span class="number">0.75</span>);</span><br><span class="line">    ~<span class="built_in">MyHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyHashMap&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器操作</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 迭代器别名</span></span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::forward_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">        <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">        <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作符</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增操作符</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyHashMap* map_;</span><br><span class="line">        size_type bucket_index_;</span><br><span class="line">        HashNode&lt;Key, T&gt;* current_node_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个有效节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;</span><br><span class="line">    size_type bucket_count_;</span><br><span class="line">    size_type element_count_;</span><br><span class="line">    <span class="type">double</span> max_load_factor_;</span><br><span class="line">    Hash hash_func_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-基本操作实现"><a href="#3-基本操作实现" class="headerlink" title="3. 基本操作实现"></a>3. 基本操作实现</h2><h3 id="构造函数及析构函数"><a href="#构造函数及析构函数" class="headerlink" title="构造函数及析构函数"></a>构造函数及析构函数</h3><p>初始化哈希表，设置初始容量和负载因子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">MyHashMap</span>(size_type initial_capacity, <span class="type">double</span> max_load_factor)</span><br><span class="line">    : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">      <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">      <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123;</span><br><span class="line">    buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::~<span class="built_in">MyHashMap</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入（Insert）"><a href="#插入（Insert）" class="headerlink" title="插入（Insert）"></a>插入（Insert）</h3><p>向哈希表中插入键值对。如果键已存在，则更新其值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            node-&gt;data.second = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键不存在，插入新节点到链表头部</span></span><br><span class="line">    HashNode&lt;Key, T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">HashNode</span>&lt;Key, T&gt;(key, value);</span><br><span class="line">    new_node-&gt;next = buckets_[index];</span><br><span class="line">    buckets_[index] = new_node;</span><br><span class="line">    ++element_count_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查负载因子，可能需要扩容</span></span><br><span class="line">    <span class="type">double</span> load_factor = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(element_count_) / bucket_count_;</span><br><span class="line">    <span class="keyword">if</span> (load_factor &gt; max_load_factor_) &#123;</span><br><span class="line">        <span class="built_in">rehash</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找（Find）"><a href="#查找（Find）" class="headerlink" title="查找（Find）"></a>查找（Find）</h3><p>根据键查找对应的值，返回指向值的指针。如果未找到，则返回 <code>nullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">const</span> T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除（Erase）"><a href="#删除（Erase）" class="headerlink" title="删除（Erase）"></a>删除（Erase）</h3><p>根据键删除对应的键值对，返回删除是否成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    HashNode&lt;Key, T&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                buckets_[index] = node-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            --element_count_;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未找到键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="清空（Clear）"><a href="#清空（Clear）" class="headerlink" title="清空（Clear）"></a>清空（Clear）</h3><p>删除哈希表中的所有元素，释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets_[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态扩容（Rehashing）"><a href="#动态扩容（Rehashing）" class="headerlink" title="动态扩容（Rehashing）"></a>动态扩容（Rehashing）</h3><p>当负载因子超过阈值时，扩展哈希表容量并重新分配所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">rehash</span>() &#123;</span><br><span class="line">    size_type new_bucket_count = bucket_count_ * <span class="number">2</span>;</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; <span class="built_in">new_buckets</span>(new_bucket_count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* next_node = node-&gt;next;</span><br><span class="line">            size_type new_index = <span class="built_in">hash_func_</span>(node-&gt;data.first) % new_bucket_count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入到新桶的头部</span></span><br><span class="line">            node-&gt;next = new_buckets[new_index];</span><br><span class="line">            new_buckets[new_index] = node;</span><br><span class="line"></span><br><span class="line">            node = next_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换旧桶</span></span><br><span class="line">    buckets_ = std::<span class="built_in">move</span>(new_buckets);</span><br><span class="line">    bucket_count_ = new_bucket_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取大小和状态"><a href="#获取大小和状态" class="headerlink" title="获取大小和状态"></a>获取大小和状态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::size_type MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element_count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">empty</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element_count_ == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-迭代器的实现"><a href="#4-迭代器的实现" class="headerlink" title="4. 迭代器的实现"></a>4. 迭代器的实现</h2><p>为了支持迭代器操作，使 <code>MyHashMap</code> 能够像标准容器一样被遍历，我们需要实现一个内部的 <code>Iterator</code> 类。</p>
<h3 id="Iterator-类定义"><a href="#Iterator-类定义" class="headerlink" title="Iterator 类定义"></a>Iterator 类定义</h3><p><code>Iterator</code> 类需要跟踪当前桶的索引和当前节点指针。它还需要能够找到下一个有效的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node)</span><br><span class="line">    : <span class="built_in">map_</span>(map), <span class="built_in">bucket_index_</span>(bucket_index), <span class="built_in">current_node_</span>(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::reference</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_node_-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员访问操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointer</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(current_node_-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map_ == other.map_ &amp;&amp;</span><br><span class="line">           bucket_index_ == other.bucket_index_ &amp;&amp;</span><br><span class="line">           current_node_ == other.current_node_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符!=</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// advance 函数：移动到下一个有效节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">advance</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current_node_ = current_node_-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_node_ == <span class="literal">nullptr</span> &amp;&amp; bucket_index_ + <span class="number">1</span> &lt; map_-&gt;bucket_count_) &#123;</span><br><span class="line">        ++bucket_index_;</span><br><span class="line">        current_node_ = map_-&gt;buckets_[bucket_index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h3><p>在 <code>MyHashMap</code> 类中实现 <code>begin()</code> 和 <code>end()</code> 函数来返回迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// begin() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">begin</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets_[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, i, buckets_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// end() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-完整代码示例"><a href="#5-完整代码示例" class="headerlink" title="5. 完整代码示例"></a>5. 完整代码示例</h2><p>以下是完整的 <code>MyHashMap</code> 实现，包括所有上述内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::hash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// For iterator_traits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// For exceptions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashNode 结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line">    std::pair&lt;<span class="type">const</span> Key, T&gt; data;</span><br><span class="line">    HashNode* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HashNode</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span><br><span class="line">        : <span class="built_in">data</span>(std::<span class="built_in">make_pair</span>(key, value)), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyHashMap 类定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 迭代器类前向声明</span></span><br><span class="line">    <span class="keyword">class</span> Iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型定义</span></span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> mapped_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数及析构函数</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(size_type initial_capacity = <span class="number">16</span>, <span class="type">double</span> max_load_factor = <span class="number">0.75</span>);</span><br><span class="line">    ~<span class="built_in">MyHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyHashMap&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyHashMap&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器操作</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 迭代器别名</span></span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::forward_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">        <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">        <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作符</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增操作符</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyHashMap* map_;</span><br><span class="line">        size_type bucket_index_;</span><br><span class="line">        HashNode&lt;Key, T&gt;* current_node_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个有效节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;</span><br><span class="line">    size_type bucket_count_;</span><br><span class="line">    size_type element_count_;</span><br><span class="line">    <span class="type">double</span> max_load_factor_;</span><br><span class="line">    Hash hash_func_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">MyHashMap</span>(size_type initial_capacity, <span class="type">double</span> max_load_factor)</span><br><span class="line">    : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">      <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">      <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123;</span><br><span class="line">    buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::~<span class="built_in">MyHashMap</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            node-&gt;data.second = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键不存在，插入新节点到链表头部</span></span><br><span class="line">    HashNode&lt;Key, T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">HashNode</span>&lt;Key, T&gt;(key, value);</span><br><span class="line">    new_node-&gt;next = buckets_[index];</span><br><span class="line">    buckets_[index] = new_node;</span><br><span class="line">    ++element_count_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查负载因子，可能需要扩容</span></span><br><span class="line">    <span class="type">double</span> load_factor = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(element_count_) / bucket_count_;</span><br><span class="line">    <span class="keyword">if</span> (load_factor &gt; max_load_factor_) &#123;</span><br><span class="line">        <span class="built_in">rehash</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找函数（非常量版本）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找函数（常量版本）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">const</span> T* MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;data.second);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    size_type hash_value = <span class="built_in">hash_func_</span>(key);</span><br><span class="line">    size_type index = hash_value % bucket_count_;</span><br><span class="line"></span><br><span class="line">    HashNode&lt;Key, T&gt;* node = buckets_[index];</span><br><span class="line">    HashNode&lt;Key, T&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data.first == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                buckets_[index] = node-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            --element_count_;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未找到键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets_[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态扩容函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">rehash</span>() &#123;</span><br><span class="line">    size_type new_bucket_count = bucket_count_ * <span class="number">2</span>;</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; <span class="built_in">new_buckets</span>(new_bucket_count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        HashNode&lt;Key, T&gt;* node = buckets_[i];</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            HashNode&lt;Key, T&gt;* next_node = node-&gt;next;</span><br><span class="line">            size_type new_index = <span class="built_in">hash_func_</span>(node-&gt;data.first) % new_bucket_count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入到新桶的头部</span></span><br><span class="line">            node-&gt;next = new_buckets[new_index];</span><br><span class="line">            new_buckets[new_index] = node;</span><br><span class="line"></span><br><span class="line">            node = next_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换旧桶</span></span><br><span class="line">    buckets_ = std::<span class="built_in">move</span>(new_buckets);</span><br><span class="line">    bucket_count_ = new_bucket_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// begin() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">begin</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; bucket_count_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets_[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, i, buckets_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// end() 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node)</span><br><span class="line">    : <span class="built_in">map_</span>(map), <span class="built_in">bucket_index_</span>(bucket_index), <span class="built_in">current_node_</span>(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::reference</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_node_-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员访问操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointer</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Iterator out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(current_node_-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置递增操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">advance</span>();</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map_ == other.map_ &amp;&amp;</span><br><span class="line">           bucket_index_ == other.bucket_index_ &amp;&amp;</span><br><span class="line">           current_node_ == other.current_node_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作符!=</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// advance 函数：移动到下一个有效节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line"><span class="type">void</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="built_in">advance</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current_node_ = current_node_-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_node_ == <span class="literal">nullptr</span> &amp;&amp; bucket_index_ + <span class="number">1</span> &lt; map_-&gt;bucket_count_) &#123;</span><br><span class="line">        ++bucket_index_;</span><br><span class="line">        current_node_ = map_-&gt;buckets_[bucket_index_];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-使用示例"><a href="#6-使用示例" class="headerlink" title="6. 使用示例"></a>6. 使用示例</h2><p>以下是一个使用 <code>MyHashMap</code> 的示例，展示如何插入、查找、删除以及使用迭代器遍历元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyHashMap&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;grape&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Map contents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string keyToFind = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* value = myMap.<span class="built_in">find</span>(keyToFind);</span><br><span class="line">    <span class="keyword">if</span>(value != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nFound &quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; with value: &quot;</span> &lt;&lt; *value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; keyToFind &lt;&lt; <span class="string">&quot; not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter erasing apple and cherry:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map contents:</span><br><span class="line">cherry =&gt; 4</span><br><span class="line">banana =&gt; 5</span><br><span class="line">apple =&gt; 3</span><br><span class="line">grape =&gt; 7</span><br><span class="line">orange =&gt; 2</span><br><span class="line"></span><br><span class="line">Found banana with value: 5</span><br><span class="line"></span><br><span class="line">After erasing apple and cherry:</span><br><span class="line">banana =&gt; 5</span><br><span class="line">grape =&gt; 7</span><br><span class="line">orange =&gt; 2</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：由于哈希表的桶顺序依赖于哈希函数的实现，输出顺序可能与预期有所不同。</p>
<p><code>Hash()</code> 在上述 <code>MyHashMap</code> 实现中是一个<strong>哈希函数对象</strong>。让我们详细解释一下它的含义以及它在代码中的作用。</p>
<h2 id="Hash-是什么？"><a href="#Hash-是什么？" class="headerlink" title="Hash 是什么？"></a><code>Hash</code> 是什么？</h2><p>在 <code>MyHashMap</code> 的模板定义中，<code>Hash</code> 是一个<strong>模板参数</strong>，用于指定键类型 <code>Key</code> 的哈希函数。它有一个默认值 <code>std::hash&lt;Key&gt;</code>，这意味着如果用户在实例化 <code>MyHashMap</code> 时没有提供自定义的哈希函数，<code>std::hash&lt;Key&gt;</code> 将被使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="默认情况下：std-hash-lt-Key-gt"><a href="#默认情况下：std-hash-lt-Key-gt" class="headerlink" title="默认情况下：std::hash&lt;Key&gt;"></a>默认情况下：<code>std::hash&lt;Key&gt;</code></h3><p><code>std::hash</code> 是 C++ 标准库（STL）中提供的一个模板结构，用于为各种内置类型（如 <code>int</code>, <code>std::string</code> 等）生成哈希值。<code>std::hash&lt;Key&gt;</code> 会根据 <code>Key</code> 的类型自动选择合适的哈希函数实现。</p>
<p>例如：</p>
<ul>
<li>对于 <code>int</code> 类型，<code>std::hash&lt;int&gt;</code> 会生成一个简单的哈希值。</li>
<li>对于 <code>std::string</code> 类型，<code>std::hash&lt;std::string&gt;</code> 会基于字符串内容生成哈希值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::hash&lt;<span class="type">int</span>&gt; intHasher;</span><br><span class="line"><span class="type">size_t</span> hashValue = <span class="built_in">intHasher</span>(<span class="number">42</span>); <span class="comment">// 生成整数 42 的哈希值</span></span><br><span class="line"></span><br><span class="line">std::hash&lt;std::string&gt; stringHasher;</span><br><span class="line"><span class="type">size_t</span> stringHash = <span class="built_in">stringHasher</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 生成字符串 &quot;hello&quot; 的哈希值</span></span><br></pre></td></tr></table></figure>



<h3 id="自定义哈希函数"><a href="#自定义哈希函数" class="headerlink" title="自定义哈希函数"></a>自定义哈希函数</h3><p>除了使用 <code>std::hash</code>，用户还可以自定义哈希函数，以适应特定的需求或优化性能。例如，假设你有一个自定义的键类型 <code>Point</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>你可以定义一个自定义的哈希函数 <code>PointHasher</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PointHasher</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的哈希组合，实际应用中应选择更好的哈希组合方法</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.x) ^ (std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.y) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>然后，在实例化 <code>MyHashMap</code> 时使用自定义哈希函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyHashMap&lt;Point, std::string, PointHasher&gt; pointMap;</span><br><span class="line">Point p1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pointMap.<span class="built_in">insert</span>(p1, <span class="string">&quot;Point1&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Hash-在代码中的作用"><a href="#Hash-在代码中的作用" class="headerlink" title="Hash() 在代码中的作用"></a><code>Hash()</code> 在代码中的作用</h2><p>在 <code>MyHashMap</code> 的构造函数中，<code>Hash()</code> 用于<strong>实例化</strong>哈希函数对象，并将其赋值给成员变量 <code>hash_func_</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash&gt;</span><br><span class="line">MyHashMap&lt;Key, T, Hash&gt;::<span class="built_in">MyHashMap</span>(size_type initial_capacity, <span class="type">double</span> max_load_factor)</span><br><span class="line">    : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">      <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">      <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123; <span class="comment">// 这里的 Hash() 是一个默认构造函数调用</span></span><br><span class="line">    buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="具体作用："><a href="#具体作用：" class="headerlink" title="具体作用："></a>具体作用：</h3><ol>
<li><strong>实例化哈希函数对象</strong>：<ul>
<li><code>Hash()</code> 会调用 <code>Hash</code> 类型的默认构造函数，创建一个哈希函数对象。</li>
<li>如果 <code>Hash</code> 是 <code>std::hash&lt;Key&gt;</code>，那么就创建一个 <code>std::hash&lt;Key&gt;</code> 对象。</li>
</ul>
</li>
<li><strong>存储哈希函数对象</strong>：<ul>
<li>生成的哈希函数对象被存储在成员变量 <code>hash_func_</code> 中，以便在哈希表的各种操作（如插入、查找、删除）中使用。</li>
</ul>
</li>
<li><strong>支持不同的哈希函数</strong>：<ul>
<li>由于 <code>Hash</code> 是一个模板参数，可以灵活地使用不同的哈希函数，无需修改 <code>MyHashMap</code> 的内部实现。</li>
</ul>
</li>
</ol>
<h2 id="示例代码解释"><a href="#示例代码解释" class="headerlink" title="示例代码解释"></a>示例代码解释</h2><p>以下是相关部分的简化示例，帮助理解 <code>Hash</code> 和 <code>Hash()</code> 的作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::hash</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> MyHashMap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyHashMap</span>(<span class="type">size_t</span> initial_capacity = <span class="number">16</span>, <span class="type">double</span> max_load_factor = <span class="number">0.75</span>)</span><br><span class="line">        : <span class="built_in">bucket_count_</span>(initial_capacity),</span><br><span class="line">          <span class="built_in">element_count_</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">max_load_factor_</span>(max_load_factor),</span><br><span class="line">          <span class="built_in">hash_func_</span>(<span class="built_in">Hash</span>()) &#123; <span class="comment">// 实例化哈希函数对象</span></span><br><span class="line">        buckets_.<span class="built_in">resize</span>(bucket_count_, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash_value = <span class="built_in">hash_func_</span>(key); <span class="comment">// 使用哈希函数对象</span></span><br><span class="line">        <span class="type">size_t</span> index = hash_value % bucket_count_;</span><br><span class="line">        <span class="comment">// 插入逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;</span><br><span class="line">    <span class="type">size_t</span> bucket_count_;</span><br><span class="line">    <span class="type">size_t</span> element_count_;</span><br><span class="line">    <span class="type">double</span> max_load_factor_;</span><br><span class="line">    Hash hash_func_; <span class="comment">// 存储哈希函数对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong><code>Hash</code> 是模板参数</strong>，用于指定键类型 <code>Key</code> 的哈希函数。默认情况下，它使用 C++ 标准库中的 <code>std::hash&lt;Key&gt;</code>。</li>
<li><strong><code>Hash()</code> 是一个默认构造函数调用</strong>，用于实例化哈希函数对象，并将其存储在 <code>hash_func_</code> 成员变量中，以便在哈希表操作中使用。</li>
<li><strong>用户可以自定义哈希函数</strong>，通过提供自定义的哈希函数对象，实现对特定键类型的优化或满足特殊需求。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/27/cppbase27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/27/cppbase27/" itemprop="url">手写线程安全智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-27T14:11:08+08:00">
                2024-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="现有-SimpleSharedPtr-的线程安全性分析"><a href="#现有-SimpleSharedPtr-的线程安全性分析" class="headerlink" title="现有 SimpleSharedPtr 的线程安全性分析"></a>现有 <code>SimpleSharedPtr</code> 的线程安全性分析</h2><p>在多线程环境下，确保智能指针的线程安全性主要涉及以下几个方面：</p>
<ol>
<li><strong>引用计数管理</strong>：多个线程可能会同时拷贝、移动或销毁智能指针实例，导致引用计数的修改。若引用计数不是原子操作，则会引发数据竞争和未定义行为。</li>
<li><strong>指针和控制块的访问</strong>：多个线程可能会同时访问或修改同一个智能指针实例的 <code>ptr</code> 和 <code>control</code> 成员，这需要同步机制来保护。</li>
</ol>
<p><strong>当前 <code>SimpleSharedPtr</code> 的问题：</strong></p>
<ul>
<li><strong>引用计数非原子</strong>：<code>ControlBlock::ref_count</code> 是普通的 <code>int</code> 类型，当多个线程同时修改 <code>ref_count</code> 时，会引发竞态条件。</li>
<li><strong>缺乏同步机制</strong>：<code>SimpleSharedPtr</code> 的成员函数（如拷贝构造、赋值操作符等）在修改 <code>ptr</code> 和 <code>control</code> 时没有任何同步机制，导致多个线程同时操作同一个 <code>SimpleSharedPtr</code> 实例时不安全。</li>
</ul>
<hr>
<h2 id="实现线程安全的-SimpleSharedPtr"><a href="#实现线程安全的-SimpleSharedPtr" class="headerlink" title="实现线程安全的 SimpleSharedPtr"></a>实现线程安全的 <code>SimpleSharedPtr</code></h2><p>为了解决上述问题，可以从以下几个方面入手：</p>
<h3 id="方法一：使用-std-atomic-管理引用计数"><a href="#方法一：使用-std-atomic-管理引用计数" class="headerlink" title="方法一：使用 std::atomic 管理引用计数"></a>方法一：使用 <code>std::atomic</code> 管理引用计数</h3><p>将 <code>ControlBlock::ref_count</code> 从普通的 <code>int</code> 替换为 <code>std::atomic&lt;int&gt;</code>，以确保引用计数的线程安全递增和递减。</p>
<p><strong>优点：</strong></p>
<ul>
<li>简单高效，避免使用互斥锁带来的性能开销。</li>
<li>类似于标准库中 <code>std::shared_ptr</code> 实现的引用计数管理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>只能保证引用计数本身的线程安全，无法保护 <code>ptr</code> 和 <code>control</code> 的同步访问。</li>
</ul>
<h3 id="方法二：引入互斥锁保护指针操作"><a href="#方法二：引入互斥锁保护指针操作" class="headerlink" title="方法二：引入互斥锁保护指针操作"></a>方法二：引入互斥锁保护指针操作</h3><p>在 <code>SimpleSharedPtr</code> 中引入 <code>std::mutex</code>，在所有可能修改 <code>ptr</code> 和 <code>control</code> 的操作中加锁。</p>
<p><strong>优点：</strong></p>
<ul>
<li>确保 <code>ptr</code> 和 <code>control</code> 在多线程访问时的一致性。</li>
<li>提供更全面的线程安全保障。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>引入锁机制，可能带来性能开销，特别是在高并发场景下。</li>
</ul>
<h3 id="方法三：组合使用-std-atomic-和互斥锁"><a href="#方法三：组合使用-std-atomic-和互斥锁" class="headerlink" title="方法三：组合使用 std::atomic 和互斥锁"></a>方法三：组合使用 <code>std::atomic</code> 和互斥锁</h3><p>结合使用 <code>std::atomic&lt;int&gt;</code> 进行引用计数的管理，并使用 <code>std::mutex</code> 保护指针和控制块的访问。</p>
<p><strong>优点：</strong></p>
<ul>
<li>引用计数管理高效且线程安全。</li>
<li>指针和控制块的访问得到完全的同步保护。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>复杂性较高，需要同时管理原子操作和互斥锁。</li>
</ul>
<hr>
<h2 id="完整线程安全的-ThreadSafeSharedPtr-实现"><a href="#完整线程安全的-ThreadSafeSharedPtr-实现" class="headerlink" title="完整线程安全的 ThreadSafeSharedPtr 实现"></a>完整线程安全的 <code>ThreadSafeSharedPtr</code> 实现</h2><p>结合上述方法二和方法一，我们可以实现一个名为 <code>ThreadSafeSharedPtr</code> 的类模板，确保在多线程环境下的安全性。以下是具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制块结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的 shared_ptr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                 <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control;  <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，用于保护 ptr 和 control</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            <span class="comment">// 原子递减引用计数</span></span><br><span class="line">            <span class="keyword">if</span> (--(control-&gt;ref_count) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> control;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Resource and ControlBlock destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Decremented ref_count to &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">ThreadSafeSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructed ThreadSafeSharedPtr (nullptr).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadSafeSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Constructed ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ThreadSafeSharedPtr</span>(<span class="type">const</span> ThreadSafeSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mtx)</span></span>;</span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copied ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">    ThreadSafeSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadSafeSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 为避免死锁，使用 std::scoped_lock 同时锁定两个互斥锁</span></span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(mtx, other.mtx);</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                control-&gt;ref_count++;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Assigned ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">ThreadSafeSharedPtr</span>(ThreadSafeSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mtx)</span></span>;</span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved ThreadSafeSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    ThreadSafeSharedPtr&amp; <span class="keyword">operator</span>=(ThreadSafeSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 为避免死锁，使用 std::scoped_lock 同时锁定两个互斥锁</span></span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(mtx, other.mtx);</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move-assigned ThreadSafeSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ThreadSafeSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> control ? control-&gt;ref_count.<span class="built_in">load</span>() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        ptr = p;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Reset ThreadSafeSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="关键改动说明"><a href="#关键改动说明" class="headerlink" title="关键改动说明"></a>关键改动说明</h3><ol>
<li><p><strong>引用计数原子化</strong>：</p>
<ul>
<li><p>将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ControlBlock::ref_count</span><br></pre></td></tr></table></figure>

<p>从普通的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt;</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ref_count;</span><br></pre></td></tr></table></figure></li>
<li><p>使用原子操作管理引用计数，确保多线程下的安全递增和递减：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">control-&gt;ref_count++;</span><br><span class="line"><span class="keyword">if</span> (--(control-&gt;ref_count) == <span class="number">0</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>ref_count.load()</code> 获取当前引用计数的值。</p>
</li>
</ul>
</li>
<li><p><strong>引入互斥锁</strong>：</p>
<ul>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadSafeSharedPtr</span><br></pre></td></tr></table></figure>

<p>中引入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx</span><br></pre></td></tr></table></figure>

<p>，用于保护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control</span><br></pre></td></tr></table></figure>

<p>的访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> std::mutex mtx;</span><br></pre></td></tr></table></figure></li>
<li><p>在所有可能修改或访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control</span><br></pre></td></tr></table></figure>

<p>的成员函数中加锁，确保同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在拷贝构造函数和拷贝赋值操作符中，为避免死锁，使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::scoped_lock</span><br></pre></td></tr></table></figure>

<p>同时锁定两个互斥锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx, other.mtx)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>线程安全的成员函数</strong>：</p>
<ul>
<li>对于 <code>operator*</code> 和 <code>operator-&gt;</code>，在返回前锁定互斥锁，确保在多线程环境中的安全访问。</li>
<li>其他成员函数如 <code>use_count</code>、<code>get</code> 和 <code>reset</code> 同样在访问共享资源前加锁。</li>
</ul>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>避免死锁</strong>：在需要同时锁定多个互斥锁时，使用 <code>std::scoped_lock</code>（C++17 引入）可以同时锁定多个互斥锁，避免死锁风险。</li>
<li><strong>性能开销</strong>：引入互斥锁会带来一定的性能开销，尤其是在高并发场景下。根据实际需求，权衡线程安全性和性能之间的关系。</li>
</ul>
<hr>
<h2 id="测试线程安全的-ThreadSafeSharedPtr"><a href="#测试线程安全的-ThreadSafeSharedPtr" class="headerlink" title="测试线程安全的 ThreadSafeSharedPtr"></a>测试线程安全的 <code>ThreadSafeSharedPtr</code></h2><p>为了验证 <code>ThreadSafeSharedPtr</code> 的线程安全性，我们可以编写一个多线程程序，让多个线程同时拷贝、赋值和销毁智能指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeSharedPtr.h&quot;</span> <span class="comment">// 假设将上述代码保存为该头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_copy</span><span class="params">(ThreadSafeSharedPtr&lt;Test&gt; sptr, <span class="type">int</span> thread_id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; is copying shared_ptr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ThreadSafeSharedPtr&lt;Test&gt; local_sptr = sptr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; copied shared_ptr, use_count = &quot;</span> &lt;&lt; local_sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    local_sptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_reset</span><span class="params">(ThreadSafeSharedPtr&lt;Test&gt;&amp; sptr, <span class="type">int</span> new_val, <span class="type">int</span> thread_id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; is resetting shared_ptr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(new_val));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; reset shared_ptr, use_count = &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating ThreadSafeSharedPtr with Test(100).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">ThreadSafeSharedPtr&lt;Test&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial use_count: &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程进行拷贝操作</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads_copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads_copy.<span class="built_in">emplace_back</span>(thread_func_copy, sptr, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads_copy) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After copy threads, use_count: &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程进行 reset 操作</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads_reset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads_reset.<span class="built_in">emplace_back</span>(thread_func_reset, std::<span class="built_in">ref</span>(sptr), <span class="number">200</span> + i, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads_reset) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After reset threads, final use_count: &quot;</span> &lt;&lt; sptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出示例（具体顺序可能因线程调度而异）：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Creating</span> <span class="string">ThreadSafeSharedPtr</span> <span class="string">with</span> <span class="string">Test(100).</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="string">Constructed</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Initial use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">0</span> <span class="string">is</span> <span class="string">copying</span> <span class="string">shared_ptr.</span></span><br><span class="line"><span class="string">Copied</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">0</span> <span class="string">copied</span> <span class="string">shared_ptr,</span> <span class="string">use_count</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">1</span> <span class="string">is</span> <span class="string">copying</span> <span class="string">shared_ptr.</span></span><br><span class="line"><span class="string">Copied</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">1</span> <span class="string">copied</span> <span class="string">shared_ptr,</span> <span class="string">use_count</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">After</span> <span class="string">copy</span> <span class="string">threads,</span> <span class="attr">use_count:</span> <span class="number">6</span></span><br><span class="line"><span class="string">Thread</span> <span class="number">0</span> <span class="string">is</span> <span class="string">resetting</span> <span class="string">shared_ptr.</span></span><br><span class="line"><span class="string">Decremented</span> <span class="string">ref_count</span> <span class="string">to</span> <span class="number">5</span></span><br><span class="line"><span class="string">Resource</span> <span class="string">and</span> <span class="string">ControlBlock</span> <span class="string">destroyed.</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="string">Reset</span> <span class="string">ThreadSafeSharedPtr,</span> <span class="string">ref_count</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">After</span> <span class="string">reset</span> <span class="string">threads,</span> <span class="attr">final use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="string">Exiting</span> <span class="string">main.</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>多个线程同时拷贝 <code>sptr</code>，引用计数正确递增。</li>
<li>多个线程同时重置 <code>sptr</code>，确保引用计数和资源管理的正确性。</li>
<li>最终，只有最新分配的对象存在，引用计数为 <code>1</code>。</li>
</ul>
<hr>
<h2 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h2><ol>
<li><strong>引用计数的原子性</strong>：<ul>
<li>使用 <code>std::atomic&lt;int&gt;</code> 来保证引用计数的线程安全递增和递减。</li>
<li>避免使用普通的 <code>int</code>，因为在多线程环境下会导致数据竞争。</li>
</ul>
</li>
<li><strong>互斥锁的使用</strong>：<ul>
<li>使用 <code>std::mutex</code> 来保护 <code>ptr</code> 和 <code>control</code> 的访问，防止多个线程同时修改智能指针实例。</li>
<li>尽量缩小锁的范围，避免在互斥锁保护的临界区内执行耗时操作，以减少性能开销。</li>
</ul>
</li>
<li><strong>避免死锁</strong>：<ul>
<li>在需要同时锁定多个互斥锁时，使用 <code>std::scoped_lock</code> 来一次性锁定，确保锁的顺序一致，避免死锁风险。</li>
</ul>
</li>
<li><strong>尽量遵循 RAII 原则</strong>：<ul>
<li>使用 <code>std::lock_guard</code> 或 <code>std::scoped_lock</code> 等 RAII 机制来管理互斥锁，确保在异常抛出时自动释放锁，防止死锁。</li>
</ul>
</li>
<li><strong>避免多重管理</strong>：<ul>
<li>确保不通过裸指针绕过智能指针的引用计数管理，避免资源泄漏或重复释放。</li>
</ul>
</li>
<li><strong>性能考虑</strong>：<ul>
<li>在高并发场景下，频繁的锁操作可能成为性能瓶颈。根据实际需求，可以考虑使用更轻量级的同步机制，如 <code>std::shared_mutex</code>（C++17）用于读多写少的场景。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过将 <code>ControlBlock::ref_count</code> 改为 <code>std::atomic&lt;int&gt;</code>，并在 <code>ThreadSafeSharedPtr</code> 中引入互斥锁来保护 <code>ptr</code> 和 <code>control</code> 的访问，可以实现一个<strong>线程安全的智能指针</strong>。这种实现确保了在多线程环境下，多个线程可以安全地拷贝、赋值和销毁智能指针，同时正确管理引用计数和资源。</p>
<p><strong>关键点总结：</strong></p>
<ul>
<li><strong>引用计数的原子性</strong>：使用 <code>std::atomic&lt;int&gt;</code> 保证引用计数操作的线程安全。</li>
<li><strong>互斥锁保护</strong>：使用 <code>std::mutex</code> 保护智能指针实例的内部状态，防止多个线程同时修改。</li>
<li><strong>RAII 机制</strong>：利用 <code>std::lock_guard</code> 和 <code>std::scoped_lock</code> 等 RAII 机制，确保锁的正确管理和释放。</li>
<li><strong>避免死锁</strong>：在需要同时锁定多个互斥锁时，使用 <code>std::scoped_lock</code> 以避免死锁风险。</li>
<li><strong>性能优化</strong>：平衡线程安全性和性能，避免不必要的锁竞争。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/27/cppbase26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/27/cppbase26/" itemprop="url">手写双端队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-27T14:10:59+08:00">
                2024-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-双端队列-Deque-概述"><a href="#1-双端队列-Deque-概述" class="headerlink" title="1. 双端队列 (Deque) 概述"></a>1. 双端队列 (Deque) 概述</h2><p><strong>双端队列</strong>（Double-Ended Queue，简称 <strong>deque</strong>）是一种允许在其两端进行高效插入和删除操作的数据结构。与普通队列（只允许在一端插入和另一端删除）相比，双端队列更为灵活。</p>
<p>C++ 标准库中已经提供了 <code>std::deque</code>，但通过自行实现一个双端队列，可以更好地理解其内部机制和迭代器的工作原理。</p>
<h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><p>为了实现一个高效的双端队列，我们需要考虑以下几点：</p>
<ol>
<li><strong>动态数组</strong>：使用动态数组（如环形缓冲区）来存储元素，以便支持在两端进行常数时间的插入和删除。</li>
<li><strong>头尾指针</strong>：维护头部和尾部的索引，以便快速访问两端。</li>
<li><strong>自动扩展</strong>：当容量不足时，自动调整内部缓冲区的大小。</li>
<li><strong>迭代器支持</strong>：定义一个迭代器类，允许用户使用像 <code>begin()</code> 和 <code>end()</code> 这样的函数进行遍历。</li>
</ol>
<p>接下来，我们将一步步实现这些功能。</p>
<h2 id="3-详细实现"><a href="#3-详细实现" class="headerlink" title="3. 详细实现"></a>3. 详细实现</h2><h3 id="3-1-内部数据结构"><a href="#3-1-内部数据结构" class="headerlink" title="3.1 内部数据结构"></a>3.1 内部数据结构</h3><p>我们将使用一个动态分配的数组作为内部缓冲区，并通过头尾索引来管理队列的前后端。为了支持在两端高效插入和删除，我们将采用<strong>环形缓冲区</strong>的概念，即当索引达到数组的末端时，自动回绕到数组的开头。</p>
<h3 id="3-2-Deque-类"><a href="#3-2-Deque-类" class="headerlink" title="3.2 Deque 类"></a>3.2 Deque 类</h3><p>下面是 <code>Deque</code> 类的基本结构和关键成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* buffer;               <span class="comment">// 内部缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> capacity;         <span class="comment">// 缓冲区容量</span></span><br><span class="line">    <span class="type">size_t</span> front_idx;        <span class="comment">// 头部索引</span></span><br><span class="line">    <span class="type">size_t</span> back_idx;         <span class="comment">// 尾部索引</span></span><br><span class="line">    <span class="type">size_t</span> count;            <span class="comment">// 当前元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        T* new_buffer = <span class="keyword">new</span> T[new_capacity];</span><br><span class="line">        <span class="comment">// 重新排列元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            new_buffer[i] = buffer[(front_idx + i) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = new_buffer;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">        front_idx = <span class="number">0</span>;</span><br><span class="line">        back_idx = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Deque</span>(<span class="type">size_t</span> initial_capacity = <span class="number">8</span>)</span><br><span class="line">        : <span class="built_in">capacity</span>(initial_capacity), <span class="built_in">front_idx</span>(<span class="number">0</span>), <span class="built_in">back_idx</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        buffer = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Deque</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数和赋值运算符（省略，为简洁起见）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : front_idx - <span class="number">1</span>;</span><br><span class="line">        buffer[front_idx] = value;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[back_idx] = value;</span><br><span class="line">        back_idx = (back_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从前面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        back_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取后端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类将放在这里（见下一部分）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类定义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Deque&lt;T&gt;* deque_ptr;</span><br><span class="line">        <span class="type">size_t</span> index;</span><br><span class="line">        <span class="type">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type        = T;</span><br><span class="line">        <span class="keyword">using</span> difference_type   = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">        <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Iterator</span>(Deque&lt;T&gt;* deque, <span class="type">size_t</span> position)</span><br><span class="line">            : <span class="built_in">deque_ptr</span>(deque), <span class="built_in">pos</span>(position) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> deque_ptr-&gt;buffer[real_idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> &amp;(deque_ptr-&gt;buffer[real_idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递增</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递增</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递减</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递减</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (deque_ptr == other.deque_ptr) &amp;&amp; (pos == other.pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 begin 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 end 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-迭代器类"><a href="#3-3-迭代器类" class="headerlink" title="3.3 迭代器类"></a>3.3 迭代器类</h3><p>在上面的 <code>Deque</code> 类中，我们定义了一个嵌套的 <code>Iterator</code> 类。这个迭代器支持前向和后向遍历，并且可以与标准的 C++ 迭代器兼容。</p>
<p><strong>关键点解释</strong>：</p>
<ol>
<li><strong>成员变量</strong>：<ul>
<li><code>deque_ptr</code>：指向包含此迭代器的 <code>Deque</code> 实例。</li>
<li><code>pos</code>：相对于队列头部的位置。</li>
</ul>
</li>
<li><strong>重载运算符</strong>：<ul>
<li><code>operator*</code> 和 <code>operator-&gt;</code>：用于访问当前元素。</li>
<li><code>operator++</code> 和 <code>operator--</code>：前置和后置递增和递减，用于移动迭代器。</li>
<li><code>operator==</code> 和 <code>operator!=</code>：用于比较两个迭代器是否相同。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>迭代器并不管理元素的生命周期，只是提供遍历接口。</li>
<li>迭代器的有效性依赖于队列的修改操作（如插入和删除）。在实际应用中，需要注意迭代器失效的问题。</li>
</ul>
</li>
</ol>
<h2 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h2><p>下面是一个使用上述 <code>Deque</code> 类及其迭代器的示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 Deque 类已经定义在这里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Deque&lt;std::string&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Elderberry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 大小: &quot;</span> &lt;&lt; dq.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问前端和后端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除元素后的 Deque: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Deque</span> 大小: <span class="number">5</span></span><br><span class="line"><span class="title class_">Deque</span> 元素: <span class="title class_">Elderberry</span> <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> <span class="title class_">Cherry</span> </span><br><span class="line">前端元素: <span class="title class_">Elderberry</span></span><br><span class="line">后端元素: <span class="title class_">Cherry</span></span><br><span class="line">删除元素后的 <span class="title class_">Deque</span>: <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> </span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ol>
<li><strong>插入操作</strong>：<ul>
<li>使用 <code>push_back</code> 在队列的后端插入 “Apple”, “Banana”, “Cherry”。</li>
<li>使用 <code>push_front</code> 在队列的前端插入 “Date”, “Elderberry”。</li>
<li>最终队列顺序为：Elderberry, Date, Apple, Banana, Cherry</li>
</ul>
</li>
<li><strong>遍历操作</strong>：<ul>
<li>使用迭代器从 <code>begin()</code> 到 <code>end()</code> 遍历并打印所有元素。</li>
</ul>
</li>
<li><strong>访问元素</strong>：<ul>
<li>使用 <code>front()</code> 获取队列前端的元素。</li>
<li>使用 <code>back()</code> 获取队列后端的元素。</li>
</ul>
</li>
<li><strong>删除操作</strong>：<ul>
<li>使用 <code>pop_front</code> 删除前端元素（”Elderberry”）。</li>
<li>使用 <code>pop_back</code> 删除后端元素（”Cherry”）。</li>
<li>删除后，队列顺序为：Date, Apple, Banana</li>
</ul>
</li>
</ol>
<h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><p>以下是完整的 <code>Deque</code> 类及其使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque 类定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* buffer;               <span class="comment">// 内部缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> capacity;         <span class="comment">// 缓冲区容量</span></span><br><span class="line">    <span class="type">size_t</span> front_idx;        <span class="comment">// 头部索引</span></span><br><span class="line">    <span class="type">size_t</span> back_idx;         <span class="comment">// 尾部索引</span></span><br><span class="line">    <span class="type">size_t</span> count;            <span class="comment">// 当前元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        T* new_buffer = <span class="keyword">new</span> T[new_capacity];</span><br><span class="line">        <span class="comment">// 重新排列元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            new_buffer[i] = buffer[(front_idx + i) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = new_buffer;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">        front_idx = <span class="number">0</span>;</span><br><span class="line">        back_idx = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Deque</span>(<span class="type">size_t</span> initial_capacity = <span class="number">8</span>)</span><br><span class="line">        : <span class="built_in">capacity</span>(initial_capacity), <span class="built_in">front_idx</span>(<span class="number">0</span>), <span class="built_in">back_idx</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        buffer = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Deque</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制构造函数和赋值运算符（为了简洁，可根据需要实现）</span></span><br><span class="line">    <span class="built_in">Deque</span>(<span class="type">const</span> Deque&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Deque&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : front_idx - <span class="number">1</span>;</span><br><span class="line">        buffer[front_idx] = value;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[back_idx] = value;</span><br><span class="line">        back_idx = (back_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从前面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front_idx = (front_idx + <span class="number">1</span>) % capacity;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后面删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        back_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer[front_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取后端元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Deque is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> last_idx = (back_idx == <span class="number">0</span>) ? capacity - <span class="number">1</span> : back_idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer[last_idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类定义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Deque&lt;T&gt;* deque_ptr;</span><br><span class="line">        <span class="type">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">        <span class="keyword">using</span> value_type        = T;</span><br><span class="line">        <span class="keyword">using</span> difference_type   = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">        <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Iterator</span>(Deque&lt;T&gt;* deque, <span class="type">size_t</span> position)</span><br><span class="line">            : <span class="built_in">deque_ptr</span>(deque), <span class="built_in">pos</span>(position) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用操作</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> deque_ptr-&gt;buffer[real_idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> real_idx = (deque_ptr-&gt;front_idx + pos) % deque_ptr-&gt;capacity;</span><br><span class="line">            <span class="keyword">return</span> &amp;(deque_ptr-&gt;buffer[real_idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递增</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递增</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置递减</span></span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置递减</span></span><br><span class="line">        Iterator <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">            --pos;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较操作</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (deque_ptr == other.deque_ptr) &amp;&amp; (pos == other.pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 begin 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 end 迭代器</span></span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="keyword">this</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Deque&lt;std::string&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Elderberry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 大小: &quot;</span> &lt;&lt; dq.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deque 元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问前端和后端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后端元素: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除元素后的 Deque: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>保存上述代码到一个文件，例如 <code>DequeWithIterator.cpp</code>，然后使用 C++ 编译器进行编译和运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -o DequeWithIterator DequeWithIterator.cpp</span><br><span class="line">./DequeWithIterator</span><br></pre></td></tr></table></figure>



<h3 id="预期输出-1"><a href="#预期输出-1" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Deque</span> 大小: <span class="number">5</span></span><br><span class="line"><span class="title class_">Deque</span> 元素: <span class="title class_">Elderberry</span> <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> <span class="title class_">Cherry</span> </span><br><span class="line">前端元素: <span class="title class_">Elderberry</span></span><br><span class="line">后端元素: <span class="title class_">Cherry</span></span><br><span class="line">删除元素后的 <span class="title class_">Deque</span>: <span class="title class_">Date</span> <span class="title class_">Apple</span> <span class="title class_">Banana</span> </span><br></pre></td></tr></table></figure>



<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通过上述步骤，我们成功实现了一个支持双端插入和删除的双端队列（deque），并添加了迭代器支持，使其能够与标准的 C++ 迭代器接口兼容。这个实现包含了以下关键点：</p>
<ol>
<li><strong>内部缓冲区管理</strong>：<ul>
<li>使用动态数组并采用环形缓冲区的方式，支持高效的双端操作。</li>
<li>自动调整缓冲区的容量，确保在元素数量增加时仍能保持高效。</li>
</ul>
</li>
<li><strong>迭代器实现</strong>：<ul>
<li>定义了一个嵌套的 <code>Iterator</code> 类，支持前向和后向遍历。</li>
<li>重载了必要的运算符（如 <code>*</code>, <code>-&gt;</code>, <code>++</code>, <code>--</code>, <code>==</code>, <code>!=</code>），以实现与标准迭代器的兼容。</li>
</ul>
</li>
<li><strong>基本操作</strong>：<ul>
<li><code>push_front</code> 和 <code>push_back</code>：分别在队列的前端和后端插入元素。</li>
<li><code>pop_front</code> 和 <code>pop_back</code>：分别从队列的前端和后端删除元素。</li>
<li><code>front</code> 和 <code>back</code>：访问队列的前端和后端元素。</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/22/cppbase25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/22/cppbase25/" itemprop="url">零基础C++(25) stl几种容器详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-22T08:17:32+08:00">
                2024-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++的标准模板库（STL）提供了多种通用容器，用于存储和管理数据。这些容器各有特点，适用于不同的应用场景。理解每种容器的用法和内部实现原理，对于编写高效且可维护的代码至关重要。本教案将详细介绍几种常用的STL容器，包括<code>vector</code>、<code>list</code>、<code>deque</code>、<code>map</code>、<code>unordered_map</code>、<code>set</code>、<code>unordered_set</code>以及容器适配器如<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。</p>
<hr>
<h2 id="vector：动态数组"><a href="#vector：动态数组" class="headerlink" title="vector：动态数组"></a><code>vector</code>：动态数组</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>vector</code>是STL中最常用的序列容器之一，提供了动态大小的数组功能。它支持随机访问，允许在末尾高效地添加和删除元素。</p>
<h3 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><code>vector</code>在内部使用动态数组（通常是连续的内存块）来存储元素。当需要扩展容量时，它会分配一块更大的内存，将现有元素复制到新内存中，然后释放旧内存。这种策略在平均情况下保证了<code>push_back</code>的常数时间复杂度。</p>
<h3 id="性能特性"><a href="#性能特性" class="headerlink" title="性能特性"></a>性能特性</h3><ul>
<li><strong>随机访问</strong>：支持常数时间的随机访问（<code>O(1)</code>）。</li>
<li><strong>末尾插入/删除</strong>：<code>push_back</code>和<code>pop_back</code>操作在摊销分析下是常数时间（<code>O(1)</code>）。</li>
<li><strong>中间插入/删除</strong>：在中间位置插入或删除元素需要移动后续元素，时间复杂度为线性时间（<code>O(n)</code>）。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要频繁随机访问元素。</li>
<li>主要在容器末尾进行插入和删除操作。</li>
<li>当容器大小不需要频繁调整（避免频繁的内存重新分配）。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向vector末尾添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历vector</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    numbers.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的vector</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除最后一个元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">第一个元素: 10</span></span><br><span class="line"><span class="section">所有元素: 10 20 30 </span></span><br><span class="line"><span class="section">删除最后一个元素后: 10 20 </span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="list：双向链表"><a href="#list：双向链表" class="headerlink" title="list：双向链表"></a><code>list</code>：双向链表</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p><code>list</code>是一个实现了双向链表的数据结构，适合在容器中间频繁插入和删除元素。与<code>vector</code>不同，<code>list</code>不支持随机访问，但在任何位置的插入和删除操作都是常数时间。</p>
<h3 id="内部实现原理-1"><a href="#内部实现原理-1" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><code>list</code>在内部使用双向链表，每个元素包含指向前一个和后一个元素的指针。这使得在已知位置插入或删除元素时，无需移动其他元素，只需更新指针即可。</p>
<h3 id="性能特性-1"><a href="#性能特性-1" class="headerlink" title="性能特性"></a>性能特性</h3><ul>
<li><strong>随机访问</strong>：不支持随机访问，访问第<code>n</code>个元素需要线性时间（<code>O(n)</code>）。</li>
<li><strong>中间插入/删除</strong>：已知位置的插入和删除操作是常数时间（<code>O(1)</code>）。</li>
<li><strong>遍历</strong>：顺序遍历，适合需要频繁遍历但不需要随机访问的场景。</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要在容器中间频繁插入或删除元素。</li>
<li>不需要进行随机访问。</li>
<li>对内存的局部性要求不高（链表元素在内存中不连续）。</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数list</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向list末尾添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">200</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向list前端添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_front</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>();</span><br><span class="line">    ++it; <span class="comment">// 指向第二个元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(it, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印插入后的list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;插入元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">remove</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">所有元素: 50 100 200 300 </span></span><br><span class="line"><span class="section">插入元素后: 50 150 100 200 300 </span></span><br><span class="line"><span class="section">删除元素后: 50 150 100 300 </span></span><br></pre></td></tr></table></figure>

<h2 id="模拟实现一个简化版的-List"><a href="#模拟实现一个简化版的-List" class="headerlink" title="模拟实现一个简化版的 List"></a>模拟实现一个简化版的 <code>List</code></h2><p>为了更好地理解 <code>std::list</code> 的内部工作原理，我们可以尝试模拟实现一个简化版的双向链表。下面将逐步介绍如何设计和实现这个 <code>List</code> 类。</p>
<h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3><p>我们的 <code>List</code> 类将包含以下组件：</p>
<ol>
<li><strong>节点结构体（Node）</strong>：表示链表的每个节点。</li>
<li><strong>迭代器类（Iterator）</strong>：允许用户遍历链表。</li>
<li><strong><code>List</code> 类</strong>：管理链表的基本操作，如插入、删除和遍历。</li>
</ol>
<h3 id="节点结构体"><a href="#节点结构体" class="headerlink" title="节点结构体"></a>节点结构体</h3><p>每个节点包含数据域和前后指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value = <span class="built_in">T</span>()) : <span class="built_in">data</span>(value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>为了实现双向迭代器，我们需要定义一个 <code>Iterator</code> 类，支持 <code>++</code> 和 <code>--</code> 操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> self_type = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Iterator</span>(Node&lt;T&gt;* ptr = <span class="literal">nullptr</span>) : <span class="built_in">node_ptr</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference operator</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> node_ptr-&gt;data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrow operator</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(node_ptr-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-increment</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-increment</span></span><br><span class="line">    self_type <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-decrement</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-decrement</span></span><br><span class="line">    self_type <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr == other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inequality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr != other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* node_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="List-类"><a href="#List-类" class="headerlink" title="List 类"></a><code>List</code> 类</h3><p><code>List</code> 类提供链表的基本功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = Iterator&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">List</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 哨兵节点</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 哨兵节点</span></span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作（简化实现）</span></span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    List&amp; <span class="keyword">operator</span>=(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到迭代器位置之前</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        Node&lt;T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(value);</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line"></span><br><span class="line">        new_node-&gt;next = current;</span><br><span class="line">        new_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = new_node;</span><br><span class="line">        current-&gt;prev = new_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        <span class="keyword">if</span> (current == head || current == tail) &#123;</span><br><span class="line">            <span class="comment">// 不能删除哨兵节点</span></span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line">        Node&lt;T&gt;* next_node = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = next_node;</span><br><span class="line">        next_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            iterator temp = <span class="built_in">end</span>();</span><br><span class="line">            --temp;</span><br><span class="line">            <span class="built_in">erase</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取尾元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;prev-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表大小（O(n)复杂度）</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            Node&lt;T&gt;* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表（辅助函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head; <span class="comment">// 头哨兵</span></span><br><span class="line">    Node&lt;T&gt;* tail; <span class="comment">// 尾哨兵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><p>下面是一个完整的示例，包括创建 <code>List</code> 对象，进行各种操作，并打印结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value = <span class="built_in">T</span>()) : <span class="built_in">data</span>(value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> self_type = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Iterator</span>(Node&lt;T&gt;* ptr = <span class="literal">nullptr</span>) : <span class="built_in">node_ptr</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference operator</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> node_ptr-&gt;data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrow operator</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(node_ptr-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-increment</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-increment</span></span><br><span class="line">    self_type <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-decrement</span></span><br><span class="line">    self_type&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_ptr) node_ptr = node_ptr-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-decrement</span></span><br><span class="line">    self_type <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self_type temp = *<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr == other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inequality comparison</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self_type&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node_ptr != other.node_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* node_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = Iterator&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = Iterator&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">List</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 头哨兵</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(); <span class="comment">// 尾哨兵</span></span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作（简化实现）</span></span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    List&amp; <span class="keyword">operator</span>=(<span class="type">const</span> List&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到迭代器位置之前</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        Node&lt;T&gt;* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(value);</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line"></span><br><span class="line">        new_node-&gt;next = current;</span><br><span class="line">        new_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = new_node;</span><br><span class="line">        current-&gt;prev = new_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = pos.node_ptr;</span><br><span class="line">        <span class="keyword">if</span> (current == head || current == tail) &#123;</span><br><span class="line">            <span class="comment">// 不能删除哨兵节点</span></span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* prev_node = current-&gt;prev;</span><br><span class="line">        Node&lt;T&gt;* next_node = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        prev_node-&gt;next = next_node;</span><br><span class="line">        next_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在头部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在尾部删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            iterator temp = <span class="built_in">end</span>();</span><br><span class="line">            --temp;</span><br><span class="line">            <span class="built_in">erase</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取尾元素引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;prev-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表大小（O(n)复杂度）</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            Node&lt;T&gt;* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束迭代器</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表（辅助函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt;* current = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(current != tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head; <span class="comment">// 头哨兵</span></span><br><span class="line">    Node&lt;T&gt;* tail; <span class="comment">// 尾哨兵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">10</span>);    <span class="comment">// 链表: 10</span></span><br><span class="line">    lst.<span class="built_in">push_front</span>(<span class="number">5</span>);    <span class="comment">// 链表: 5, 10</span></span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">15</span>);    <span class="comment">// 链表: 5, 10, 15</span></span><br><span class="line">    lst.<span class="built_in">insert</span>(++lst.<span class="built_in">begin</span>(), <span class="number">7</span>); <span class="comment">// 链表: 5, 7, 10, 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;链表内容: &quot;</span>;</span><br><span class="line">    lst.<span class="built_in">print</span>(); <span class="comment">// 输出: 5 7 10 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    lst.<span class="built_in">pop_front</span>(); <span class="comment">// 链表: 7, 10, 15</span></span><br><span class="line">    lst.<span class="built_in">pop_back</span>();  <span class="comment">// 链表: 7, 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除头尾后链表内容: &quot;</span>;</span><br><span class="line">    lst.<span class="built_in">print</span>(); <span class="comment">// 输出: 7 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除</span></span><br><span class="line">    <span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>();</span><br><span class="line">    lst.<span class="built_in">insert</span>(it, <span class="number">3</span>);  <span class="comment">// 链表: 3, 7, 10</span></span><br><span class="line">    lst.<span class="built_in">erase</span>(++it);    <span class="comment">// 链表: 3, 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;插入和删除后链表内容: &quot;</span>;</span><br><span class="line">    lst.<span class="built_in">print</span>(); <span class="comment">// 输出: 3 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空链表</span></span><br><span class="line">    lst.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空后，链表是否为空: &quot;</span> &lt;&lt; (lst.<span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p>**节点结构体 <code>Node</code>**：包含数据域 <code>data</code>，前驱指针 <code>prev</code> 和后继指针 <code>next</code>。</p>
</li>
<li><p>**迭代器类 <code>Iterator</code>**：</p>
<ul>
<li><p><strong>构造函数</strong>：接受一个 <code>Node&lt;T&gt;*</code> 指针。</p>
</li>
<li><p>重载操作符</p>
<p>：</p>
<ul>
<li><code>*</code> 和 <code>-&gt;</code> 用于访问节点数据。</li>
<li><code>++</code> 和 <code>--</code> 支持前向和后向遍历。</li>
<li><code>==</code> 和 <code>!=</code> 用于比较迭代器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>List</code> 类</strong>：</p>
<ul>
<li><p>成员变量</p>
<p>：</p>
<ul>
<li><code>head</code> 和 <code>tail</code> 是头尾哨兵节点。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>：初始化头尾哨兵，并将它们互相连接。</p>
</li>
<li><p><strong>析构函数</strong>：清空链表并删除哨兵节点。</p>
</li>
<li><p>**<code>insert</code>**：在指定位置前插入新节点。</p>
</li>
<li><p>**<code>erase</code>**：删除指定位置的节点。</p>
</li>
<li><p>**<code>push_front</code> 和 <code>push_back</code>**：分别在头部和尾部插入元素。</p>
</li>
<li><p>**<code>pop_front</code> 和 <code>pop_back</code>**：分别删除头部和尾部元素。</p>
</li>
<li><p>**<code>front</code> 和 <code>back</code>**：访问头尾元素。</p>
</li>
<li><p>**<code>empty</code> 和 <code>size</code>**：检查链表是否为空和获取链表大小。</p>
</li>
<li><p>**<code>clear</code>**：清空链表。</p>
</li>
<li><p>**<code>begin</code> 和 <code>end</code>**：返回开始和结束迭代器。</p>
</li>
<li><p>**<code>print</code>**：辅助函数，用于打印链表内容。</p>
</li>
</ul>
</li>
<li><p><strong>测试代码</strong>：创建 <code>List&lt;int&gt;</code> 对象，并执行一系列的插入、删除和遍历操作，验证 <code>List</code> 类的功能。</p>
</li>
</ol>
<h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>保存上述代码到一个名为 <code>List.cpp</code> 的文件中，然后使用以下命令编译和运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -o List List.cpp</span><br><span class="line">./List</span><br></pre></td></tr></table></figure>



<p><strong>输出结果：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">链表内容: 5 7 10 15 </span></span><br><span class="line"><span class="section">删除头尾后链表内容: 7 10 </span></span><br><span class="line"><span class="section">插入和删除后链表内容: 3 10 </span></span><br><span class="line"><span class="section">清空后，链表是否为空: 是</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h2><h3 id="1-迭代器（Iterator）简介"><a href="#1-迭代器（Iterator）简介" class="headerlink" title="1. 迭代器（Iterator）简介"></a>1. 迭代器（Iterator）简介</h3><p>在 C++ 中，<strong>迭代器</strong> 是一种用于遍历容器（如 <code>std::vector</code>、<code>std::list</code> 等）元素的对象。它们提供了类似指针的接口，使得算法可以独立于具体的容器而工作。迭代器的设计允许算法以统一的方式处理不同类型的容器。</p>
<hr>
<h3 id="2-迭代器类别（Iterator-Categories）"><a href="#2-迭代器类别（Iterator-Categories）" class="headerlink" title="2. 迭代器类别（Iterator Categories）"></a>2. 迭代器类别（Iterator Categories）</h3><p>为了使不同类型的迭代器能够支持不同的操作，C++ 标准库将迭代器分为以下几种类别，每种类别支持的操作能力逐级增强：</p>
<ol>
<li><strong>输入迭代器（Input Iterator）</strong></li>
<li><strong>输出迭代器（Output Iterator）</strong></li>
<li><strong>前向迭代器（Forward Iterator）</strong></li>
<li><strong>双向迭代器（Bidirectional Iterator）</strong></li>
<li><strong>随机访问迭代器（Random Access Iterator）</strong></li>
<li><strong>无效迭代器（Contiguous Iterator）</strong>（C++20 引入）</li>
</ol>
<p>每个类别都继承自前一个类别，具备更强的功能。例如，双向迭代器不仅支持前向迭代器的所有操作，还支持反向迭代（即可以向后移动）。</p>
<p><strong>主要迭代器类别及其特性</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>支持的操作</th>
<th>示例容器</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>只读访问、单向前进</td>
<td>单向链表 <code>std::forward_list</code></td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写访问、单向前进</td>
<td>输出流 <code>std::ostream_iterator</code></td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写访问、单向前进</td>
<td>向量 <code>std::vector</code></td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写访问、单向前进和反向迭代</td>
<td>双向链表 <code>std::list</code></td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写访问、单向前进、反向迭代、跳跃移动（支持算术运算）</td>
<td>向量 <code>std::vector</code>、队列 <code>std::deque</code></td>
</tr>
<tr>
<td>无效迭代器（新）</td>
<td>随机访问迭代器的所有功能，且元素在内存中连续排列</td>
<td>新的 C++ 容器如 <code>std::span</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-iterator-category-的作用"><a href="#3-iterator-category-的作用" class="headerlink" title="3. iterator_category 的作用"></a>3. <code>iterator_category</code> 的作用</h3><p><code>iterator_category</code> 是迭代器类型中的一个别名，用于标识该迭代器所属的类别。它是标准库中 <strong>迭代器特性（Iterator Traits）</strong> 的一部分，标准算法会根据迭代器的类别优化其行为。</p>
<h3 id="为什么需要-iterator-category"><a href="#为什么需要-iterator-category" class="headerlink" title="为什么需要 iterator_category"></a>为什么需要 <code>iterator_category</code></h3><p>标准库中的算法（如 <code>std::sort</code>、<code>std::find</code> 等）需要知道迭代器支持哪些操作，以便选择最优的实现方式。例如：</p>
<ul>
<li>对于<strong>随机访问迭代器</strong>，可以使用快速的随机访问算法（如快速排序）。</li>
<li>对于<strong>双向迭代器</strong>，只能使用适用于双向迭代的算法（如归并排序）。</li>
<li>对于<strong>输入迭代器</strong>，只能进行单次遍历，许多复杂算法无法使用。</li>
</ul>
<p>通过指定 <code>iterator_category</code>，你可以让标准算法了解你自定义迭代器的能力，从而选择合适的方法进行操作。</p>
<h3 id="iterator-category-的声明"><a href="#iterator-category-的声明" class="headerlink" title="iterator_category 的声明"></a><code>iterator_category</code> 的声明</h3><p>在你的自定义迭代器类中，通过以下方式声明迭代器类别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br></pre></td></tr></table></figure>



<p>这表示该迭代器是一个 <strong>双向迭代器</strong>，支持向前和向后遍历。</p>
<hr>
<h3 id="4-std-bidirectional-iterator-tag-详解"><a href="#4-std-bidirectional-iterator-tag-详解" class="headerlink" title="4. std::bidirectional_iterator_tag 详解"></a>4. <code>std::bidirectional_iterator_tag</code> 详解</h3><p><code>std::bidirectional_iterator_tag</code> 是一个标签（Tag），用于标识迭代器类别。C++ 标准库中有多个这样的标签，分别对应不同的迭代器类别：</p>
<ul>
<li><code>std::input_iterator_tag</code></li>
<li><code>std::output_iterator_tag</code></li>
<li><code>std::forward_iterator_tag</code></li>
<li><code>std::bidirectional_iterator_tag</code></li>
<li><code>std::random_access_iterator_tag</code></li>
<li><code>std::contiguous_iterator_tag</code>（C++20）</li>
</ul>
<p>这些标签本质上是空的结构体，用于类型区分。在标准算法中，通常会通过这些标签进行 <strong>重载选择（Overload Resolution）</strong> 或 <strong>特化（Specialization）</strong>，以实现针对不同迭代器类别的优化。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>迭代器标签是有继承关系的：</p>
<ul>
<li><code>std::forward_iterator_tag</code> 继承自 <code>std::input_iterator_tag</code></li>
<li><code>std::bidirectional_iterator_tag</code> 继承自 <code>std::forward_iterator_tag</code></li>
<li><code>std::random_access_iterator_tag</code> 继承自 <code>std::bidirectional_iterator_tag</code></li>
<li><code>std::contiguous_iterator_tag</code> 继承自 <code>std::random_access_iterator_tag</code></li>
</ul>
<p>这种继承关系反映了迭代器类别的能力层级。例如，<strong>双向迭代器</strong> 具备 <strong>前向迭代器</strong> 的所有能力，加上反向遍历的能力。</p>
<hr>
<h3 id="5-迭代器特性（Iterator-Traits）详解"><a href="#5-迭代器特性（Iterator-Traits）详解" class="headerlink" title="5. 迭代器特性（Iterator Traits）详解"></a>5. 迭代器特性（Iterator Traits）详解</h3><p>C++ 提供了 <strong>迭代器特性（Iterator Traits）</strong>，通过模板类 <code>std::iterator_traits</code> 来获取迭代器的相关信息。通过这些特性，标准算法可以泛化地处理不同类型的迭代器。</p>
<h3 id="迭代器特性包含的信息"><a href="#迭代器特性包含的信息" class="headerlink" title="迭代器特性包含的信息"></a>迭代器特性包含的信息</h3><p><code>std::iterator_traits</code> 提供以下信息：</p>
<ul>
<li><code>iterator_category</code>：迭代器类别标签。</li>
<li><code>value_type</code>：迭代器指向的元素类型。</li>
<li><code>difference_type</code>：迭代器间的距离类型（通常是 <code>std::ptrdiff_t</code>）。</li>
<li><code>pointer</code>：指向元素的指针类型。</li>
<li><code>reference</code>：对元素的引用类型。</li>
</ul>
<h3 id="自定义迭代器与-iterator-traits"><a href="#自定义迭代器与-iterator-traits" class="headerlink" title="自定义迭代器与 iterator_traits"></a>自定义迭代器与 <code>iterator_traits</code></h3><p>当你定义自己的迭代器时，确保提供这些类型别名，以便标准库算法能够正确识别和使用你的迭代器。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这样，使用 <code>std::iterator_traits&lt;Iterator&lt;T&gt;&gt;</code> 时，就能正确获取迭代器的特性。</p>
<hr>
<h2 id="deque：双端队列"><a href="#deque：双端队列" class="headerlink" title="deque：双端队列"></a><code>deque</code>：双端队列</h2><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p><code>deque</code>（双端队列）是一种支持在两端高效插入和删除元素的序列容器。与<code>vector</code>相比，<code>deque</code>支持在前端和后端均以常数时间进行插入和删除操作。</p>
<h3 id="内部实现原理-2"><a href="#内部实现原理-2" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><code>deque</code>通常由一系列固定大小的数组块组成，这些块通过一个中央映射数组进行管理。这种结构使得在两端扩展时不需要重新分配整个容器的内存，从而避免了<code>vector</code>在前端插入的高成本。</p>
<h3 id="性能特性-2"><a href="#性能特性-2" class="headerlink" title="性能特性"></a>性能特性</h3><ul>
<li><strong>随机访问</strong>：支持常数时间的随机访问（<code>O(1)</code>）。</li>
<li><strong>前后插入/删除</strong>：在前端和后端插入和删除元素的操作都是常数时间（<code>O(1)</code>）。</li>
<li><strong>中间插入/删除</strong>：在中间位置插入或删除元素需要移动元素，时间复杂度为线性时间（<code>O(n)</code>）。</li>
</ul>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要在容器两端频繁插入和删除元素。</li>
<li>需要随机访问元素。</li>
<li>不需要频繁在中间位置插入和删除元素。</li>
</ul>
<h2 id="双端队列简介"><a href="#双端队列简介" class="headerlink" title="双端队列简介"></a>双端队列简介</h2><p><strong>双端队列（deque）</strong>是一种序列容器，允许在其两端高效地插入和删除元素。与<code>vector</code>不同，<code>deque</code>不仅支持在末尾添加或删除元素（如<code>vector</code>），还支持在头部进行同样的操作。此外，<code>deque</code>提供了随机访问能力，可以像<code>vector</code>一样通过索引访问元素。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li><strong>双端操作</strong>：支持在头部和尾部高效的插入和删除操作。</li>
<li><strong>随机访问</strong>：可以像数组和<code>vector</code>一样通过索引访问元素。</li>
<li><strong>动态大小</strong>：可以根据需要增长和收缩，无需预先定义大小。</li>
</ul>
<hr>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p><code>deque</code>内部并不使用一个单一的连续内存块，而是将元素分割成多个<strong>固定大小的块</strong>（也称为<strong>缓冲区</strong>或<strong>页面</strong>），并通过一个<strong>中央映射数组</strong>（通常称为<strong>map</strong>）来管理这些块。具体来说，<code>deque</code>的内部结构可以分为以下几个部分：</p>
<ol>
<li><strong>中央映射数组（Map）</strong>：<ul>
<li>一个指针数组，指向各个数据块。</li>
<li><code>map</code>本身也是动态分配的，可以根据需要增长或收缩。</li>
<li><code>map</code>允许<code>deque</code>在两端添加新的数据块，而无需移动现有的数据块。</li>
</ul>
</li>
<li><strong>数据块（Blocks）</strong>：<ul>
<li>每个数据块是一个固定大小的连续内存区域，用于存储元素。</li>
<li>数据块的大小通常与编译器和平台相关，但在大多数实现中，数据块的大小在运行时是固定的（如512字节或更多，具体取决于元素类型的大小）。</li>
</ul>
</li>
<li><strong>起始和结束指针</strong>：<ul>
<li><code>deque</code>维护指向中央映射数组中第一个有效数据块的指针以及第一个无效数据块的指针。</li>
<li>这些指针帮助<code>deque</code>快速地在两端添加或删除数据块。</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.llfc.club/912f900f6a609de906df07ee849a57f.png" alt="https://cdn.llfc.club/912f900f6a609de906df07ee849a57f.png"></p>
<h3 id="双端队列的操作实现"><a href="#双端队列的操作实现" class="headerlink" title="双端队列的操作实现"></a>双端队列的操作实现</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p><strong>在末尾插入 (<code>push_back</code>)</strong></p>
<ol>
<li><strong>检查当前末端数据块的剩余空间</strong>：<ul>
<li>如果有空间，直接在当前末端数据块中插入新元素。</li>
<li>如果没有空间，分配一个新的数据块，并将其指针添加到<code>map</code>中，然后在新块中插入元素。</li>
</ul>
</li>
<li><strong>更新末尾指针</strong>：<ul>
<li>如果分配了新块，末尾指针指向该块的第一个元素。</li>
<li>否则，末尾指针移动到当前末端数据块的下一个位置。</li>
</ul>
</li>
</ol>
<p><strong>在前端插入 (<code>push_front</code>)</strong></p>
<ol>
<li><strong>检查当前前端数据块的剩余空间</strong>：<ul>
<li>如果有空间，直接在当前前端数据块中插入新元素。</li>
<li>如果没有空间，分配一个新的数据块，并将其指针添加到<code>map</code>的前面，然后在新块中插入元素。</li>
</ul>
</li>
<li><strong>更新前端指针</strong>：<ul>
<li>如果分配了新块，前端指针指向该块的最后一个元素。</li>
<li>否则，前端指针移动到当前前端数据块的前一个位置。</li>
</ul>
</li>
</ol>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p><strong>从末尾删除 (<code>pop_back</code>)</strong></p>
<ol>
<li><p>检查末端数据块是否有元素</p>
<p>：</p>
<ul>
<li>如果有，移除最后一个元素，并更新末尾指针。</li>
<li>如果数据块变为空，释放该数据块并从<code>map</code>中移除其指针，然后更新末尾指针指向前一个块。</li>
</ul>
</li>
</ol>
<p><strong>从前端删除 (<code>pop_front</code>)</strong></p>
<ol>
<li><p>检查前端数据块是否有元素</p>
<p>：</p>
<ul>
<li>如果有，移除第一个元素，并更新前端指针。</li>
<li>如果数据块变为空，释放该数据块并从<code>map</code>中移除其指针，然后更新前端指针指向下一个块。</li>
</ul>
</li>
</ol>
<h4 id="访问操作"><a href="#访问操作" class="headerlink" title="访问操作"></a>访问操作</h4><p><strong>随机访问</strong></p>
<p><code>deque</code>支持通过索引进行随机访问，其内部机制如下：</p>
<ol>
<li><strong>计算元素的位置</strong>：<ul>
<li>根据给定的索引，确定对应的<strong>数据块</strong>和<strong>数据块内的偏移量</strong>。</li>
<li>使用<code>map</code>数组定位到具体的块，然后通过偏移量定位到块内的元素。</li>
</ul>
</li>
<li><strong>访问元素</strong>：<ul>
<li>一旦定位到具体的位置，即可像数组一样访问元素。</li>
</ul>
</li>
</ol>
<p><strong>迭代器访问</strong></p>
<p><code>deque</code>提供双向迭代器，支持使用标准的C++迭代器操作（如<code>++</code>、<code>--</code>等）进行遍历。</p>
<hr>
<h3 id="双端队列的性能特性"><a href="#双端队列的性能特性" class="headerlink" title="双端队列的性能特性"></a>双端队列的性能特性</h3><p>理解<code>deque</code>的内部实现有助于理解其性能特性。以下是<code>deque</code>的主要操作及其时间复杂度：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>随机访问（通过索引）</td>
<td>常数时间（O(1)）</td>
<td>通过计算块和偏移量直接访问元素</td>
</tr>
<tr>
<td>插入/删除前端</td>
<td>常数时间（O(1)）</td>
<td>仅涉及前端指针和可能的数据块分配</td>
</tr>
<tr>
<td>插入/删除末端</td>
<td>常数时间（O(1)）</td>
<td>仅涉及末端指针和可能的数据块分配</td>
</tr>
<tr>
<td>中间插入/删除</td>
<td>线性时间（O(n)）</td>
<td>需要移动数据块内的元素，可能涉及多个块的操作</td>
</tr>
<tr>
<td>查找元素</td>
<td>线性时间（O(n)）</td>
<td>需要遍历元素进行查找</td>
</tr>
<tr>
<td>插入单个元素</td>
<td>平均常数时间（O(1)）</td>
<td>在前端或末端插入，通常不需移动大量元素</td>
</tr>
<tr>
<td>插入大量元素</td>
<td>线性时间（O(n)）</td>
<td>需要分配新的数据块并进行元素复制</td>
</tr>
</tbody></table>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>双端操作高效</strong>：在两端插入和删除元素非常快速，不需要移动大量元素。</li>
<li><strong>支持随机访问</strong>：可以像<code>vector</code>一样通过索引高效访问元素。</li>
<li><strong>动态增长</strong>：无需预先定义大小，可以根据需要自动调整。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>内存碎片</strong>：由于使用多个数据块，可能导致内存碎片，尤其是在大量插入和删除操作后。</li>
<li><strong>较低的局部性</strong>：元素不连续存储，可能导致缓存未命中率较高，影响性能。</li>
<li><strong>复杂性较高</strong>：内部实现相对复杂，不如<code>vector</code>直接高效。</li>
</ul>
<hr>
<h2 id="双端队列与其他容器的比较"><a href="#双端队列与其他容器的比较" class="headerlink" title="双端队列与其他容器的比较"></a>双端队列与其他容器的比较</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>vector</code></th>
<th><code>deque</code></th>
<th><code>list</code></th>
</tr>
</thead>
<tbody><tr>
<td>内存结构</td>
<td>单一连续内存块</td>
<td>多块连续内存，通过映射数组管理</td>
<td>双向链表</td>
</tr>
<tr>
<td>随机访问</td>
<td>是，常数时间（O(1)）</td>
<td>是，常数时间（O(1)）</td>
<td>否，需要线性时间（O(n)）</td>
</tr>
<tr>
<td>前端插入/删除</td>
<td>低效，线性时间（O(n)）</td>
<td>高效，常数时间（O(1)）</td>
<td>高效，常数时间（O(1)）</td>
</tr>
<tr>
<td>末端插入/删除</td>
<td>高效，常数时间（O(1)）</td>
<td>高效，常数时间（O(1)）</td>
<td>高效，常数时间（O(1)）</td>
</tr>
<tr>
<td>内存碎片</td>
<td>低，由于单一连续内存块</td>
<td>较高，由于多块内存管理</td>
<td>较高，由于节点分散在内存中</td>
</tr>
<tr>
<td>元素隔离</td>
<td>高，局部性较好</td>
<td>中等，分块存储提高了部分局部性</td>
<td>低，元素分散存储，缓存效率低</td>
</tr>
<tr>
<td>应用场景</td>
<td>需要频繁随机访问、末端操作的场景</td>
<td>需要频繁在两端插入/删除且偶尔随机访问的场景</td>
<td>需要频繁在中间插入/删除且不需要随机访问的场景</td>
</tr>
</tbody></table>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的deque</span></span><br><span class="line">    std::deque&lt;std::string&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;End1&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="string">&quot;End2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前端添加元素</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Front1&quot;</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="string">&quot;Front2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历deque</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = dq.<span class="built_in">begin</span>(); it != dq.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问首尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;首元素: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尾元素: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除首元素</span></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除尾元素</span></span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的deque</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除首尾元素后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : dq) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">deque中的元素: Front2 Front1 End1 End2 </span></span><br><span class="line"><span class="section">首元素: Front2</span></span><br><span class="line"><span class="section">尾元素: End2</span></span><br><span class="line"><span class="section">删除首尾元素后: Front1 End1 </span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="map和unordered-map：关联数组"><a href="#map和unordered-map：关联数组" class="headerlink" title="map和unordered_map：关联数组"></a><code>map</code>和<code>unordered_map</code>：关联数组</h2><h3 id="map用法与原理"><a href="#map用法与原理" class="headerlink" title="map用法与原理"></a><code>map</code>用法与原理</h3><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>map</code>是一个关联容器，用于存储键值对（key-value）。它基于键自动排序，且每个键都是唯一的。<code>map</code>提供了快速的查找、插入和删除操作。</p>
<h4 id="内部实现原理-3"><a href="#内部实现原理-3" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>map</code>通常使用自平衡的二叉搜索树（如红黑树）实现。这确保了所有操作的时间复杂度为对数时间（<code>O(log n)</code>），且元素按照键的顺序排列。</p>
<h3 id="unordered-map用法与原理"><a href="#unordered-map用法与原理" class="headerlink" title="unordered_map用法与原理"></a><code>unordered_map</code>用法与原理</h3><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>unordered_map</code>也是一种关联容器，用于存储键值对，但它不保证元素的顺序。<code>unordered_map</code>基于哈希表实现，提供了平均常数时间（<code>O(1)</code>）的查找、插入和删除操作。</p>
<h4 id="内部实现原理-4"><a href="#内部实现原理-4" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>unordered_map</code>使用哈希表来存储元素。键通过哈希函数转换为哈希值，并映射到特定的桶中。如果多个键映射到同一桶，会通过链表或其他方法解决冲突。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th>操作</th>
<th><code>map</code></th>
<th><code>unordered_map</code></th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td><code>O(log n)</code></td>
<td>平均 <code>O(1)</code></td>
</tr>
<tr>
<td>插入</td>
<td><code>O(log n)</code></td>
<td>平均 <code>O(1)</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>O(log n)</code></td>
<td>平均 <code>O(1)</code></td>
</tr>
<tr>
<td>内存使用</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>元素顺序</td>
<td>有序</td>
<td>无序</td>
</tr>
</tbody></table>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>**<code>map</code>**：<ul>
<li>需要按键的顺序遍历元素。</li>
<li>需要有序的关联数组。</li>
<li>需要高效的范围查找。</li>
</ul>
</li>
<li>**<code>unordered_map</code>**：<ul>
<li>对元素顺序没有要求。</li>
<li>需要极高效的查找、插入和删除操作。</li>
<li>不需要自定义的排序规则。</li>
</ul>
</li>
</ul>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="map示例"><a href="#map示例" class="headerlink" title="map示例"></a><code>map</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的map，键为string，值为int</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ageMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ageMap.<span class="built_in">find</span>(name) != ageMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 的年龄是 &quot;</span> &lt;&lt; ageMap[name] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有人员和年龄: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ageMap.<span class="built_in">begin</span>(); it != ageMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    ageMap.<span class="built_in">erase</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除Alice后: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : ageMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="unordered-map示例"><a href="#unordered-map示例" class="headerlink" title="unordered_map示例"></a><code>unordered_map</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的unordered_map，键为string，值为double</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">double</span>&gt; priceMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    priceMap[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1.2</span>;</span><br><span class="line">    priceMap[<span class="string">&quot;Banana&quot;</span>] = <span class="number">0.5</span>;</span><br><span class="line">    priceMap[<span class="string">&quot;Orange&quot;</span>] = <span class="number">0.8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    std::string fruit = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(priceMap.<span class="built_in">find</span>(fruit) != priceMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; 的价格是 $&quot;</span> &lt;&lt; priceMap[fruit] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到 &quot;</span> &lt;&lt; fruit &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历unordered_map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有水果和价格: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : priceMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; : $&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    priceMap.<span class="built_in">erase</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的unordered_map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除Apple后: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key, value] : priceMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; : $&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><h4 id="map输出"><a href="#map输出" class="headerlink" title="map输出"></a><code>map</code>输出</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Bob</span> <span class="string">的年龄是</span> <span class="number">25</span></span><br><span class="line"><span class="string">所有人员和年龄:</span> </span><br><span class="line"><span class="attr">Alice :</span> <span class="number">30</span></span><br><span class="line"><span class="attr">Bob :</span> <span class="number">25</span></span><br><span class="line"><span class="attr">Charlie :</span> <span class="number">35</span></span><br><span class="line"><span class="string">删除Alice后:</span> </span><br><span class="line"><span class="attr">Bob :</span> <span class="number">25</span></span><br><span class="line"><span class="attr">Charlie :</span> <span class="number">35</span></span><br></pre></td></tr></table></figure>



<h4 id="unordered-map输出"><a href="#unordered-map输出" class="headerlink" title="unordered_map输出"></a><code>unordered_map</code>输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Banana 的价格是 <span class="variable">$0</span>.5</span><br><span class="line">所有水果和价格: </span><br><span class="line">Apple : <span class="variable">$1</span>.2</span><br><span class="line">Banana : <span class="variable">$0</span>.5</span><br><span class="line">Orange : <span class="variable">$0</span>.8</span><br><span class="line">删除Apple后: </span><br><span class="line">Banana : <span class="variable">$0</span>.5</span><br><span class="line">Orange : <span class="variable">$0</span>.8</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="set和unordered-set：集合"><a href="#set和unordered-set：集合" class="headerlink" title="set和unordered_set：集合"></a><code>set</code>和<code>unordered_set</code>：集合</h2><h3 id="set用法与原理"><a href="#set用法与原理" class="headerlink" title="set用法与原理"></a><code>set</code>用法与原理</h3><h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><p><code>set</code>是一个关联容器，用于存储唯一的、有序的元素。<code>set</code>基于键自动排序，且每个元素都是唯一的。</p>
<h4 id="内部实现原理-5"><a href="#内部实现原理-5" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>set</code>通常使用自平衡的二叉搜索树（如红黑树）实现，保证元素按顺序排列。每次插入元素时，都会自动保持树的平衡，并确保元素的唯一性。</p>
<h3 id="unordered-set用法与原理"><a href="#unordered-set用法与原理" class="headerlink" title="unordered_set用法与原理"></a><code>unordered_set</code>用法与原理</h3><h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><p><code>unordered_set</code>也是一种集合容器，用于存储唯一的元素，但它不保证元素的顺序。<code>unordered_set</code>基于哈希表实现，提供了平均常数时间（<code>O(1)</code>）的查找、插入和删除操作。</p>
<h4 id="内部实现原理-6"><a href="#内部实现原理-6" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><code>unordered_set</code>使用哈希表存储元素。每个元素通过哈希函数转换为哈希值，并映射到特定的桶中。冲突通过链表或其他方法解决。</p>
<h3 id="性能对比-1"><a href="#性能对比-1" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th>操作</th>
<th><code>set</code></th>
<th><code>unordered_set</code></th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td><code>O(log n)</code></td>
<td>平均 <code>O(1)</code></td>
</tr>
<tr>
<td>插入</td>
<td><code>O(log n)</code></td>
<td>平均 <code>O(1)</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>O(log n)</code></td>
<td>平均 <code>O(1)</code></td>
</tr>
<tr>
<td>内存使用</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>元素顺序</td>
<td>有序</td>
<td>无序</td>
</tr>
</tbody></table>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>**<code>set</code>**：<ul>
<li>需要有序的唯一元素集合。</li>
<li>需要按顺序遍历元素。</li>
<li>需要基于区间的操作（如查找、删除某范围的元素）。</li>
</ul>
</li>
<li>**<code>unordered_set</code>**：<ul>
<li>对元素顺序无要求。</li>
<li>需要极高效的查找、插入和删除操作。</li>
<li>不需要自定义的排序规则。</li>
</ul>
</li>
</ul>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="set示例"><a href="#set示例" class="headerlink" title="set示例"></a><code>set</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数set</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>); <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.<span class="built_in">find</span>(key) != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 在set中存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 不在set中。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除10后set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="unordered-set示例"><a href="#unordered-set示例" class="headerlink" title="unordered_set示例"></a><code>unordered_set</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的unordered_set</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>); <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历unordered_set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unordered_set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.<span class="built_in">find</span>(key) != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 在unordered_set中存在。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; 不在unordered_set中。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印删除后的unordered_set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除10后unordered_set中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><h4 id="set输出"><a href="#set输出" class="headerlink" title="set输出"></a><code>set</code>输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>中的元素: 10 20 30 </span><br><span class="line">20 在<span class="built_in">set</span>中存在。</span><br><span class="line">删除10后<span class="built_in">set</span>中的元素: 20 30 </span><br></pre></td></tr></table></figure>



<h4 id="unordered-set输出（注意元素顺序可能不同）"><a href="#unordered-set输出（注意元素顺序可能不同）" class="headerlink" title="unordered_set输出（注意元素顺序可能不同）"></a><code>unordered_set</code>输出（注意元素顺序可能不同）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_set中的元素: <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br><span class="line"><span class="number">20</span> 在unordered_set中存在。</span><br><span class="line">删除<span class="number">10</span>后unordered_set中的元素: <span class="number">20</span> <span class="number">30</span> </span><br></pre></td></tr></table></figure>



<hr>
<h2 id="stack、queue和priority-queue：容器适配器"><a href="#stack、queue和priority-queue：容器适配器" class="headerlink" title="stack、queue和priority_queue：容器适配器"></a><code>stack</code>、<code>queue</code>和<code>priority_queue</code>：容器适配器</h2><h3 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h3><p>STL中的容器适配器（<code>stack</code>、<code>queue</code>、<code>priority_queue</code>）提供了特定的数据结构接口，这些适配器在内部使用其他容器来存储元素（默认使用<code>deque</code>或<code>vector</code>）。</p>
<h3 id="内部实现原理-7"><a href="#内部实现原理-7" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><ul>
<li>**<code>stack</code>**：后进先出（LIFO）数据结构，通常使用<code>deque</code>或<code>vector</code>作为底层容器，通过限制操作接口来实现。</li>
<li>**<code>queue</code>**：先进先出（FIFO）数据结构，通常使用<code>deque</code>作为底层容器，通过限制操作接口来实现。</li>
<li>**<code>priority_queue</code>**：基于堆的数据结构，通常使用<code>vector</code>作为底层容器，并通过堆算法（如<code>std::make_heap</code>、<code>std::push_heap</code>、<code>std::pop_heap</code>）维护元素的优先级顺序。</li>
</ul>
<h3 id="性能特性-3"><a href="#性能特性-3" class="headerlink" title="性能特性"></a>性能特性</h3><ul>
<li>**<code>stack</code>**：<ul>
<li>访问顶部元素：<code>O(1)</code></li>
<li>插入和删除：<code>O(1)</code></li>
</ul>
</li>
<li>**<code>queue</code>**：<ul>
<li>访问前端和后端元素：<code>O(1)</code></li>
<li>插入和删除：<code>O(1)</code></li>
</ul>
</li>
<li>**<code>priority_queue</code>**：<ul>
<li>访问顶部（最大或最小元素）：<code>O(1)</code></li>
<li>插入和删除：<code>O(log n)</code></li>
</ul>
</li>
</ul>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>**<code>stack</code>**：<ul>
<li>实现函数调用栈。</li>
<li>处理撤销操作。</li>
<li>深度优先搜索（DFS）。</li>
</ul>
</li>
<li>**<code>queue</code>**：<ul>
<li>实现任务调度。</li>
<li>广度优先搜索（BFS）。</li>
<li>数据流处理。</li>
</ul>
</li>
<li>**<code>priority_queue</code>**：<ul>
<li>实现优先级调度。</li>
<li>求解最短路径算法（如Dijkstra）。</li>
<li>任意需要按优先级处理元素的场景。</li>
</ul>
</li>
</ul>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="stack示例"><a href="#stack示例" class="headerlink" title="stack示例"></a><code>stack</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的stack，底层使用vector</span></span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;弹出一个元素后，新的栈顶: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈不为空，元素数量: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="queue示例"><a href="#queue示例" class="headerlink" title="queue示例"></a><code>queue</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的queue，底层使用deque</span></span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队元素</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队首元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队首元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队尾元素: &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;出队后新的队首: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列不为空，元素数量: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="priority-queue示例"><a href="#priority-queue示例" class="headerlink" title="priority_queue示例"></a><code>priority_queue</code>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的priority_queue，默认是最大堆</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问堆顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;优先级最高的元素: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出元素</span></span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;弹出一个元素后，新的堆顶: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历priority_queue（需要复制，因为无法直接遍历）</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; copy = pq;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;剩余的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!copy.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; copy.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        copy.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><h4 id="stack输出"><a href="#stack输出" class="headerlink" title="stack输出"></a><code>stack</code>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">栈顶元素: 3</span></span><br><span class="line"><span class="section">弹出一个元素后，新的栈顶: 2</span></span><br><span class="line"><span class="section">栈不为空，元素数量: 2</span></span><br></pre></td></tr></table></figure>



<h4 id="queue输出"><a href="#queue输出" class="headerlink" title="queue输出"></a><code>queue</code>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">队首元素: First</span></span><br><span class="line"><span class="section">队尾元素: Third</span></span><br><span class="line"><span class="section">出队后新的队首: Second</span></span><br><span class="line"><span class="section">队列不为空，元素数量: 2</span></span><br></pre></td></tr></table></figure>



<h4 id="priority-queue输出"><a href="#priority-queue输出" class="headerlink" title="priority_queue输出"></a><code>priority_queue</code>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">优先级最高的元素: 40</span></span><br><span class="line"><span class="section">弹出一个元素后，新的堆顶: 30</span></span><br><span class="line"><span class="section">剩余的元素: 30 20 10 </span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ STL提供了丰富多样的容器，适用于各种不同的数据存储和管理需求。理解每种容器的特点、内部实现原理以及性能特性，可以帮助开发者在实际应用中做出最佳的选择，从而编写出高效且可维护的代码。</p>
<ul>
<li><strong>序列容器</strong>：<ul>
<li>**<code>vector</code>**：适用于需要频繁随机访问和在末尾操作的场景。</li>
<li>**<code>list</code>**：适用于需要在中间频繁插入和删除的场景。</li>
<li>**<code>deque</code>**：适用于需要在两端频繁插入和删除的场景。</li>
</ul>
</li>
<li><strong>关联容器</strong>：<ul>
<li>**<code>map</code>*<em>和*</em><code>set</code>**：适用于需要有序存储和快速查找的场景。</li>
<li>**<code>unordered_map</code>*<em>和*</em><code>unordered_set</code>**：适用于需要高效查找且对元素顺序无要求的场景。</li>
</ul>
</li>
<li><strong>容器适配器</strong>：<ul>
<li>**<code>stack</code>**：用于LIFO操作。</li>
<li>**<code>queue</code>**：用于FIFO操作。</li>
<li>**<code>priority_queue</code>**：用于优先级队列操作。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/06/cppbase23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/06/cppbase23/" itemprop="url">零基础C++(23) 智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-06T10:57:07+08:00">
                2024-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 <code>new</code> 和 <code>delete</code> 带来的复杂性和错误。智能指针通过 <code>RAII</code>（资源获取即初始化）机制，在对象生命周期结束时自动释放资源，从而有效防止内存泄漏和资源管理错误。</p>
<h2 id="2-原生指针-vs-智能指针"><a href="#2-原生指针-vs-智能指针" class="headerlink" title="2. 原生指针 vs 智能指针"></a>2. 原生指针 vs 智能指针</h2><h3 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h3><p>原生指针是 C++ 最基本的指针类型，允许程序员直接管理内存。然而，原生指针存在以下问题：</p>
<ul>
<li><strong>内存泄漏</strong>：未释放动态分配的内存。</li>
<li><strong>悬挂指针</strong>：指针指向已释放或未初始化的内存。</li>
<li><strong>双重释放</strong>：多次释放同一内存区域。</li>
</ul>
<h3 id="智能指针的优势"><a href="#智能指针的优势" class="headerlink" title="智能指针的优势"></a>智能指针的优势</h3><p>智能指针通过封装原生指针，自动管理内存，解决上述问题。主要优势包括：</p>
<ul>
<li><strong>自动销毁</strong>：在智能指针生命周期结束时自动释放资源。</li>
<li><strong>引用计数</strong>：共享智能指针能够跟踪引用数量，确保资源在最后一个引用结束时释放。</li>
<li><strong>避免内存泄漏</strong>：通过 RAII 机制自动管理资源生命周期。</li>
<li><strong>类型安全</strong>：提供更严格的类型检查，减少错误。</li>
</ul>
<h2 id="3-std-unique-ptr"><a href="#3-std-unique-ptr" class="headerlink" title="3. std::unique_ptr"></a>3. <code>std::unique_ptr</code></h2><h3 id="3-1-定义与用法"><a href="#3-1-定义与用法" class="headerlink" title="3.1 定义与用法"></a>3.1 定义与用法</h3><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，任何时刻只能有一个 <code>unique_ptr</code> 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。</p>
<p><strong>主要特性</strong>：</p>
<ul>
<li><strong>独占所有权</strong>：确保资源在一个所有者下。</li>
<li><strong>轻量级</strong>：没有引用计数，开销小。</li>
<li><strong>自动释放</strong>：在指针销毁时自动释放资源。</li>
</ul>
<h3 id="3-2-构造函数与赋值"><a href="#3-2-构造函数与赋值" class="headerlink" title="3.2 构造函数与赋值"></a>3.2 构造函数与赋值</h3><p><code>unique_ptr</code> 提供多种构造函数和赋值操作，以支持不同的使用场景。</p>
<ul>
<li><strong>默认构造函数</strong>：创建一个空的 <code>unique_ptr</code>。</li>
<li><strong>指针构造函数</strong>：接受一个裸指针，拥有其所有权。</li>
<li><strong>移动构造函数</strong>：将一个 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li>
<li><strong>移动赋值操作符</strong>：将一个 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li>
</ul>
<h3 id="3-3-移动语义"><a href="#3-3-移动语义" class="headerlink" title="3.3 移动语义"></a>3.3 移动语义</h3><p>由于 <code>unique_ptr</code> 不能被拷贝，必须通过移动语义转移所有权。这保证了资源的独占性。</p>
<h3 id="3-4-代码案例"><a href="#3-4-代码案例" class="headerlink" title="3.4 代码案例"></a>3.4 代码案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unique_ptr</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 make_unique（C++14 引入）</span></span><br><span class="line">    <span class="keyword">auto</span> ptr2 = std::<span class="built_in">make_unique</span>&lt;Test&gt;(<span class="number">200</span>);</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动 unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Test&gt; ptr3 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr3-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 unique_ptr</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">300</span>));</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr 自动释放资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">ptr1</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">move.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><code>ptr1</code> 拥有 <code>Test(100)</code>，<code>ptr2</code> 拥有 <code>Test(200)</code>。</li>
<li>通过 <code>std::move</code> 将 <code>ptr1</code> 的所有权转移到 <code>ptr3</code>，<code>ptr1</code> 变为空。</li>
<li><code>ptr2.reset(new Test(300))</code> 释放了原有的 <code>Test(200)</code>，并拥有新的 <code>Test(300)</code>。</li>
<li>程序结束时，<code>ptr3</code> 和 <code>ptr2</code> 自动释放各自拥有的资源。</li>
</ul>
<h2 id="4-std-shared-ptr"><a href="#4-std-shared-ptr" class="headerlink" title="4. std::shared_ptr"></a>4. <code>std::shared_ptr</code></h2><h3 id="4-1-定义与用法"><a href="#4-1-定义与用法" class="headerlink" title="4.1 定义与用法"></a>4.1 定义与用法</h3><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，允许多个 <code>shared_ptr</code> 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。</p>
<p><strong>主要特性</strong>：</p>
<ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可以指向同一个对象。</li>
<li><strong>引用计数</strong>：跟踪有多少 <code>shared_ptr</code> 实例指向同一对象。</li>
<li><strong>自动释放</strong>：当引用计数为0时，自动释放资源。</li>
</ul>
<h3 id="4-2-引用计数与控制块"><a href="#4-2-引用计数与控制块" class="headerlink" title="4.2 引用计数与控制块"></a>4.2 引用计数与控制块</h3><p><code>shared_ptr</code> 背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括：</p>
<ul>
<li><strong>强引用计数（<code>use_count</code>）</strong>：表示有多少个 <code>shared_ptr</code> 指向对象。</li>
<li><strong>弱引用计数（<code>weak_count</code>）</strong>：表示有多少个 <code>weak_ptr</code> 指向对象（不增加强引用计数）。</li>
</ul>
<h3 id="4-3-构造函数与赋值"><a href="#4-3-构造函数与赋值" class="headerlink" title="4.3 构造函数与赋值"></a>4.3 构造函数与赋值</h3><p><code>shared_ptr</code> 提供多种构造函数和赋值操作，以支持不同的使用场景。</p>
<ul>
<li><strong>默认构造函数</strong>：创建一个空的 <code>shared_ptr</code>。</li>
<li><strong>指针构造函数</strong>：接受一个裸指针，拥有其所有权。</li>
<li><strong>拷贝构造函数</strong>：增加引用计数，共享对象所有权。</li>
<li><strong>移动构造函数</strong>：转移所有权，源 <code>shared_ptr</code> 变为空。</li>
<li><strong>拷贝赋值操作符</strong>：释放当前资源，增加引用计数，指向新对象。</li>
<li><strong>移动赋值操作符</strong>：释放当前资源，转移所有权，源 <code>shared_ptr</code> 变为空。</li>
</ul>
<h3 id="4-4-代码案例"><a href="#4-4-代码案例" class="headerlink" title="4.4 代码案例"></a>4.4 代码案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sp1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过拷贝构造共享所有权</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp2 = sp1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp2 = sp1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过拷贝赋值共享所有权</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp3;</span><br><span class="line">    sp3 = sp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp3 = sp2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 shared_ptr</span></span><br><span class="line">    sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">200</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp2.reset(new Test(200)):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动释放资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp2</span> <span class="string">=</span> <span class="attr">sp1:</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp3</span> <span class="string">=</span> <span class="attr">sp2:</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">sp3 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp2.reset(new</span> <span class="string">Test(200)):</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">sp3 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">Exiting</span> <span class="string">main...</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><p>创建 <code>sp1</code>，引用计数为1。</p>
</li>
<li><p>拷贝构造 <code>sp2</code>，引用计数增加到2。</p>
</li>
<li><p>拷贝赋值 <code>sp3</code>，引用计数增加到3。</p>
</li>
<li><p>```<br>sp2.reset(new Test(200))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 原 `Test(100)` 的引用计数减少到2。</span><br><span class="line">  - 分配新的 `Test(200)`，`sp2` 拥有它，引用计数为1。</span><br><span class="line"></span><br><span class="line">- 程序结束时：</span><br><span class="line"></span><br><span class="line">  - `sp1` 和 `sp3` 释放 `Test(100)`，引用计数降到0，资源被销毁。</span><br><span class="line">  - `sp2` 释放 `Test(200)`，引用计数为0，资源被销毁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5. `std::weak_ptr`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.1 定义与用法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`std::weak_ptr` 是一种不拥有对象所有权的智能指针，用于观察但不影响对象的生命周期。主要用于解决 `shared_ptr` 之间的循环引用问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**主要特性**：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **非拥有所有权**：不增加引用计数。</span><br><span class="line">- **可从 `shared_ptr` 生成**：通过 `std::weak_ptr` 可以访问 `shared_ptr` 管理的对象。</span><br><span class="line">- **避免循环引用**：适用于双向关联或观察者模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.2 避免循环引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在存在双向关联（如父子关系）时，使用多个 `shared_ptr` 可能导致循环引用，导致内存泄漏。此时，可以使用 `weak_ptr` 来打破循环。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.3 代码案例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 场景：双向关联导致循环引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class B; // 前向声明</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB;</span><br><span class="line"></span><br><span class="line">    A() &#123; std::cout &lt;&lt; &quot;A Constructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~A() &#123; std::cout &lt;&lt; &quot;A Destructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA;</span><br><span class="line"></span><br><span class="line">    B() &#123; std::cout &lt;&lt; &quot;B Constructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~B() &#123; std::cout &lt;&lt; &quot;B Destructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();</span><br><span class="line">        a-&gt;ptrB = b;</span><br><span class="line">        b-&gt;ptrA = a;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> Constructor</span><br><span class="line"><span class="selector-tag">B</span> Constructor</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br><span class="line"><span class="selector-tag">A</span> Destructor</span><br><span class="line"><span class="selector-tag">B</span> Destructor</span><br></pre></td></tr></table></figure>



<p><strong>问题</strong>：</p>
<p>虽然 <code>a</code> 和 <code>b</code> 离开作用域，但 <code>A Destructor</code> 和 <code>B Destructor</code> 并未被调用，因为 <code>a</code> 和 <code>b</code> 相互引用，引用计数无法降到0，导致内存泄漏。</p>
<h4 id="解决方案：使用-weak-ptr"><a href="#解决方案：使用-weak-ptr" class="headerlink" title="解决方案：使用 weak_ptr"></a>解决方案：使用 <code>weak_ptr</code></h4><p>改用 <code>weak_ptr</code> 其中一方（如 <code>B</code> 的 <code>ptrA</code>），打破循环引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; ptrA; <span class="comment">// 使用 weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;ptrB = b;</span><br><span class="line">        b-&gt;ptrA = a;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> Constructor</span><br><span class="line"><span class="selector-tag">B</span> Constructor</span><br><span class="line"><span class="selector-tag">A</span> Destructor</span><br><span class="line"><span class="selector-tag">B</span> Destructor</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><code>B</code> 使用 <code>weak_ptr</code> 指向 <code>A</code>，不增加引用计数。</li>
<li><code>a</code> 和 <code>b</code> 离开作用域，引用计数降为0，资源被正确释放。</li>
<li>防止了循环引用，避免了内存泄漏。</li>
</ul>
<h3 id="5-4-访问-weak-ptr-指向的对象"><a href="#5-4-访问-weak-ptr-指向的对象" class="headerlink" title="5.4 访问 weak_ptr 指向的对象"></a>5.4 访问 <code>weak_ptr</code> 指向的对象</h3><p><code>weak_ptr</code> 不能直接访问对象，需要通过 <code>lock()</code> 方法转换为 <code>shared_ptr</code>，并检查对象是否仍然存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *locked &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object no longer exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">// 再次尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *locked &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object no longer exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Value:</span> <span class="number">42</span></span><br><span class="line"><span class="type">Object</span> no longer exists.</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><code>wp.lock()</code> 返回一个 <code>shared_ptr</code>，如果对象依然存在，则有效。</li>
<li><code>sp.reset()</code> 释放资源后，<code>wp.lock()</code> 无法获取有效的 <code>shared_ptr</code>。</li>
</ul>
<h2 id="6-自定义删除器"><a href="#6-自定义删除器" class="headerlink" title="6. 自定义删除器"></a>6. 自定义删除器</h2><h3 id="6-1-用例与实现"><a href="#6-1-用例与实现" class="headerlink" title="6.1 用例与实现"></a>6.1 用例与实现</h3><p>有时，默认的 <code>delete</code> 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。</p>
<h3 id="6-2-代码案例"><a href="#6-2-代码案例" class="headerlink" title="6.2 代码案例"></a>6.2 代码案例</h3><h4 id="用例：管理-FILE-资源"><a href="#用例：管理-FILE-资源" class="headerlink" title="用例：管理 FILE* 资源"></a>用例：管理 FILE* 资源</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileDeleter</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Closing file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), FileDeleter())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (filePtr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 使用 filePtr 进行文件操作</span></span><br><span class="line">            <span class="built_in">fprintf</span>(filePtr.<span class="built_in">get</span>(), <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 自动关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully.</span><br><span class="line">Closing file.</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li>自定义删除器 <code>FileDeleter</code> 用于在 <code>shared_ptr</code> 被销毁时关闭文件。</li>
<li>使用 <code>filePtr.get()</code> 获取原生 <code>FILE*</code> 指针进行文件操作。</li>
<li>离开作用域时，自动调用 <code>FileDeleter</code> 关闭文件。</li>
</ul>
<h3 id="6-3-使用-Lambda-表达式作为删除器"><a href="#6-3-使用-Lambda-表达式作为删除器" class="headerlink" title="6.3 使用 Lambda 表达式作为删除器"></a>6.3 使用 Lambda 表达式作为删除器</h3><p>C++11 允许使用 lambda 表达式作为删除器，简化代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fileDeleter = [](FILE* fp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Closing file via lambda.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(fileDeleter)</span>&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), fileDeleter)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (filePtr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fprintf</span>(filePtr.<span class="built_in">get</span>(), <span class="string">&quot;Hello, Lambda!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 自动关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully.</span><br><span class="line">Closing file via lambda.</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li>使用 <code>std::unique_ptr</code> 搭配 lambda 删除器管理 <code>FILE*</code>。</li>
<li>提供了更灵活和简洁的删除器实现。</li>
</ul>
<h2 id="7-最佳实践与常见陷阱"><a href="#7-最佳实践与常见陷阱" class="headerlink" title="7. 最佳实践与常见陷阱"></a>7. 最佳实践与常见陷阱</h2><h3 id="7-1-选择合适的智能指针"><a href="#7-1-选择合适的智能指针" class="headerlink" title="7.1 选择合适的智能指针"></a>7.1 选择合适的智能指针</h3><ul>
<li>**<code>std::unique_ptr</code>**：<ul>
<li>用于明确的独占所有权场景。</li>
<li>适用于资源的单一管理者或需要所有权转移的情况。</li>
<li>更轻量，性能更优。</li>
</ul>
</li>
<li>**<code>std::shared_ptr</code>**：<ul>
<li>用于共享所有权的场景。</li>
<li>需要多个指针共同管理同一资源时使用。</li>
<li>引用计数带来一定的性能开销。</li>
</ul>
</li>
<li>**<code>std::weak_ptr</code>**：<ul>
<li>用于观察不拥有资源的场景。</li>
<li>适用于需要避免循环引用或只需临时访问资源的情况。</li>
</ul>
</li>
</ul>
<h3 id="7-2-避免循环引用"><a href="#7-2-避免循环引用" class="headerlink" title="7.2 避免循环引用"></a>7.2 避免循环引用</h3><p>在使用 <code>shared_ptr</code> 时，特别是在对象间存在双向引用时，容易导致循环引用，内存泄漏。使用 <code>weak_ptr</code> 打破循环引用。</p>
<h3 id="7-3-使用-make-shared-与-make-unique"><a href="#7-3-使用-make-shared-与-make-unique" class="headerlink" title="7.3 使用 make_shared 与 make_unique"></a>7.3 使用 <code>make_shared</code> 与 <code>make_unique</code></h3><p>优先使用 <code>make_shared</code> 和 <code>make_unique</code> 来创建智能指针，避免直接使用 <code>new</code>，提高效率和异常安全性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">auto</span> up = std::<span class="built_in">make_unique</span>&lt;Test&gt;(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>



<h3 id="7-4-不要混用原生指针与智能指针"><a href="#7-4-不要混用原生指针与智能指针" class="headerlink" title="7.4 不要混用原生指针与智能指针"></a>7.4 不要混用原生指针与智能指针</h3><p>避免在智能指针管理的对象上同时使用原生指针进行管理，防止重复释放或不安全访问。</p>
<h3 id="7-5-理解智能指针的所有权语义"><a href="#7-5-理解智能指针的所有权语义" class="headerlink" title="7.5 理解智能指针的所有权语义"></a>7.5 理解智能指针的所有权语义</h3><p>深入理解不同智能指针的所有权规则，避免误用导致资源管理错误。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>智能指针是 C++ 中强大的资源管理工具，通过封装原生指针，提供自动化的内存管理，极大地减少了内存泄漏和资源管理错误。<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 各有其应用场景，理解它们的差异和使用方法对于编写安全、高效的 C++ 代码至关重要。此外，通过实现自己的智能指针（如 <code>SimpleSharedPtr</code>），可以更深入地理解智能指针的工作原理，为高级 C++ 编程打下坚实基础。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/06/cppbase24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/06/cppbase24/" itemprop="url">零基础C++(24) 可调用对象function类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-06T10:57:07+08:00">
                2024-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C++ 提供了多种方式来表示和操作可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code> 和 <code>std::bind</code> 等。这些工具极大地增强了C++的灵活性和表达能力，尤其在处理回调、事件驱动编程和函数式编程时表现尤为出色。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是C++中最基本的可调用对象之一，用于指向普通函数和静态成员函数。</p>
<h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>函数指针的定义涉及到函数的返回类型和参数列表。例如，定义一个指向返回 <code>int</code> 且接受两个 <code>int</code> 参数的函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给函数指针赋值</span></span><br><span class="line">    funcPtr = &amp;add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">funcPtr</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出: 结果: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优点与局限性"><a href="#优点与局限性" class="headerlink" title="优点与局限性"></a>优点与局限性</h3><p><strong>优点:</strong></p>
<ul>
<li>简单直观，适用于简单的回调函数。</li>
</ul>
<p><strong>局限性:</strong></p>
<ul>
<li>不能捕获上下文（如lambda中的闭包）。</li>
<li>语法相对复杂，尤其是指针的声明和使用。</li>
</ul>
<hr>
<h2 id="仿函数（Functors）"><a href="#仿函数（Functors）" class="headerlink" title="仿函数（Functors）"></a>仿函数（Functors）</h2><p><strong>仿函数（Functors）</strong>，又称<strong>函数对象（Function Objects）</strong>，是在C++中重载了 <code>operator()</code> 的类或结构体实例。仿函数不仅可以像普通函数一样被调用，还能携带状态，提供更大的灵活性和功能性。</p>
<h3 id="定义与使用-1"><a href="#定义与使用-1" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>仿函数是通过定义一个类或结构体，并重载其调用运算符 <code>operator()</code> 来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="type">int</span> to_add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> value) : <span class="built_in">to_add</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + to_add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">add5</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个添加5的仿函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 10 + 5 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>携带状态：</strong> 仿函数可以拥有内部状态，通过成员变量存储数据，使其在调用时具备上下文信息。</li>
<li><strong>灵活性高：</strong> 可以根据需要添加更多的成员函数和变量，扩展功能。</li>
<li><strong>性能优化：</strong> 编译器可以对仿函数进行优化，例如内联展开，提高执行效率。</li>
</ol>
<h3 id="高级示例"><a href="#高级示例" class="headerlink" title="高级示例"></a>高级示例</h3><p>仿函数不仅可以执行简单的计算，还可以进行复杂的操作。例如，实现一个可变的仿函数，用于累加多个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变累加器仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Accumulator</span>() : <span class="built_in">sum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Accumulator acc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;总和: &quot;</span> &lt;&lt; acc.sum &lt;&lt; std::endl; <span class="comment">// 输出: 总和: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用仿函数的标准库算法"><a href="#使用仿函数的标准库算法" class="headerlink" title="使用仿函数的标准库算法"></a>使用仿函数的标准库算法</h3><p>许多标准库算法可以接受仿函数作为参数，使得算法的行为更加灵活和可定制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数：判断一个数是否大于某个阈值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsGreaterThan</span> &#123;</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IsGreaterThan</span>(<span class="type">int</span> t) : <span class="built_in">threshold</span>(t) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行筛选</span></span><br><span class="line">    <span class="function">IsGreaterThan <span class="title">greaterThan10</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), greaterThan10);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个大于10的数是: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 输出: 第一个大于10的数是: 15</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于10的数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="仿函数与模板"><a href="#仿函数与模板" class="headerlink" title="仿函数与模板"></a>仿函数与模板</h3><p>仿函数与模板相结合，可以实现高度通用和可复用的代码。例如，编写一个通用的比较仿函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用比较仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">Compare</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 5 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="仿函数的优势"><a href="#仿函数的优势" class="headerlink" title="仿函数的优势"></a>仿函数的优势</h3><ul>
<li><strong>可扩展性：</strong> 能够根据需要添加更多功能和状态。</li>
<li><strong>与Lambda的互补性：</strong> 在需要携带复杂状态或多次调用时，仿函数比Lambda更适合。</li>
<li><strong>类型安全：</strong> 仿函数是具体的类型，可以在编译期进行类型检查。</li>
</ul>
<h3 id="何时使用仿函数"><a href="#何时使用仿函数" class="headerlink" title="何时使用仿函数"></a>何时使用仿函数</h3><ul>
<li><strong>需要携带状态时：</strong> 当回调函数需要维护内部状态时，仿函数是理想选择。</li>
<li><strong>复杂操作：</strong> 当简单的函数指针或Lambda难以表达复杂逻辑时。</li>
<li><strong>性能关键场景：</strong> 由于仿函数可以被编译器优化，适用于性能敏感的代码。</li>
</ul>
<hr>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是C++11引入的一种轻量级函数对象，允许在代码中定义匿名函数。它们可以捕获周围的变量，具有更强的表达能力。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[captures](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>captures</strong>: 捕获外部变量的方式，可以是值捕获、引用捕获或者混合捕获。</li>
<li><strong>parameters</strong>: 参数列表。</li>
<li><strong>return_type</strong>: 返回类型，可以省略，编译器会自动推导。</li>
<li><strong>函数体</strong>: 实际执行的代码。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式进行过滤</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">        [threshold](<span class="type">int</span> n) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n &lt; threshold;</span><br><span class="line">        &#125;), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 6 8 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="捕获方式"><a href="#捕获方式" class="headerlink" title="捕获方式"></a>捕获方式</h3><ol>
<li><strong>值捕获 (<code>[=]</code>)</strong>: 捕获所有外部变量的副本。</li>
<li><strong>引用捕获 (<code>[&amp;]</code>)</strong>: 捕获所有外部变量的引用。</li>
<li><strong>混合捕获</strong>: 指定部分变量按值捕获，部分按引用捕获，如 <code>[=, &amp;var]</code> 或 <code>[&amp;, var]</code>。</li>
<li><strong>无捕获 (<code>[]</code>)</strong>: 不捕获任何外部变量。</li>
</ol>
<h3 id="可变Lambda"><a href="#可变Lambda" class="headerlink" title="可变Lambda"></a>可变Lambda</h3><p>默认情况下，Lambda表达式是不可变的（<code>const</code>）。通过<code>mutable</code>关键字，可以允许修改捕获的变量副本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [count]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count inside Lambda: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">increment</span>(); <span class="comment">// 输出: Count inside Lambda: 1</span></span><br><span class="line">    <span class="built_in">increment</span>(); <span class="comment">// 输出: Count inside Lambda: 2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count outside Lambda: &quot;</span> &lt;&lt; count &lt;&lt; std::endl; <span class="comment">// 输出: Count outside Lambda: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="捕获成员函数和类变量"><a href="#捕获成员函数和类变量" class="headerlink" title="捕获成员函数和类变量"></a>捕获成员函数和类变量</h3><p>Lambda表达式可以捕获类的成员变量和成员函数，使其在类的上下文中更加灵活。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Processor</span>(<span class="type">int</span> threshold) : <span class="built_in">threshold</span>(threshold) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理前数据: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式进行过滤</span></span><br><span class="line">        data.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">int</span> n) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n &lt; threshold;</span><br><span class="line">            &#125;), data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理后数据: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function">Processor <span class="title">proc</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    proc.<span class="built_in">process</span>(numbers);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    处理前数据: 1 6 3 8 2 7 </span></span><br><span class="line"><span class="comment">    处理后数据: 6 8 7 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lambda与标准库算法"><a href="#Lambda与标准库算法" class="headerlink" title="Lambda与标准库算法"></a>Lambda与标准库算法</h3><p>Lambda表达式与标准库算法紧密结合，提供了更简洁和直观的代码书写方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lambda表达式的优势"><a href="#Lambda表达式的优势" class="headerlink" title="Lambda表达式的优势"></a>Lambda表达式的优势</h3><ul>
<li><strong>简洁性：</strong> 代码更加紧凑，易于理解。</li>
<li><strong>灵活性：</strong> 能够捕获外部变量，适应更多场景。</li>
<li><strong>性能优化：</strong> 编译器可以对Lambda进行优化，如内联展开。</li>
<li><strong>与标准库的良好集成：</strong> 与STL算法无缝结合，简化代码逻辑。</li>
</ul>
<hr>
<h2 id="std-function-对象"><a href="#std-function-对象" class="headerlink" title="std::function 对象"></a><code>std::function</code> 对象</h2><p><code>std::function</code> 是C++11提供的一个通用的可调用包装器，能够封装任何可调用对象，包括普通函数、Lambda表达式、函数对象以及绑定表达式。它实现了类型擦除，使得不同类型的可调用对象可以通过统一的接口进行操作。</p>
<h3 id="定义与使用-2"><a href="#定义与使用-2" class="headerlink" title="定义与使用"></a>定义与使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func1 = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Add: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装Lambda表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func2 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Subtract: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装函数对象</span></span><br><span class="line">    Multiply multiply;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = multiply;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; <span class="built_in">func3</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Multiply: 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>类型擦除：</strong> 可以存储任何符合签名的可调用对象。</li>
<li><strong>灵活性：</strong> 支持动态改变存储的可调用对象。</li>
<li><strong>性能开销：</strong> 相比于直接使用函数指针或Lambda，<code>std::function</code> 可能带来一定的性能开销，尤其是在频繁调用时。</li>
</ul>
<h3 id="用法场景"><a href="#用法场景" class="headerlink" title="用法场景"></a>用法场景</h3><ul>
<li><strong>回调函数的传递。</strong></li>
<li><strong>事件处理系统。</strong></li>
<li><strong>策略模式的实现。</strong></li>
</ul>
<h3 id="示例：回调机制"><a href="#示例：回调机制" class="headerlink" title="示例：回调机制"></a>示例：回调机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回调类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(Callback cb, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件发生，调用回调</span></span><br><span class="line">    <span class="built_in">cb</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda作为回调</span></span><br><span class="line">    <span class="built_in">triggerEvent</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;事件触发，值为: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;, <span class="number">42</span>); <span class="comment">// 输出: 事件触发，值为: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数作为回调</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Printer打印值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; printer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">triggerEvent</span>(printer, <span class="number">100</span>); <span class="comment">// 输出: Printer打印值: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="存储和调用不同类型的可调用对象"><a href="#存储和调用不同类型的可调用对象" class="headerlink" title="存储和调用不同类型的可调用对象"></a>存储和调用不同类型的可调用对象</h3><p><code>std::function</code> 可以在容器中存储各种不同类型的可调用对象，只要它们符合指定的签名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同类型的可调用对象</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(add); <span class="comment">// 普通函数</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(<span class="built_in">Multiply</span>()); <span class="comment">// 仿函数</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a - b; &#125;); <span class="comment">// Lambda</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">op</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 15 50 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="std-bind-操作"><a href="#std-bind-操作" class="headerlink" title="std::bind 操作"></a><code>std::bind</code> 操作</h2><p><code>std::bind</code> 是C++11中提供的一个函数适配器，用于绑定函数或可调用对象的部分参数，生成一个新的可调用对象。它允许提前固定某些参数，简化函数调用或适应接口需求。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为10，生成新的函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> add10 = std::<span class="built_in">bind</span>(add, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add10</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 10 + 5 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="占位符-std-placeholders"><a href="#占位符-std-placeholders" class="headerlink" title="占位符 (std::placeholders)"></a>占位符 (<code>std::placeholders</code>)</h3><p><code>std::bind</code> 使用占位符来表示未绑定的参数，这些占位符决定了在生成的新函数对象中如何传递参数。</p>
<p>常用的占位符包括：</p>
<ul>
<li><code>std::placeholders::_1</code></li>
<li><code>std::placeholders::_2</code></li>
<li><code>std::placeholders::_3</code></li>
<li>等等，根据需要传递的参数数量。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> std::string&amp; msg, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定消息为&quot;Hello&quot;，生成新的函数对象，只需要传递次数</span></span><br><span class="line">    <span class="keyword">auto</span> sayHello = std::<span class="built_in">bind</span>(display, <span class="string">&quot;Hello&quot;</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sayHello</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定次数为2，生成新的函数对象，只需要传递消息</span></span><br><span class="line">    <span class="keyword">auto</span> sayTwice = std::<span class="built_in">bind</span>(display, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">sayTwice</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Hi</span></span><br><span class="line"><span class="comment">    Hi</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="与Lambda表达式的对比"><a href="#与Lambda表达式的对比" class="headerlink" title="与Lambda表达式的对比"></a>与Lambda表达式的对比</h3><p><code>std::bind</code> 曾在C++11中广泛使用，但随着Lambda表达式的普及，很多情况下Lambda更为直观和高效。不过，在某些复杂的参数绑定场景下，<code>std::bind</code> 依然有其独特优势。</p>
<p><strong>使用 <code>std::bind</code>:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为2，生成新的函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = std::<span class="built_in">bind</span>(multiply, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 5 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2 * 5 = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用 Lambda 表达式:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda表达式绑定第一个参数为2</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = [](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">multiply</span>(<span class="number">2</span>, b);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 5 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2 * 5 = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li><strong>可读性：</strong> Lambda表达式通常更具可读性，语法更直观。</li>
<li><strong>灵活性：</strong> Lambda更易于捕获和使用外部变量。</li>
<li><strong>性能：</strong> Lambda通常比<code>std::bind</code>更高效，因为<code>std::bind</code>可能引入额外的间接层。</li>
</ul>
<hr>
<h2 id="绑定类的成员函数"><a href="#绑定类的成员函数" class="headerlink" title="绑定类的成员函数"></a>绑定类的成员函数</h2><p>在C++中，成员函数与普通函数不同，因为它们需要一个对象实例来调用。使用 <code>std::bind</code> 或Lambda表达式，可以方便地绑定类的成员函数，生成可调用对象。</p>
<h3 id="使用-std-bind-绑定成员函数"><a href="#使用-std-bind-绑定成员函数" class="headerlink" title="使用 std::bind 绑定成员函数"></a>使用 <code>std::bind</code> 绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定成员函数multiply，固定第一个参数为5</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy5 = std::<span class="built_in">bind</span>(&amp;Calculator::multiply, &amp;calc, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 * 3 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy5</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5 * 3 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用Lambda表达式绑定成员函数"><a href="#使用Lambda表达式绑定成员函数" class="headerlink" title="使用Lambda表达式绑定成员函数"></a>使用Lambda表达式绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Greeter greeter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式绑定成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> greetFunc = [&amp;greeter](<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">        greeter.<span class="built_in">greet</span>(name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">greetFunc</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绑定静态成员函数"><a href="#绑定静态成员函数" class="headerlink" title="绑定静态成员函数"></a>绑定静态成员函数</h3><p>静态成员函数不依赖于类的实例，可以像普通函数一样使用 <code>std::bind</code> 和 <code>std::function</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用std::bind绑定静态成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> logFunc = std::<span class="built_in">bind</span>(&amp;Logger::log, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logFunc</span>(<span class="string">&quot;This is a static log message.&quot;</span>); <span class="comment">// 输出: Log: This is a static log message.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绑定带有返回值的成员函数"><a href="#绑定带有返回值的成员函数" class="headerlink" title="绑定带有返回值的成员函数"></a>绑定带有返回值的成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">power</span><span class="params">(<span class="type">double</span> base, <span class="type">double</span> exponent)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(exponent); ++i) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Math mathObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定成员函数power，固定基数为2</span></span><br><span class="line">    <span class="keyword">auto</span> powerOf2 = std::<span class="built_in">bind</span>(&amp;Math::power, &amp;mathObj, <span class="number">2.0</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2^3 = &quot;</span> &lt;&lt; <span class="built_in">powerOf2</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2^3 = 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>对象生命周期：</strong> 绑定成员函数时，确保对象在可调用对象使用期间依然存在，以避免悬空指针问题。</li>
<li><strong>指针与引用：</strong> 可以通过指针或引用传递对象实例给 <code>std::bind</code> 或Lambda表达式。</li>
<li><strong>捕获方式：</strong> 在使用Lambda表达式时，选择合适的捕获方式（值捕获或引用捕获）以确保对象的正确访问。</li>
</ul>
<hr>
<h2 id="C-可调用对象的总结"><a href="#C-可调用对象的总结" class="headerlink" title="C++ 可调用对象的总结"></a>C++ 可调用对象的总结</h2><p>C++ 提供了多种方式来定义和操作可调用对象，每种方式有其独特的特点和适用场景。</p>
<table>
<thead>
<tr>
<th>可调用对象</th>
<th>描述</th>
<th>示例用法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数指针</strong></td>
<td>指向普通函数或静态成员函数的指针</td>
<td><code>int (*func)(int) = &amp;funcName;</code></td>
</tr>
<tr>
<td><strong>仿函数（Functors）</strong></td>
<td>重载了 <code>operator()</code> 的类实例，可以携带状态</td>
<td><code>struct Foo &#123; void operator()(); &#125;;</code></td>
</tr>
<tr>
<td><strong>Lambda表达式</strong></td>
<td>定义在表达式中的匿名函数，支持捕获上下文变量</td>
<td><code>[capture](params) &#123; /* code */ &#125;</code></td>
</tr>
<tr>
<td><strong><code>std::function</code></strong></td>
<td>通用的可调用对象包装器，能够封装任何符合签名的可调用对象</td>
<td><code>std::function&lt;void(int)&gt; func;</code></td>
</tr>
<tr>
<td><strong><code>std::bind</code></strong></td>
<td>绑定函数或可调用对象的部分参数，生成新的可调用对象</td>
<td><code>auto newFunc = std::bind(func, _1);</code></td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul>
<li><strong>简单回调：</strong> 使用函数指针或Lambda表达式。</li>
<li><strong>需要携带状态或更复杂逻辑：</strong> 使用Lambda表达式或仿函数（Functors）。</li>
<li><strong>接口要求 <code>std::function</code>：</strong> 使用 <code>std::function</code>，不过要注意可能的性能开销。</li>
<li><strong>参数预绑定：</strong> 使用 <code>std::bind</code>，但在现代C++中，许多情况下Lambda表达式能达到相同效果且更直观。</li>
</ul>
<hr>
<h2 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h2><p>以下是一个综合示例，展示了函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code>、<code>std::bind</code> 以及绑定类成员函数的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 仿函数（Functors）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> subtract = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayOperation</span><span class="params">(<span class="type">const</span> std::string&amp; op, <span class="type">int</span> result)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; op &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add (Function Pointer): &quot;</span> &lt;&lt; <span class="built_in">funcPtr</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 仿函数（Functors）</span></span><br><span class="line">    Multiply multiply;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply (Functors): &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Lambda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract (Lambda): &quot;</span> &lt;&lt; <span class="built_in">subtract</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. std::function 封装不同可调用对象</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcAdd = add;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcSubtract = subtract;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcMultiply = multiply;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcAdd</span>(<span class="number">20</span>, <span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcSubtract</span>(<span class="number">20</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcMultiply</span>(<span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. std::bind 绑定部分参数</span></span><br><span class="line">    <span class="keyword">auto</span> add5 = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 10 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = std::<span class="built_in">bind</span>(multiply, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 10 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 绑定类成员函数</span></span><br><span class="line">    Calculator calc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定成员函数 subtract</span></span><br><span class="line">    <span class="keyword">auto</span> boundSubtract = std::<span class="built_in">bind</span>(&amp;Calculator::subtract, &amp;calc, <span class="number">15</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;15 - 5 = &quot;</span> &lt;&lt; <span class="built_in">boundSubtract</span>() &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定成员函数 displayOperation</span></span><br><span class="line">    <span class="keyword">auto</span> displayAdd = std::<span class="built_in">bind</span>(&amp;Calculator::displayOperation, &amp;calc, <span class="string">&quot;Add&quot;</span>, std::placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> displayResult = funcAdd;</span><br><span class="line">    <span class="type">int</span> addResult = <span class="built_in">displayResult</span>(<span class="number">7</span>, <span class="number">8</span>); <span class="comment">// 15</span></span><br><span class="line">    <span class="built_in">displayAdd</span>(addResult); <span class="comment">// 输出: Add结果: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 绑定静态成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> logFunc = std::<span class="built_in">bind</span>(&amp;Logger::log, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">logFunc</span>(<span class="string">&quot;This is a static log message.&quot;</span>); <span class="comment">// 输出: Log: This is a static log message.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 使用 std::function 存储混合可调用对象</span></span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同的操作到容器</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::cout &lt;&lt; <span class="string">&quot;Lambda Operation&quot;</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;Calculator::displayOperation, &amp;calc, <span class="string">&quot;Multiply&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::cout &lt;&lt; <span class="string">&quot;Add5(10): &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; &#125;);</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; Logger::<span class="built_in">log</span>(<span class="string">&quot;Lambda-based log message.&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        <span class="built_in">op</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Lambda Operation</span></span><br><span class="line"><span class="comment">    Multiply结果: 30</span></span><br><span class="line"><span class="comment">    Add5(10): 15</span></span><br><span class="line"><span class="comment">    Log: Lambda-based log message.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释:</strong></p>
<ol>
<li><strong>函数指针:</strong> 定义并使用了指向 <code>add</code> 函数的函数指针 <code>funcPtr</code>。</li>
<li><strong>仿函数（Functors）:</strong> 定义了 <code>Multiply</code> 结构体，并使用其实例 <code>multiply</code> 进行乘法运算。</li>
<li><strong>Lambda表达式:</strong> 定义了一个用于减法的Lambda <code>subtract</code>。</li>
<li><strong><code>std::function</code>:</strong> 封装了不同类型的可调用对象，包括普通函数、Lambda和仿函数。</li>
<li><strong><code>std::bind</code>:</strong> 绑定 <code>add</code> 和 <code>multiply</code> 函数的部分参数，生成新的可调用对象 <code>add5</code> 和 <code>multiplyBy2</code>。</li>
<li><strong>绑定类成员函数:</strong> 使用 <code>std::bind</code> 绑定 <code>Calculator</code> 类的成员函数 <code>subtract</code> 和 <code>displayOperation</code>。</li>
<li><strong>绑定静态成员函数:</strong> 使用 <code>std::bind</code> 绑定 <code>Logger</code> 类的静态成员函数 <code>log</code>。</li>
<li><strong>混合可调用对象容器:</strong> 使用 <code>std::function</code> 和 <code>std::vector</code> 存储并执行不同类型的可调用对象，包括Lambda、绑定成员函数和静态成员函数。</li>
</ol>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本教案，学生应能够理解并运用C++中的各种可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code> 和 <code>std::bind</code> 等。掌握这些工具不仅有助于编写更灵活和可维护的代码，还为进一步学习函数式编程和设计模式奠定了坚实的基础。在实际编程中，合理选择和组合这些可调用对象，可以大大提升代码的效率和表达力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/05/cppbase22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/05/cppbase22/" itemprop="url">零基础C++(22) 内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-05T15:47:53+08:00">
                2024-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存管理简介"><a href="#内存管理简介" class="headerlink" title="内存管理简介"></a>内存管理简介</h2><p>详细技术视频请看我的主页</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">C++教程视频</a></p>
<p>C++ 提供了多种内存管理方式，包括传统的 C 风格的 <code>malloc</code> 和 <code>free</code>，以及 C++ 专用的 <code>new</code> 和 <code>delete</code>。</p>
<p>理解这些内存管理方法对于编写高效、安全的 C++ 程序至关重要。</p>
<p>本文将详细介绍这些内存管理方法，包含基本用法、复杂操作（如 <code>realloc</code>），并配以实际案例和代码示例。</p>
<h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><p>在 C++ 程序中，内存主要分为以下几个区域：</p>
<ul>
<li><strong>栈（Stack）</strong>：自动管理内存，存储局部变量和函数调用信息。内存分配和释放速度快，但空间有限。</li>
<li><strong>堆（Heap）</strong>：手动管理内存，用于动态分配内存。内存分配和释放由程序员控制，灵活但易出错（如内存泄漏、悬挂指针）。</li>
<li><strong>全局/静态区（<code>Data/BSS Segment</code>）</strong>：存储全局变量和静态变量。</li>
</ul>
<p>了解栈和堆的区别，以及如何有效地在堆上分配和管理内存，是编写高效且安全的 C++ 程序的基础。</p>
<h2 id="C-风格内存管理"><a href="#C-风格内存管理" class="headerlink" title="C 风格内存管理"></a>C 风格内存管理</h2><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc 函数"></a><code>malloc</code> 函数</h3><p><code>malloc</code>（memory allocation）用于在堆上分配指定字节数的内存。其原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>参数</strong>：<code>size</code> - 要分配的内存字节数。</li>
<li><strong>返回值</strong>：指向分配内存的指针，如果分配失败则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a><code>free</code> 函数</h3><p><code>free</code> 用于释放之前由 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 分配的内存。其原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>参数</strong>：<code>ptr</code> - 要释放的内存指针。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 malloc 和 free</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>类型转换</strong>：<code>malloc</code> 返回 <code>void*</code>，需要显式转换为所需类型的指针。</li>
<li><strong>初始化</strong>：<code>malloc</code> 分配的内存未初始化，内容不确定。</li>
<li><strong>释放对应性</strong>：由 <code>malloc</code> 分配的内存必须使用 <code>free</code> 释放，避免使用 <code>delete</code>。</li>
</ul>
<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h2><p>C++ 提供了更高层次的内存管理操作符：<code>new</code> 和 <code>delete</code>，它们不仅分配和释放内存，还调用构造函数和析构函数，提供类型安全。</p>
<h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><strong><code>new</code> 操作符</strong></h3><p>用于在堆上分配对象，并调用其构造函数。</p>
<p><strong>单个对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* ptr = <span class="keyword">new</span> <span class="built_in">Type</span>(parameters);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="keyword">called</span> <span class="keyword">with</span> <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Object <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Destructor <span class="keyword">called</span> <span class="keyword">for</span> <span class="keyword">value</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p><strong>数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* array = <span class="keyword">new</span> Type[size];</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 分配5个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放数组内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr[0] = 0</span><br><span class="line">arr[1] = 10</span><br><span class="line">arr[2] = 20</span><br><span class="line">arr[3] = 30</span><br><span class="line">arr[4] = 40</span><br></pre></td></tr></table></figure>



<p><strong><code>delete</code> 操作符</strong></p>
<p>用于释放由 <code>new</code> 分配的内存，并调用析构函数。</p>
<h3 id="释放单个对象"><a href="#释放单个对象" class="headerlink" title="释放单个对象"></a>释放单个对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>



<h3 id="释放数组"><a href="#释放数组" class="headerlink" title="释放数组"></a>释放数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>



<h3 id="区别于-malloc-和-free"><a href="#区别于-malloc-和-free" class="headerlink" title="区别于 malloc 和 free"></a>区别于 <code>malloc</code> 和 <code>free</code></h3><ul>
<li><strong>类型安全</strong>：<code>new</code> 返回正确类型的指针，免去了强制类型转换。</li>
<li><strong>构造/析构</strong>：<code>new</code> 和 <code>delete</code> 自动调用构造函数和析构函数。</li>
<li><strong>异常处理</strong>：在分配失败时，<code>new</code> 默认抛出 <code>std::bad_alloc</code> 异常，而 <code>malloc</code> 返回 <code>nullptr</code>。</li>
</ul>
<h3 id="异常安全的-new"><a href="#异常安全的-new" class="headerlink" title="异常安全的 new"></a>异常安全的 <code>new</code></h3><p>可以通过 <code>nothrow</code> 参数防止 <code>new</code> 抛出异常，改为返回 <code>nullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 包含 std::nothrow</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="总结和对比"><a href="#总结和对比" class="headerlink" title="总结和对比"></a>总结和对比</h2><p>了解 <code>malloc/free</code> 与 <code>new/delete</code> 的区别，有助于在编写 C++ 程序时正确选择内存管理方法。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>malloc/free</th>
<th>new/delete</th>
</tr>
</thead>
<tbody><tr>
<td>类型安全</td>
<td>需要显式类型转换</td>
<td>自动类型转换，无需显式转换</td>
</tr>
<tr>
<td>构造/析构函数</td>
<td>不调用对象的构造/析构函数</td>
<td>调用对象的构造/析构函数</td>
</tr>
<tr>
<td>返回值</td>
<td><code>void*</code>，需要转换为目标类型</td>
<td>返回目标类型指针，类型安全</td>
</tr>
<tr>
<td>错误处理</td>
<td>分配失败返回 <code>nullptr</code></td>
<td>分配失败抛出 <code>std::bad_alloc</code> 异常</td>
</tr>
<tr>
<td>多态行为</td>
<td>无</td>
<td>支持多态，通过虚函数正确调用析构函数</td>
</tr>
<tr>
<td>内存分配与释放对应性</td>
<td>必须使用 <code>free</code> 释放由 <code>malloc</code> 分配的内存</td>
<td>必须使用 <code>delete</code> 释放由 <code>new</code> 分配的内存</td>
</tr>
</tbody></table>
<h3 id="示例对比"><a href="#示例对比" class="headerlink" title="示例对比"></a>示例对比</h3><p><strong>使用 <code>malloc</code> 和 <code>free</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">    MyClass* obj = (MyClass*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyClass));</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;malloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调用构造函数（不推荐）</span></span><br><span class="line">    <span class="keyword">new</span>(obj) <span class="built_in">MyClass</span>(<span class="number">20</span>); <span class="comment">// 通过“定位 new”调用构造函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调用析构函数</span></span><br><span class="line">    obj-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：使用 <code>malloc</code> 分配 C++ 对象时，需要手动调用构造函数和析构函数，这非常不便且易出错。因此，推荐使用 <code>new</code> 和 <code>delete</code>。</p>
<p><strong>使用 <code>new</code> 和 <code>delete</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 new 分配内存并调用构造函数</span></span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 delete 释放内存并调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="keyword">called</span></span><br><span class="line"><span class="keyword">Value</span>: <span class="number">30</span></span><br><span class="line">Destructor <span class="keyword">called</span></span><br></pre></td></tr></table></figure>



<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul>
<li><strong>C++ 类型特性</strong>：<code>new</code> 和 <code>delete</code> 支持 C++ 的类型特性，包括构造函数、析构函数、多态等。</li>
<li><strong>C 兼容性</strong>：在需要兼容 C 代码或通过 C 接口分配内存时，仍可能需要使用 <code>malloc</code> 和 <code>free</code>。</li>
</ul>
<h2 id="高级内存管理"><a href="#高级内存管理" class="headerlink" title="高级内存管理"></a>高级内存管理</h2><h3 id="使用-realloc-进行内存重分配"><a href="#使用-realloc-进行内存重分配" class="headerlink" title="使用 realloc 进行内存重分配"></a>使用 realloc 进行内存重分配</h3><p><code>realloc</code> 用于调整之前分配的内存块大小。这在动态数组等数据结构中非常有用。</p>
<p><strong>原型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>参数</p>
<p>：</p>
<ul>
<li><code>ptr</code>：指向之前分配的内存块。</li>
<li><code>new_size</code>：新的内存大小（以字节为单位）。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：指向重新分配后的内存块的新指针。如果重新分配失败，返回 <code>nullptr</code>，原内存块保持不变。</p>
</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含 memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始分配 3 个整数</span></span><br><span class="line">    <span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Initial malloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配为 5 个整数</span></span><br><span class="line">    <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Realloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">free</span>(arr); <span class="comment">// 释放原内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化新元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = (i + <span class="number">1</span>) * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reallocated array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Initial</span> <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">Reallocated <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">40</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure>



<h3 id="动态数组管理"><a href="#动态数组管理" class="headerlink" title="动态数组管理"></a>动态数组管理</h3><p>使用 <code>malloc</code> 和 <code>realloc</code> 来手动管理动态数组可以实现可变大小的数组，但需要处理内存分配、释放和数据复制。</p>
<p><strong>封装动态数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>(<span class="type">size_t</span> initial_size = <span class="number">1</span>)</span><br><span class="line">        : <span class="built_in">size</span>(initial_size), <span class="built_in">data</span>((<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_size)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(data, new_size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">        size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">DynamicArray <span class="title">arr</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Initial array: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整大小</span></span><br><span class="line">        arr.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="number">40</span>;</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resized array: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Initial</span> <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">Resized <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">40</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：这种方式需要手动管理内存和数组大小，且缺乏类型安全性和自动化。推荐使用 C++ 标准容器如 <code>std::vector</code> 来代替。</p>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h3 id="案例一：动态数组实现"><a href="#案例一：动态数组实现" class="headerlink" title="案例一：动态数组实现"></a>案例一：动态数组实现</h3><p>实现一个简单的动态数组类，支持添加元素、访问元素和自动扩展。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>()</span><br><span class="line">        : <span class="built_in">capacity</span>(<span class="number">2</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">data</span>((<span class="type">int</span>*)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[size++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(data, new_capacity * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DynamicArray arr;</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">30</span>); <span class="comment">// 触发扩展</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dynamic Array Contents:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr.<span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Array access error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dynamic</span> <span class="keyword">Array</span> Contents:</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br></pre></td></tr></table></figure>



<h3 id="案例二：自定义内存管理器"><a href="#案例二：自定义内存管理器" class="headerlink" title="案例二：自定义内存管理器"></a>案例二：自定义内存管理器</h3><p>实现一个简单的内存池，用于高效分配和释放固定大小的对象。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> objectSize, <span class="type">size_t</span> poolSize)</span><br><span class="line">        : <span class="built_in">objSize</span>(objectSize), <span class="built_in">totalSize</span>(poolSize), <span class="built_in">pool</span>((<span class="type">char</span>*)<span class="built_in">malloc</span>(objectSize * poolSize)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 free list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; poolSize; ++i) &#123;</span><br><span class="line">            freeList.<span class="built_in">push</span>(pool + i * objectSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (freeList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">void</span>* ptr = freeList.<span class="built_in">top</span>();</span><br><span class="line">        freeList.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        freeList.<span class="built_in">push</span>((<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> objSize;</span><br><span class="line">    <span class="type">size_t</span> totalSize;</span><br><span class="line">    <span class="type">char</span>* pool;</span><br><span class="line">    std::stack&lt;<span class="type">void</span>*&gt; freeList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个能容纳 3 个 MyClass 对象的内存池</span></span><br><span class="line">        <span class="function">MemoryPool <span class="title">pool</span><span class="params">(<span class="keyword">sizeof</span>(MyClass), <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配对象内存</span></span><br><span class="line">        <span class="type">void</span>* mem1 = pool.<span class="built_in">allocate</span>();</span><br><span class="line">        <span class="type">void</span>* mem2 = pool.<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用“定位 new”构造对象</span></span><br><span class="line">        MyClass* obj1 = <span class="built_in">new</span>(mem1) <span class="built_in">MyClass</span>(<span class="number">100</span>);</span><br><span class="line">        MyClass* obj2 = <span class="built_in">new</span>(mem2) <span class="built_in">MyClass</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用对象</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj1 value: &quot;</span> &lt;&lt; obj1-&gt;value &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 value: &quot;</span> &lt;&lt; obj2-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式调用析构函数</span></span><br><span class="line">        obj1-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line">        obj2-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        pool.<span class="built_in">deallocate</span>(mem1);</span><br><span class="line">        pool.<span class="built_in">deallocate</span>(mem2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory pool allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MyClass constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">MyClass constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">obj1 value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">obj2 value:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">MyClass destructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">MyClass destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li><strong>MemoryPool</strong> 管理固定大小的内存块，避免频繁调用 <code>malloc</code> 和 <code>free</code>。</li>
<li>使用“<strong>定位 new</strong>”在预分配的内存上构造对象。</li>
<li>需要手动调用析构函数和将内存返回给内存池。</li>
</ul>
<p><strong>注意</strong>：这种方法适用于大量小对象的高效管理，但需要确保正确使用构造和析构函数。</p>
<h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h2><p>内存泄漏是指程序分配的内存未被释放，导致内存被浪费，甚至耗尽。避免内存泄漏的策略包括：</p>
<ul>
<li>**确保每个 <code>new</code> 有对应的 <code>delete</code>**。</li>
<li><strong>使用 <code>RAII</code> 和智能指针</strong>：自动管理资源，避免手动管理内存。</li>
<li><strong>工具辅助</strong>：使用工具如 <code>Valgrind</code> 检测内存泄漏。</li>
</ul>
<p><strong>示例：内存泄漏</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 忘记 delete p; 导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解决方法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 正确释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RAII（资源获取即初始化）"><a href="#RAII（资源获取即初始化）" class="headerlink" title="RAII（资源获取即初始化）"></a><code>RAII</code>（资源获取即初始化）</h2><p><code>RAII</code> 是 C++ 中的一种编程惯用法，通过对象的生命周期管理资源，确保资源在对象构造时获取，析构时释放，避免泄漏。</p>
<p><strong>示例：<code>RAII</code> 实现类似于<code>shared_ptr</code>智能指针</strong></p>
<p><code>std::shared_ptr</code> 是 C++ 标准库中功能强大的智能指针之一，提供了共享所有权的能力，使得多个指针可以共同管理同一个动态分配的对象。通过引用计数机制，<code>shared_ptr</code> 确保了对象在最后一个指针被销毁时自动释放，极大地简化了内存管理，防止了内存泄漏和悬挂指针问题。</p>
<h3 id="SimpleSharedPtr-的基本概念"><a href="#SimpleSharedPtr-的基本概念" class="headerlink" title="SimpleSharedPtr 的基本概念"></a><strong><code>SimpleSharedPtr</code> 的基本概念</strong></h3><p><code>SimpleSharedPtr</code> 是一个简化版的 <code>shared_ptr</code> 实现，旨在帮助理解其核心机制。其基本功能包括：</p>
<ul>
<li><strong>共享所有权</strong>：多个 <code>SimpleSharedPtr</code> 实例可以指向同一个对象，共享对该对象的所有权。</li>
<li><strong>自动管理生命周期</strong>：当最后一个 <code>SimpleSharedPtr</code> 被销毁或指向其他对象时，管理的对象被自动释放。</li>
<li><strong>引用计数</strong>：内部维护一个引用计数，记录有多少个 <code>SimpleSharedPtr</code> 实例指向同一个对象。</li>
</ul>
<h3 id="引用计数控制块的设计"><a href="#引用计数控制块的设计" class="headerlink" title="引用计数控制块的设计"></a><strong>引用计数控制块的设计</strong></h3><p>为了实现引用计数机制，<code>SimpleSharedPtr</code> 需要一个控制块（Control Block），它包含：</p>
<ul>
<li><strong>引用计数（<code>ref_count</code>）</strong>：记录有多少个 <code>SimpleSharedPtr</code> 指向同一个对象。</li>
<li><strong>指向对象的指针（<code>ptr</code>）</strong>：指向实际管理的对象。</li>
</ul>
<p>控制块通常与被管理对象一起被分配，但为了简化实现，本示例将它们独立管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count;    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="comment">// 可以扩展为包含自定义删除器等</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleSharedPtr-的实现"><a href="#SimpleSharedPtr-的实现" class="headerlink" title="SimpleSharedPtr 的实现"></a><code>SimpleSharedPtr</code> 的实现</h3><p><strong>类结构</strong></p>
<p><code>SimpleSharedPtr</code> 是一个模板类，模板参数 <code>T</code> 表示它所管理的对象类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control; <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、析构函数、拷贝与移动操作、操作符重载等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>构造函数与析构函数</strong></p>
<ul>
<li><strong>默认构造函数</strong>：初始化指针和控制块为空。</li>
<li><strong>参数化构造函数</strong>：接受一个裸指针，初始化控制块，并引用计数为1。</li>
<li><strong>析构函数</strong>：减少引用计数，若引用计数为0，则释放对象和控制块。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**辅助函数 <code>release</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (control) &#123;</span><br><span class="line">        control-&gt;ref_count--;</span><br><span class="line">        <span class="keyword">if</span> (control-&gt;ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> control;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    control = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拷贝构造与拷贝赋值"><a href="#拷贝构造与拷贝赋值" class="headerlink" title="拷贝构造与拷贝赋值"></a>拷贝构造与拷贝赋值</h3><p>拷贝构造函数和拷贝赋值操作符允许多个 <code>SimpleSharedPtr</code> 实例共享同一个对象，共享相同的控制块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">    <span class="keyword">if</span> (control) &#123;</span><br><span class="line">        control-&gt;ref_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制新的资源和控制块</span></span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移动构造与移动赋值"><a href="#移动构造与移动赋值" class="headerlink" title="移动构造与移动赋值"></a>移动构造与移动赋值</h3><p>移动语义允许资源所有权从一个 <code>SimpleSharedPtr</code> 转移到另一个，而不增加引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">    other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    other.control = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值操作符</span></span><br><span class="line">SimpleSharedPtr&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接管 `other` 的资源</span></span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置 `other` 为空</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>重载 <code>*</code> 和 <code>-&gt;</code> 操作符，以便像使用原生指针一样使用 <code>SimpleSharedPtr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头操作符</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h3><ul>
<li>**<code>use_count</code>**：返回当前引用计数。</li>
<li>**<code>get</code>**：返回裸指针。</li>
<li>**<code>reset</code>**：重置指针，指向新对象或 <code>nullptr</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取引用计数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> control ? control-&gt;ref_count : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裸指针</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向新资源</span></span><br><span class="line">    ptr = p;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><p>以下是 <code>SimpleSharedPtr</code> 的完整实现及其使用示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制块结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版的 shared_ptr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control; <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count--;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Decremented ref_count to &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (control-&gt;ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> control;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Resource and ControlBlock destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructed SimpleSharedPtr (nullptr).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Constructed SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copied SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                control-&gt;ref_count++;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Assigned SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved SimpleSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move-assigned SimpleSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> control ? control-&gt;ref_count : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        ptr = p;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Reset SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating default constructed shared_ptr...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    SimpleSharedPtr&lt;Test&gt; ptr1; <span class="comment">// 默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating shared_ptr with resource...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">SimpleSharedPtr&lt;Test&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>; <span class="comment">// 非默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCopying ptr2 to ptr3...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    SimpleSharedPtr&lt;Test&gt; ptr3 = ptr2; <span class="comment">// 拷贝构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr3-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning ptr3 to ptr1...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ptr1 = ptr3; <span class="comment">// 拷贝赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nResetting ptr2...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">200</span>)); <span class="comment">// 重新指向新的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nExiting scope...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// ptr2, ptr1, ptr3 离开作用域</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SimpleUniquePtr-的实现"><a href="#SimpleUniquePtr-的实现" class="headerlink" title="SimpleUniquePtr 的实现"></a><code>SimpleUniquePtr</code> 的实现</h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，确保在任意时刻，只有一个 <code>unique_ptr</code> 实例指向特定资源。它不支持拷贝操作，只支持移动操作。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>首先，定义一个模板类 <code>SimpleUniquePtr</code>，它持有一个指向资源的裸指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleUniquePtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr; <span class="comment">// 指向管理对象的裸指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、析构函数、删除拷贝构造与拷贝赋值</span></span><br><span class="line">    <span class="comment">// 实现移动构造与移动赋值</span></span><br><span class="line">    <span class="comment">// 重载操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul>
<li><strong>默认构造函数</strong>：初始化指针为空。</li>
<li><strong>参数化构造函数</strong>：接受一个指向资源的裸指针。</li>
<li><strong>析构函数</strong>：当 <code>SimpleUniquePtr</code> 被销毁时，释放所管理的资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleUniquePtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">SimpleUniquePtr</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除拷贝构造与拷贝赋值"><a href="#删除拷贝构造与拷贝赋值" class="headerlink" title="删除拷贝构造与拷贝赋值"></a>删除拷贝构造与拷贝赋值</h3><p>为了确保唯一性，禁止拷贝构造和拷贝赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除拷贝构造</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除拷贝赋值</span></span><br><span class="line">SimpleUniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>



<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>支持移动构造和移动赋值，以转移所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;</span><br><span class="line">    other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值</span></span><br><span class="line">SimpleUniquePtr&amp; <span class="keyword">operator</span>=(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;     <span class="comment">// 释放当前资源</span></span><br><span class="line">        ptr = other.ptr; <span class="comment">// 转移所有权</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>重载 <code>*</code> 和 <code>-&gt;</code> 操作符，以模拟指针的行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头操作符</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裸指针</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有权，返回裸指针并设为 nullptr</span></span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T* temp = ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设定指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下示例展示了如何使用 <code>SimpleUniquePtr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleUniquePtr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleUniquePtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleUniquePtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleUniquePtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SimpleUniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    SimpleUniquePtr&amp; <span class="keyword">operator</span>=(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权</span></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* temp = ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设定指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 SimpleUniquePtr</span></span><br><span class="line">    <span class="function">SimpleUniquePtr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    (*ptr1).<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动所有权到 ptr2</span></span><br><span class="line">    SimpleUniquePtr&lt;Test&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权</span></span><br><span class="line">    Test* rawPtr = ptr2.<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptr2.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now nullptr after release.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    rawPtr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> rawPtr; <span class="comment">// 手动删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reset</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(); <span class="comment">// 自动删除</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now nullptr after reset.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="string">ptr1</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">move.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="string">ptr2</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">release.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">2</span></span><br><span class="line"><span class="string">ptr2</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">reset.</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li>创建 <code>ptr1</code> 并指向一个 <code>Test</code> 对象。</li>
<li>使用 <code>std::move</code> 将所有权转移到 <code>ptr2</code>，<code>ptr1</code> 变为 <code>nullptr</code>。</li>
<li>使用 <code>release()</code> 释放 <code>ptr2</code> 的所有权，获取裸指针后需要手动 <code>delete</code>。</li>
<li>使用 <code>reset()</code> 重新指向一个新的 <code>Test</code> 对象，自动释放之前的资源。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 C++ 中的内存管理方法，包括基础的 <code>malloc</code> 和 <code>free</code>，以及更现代的 C++ 风格的 <code>new</code> 和 <code>delete</code>。通过对比两者的特点，强调了 <code>new</code> 和 <code>delete</code> 在 C++ 中的优势，如类型安全、自动调用构造和析构函数等。</p>
<p>高级内存管理部分探讨了如何使用 <code>realloc</code> 进行内存重分配，并通过实际案例展示了如何实现动态数组和自定义内存管理器。最后，介绍了最佳实践，强调避免内存泄漏的重要性，以及 <code>RAII</code> 和智能指针对内存管理的帮助。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">367</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/secondtonone1" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" target="_blank" title="ZhiHu">
                    
                      <i class="fa fa-fw fa-ZhiHu"></i>ZhiHu</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恋恋风辰</span>

  
  
 
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
 
 
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
