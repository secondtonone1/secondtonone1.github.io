<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="重剑无锋，大巧不工">
<meta property="og:type" content="website">
<meta property="og:title" content="恋恋风辰的个人博客">
<meta property="og:url" content="http://www.limerence2017.com/page/2/index.html">
<meta property="og:site_name" content="恋恋风辰的个人博客">
<meta property="og:description" content="重剑无锋，大巧不工">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="恋恋风辰">
<meta property="article:tag" content="C++ python 大并发网络 逆向">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.limerence2017.com/page/2/"/>





  <title>恋恋风辰的个人博客</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恋恋风辰的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/24/cpppro31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/24/cpppro31/" itemprop="url">聊天项目(31) 单线程文件传输</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-24T18:04:18+08:00">
                2024-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cpppro/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cpppro</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>文件传输必须满足以下几个条件：</p>
<ul>
<li>限制文件大小(不超过<code>4G</code>)</li>
<li>长连接传输(效率高，支持大文件)</li>
<li>客户端和服务器都知道传输进度，以保证支持断点续传(后续实现)</li>
<li>先实现服务器单线程处理版本，在实现多线程处理版本</li>
</ul>
<p>如遇问题可添加我的微信</p>
<img src="https://cdn.llfc.club/wechat.jpg" alt="img" style="zoom: 33%;" />

<p>也可以去我得哔哩哔哩主页查看项目视频详细讲解</p>
<p>B站主页 <a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">https://space.bilibili.com/271469206</a></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端还是采用聊天项目客户端封装的<code>TcpClient</code>, 只是修改了发送逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::slot_send_msg</span><span class="params">(quint16 id, QByteArray body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果连接异常则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(_socket-&gt;<span class="built_in">state</span>() != QAbstractSocket::ConnectedState)&#123;</span><br><span class="line">        <span class="function">emit <span class="title">sig_net_error</span><span class="params">(QString(<span class="string">&quot;断开连接无法发送&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取body的长度</span></span><br><span class="line">    quint32 bodyLength = body.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    QByteArray data;</span><br><span class="line">    <span class="comment">//绑定字节数组</span></span><br><span class="line">    <span class="function">QDataStream <span class="title">stream</span><span class="params">(&amp;data, QIODevice::WriteOnly)</span></span>;</span><br><span class="line">    <span class="comment">//设置大端模式</span></span><br><span class="line">    stream.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">    <span class="comment">//写入ID</span></span><br><span class="line">    stream &lt;&lt; id;</span><br><span class="line">    <span class="comment">//写入长度</span></span><br><span class="line">    stream &lt;&lt; bodyLength;</span><br><span class="line">    <span class="comment">//写入包体</span></span><br><span class="line">    data.<span class="built_in">append</span>(body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">     _socket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里着重叙述以下，发送的格式是<code>id + bodyLength + 文件流数据</code></p>
<p>其中id 为2字节，<code>bodyLength</code>为4字节，之后就是传输的文件流</p>
<p><img src="https://cdn.llfc.club/1732450428990.jpg" alt="https://cdn.llfc.club/1732450428990.jpg"></p>
<p><code>slot_send_msg</code>是槽函数，和 <code>sig_send_msg</code>信号连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接 发送数据信号和槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;TcpClient::sig_send_msg, <span class="keyword">this</span>, &amp;TcpClient::slot_send_msg);</span><br></pre></td></tr></table></figure>

<p>客户端在发送数据的时候调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::sendMsg</span><span class="params">(quint16 id,QByteArray data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发送信号，统一交给槽函数处理，这么做的好处是多线程安全</span></span><br><span class="line">    <span class="function">emit <span class="title">sig_send_msg</span><span class="params">(id, data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在打开文件对话框后选择文件，接下来，点击发送会将文件切分成固定大小的报文发送</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_uploadBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;uploadBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">       <span class="function">QFile <span class="title">file</span><span class="params">(_file_name)</span></span>;</span><br><span class="line">       <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">           <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Could not open file:&quot;</span> &lt;&lt; file.<span class="built_in">errorString</span>();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 保存当前文件指针位置</span></span><br><span class="line">       qint64 originalPos = file.<span class="built_in">pos</span>();</span><br><span class="line">       <span class="function">QCryptographicHash <span class="title">hash</span><span class="params">(QCryptographicHash::Md5)</span></span>;</span><br><span class="line">       <span class="keyword">if</span> (!hash.<span class="built_in">addData</span>(&amp;file)) &#123;</span><br><span class="line">           <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to read data from file:&quot;</span> &lt;&lt; _file_name;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       _file_md5 = hash.<span class="built_in">result</span>().<span class="built_in">toHex</span>(); <span class="comment">// 返回十六进制字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容并发送</span></span><br><span class="line">    QByteArray buffer;</span><br><span class="line">    <span class="type">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QFileInfo <span class="title">fileInfo</span><span class="params">(_file_name)</span></span>; <span class="comment">// 创建 QFileInfo 对象</span></span><br><span class="line"></span><br><span class="line">    QString fileName = fileInfo.<span class="built_in">fileName</span>(); <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件名是：&quot;</span> &lt;&lt; fileName; <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="type">int</span> total_size = fileInfo.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> last_seq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(total_size % MAX_FILE_LEN)&#123;</span><br><span class="line">        last_seq = (total_size/MAX_FILE_LEN)+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        last_seq = total_size/MAX_FILE_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件指针到原来的位置</span></span><br><span class="line">    file.<span class="built_in">seek</span>(originalPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        <span class="comment">//每次读取2048字节发送</span></span><br><span class="line">        buffer = file.<span class="built_in">read</span>(MAX_FILE_LEN);</span><br><span class="line">        QJsonObject jsonObj;</span><br><span class="line">        <span class="comment">// 将文件内容转换为 Base64 编码（可选）</span></span><br><span class="line">        QString base64Data = buffer.<span class="built_in">toBase64</span>();</span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt; &quot;send data is &quot; &lt;&lt; base64Data;</span></span><br><span class="line">        ++seq;</span><br><span class="line">        jsonObj[<span class="string">&quot;md5&quot;</span>] = _file_md5;</span><br><span class="line">        jsonObj[<span class="string">&quot;name&quot;</span>] = fileName;</span><br><span class="line">        jsonObj[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">        jsonObj[<span class="string">&quot;trans_size&quot;</span>] = buffer.<span class="built_in">size</span>() + (seq<span class="number">-1</span>)*MAX_FILE_LEN;</span><br><span class="line">        jsonObj[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">        <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() &lt; MAX_FILE_LEN)&#123;</span><br><span class="line">            jsonObj[<span class="string">&quot;last&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            jsonObj[<span class="string">&quot;last&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonObj[<span class="string">&quot;data&quot;</span>]= base64Data;</span><br><span class="line">        jsonObj[<span class="string">&quot;last_seq&quot;</span>] = last_seq;</span><br><span class="line">        <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(jsonObj)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> send_data = doc.<span class="built_in">toJson</span>();</span><br><span class="line">        TcpClient::<span class="built_in">Inst</span>().<span class="built_in">sendMsg</span>(ID_UPLOAD_FILE_REQ, send_data);</span><br><span class="line">        <span class="comment">//startDelay(500);</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送时数据字段分别为：</p>
<ul>
<li><p>文件<code>md5 </code> : 以后用来做断点续传校验</p>
</li>
<li><p><code>name</code> : 文件名</p>
</li>
<li><p><code>seq</code>:  报文序列号，类似于TCP序列号，自己定义的，服务器根据这个序列号组合数据写入文件。</p>
</li>
<li><p><code>trans_size</code>:   当前已经传输的大小</p>
</li>
<li><p><code>total_size</code>： 传输文件的总大小。</p>
</li>
</ul>
<p>客户端需要接受服务器返回的消息更新进度条</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受服务器发送的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::slot_ready_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取所有数据</span></span><br><span class="line">    QByteArray data = _socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据缓存起来</span></span><br><span class="line">    _buffer.<span class="built_in">append</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理收到的数据</span></span><br><span class="line">    <span class="built_in">processData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理消息更新进度条</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::processData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(_buffer.<span class="built_in">size</span>() &gt;= TCP_HEAD_LEN)&#123;</span><br><span class="line">        <span class="comment">//先取出八字节头部</span></span><br><span class="line">        <span class="keyword">auto</span> head_byte = _buffer.<span class="built_in">left</span>(TCP_HEAD_LEN);</span><br><span class="line">        <span class="function">QDataStream <span class="title">stream</span><span class="params">(head_byte)</span></span>;</span><br><span class="line">        <span class="comment">//设置为大端模式</span></span><br><span class="line">        stream.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">        <span class="comment">//读取ID</span></span><br><span class="line">        quint16 msg_id;</span><br><span class="line">        stream &gt;&gt; msg_id;</span><br><span class="line">        <span class="comment">//读取长度</span></span><br><span class="line">        quint32 body_length;</span><br><span class="line">        stream &gt;&gt; body_length;</span><br><span class="line">        <span class="keyword">if</span>(_buffer.<span class="built_in">size</span>() &gt;= TCP_HEAD_LEN+body_length)&#123;</span><br><span class="line">            <span class="comment">//完整的消息体已经接受</span></span><br><span class="line">            QByteArray body = _buffer.<span class="built_in">mid</span>(TCP_HEAD_LEN,body_length);</span><br><span class="line">            <span class="comment">//去掉完整的消息包</span></span><br><span class="line">            _buffer = _buffer.<span class="built_in">mid</span>(TCP_HEAD_LEN+body_length);</span><br><span class="line">            <span class="comment">// 解析服务器发过来的消息</span></span><br><span class="line">            QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(body);</span><br><span class="line">            <span class="keyword">if</span>(jsonDoc.<span class="built_in">isNull</span>())&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create JSON doc.&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!jsonDoc.<span class="built_in">isObject</span>())&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;JSON is not an object.&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//qDebug() &lt;&lt; &quot;receive data is &quot; &lt;&lt; body;</span></span><br><span class="line">            <span class="comment">// 获取 JSON 对象</span></span><br><span class="line">            QJsonObject jsonObject = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line">            <span class="function">emit <span class="title">sig_logic_process</span><span class="params">(msg_id, jsonObject)</span></span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//消息未完全接受，所以中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单线程逻辑服务器"><a href="#单线程逻辑服务器" class="headerlink" title="单线程逻辑服务器"></a>单线程逻辑服务器</h2><p>我们先讲解单线程处理收包逻辑的服务器，以后再给大家将多线程的。</p>
<p>服务器要配合客户端，对报文头部大小做修改</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部总长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_TOTAL_LEN 6</span></span><br><span class="line"><span class="comment">//头部id长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_ID_LEN 2</span></span><br><span class="line"><span class="comment">//头部数据长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_DATA_LEN 4</span></span><br><span class="line"><span class="comment">// 接受队列最大个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RECVQUE  2000000</span></span><br><span class="line"><span class="comment">// 发送队列最大个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SENDQUE 2000000</span></span><br></pre></td></tr></table></figure>

<p>其余逻辑和我们在网络编程中讲的<code>IocontextPool</code>模型服务器一样</p>
<p>服务器收到报文头后调用<code>LogicSystem</code>来处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::AsyncReadBody</span><span class="params">(<span class="type">int</span> total_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="built_in">asyncReadFull</span>(total_len, [self, <span class="keyword">this</span>, total_len](<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transfered) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">Close</span>();</span><br><span class="line">				_server-&gt;<span class="built_in">ClearSession</span>(_session_id);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (bytes_transfered &lt; total_len) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;read length not match, read [&quot;</span> &lt;&lt; bytes_transfered &lt;&lt; <span class="string">&quot;] , total [&quot;</span></span><br><span class="line">					&lt;&lt; total_len&lt;&lt;<span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">Close</span>();</span><br><span class="line">				_server-&gt;<span class="built_in">ClearSession</span>(_session_id);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data , _data , bytes_transfered);</span><br><span class="line">			_recv_msg_node-&gt;_cur_len += bytes_transfered;</span><br><span class="line">			_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">			<span class="comment">//此处将消息投递到逻辑队列中</span></span><br><span class="line">			LogicSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line">			<span class="comment">//继续监听头部接受事件</span></span><br><span class="line">			<span class="built_in">AsyncReadHead</span>(HEAD_TOTAL_LEN);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>LogicSystem</code>会将消息投递到队列里，然后单线程处理,  服务器<code>LogicSystem</code>注册上传逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_fun_callbacks[ID_TEST_MSG_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;recv test data is  &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_TEST_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;data&quot;</span>] = data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_UPLOAD_FILE_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			<span class="comment">//std::cout &lt;&lt; &quot;recv file data is  &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 解码</span></span><br><span class="line">			std::string decoded = <span class="built_in">base64_decode</span>(data);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> seq = root[<span class="string">&quot;seq&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> name = root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			<span class="keyword">auto</span> total_size = root[<span class="string">&quot;total_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> trans_size = root[<span class="string">&quot;trans_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> file_path = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetFileOutPath</span>();</span><br><span class="line">			<span class="keyword">auto</span> file_path_str = (file_path / name).<span class="built_in">string</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;file_path_str is &quot;</span> &lt;&lt; file_path_str &lt;&lt; std::endl;</span><br><span class="line">			std::ofstream outfile;</span><br><span class="line">			<span class="comment">//第一个包</span></span><br><span class="line">			<span class="keyword">if</span> (seq == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 打开文件，如果存在则清空，不存在则创建</span></span><br><span class="line">				outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::trunc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 保存为文件</span></span><br><span class="line">				outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::app);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">				std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			outfile.<span class="built_in">write</span>(decoded.<span class="built_in">data</span>(), decoded.<span class="built_in">size</span>());</span><br><span class="line">			<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">				std::cerr &lt;&lt; <span class="string">&quot;写入文件失败。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			outfile.<span class="built_in">close</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;文件已成功保存为: &quot;</span> &lt;&lt; name &lt;&lt;  std::endl;</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">			rtvalue[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">			rtvalue[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">			rtvalue[<span class="string">&quot;trans_size&quot;</span>] = trans_size;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收到上传消息后写入文件。</p>
<h2 id="多线程逻辑服务器"><a href="#多线程逻辑服务器" class="headerlink" title="多线程逻辑服务器"></a>多线程逻辑服务器</h2><p>多线程逻辑服务器主要是为了缓解单线程接受数据造成的瓶颈，因为单线程接收数据，就会影响其他线程接收数据，所以考虑引入线程池处理收到的数据。</p>
<p>在多线程编程中我们讲过划分多线程设计的几种思路：</p>
<ol>
<li>按照任务划分，将不同的任务投递给不同的线程</li>
<li>按照线程数轮询处理</li>
<li>按照递归的方式划分</li>
</ol>
<p>很明显我们不是做二分查找之类的算法处理，所以不会采用第三种。</p>
<p>现在考虑第二种，如果客户端发送一个很大的文件，客户端将文件切分为几个小份发送，服务器通过<code>iocontext</code>池接受数据, 将接受的数据投递到线程池。</p>
<p>我们知道线程池处理任务是不分先后顺序的，只要投递到队列中的都会被无序取出处理。</p>
<p><img src="https://cdn.llfc.club/1732945106584.jpg" alt="https://cdn.llfc.club/1732945106584.jpg"></p>
<p>会造成数据包处理的乱序，当然可以最后交给一个线程去组合，统一写入文件，这么做的一个弊端就是如果文件很大，那就要等待完全重组完成才能组合为一个统一的包，如果文件很大，这个时间就会很长，当然也可以暂时缓存这些数据，每次收到后排序组合，比较麻烦。</p>
<p>所以这里推荐按照任务划分。</p>
<p>按照任务划分就是按照不同的客户端做区分，一个客户端传输的数据按照文件名字的hash值划分给不同的线程单独处理，也就是一个线程专门处理对应的hash值的任务，这样既能保证有序，又能保证其他线程可以处理其他任务，也有概率会命中hash同样的值投递给一个队列，但也扩充了并发能力。</p>
<p><img src="https://cdn.llfc.club/1732948742965.jpg" alt="https://cdn.llfc.club/1732948742965.jpg"></p>
<p>因为我们之前的逻辑处理也是单线程，所以考虑在逻辑层这里做一下解耦合，因为这个服务只是用来处理数据接受，不涉及多个连接互相访问。所以可以讲logic线程扩充为多个，按照<code>sessionid</code>将不同的逻辑分配给不同的线程处理。</p>
<p><img src="https://cdn.llfc.club/1732952125218.jpg" alt="https://cdn.llfc.club/1732952125218.jpg"></p>
<h2 id="多线程处理逻辑"><a href="#多线程处理逻辑" class="headerlink" title="多线程处理逻辑"></a>多线程处理逻辑</h2><p>将<code>LogicSystem</code>中添加多个<code>LogicWorker</code>用来处理逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  function&lt;<span class="type">void</span>(shared_ptr&lt;CSession&gt;, <span class="type">const</span> <span class="type">short</span> &amp;msg_id, <span class="type">const</span> string &amp;msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span>:<span class="keyword">public</span> Singleton&lt;LogicSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">LogicSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(shared_ptr &lt; LogicNode&gt; msg, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>();</span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;LogicWorker&gt; &gt; _workers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现投递逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LOGIC_WORKER_COUNT; i++) &#123;</span><br><span class="line">		_workers.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;LogicWorker&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(shared_ptr &lt; LogicNode&gt; msg, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">	_workers[index]-&gt;<span class="built_in">PostTask</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个LogicWorker都包含一个线程，这样LogicWorker可以在独立的线程里处理任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicWorker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicWorker</span>();</span><br><span class="line">	~<span class="built_in">LogicWorker</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; task)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">task_callback</span><span class="params">(std::shared_ptr&lt;LogicNode&gt;)</span></span>;</span><br><span class="line">	std::thread _work_thread;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _task_que;</span><br><span class="line">	std::atomic&lt;<span class="type">bool</span>&gt; _b_stop;</span><br><span class="line">	std::mutex  _mtx;</span><br><span class="line">	std::condition_variable _cv;</span><br><span class="line">	std::unordered_map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>LogicWorker启动一个线程处理任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LogicWorker::<span class="built_in">LogicWorker</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">RegisterCallBacks</span>();</span><br><span class="line"></span><br><span class="line">	_work_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="keyword">while</span> (!_b_stop) &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">			_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">				<span class="keyword">if</span>(_b_stop) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (_task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> task = _task_que.<span class="built_in">front</span>();</span><br><span class="line">			<span class="built_in">task_callback</span>(task);</span><br><span class="line">			_task_que.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然要提前注册好任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicWorker::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_fun_callbacks[ID_TEST_MSG_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;recv test data is  &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_TEST_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;data&quot;</span>] = data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_UPLOAD_FILE_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> seq = root[<span class="string">&quot;seq&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> name = root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			<span class="keyword">auto</span> total_size = root[<span class="string">&quot;total_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> trans_size = root[<span class="string">&quot;trans_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> last = root[<span class="string">&quot;last&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> file_data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用 std::hash 对字符串进行哈希</span></span><br><span class="line">			std::hash&lt;std::string&gt; hash_fn;</span><br><span class="line">			<span class="type">size_t</span> hash_value = <span class="built_in">hash_fn</span>(name); <span class="comment">// 生成哈希值</span></span><br><span class="line">			<span class="type">int</span> index = hash_value % FILE_WORKER_COUNT;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Hash value: &quot;</span> &lt;&lt; hash_value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			FileSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(</span><br><span class="line">				std::<span class="built_in">make_shared</span>&lt;FileTask&gt;(session, name, seq, total_size,</span><br><span class="line">					trans_size, last, file_data),</span><br><span class="line">				index</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">			rtvalue[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">			rtvalue[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">			rtvalue[<span class="string">&quot;trans_size&quot;</span>] = trans_size;</span><br><span class="line">			rtvalue[<span class="string">&quot;last&quot;</span>] = last;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicWorker::task_callback</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; task-&gt;_recvnode-&gt;_msg_id &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(task-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">	<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	call_back_iter-&gt;<span class="built_in">second</span>(task-&gt;_session, task-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">		std::<span class="built_in">string</span>(task-&gt;_recvnode-&gt;_data, task-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如对于文件上传，<code>ID_UPLOAD_FILE_REQ</code>就调用对应的回调，在回调函数里我们再次将要处理的任务封装好投递到文件系统</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(</span><br><span class="line">				std::<span class="built_in">make_shared</span>&lt;FileTask&gt;(session, name, seq, total_size,</span><br><span class="line">					trans_size, last, file_data),</span><br><span class="line">				index</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<p>文件系统和逻辑系统类似，包含一堆FileWorker</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> :<span class="keyword">public</span> Singleton&lt;FileSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;FileSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">FileSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(shared_ptr &lt;FileTask&gt; msg, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">FileSystem</span>();</span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;FileWorker&gt;&gt;  _file_workers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现投递逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileSystem::~<span class="built_in">FileSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileSystem::PostMsgToQue</span><span class="params">(shared_ptr&lt;FileTask&gt; msg, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_file_workers[index]-&gt;<span class="built_in">PostTask</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileSystem::<span class="built_in">FileSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILE_WORKER_COUNT; i++) &#123;</span><br><span class="line">		_file_workers.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;FileWorker&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义文件任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileTask</span> &#123;</span><br><span class="line">	<span class="built_in">FileTask</span>(std::shared_ptr&lt;CSession&gt; session, std::string name,</span><br><span class="line">		<span class="type">int</span> seq, <span class="type">int</span> total_size, <span class="type">int</span> trans_size, <span class="type">int</span> last, </span><br><span class="line">		std::string file_data) :_session(session),</span><br><span class="line">		_seq(seq),_name(name),_total_size(total_size),</span><br><span class="line">		_trans_size(trans_size),_last(last),_file_data(file_data)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">FileTask</span>()&#123;&#125;</span><br><span class="line">	std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _seq ;</span><br><span class="line">	std::string _name ;</span><br><span class="line">	<span class="type">int</span> _total_size ;</span><br><span class="line">	<span class="type">int</span> _trans_size ;</span><br><span class="line">	<span class="type">int</span> _last ;</span><br><span class="line">	std::string _file_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现文件工作者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileWorker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FileWorker</span>();</span><br><span class="line">	~<span class="built_in">FileWorker</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">task_callback</span><span class="params">(std::shared_ptr&lt;FileTask&gt;)</span></span>;</span><br><span class="line">	std::thread _work_thread;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;FileTask&gt;&gt; _task_que;</span><br><span class="line">	std::atomic&lt;<span class="type">bool</span>&gt; _b_stop;</span><br><span class="line">	std::mutex  _mtx;</span><br><span class="line">	std::condition_variable _cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数启动线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FileWorker::<span class="built_in">FileWorker</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_work_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="keyword">while</span> (!_b_stop) &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">			_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">				<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (_task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> task = _task_que.<span class="built_in">front</span>();</span><br><span class="line">			_task_que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="built_in">task_callback</span>(task);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构需等待线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileWorker::~<span class="built_in">FileWorker</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_b_stop = <span class="literal">true</span>;</span><br><span class="line">	_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	_work_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>投递任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileWorker::PostTask</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">		_task_que.<span class="built_in">push</span>(task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为线程会触发回调函数保存文件，所以我们实现回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileWorker::task_callback</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	std::string decoded = <span class="built_in">base64_decode</span>(task-&gt;_file_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> file_path = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetFileOutPath</span>();</span><br><span class="line">	<span class="keyword">auto</span> file_path_str = (file_path / task-&gt;_name).<span class="built_in">string</span>();</span><br><span class="line">	<span class="keyword">auto</span> last = task-&gt;_last;</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; &quot;file_path_str is &quot; &lt;&lt; file_path_str &lt;&lt; std::endl;</span></span><br><span class="line">	std::ofstream outfile;</span><br><span class="line">	<span class="comment">//第一个包</span></span><br><span class="line">	<span class="keyword">if</span> (task-&gt;_seq == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 打开文件，如果存在则清空，不存在则创建</span></span><br><span class="line">		outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::trunc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 保存为文件</span></span><br><span class="line">		outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::app);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">write</span>(decoded.<span class="built_in">data</span>(), decoded.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;写入文件失败。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">if</span> (last) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;文件已成功保存为: &quot;</span> &lt;&lt; task-&gt;_name &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p><img src="https://cdn.llfc.club/1732955339237.jpg" alt="https://cdn.llfc.club/1732955339237.jpg"></p>
<h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server">https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/23/cppbase21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/23/cppbase21/" itemprop="url">零基础C++(21) 类相关面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-23T09:47:27+08:00">
                2024-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>详细技术视频请看我的主页</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">C++教程视频</a></p>
<h2 id="什么是默认构造"><a href="#什么是默认构造" class="headerlink" title="什么是默认构造"></a>什么是默认构造</h2><p>默认构造就是不带参数的构造函数，如果我们不实现任何构造函数，系统会为我们生成一个默认的构造函数</p>
<p>比如下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以我们可以直接使用默认构造函数构造一个对象，并且打印成员<code>_i</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试默认合成</span></span><br><span class="line">JoiningThread jt;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member _i is -1284874240</span><br></pre></td></tr></table></figure>

<p>可以看到默认构造函数并不会帮我们初始化类成员变量。</p>
<h2 id="什么是有参构造"><a href="#什么是有参构造" class="headerlink" title="什么是有参构造"></a>什么是有参构造</h2><p>有参构造就是传递参数的构造函数，可以根据参数构造对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JoiningThread</span>(<span class="type">int</span> i) : _i&#123;i&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下方式构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JoiningThread <span class="title">jt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>当我们执行程序，会输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member _i is 1</span><br></pre></td></tr></table></figure>

<p>但如果这样构造会产生问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JoiningThread jt;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>如果我们实现了参数构造而不实现无参构造，系统将不会为我们实现默认构造，导致无法使用默认构造生成对象。</p>
</blockquote>
<p>所以稳妥一点，我们基本都会实现无参构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JoiningThread</span>() :_i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">JoiningThread</span>(<span class="type">int</span> i) : _i&#123;i&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝构造函数是什么"><a href="#拷贝构造函数是什么" class="headerlink" title="拷贝构造函数是什么"></a><strong>拷贝构造函数是什么</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：拷贝构造函数用于创建一个对象，该对象是通过复制另一个同类型对象来初始化的。</p>
</li>
<li><p>调用时机</p>
<p>：</p>
<ul>
<li>使用现有对象初始化新对象。</li>
<li>按值传递对象作为函数参数。</li>
<li>按值返回对象。</li>
</ul>
</li>
<li><p><strong>默认拷贝构造函数</strong>：成员逐个拷贝。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        <span class="comment">// 复制代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="是否会默认生成拷贝构造"><a href="#是否会默认生成拷贝构造" class="headerlink" title="是否会默认生成拷贝构造"></a>是否会默认生成拷贝构造</h2><p>在 C++ 中，如果你没有为一个类显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。这个默认拷贝构造函数会按成员的逐个拷贝（member-wise copy）方式来复制对象的每个成员变量。</p>
<h2 id="默认拷贝构造函数的行为"><a href="#默认拷贝构造函数的行为" class="headerlink" title="默认拷贝构造函数的行为"></a>默认拷贝构造函数的行为</h2><ol>
<li><strong>逐个拷贝</strong>：默认拷贝构造函数会逐个拷贝所有的非静态成员变量。</li>
<li><strong>指针成员</strong>：如果类中有指针成员，默认拷贝构造函数只会拷贝指针的值（地址），而不会拷贝指针所指向的对象。这可能会导致多个对象指向同一块内存，进而引发问题（如双重释放、内存泄漏等）。</li>
<li>**<code>const</code> 和<code>引用成员</code>**：如果类中有 <code>const</code> 成员或引用成员，编译器不会生成默认的拷贝构造函数，因为这些成员不能被复制。</li>
<li>类中包含不可拷贝对象时，无法合成默认拷贝构造函数</li>
</ol>
<h2 id="拷贝构造是否必须实现"><a href="#拷贝构造是否必须实现" class="headerlink" title="拷贝构造是否必须实现"></a>拷贝构造是否必须实现</h2><p>当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。</p>
<p>比如一个类<code>JoiningThread</code>中有成员变量<code>std::thread</code>，<code>std::thread</code>没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。</p>
<p>比如我们这样调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JoiningThread <span class="title">jt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">JoiningThread <span class="title">jt2</span><span class="params">(jt)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>上面代码报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of deleted function <span class="string">&#x27;std::thread::thread(const std::thread&amp;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以我们要显示实现拷贝构造，指定一个拷贝规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JoiningThread</span>(<span class="type">const</span> JoiningThread &amp; other): _i(other._i)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是浅拷贝和深拷贝"><a href="#什么是浅拷贝和深拷贝" class="headerlink" title="什么是浅拷贝和深拷贝"></a>什么是浅拷贝和深拷贝</h2><p>类在拷贝构造或者拷贝赋值的时候，将被拷贝的类中的成员值拷贝到目的类，如果被拷贝的类中包含指针成员，只是简单的拷贝指针的值。</p>
<p>同样析构也要显示编写，等待线程完成。</p>
<p>除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果</p>
<p><img src="https://cdn.llfc.club/1731294878994.jpg" alt="https://cdn.llfc.club/1731294878994.jpg"></p>
<p><img src="https://cdn.llfc.club/1731295328032.jpg-llfc" alt="https://cdn.llfc.club/1731295328032.jpg-llfc"></p>
<h2 id="构造顺序和析构顺序"><a href="#构造顺序和析构顺序" class="headerlink" title="构造顺序和析构顺序"></a>构造顺序和析构顺序</h2><p>类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？</p>
<p>如果析构的时候是A先析构还是B先析构呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InnerB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InnerB</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;InnerB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">InnerB</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~InnerB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrapperC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WrapperC</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WrapperC()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">WrapperC</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~WrapperC()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    InnerB _inner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行结果，先调用B的构造，在调用C的构造。</p>
<p>析构时，先析构C再析构B</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InnerB</span>()</span><br><span class="line"><span class="built_in">WrapperC</span>()</span><br><span class="line">~<span class="built_in">WrapperC</span>()</span><br><span class="line">~<span class="built_in">InnerB</span>()</span><br></pre></td></tr></table></figure>

<h2 id="类默认构造是否必须实现"><a href="#类默认构造是否必须实现" class="headerlink" title="类默认构造是否必须实现"></a>类默认构造是否必须实现</h2><p>如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。</p>
<p>系统提供的合成的默认构造函数不会对成员做初始化操作。</p>
<p>比如我们之后要学到的继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>: <span class="keyword">public</span> BaseA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedA</span>(std::string name,std::string num) :</span><br><span class="line">    <span class="built_in">BaseA</span>(name), _num(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string _num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DerivedA <span class="title">a</span><span class="params">(<span class="string">&quot;zack&quot;</span>,<span class="string">&quot;1001&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="this-指针的特性和用途"><a href="#this-指针的特性和用途" class="headerlink" title="this 指针的特性和用途"></a><code>this</code> 指针的特性和用途</h2><ol>
<li><p><strong>指向当前对象</strong>：</p>
<ul>
<li><code>this</code> 指针是一个隐式参数，指向调用成员函数的对象。通过 <code>this</code>，你可以访问当前对象的属性和方法。</li>
</ul>
</li>
<li><p><strong>区分成员变量和参数</strong>：</p>
<ul>
<li><p>在构造函数或成员函数中，参数名和成员变量可能同名。使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure>

<p>可以明确指代成员变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>返回当前对象</strong>：</p>
<ul>
<li>```<br>this<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以用于返回当前对象的引用，以支持链式调用。例如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    MyClass&amp; setValue(int value) &#123;</span><br><span class="line">        this-&gt;value = value;</span><br><span class="line">        return *this; // 返回当前对象的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.setValue(10).setValue(20); // 链式调用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>在 const 成员函数中的使用</strong>：</p>
<ul>
<li>在 <code>const</code> 成员函数中，<code>this</code> 的类型为 <code>const MyClass*</code>，这意味着你不能通过 <code>this</code> 修改成员变量。这有助于确保对象的状态不被改变。</li>
</ul>
</li>
<li><p><strong>在静态成员函数中的不可用性</strong>：</p>
<ul>
<li>静态成员函数没有 <code>this</code> 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。</li>
</ul>
</li>
</ol>
<p><strong>示例代码</strong></p>
<p>以下是一个简单的示例，展示了 <code>this</code> 指针的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl; <span class="comment">// 使用 this 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">printValue</span>(); <span class="comment">// 链式调用，输出: Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="delete和default"><a href="#delete和default" class="headerlink" title="delete和default"></a>delete和default</h2><p><code>C++11</code>用法：</p>
<p>delete可以删除指定的构造函数。</p>
<p>default可以指定某个构造函数为系统默认合成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">DefaultClass</span>(<span class="type">const</span> DefaultClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DefaultClass &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DefaultClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;out, <span class="type">const</span> DefaultClass &amp;defaultClass);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _num ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主函数中调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultClass b;</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出<code>num</code>是一个随机数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultClass num is 331</span><br></pre></td></tr></table></figure>



<h2 id="什么是移动构造函数？与拷贝构造函数有何不同？"><a href="#什么是移动构造函数？与拷贝构造函数有何不同？" class="headerlink" title="什么是移动构造函数？与拷贝构造函数有何不同？"></a><strong>什么是移动构造函数？与拷贝构造函数有何不同？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：移动构造函数用于通过“移动”资源来初始化对象，而不是复制资源。</p>
</li>
<li><p><strong>语法</strong>：使用右值引用作为参数 (<code>MyClass(MyClass&amp;&amp; other)</code>).</p>
</li>
<li><p>优势</p>
<p>：</p>
<ul>
<li>性能更高，避免不必要的深拷贝。</li>
<li>适用于临时对象。</li>
</ul>
</li>
<li><p>区别</p>
<p>：</p>
<ul>
<li>拷贝构造函数复制资源，移动构造函数转移资源所有权。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        <span class="comment">// 移动资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="默认构造函数和用户定义的构造函数有什么区别？"><a href="#默认构造函数和用户定义的构造函数有什么区别？" class="headerlink" title="默认构造函数和用户定义的构造函数有什么区别？"></a><strong>默认构造函数和用户定义的构造函数有什么区别？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p>默认构造函数</p>
<p>：</p>
<ul>
<li>无参数的构造函数。</li>
<li>如果没有用户定义的构造函数，编译器会自动生成一个默认构造函数。</li>
</ul>
</li>
<li><p>用户定义的构造函数</p>
<p>：</p>
<ul>
<li>开发者自定义的构造函数，可以有参数。</li>
<li>一旦定义了任何构造函数，编译器不会再生成默认构造函数，除非显式声明。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">// 有参数的构造函数</span></span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="什么是初始化列表？为什么在构造函数中使用它？"><a href="#什么是初始化列表？为什么在构造函数中使用它？" class="headerlink" title="什么是初始化列表？为什么在构造函数中使用它？"></a><strong>什么是初始化列表？为什么在构造函数中使用它？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：初始化列表是在构造函数的参数列表之后，函数体之前，用于初始化成员变量的语法。</p>
</li>
<li><p>优点</p>
<p>：</p>
<ul>
<li>提高性能，特别是对于常量成员或引用成员。</li>
<li>必须用于初始化常量成员、引用成员以及基类。</li>
<li>避免对象先默认构造再赋值，减少不必要的操作。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123; <span class="comment">// 初始化列表</span></span><br><span class="line">        <span class="comment">// 其他初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="什么是虚析构函数？为什么需要它？"><a href="#什么是虚析构函数？为什么需要它？" class="headerlink" title="什么是虚析构函数？为什么需要它？"></a><strong>什么是虚析构函数？为什么需要它？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：在基类中将析构函数声明为<code>virtual</code>，以确保通过基类指针删除派生类对象时，能正确调用派生类的析构函数。</p>
</li>
<li><p>用途</p>
<p>：</p>
<ul>
<li>防止内存泄漏。</li>
<li>确保派生类的资源被正确释放。</li>
</ul>
</li>
<li><p>不使用虚析构函数的风险</p>
<p>：</p>
<ul>
<li>仅调用基类析构函数，导致派生类资源未释放。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>如果<code>BaseA</code>的析构不写成虚析构，则主函数开辟子类对象赋值给基类指针，以后<code>delete</code>基类指针的时候会发现没有析构子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(std::string name):_name(name)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BaseA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>: <span class="keyword">public</span> BaseA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedA</span>(std::string name,std::string num) :</span><br><span class="line">    <span class="built_in">BaseA</span>(name), _num(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DerivedA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主函数回收内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseA* base = <span class="keyword">new</span> <span class="built_in">DerivedA</span>(<span class="string">&quot;zack&quot;</span>,<span class="string">&quot;1002&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> base;</span><br></pre></td></tr></table></figure>

<p>会看到只调用了基类<code>BaseA</code>的析构函数。</p>
<p>当BaseA的析构改为虚析构的时候，才会回收子类DerivedA</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(std::string name):_name(name)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="什么是委托构造函数？它是如何工作的？（C-11引入的特性）"><a href="#什么是委托构造函数？它是如何工作的？（C-11引入的特性）" class="headerlink" title="什么是委托构造函数？它是如何工作的？（C++11引入的特性）"></a><strong>什么是委托构造函数？它是如何工作的？（C++11引入的特性）</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：一个构造函数可以调用同一类中的另一个构造函数，从而委托初始化任务。</p>
</li>
<li><p>优点</p>
<p>：</p>
<ul>
<li>避免代码重复，提升代码可维护性。</li>
</ul>
</li>
<li><p><strong>语法</strong>：使用构造函数初始化列表中的类名和参数。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>, <span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="什么是析构函数的顺序？"><a href="#什么是析构函数的顺序？" class="headerlink" title="什么是析构函数的顺序？"></a><strong>什么是析构函数的顺序？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><strong>成员变量的析构顺序</strong>：按照声明的逆序析构。</li>
<li><strong>继承关系的析构顺序</strong>：先析构派生类的成员和资源，再析构基类。</li>
<li><strong>全局/静态对象</strong>：按照创建的逆序析构。</li>
</ul>
<p><strong>示例说明：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    <span class="comment">// 当obj被销毁时，首先调用Derived的析构函数，然后调用Base的析构函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived析构</span><br><span class="line">Base析构</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="如何防止对象被复制？"><a href="#如何防止对象被复制？" class="headerlink" title="如何防止对象被复制？"></a><strong>如何防止对象被复制？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><strong>C++11及以上</strong>：使用<code>delete</code>关键字显式删除拷贝构造函数和拷贝赋值运算符。</li>
<li><strong>C++11之前</strong>：将拷贝构造函数和拷贝赋值运算符声明为私有且不实现。</li>
</ul>
<p><strong>示例（C++11及以上）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="构造函数中抛出异常会发生什么？"><a href="#构造函数中抛出异常会发生什么？" class="headerlink" title="构造函数中抛出异常会发生什么？"></a><strong>构造函数中抛出异常会发生什么？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><strong>对象未完全构造</strong>：如果构造函数中抛出异常，析构函数不会被调用，因为对象尚未完全构造。</li>
<li><strong>资源泄漏风险</strong>：如果在构造函数中分配了资源，需使用RAII（资源获取即初始化）类或智能指针来确保资源被正确释放。</li>
<li><strong>异常安全</strong>：确保在构造函数抛出异常时，任何已经初始化的成员都会被正确析构。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        data.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;构造函数异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="解释RAII及其与构造函数、析构函数的关系"><a href="#解释RAII及其与构造函数、析构函数的关系" class="headerlink" title="解释RAII及其与构造函数、析构函数的关系"></a><strong>解释<code>RAII</code>及其与构造函数、析构函数的关系</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><code>RAII</code>（资源获取即初始化）</p>
<p>：</p>
<ul>
<li>编程范式，通过对象的生命周期管理资源。</li>
<li>资源在对象构造时获取，在对象析构时释放。</li>
</ul>
</li>
<li><p>关系</p>
<p>：</p>
<ul>
<li>构造函数负责获取资源。</li>
<li>析构函数负责释放资源。</li>
</ul>
</li>
<li><p>优点</p>
<p>：</p>
<ul>
<li>自动管理资源，防止内存泄漏。</li>
<li>异常安全，确保资源在异常发生时被释放。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    FILE* file;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        file = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file) <span class="built_in">fclose</span>(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁止拷贝和移动</span></span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    FileHandler&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="解释什么是赋值运算符重载？与拷贝构造函数有何不同？"><a href="#解释什么是赋值运算符重载？与拷贝构造函数有何不同？" class="headerlink" title="解释什么是赋值运算符重载？与拷贝构造函数有何不同？"></a><strong>解释什么是赋值运算符重载？与拷贝构造函数有何不同？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>赋值运算符重载</strong>：通过重载<code>operator=</code>，定义对象之间的赋值行为。</p>
</li>
<li><p>区别与拷贝构造函数</p>
<p>：</p>
<ul>
<li>拷贝构造函数用于初始化新对象。</li>
<li>赋值运算符用于将一个已存在的对象赋值给另一个已存在的对象。</li>
</ul>
</li>
<li><p>常规实现</p>
<p>：</p>
<ul>
<li>检查自赋值。</li>
<li>释放已有资源。</li>
<li>复制资源。</li>
<li>返回<code>*this</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123; <span class="comment">// 赋值运算符重载</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自赋值检查</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 复制资源</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="解释静态成员变量在构造和析构中的处理"><a href="#解释静态成员变量在构造和析构中的处理" class="headerlink" title="解释静态成员变量在构造和析构中的处理"></a><strong>解释静态成员变量在构造和析构中的处理</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p>静态成员变量</p>
<p>：</p>
<ul>
<li>属于类本身，而非任何对象实例。</li>
<li>在程序开始时初始化，在程序结束时析构。</li>
</ul>
</li>
<li><p>构造顺序</p>
<p>：</p>
<ul>
<li>单例模式中，静态成员在第一次使用时构造。</li>
</ul>
</li>
<li><p>析构顺序</p>
<p>：</p>
<ul>
<li>按逆序构造顺序析构，确保依赖关系被正确处理。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> MyClass instance;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="string">&quot;构造\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//放在cpp中</span></span><br><span class="line">MyClass MyClass::instance; <span class="comment">// 静态成员变量定义</span></span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造</span><br><span class="line">析构</span><br></pre></td></tr></table></figure>

<h2 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a><strong>虚函数原理</strong></h2><h2 id="包含虚函数的类构成"><a href="#包含虚函数的类构成" class="headerlink" title="包含虚函数的类构成"></a>包含虚函数的类构成</h2><p>参考我得另一篇文章，<a target="_blank" rel="noopener" href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73</a></p>
<h2 id="虚继承与菱形继承问题"><a href="#虚继承与菱形继承问题" class="headerlink" title="虚继承与菱形继承问题"></a><strong>虚继承与菱形继承问题</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string brand;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Device</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">brand</span>(brand_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBrand</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Brand: &quot;</span> &lt;&lt; brand &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Laptop，虚继承 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Laptop</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Tablet，虚继承 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tablet</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tablet</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Convertible</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Convertible</span> : <span class="keyword">public</span> Laptop, <span class="keyword">public</span> Tablet &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Convertible</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_), <span class="built_in">Laptop</span>(brand_), <span class="built_in">Tablet</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Convertible <span class="title">c</span><span class="params">(<span class="string">&quot;TechBrand&quot;</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">showBrand</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Brand: TechBrand</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<ul>
<li>在无虚继承的情况下，<code>Convertible</code> 类将拥有两份 <code>Device</code> 的成员变量，这会导致二义性问题。</li>
<li>通过使用虚继承（<code>virtual public</code>），确保 <code>Convertible</code> 类只有一份 <code>Device</code> 的成员。</li>
<li>在 <code>Convertible</code> 的构造函数中，需要明确调用基类 <code>Device</code> 的构造函数，避免二义性。</li>
<li>在 <code>main</code> 函数中，创建一个 <code>Convertible</code> 对象，并调用 <code>showBrand()</code> 函数，正确显示品牌名称。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>菱形继承（多重继承导致的重复基类）可以通过虚继承来解决，确保共享同一份基类成员。</li>
<li>虚继承会增加一定的开销，需根据具体需求权衡使用。</li>
</ul>
<h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p><strong>概念定义</strong></p>
<ul>
<li>在 C++ 中，协变返回类型（Covariant Return Types）是一个与函数重写（Override）相关的概念。当一个派生类重写基类的虚函数时，协变返回类型允许派生类的函数返回一个从基类函数返回类型派生而来的类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base cloned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 协变返回类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived cloned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    Base* bClone = b-&gt;<span class="built_in">clone</span>(); <span class="comment">// 输出: Base cloned.</span></span><br><span class="line">    Base* dClone = d-&gt;<span class="built_in">clone</span>(); <span class="comment">// 输出: Derived cloned.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">    <span class="keyword">delete</span> bClone;</span><br><span class="line">    <span class="keyword">delete</span> dClone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base cloned.</span><br><span class="line">Derived cloned.</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<ul>
<li><p>基类 <code>Base</code> 定义了一个虚函数 <code>clone()</code>，返回 <code>Base*</code> 类型的指针。</p>
</li>
<li><p>派生类 <code>Derived</code> 重写了 <code>clone()</code> 函数，返回类型为 <code>Derived*</code>，这是一种协变返回类型。</p>
</li>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure>

<p>函数中，通过基类指针调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone()</span><br></pre></td></tr></table></figure>

<p>函数：</p>
<ul>
<li>对于 <code>Base</code> 对象，调用 <code>Base::clone()</code>。</li>
<li>对于 <code>Derived</code> 对象，由于虚函数机制，调用 <code>Derived::clone()</code>。</li>
</ul>
</li>
<li><p>协变返回类型允许派生类的重写函数返回更具体的类型，增强类型安全性和代码可读性。</p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>协变返回类型必须满足派生类返回类型是基类返回类型的派生类。</li>
<li>编译器会检查协变返回类型的正确性，确保类型安全。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/23/cppbase20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/23/cppbase20/" itemprop="url">零基础C++(20) 继承和多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-23T09:44:32+08:00">
                2024-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-类继承（Class-Inheritance）"><a href="#1-类继承（Class-Inheritance）" class="headerlink" title="1. 类继承（Class Inheritance）"></a>1. 类继承（Class Inheritance）</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>类继承</strong> 是面向对象编程（OOP）中的一个核心概念，允许一个类（派生类）从另一个类（基类）继承属性和行为。通过继承，派生类可以重用基类的代码，并根据需要添加新的成员或重写现有成员。</p>
<h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedMember;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-代码示例"><a href="#1-3-代码示例" class="headerlink" title="1.3 代码示例"></a>1.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal eats.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        age = a; <span class="comment">// 访问受保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 继承自Animal</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// Dog特有</span></span><br><span class="line"></span><br><span class="line">    myDog.<span class="built_in">setAge</span>(<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog&#x27;s age: &quot;</span> &lt;&lt; myDog.<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-执行结果"><a href="#1-4-执行结果" class="headerlink" title="1.4 执行结果"></a>1.4 执行结果</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal eats.</span><br><span class="line">Dog barks.</span><br><span class="line">Dog<span class="symbol">&#x27;s</span> age: <span class="number">5</span></span><br></pre></td></tr></table></figure>





<h2 id="2-虚函数（Virtual-Functions）"><a href="#2-虚函数（Virtual-Functions）" class="headerlink" title="2. 虚函数（Virtual Functions）"></a>2. 虚函数（Virtual Functions）</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><strong>虚函数</strong> 允许派生类重新定义基类中的函数，以实现多态性。在运行时，根据对象的实际类型调用相应的函数版本。</p>
<h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(<span class="type">const</span> Shape&amp; shape)</span> </span>&#123;</span><br><span class="line">    shape.<span class="built_in">draw</span>(); <span class="comment">// 动态绑定，根据实际对象类型调用对应的draw()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c;</span><br><span class="line">    Square s;</span><br><span class="line">    Shape genericShape;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(c);           <span class="comment">// 输出: Drawing a circle.</span></span><br><span class="line">    <span class="built_in">render</span>(s);           <span class="comment">// 输出: Drawing a square.</span></span><br><span class="line">    <span class="built_in">render</span>(genericShape); <span class="comment">// 输出: Drawing a shape.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-执行结果"><a href="#2-4-执行结果" class="headerlink" title="2.4 执行结果"></a>2.4 执行结果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing <span class="selector-tag">a</span> circle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> square.</span><br><span class="line">Drawing <span class="selector-tag">a</span> shape.</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-纯虚类与抽象基类（Pure-Virtual-Classes-and-Abstract-Base-Classes）"><a href="#3-纯虚类与抽象基类（Pure-Virtual-Classes-and-Abstract-Base-Classes）" class="headerlink" title="3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）"></a>3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>纯虚函数</strong> 是在基类中声明但不提供实现的虚函数。包含至少一个纯虚函数的类称为 <strong>抽象基类</strong>（Abstract Base Class，ABC）。抽象基类不能被实例化，要求派生类必须实现所有纯虚函数才能被实例化。</p>
<h3 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printm</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-代码示例"><a href="#3-3-代码示例" class="headerlink" title="3.3 代码示例"></a>3.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vehicle</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car engine started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motorcycle</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Motorcycle engine started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Vehicle v; // 错误: 不能实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    Car car;</span><br><span class="line">    Motorcycle bike;</span><br><span class="line"></span><br><span class="line">    car.<span class="built_in">startEngine</span>();     <span class="comment">// 输出: Car engine started.</span></span><br><span class="line">    bike.<span class="built_in">startEngine</span>();    <span class="comment">// 输出: Motorcycle engine started.</span></span><br><span class="line"></span><br><span class="line">    Vehicle* v1 = &amp;car;</span><br><span class="line">    Vehicle* v2 = &amp;bike;</span><br><span class="line"></span><br><span class="line">    v1-&gt;<span class="built_in">startEngine</span>(); <span class="comment">// 动态绑定，输出: Car engine started.</span></span><br><span class="line">    v2-&gt;<span class="built_in">startEngine</span>(); <span class="comment">// 动态绑定，输出: Motorcycle engine started.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-执行结果"><a href="#3-4-执行结果" class="headerlink" title="3.4 执行结果"></a>3.4 执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car engine started.</span><br><span class="line">Motorcycle engine started.</span><br><span class="line">Car engine started.</span><br><span class="line">Motorcycle engine started.</span><br></pre></td></tr></table></figure>



<h2 id="4-继承后的访问控制（Access-Control-in-Inheritance）"><a href="#4-继承后的访问控制（Access-Control-in-Inheritance）" class="headerlink" title="4. 继承后的访问控制（Access Control in Inheritance）"></a>4. 继承后的访问控制（Access Control in Inheritance）</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>继承时的 <strong>访问控制</strong> 决定了基类成员在派生类中的可访问性。继承方式主要有三种：<code>public</code>、<code>protected</code> 和 <code>private</code>。它们影响继承成员的访问级别。</p>
<h3 id="4-2-语法与影响"><a href="#4-2-语法与影响" class="headerlink" title="4.2 语法与影响"></a>4.2 语法与影响</h3><ul>
<li><strong>公有继承（public inheritance）</strong>：<ul>
<li>基类的 <code>public</code> 成员在派生类中保持 <code>public</code>。</li>
<li>基类的 <code>protected</code> 成员在派生类中保持 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员在派生类中不可访问。</li>
</ul>
</li>
<li><strong>保护继承（protected inheritance）</strong>：<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>protected</code>。</li>
</ul>
</li>
<li><strong>私有继承（private inheritance）</strong>：<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>
</ul>
</li>
</ul>
<h3 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicMember;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedMember;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 可访问</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 可访问</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误：privateMember 在派生类中不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerived</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 转为 protected</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 转为 protected</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 转为 private</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 转为 private</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublicDerived pubDer;</span><br><span class="line">    pubDer.publicMember = <span class="number">10</span>; <span class="comment">// 可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProtectedDerived protDer;</span></span><br><span class="line">    <span class="comment">// protDer.publicMember = 10; // 错误：publicMember 在 ProtectedDerived 中为 protected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PrivateDerived privDer;</span></span><br><span class="line">    <span class="comment">// privDer.publicMember = 10; // 错误：publicMember 在 PrivateDerived 中为 private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-继承中类的作用域（Scope-of-Classes-in-Inheritance）"><a href="#5-继承中类的作用域（Scope-of-Classes-in-Inheritance）" class="headerlink" title="5. 继承中类的作用域（Scope of Classes in Inheritance）"></a>5. 继承中类的作用域（Scope of Classes in Inheritance）</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>在继承关系中，类的作用域决定了成员名称的可见性和访问方式。派生类可以访问基类的成员，根据访问控制的不同，还可能需要使用 <strong>作用域解析符</strong> 来访问隐藏的成员。</p>
<h3 id="5-2-代码示例"><a href="#5-2-代码示例" class="headerlink" title="5.2 代码示例"></a>5.2 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display from Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Show from Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 隐藏基类的 display</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display from Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callBaseDisplay</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">display</span>(); <span class="comment">// 使用作用域解析符调用基类的 display</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 重写 show， show 是虚函数可实现多态</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Show from Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>();          <span class="comment">// 调用 Derived::display</span></span><br><span class="line">    d.<span class="built_in">callBaseDisplay</span>();  <span class="comment">// 调用 Base::display</span></span><br><span class="line">    d.<span class="built_in">show</span>();             <span class="comment">// 调用 Derived::show</span></span><br><span class="line"></span><br><span class="line">    Base* bPtr = &amp;d;</span><br><span class="line">    bPtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Base::display，因为 display 不是虚函数</span></span><br><span class="line">    bPtr-&gt;<span class="built_in">show</span>();    <span class="comment">// show 是虚函数，调用 Derived::show；否则调用 Base::show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-执行结果"><a href="#5-3-执行结果" class="headerlink" title="5.3 执行结果"></a>5.3 执行结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Display <span class="keyword">from</span> Derived</span><br><span class="line">Display <span class="keyword">from</span> Base</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">from</span> Derived</span><br><span class="line">Display <span class="keyword">from</span> Base</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">from</span> Base <span class="operator">/</span><span class="operator">/</span> <span class="keyword">show</span> 是虚函数则输出: <span class="keyword">Show</span> <span class="keyword">from</span> Derived</span><br></pre></td></tr></table></figure>



<h2 id="6-构造函数与拷贝控制（Constructors-and-Copy-Control-in-Inheritance）"><a href="#6-构造函数与拷贝控制（Constructors-and-Copy-Control-in-Inheritance）" class="headerlink" title="6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）"></a>6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>在继承体系中，类的构造函数和拷贝控制函数（拷贝构造函数、拷贝赋值运算符、析构函数）的调用顺序和行为需要注意。基类的构造函数在派生类之前调用，析构函数则在派生类之后调用。</p>
<h3 id="6-2-构造函数的调用顺序"><a href="#6-2-构造函数的调用顺序" class="headerlink" title="6.2 构造函数的调用顺序"></a>6.2 构造函数的调用顺序</h3><ol>
<li>基类的 <strong>默认构造函数</strong> 首先被调用，除非派生类在初始化列表中显式调用其他基类构造函数。</li>
<li>派生类的成员按照声明顺序被构造。</li>
<li>派生类的构造函数体被执行。</li>
</ol>
<h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base parameterized constructor: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other) : <span class="built_in">name_</span>(other.name_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base copy assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            name_ = other.name_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base</span>(<span class="string">&quot;Default Derived&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value) : <span class="built_in">Base</span>(name), <span class="built_in">value_</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived parameterized constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; other) : <span class="built_in">Base</span>(other), <span class="built_in">value_</span>(other.value_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived copy assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            Base::<span class="keyword">operator</span>=(other);</span><br><span class="line">            value_ = other.value_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating d1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived d1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="string">&quot;Custom Derived&quot;</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCopy constructing d3 from d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived d3 = d2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning d1 = d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    d1 = d2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nExiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-执行结果"><a href="#6-4-执行结果" class="headerlink" title="6.4 执行结果"></a>6.4 执行结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Creating d1:</span><br><span class="line">Base parameterized constructor: <span class="keyword">Default</span> Derived</span><br><span class="line">Derived <span class="keyword">default</span> constructor</span><br><span class="line"></span><br><span class="line">Creating d2:</span><br><span class="line">Base parameterized constructor: Custom Derived</span><br><span class="line">Derived parameterized constructor: <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Copy</span> constructing d3 <span class="keyword">from</span> d2:</span><br><span class="line">Base <span class="keyword">copy</span> constructor</span><br><span class="line">Derived <span class="keyword">copy</span> constructor</span><br><span class="line"></span><br><span class="line">Assigning d1 <span class="operator">=</span> d2:</span><br><span class="line">Derived <span class="keyword">copy</span> assignment</span><br><span class="line">Base <span class="keyword">copy</span> assignment</span><br><span class="line"></span><br><span class="line">Exiting main...</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure>



<h2 id="7-容器与继承（Containers-and-Inheritance）"><a href="#7-容器与继承（Containers-and-Inheritance）" class="headerlink" title="7. 容器与继承（Containers and Inheritance）"></a>7. 容器与继承（Containers and Inheritance）</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p><strong>C++ 容器（如 <code>std::vector</code>、<code>std::list</code> 等）</strong> 通常存储对象的副本，而非指向对象的指针。因此，当与继承结合使用时，可能导致 <strong>切片（Object Slicing）</strong> 问题，即仅存储基类部分，丢失派生类特有的信息。为了实现多态性，推荐使用指针或智能指针存储对象。</p>
<h3 id="7-2-切片问题示例"><a href="#7-2-切片问题示例" class="headerlink" title="7.2 切片问题示例"></a>7.2 切片问题示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Base&gt; vec;</span><br><span class="line">    Derived d;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(d); <span class="comment">// 切片发生，派生类特有部分被丢弃</span></span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>].<span class="built_in">show</span>(); <span class="comment">// 输出: Base show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-使用指针避免切片"><a href="#7-3-使用指针避免切片" class="headerlink" title="7.3 使用指针避免切片"></a>7.3 使用指针避免切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived&gt;());</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>]-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-5-智能指针选择"><a href="#7-5-智能指针选择" class="headerlink" title="7.5 智能指针选择"></a>7.5 智能指针选择</h3><ul>
<li>**<code>std::unique_ptr</code>**：<ul>
<li>独占所有权，不可复制，只能移动。</li>
<li>适用于明确的单一所有权场景。</li>
</ul>
</li>
<li>**<code>std::shared_ptr</code>**：<ul>
<li>共享所有权，可以被多个指针共享和引用计数。</li>
<li>适用于需要多个所有者的场景。</li>
</ul>
</li>
</ul>
<h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="1-简单继承与成员访问"><a href="#1-简单继承与成员访问" class="headerlink" title="1. 简单继承与成员访问"></a>1. 简单继承与成员访问</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Person</code>，包含以下成员：</p>
<ul>
<li><p><strong>私有成员变量</strong>：<code>name</code>（字符串类型），<code>age</code>（整数类型）</p>
</li>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：接受姓名和年龄作为参数并初始化成员变量</li>
<li><code>displayInfo()</code>：打印姓名和年龄</li>
</ul>
</li>
</ul>
<p>然后，定义一个派生类 <code>Student</code>，继承自 <code>Person</code>，并添加以下内容：</p>
<ul>
<li><p><strong>私有成员变量</strong>：<code>studentID</code>（字符串类型）</p>
</li>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：接受姓名、年龄和学号作为参数，并调用基类构造函数初始化姓名和年龄</li>
<li>重写 <code>displayInfo()</code>：除了显示姓名和年龄外，还显示学号</li>
</ul>
</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建一个 <code>Student</code> 对象，并调用 <code>displayInfo()</code> 函数展示信息。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Alice</span></span><br><span class="line"><span class="attr">Age:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">Student ID:</span> <span class="string">S12345</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="2-虚函数重写与多态性"><a href="#2-虚函数重写与多态性" class="headerlink" title="2. 虚函数重写与多态性"></a>2. 虚函数重写与多态性</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Shape</code>，包含以下内容：</p>
<ul>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>虚函数 <code>draw()</code>：在基类中实现，输出 “Drawing a generic shape.”</li>
</ul>
</li>
</ul>
<p>然后，定义两个派生类 <code>Circle</code> 和 <code>Rectangle</code>，分别重写 <code>draw()</code> 函数，实现各自的输出：</p>
<ul>
<li><code>Circle</code> 的 <code>draw()</code> 输出：”Drawing a circle.”</li>
<li><code>Rectangle</code> 的 <code>draw()</code> 输出：”Drawing a rectangle.”</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建一个 <code>Shape</code> 类型的指针数组，包含不同类型的 <code>Shape</code> 对象（<code>Circle</code> 和 <code>Rectangle</code>）。</li>
<li>遍历数组，调用每个对象的 <code>draw()</code> 函数，验证多态性的实现。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing <span class="selector-tag">a</span> circle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> rectangle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> generic shape.</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3-函数重载与隐藏"><a href="#3-函数重载与隐藏" class="headerlink" title="3. 函数重载与隐藏"></a>3. 函数重载与隐藏</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Calculator</code>，包含以下公共成员函数：</p>
<ul>
<li><code>int add(int a, int b)</code>：返回两个整数的和</li>
<li><code>double add(double a, double b)</code>：返回两个浮点数的和</li>
</ul>
<p>然后，定义一个派生类 <code>AdvancedCalculator</code>，继承自 <code>Calculator</code>，并添加以下成员函数：</p>
<ul>
<li><code>int add(int a, int b, int c)</code>：返回三个整数的和</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure>

<p>函数中，创建一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdvancedCalculator</span><br></pre></td></tr></table></figure>

<p>对象，分别调用以下函数，并观察输出：</p>
<ul>
<li><code>add(2, 3)</code></li>
<li><code>add(2.5, 3.5)</code></li>
<li><code>add(1, 2, 3)</code></li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>观察派生类中新增的 <code>add</code> 函数是否影响基类中的同名函数。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-抽象类与纯虚函数"><a href="#4-抽象类与纯虚函数" class="headerlink" title="4. 抽象类与纯虚函数"></a>4. 抽象类与纯虚函数</h3><p><strong>题目：</strong></p>
<p>定义一个抽象基类 <code>Animal</code>，包含以下内容：</p>
<ul>
<li><p>公共纯虚函数</p>
<p>：</p>
<ul>
<li><code>void makeSound() const</code>：纯虚函数，用于发出动物的叫声</li>
</ul>
</li>
</ul>
<p>然后，定义两个派生类 <code>Dog</code> 和 <code>Cat</code>，分别实现 <code>makeSound()</code> 函数：</p>
<ul>
<li><code>Dog</code> 的 <code>makeSound()</code> 输出：”Woof!”</li>
<li><code>Cat</code> 的 <code>makeSound()</code> 输出：”Meow!”</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建 <code>Dog</code> 和 <code>Cat</code> 对象的基类指针，并调用 <code>makeSound()</code> 函数，展示多态性。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Woof!</span><br><span class="line">Meow!</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-构造函数与析构函数的继承"><a href="#5-构造函数与析构函数的继承" class="headerlink" title="5. 构造函数与析构函数的继承"></a>5. 构造函数与析构函数的继承</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Vehicle</code>，包含以下内容：</p>
<ul>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：输出 “Vehicle constructed.”</li>
<li>析构函数：输出 “Vehicle destructed.”</li>
</ul>
</li>
</ul>
<p>然后，定义一个派生类 <code>Car</code>，继承自 <code>Vehicle</code>，并添加以下内容：</p>
<ul>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：输出 “Car constructed.”</li>
<li>析构函数：输出 “Car destructed.”</li>
</ul>
</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建一个 <code>Car</code> 对象，并观察构造和析构的调用顺序。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vehicle constructed.</span><br><span class="line">Car constructed.</span><br><span class="line">Car destructed.</span><br><span class="line">Vehicle destructed.</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/09/cppbase19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/09/cppbase19/" itemprop="url">零基础C++(19) 类基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-09T20:58:32+08:00">
                2024-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-类与对象简介"><a href="#1-类与对象简介" class="headerlink" title="1. 类与对象简介"></a>1. 类与对象简介</h2><h3 id="1-1-什么是类和对象"><a href="#1-1-什么是类和对象" class="headerlink" title="1.1 什么是类和对象"></a>1.1 什么是类和对象</h3><ul>
<li><strong>类（Class）</strong>是C++中创建用户自定义类型的一种方式，它将数据（成员变量）和操作数据的函数（成员函数）封装在一起。</li>
<li><strong>对象（Object）</strong>是类的实例化，拥有类定义的所有属性和行为。</li>
<li><strong>类</strong>更像是汽车图纸，<strong>对象</strong>更像是造出来的汽车。</li>
</ul>
<h3 id="1-2-类的作用"><a href="#1-2-类的作用" class="headerlink" title="1.2 类的作用"></a>1.2 类的作用</h3><ul>
<li><strong>封装（Encapsulation）</strong>：将数据和操作数据的代码绑定在一起，保护数据不被外界直接访问。</li>
<li><strong>抽象（Abstraction）</strong>：通过类定义抽象出具有共同特性的对象，提高代码的可重用性和可维护性。</li>
<li><strong>继承（Inheritance）和多态（Polymorphism）</strong>：实现代码的复用与动态绑定。</li>
</ul>
<hr>
<h2 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 受保护成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>创建一个表示学生的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-成员变量与成员函数"><a href="#3-成员变量与成员函数" class="headerlink" title="3. 成员变量与成员函数"></a>3. 成员变量与成员函数</h2><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><ul>
<li><strong>成员变量（Member Variables）</strong>：用于存储对象的状态信息。</li>
<li><strong>命名约定</strong>：常用下划线结尾（例如 <code>name_</code>）表示成员变量，避免与局部变量混淆。</li>
</ul>
<h3 id="3-2-成员函数"><a href="#3-2-成员函数" class="headerlink" title="3.2 成员函数"></a>3.2 成员函数</h3><ul>
<li><strong>成员函数（Member Functions）</strong>：定义对象的行为，可以访问和修改成员变量。</li>
<li><strong>常成员函数（Const Member Functions）</strong>：保证函数不会修改对象的状态。</li>
</ul>
<h3 id="3-3-示例实现"><a href="#3-3-示例实现" class="headerlink" title="3.3 示例实现"></a>3.3 示例实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age)</span><br><span class="line">    : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    name_ = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">0</span>)</span><br><span class="line">        age_ = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4. 访问控制"></a>4. 访问控制</h2><h3 id="4-1-访问修饰符"><a href="#4-1-访问修饰符" class="headerlink" title="4.1 访问修饰符"></a>4.1 访问修饰符</h3><ul>
<li><strong>public</strong>：公有成员，可以被所有代码访问。</li>
<li><strong>private</strong>：私有成员，仅能被类的成员函数和友元访问。</li>
<li><strong>protected</strong>：受保护成员，仅能被类的成员函数、友元和派生类访问。</li>
</ul>
<h3 id="4-2-例子"><a href="#4-2-例子" class="headerlink" title="4.2 例子"></a>4.2 例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="5-构造函数与析构函数"><a href="#5-构造函数与析构函数" class="headerlink" title="5. 构造函数与析构函数"></a>5. 构造函数与析构函数</h2><h3 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h3><ul>
<li><strong>默认构造函数</strong>：没有参数的构造函数。</li>
<li><strong>参数化构造函数</strong>：接受参数以初始化对象。</li>
<li><strong>拷贝构造函数</strong>：用一个对象初始化另一个对象。</li>
<li><strong>移动构造函数（C++11）</strong>：从临时对象“移动”资源。</li>
</ul>
<h3 id="5-2-析构函数"><a href="#5-2-析构函数" class="headerlink" title="5.2 析构函数"></a>5.2 析构函数</h3><ul>
<li><strong>析构函数（Destructor）</strong>：在对象生命周期结束时调用，用于释放资源。</li>
</ul>
<h3 id="5-3-示例"><a href="#5-3-示例" class="headerlink" title="5.3 示例"></a>5.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>() : <span class="built_in">data_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> data) : <span class="built_in">data_</span>(data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called with data = &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other) : <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(Example&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.data_ = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for data = &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-4-使用示例"><a href="#5-4-使用示例" class="headerlink" title="5.4 使用示例"></a>5.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example ex1;               <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">Example <span class="title">ex2</span><span class="params">(<span class="number">42</span>)</span></span>;           <span class="comment">// 调用参数化构造函数</span></span><br><span class="line">    Example ex3 = ex2;         <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example ex4 = std::<span class="built_in">move</span>(ex2); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Default <span class="keyword">constructor</span> called.</span><br><span class="line">Parameterized <span class="keyword">constructor</span> called with <span class="keyword">data</span> = <span class="number">42.</span></span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">0.</span></span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">42.</span></span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">42.</span></span><br></pre></td></tr></table></figure>



<h3 id="5-5-拷贝构造是否必须实现"><a href="#5-5-拷贝构造是否必须实现" class="headerlink" title="5.5 拷贝构造是否必须实现"></a>5.5 拷贝构造是否必须实现</h3><p>当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。比如一个类A中有成员变量<code>std::thread</code>，<code>std::thread</code>没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。</p>
<p>同样析构也要显示编写，等待线程完成。</p>
<p>除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果</p>
<p><img src="https://cdn.llfc.club/1731294878994.jpg" alt="https://cdn.llfc.club/1731294878994.jpg"></p>
<p><img src="https://cdn.llfc.club/1731295328032.jpg-llfc" alt="https://cdn.llfc.club/1731295328032.jpg-llfc"></p>
<h3 id="5-6-构造顺序和析构顺序"><a href="#5-6-构造顺序和析构顺序" class="headerlink" title="5.6 构造顺序和析构顺序"></a>5.6 构造顺序和析构顺序</h3><p>类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？</p>
<p>如果析构的时候是A先析构还是B先析构呢？</p>
<h3 id="5-7-类默认构造是否必须实现"><a href="#5-7-类默认构造是否必须实现" class="headerlink" title="5.7 类默认构造是否必须实现"></a>5.7 类默认构造是否必须实现</h3><p>如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。</p>
<p>系统提供的合成的默认构造函数不会对成员做初始化操作。</p>
<h3 id="5-8-this-指针的特性和用途"><a href="#5-8-this-指针的特性和用途" class="headerlink" title="5.8 this 指针的特性和用途"></a>5.8 <code>this</code> 指针的特性和用途</h3><ol>
<li><p><strong>指向当前对象</strong>：</p>
<ul>
<li><code>this</code> 指针是一个隐式参数，指向调用成员函数的对象。通过 <code>this</code>，你可以访问当前对象的属性和方法。</li>
</ul>
</li>
<li><p><strong>区分成员变量和参数</strong>：</p>
<ul>
<li><p>在构造函数或成员函数中，参数名和成员变量可能同名。使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure>

<p>可以明确指代成员变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>返回当前对象</strong>：</p>
<ul>
<li>```<br>this<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以用于返回当前对象的引用，以支持链式调用。例如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    MyClass&amp; setValue(int value) &#123;</span><br><span class="line">        this-&gt;value = value;</span><br><span class="line">        return *this; // 返回当前对象的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.setValue(10).setValue(20); // 链式调用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>在 const 成员函数中的使用</strong>：</p>
<ul>
<li>在 <code>const</code> 成员函数中，<code>this</code> 的类型为 <code>const MyClass*</code>，这意味着你不能通过 <code>this</code> 修改成员变量。这有助于确保对象的状态不被改变。</li>
</ul>
</li>
<li><p><strong>在静态成员函数中的不可用性</strong>：</p>
<ul>
<li>静态成员函数没有 <code>this</code> 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。</li>
</ul>
</li>
</ol>
<p><strong>示例代码</strong></p>
<p>以下是一个简单的示例，展示了 <code>this</code> 指针的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl; <span class="comment">// 使用 this 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">printValue</span>(); <span class="comment">// 链式调用，输出: Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-9-delete和default"><a href="#5-9-delete和default" class="headerlink" title="5.9 delete和default"></a>5.9 delete和default</h3><p><code>C++11</code>用法：</p>
<p>delete可以删除指定的构造函数。</p>
<p>default可以指定某个构造函数为系统默认合成。</p>
<h2 id="6-拷贝控制"><a href="#6-拷贝控制" class="headerlink" title="6. 拷贝控制"></a>6. 拷贝控制</h2><p><strong>拷贝构造函数与拷贝赋值运算符</strong></p>
<h3 id="6-1-拷贝构造函数"><a href="#6-1-拷贝构造函数" class="headerlink" title="6.1 拷贝构造函数"></a>6.1 拷贝构造函数</h3><ul>
<li><strong>定义</strong>：用于创建一个新对象，并复制现有对象的成员。</li>
<li><strong>语法</strong>：<code>ClassName(const ClassName&amp; other);</code></li>
</ul>
<h3 id="6-2-拷贝赋值运算符"><a href="#6-2-拷贝赋值运算符" class="headerlink" title="6.2 拷贝赋值运算符"></a>6.2 拷贝赋值运算符</h3><ul>
<li><strong>定义</strong>：用于将一个已有对象的值赋给另一个已有对象。</li>
<li><strong>语法</strong>：<code>ClassName&amp; operator=(const ClassName&amp; other);</code></li>
</ul>
<h3 id="6-3-示例"><a href="#6-3-示例" class="headerlink" title="6.3 示例"></a>6.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            size_ = std::<span class="built_in">strlen</span>(str);</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">            std::<span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size_ = <span class="number">0</span>;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) : <span class="built_in">size_</span>(other.size_) &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自赋值检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_; <span class="comment">// 释放现有资源</span></span><br><span class="line"></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    std::<span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-使用示例"><a href="#6-4-使用示例" class="headerlink" title="6.4 使用示例"></a>6.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = s1;        <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    MyString s3;</span><br><span class="line">    s3 = s1;                  <span class="comment">// 调用拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s3.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constructor called.</span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Constructor called.</span><br><span class="line">Copy assignment <span class="keyword">operator</span> called.</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure>



<h2 id="7-移动语义"><a href="#7-移动语义" class="headerlink" title="7. 移动语义"></a>7. 移动语义</h2><h3 id="7-1-什么是移动语义"><a href="#7-1-什么是移动语义" class="headerlink" title="7.1 什么是移动语义"></a>7.1 什么是移动语义</h3><ul>
<li><strong>移动语义（Move Semantics）</strong>：允许资源的所有权从一个对象转移到另一个对象，避免不必要的拷贝，提高性能。</li>
</ul>
<h3 id="7-2-移动构造函数与移动赋值运算符"><a href="#7-2-移动构造函数与移动赋值运算符" class="headerlink" title="7.2 移动构造函数与移动赋值运算符"></a>7.2 移动构造函数与移动赋值运算符</h3><ul>
<li><strong>移动构造函数</strong>：<code>ClassName(ClassName&amp;&amp; other) noexcept;</code></li>
<li><strong>移动赋值运算符</strong>：<code>ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept;</code></li>
</ul>
<h3 id="7-3-示例"><a href="#7-3-示例" class="headerlink" title="7.3 示例"></a>7.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(<span class="type">const</span> MoveExample&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(MoveExample&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MoveExample&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MoveExample&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MoveExample&amp; <span class="keyword">operator</span>=(MoveExample&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MoveExample</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-使用示例"><a href="#7-4-使用示例" class="headerlink" title="7.4 使用示例"></a>7.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MoveExample <span class="title">ex1</span><span class="params">(<span class="number">100</span>)</span></span>;                 <span class="comment">// Constructor</span></span><br><span class="line">    MoveExample ex2 = ex1;                <span class="comment">// Copy Constructor</span></span><br><span class="line">    MoveExample ex3 = <span class="built_in">MoveExample</span>(<span class="number">200</span>);   <span class="comment">// Move Constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MoveExample <span class="title">ex4</span><span class="params">(<span class="number">300</span>)</span></span>;</span><br><span class="line">    ex4 = ex1;                             <span class="comment">// Copy Assignment</span></span><br><span class="line">    ex4 = <span class="built_in">MoveExample</span>(<span class="number">400</span>);                <span class="comment">// Move Assignment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Constructor called.</span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Constructor called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Destructor called.</span><br><span class="line">Constructor called.</span><br><span class="line">Copy assignment <span class="keyword">operator</span> called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Move assignment <span class="keyword">operator</span> called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="8-类的友元"><a href="#8-类的友元" class="headerlink" title="8. 类的友元"></a>8. 类的友元</h2><h3 id="8-1-什么是友元"><a href="#8-1-什么是友元" class="headerlink" title="8.1 什么是友元"></a>8.1 什么是友元</h3><ul>
<li><strong>友元（Friend）</strong>：可以访问类的私有和保护成员的非成员函数或另一个类。</li>
</ul>
<h3 id="8-2-类型"><a href="#8-2-类型" class="headerlink" title="8.2 类型"></a>8.2 类型</h3><ul>
<li><strong>友元函数</strong>：单个函数可以被声明为友元。</li>
<li><strong>友元类</strong>：整个类可以被声明为友元。</li>
</ul>
<h3 id="8-3-使用示例"><a href="#8-3-使用示例" class="headerlink" title="8.3 使用示例"></a>8.3 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> length, <span class="type">double</span> width, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">length_</span>(length), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span> <span class="title">calculateVolume</span><span class="params">(<span class="type">const</span> Box&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length_;</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">(<span class="type">const</span> Box&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.length_ * b.width_ * b.height_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-4-使用友元类"><a href="#8-4-使用友元类" class="headerlink" title="8.4 使用友元类"></a>8.4 使用友元类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height) : <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AreaCalculator</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">const</span> Rectangle&amp; rect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rect.width_ * rect.height_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="9-运算符重载"><a href="#9-运算符重载" class="headerlink" title="9. 运算符重载"></a>9. 运算符重载</h2><h3 id="9-1-什么是运算符重载"><a href="#9-1-什么是运算符重载" class="headerlink" title="9.1 什么是运算符重载"></a>9.1 什么是运算符重载</h3><ul>
<li><strong>运算符重载（Operator Overloading）</strong>：允许对自定义类型使用C++运算符，如 <code>+</code>, <code>-</code>, <code>&lt;&lt;</code> 等。</li>
</ul>
<h3 id="9-2-重载运算符的规则"><a href="#9-2-重载运算符的规则" class="headerlink" title="9.2 重载运算符的规则"></a>9.2 重载运算符的规则</h3><ul>
<li>只能对已有运算符进行重载，不能创建新运算符。</li>
<li>至少有一个操作数必须是用户定义的类型。</li>
<li>不能改变运算符的优先级或结合性。</li>
</ul>
<h3 id="9-3-示例：重载-运算符"><a href="#9-3-示例：重载-运算符" class="headerlink" title="9.3 示例：重载 + 运算符"></a>9.3 示例：重载 <code>+</code> 运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数重载 +</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x_ + other.x_, y_ + other.y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x_ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y_ &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用友元函数重载 +</span></span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x_ - b.x_, a.y_ - b.y_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1.5</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出： (4.5, 6.5)</span></span><br><span class="line"></span><br><span class="line">    Point p4 = p2 - p1;</span><br><span class="line">    p4.<span class="built_in">print</span>(); <span class="comment">// 输出： (1.5, 1.5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-4-示例：重载-lt-lt-运算符（输出流）"><a href="#9-4-示例：重载-lt-lt-运算符（输出流）" class="headerlink" title="9.4 示例：重载 &lt;&lt; 运算符（输出流）"></a>9.4 示例：重载 <code>&lt;&lt;</code> 运算符（输出流）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; name, <span class="type">double</span> salary)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">salary_</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数以重载 &lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Employee&amp; emp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">double</span> salary_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的 &lt;&lt;</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Employee&amp; emp) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Employee Name: &quot;</span> &lt;&lt; emp.name_ &lt;&lt; <span class="string">&quot;, Salary: $&quot;</span> &lt;&lt; emp.salary_;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">emp</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">75000</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; emp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Employee Name:</span> <span class="string">John</span> <span class="string">Doe,</span> <span class="attr">Salary:</span> <span class="string">$75000</span></span><br></pre></td></tr></table></figure>



<h2 id="10-练习示例"><a href="#10-练习示例" class="headerlink" title="10. 练习示例"></a>10. 练习示例</h2><h3 id="项目：实现自定义MyString类"><a href="#项目：实现自定义MyString类" class="headerlink" title="项目：实现自定义MyString类"></a>项目：实现自定义<code>MyString</code>类</h3><p><strong>目标</strong>：创建一个简单的<code>MyString</code>类，支持拷贝构造，默认构造，有参构造，支持输出和比较等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;  <span class="comment">// 动态分配的字符数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]; <span class="comment">// +1 for the null terminator</span></span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.data) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data; <span class="comment">// 释放原有内存</span></span><br><span class="line">            <span class="keyword">if</span> (other.data) &#123;</span><br><span class="line">                data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较运算符重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span> &amp;&amp; other.data == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span> || other.data == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(data, other.data) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyString&amp; myStr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myStr.data) &#123;</span><br><span class="line">            os &lt;&lt; myStr.data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    MyString str2 = str1; <span class="comment">// 拷贝构造</span></span><br><span class="line">    MyString str3;</span><br><span class="line"></span><br><span class="line">    str3 = str1; <span class="comment">// 赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3: &quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><strong>私有成员</strong>：<ul>
<li><code>char* data</code>：指向动态分配的字符数组，用于存储字符串。</li>
</ul>
</li>
<li><strong>构造函数</strong>：<ul>
<li><strong>默认构造函数</strong>：初始化 <code>data</code> 为 <code>nullptr</code>。</li>
<li><strong>有参构造函数</strong>：接收一个 <code>const char*</code> 类型的字符串，动态分配内存并复制字符串内容。</li>
<li><strong>拷贝构造函数</strong>：复制另一个 <code>MyString</code> 对象的内容，确保深拷贝。</li>
</ul>
</li>
<li><strong>赋值运算符重载</strong>：支持将一个 <code>MyString</code> 对象赋值给另一个，确保释放原有内存并进行深拷贝。</li>
<li><strong>比较运算符重载</strong>：支持比较两个 <code>MyString</code> 对象是否相等。</li>
<li><strong>输出运算符重载</strong>：支持直接使用 <code>std::cout</code> 输出 <code>MyString</code> 对象。</li>
<li><strong>析构函数</strong>：释放动态分配的内存，防止内存泄漏。</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在 <code>main</code> 函数中，创建了几个 <code>MyString</code> 对象，演示了拷贝构造、赋值和比较的用法。</p>
<h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p>关于C++的视频教程可参考我的主页</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">C++教程视频</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/03/cppbase18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/03/cppbase18/" itemprop="url">零基础C++(18) 函数用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-03T11:41:04+08:00">
                2024-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-函数简介"><a href="#1-函数简介" class="headerlink" title="1. 函数简介"></a>1. 函数简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数是执行特定任务的代码块，可以被程序中的多个地方调用。使用函数可以增加代码的可重用性、可读性和可维护性。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><strong>封装</strong>：将特定功能封装在函数中，便于管理和修改。</li>
<li><strong>复用</strong>：同一段功能代码可以在程序中多次调用，减少代码重复。</li>
<li><strong>结构化</strong>：通过函数组织代码，提高程序的结构清晰度。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 + 3 = 8</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-函数的声明与定义"><a href="#2-函数的声明与定义" class="headerlink" title="2. 函数的声明与定义"></a>2. 函数的声明与定义</h2><h3 id="函数声明（Function-Declaration）"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h3><p>告诉编译器函数的名称、返回类型和参数类型，但不包含函数体。通常放在头文件中或在使用函数前进行声明。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure>



<h3 id="函数定义（Function-Definition）"><a href="#函数定义（Function-Definition）" class="headerlink" title="函数定义（Function Definition）"></a>函数定义（Function Definition）</h3><p>提供函数的具体实现，包括函数体。函数定义可以在源文件中或与声明一起在头文件中出现（推荐仅声明在头文件中）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 函数定义</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数分离编译"><a href="#函数分离编译" class="headerlink" title="函数分离编译"></a>函数分离编译</h3><ul>
<li><strong>声明</strong>：放在头文件（如 <code>multiply.h</code>）。</li>
<li><strong>定义</strong>：放在源文件（如 <code>multiply.cpp</code>）。</li>
</ul>
<p><strong>multiply.h</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MULTIPLY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIPLY_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><strong>multiply.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiply.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>main.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiply.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multiply</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4 * 6 = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编译命令</strong>（假设使用g++）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp multiply.cpp -o program</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 * 6 = 24</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-函数调用"><a href="#3-函数调用" class="headerlink" title="3. 函数调用"></a>3. 函数调用</h2><h3 id="基本调用"><a href="#基本调用" class="headerlink" title="基本调用"></a>基本调用</h3><p>通过函数名称和必要的参数来调用函数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>



<h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p>同一函数可以在程序中被调用多次。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-参数传递机制"><a href="#4-参数传递机制" class="headerlink" title="4. 参数传递机制"></a>4. 参数传递机制</h2><p>C++中函数参数的传递方式主要有以下三种：</p>
<ol>
<li><strong>传值调用（Pass by Value）</strong></li>
<li><strong>传引用调用（Pass by Reference）</strong></li>
<li><strong>传指针调用（Pass by Pointer）</strong></li>
</ol>
<h3 id="传值调用"><a href="#传值调用" class="headerlink" title="传值调用"></a>传值调用</h3><p><strong>定义</strong>：函数接收参数的副本，函数内对参数的修改不会影响原始数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 只修改副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 50</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>changeValue</code>函数修改的是<code>num</code>的副本，原始变量<code>value</code>保持不变。</p>
<h3 id="传引用调用"><a href="#传引用调用" class="headerlink" title="传引用调用"></a>传引用调用</h3><p><strong>定义</strong>：函数接收参数的引用，函数内对参数的修改会影响原始数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 修改原始数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 100</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>changeValue</code>函数通过引用修改了原始变量<code>value</code>的值。</p>
<h3 id="传指针调用"><a href="#传指针调用" class="headerlink" title="传指针调用"></a>传指针调用</h3><p><strong>定义</strong>：函数接收指向参数的指针，函数内通过指针可以修改原始数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>; <span class="comment">// 修改原始数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> *num)</span> </span>&#123;</span><br><span class="line">    *num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(&amp;value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 100</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>changeValue</code>函数通过指针修改了原始变量<code>value</code>的值。</p>
<h3 id="选择合适的传递方式"><a href="#选择合适的传递方式" class="headerlink" title="选择合适的传递方式"></a>选择合适的传递方式</h3><ul>
<li><strong>传值调用</strong>：适用于不需要修改原始数据且数据量较小的情况。</li>
<li><strong>传引用调用</strong>：适用于需要修改原始数据或传递大型数据结构以提高效率。</li>
<li><strong>传指针调用</strong>：类似传引用调用，但更灵活，可用于传递<code>nullptr</code>或指向动态分配的内存。</li>
</ul>
<hr>
<h2 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h2><p>函数可以通过<code>return</code>语句将结果返回给调用者。返回值的类型可以是基本数据类型、引用、指针、对象等。</p>
<h3 id="5-1-返回基本数据类型"><a href="#5-1-返回基本数据类型" class="headerlink" title="5.1 返回基本数据类型"></a>5.1 返回基本数据类型</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Sum: 7</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-返回引用"><a href="#5-2-返回引用" class="headerlink" title="5.2 返回引用"></a>5.2 返回引用</h3><p><strong>注意</strong>：返回引用需要确保引用的对象在返回后依然有效（避免悬垂引用）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;max = <span class="built_in">getMax</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max: &quot;</span> &lt;&lt; max &lt;&lt; std::endl;</span><br><span class="line">    max = <span class="number">30</span>; <span class="comment">// 修改引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Max:</span> <span class="number">20</span></span><br><span class="line"><span class="string">After</span> <span class="string">modification,</span> <span class="attr">y:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>getMax</code>函数返回较大的变量的引用，修改<code>max</code>实际上修改了<code>y</code>。</p>
<h3 id="5-3-返回指针"><a href="#5-3-返回指针" class="headerlink" title="5.3 返回指针"></a>5.3 返回指针</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">allocateArray</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        arr[i] = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>* myArray = <span class="built_in">allocateArray</span>(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        std::cout &lt;&lt; myArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] myArray; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 4 6 8 </span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>allocateArray</code>函数动态分配一个数组并返回指向数组的指针。调用者需负责释放内存。</p>
<h3 id="5-4-返回对象"><a href="#5-4-返回对象" class="headerlink" title="5.4 返回对象"></a>5.4 返回对象</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">createPerson</span><span class="params">(std::string name, <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(name, age)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="built_in">createPerson</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Alice,</span> <span class="attr">Age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>createPerson</code>函数返回一个<code>Person</code>对象。现代编译器通过返回值优化（RVO）减少对象拷贝，提高效率。</p>
<hr>
<h2 id="6-函数重载"><a href="#6-函数重载" class="headerlink" title="6. 函数重载"></a>6. 函数重载</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>函数重载允许在同一个作用域内定义多个名称相同但参数列表不同的函数。编译器通过参数列表的不同来区分调用哪个函数。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>函数名相同。</li>
<li>参数列表（类型、数量或顺序）不同。</li>
<li>返回类型不参与重载的区分。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：不同参数数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：不同参数类型</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2, 3) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2, 3, 4) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2.5, 3.5) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">5</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) = <span class="number">9</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) = <span class="number">6</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>仅返回类型不同的重载是非法的。</li>
<li>默认参数可能会与重载产生冲突，使用时需谨慎。</li>
</ul>
<p><strong>非法示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冲突重载，仅返回类型不同</span></span><br><span class="line"><span class="comment">// 会导致编译错误</span></span><br><span class="line"><span class="comment">// double add(int a, int b);</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="7-默认参数"><a href="#7-默认参数" class="headerlink" title="7. 默认参数"></a>7. 默认参数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>函数参数可以指定默认值，调用函数时可以省略这些参数，默认值将被使用。</p>
<h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><ul>
<li>默认参数从右到左设置，不能部分设置。</li>
<li>函数声明和定义中默认参数只需在声明中指定。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明时指定默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(std::string name, <span class="type">int</span> age = <span class="number">18</span>, std::string city = <span class="string">&quot;Unknown&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>, <span class="string">&quot;New York&quot;</span>); <span class="comment">// 全部参数传递</span></span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>);         <span class="comment">// 省略city</span></span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Diana&quot;</span>);               <span class="comment">// 省略age和city</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(std::string name, <span class="type">int</span> age, std::string city)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, City: &quot;</span> &lt;&lt; city &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Bob,</span> <span class="attr">Age:</span> <span class="number">25</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">New</span> <span class="string">York</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">Charlie,</span> <span class="attr">Age:</span> <span class="number">30</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">Unknown</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">Diana,</span> <span class="attr">Age:</span> <span class="number">18</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">Unknown</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>默认参数必须从右端开始，不能跳过中间参数。</li>
<li>如果同时使用默认参数和重载，可能会产生歧义，需谨慎设计。</li>
</ul>
<hr>
<h2 id="8-内联函数"><a href="#8-内联函数" class="headerlink" title="8. 内联函数"></a>8. 内联函数</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>内联函数通过在函数前加<code>inline</code>关键字，建议编译器将函数代码嵌入到调用处，减少函数调用的开销。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于函数体积小、调用频繁的函数，如访问器（getter）和修改器（setter）等。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square of 5: &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Square of <span class="number">5</span>: <span class="number">25</span></span><br></pre></td></tr></table></figure>



<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少函数调用的开销（如栈操作）。</li>
<li>可能提高程序性能。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>使得代码体积增大，可能影响缓存性能。</li>
<li>编译器可能忽略内联请求，特别是对于复杂函数。</li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>编译器对<code>inline</code>关键字的处理是建议性质，最终是否内联由编译器决定。</li>
<li>过度使用内联函数可能导致代码膨胀。</li>
</ul>
<hr>
<h2 id="9-递归函数"><a href="#9-递归函数" class="headerlink" title="9. 递归函数"></a>9. 递归函数</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>递归函数是指在函数体内调用自身的函数。递归通常用于解决可以分解为相似子问题的问题，如阶乘、斐波那契数列、树的遍历等。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>递归函数通常包含两个部分：</p>
<ol>
<li><strong>基准情形（Base Case）</strong>：直接返回结果，避免无限递归。</li>
<li><strong>递归情形（Recursive Case）</strong>：将问题分解为更小的子问题并调用自身。</li>
</ol>
<h3 id="示例：计算阶乘"><a href="#示例：计算阶乘" class="headerlink" title="示例：计算阶乘"></a>示例：计算阶乘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误情况</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基准情形</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); <span class="comment">// 递归情形</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">factorial</span>(number);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid input!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br></pre></td></tr></table></figure>



<h3 id="示例：斐波那契数列"><a href="#示例：斐波那契数列" class="headerlink" title="示例：斐波那契数列"></a>示例：斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> term = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(term) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10) = 55</span><br></pre></td></tr></table></figure>



<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>基准情形</strong>：必须正确设置，避免无限递归导致栈溢出（Stack Overflow）。</li>
<li><strong>效率问题</strong>：一些递归实现可能效率低下（如斐波那契数列），可以通过“记忆化”或改用迭代方法优化。</li>
<li><strong>堆栈深度</strong>：递归深度过大可能导致栈溢出，需避免深度递归。</li>
</ul>
<h3 id="递归优化：尾递归"><a href="#递归优化：尾递归" class="headerlink" title="递归优化：尾递归"></a>递归优化：尾递归</h3><p>尾递归是指递归调用在函数的最后一步，可以被编译器优化为循环，减少堆栈消耗。</p>
<p><strong>示例：尾递归阶乘</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于尾递归</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorialHelper</span><span class="params">(<span class="type">int</span> n, <span class="type">long</span> <span class="type">long</span> accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorialHelper</span>(n - <span class="number">1</span>, n * accumulator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorialHelper</span>(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(number) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>factorialHelper</code>函数的递归调用是函数的最后一步，编译器可以将其优化为迭代，减少堆栈消耗。</p>
<hr>
<h2 id="10-Lambda表达式"><a href="#10-Lambda表达式" class="headerlink" title="10. Lambda表达式"></a>10. Lambda表达式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>Lambda表达式是C++11引入的匿名函数，便于在需要函数对象的地方快速定义和使用函数。它允许定义内联的、小型的可调用对象，无需单独定义函数。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ capture_list ] ( parameter_list ) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式打印每个元素</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式计算总和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> x) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line"><span class="section">Sum: 15</span></span><br></pre></td></tr></table></figure>



<h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ol>
<li><strong>捕获列表（Capture List）</strong>：指定如何访问外部变量。<ul>
<li><code>[ ]</code>：不捕获任何外部变量。</li>
<li><code>[&amp;]</code>：按引用捕获所有外部变量。</li>
<li><code>[=]</code>：按值捕获所有外部变量。</li>
<li><code>[x, &amp;y]</code>：按值捕获<code>x</code>，按引用捕获<code>y</code>。</li>
</ul>
</li>
<li><strong>参数列表（Parameter List）</strong>：类似普通函数的参数列表，可以省略类型（C++14及以上支持自动类型推断）。</li>
<li><strong>返回类型（Return Type）</strong>：可指定返回类型，也可省略，编译器自动推断。</li>
<li><strong>函数体（Function Body）</strong>：Lambda的具体实现。</li>
</ol>
<h3 id="高级示例：捕获并排序"><a href="#高级示例：捕获并排序" class="headerlink" title="高级示例：捕获并排序"></a>高级示例：捕获并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按降序排序，使用Lambda表达式</span></span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted data: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data)</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorted <span class="keyword">data</span>: <span class="number">9</span> <span class="number">6</span> <span class="number">5</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>



<h3 id="使用Lambda表达式与标准库"><a href="#使用Lambda表达式与标准库" class="headerlink" title="使用Lambda表达式与标准库"></a>使用Lambda表达式与标准库</h3><p>C++标准库中的许多算法（如<code>std::for_each</code>、<code>std::sort</code>、<code>std::transform</code>等）常用Lambda表达式作为参数，以实现自定义的操作。</p>
<hr>
<h2 id="11-函数指针与回调函数"><a href="#11-函数指针与回调函数" class="headerlink" title="11. 函数指针与回调函数"></a>11. 函数指针与回调函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p><strong>定义</strong>：指向函数的指针变量，保存函数的地址，可以通过指针调用函数。</p>
<h3 id="声明与使用"><a href="#声明与使用" class="headerlink" title="声明与使用"></a>声明与使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from greet!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*funcPtr)() = greet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用函数</span></span><br><span class="line">    <span class="built_in">funcPtr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello <span class="keyword">from</span> greet!</span><br></pre></td></tr></table></figure>



<h3 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数，接受函数指针作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">void</span> (*func)())</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 调用传入的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hi!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">execute</span>(sayHi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi!</span><br></pre></td></tr></table></figure>



<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>定义</strong>：通过函数指针传递的函数，通常用于在特定事件发生时执行自定义操作。</p>
<p><strong>示例</strong>：基于函数指针的回调</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接收回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">cb</span>(); <span class="comment">// 执行回调</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Callback executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">registerCallback</span>(myCallback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before callback</span><br><span class="line">Callback executed!</span><br><span class="line">After callback</span><br></pre></td></tr></table></figure>



<h3 id="与Lambda表达式结合"><a href="#与Lambda表达式结合" class="headerlink" title="与Lambda表达式结合"></a>与Lambda表达式结合</h3><p>函数指针也可以指向Lambda表达式，但仅限于不捕获外部变量的Lambda。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不捕获外部变量的Lambda</span></span><br><span class="line">    Callback cb = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda callback!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeCallback</span>(cb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda callback!</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：捕获外部变量的Lambda无法转换为普通函数指针。</p>
<hr>
<h2 id="12-总结与练习"><a href="#12-总结与练习" class="headerlink" title="12. 总结与练习"></a>12. 总结与练习</h2><h3 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h3><ul>
<li><strong>函数的基本概念</strong>：了解函数的作用、基本结构及使用方法。</li>
<li><strong>函数声明与定义</strong>：掌握在头文件和源文件中分离声明与定义的方法。</li>
<li><strong>参数传递机制</strong>：理解传值、传引用和传指针的区别及应用场景。</li>
<li><strong>返回值</strong>：学习不同类型的返回值及其使用方法。</li>
<li><strong>函数重载</strong>：掌握函数名相同但参数不同的重载机制。</li>
<li><strong>默认参数</strong>：学习设定和使用函数的默认参数。</li>
<li><strong>内联函数</strong>：了解内联函数的概念、优缺点及使用场景。</li>
<li><strong>递归函数</strong>：理解递归的基本原理、编写方法及优化技巧。</li>
<li><strong>Lambda表达式</strong>：掌握定义和使用Lambda表达式的方法，及其在标准库中的应用。</li>
<li><strong>函数指针与回调函数</strong>：了解函数指针的声明、使用以及如何实现回调机制。</li>
</ul>
<h2 id="13-课后练习"><a href="#13-课后练习" class="headerlink" title="13. 课后练习"></a>13. 课后练习</h2><h3 id="1-练习1"><a href="#1-练习1" class="headerlink" title="1. 练习1"></a>1. 练习1</h3><p> <strong>编写一个递归函数，计算斐波那契数列的第n项</strong></p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>斐波那契数列是由0和1开始，后续的每一项都是前两项的和。数列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</span><br></pre></td></tr></table></figure>



<p>编写一个递归函数 <code>fibonacci</code>，接受一个整数 <code>n</code>，返回斐波那契数列的第 <code>n</code> 项。假设 <code>fibonacci(0) = 0</code>，<code>fibonacci(1) = 1</code>。</p>
<h4 id="答案代码"><a href="#答案代码" class="headerlink" title="答案代码"></a><strong>答案代码</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数列的第n项</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Invalid input: n must be non-negative.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 基准情形1</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基准情形2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> term = <span class="number">10</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">fibonacci</span>(term);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10) = 55</span><br></pre></td></tr></table></figure>



<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul>
<li>函数 <code>fibonacci</code> 定义了两个基准情形：<code>n == 0</code> 返回0，<code>n == 1</code> 返回1。</li>
<li>对于 <code>n &gt; 1</code>，函数递归调用自身计算 <code>fibonacci(n - 1)</code> 和 <code>fibonacci(n - 2)</code>，并返回它们的和。</li>
<li>在 <code>main</code> 函数中，计算并输出斐波那契数列的第10项，其值为55。</li>
</ul>
<h3 id="2-练习2"><a href="#2-练习2" class="headerlink" title="2. 练习2"></a>2. 练习2</h3><p><strong>使用Lambda表达式和<code>std::sort</code>对一个字符串数组按长度排序</strong></p>
<h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>给定一个字符串数组，使用Lambda表达式和<code>std::sort</code>函数对数组中的字符串按照其长度进行排序。</p>
<h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a><strong>答案</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; fruits = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式按照字符串长度进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(fruits.<span class="built_in">begin</span>(), fruits.<span class="built_in">end</span>(), [](<span class="type">const</span> std::string &amp;a, <span class="type">const</span> std::string &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fruits sorted by length:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;fruit : fruits)</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a><strong>输出</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruits sorted <span class="keyword">by</span> length:</span><br><span class="line">kiwi grape apple banana pineapple strawberry </span><br></pre></td></tr></table></figure>



<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul>
<li>定义了一个包含多个水果名称的字符串向量 <code>fruits</code>。</li>
<li>使用 <code>std::sort</code> 对 <code>fruits</code> 进行排序，第三个参数是一个Lambda表达式，用于指定排序的规则。</li>
<li>Lambda表达式接收两个字符串 <code>a</code> 和 <code>b</code>，比较它们的长度，以实现按长度升序排序。</li>
<li>排序完成后，输出排序后的水果名称，按长度从短到长排列。</li>
</ul>
<h3 id="3-练习3"><a href="#3-练习3" class="headerlink" title="3. 练习3"></a>3. 练习3</h3><p><strong>实现一个简易的事件系统，允许注册和触发回调函数</strong></p>
<h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>构建一个简单的事件系统，允许用户注册多个回调函数（函数指针或Lambda表达式），并在特定事件触发时调用这些回调函数。</p>
<h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a><strong>答案</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义带参数的回调函数类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件系统类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSystem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Callback&gt; callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(<span class="type">const</span> Callback &amp;cb)</span> </span>&#123;</span><br><span class="line">        callbacks.<span class="built_in">push_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，传递参数给回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event triggered with data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;. Executing callbacks...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cb : callbacks)</span><br><span class="line">            <span class="built_in">cb</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数作为回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function callback received data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventSystem eventSystem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册基于函数指针的回调</span></span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>(onEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册基于Lambda表达式的回调</span></span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda callback received: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册带捕获的Lambda表达式的回调</span></span><br><span class="line">    <span class="type">int</span> multiplier = <span class="number">5</span>;</span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>([multiplier](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda with capture received: &quot;</span> &lt;&lt; x * multiplier &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，传递参数</span></span><br><span class="line">    eventSystem.<span class="built_in">triggerEvent</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Event</span> triggered <span class="keyword">with</span> data = <span class="number">10</span>. Executing callbacks...</span><br><span class="line"><span class="keyword">Function</span> callback received data: <span class="number">10</span></span><br><span class="line">Lambda callback received: <span class="number">20</span></span><br><span class="line">Lambda <span class="keyword">with</span> capture received: <span class="number">50</span></span><br></pre></td></tr></table></figure>



<h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul>
<li>定义了一个带参数的回调函数类型 <code>std::function&lt;void(int)&gt;</code>，允许回调函数接受一个整数参数。</li>
<li><code>EventSystem</code> 类的方法 <code>triggerEvent</code> 接受一个整数 <code>data</code>，并将其作为参数传递给每个回调函数。</li>
<li>在 <code>main</code> 函数中，注册了三个带不同处理逻辑的回调函数，并在触发事件时传递参数 <code>10</code>。</li>
<li>回调函数根据传入的 <code>data</code> 执行相应的操作，展示了回调函数的灵活性。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/27/cppbase17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/27/cppbase17/" itemprop="url">零基础C++(17) 语句和作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-27T09:12:20+08:00">
                2024-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-简单语句"><a href="#1-简单语句" class="headerlink" title="1. 简单语句"></a>1. 简单语句</h2><h3 id="1-1-表达式语句"><a href="#1-1-表达式语句" class="headerlink" title="1.1 表达式语句"></a>1.1 表达式语句</h3><p><strong>描述</strong>：在 C++ 中，最常见的简单语句是表达式语句。它由一个表达式组成，并以分号结束。表达式语句可以包括函数调用、赋值操作、增减操作等。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;          <span class="comment">// 赋值表达式语句</span></span><br><span class="line">    a = a + <span class="number">10</span>;         <span class="comment">// 赋值表达式语句</span></span><br><span class="line">    std::cout &lt;&lt; a;     <span class="comment">// 函数调用表达式语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// return 表达式语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>int a = 5;</code> 初始化变量 <code>a</code>，这是一个赋值表达式语句。</li>
<li><code>a = a + 10;</code> 更新变量 <code>a</code> 的值。</li>
<li><code>std::cout &lt;&lt; a;</code> 调用了输出流对象的 <code>&lt;&lt;</code> 运算符函数。</li>
<li><code>return 0;</code> 从 <code>main</code> 函数返回，结束程序。</li>
</ul>
<h3 id="1-2-声明语句"><a href="#1-2-声明语句" class="headerlink" title="1.2 声明语句"></a>1.2 声明语句</h3><p><strong>描述</strong>：声明语句用于声明变量、函数、类等标识符。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>int add(int x, int y);</code> 是一个函数声明语句。</li>
<li><code>int result = add(3, 4);</code> 在 <code>main</code> 中调用函数并声明变量。</li>
<li><code>int add(int x, int y) &#123; ... &#125;</code> 是函数定义，提供了函数的实现。</li>
</ul>
<hr>
<h2 id="2-语句作用域"><a href="#2-语句作用域" class="headerlink" title="2. 语句作用域"></a>2. 语句作用域</h2><h3 id="2-1-作用域的基本概念"><a href="#2-1-作用域的基本概念" class="headerlink" title="2.1 作用域的基本概念"></a>2.1 作用域的基本概念</h3><p><strong>描述</strong>：作用域定义了变量或其他标识符在程序中的可见范围。C++ 中主要有以下几种作用域：</p>
<ul>
<li>**局部作用域 (Local Scope)**：在函数或代码块内部定义的变量，仅在其所在的块内可见。</li>
<li>**全局作用域 (Global Scope)**：在所有函数外部定义的变量，在整个文件中可见。</li>
<li>**命名空间作用域 (Namespace Scope)**：在命名空间内部定义的标识符。</li>
</ul>
<h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside display() - globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; <span class="string">&quot;, localVar: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main() - globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> mainVar = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main() - mainVar: &quot;</span> &lt;&lt; mainVar &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试访问 display() 中的局部变量（将导致编译错误）</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; localVar; // 错误：未定义标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">In</span> <span class="string">main()</span> <span class="bullet">-</span> <span class="attr">globalVar:</span> <span class="number">10</span></span><br><span class="line"><span class="string">In</span> <span class="string">main()</span> <span class="bullet">-</span> <span class="attr">mainVar:</span> <span class="number">20</span></span><br><span class="line"><span class="string">Inside</span> <span class="string">display()</span> <span class="bullet">-</span> <span class="attr">globalVar:</span> <span class="number">10</span><span class="string">,</span> <span class="attr">localVar:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>globalVar</code> 在所有函数中都可见。</li>
<li><code>mainVar</code> 仅在 <code>main</code> 函数内部可见。</li>
<li><code>localVar</code> 仅在 <code>display</code> 函数内部可见。</li>
<li>尝试在 <code>main</code> 中访问 <code>display</code> 函数的 <code>localVar</code> 将导致编译错误，因为它不在作用域内。</li>
</ul>
<h3 id="2-3-代码块作用域"><a href="#2-3-代码块作用域" class="headerlink" title="2.3 代码块作用域"></a>2.3 代码块作用域</h3><p><strong>描述</strong>：通过使用花括号 <code>&#123;&#125;</code>，可以创建新的代码块，从而定义局部作用域。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x before block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新的代码块</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">20</span>; <span class="comment">// 局部变量 x，隐藏外部的 x</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x inside block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 访问外部的 x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x before <span class="keyword">block</span>: <span class="number">10</span></span><br><span class="line">x inside <span class="keyword">block</span>: <span class="number">20</span></span><br><span class="line">x after <span class="keyword">block</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>在内部代码块中重新声明了变量 <code>x</code>，该 <code>x</code> 只在代码块内有效，隐藏了外部的 <code>x</code>。</li>
<li>离开代码块后，内部的 <code>x</code> 不再可见，外部的 <code>x</code> 依然有效。</li>
</ul>
<hr>
<h2 id="3-条件语句"><a href="#3-条件语句" class="headerlink" title="3. 条件语句"></a>3. 条件语句</h2><p>C++ 提供了多种条件语句，用于根据不同的条件执行不同的代码块。</p>
<h3 id="3-1-if-语句"><a href="#3-1-if-语句" class="headerlink" title="3.1 if 语句"></a>3.1 <code>if</code> 语句</h3><p><strong>描述</strong>：<code>if</code> 语句用于在条件为真时执行特定的代码块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The number is positive.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>用户输入一个数字，如果 <code>number</code> 大于 <code>0</code>，则输出 “The number is positive.”。</li>
</ul>
<h3 id="3-2-if-else-语句"><a href="#3-2-if-else-语句" class="headerlink" title="3.2 if-else 语句"></a>3.2 <code>if-else</code> 语句</h3><p><strong>描述</strong>：<code>if-else</code> 语句在条件为假时执行另一个代码块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is even.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is odd.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>判断输入的数字是奇数还是偶数，并输出相应的结果。</li>
</ul>
<h3 id="3-3-else-if-语句"><a href="#3-3-else-if-语句" class="headerlink" title="3.3 else if 语句"></a>3.3 <code>else if</code> 语句</h3><p><strong>描述</strong>：<code>else if</code> 允许在多重条件下执行不同的代码块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// code if condition1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// code if condition1 is false and condition2 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code if both condition1 and condition2 are false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter your score (0-100): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: C&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: D&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: F&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>根据分数范围判断并输出相应的等级。</li>
</ul>
<h3 id="3-4-switch-语句"><a href="#3-4-switch-语句" class="headerlink" title="3.4 switch 语句"></a>3.4 <code>switch</code> 语句</h3><p><strong>描述</strong>：<code>switch</code> 语句根据变量的值选择执行的代码块，适用于离散的值。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> grade;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter your grade (A, B, C, D, F): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Excellent!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Good!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Fair!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Poor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Invalid grade.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>根据输入的字母等级输出相应的评价。</li>
<li><code>break</code> 语句防止代码“掉入”下一个 <code>case</code> 中。</li>
</ul>
<hr>
<h2 id="4-迭代语句"><a href="#4-迭代语句" class="headerlink" title="4. 迭代语句"></a>4. 迭代语句</h2><p>C++ 提供了多种循环结构，用于重复执行代码块。</p>
<h3 id="4-1-for-循环"><a href="#4-1-for-循环" class="headerlink" title="4.1 for 循环"></a>4.1 <code>for</code> 循环</h3><p><strong>描述</strong>：<code>for</code> 循环用于已知循环次数的情况，结构紧凑。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="selector-tag">from</span> <span class="number">1</span> <span class="selector-tag">to</span> <span class="number">5</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>初始化 <code>int i = 1</code>。</li>
<li>条件 <code>i &lt;= 5</code> 为真时执行循环体。</li>
<li>每次循环后执行 <code>++i</code>，增加 <code>i</code> 的值。</li>
<li>最终输出 1 到 5。</li>
</ul>
<h3 id="4-2-while-循环"><a href="#4-2-while-循环" class="headerlink" title="4.2 while 循环"></a>4.2 <code>while</code> 循环</h3><p><strong>描述</strong>：<code>while</code> 循环在循环前判断条件，适合未知循环次数的情况。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5 using while loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">while</span> <span class="keyword">loop</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>初始化 <code>count = 1</code>。</li>
<li>条件 <code>count &lt;= 5</code> 为真时执行循环体。</li>
<li>每次循环后 <code>++count</code> 增加 <code>count</code> 的值。</li>
</ul>
<h3 id="4-3-do-while-循环"><a href="#4-3-do-while-循环" class="headerlink" title="4.3 do-while 循环"></a>4.3 <code>do-while</code> 循环</h3><p><strong>描述</strong>：<code>do-while</code> 循环在循环后判断条件，保证至少执行一次循环体。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5 using do-while loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt;= <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">do</span>-<span class="keyword">while</span> <span class="keyword">loop</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>无论条件是否为真，<code>do</code> 块中的代码至少执行一次。</li>
<li>在本例中，<code>count</code> 从 <code>1</code> 开始，逐步增加到 <code>5</code>。</li>
</ul>
<h3 id="4-4-嵌套循环"><a href="#4-4-嵌套循环" class="headerlink" title="4.4 嵌套循环"></a>4.4 嵌套循环</h3><p><strong>描述</strong>：一个循环内部嵌套另一个循环，常用于多维数据结构的遍历。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Outer loop iteration &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  Inner loop iteration &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>外层 <code>for</code> 循环控制外层迭代次数。</li>
<li>内层 <code>for</code> 循环在每次外层循环中执行，控制内层迭代次数。</li>
</ul>
<hr>
<h2 id="5-跳转语句"><a href="#5-跳转语句" class="headerlink" title="5. 跳转语句"></a>5. 跳转语句</h2><p>跳转语句用于改变程序的执行流。C++ 中主要有 <code>break</code>、<code>continue</code>、<code>return</code> 和 <code>goto</code>。</p>
<h3 id="5-1-break-语句"><a href="#5-1-break-语句" class="headerlink" title="5.1 break 语句"></a>5.1 <code>break</code> 语句</h3><p><strong>描述</strong>：<code>break</code> 用于立即终止最近的循环或 <code>switch</code> 语句。</p>
<p><strong>示例代码（在循环中使用 <code>break</code>）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nLoop exited when i == 5.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="keyword">Loop</span> exited <span class="keyword">when</span> i == <span class="number">5</span>.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>当 <code>i</code> 达到 <code>5</code> 时，<code>break</code> 终止循环，停止进一步的迭代。</li>
</ul>
<h3 id="5-2-continue-语句"><a href="#5-2-continue-语句" class="headerlink" title="5.2 continue 语句"></a>5.2 <code>continue</code> 语句</h3><p><strong>描述</strong>：<code>continue</code> 用于跳过当前的循环迭代，继续下一次循环。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Even numbers between 1 and 10:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Even numbers <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span>:</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>当 <code>i</code> 是奇数时，<code>continue</code> 跳过本次循环，避免执行 <code>std::cout</code> 语句。</li>
<li>仅输出偶数。</li>
</ul>
<h3 id="5-3-return-语句"><a href="#5-3-return-语句" class="headerlink" title="5.3 return 语句"></a>5.3 <code>return</code> 语句</h3><p><strong>描述</strong>：<code>return</code> 用于从函数中返回一个值或结束函数执行。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，返回两个数中的较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// 返回 a，退出函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b; <span class="comment">// 返回 b，退出函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The maximum of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">max</span>(x, y) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The maximum of <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">is</span> <span class="number">20.</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>max</code> 函数根据条件返回较大的数，并退出函数执行。</li>
</ul>
<h3 id="5-4-goto-语句"><a href="#5-4-goto-语句" class="headerlink" title="5.4 goto 语句"></a>5.4 <code>goto</code> 语句</h3><p><strong>描述</strong>：<code>goto</code> 允许无条件跳转到程序中指定的标签。虽然 <code>goto</code> 有时能简化代码，但不推荐频繁使用，因为它会使程序流程难以理解和维护。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a positive number (negative to quit): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> end; <span class="comment">// 跳转到 end 标签，结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program ended.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（输入为负数）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="selector-tag">a</span> positive number (negative <span class="selector-tag">to</span> quit): -<span class="number">5</span></span><br><span class="line">Program ended.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>当输入负数时，<code>goto end;</code> 跳转到 <code>end</code> 标签，结束程序。</li>
<li>尽管可以使用 <code>goto</code>，但建议使用更结构化的控制流，如循环和条件语句。</li>
</ul>
<hr>
<h2 id="6-异常处理语句"><a href="#6-异常处理语句" class="headerlink" title="6. 异常处理语句"></a>6. 异常处理语句</h2><p>异常处理用于应对程序运行过程中可能出现的错误情况，确保程序的健壮性和可靠性。</p>
<h3 id="6-1-try-catch-和-throw-语句"><a href="#6-1-try-catch-和-throw-语句" class="headerlink" title="6.1 try, catch, 和 throw 语句"></a>6.1 <code>try</code>, <code>catch</code>, 和 <code>throw</code> 语句</h3><p><strong>描述</strong>：</p>
<ul>
<li><code>try</code> 块用于包含可能引发异常的代码。</li>
<li><code>throw</code> 用于抛出异常。</li>
<li><code>catch</code> 块用于捕获并处理异常。</li>
</ul>
<p><strong>基本语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// code that may throw an exception</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// handler for ExceptionType1</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// handler for ExceptionType2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，计算除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Denominator cannot be zero.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num, denom;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter numerator: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter denominator: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; denom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">divide</span>(num, denom);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::invalid_argument &amp;e) &#123; <span class="comment">// 捕获 std::invalid_argument 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues after try-catch.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Enter</span> <span class="attr">numerator</span>: <span class="number">10</span></span><br><span class="line"><span class="title class_">Enter</span> <span class="attr">denominator</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Denominator</span> cannot be zero.</span><br><span class="line"><span class="title class_">Program</span> continues after <span class="keyword">try</span>-<span class="keyword">catch</span>.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>divide</code> 函数在分母为零时抛出 <code>std::invalid_argument</code> 异常。</li>
<li><code>try</code> 块尝试执行 <code>divide</code> 函数。</li>
<li>当异常发生时，执行对应的 <code>catch</code> 块，输出错误信息。</li>
<li>程序在异常处理后继续执行，而不会异常终止。</li>
</ul>
<h3 id="6-2-多重-catch-块"><a href="#6-2-多重-catch-块" class="headerlink" title="6.2 多重 catch 块"></a>6.2 多重 <code>catch</code> 块</h3><p><strong>描述</strong>：可以为 <code>try</code> 块指定多个 <code>catch</code> 块，以处理不同类型的异常。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟不同类型的异常</span></span><br><span class="line">        <span class="type">int</span> choice;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Choose exception to throw (1: bad_alloc, 2: invalid_argument): &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid argument provided.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No exception thrown.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123; <span class="comment">// 处理 bad_alloc 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::invalid_argument &amp;e) &#123; <span class="comment">// 处理 invalid_argument 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::invalid_argument: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues after try-catch.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（选择 <code>1</code>）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Choose exception to <span class="keyword">throw</span> (<span class="number">1</span>: bad_alloc, <span class="number">2</span>: invalid_argument): <span class="number">1</span></span><br><span class="line">Caught std::<span class="variable constant_">bad_alloc</span>: std::<span class="variable constant_">bad_alloc</span></span><br><span class="line">Program continues after <span class="keyword">try</span>-<span class="keyword">catch</span>.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>根据用户输入抛出不同类型的异常。</li>
<li>对应的 <code>catch</code> 块分别处理不同的异常类型。</li>
<li>如果未匹配的异常被抛出且没有对应的 <code>catch</code> 块，将导致程序终止（未在此示例中展示）。</li>
</ul>
<h3 id="6-3-throw-通常位置"><a href="#6-3-throw-通常位置" class="headerlink" title="6.3 throw 通常位置"></a>6.3 <code>throw</code> 通常位置</h3><p><strong>描述</strong>：<code>throw</code> 语句可以在任何需要引发异常的位置使用，包括函数内部、嵌套调用中等。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，检查数组索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElement</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index is out of range.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter array index (0-4): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="built_in">getElement</span>(myArray, <span class="number">5</span>, index);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element at index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::out_of_range &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（输入为 <code>3</code>）：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter array <span class="keyword">index</span> (<span class="number">0</span>-<span class="number">4</span>): <span class="number">3</span></span><br><span class="line">Element at <span class="keyword">index</span> <span class="number">3</span> is <span class="number">40</span>.</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（输入为 <code>5</code>）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Enter array <span class="title">index</span> (<span class="params"><span class="number">0</span><span class="number">-4</span></span>): 5</span></span><br><span class="line"><span class="function">Error: Index <span class="keyword">is</span> <span class="keyword">out</span> of range.</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>getElement</code> 函数检查索引是否有效，如果无效则抛出 <code>std::out_of_range</code> 异常。</li>
<li><code>main</code> 函数中的 <code>try</code> 块调用 <code>getElement</code>，并在 <code>catch</code> 块中处理异常。</li>
</ul>
<h3 id="6-4-rethrow-异常"><a href="#6-4-rethrow-异常" class="headerlink" title="6.4 rethrow 异常"></a>6.4 <code>rethrow</code> 异常</h3><p><strong>描述</strong>：可以在 <code>catch</code> 块中使用 <code>throw</code> 语句重新抛出捕获的异常，以便其他部分处理。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error in func1.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，调用 func1 并重新抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func2() caught an exception and is rethrowing it.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123; <span class="comment">// 在 main 中捕获异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Main caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func2</span>() caught an exception and is rethrowing it.</span><br><span class="line"><span class="selector-tag">Main</span> caught: Error in func1.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>func1</code> 抛出异常。</li>
<li><code>func2</code> 调用 <code>func1</code>，捕获异常后重新抛出。</li>
<li><code>main</code> 最终捕获并处理异常。</li>
</ul>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h2 id="练习题-1：打印九九乘法表"><a href="#练习题-1：打印九九乘法表" class="headerlink" title="练习题 1：打印九九乘法表"></a>练习题 1：打印九九乘法表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，使用嵌套的 <code>for</code> 循环来打印标准的九九乘法表。输出的格式应整齐对齐，便于阅读。</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol>
<li>使用嵌套的 <code>for</code> 循环实现。</li>
<li>输出的乘法表应从 1×1 到 9×9。</li>
<li>每行输出一个数字的乘法结果，例如第 3 行包含 <code>3×1=3</code> 到 <code>3×9=27</code>。</li>
<li>确保输出格式整齐，便于阅读。</li>
</ol>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a><strong>示例输出</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1x1=1	1x2=2	1x3=3	1x4=4	1x5=5	1x6=6	1x7=7	1x8=8	1x9=9	</span><br><span class="line">2x1=2	2x2=4	2x3=6	2x4=8	2x5=10	2x6=12	2x7=14	2x8=16	2x9=18	</span><br><span class="line">3x1=3	3x2=6	3x3=9	3x4=12	3x5=15	3x6=18	3x7=21	3x8=24	3x9=27	</span><br><span class="line">4x1=4	4x2=8	4x3=12	4x4=16	4x5=20	4x6=24	4x7=28	4x8=32	4x9=36	</span><br><span class="line">5x1=5	5x2=10	5x3=15	5x4=20	5x5=25	5x6=30	5x7=35	5x8=40	5x9=45	</span><br><span class="line">6x1=6	6x2=12	6x3=18	6x4=24	6x5=30	6x6=36	6x7=42	6x8=48	6x9=54	</span><br><span class="line">7x1=7	7x2=14	7x3=21	7x4=28	7x5=35	7x6=42	7x7=49	7x8=56	7x9=63	</span><br><span class="line">8x1=8	8x2=16	8x3=24	8x4=32	8x5=40	8x6=48	8x7=56	8x8=64	8x9=72	</span><br><span class="line">9x1=9	9x2=18	9x3=27	9x4=36	9x5=45	9x6=54	9x7=63	9x8=72	9x9=81	</span><br></pre></td></tr></table></figure>



<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul>
<li>使用两个嵌套的 <code>for</code> 循环：外层循环控制行数（1 到 9），内层循环控制列数（1 到 9）。</li>
<li>使用 <code>\t</code> 或者适当的空格来对齐输出结果。</li>
<li>可以使用 <code>std::cout</code> 进行输出。</li>
</ul>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><strong>参考答案</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环控制行数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 内层循环控制列数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i * j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题-2：实现冒泡排序"><a href="#练习题-2：实现冒泡排序" class="headerlink" title="练习题 2：实现冒泡排序"></a>练习题 2：实现冒泡排序</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，使用 <strong>冒泡排序算法</strong> 对用户输入的一组整数进行排序。冒泡排序是一种简单的排序算法，通过重复交换相邻的未按顺序排列的元素，将最大或最小的元素“冒泡”到序列的一端。</p>
<h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol>
<li><strong>输入</strong>：用户输入一组整数，首先输入整数的数量 <code>n</code>，然后输入 <code>n</code> 个整数。</li>
<li><strong>排序</strong>：使用冒泡排序算法对输入的整数进行升序排序。</li>
<li><strong>输出</strong>：显示排序前和排序后的整数序列。</li>
<li><strong>函数封装</strong>：将冒泡排序算法封装在一个独立的函数中，提高代码的模块化和可读性。</li>
</ol>
<h3 id="示例输入与输出"><a href="#示例输入与输出" class="headerlink" title="示例输入与输出"></a><strong>示例输入与输出</strong></h3><p><strong>示例 1：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 5</span></span><br><span class="line">请输入 5 个整数，用空格分隔: 64 34 25 12 22</span><br><span class="line"><span class="section">排序前的数组: 64 34 25 12 22 </span></span><br><span class="line"><span class="section">排序后的数组: 12 22 25 34 64 </span></span><br></pre></td></tr></table></figure>



<p><strong>示例 2：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 8</span></span><br><span class="line">请输入 8 个整数，用空格分隔: 5 1 4 2 8 0 2 9</span><br><span class="line"><span class="section">排序前的数组: 5 1 4 2 8 0 2 9 </span></span><br><span class="line"><span class="section">排序后的数组: 0 1 2 2 4 5 8 9 </span></span><br></pre></td></tr></table></figure>



<h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul>
<li><strong>冒泡排序的基本思想</strong>：通过多次遍历数组，每次比较相邻的元素并交换顺序错误的元素。每一轮遍历后，最大的元素会被移动到数组的末端。</li>
<li><strong>优化</strong>：如果在某一轮遍历中没有发生任何交换，说明数组已经有序，可以提前终止排序过程。</li>
<li><strong>函数设计</strong>：可以设计一个 <code>bubbleSort</code> 函数接收数组及其大小作为参数，并对数组进行排序。</li>
</ul>
<h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><strong>参考答案</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="comment">// 外层循环控制总的遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个元素大于后一个元素，则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在一轮遍历中没有进行任何交换，数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数组大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入整数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数组大小必须为正整数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数组元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 个整数，用空格分隔: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序前的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序前的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行冒泡排序</span></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ol>
<li><p>**函数 <code>bubbleSort</code>**：</p>
<ul>
<li><p><strong>参数</strong>：接收一个整数数组 <code>arr</code> 和数组的大小 <code>n</code>。</p>
</li>
<li><p>逻辑</p>
<p>：</p>
<ul>
<li>使用两层 <code>for</code> 循环实现冒泡排序。</li>
<li>外层循环控制需要进行的遍历次数，总共需要 <code>n-1</code> 轮。</li>
<li>内层循环进行相邻元素的比较和交换，每一轮内层循环会将当前未排序部分的最大元素移动到数组的末端。</li>
<li>使用 <code>swapped</code> 标志位优化排序过程，如果一轮内层循环中没有发生任何交换，说明数组已经有序，提前终止排序。</li>
</ul>
</li>
<li><p><strong>交换操作</strong>：使用 <code>std::swap</code> 函数交换两个元素的位置。</p>
</li>
</ul>
</li>
<li><p>**函数 <code>printArray</code>**：</p>
<ul>
<li><strong>功能</strong>：遍历数组并打印每个元素，便于观察排序前后的结果。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数</strong>：</p>
<ul>
<li><p>步骤</p>
<p>：</p>
<ol>
<li><strong>输入数组大小</strong>：提示用户输入要排序的整数数量 <code>n</code>。</li>
<li><strong>输入数组元素</strong>：动态分配一个大小为 <code>n</code> 的整数数组，并从用户处获取 <code>n</code> 个整数的输入。</li>
<li><strong>打印排序前的数组</strong>：调用 <code>printArray</code> 函数显示原始数组。</li>
<li><strong>执行冒泡排序</strong>：调用 <code>bubbleSort</code> 函数对数组进行排序。</li>
<li><strong>打印排序后的数组</strong>：再次调用 <code>printArray</code> 函数显示排序后的数组。</li>
<li><strong>内存管理</strong>：使用 <code>delete[]</code> 释放动态分配的内存，避免内存泄漏。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li>判断用户输入的数组大小 <code>n</code> 是否为正整数，否者输出错误信息并终止程序。</li>
</ul>
</li>
</ol>
<h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a><strong>运行示例</strong></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 5</span></span><br><span class="line">请输入 5 个整数，用空格分隔: 64 34 25 12 22</span><br><span class="line"><span class="section">排序前的数组: 64 34 25 12 22 </span></span><br><span class="line"><span class="section">排序后的数组: 12 22 25 34 64 </span></span><br></pre></td></tr></table></figure>





<h2 id="练习题-3：生成斐波那契数列"><a href="#练习题-3：生成斐波那契数列" class="headerlink" title="练习题 3：生成斐波那契数列"></a>练习题 3：生成斐波那契数列</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，生成并显示斐波那契数列。程序应允许用户指定生成数列的长度，并使用 <strong>循环结构</strong> 或 <strong>递归方法</strong> 来生成斐波那契数。</p>
<p>斐波那契数列是一个由 0 和 1 开始，后续的每个数都是前两个数之和的数列。例如：0, 1, 1, 2, 3, 5, 8, 13, …</p>
<h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol>
<li><strong>输入</strong>：用户输入要生成的斐波那契数的数量 <code>n</code>。</li>
<li><strong>生成</strong>：使用循环结构（如 <code>for</code> 或 <code>while</code> 循环）生成斐波那契数列。</li>
<li><strong>输出</strong>：显示生成的斐波那契数列。</li>
<li><strong>函数封装</strong>：将生成斐波那契数列的逻辑封装在一个独立的函数中。</li>
</ol>
<h3 id="示例输入与输出-1"><a href="#示例输入与输出-1" class="headerlink" title="示例输入与输出"></a><strong>示例输入与输出</strong></h3><p><strong>示例 1：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 10</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 </span><br></pre></td></tr></table></figure>



<p><strong>示例 2：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 5</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 </span><br></pre></td></tr></table></figure>



<h3 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul>
<li><p>斐波那契数列的定义</p>
<p>：</p>
<ul>
<li>第 0 个斐波那契数是 0。</li>
<li>第 1 个斐波那契数是 1。</li>
<li>对于 <code>n &gt;= 2</code>，第 <code>n</code> 个斐波那契数是第 <code>n-1</code> 个数和第 <code>n-2</code> 个数的和。</li>
</ul>
</li>
<li><p>实现方法</p>
<p>：</p>
<ul>
<li><strong>迭代法</strong>：使用循环结构依次计算斐波那契数。</li>
<li><strong>递归法</strong>（高级）：使用递归函数实现，但效率较低，通常不推荐用于较大的 <code>n</code>。</li>
</ul>
</li>
<li><p><strong>数据类型</strong>：根据 <code>n</code> 的范围选择合适的数据类型，<code>unsigned long long</code> 可以存储较大的斐波那契数。</p>
</li>
</ul>
<h3 id="参考答案（迭代法实现）"><a href="#参考答案（迭代法实现）" class="headerlink" title="参考答案（迭代法实现）"></a><strong>参考答案（迭代法实现）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成斐波那契数列的函数（迭代法）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">generateFibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fib;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空向量</span></span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个斐波那契数</span></span><br><span class="line">    fib.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个斐波那契数</span></span><br><span class="line">    fib.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成后续的斐波那契数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> next = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        fib.<span class="built_in">push_back</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斐波那契数列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFibonacci</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; &amp;fib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fib.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取要生成的斐波那契数的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要生成的斐波那契数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数量不能为负数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fibonacci = <span class="built_in">generateFibonacci</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印斐波那契数列</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;斐波那契数列:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printFibonacci</span>(fibonacci);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ol>
<li><p>**函数 <code>generateFibonacci</code>**：</p>
<ul>
<li><p><strong>参数</strong>：接收一个整数 <code>n</code>，表示要生成的斐波那契数的数量。</p>
</li>
<li><p><strong>返回值</strong>：返回一个 <code>std::vector&lt;unsigned long long&gt;</code>，包含生成的斐波那契数列。</p>
</li>
<li><p>逻辑</p>
<p>：</p>
<ul>
<li>如果 <code>n &lt;= 0</code>，返回一个空的向量。</li>
<li>初始化斐波那契数列的前两个数：0 和 1。</li>
<li>使用一个 <code>for</code> 循环，从第三个数开始，依次计算当前数为前两个数之和，并将其添加到向量中。</li>
</ul>
</li>
</ul>
</li>
<li><p>**函数 <code>printFibonacci</code>**：</p>
<ul>
<li><strong>参数</strong>：接收一个 <code>const</code> 引用的斐波那契数列向量。</li>
<li><strong>功能</strong>：遍历并打印斐波那契数列中的每个数，用空格分隔。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数</strong>：</p>
<ul>
<li><p>步骤</p>
<p>：</p>
<ol>
<li><strong>输入数量</strong>：提示用户输入要生成的斐波那契数的数量 <code>n</code>。</li>
<li><strong>输入验证</strong>：检查 <code>n</code> 是否为负数，若是则输出错误信息并终止程序。</li>
<li><strong>生成数列</strong>：调用 <code>generateFibonacci</code> 函数生成斐波那契数列。</li>
<li><strong>打印数列</strong>：调用 <code>printFibonacci</code> 函数显示生成的斐波那契数列。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>数据类型选择</strong>：</p>
<ul>
<li>使用 <code>unsigned long long</code> 可以存储较大的斐波那契数，避免整数溢出。但需要注意，<code>unsigned long long</code> 的范围有限，对于非常大的 <code>n</code>，仍然会发生溢出。</li>
</ul>
</li>
</ol>
<h3 id="运行示例-1"><a href="#运行示例-1" class="headerlink" title="运行示例"></a><strong>运行示例</strong></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 10</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 </span><br></pre></td></tr></table></figure>



<h3 id="递归实现参考代码（可选）"><a href="#递归实现参考代码（可选）" class="headerlink" title="递归实现参考代码（可选）"></a><strong>递归实现参考代码（可选）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，计算第 n 个斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;n 不能为负数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacciRecursive</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacciRecursive</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成斐波那契数列的函数（递归实现）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">generateFibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fib;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fib.<span class="built_in">push_back</span>(<span class="built_in">fibonacciRecursive</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斐波那契数列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFibonacci</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; &amp;fib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fib.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取要生成的斐波那契数的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要生成的斐波那契数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数量不能为负数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 生成斐波那契数列（递归实现）</span></span><br><span class="line">        std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fibonacci = <span class="built_in">generateFibonacciRecursive</span>(n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印斐波那契数列</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;斐波那契数列:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printFibonacci</span>(fibonacci);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归实现说明"><a href="#递归实现说明" class="headerlink" title="递归实现说明"></a><strong>递归实现说明</strong></h3><ul>
<li><p>优点</p>
<p>：</p>
<ul>
<li>代码简洁，符合斐波那契数列的数学定义。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>时间复杂度为指数级 <code>O(2^n)</code>，对于较大的 <code>n</code> 会非常低效。</li>
<li>递归深度过大可能导致栈溢出。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合学习和理解递归概念，但在实际应用中需谨慎使用。</p>
</li>
</ul>
<h3 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h3><p>动态规划通过存储已计算的值来避免重复计算，提高了效率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划实现斐波那契数列</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fibonacci_dynamic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fib</span><span class="params">(n)</span></span>;</span><br><span class="line">    fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入斐波那契数列的项数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; fib = <span class="built_in">fibonacci_dynamic</span>(n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;斐波那契数列的前 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 项为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/26/cppbase16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/26/cppbase16/" itemprop="url">零基础C++(16) 常见运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-26T11:59:11+08:00">
                2024-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>运算符是编程语言中用于执行特定操作的符号或关键字。在C++中，运算符的使用广泛且多样，掌握运算符的使用对于编写高效、简洁的代码至关重要。本教案旨在全面介绍C++中的各种运算符，帮助学习者深入理解和灵活运用。</p>
<h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><p><strong>运算符（Operator）</strong> 是用来对变量进行操作的符号或函数。C++中的运算符可分为多种类型，每种运算符具有特定的功能和使用规则。运算符可以单目（仅操作一个操作数）、双目（操作两个操作数）、甚至三目（操作三个操作数）等。</p>
<h2 id="运算符分类"><a href="#运算符分类" class="headerlink" title="运算符分类"></a>运算符分类</h2><p>C++中的运算符可以根据功能和使用方式分为以下几类：</p>
<h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>用于执行基本的数学计算。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>a + b</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>a - b</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>a * b</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>a / b</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模（求余数）</td>
<td><code>a % b</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增（前缀/后缀）</td>
<td><code>++a</code>, <code>a++</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减（前缀/后缀）</td>
<td><code>--a</code>, <code>a--</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> sum = a + b;    <span class="comment">// 13</span></span><br><span class="line"><span class="type">int</span> diff = a - b;   <span class="comment">// 7</span></span><br><span class="line"><span class="type">int</span> prod = a * b;   <span class="comment">// 30</span></span><br><span class="line"><span class="type">int</span> div = a / b;    <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span> mod = a % b;    <span class="comment">// 1</span></span><br><span class="line">a++;                <span class="comment">// a = 11</span></span><br><span class="line">--b;                <span class="comment">// b = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h3><p>用于比较两个值之间的关系，返回布尔值（<code>true</code> 或 <code>false</code>）。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>a == b</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>a != b</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>a &gt; b</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>a &lt; b</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于或等于</td>
<td><code>a &gt;= b</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
<td><code>a &lt;= b</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> result1 = (a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">bool</span> result2 = (a &lt; b);  <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> result3 = (a &gt;= b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>用于组合或反转布尔表达式，返回布尔值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与（AND）</td>
<td><code>a &amp;&amp; b</code></td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非（NOT）</td>
<td><code>!a</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> result1 = a &amp;&amp; b; <span class="comment">// false</span></span><br><span class="line"><span class="type">bool</span> result2 = a || b; <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> result3 = !a;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>用于按位操作整数类型的二进制位。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>a &amp; b</code></td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>按位或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或（不等时为1）</td>
<td><code>a ^ b</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位取反</td>
<td><code>~a</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>a &lt;&lt; 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>a &gt;&gt; 2</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 二进制：0101</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 二进制：0011</span></span><br><span class="line"><span class="type">int</span> andResult = a &amp; b; <span class="comment">// 1 (0001)</span></span><br><span class="line"><span class="type">int</span> orResult = a | b;  <span class="comment">// 7 (0111)</span></span><br><span class="line"><span class="type">int</span> xorResult = a ^ b; <span class="comment">// 6 (0110)</span></span><br><span class="line"><span class="type">int</span> notResult = ~a;    <span class="comment">// -6 (补码)</span></span><br><span class="line"><span class="type">int</span> leftShift = a &lt;&lt; <span class="number">1</span>; <span class="comment">// 10 (1010)</span></span><br><span class="line"><span class="type">int</span> rightShift = a &gt;&gt; <span class="number">1</span>; <span class="comment">// 2 (0010)</span></span><br></pre></td></tr></table></figure>



<h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h3><p>用于向变量赋值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>简单赋值</td>
<td><code>a = b</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加后赋值</td>
<td><code>a += b</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减后赋值</td>
<td><code>a -= b</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘后赋值</td>
<td><code>a *= b</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除后赋值</td>
<td><code>a /= b</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模后赋值</td>
<td><code>a %= b</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与后赋值</td>
<td><code>a &amp;= b</code></td>
</tr>
<tr>
<td>`</td>
<td>=`</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或后赋值</td>
<td><code>a ^= b</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移后赋值</td>
<td><code>a &lt;&lt;= 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移后赋值</td>
<td><code>a &gt;&gt;= 2</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">a += b; <span class="comment">// a = 8</span></span><br><span class="line">a *= <span class="number">2</span>; <span class="comment">// a = 16</span></span><br><span class="line">a &amp;= b; <span class="comment">// a = 16 &amp; 3 = 0</span></span><br></pre></td></tr></table></figure>



<h3 id="6-复合赋值运算符"><a href="#6-复合赋值运算符" class="headerlink" title="6. 复合赋值运算符"></a>6. 复合赋值运算符</h3><p>结合赋值与其他运算的运算符（如上表中所示的<code>+=</code>, <code>-=</code>, 等）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// 等同于 a = a + 5; 结果 a = 15</span></span><br></pre></td></tr></table></figure>



<h3 id="7-条件运算符"><a href="#7-条件运算符" class="headerlink" title="7. 条件运算符"></a>7. 条件运算符</h3><p>用于基于条件选择值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>?:</code></td>
<td>条件（三目）运算符</td>
<td><code>a ? b : c</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">c = (a &gt; b) ? a : b; <span class="comment">// c = 20</span></span><br></pre></td></tr></table></figure>



<h3 id="8-递增和递减运算符"><a href="#8-递增和递减运算符" class="headerlink" title="8. 递增和递减运算符"></a>8. 递增和递减运算符</h3><p>用于增加或减少变量的值，前缀和后缀形式。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>++</code></td>
<td>自增（前缀/后缀）</td>
<td><code>++a</code>, <code>a++</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减（前缀/后缀）</td>
<td><code>--a</code>, <code>a--</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = ++a; <span class="comment">// a = 6, b = 6</span></span><br><span class="line"><span class="type">int</span> c = a--; <span class="comment">// a = 5, c = 6</span></span><br></pre></td></tr></table></figure>



<h3 id="9-指针运算符"><a href="#9-指针运算符" class="headerlink" title="9. 指针运算符"></a>9. 指针运算符</h3><p>用于操作指针。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>间接访问（解引用）</td>
<td><code>*ptr</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>取地址</td>
<td><code>&amp;a</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>成员访问（指向对象的指针）</td>
<td><code>ptr-&gt;member</code></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>数组下标访问</td>
<td><code>arr[2]</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// value = 10</span></span><br></pre></td></tr></table></figure>



<h3 id="10-成员访问运算符"><a href="#10-成员访问运算符" class="headerlink" title="10. 成员访问运算符"></a>10. 成员访问运算符</h3><p>用于访问类或结构体的成员。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>直接成员访问</td>
<td><code>object.member</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>指向成员的指针访问</td>
<td><code>ptr-&gt;member</code></td>
</tr>
<tr>
<td><code>::*</code></td>
<td>指向成员的指针（成员指针操作符）</td>
<td><code>Class::*ptr</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">Point *ptr = &amp;p;</span><br><span class="line"><span class="type">int</span> a = p.x;      <span class="comment">// 使用 . 运算符</span></span><br><span class="line"><span class="type">int</span> b = ptr-&gt;y;  <span class="comment">// 使用 -&gt; 运算符</span></span><br></pre></td></tr></table></figure>



<h3 id="11-其他运算符"><a href="#11-其他运算符" class="headerlink" title="11. 其他运算符"></a>11. 其他运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>sizeof</code></td>
<td>返回变量或类型所占字节数</td>
<td><code>sizeof(int)</code></td>
</tr>
<tr>
<td><code>?:</code></td>
<td>条件（三目）运算符</td>
<td><code>a ? b : c</code></td>
</tr>
<tr>
<td><code>,</code></td>
<td>逗号运算符</td>
<td><code>a = (b, c)</code></td>
</tr>
<tr>
<td><code>typeid</code></td>
<td>运行时类型信息运算符</td>
<td><code>typeid(a)</code></td>
</tr>
<tr>
<td><code>new</code></td>
<td>动态内存分配</td>
<td><code>int *ptr = new int;</code></td>
</tr>
<tr>
<td><code>delete</code></td>
<td>动态内存释放</td>
<td><code>delete ptr;</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(a); <span class="comment">// size = 4 (通常)</span></span><br><span class="line"><span class="type">int</span> b, c;</span><br><span class="line">b = (a++, a + <span class="number">2</span>); <span class="comment">// a = 6, b = 8</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h2><p>运算符的优先级决定了在没有括号明确指定的情况下，哪一个运算符先被计算。结合性则决定了运算符在具有相同优先级时的计算顺序（从左到右或从右到左）。</p>
<h3 id="优先级表"><a href="#优先级表" class="headerlink" title="优先级表"></a>优先级表</h3><p>以下是C++运算符的优先级从高到低的简要概览：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符类别</th>
<th>运算符</th>
<th>结合性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>范围解析运算符</td>
<td><code>::</code></td>
<td>左到右</td>
<td>用于访问命名空间或类的成员</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>后缀运算符</td>
<td><code>()</code>, <code>[]</code>, <code>.</code>, <code>-&gt;</code>, <code>++</code>(后置), <code>--</code>(后置)</td>
<td>左到右</td>
<td>包含函数调用、数组下标、成员访问</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>一元运算符</td>
<td><code>+</code>, <code>-</code>, <code>!</code>, <code>~</code>, <code>++</code>(前置), <code>--</code>(前置), <code>*</code>(解引用), <code>&amp;</code>(取地址), <code>sizeof</code>, <code>typeid</code></td>
<td>右到左</td>
<td>适用于单个操作数的运算符</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>乘法运算符</td>
<td><code>*</code>, <code>/</code>, <code>%</code></td>
<td>左到右</td>
<td>乘法、除法和取模运算</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>加法运算符</td>
<td><code>+</code>, <code>-</code></td>
<td>左到右</td>
<td>加法和减法运算</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>移位运算符</td>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td>左到右</td>
<td>位左移和位右移</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>关系运算符</td>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
<td>左到右</td>
<td>比较运算符</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>相等运算符</td>
<td><code>==</code>, <code>!=</code></td>
<td>左到右</td>
<td>判断相等与不相等</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>位与运算符</td>
<td><code>&amp;</code></td>
<td>左到右</td>
<td>按位与</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>位异或运算符</td>
<td><code>^</code></td>
<td>左到右</td>
<td>按位异或</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>位或运算符</td>
<td>`</td>
<td>`</td>
<td>左到右</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>逻辑与运算符</td>
<td><code>&amp;&amp;</code></td>
<td>左到右</td>
<td>逻辑与</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>逻辑或运算符</td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td>条件运算符</td>
<td><code>?:</code></td>
<td>右到左</td>
<td>条件（三目）运算符</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>赋值运算符</td>
<td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, `</td>
<td>=<code>, </code>^=<code>, </code>&lt;&lt;=<code>, </code>&gt;&gt;=`</td>
<td>右到左</td>
</tr>
<tr>
<td><strong>16</strong></td>
<td>逗号运算符</td>
<td><code>,</code></td>
<td>左到右</td>
<td>逗号用于表达式中多个操作</td>
</tr>
</tbody></table>
<h3 id="表格说明"><a href="#表格说明" class="headerlink" title="表格说明"></a><strong>表格说明</strong></h3><ul>
<li><strong>优先级</strong>：数字越小，优先级越高。即优先级为1的运算符最先被计算。</li>
<li><strong>运算符类别</strong>：运算符的功能分类，帮助理解不同类型运算符的用途。</li>
<li><strong>运算符</strong>：具体的C++运算符符号。</li>
<li><strong>结合性</strong>：当表达式中出现多个相同优先级的运算符时，决定运算顺序的规则。<code>左到右</code>表示从左侧的操作数开始，<code>右到左</code>表示从右侧的操作数开始。</li>
<li><strong>备注</strong>：对运算符类别或特定运算符的简要说明。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><strong>运算符重载（Operator Overloading）</strong> 允许开发者为自定义类型（如类和结构体）定义或改变运算符的行为，使其表现得像内置类型一样。这提高了代码的可读性和可维护性。</p>
<h3 id="运算符重载的规则"><a href="#运算符重载的规则" class="headerlink" title="运算符重载的规则"></a>运算符重载的规则</h3><ol>
<li><strong>可重载运算符</strong>：几乎所有的运算符都可以被重载，但如 <code>::</code>, <code>?:</code>, <code>sizeof</code> 等运算符不能被重载。</li>
<li><strong>至少一个操作数必须是用户定义类型</strong>：即至少有一个操作数是类、结构体或联合体类型。</li>
<li><strong>运算符重载不改变运算符的优先级、结合性和操作数数量</strong>。</li>
</ol>
<h3 id="运算符重载的基本语法"><a href="#运算符重载的基本语法" class="headerlink" title="运算符重载的基本语法"></a>运算符重载的基本语法</h3><p>运算符可以作为成员函数或友元函数进行重载。</p>
<p><strong>成员函数重载示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">        Complex temp;</span><br><span class="line">        temp.real = real + c.real;</span><br><span class="line">        temp.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>友元函数重载示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2) &#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = c1.real + c2.real;</span><br><span class="line">    temp.imag = c1.imag + c2.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常见的重载运算符"><a href="#常见的重载运算符" class="headerlink" title="常见的重载运算符"></a>常见的重载运算符</h3><ul>
<li><strong>算术运算符</strong>：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>关系运算符</strong>：<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li><strong>逻辑运算符</strong>：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li><strong>赋值运算符</strong>：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li><strong>输入输出运算符</strong>：<code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li><strong>索引运算符</strong>：<code>[]</code></li>
<li><strong>函数调用运算符</strong>：<code>()</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, imag + c.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符（作为友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">    out &lt;&lt; c.real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.8</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl; <span class="comment">// 输出: c1 + c2 = 6.8 + 11.2i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1-交换两个数"><a href="#1-交换两个数" class="headerlink" title="1 交换两个数"></a>1 交换两个数</h3><p><strong>题目：</strong> 使用位运算符，交换两个整数变量的值而不使用第三个变量。</p>
<p><strong>答案：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换操作</span></span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = x ^ y;</span><br><span class="line">    x = x ^ y;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Before swap:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">15</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">27</span></span><br><span class="line"><span class="attr">After swap:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">27</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong> 通过异或运算 <code>^</code> 完成变量值的交换，无需使用临时变量。</p>
<h3 id="2-函数修改外部变量"><a href="#2-函数修改外部变量" class="headerlink" title="2 函数修改外部变量"></a>2 函数修改外部变量</h3><p><strong>题目：</strong> 编写一个函数，接受一个整数指针，使用解引用运算符修改其值为原值的平方。</p>
<p><strong>答案：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">square</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = (*ptr) * (*ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">square</span>(&amp;num);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Before: 5</span></span><br><span class="line"><span class="section">After: 25</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong> 通过指针访问并修改原变量的值。</p>
<h3 id="3-计算范围内所有元素的和"><a href="#3-计算范围内所有元素的和" class="headerlink" title="3 计算范围内所有元素的和"></a>3 计算范围内所有元素的和</h3><p><strong>题目：</strong> 编写一个函数，接受 <code>std::vector&lt;int&gt;</code> 的迭代器范围，计算并返回范围内所有元素的和。</p>
<p><strong>函数示例：</strong></p>
<p>须实现如下函数，返回范围内元素求和的结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator end)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>答案：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="built_in">sumRange</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Sum: 30</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong> 函数通过迭代器遍历范围，累加元素值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/22/cppbase15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/22/cppbase15/" itemprop="url">零基础C++(15) 多维数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-22T19:01:13+08:00">
                2024-10-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>更多资料可查阅官方博客，官方博客地址：<a target="_blank" rel="noopener" href="https://llfc.club/">https://llfc.club/</a></p>
<p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。</p>
<p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为3的数组，每个元素是大小为4的数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>按照由内而外的顺序阅读此类定义有助于更好地理解其真实含义。</p>
<p>在第一条语句中，我们定义的名字是<code>ia</code>，显然<code>ia</code>是一个含有3个元素的数组。</p>
<p>接着观察右边发现，<code>ia</code>的元素也有自己的维度，所以<code>ia</code>的元素本身又都是含有4个元素的数组。</p>
<p>再观察左边知道，真正存储的元素是整数。因此最后可以明确第一条语句的含义：它定义了一个大小为3的数组，该数组的每个元素都是含有4个整数的数组。</p>
<p>上面的代码可以理解为下面的形式</p>
<p><img src="https://cdn.llfc.club/1729729218328.jpg-llfc" alt="https://cdn.llfc.club/1729729218328.jpg-llfc"></p>
<p>也可以初始化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些数组的元素是含有30个整数的数组</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>使用同样的方式理解arr的定义。</p>
<p>首先arr是一个大小为10的数组，它的每个元素都是大小为20的数组，这些数组的元素又都是含有30个整数的数组。</p>
<p>实际上，定义数组时对下标运算符的数量并没有限制，因此只要愿意就可以定义这样一个数组：它的元素还是数组，下一级数组的元素还是数组，再下一级数组的元素还是数组，以此类推。对于二维数组来说，常把第一个维度称作行，第二个维度称作列。</p>
<p>多维数组的初始化</p>
<p>允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个元素，每个元素是大小为4的数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] =&#123;</span><br><span class="line">        <span class="comment">//第一行的初始值</span></span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        <span class="comment">//第二行初始值</span></span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">        <span class="comment">//第三行初始值</span></span><br><span class="line">        &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中内层嵌套着的花括号并非必需的，例如下面的初始化语句，形式上更为简洁，完成的功能和上面这段代码完全一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化每一行的首元素</span></span><br><span class="line"><span class="type">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>其他未列出的元素执行默认值初始化，这个过程和一维数组一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值初始化第一i行</span></span><br><span class="line"><span class="type">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>含义发生了变化，它初始化的是第一行的4个元素，其他元素被初始化为0。</p>
<h2 id="多维数组的下标"><a href="#多维数组的下标" class="headerlink" title="多维数组的下标"></a><strong>多维数组的下标</strong></h2><p>引用可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。</p>
<p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；</p>
<p>反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = &#123;&#123;&#123;<span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="comment">// 用arr的首元素为ia的最后一个元素赋值</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//row是一个4维数组的引用,将row绑定到ia的第二个元素(4维数组)上</span></span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>使用for循环</strong></p>
<p>我们可以使用for循环构建数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> rowCnt = <span class="number">3</span>, colCnt=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//12 个未初始化的元素</span></span><br><span class="line"><span class="type">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="comment">//对于每一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != rowCnt; ++i)&#123;</span><br><span class="line">    <span class="comment">//对于行内的每一列</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">size_t</span> j = <span class="number">0</span>; j != colCnt; ++j)&#123;</span><br><span class="line">        ia[i][j] = i*colCnt + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C++11风格处理多维数组</strong></p>
<p>由于C++11新标准增加了范围for语句，所以前一个程序可以简化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> rowCnt = <span class="number">3</span>, colCnt=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//12 个未初始化的元素</span></span><br><span class="line"><span class="type">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row: ia)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; col : row)&#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出每一个元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; row: ia)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col : row)&#123;</span><br><span class="line">        std::cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br></pre></td></tr></table></figure>

<h2 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h2><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。</p>
<p><strong>新手雷区</strong></p>
<blockquote>
<p>定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。</p>
</blockquote>
<p>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="built_in">int</span>(*p)[<span class="number">4</span>] = ia;</span><br><span class="line"><span class="comment">//将p修改为指向ia数组的尾部</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>随着C++11新标准的提出，通过使用auto或者<code>decltype</code>就能尽可能地避免在数组前面加上一个指针类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ia数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//输出ia中每个元素的值,每个内存数组各占一行</span></span><br><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)&#123;</span><br><span class="line">    <span class="comment">//q指向4个整数的数组的首元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)&#123;</span><br><span class="line">        std::cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用C++11提供的<code>std::begin</code>也能实现类似的功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ia数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p指向ia的第一个数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = std::<span class="built_in">begin</span>(ia); p != std::<span class="built_in">end</span>(ia); ++p)&#123;</span><br><span class="line">    <span class="comment">// q指向内存数组的首元素</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> q = std::<span class="built_in">begin</span>(*p); q != std::<span class="built_in">end</span>(*p); ++q)&#123;</span><br><span class="line">        <span class="comment">// 输出q所指的整数值</span></span><br><span class="line">        std::cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型别名简化多维数组指针</strong></p>
<p>可以使用using 进行类型别名的声明，或者使用typedef声明类型的别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ia数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 新标准下类型别名的声明</span></span><br><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 使用typedef 声明类型的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  <span class="type">int_array_t</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int_array * p = ia; p != ia + <span class="number">3</span>; ++p)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> *q = *p ; q != *p+<span class="number">4</span>; ++q)&#123;</span><br><span class="line">        std::cout &lt;&lt; *q &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题1：矩阵加法"><a href="#练习题1：矩阵加法" class="headerlink" title="练习题1：矩阵加法"></a>练习题1：矩阵加法</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个C++程序，输入两个<code>2x3</code>的矩阵，计算它们的和，并输出结果矩阵。</p>
<h3 id="示例代码框架"><a href="#示例代码框架" class="headerlink" title="示例代码框架"></a>示例代码框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ROW = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> COL = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> matrix1[ROW][COL];</span><br><span class="line">    <span class="type">int</span> matrix2[ROW][COL];</span><br><span class="line">    <span class="type">int</span> sum[ROW][COL];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入第一个矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入第一个2x3矩阵的元素（共6个整数）:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            <span class="comment">// 在此输入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入第二个矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入第二个2x3矩阵的元素（共6个整数）:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            <span class="comment">// 在此输入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个矩阵的和</span></span><br><span class="line">    <span class="comment">// 在此实现加法逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;两个矩阵的和为:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            <span class="comment">// 在此输出sum[i][j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预期输出（示例）"><a href="#预期输出（示例）" class="headerlink" title="预期输出（示例）"></a>预期输出（示例）</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入第一个2x3矩阵的元素（共6个整数）:</span></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line"><span class="section">请输入第二个2x3矩阵的元素（共6个整数）:</span></span><br><span class="line">6 5 4 3 2 1</span><br><span class="line"><span class="section">两个矩阵的和为:</span></span><br><span class="line">7 7 7</span><br><span class="line">7 7 7</span><br></pre></td></tr></table></figure>

<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ROW = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> COL = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> matrix1[ROW][COL];</span><br><span class="line">    <span class="type">int</span> matrix2[ROW][COL];</span><br><span class="line">    <span class="type">int</span> sum[ROW][COL];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入第一个矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入第一个2x3矩阵的元素（共6个整数）:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            std::cin &gt;&gt; matrix1[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入第二个矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入第二个2x3矩阵的元素（共6个整数）:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            std::cin &gt;&gt; matrix2[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个矩阵的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            sum[i][j] = matrix1[i][j] + matrix2[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;两个矩阵的和为:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; sum[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="练习题2：矩阵转置"><a href="#练习题2：矩阵转置" class="headerlink" title="练习题2：矩阵转置"></a>练习题2：矩阵转置</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个C++程序，输入一个<code>3x3</code>的矩阵，计算其转置矩阵，并输出结果。</p>
<h3 id="示例代码框架-1"><a href="#示例代码框架-1" class="headerlink" title="示例代码框架"></a>示例代码框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> matrix[SIZE][SIZE];</span><br><span class="line">    <span class="type">int</span> transpose[SIZE][SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入原始矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个3x3矩阵的元素（共9个整数）:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIZE; ++j) &#123;</span><br><span class="line">            <span class="comment">// 在此输入matrix[i][j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算转置矩阵</span></span><br><span class="line">    <span class="comment">// 在此实现转置逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转置后的矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;矩阵的转置为:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIZE; ++j) &#123;</span><br><span class="line">            <span class="comment">// 在此输出transpose[i][j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预期输出（示例）-1"><a href="#预期输出（示例）-1" class="headerlink" title="预期输出（示例）"></a>预期输出（示例）</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入一个3x3矩阵的元素（共9个整数）:</span></span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line"><span class="section">矩阵的转置为:</span></span><br><span class="line">1 4 7</span><br><span class="line">2 5 8</span><br><span class="line">3 6 9</span><br></pre></td></tr></table></figure>



<h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> matrix[SIZE][SIZE];</span><br><span class="line">    <span class="type">int</span> transpose[SIZE][SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入原始矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个3x3矩阵的元素（共9个整数）:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIZE; ++j) &#123;</span><br><span class="line">            std::cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算转置矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIZE; ++j) &#123;</span><br><span class="line">            transpose[j][i] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转置后的矩阵</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;矩阵的转置为:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIZE; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; transpose[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>感谢支持</p>
<p><img src="https://cdn.llfc.club/dashang.jpg" alt="https://cdn.llfc.club/dashang.jpg"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/20/cppbase14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/20/cppbase14/" itemprop="url">零基础C++(14) 数组知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-20T11:24:09+08:00">
                2024-10-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。</p>
<p><strong>与vector对比</strong></p>
<p><strong>相同点</strong></p>
<p>与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。</p>
<p><strong>不同点</strong></p>
<p>与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</p>
<p><strong>友情提示</strong></p>
<p>如果不清楚元素的确切个数，请使用vector。</p>
<h2 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h2><p>数组是一种复合类型。数组的声明形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 a[d];</span><br></pre></td></tr></table></figure>

<p>其中a是数组的名字，d是数组的维度。</p>
<p>维度说明了数组中元素的个数，因此必须大于0。</p>
<p>数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式</p>
<p>关于常量表达式我们可以复习一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">42</span>;</span><br><span class="line"><span class="comment">//常量表达式, 用constexpr修饰</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>定义数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不是常量表达式</span></span><br><span class="line">    <span class="type">unsigned</span> cnt = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">//常量表达式, 用constexpr修饰</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">//包含10个整数的数组</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//含有42个整数指针的数组</span></span><br><span class="line">    <span class="type">int</span> *parr[sz];</span><br><span class="line">    <span class="comment">//定义字符串数组，错误！cnt不是常量表达式,但是部分编译器可通过</span></span><br><span class="line">    std::string bad[cnt];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
</blockquote>
<h2 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h2><p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度。</p>
<p>如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；</p>
<p>相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 含有3个元素的数组，元素值分别是0，1，2</span></span><br><span class="line"><span class="type">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 维度是3的数组</span></span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//等价于a3[] = &#123;0,1,2,0,0&#125;</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//等价于a4[] = &#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;</span></span><br><span class="line">std::string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//错误，初始值过多</span></span><br><span class="line"><span class="comment">//int a5[2] = &#123;0,1,2&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h2><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//含有三个整数的数组</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 错误，不允许使用一个数组初始化另一个数组</span></span><br><span class="line"><span class="comment">// int a2[] = a;</span></span><br></pre></td></tr></table></figure>

<p><strong>友情提示</strong></p>
<blockquote>
<p>一些编译器支持数组的赋值，这就是所谓的编译器扩展（compiler extension）。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</p>
</blockquote>
<h2 id="理解复杂的数组声明"><a href="#理解复杂的数组声明" class="headerlink" title="理解复杂的数组声明"></a>理解复杂的数组声明</h2><p>和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。</p>
<p>在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//错误, 不存在引用的数组</span></span><br><span class="line"><span class="comment">//int&amp; refs[10] = /*?*/;</span></span><br><span class="line"><span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"><span class="comment">//arrRef 引用一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;</span><br></pre></td></tr></table></figure>

<p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>与标准库类型vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问。数组的索引从0开始，以一个包含10个元素的数组为例，它的索引从0到9，而非从1到10。</p>
<p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>); ++i)&#123;</span><br><span class="line">    std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>数组的大小可以用<code>sizeof(arr)</code>获取，要进一步计算获取其中的元素个数，我们可以使用<code>sizeof(arr)/sizeof(int)</code></p>
<p><strong>防止越界</strong></p>
<p>数组不具备越界检测，所以在使用下标访问数组元素的时候，一定要注意防止越界，不要超过或等于数组元素个数</p>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。</p>
<p>通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。</p>
<p>数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 第一个元素地址</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;first element: address is &quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 数组首地址</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;arr address is &quot;</span> &lt;&lt; arr &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 数组首地址</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;arr address is &quot;</span> &lt;&lt; &amp;arr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于 int * first_elem_addr = &amp;arr[0];</span></span><br><span class="line"><span class="type">int</span>* first_elem_addr = arr;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;first element address is &quot;</span> &lt;&lt; first_elem_addr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ia2是一个int类型的指针,指向ia的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(arr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当使用decltype关键字时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ia3是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(arr) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//错误，不能用整数指针给数组赋值</span></span><br><span class="line"><span class="comment">//ia3 = ia2;</span></span><br></pre></td></tr></table></figure>

<h2 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h2><p>介绍的内容相比，指向数组元素的指针拥有更多功能。</p>
<p>vector和string的迭代器。支持的运算，数组的指针全都支持。</p>
<p>例如，允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//p指向arr的第一个元素</span></span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"><span class="comment">//p指向arr[1]</span></span><br><span class="line">++p;</span><br></pre></td></tr></table></figure>

<p><strong>奇技淫巧</strong></p>
<p>就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// e指向arr[10],也就是最后一个元素的下一个位置</span></span><br><span class="line"><span class="type">int</span> *e = arr+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span>* b = arr; b != e; ++b)&#123;</span><br><span class="line">    std::cout &lt;&lt; *b &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>C++11的改进</strong></p>
<p>为了方便遍历数组，C++11提供了获取最后元素的下一个位置的指针，以及指向首元素的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> * beg = std::<span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="type">int</span> * end = std::<span class="built_in">end</span>(ia);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = beg; it != end; ++it)&#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>指向数组元素的指针可以执行的运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。</p>
<p>给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//等价于int *ip = &amp;arr[0];</span></span><br><span class="line"><span class="type">int</span> *ip = arr;</span><br><span class="line"><span class="comment">//ip2</span></span><br><span class="line"><span class="type">int</span> * ip2 = ip + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算数组元素个数</span></span><br><span class="line"><span class="keyword">auto</span> n = std::<span class="built_in">end</span>(arr) - std::<span class="built_in">begin</span>(arr);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;n is &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="解引用和指针运算的交互"><a href="#解引用和指针运算的交互" class="headerlink" title="解引用和指针运算的交互"></a>解引用和指针运算的交互</h2><p>指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> last = *(ia+<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;last is &quot;</span> &lt;&lt; last &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>表达式＊（ia+4）计算ia前进4个元素后的新地址，解引用该结果指针的效果等价于表达式ia[4]。</p>
<p>如果写成下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//等价于ia[0] + 4</span></span><br><span class="line"><span class="type">int</span> value = *ia + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h2 id="下标和指针的关系"><a href="#下标和指针的关系" class="headerlink" title="下标和指针的关系"></a>下标和指针的关系</h2><p>对数组执行下标运算其实是对指向数组元素的指针解引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//等价于ia[1]</span></span><br><span class="line"><span class="type">int</span> value = *(ia+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><blockquote>
<p>尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。</p>
</blockquote>
<p>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串（C-style character string）。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\0’）。一般利用指针来操作这些字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* msg = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>C标准库函数</strong></p>
<p>这些函数可用于操作C风格字符串，它们定义在cstring头文件中，cstring是C语言头文件string.h的C++版本。</p>
<table>
<thead>
<tr>
<th>函数示例</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>strlen(p)</td>
<td>返回p的长度，空字符不计算在内</td>
</tr>
<tr>
<td>strcmp(p1,p2)</td>
<td>比较p1和p2的是否相等，如果相等返回0，如果p1&gt;p2返回一个正值，如果p1&lt;p2返回一个负值</td>
</tr>
<tr>
<td>strcat(p1,p2)</td>
<td>将p2附加到p1之后，返回p1</td>
</tr>
<tr>
<td>strcpy(p1,p2)</td>
<td>将p2拷贝给p1，返回p1</td>
</tr>
</tbody></table>
<p><strong>新手雷区</strong></p>
<p>传入此类函数的指针必须指向以空字符作为结束的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;P&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//有风险，因为ca没有以\0结束，所以strlen可能访问越界</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(ca);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;len is &quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>此例中，ca虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下来。</p>
<p><strong>比较字符串</strong></p>
<p>比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string s1 = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">std::string s2 = <span class="string">&quot;A different string example&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(s1 &lt; s2)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 is less than s2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 is not less than s2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ca1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ca2[] = <span class="string">&quot;A different string example&quot;</span>;</span><br><span class="line"><span class="comment">//未定义的，视图比较两个无关地址</span></span><br><span class="line"><span class="keyword">if</span>(ca1 &lt; ca2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。如果两个字符串相等，strcmp返回0；如果前面的字符串较大，返回正值；如果后面的字符串较大，返回负值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和两个string比较大小功能一样</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1, ca2) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ca1 is less than ca2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ca1 is not less than ca2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接</strong></p>
<p>字符串拼接可采用strcpy</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>; <span class="comment">// 确保有足够的空间</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *src = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用strcpy</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest + <span class="built_in">strlen</span>(dest), src); <span class="comment">// 从dest的末尾开始复制src</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;After strcpy: &quot;</span> &lt;&lt; dest &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>strcat连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一个例子，直接使用strcat</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *src = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> anotherDest[<span class="number">40</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(anotherDest, src);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;After strcat: &quot;</span> &lt;&lt; anotherDest &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="与旧代码衔接"><a href="#与旧代码衔接" class="headerlink" title="与旧代码衔接"></a>与旧代码衔接</h2><p>很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和vector类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此，现代的C++程序不得不与那些充满了数组和/或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p>
<p><strong>混用string对象和C风格字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意返回const char *</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>

<p>顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char＊，从而确保我们不会改变字符数组的内容。</p>
<p>我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。</p>
<p><strong>使用数组初始化vector对象</strong></p>
<p>介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。</p>
<p>相反的，允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(std::begin(int_arr), std::end(int_arr))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : ivec)&#123;</span><br><span class="line">    std::cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="练习题1："><a href="#练习题1：" class="headerlink" title="练习题1："></a>练习题1：</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数 <code>my_strcpy</code>，其功能与标准库函数 <code>strcpy</code> 类似，用于将源字符串复制到目标字符串中。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li><strong>禁止使用</strong>标准库中的字符串操作函数（如 <code>strcpy</code>、<code>strlen</code> 等）。</li>
<li>函数应能够正确处理所有合法的C风格字符串，包括空字符串。</li>
<li>确保目标字符串有足够的内存来存放源字符串。</li>
<li>函数应返回目标字符串的指针。</li>
</ul>
<h3 id="示例代码框架"><a href="#示例代码框架" class="headerlink" title="示例代码框架"></a>示例代码框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的字符串复制函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在此实现函数逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* source = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">50</span>]; <span class="comment">// 确保目标有足够的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_strcpy</span>(destination, source);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source: &quot;</span> &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Source: Hello, World!</span></span><br><span class="line"><span class="section">Destination: Hello, World!</span></span><br></pre></td></tr></table></figure>



<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>遍历源字符串，逐个字符复制到目标字符串，直到遇到字符串结束符<code>&#39;\0&#39;</code>。</li>
<li>不要忘记在目标字符串末尾添加结束符<code>&#39;\0&#39;</code>。</li>
</ul>
<h3 id="答案实现"><a href="#答案实现" class="headerlink" title="答案实现"></a>答案实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的字符串复制函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个指针遍历源字符串</span></span><br><span class="line">    <span class="type">char</span>* original_dest = dest; <span class="comment">// 保存目标字符串的起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="comment">// 当源字符不是结束符</span></span><br><span class="line">        *dest = *src;       <span class="comment">// 复制字符</span></span><br><span class="line">        dest++;             <span class="comment">// 移动目标指针</span></span><br><span class="line">        src++;              <span class="comment">// 移动源指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在目标字符串末尾添加结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> original_dest; <span class="comment">// 返回目标字符串的起始地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* source = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">50</span>]; <span class="comment">// 确保目标有足够的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_strcpy</span>(destination, source);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source: &quot;</span> &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>函数原型</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<p>:</p>
<ul>
<li><code>dest</code>: 目标字符串的指针，指向预先分配好的足够空间的字符数组。</li>
<li><code>src</code>: 源字符串的指针，指向需要复制的字符串。</li>
</ul>
</li>
<li><p><strong>返回值</strong>: 返回目标字符串的指针，以便于链式调用。</p>
</li>
</ul>
</li>
<li><p><strong>实现细节</strong>:</p>
<ul>
<li>使用一个临时指针 <code>original_dest</code> 保存 <code>dest</code> 的起始地址，以便在函数结束时返回。</li>
<li>使用一个 <code>while</code> 循环遍历源字符串，逐个字符复制到目标字符串。</li>
<li>当源字符串的当前字符为 <code>&#39;\0&#39;</code> 时，结束复制，并在目标字符串末尾添加 <code>&#39;\0&#39;</code> 确保字符串终止。</li>
<li>返回 <code>original_dest</code> 指针。</li>
</ul>
</li>
<li><p><strong>主函数</strong>:</p>
<ul>
<li>定义一个源字符串 <code>source</code>。</li>
<li>定义一个足够大的目标字符数组 <code>destination</code>。</li>
<li>调用 <code>my_strcpy</code> 函数进行复制。</li>
<li>输出源字符串和目标字符串以验证复制的正确性。</li>
</ul>
</li>
</ol>
<h3 id="预期输出-1"><a href="#预期输出-1" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Source: Hello, World!</span></span><br><span class="line"><span class="section">Destination: Hello, World!</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>内存分配</strong>: 确保 <code>dest</code> 指向的内存区域足够大，以容纳源字符串和结束符 <code>&#39;\0&#39;</code>。</li>
<li><strong>安全性</strong>: 本实现没有进行边界检查。在实际应用中，建议使用更安全的方法，如<code>strncpy</code>，以防止缓冲区溢出。</li>
</ul>
<h2 id="练习题2："><a href="#练习题2：" class="headerlink" title="练习题2："></a>练习题2：</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数 <code>my_strcat</code>，其功能与标准库函数 <code>strcat</code> 类似，用于将源字符串追加到目标字符串的末尾。</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul>
<li><strong>禁止使用</strong>标准库中的字符串操作函数（如 <code>strcat</code>、<code>strlen</code> 等）。</li>
<li>函数应能够正确处理所有合法的C风格字符串，包括空字符串。</li>
<li>确保目标字符串有足够的内存来存放追加后的字符串。</li>
<li>函数应返回目标字符串的指针。</li>
</ul>
<h3 id="示例代码框架-1"><a href="#示例代码框架-1" class="headerlink" title="示例代码框架"></a>示例代码框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的字符串连接函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在此实现函数逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">100</span>] = <span class="string">&quot;Hello, &quot;</span>; <span class="comment">// 初始内容</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* source = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_strcat</span>(destination, source);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After concatenation: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预期输出-2"><a href="#预期输出-2" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">After concatenation:</span> <span class="string">Hello,</span> <span class="string">World!</span></span><br></pre></td></tr></table></figure>



<h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h3><ul>
<li>首先找到目标字符串中的结束符<code>&#39;\0&#39;</code>，然后从那里开始复制源字符串的内容。</li>
<li>确保在追加完成后，目标字符串依然以<code>&#39;\0&#39;</code>结尾。</li>
</ul>
<h3 id="答案实现-1"><a href="#答案实现-1" class="headerlink" title="答案实现"></a>答案实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的字符串连接函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* original_dest = dest; <span class="comment">// 保存目标字符串的起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到目标字符串的结束位置</span></span><br><span class="line">    <span class="keyword">while</span> (*dest != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从源字符串复制字符到目标字符串末尾</span></span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *dest = *src;</span><br><span class="line">        dest++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在连接后的字符串末尾添加结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> original_dest; <span class="comment">// 返回目标字符串的起始地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">100</span>] = <span class="string">&quot;Hello, &quot;</span>; <span class="comment">// 初始内容</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* source = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_strcat</span>(destination, source);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After concatenation: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>函数原型</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<p>:</p>
<ul>
<li><code>dest</code>: 目标字符串的指针，指向预先分配好的足够空间的字符数组，并且该数组包含一个以 <code>&#39;\0&#39;</code> 结尾的合法C风格字符串。</li>
<li><code>src</code>: 源字符串的指针，指向需要追加的字符串。</li>
</ul>
</li>
<li><p><strong>返回值</strong>: 返回目标字符串的指针，以便于链式调用。</p>
</li>
</ul>
</li>
<li><p><strong>实现细节</strong>:</p>
<ul>
<li>使用一个临时指针 <code>original_dest</code> 保存 <code>dest</code> 的起始地址，以便在函数结束时返回。</li>
<li>首先，使用一个 <code>while</code> 循环找到目标字符串 <code>dest</code> 的结束符 <code>&#39;\0&#39;</code>，使指针 <code>dest</code> 指向字符串的末尾。</li>
<li>然后，使用另一个 <code>while</code> 循环将源字符串 <code>src</code> 的字符一个个复制到 <code>dest</code> 的末尾。</li>
<li>在复制结束后，添加 <code>&#39;\0&#39;</code> 结束符。</li>
<li>返回 <code>original_dest</code> 指针。</li>
</ul>
</li>
<li><p><strong>主函数</strong>:</p>
<ul>
<li>初始化目标字符数组 <code>destination</code> 为 <code>&quot;Hello, &quot;</code>，并确保其有足够的空间容纳追加的内容。</li>
<li>定义一个源字符串 <code>source</code> 为 <code>&quot;World!&quot;</code>。</li>
<li>调用 <code>my_strcat</code> 函数将 <code>source</code> 追加到 <code>destination</code>。</li>
<li>输出连接后的字符串以验证结果。</li>
</ul>
</li>
</ol>
<h3 id="预期输出-3"><a href="#预期输出-3" class="headerlink" title="预期输出"></a>预期输出</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">After concatenation:</span> <span class="string">Hello,</span> <span class="string">World!</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>内存分配</strong>: 确保 <code>dest</code> 指向的内存区域足够大，以容纳原始字符串、追加的字符串以及结束符 <code>&#39;\0&#39;</code>。</li>
<li><strong>字符串终止</strong>: 在追加完成后，务必在目标字符串末尾添加 <code>&#39;\0&#39;</code>，以确保字符串正确终止。</li>
<li><strong>安全性</strong>: 本实现没有进行边界检查。在实际应用中，建议使用更安全的方法，如<code>strncat</code>，以防止缓冲区溢出。</li>
</ul>
<h3 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h3><p>感谢支持</p>
<p><img src="https://cdn.llfc.club/dashang.jpg" alt="https://cdn.llfc.club/dashang.jpg"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/12/cppbase13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/12/cppbase13/" itemprop="url">零基础C++(13) 迭代器用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-12T11:39:34+08:00">
                2024-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">C++ cppbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h2><p>迭代器（<code>Iterator</code>）是C++标准模板库（<code>STL</code>）中的一个重要概念，它提供了一种方法，按顺序访问容器（如<code>vector, list, map</code>等）中的元素，而无需暴露容器的内部表示。迭代器就像是一个指针，但它比指针更加安全，因为它只能访问容器内的元素，并且它的类型与容器紧密相关。</p>
<h2 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h2><p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器。如有下述语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>(); <span class="comment">//b和e的类型相同</span></span><br></pre></td></tr></table></figure>

<p>end成员则负责返回指向容器（或string对象）“尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后（off the end）”元素。</p>
<p>这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。</p>
<p><strong>特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。</strong></p>
<p>一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。在上面的例子中，使用auto关键字定义变量b和e，这两个变量的类型也就是begin和end的返回值类型，之后将对相关内容做更详细的介绍。</p>
<h2 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h2><p>符表3.6列举了迭代器支持的一些运算。使用==和！=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否则就说这两个迭代器不相等。</p>
<p><img src="https://cdn.llfc.club/1728711512535.jpg" alt="https://cdn.llfc.club/1728711512535.jpg"></p>
<p>和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素。</p>
<p>试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。举个例子，利用下标运算符把string对象的第一个字母改为了大写形式，下面利用迭代器实现同样的功能：</p>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//确保s非空</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">//第一个字母改为大写</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例和原来的程序一样，首先检查s是否为空，显然通过检查begin和end返回的结果是否一致就能做到这一点。如果返回的结果一样，说明s为空；</p>
<p>如果返回的结果不一样，说明s不为空，此时s中至少包含一个字符。</p>
<p>我们在if内部，声明了一个迭代器变量it并把begin返回的结果赋给它，这样就得到了指示s中第一个字符的迭代器，接下来通过解引用运算符将第一个字符更改为大写形式。</p>
<p>和原来的程序一样，输出结果将是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some string</span><br></pre></td></tr></table></figure>

<h4 id="自增运算"><a href="#自增运算" class="headerlink" title="自增运算"></a>自增运算</h4><p> 将迭代器从一个元素移动到另外一个元素迭代器使用递增（++）运算符。</p>
<p>来从一个元素移动到下一个元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递增是在整数值上“加1”，迭代器的递增则是将迭代器“向前移动一个位置”。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p>
</blockquote>
<p>把字符串中的第一个单词改为大写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string s2 = <span class="string">&quot;another string&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">    !<span class="built_in">isspace</span>(*it); ++it) &#123;</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANOTHER string</span><br></pre></td></tr></table></figure>

<p>循环首先用<code>s.begin</code>的返回值来初始化it，意味着it指示的是s中的第一个字符（如果有的话）。</p>
<p>条件部分检查是否已到达s的尾部，如果尚未到达，则将it解引用的结果传入<code>isspace</code>函数检查是否遇到了空白。</p>
<p>每次迭代的最后，执行<code>++it</code>令迭代器前移一个位置以访问s的下一个字符。</p>
<p>循环体内部和上一个程序if语句内的最后一句话一样，先解引用it，然后将结果传入<code>toupper</code>函数得到该字母对应的大写形式，再把这个大写字母重新赋值给it所指示的字符。</p>
<h2 id="关键概念：泛型编程"><a href="#关键概念：泛型编程" class="headerlink" title="关键概念：泛型编程"></a>关键概念：泛型编程</h2><p>原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用<code>！=</code>而非<code>&lt;</code>进行判断有点儿奇怪，</p>
<p>C++程序员习惯性地使用<code>！=</code>，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。</p>
<p>之前已经说过，只有<code>string</code>和<code>vector</code>等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了<code>==</code>和<code>！=</code>，但是它们中的大多数都没有定义<code>&lt;</code>运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用的到底是哪种容器类型。</p>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>就像不知道<code>string</code>和<code>vector</code>的<code>size_type</code>成员到底是什么类型一样，一般来说我们无须知道迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用<code>iterator</code>和<code>const_iterator</code>来表示迭代器的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器it, it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">// it2能读写string对象的字符</span></span><br><span class="line">std::string::iterator it2;</span><br><span class="line"><span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator it3;</span><br><span class="line"><span class="comment">// it4只能读字符,不能写字符</span></span><br><span class="line">std::string::const_iterator it4;</span><br></pre></td></tr></table></figure>

<p><code>const_iterator</code>和指向常量的指针差不多，能读取但不能修改它所指的元素值。相反，<code>iterator</code>的对象可读可写。</p>
<p>如果<code>vector</code>对象或<code>string</code>对象是一个常量，只能使用<code>const_iterator</code>；如果<code>vector</code>对象或<code>string</code>对象不是常量，那么既能使用<code>iterator</code>也能使用<code>const_iterator</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const_iterator 遍历</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = numbers.<span class="built_in">cbegin</span>(); it != numbers.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 读取元素值</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="术语：迭代器和迭代器类型"><a href="#术语：迭代器和迭代器类型" class="headerlink" title="术语：迭代器和迭代器类型"></a>术语：迭代器和迭代器类型</h3><p>迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象。</p>
<p>重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。</p>
<p>每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。</p>
<h3 id="begin和end运算符"><a href="#begin和end运算符" class="headerlink" title="begin和end运算符"></a>begin和end运算符</h3><p>begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，<code>begin</code>和<code>end</code>返回<code>const_iterator</code>；如果对象不是常量，返回<code>iterator</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="comment">//it1是 vector&lt;int&gt;的迭代器，</span></span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//it2是const vector&lt;int&gt;的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p><strong>c++11</strong></p>
<p>如果一个容器非常量，我们也可以通过分别是cbegin和cend：获取对应的常量迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();</span><br></pre></td></tr></table></figure>

<h3 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h3><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure>

<p><code>(*it).empty()</code>中的圆括号必不可少，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符。</p>
<p>如果不加圆括号，点运算符将由it来执行将报错</p>
<p><strong>完整案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vs.<span class="built_in">begin</span>(); it != vs.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    <span class="comment">//(*it)解引用获取string对象，再次调用empty()方法判断为空</span></span><br><span class="line">    <span class="keyword">if</span>((*it).<span class="built_in">empty</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;empty string&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了简化上述表达式，C++语言定义了箭头运算符（-&gt;）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</p>
<p>例如，假设用一个名为text的字符串向量存放文本文件中的数据，其中的元素或者是一句话或者是一个用于表示段落分隔的空字符串。如果要输出text中第一段的内容，可以利用迭代器写一个循环令其遍历text，直到遇到空字符串的元素为止：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次输出text的每一行直到遇到第一个空行为止</span></span><br><span class="line">std::vector&lt;std::string&gt; text = &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;world&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = text.<span class="built_in">cbegin</span>(); it != text.<span class="built_in">cend</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先初始化it令其指向text的第一个元素，循环重复执行直至处理完了text的所有元素或者发现某个元素为空。</p>
<p>每次迭代时只要发现还有元素并且尚未遇到空元素，就输出当前正在处理的元素。</p>
<p>值得注意的是，因为循环从头到尾只是读取text的元素而未向其中写值，所以使用了<code>cbegin</code>和<code>cend</code>来控制整个迭代过程。</p>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>曾经介绍过，虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意下面逻辑错误，在for循环中push元素导致死循环</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也不要在循环中执行push操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意下面逻辑错误，在for循环中push元素导致迭代器失效,也会导致死循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们执行删除操作也要注意，我们可以通过vector的erase操作删除迭代器指向的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第一个元素</span></span><br><span class="line">numbers.<span class="built_in">erase</span>(numbers.<span class="built_in">begin</span>() );</span><br></pre></td></tr></table></figure>

<p>erase会返回删除元素的下一个元素的迭代器</p>
<p><strong>面试题</strong></p>
<p>vector<int>容器存储了一系列数字，在循环中遍历每一个元素，并且删除其中的奇数，要求循环结束，vector元素为偶数，要求时间复杂度o(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//循环遍历,并删除其中奇数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="comment">// 删除奇数</span></span><br><span class="line">    <span class="keyword">if</span>(*it % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        it = numbers.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>



<h3 id="迭代器运算-1"><a href="#迭代器运算-1" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算的迭代器。</p>
<p>类似的，也能用==和！=对任意标准库类型的两个有效迭代器，进行比较。</p>
<p>string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算（iterator arithmetic）。</p>
<p><img src="https://cdn.llfc.club/1728788292262.jpg" alt="https://cdn.llfc.club/1728788292262.jpg"></p>
<p><strong>迭代器的算术运算</strong></p>
<p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。</p>
<p>执行这样的操作时，结果迭代器或者指示原vector对象（或string对象）内的一个元素，或者指示原vector对象（或string对象）尾元素的下一位置。</p>
<p>举个例子，下面的代码得到一个迭代器，它指向某vector对象中间位置的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//中间位置的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> mid = numbers.<span class="built_in">begin</span>() + numbers.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//判断迭代器是否有效</span></span><br><span class="line"><span class="keyword">if</span>(mid != numbers.<span class="built_in">end</span>())&#123;</span><br><span class="line">    std::cout &lt;&lt; *mid &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mid is end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mid指向了中间的元素3</p>
<h3 id="使用迭代器运算"><a href="#使用迭代器运算" class="headerlink" title="使用迭代器运算"></a>使用迭代器运算</h3><p>使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。</p>
<p>二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜索完成；</p>
<p>如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素；</p>
<p>假如该元素大于要找的元素，则在序列的前半部分继续搜索。</p>
<p>在缩小的范围中计算一个新的中间元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。</p>
<p>下面的程序使用迭代器完成了二分搜索：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//二分查找4所在的迭代器为止</span></span><br><span class="line"><span class="keyword">auto</span> beg = numbers.<span class="built_in">begin</span>(), end = numbers.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">while</span>(mid != end &amp;&amp; *mid != <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">//4在mid的右边</span></span><br><span class="line">    <span class="keyword">if</span>(*mid &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//4在mid的左边</span></span><br><span class="line">        end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mid != end)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4 is found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4 is not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的一开始定义了三个迭代器：<code>beg</code>指向搜索范围内的第一个元素、<code>end</code>指向尾元素的下一位置、mid指向中间的那个元素。</p>
<p>初始状态下，搜索范围是名为<code>numbers</code>的<code>vector&lt;int&gt;</code>的全部范围。</p>
<p>循环部分先检查搜索范围是否为空，如果mid和end的当前值相等，说明已经找遍了所有元素。</p>
<p>此时条件不满足，循环终止。当搜索范围不为空时，可知<code>mid</code>指向了某个元素，检查该元素是否就是我们所要搜索的，如果是，也终止循环。</p>
<p>当进入到循环体内部后，程序通过某种规则移动<code>beg</code>或者<code>end</code>来缩小搜索的范围。</p>
<p>如果mid所指的元素比要找的元素4大，可推测若numbers含有4，则必出现在mid所指元素的前面。此时，可以忽略mid后面的元素不再查找，并把mid赋给end即可。</p>
<p>另一种情况，如果＊mid比4小，则要找的元素必出现在mid所指元素的后面。此时，通过令beg指向mid的下一个位置即可改变搜索范围。因为已经验证过mid不是我们要找的对象，所以在接下来的搜索中不必考虑它。</p>
<p>循环过程终止时，mid或者等于end或者指向要找的元素。如果mid等于end，说明numbers中没有我们要找的元素。</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1-相邻元素的和"><a href="#1-相邻元素的和" class="headerlink" title="1 相邻元素的和"></a>1 相邻元素的和</h3><p><strong>题目描述：</strong><br> 编写一个程序，读取一组整数到一个 <code>std::vector</code> 中，并打印每对相邻元素的和。例如，给定输入 <code>1 2 3 4</code>，输出应为 <code>3 5 7</code>。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一组整数（以 -1 结束）: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; num &amp;&amp; num != <span class="number">-1</span>) &#123;</span><br><span class="line">        numbers.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;相邻元素的和: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it + <span class="number">1</span> != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; (*it + *(it + <span class="number">1</span>)) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>答案：</strong></p>
<ul>
<li>输入示例：<code>1 2 3 4 -1</code></li>
<li>输出示例：<code>相邻元素的和: 3 5 7</code></li>
</ul>
<h3 id="2-反向打印"><a href="#2-反向打印" class="headerlink" title="2 反向打印"></a>2 反向打印</h3><p><strong>描述：</strong> 编写一个程序，从用户输入一组整数到一个 <code>std::vector</code> 中，然后使用迭代器反向打印这些元素。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一组整数（输入-1结束输入）：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; input &amp;&amp; input != <span class="number">-1</span>) &#123;</span><br><span class="line">        numbers.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;反向打印结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::reverse_iterator it = numbers.<span class="built_in">rbegin</span>(); it != numbers.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 -1</span><br></pre></td></tr></table></figure>



<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反向打印结果：5 4 3 2 1 </span><br></pre></td></tr></table></figure>

<h3 id="3-合并两个-vector"><a href="#3-合并两个-vector" class="headerlink" title="3 合并两个 vector"></a>3 合并两个 <code>vector</code></h3><p><strong>描述：</strong> 编写一个程序，创建两个 <code>std::vector</code>，从用户输入填充它们。使用迭代器将这两个 <code>vector</code> 合并为一个新 <code>vector</code>。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vector1, vector2, mergedVector;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入第一个向量的整数（输入-1结束输入）：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; input &amp;&amp; input != <span class="number">-1</span>) &#123;</span><br><span class="line">        vector1.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入第二个向量的整数（输入-1结束输入）：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; input &amp;&amp; input != <span class="number">-1</span>) &#123;</span><br><span class="line">        vector2.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个向量</span></span><br><span class="line">    mergedVector.<span class="built_in">insert</span>(mergedVector.<span class="built_in">end</span>(), vector1.<span class="built_in">begin</span>(), vector1.<span class="built_in">end</span>());</span><br><span class="line">    mergedVector.<span class="built_in">insert</span>(mergedVector.<span class="built_in">end</span>(), vector2.<span class="built_in">begin</span>(), vector2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;合并后的向量结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = mergedVector.<span class="built_in">begin</span>(); it != mergedVector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例输入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 -1</span><br><span class="line">4 5 6 -1</span><br></pre></td></tr></table></figure>



<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后的向量结果：1 2 3 4 5 6 </span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/3/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">367</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/secondtonone1" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" target="_blank" title="ZhiHu">
                    
                      <i class="fa fa-fw fa-ZhiHu"></i>ZhiHu</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恋恋风辰</span>

  
  
 
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
 
 
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
