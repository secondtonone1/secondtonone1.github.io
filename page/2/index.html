<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="恋恋风辰的个人博客" type="application/atom+xml" />






<meta name="description" content="重剑无锋，大巧不工">
<meta property="og:type" content="website">
<meta property="og:title" content="恋恋风辰的个人博客">
<meta property="og:url" content="http://www.limerence2017.com/page/2/index.html">
<meta property="og:site_name" content="恋恋风辰的个人博客">
<meta property="og:description" content="重剑无锋，大巧不工">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="恋恋风辰">
<meta property="article:tag" content="C++ python 大并发网络 逆向">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.limerence2017.com/page/2/"/>





  <title>恋恋风辰的个人博客</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恋恋风辰的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/06/cppbase23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/06/cppbase23/" itemprop="url">零基础C++(23) 智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-06T10:57:07+08:00">
                2024-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 <code>new</code> 和 <code>delete</code> 带来的复杂性和错误。智能指针通过 <code>RAII</code>（资源获取即初始化）机制，在对象生命周期结束时自动释放资源，从而有效防止内存泄漏和资源管理错误。</p>
<h2 id="2-原生指针-vs-智能指针"><a href="#2-原生指针-vs-智能指针" class="headerlink" title="2. 原生指针 vs 智能指针"></a>2. 原生指针 vs 智能指针</h2><h3 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h3><p>原生指针是 C++ 最基本的指针类型，允许程序员直接管理内存。然而，原生指针存在以下问题：</p>
<ul>
<li><strong>内存泄漏</strong>：未释放动态分配的内存。</li>
<li><strong>悬挂指针</strong>：指针指向已释放或未初始化的内存。</li>
<li><strong>双重释放</strong>：多次释放同一内存区域。</li>
</ul>
<h3 id="智能指针的优势"><a href="#智能指针的优势" class="headerlink" title="智能指针的优势"></a>智能指针的优势</h3><p>智能指针通过封装原生指针，自动管理内存，解决上述问题。主要优势包括：</p>
<ul>
<li><strong>自动销毁</strong>：在智能指针生命周期结束时自动释放资源。</li>
<li><strong>引用计数</strong>：共享智能指针能够跟踪引用数量，确保资源在最后一个引用结束时释放。</li>
<li><strong>避免内存泄漏</strong>：通过 RAII 机制自动管理资源生命周期。</li>
<li><strong>类型安全</strong>：提供更严格的类型检查，减少错误。</li>
</ul>
<h2 id="3-std-unique-ptr"><a href="#3-std-unique-ptr" class="headerlink" title="3. std::unique_ptr"></a>3. <code>std::unique_ptr</code></h2><h3 id="3-1-定义与用法"><a href="#3-1-定义与用法" class="headerlink" title="3.1 定义与用法"></a>3.1 定义与用法</h3><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，任何时刻只能有一个 <code>unique_ptr</code> 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。</p>
<p><strong>主要特性</strong>：</p>
<ul>
<li><strong>独占所有权</strong>：确保资源在一个所有者下。</li>
<li><strong>轻量级</strong>：没有引用计数，开销小。</li>
<li><strong>自动释放</strong>：在指针销毁时自动释放资源。</li>
</ul>
<h3 id="3-2-构造函数与赋值"><a href="#3-2-构造函数与赋值" class="headerlink" title="3.2 构造函数与赋值"></a>3.2 构造函数与赋值</h3><p><code>unique_ptr</code> 提供多种构造函数和赋值操作，以支持不同的使用场景。</p>
<ul>
<li><strong>默认构造函数</strong>：创建一个空的 <code>unique_ptr</code>。</li>
<li><strong>指针构造函数</strong>：接受一个裸指针，拥有其所有权。</li>
<li><strong>移动构造函数</strong>：将一个 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li>
<li><strong>移动赋值操作符</strong>：将一个 <code>unique_ptr</code> 的所有权转移到另一个 <code>unique_ptr</code>。</li>
</ul>
<h3 id="3-3-移动语义"><a href="#3-3-移动语义" class="headerlink" title="3.3 移动语义"></a>3.3 移动语义</h3><p>由于 <code>unique_ptr</code> 不能被拷贝，必须通过移动语义转移所有权。这保证了资源的独占性。</p>
<h3 id="3-4-代码案例"><a href="#3-4-代码案例" class="headerlink" title="3.4 代码案例"></a>3.4 代码案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unique_ptr</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 make_unique（C++14 引入）</span></span><br><span class="line">    <span class="keyword">auto</span> ptr2 = std::<span class="built_in">make_unique</span>&lt;Test&gt;(<span class="number">200</span>);</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动 unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Test&gt; ptr3 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr3-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 unique_ptr</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">300</span>));</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr 自动释放资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">ptr1</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">move.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><code>ptr1</code> 拥有 <code>Test(100)</code>，<code>ptr2</code> 拥有 <code>Test(200)</code>。</li>
<li>通过 <code>std::move</code> 将 <code>ptr1</code> 的所有权转移到 <code>ptr3</code>，<code>ptr1</code> 变为空。</li>
<li><code>ptr2.reset(new Test(300))</code> 释放了原有的 <code>Test(200)</code>，并拥有新的 <code>Test(300)</code>。</li>
<li>程序结束时，<code>ptr3</code> 和 <code>ptr2</code> 自动释放各自拥有的资源。</li>
</ul>
<h2 id="4-std-shared-ptr"><a href="#4-std-shared-ptr" class="headerlink" title="4. std::shared_ptr"></a>4. <code>std::shared_ptr</code></h2><h3 id="4-1-定义与用法"><a href="#4-1-定义与用法" class="headerlink" title="4.1 定义与用法"></a>4.1 定义与用法</h3><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，允许多个 <code>shared_ptr</code> 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。</p>
<p><strong>主要特性</strong>：</p>
<ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可以指向同一个对象。</li>
<li><strong>引用计数</strong>：跟踪有多少 <code>shared_ptr</code> 实例指向同一对象。</li>
<li><strong>自动释放</strong>：当引用计数为0时，自动释放资源。</li>
</ul>
<h3 id="4-2-引用计数与控制块"><a href="#4-2-引用计数与控制块" class="headerlink" title="4.2 引用计数与控制块"></a>4.2 引用计数与控制块</h3><p><code>shared_ptr</code> 背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括：</p>
<ul>
<li><strong>强引用计数（<code>use_count</code>）</strong>：表示有多少个 <code>shared_ptr</code> 指向对象。</li>
<li><strong>弱引用计数（<code>weak_count</code>）</strong>：表示有多少个 <code>weak_ptr</code> 指向对象（不增加强引用计数）。</li>
</ul>
<h3 id="4-3-构造函数与赋值"><a href="#4-3-构造函数与赋值" class="headerlink" title="4.3 构造函数与赋值"></a>4.3 构造函数与赋值</h3><p><code>shared_ptr</code> 提供多种构造函数和赋值操作，以支持不同的使用场景。</p>
<ul>
<li><strong>默认构造函数</strong>：创建一个空的 <code>shared_ptr</code>。</li>
<li><strong>指针构造函数</strong>：接受一个裸指针，拥有其所有权。</li>
<li><strong>拷贝构造函数</strong>：增加引用计数，共享对象所有权。</li>
<li><strong>移动构造函数</strong>：转移所有权，源 <code>shared_ptr</code> 变为空。</li>
<li><strong>拷贝赋值操作符</strong>：释放当前资源，增加引用计数，指向新对象。</li>
<li><strong>移动赋值操作符</strong>：释放当前资源，转移所有权，源 <code>shared_ptr</code> 变为空。</li>
</ul>
<h3 id="4-4-代码案例"><a href="#4-4-代码案例" class="headerlink" title="4.4 代码案例"></a>4.4 代码案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sp1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过拷贝构造共享所有权</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp2 = sp1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp2 = sp1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过拷贝赋值共享所有权</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp3;</span><br><span class="line">    sp3 = sp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp3 = sp2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 shared_ptr</span></span><br><span class="line">    sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">200</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After sp2.reset(new Test(200)):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动释放资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">100</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp2</span> <span class="string">=</span> <span class="attr">sp1:</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp3</span> <span class="string">=</span> <span class="attr">sp2:</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">sp3 use_count:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="string">After</span> <span class="string">sp2.reset(new</span> <span class="string">Test(200)):</span></span><br><span class="line"><span class="attr">sp1 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">sp2 use_count:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">sp3 use_count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">200</span></span><br><span class="line"><span class="string">Exiting</span> <span class="string">main...</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><p>创建 <code>sp1</code>，引用计数为1。</p>
</li>
<li><p>拷贝构造 <code>sp2</code>，引用计数增加到2。</p>
</li>
<li><p>拷贝赋值 <code>sp3</code>，引用计数增加到3。</p>
</li>
<li><p>```<br>sp2.reset(new Test(200))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 原 `Test(100)` 的引用计数减少到2。</span><br><span class="line">  - 分配新的 `Test(200)`，`sp2` 拥有它，引用计数为1。</span><br><span class="line"></span><br><span class="line">- 程序结束时：</span><br><span class="line"></span><br><span class="line">  - `sp1` 和 `sp3` 释放 `Test(100)`，引用计数降到0，资源被销毁。</span><br><span class="line">  - `sp2` 释放 `Test(200)`，引用计数为0，资源被销毁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5. `std::weak_ptr`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.1 定义与用法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`std::weak_ptr` 是一种不拥有对象所有权的智能指针，用于观察但不影响对象的生命周期。主要用于解决 `shared_ptr` 之间的循环引用问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**主要特性**：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **非拥有所有权**：不增加引用计数。</span><br><span class="line">- **可从 `shared_ptr` 生成**：通过 `std::weak_ptr` 可以访问 `shared_ptr` 管理的对象。</span><br><span class="line">- **避免循环引用**：适用于双向关联或观察者模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.2 避免循环引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在存在双向关联（如父子关系）时，使用多个 `shared_ptr` 可能导致循环引用，导致内存泄漏。此时，可以使用 `weak_ptr` 来打破循环。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.3 代码案例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 场景：双向关联导致循环引用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class B; // 前向声明</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB;</span><br><span class="line"></span><br><span class="line">    A() &#123; std::cout &lt;&lt; &quot;A Constructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~A() &#123; std::cout &lt;&lt; &quot;A Destructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA;</span><br><span class="line"></span><br><span class="line">    B() &#123; std::cout &lt;&lt; &quot;B Constructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~B() &#123; std::cout &lt;&lt; &quot;B Destructor&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();</span><br><span class="line">        a-&gt;ptrB = b;</span><br><span class="line">        b-&gt;ptrA = a;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Exiting main...&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> Constructor</span><br><span class="line"><span class="selector-tag">B</span> Constructor</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br><span class="line"><span class="selector-tag">A</span> Destructor</span><br><span class="line"><span class="selector-tag">B</span> Destructor</span><br></pre></td></tr></table></figure>



<p><strong>问题</strong>：</p>
<p>虽然 <code>a</code> 和 <code>b</code> 离开作用域，但 <code>A Destructor</code> 和 <code>B Destructor</code> 并未被调用，因为 <code>a</code> 和 <code>b</code> 相互引用，引用计数无法降到0，导致内存泄漏。</p>
<h4 id="解决方案：使用-weak-ptr"><a href="#解决方案：使用-weak-ptr" class="headerlink" title="解决方案：使用 weak_ptr"></a>解决方案：使用 <code>weak_ptr</code></h4><p>改用 <code>weak_ptr</code> 其中一方（如 <code>B</code> 的 <code>ptrA</code>），打破循环引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; ptrA; <span class="comment">// 使用 weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        a-&gt;ptrB = b;</span><br><span class="line">        b-&gt;ptrA = a;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> Constructor</span><br><span class="line"><span class="selector-tag">B</span> Constructor</span><br><span class="line"><span class="selector-tag">A</span> Destructor</span><br><span class="line"><span class="selector-tag">B</span> Destructor</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><code>B</code> 使用 <code>weak_ptr</code> 指向 <code>A</code>，不增加引用计数。</li>
<li><code>a</code> 和 <code>b</code> 离开作用域，引用计数降为0，资源被正确释放。</li>
<li>防止了循环引用，避免了内存泄漏。</li>
</ul>
<h3 id="5-4-访问-weak-ptr-指向的对象"><a href="#5-4-访问-weak-ptr-指向的对象" class="headerlink" title="5.4 访问 weak_ptr 指向的对象"></a>5.4 访问 <code>weak_ptr</code> 指向的对象</h3><p><code>weak_ptr</code> 不能直接访问对象，需要通过 <code>lock()</code> 方法转换为 <code>shared_ptr</code>，并检查对象是否仍然存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *locked &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object no longer exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = wp.<span class="built_in">lock</span>()) &#123; <span class="comment">// 再次尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *locked &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object no longer exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Value:</span> <span class="number">42</span></span><br><span class="line"><span class="type">Object</span> no longer exists.</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li><code>wp.lock()</code> 返回一个 <code>shared_ptr</code>，如果对象依然存在，则有效。</li>
<li><code>sp.reset()</code> 释放资源后，<code>wp.lock()</code> 无法获取有效的 <code>shared_ptr</code>。</li>
</ul>
<h2 id="6-自定义删除器"><a href="#6-自定义删除器" class="headerlink" title="6. 自定义删除器"></a>6. 自定义删除器</h2><h3 id="6-1-用例与实现"><a href="#6-1-用例与实现" class="headerlink" title="6.1 用例与实现"></a>6.1 用例与实现</h3><p>有时，默认的 <code>delete</code> 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。</p>
<h3 id="6-2-代码案例"><a href="#6-2-代码案例" class="headerlink" title="6.2 代码案例"></a>6.2 代码案例</h3><h4 id="用例：管理-FILE-资源"><a href="#用例：管理-FILE-资源" class="headerlink" title="用例：管理 FILE* 资源"></a>用例：管理 FILE* 资源</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileDeleter</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Closing file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), FileDeleter())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (filePtr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 使用 filePtr 进行文件操作</span></span><br><span class="line">            <span class="built_in">fprintf</span>(filePtr.<span class="built_in">get</span>(), <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 自动关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully.</span><br><span class="line">Closing file.</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li>自定义删除器 <code>FileDeleter</code> 用于在 <code>shared_ptr</code> 被销毁时关闭文件。</li>
<li>使用 <code>filePtr.get()</code> 获取原生 <code>FILE*</code> 指针进行文件操作。</li>
<li>离开作用域时，自动调用 <code>FileDeleter</code> 关闭文件。</li>
</ul>
<h3 id="6-3-使用-Lambda-表达式作为删除器"><a href="#6-3-使用-Lambda-表达式作为删除器" class="headerlink" title="6.3 使用 Lambda 表达式作为删除器"></a>6.3 使用 Lambda 表达式作为删除器</h3><p>C++11 允许使用 lambda 表达式作为删除器，简化代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fileDeleter = [](FILE* fp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Closing file via lambda.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(fileDeleter)</span>&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), fileDeleter)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (filePtr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fprintf</span>(filePtr.<span class="built_in">get</span>(), <span class="string">&quot;Hello, Lambda!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 自动关闭文件</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File opened successfully.</span><br><span class="line">Closing file via lambda.</span><br><span class="line">Exiting <span class="selector-tag">main</span>...</span><br></pre></td></tr></table></figure>



<p><strong>解析</strong>：</p>
<ul>
<li>使用 <code>std::unique_ptr</code> 搭配 lambda 删除器管理 <code>FILE*</code>。</li>
<li>提供了更灵活和简洁的删除器实现。</li>
</ul>
<h2 id="7-最佳实践与常见陷阱"><a href="#7-最佳实践与常见陷阱" class="headerlink" title="7. 最佳实践与常见陷阱"></a>7. 最佳实践与常见陷阱</h2><h3 id="7-1-选择合适的智能指针"><a href="#7-1-选择合适的智能指针" class="headerlink" title="7.1 选择合适的智能指针"></a>7.1 选择合适的智能指针</h3><ul>
<li>**<code>std::unique_ptr</code>**：<ul>
<li>用于明确的独占所有权场景。</li>
<li>适用于资源的单一管理者或需要所有权转移的情况。</li>
<li>更轻量，性能更优。</li>
</ul>
</li>
<li>**<code>std::shared_ptr</code>**：<ul>
<li>用于共享所有权的场景。</li>
<li>需要多个指针共同管理同一资源时使用。</li>
<li>引用计数带来一定的性能开销。</li>
</ul>
</li>
<li>**<code>std::weak_ptr</code>**：<ul>
<li>用于观察不拥有资源的场景。</li>
<li>适用于需要避免循环引用或只需临时访问资源的情况。</li>
</ul>
</li>
</ul>
<h3 id="7-2-避免循环引用"><a href="#7-2-避免循环引用" class="headerlink" title="7.2 避免循环引用"></a>7.2 避免循环引用</h3><p>在使用 <code>shared_ptr</code> 时，特别是在对象间存在双向引用时，容易导致循环引用，内存泄漏。使用 <code>weak_ptr</code> 打破循环引用。</p>
<h3 id="7-3-使用-make-shared-与-make-unique"><a href="#7-3-使用-make-shared-与-make-unique" class="headerlink" title="7.3 使用 make_shared 与 make_unique"></a>7.3 使用 <code>make_shared</code> 与 <code>make_unique</code></h3><p>优先使用 <code>make_shared</code> 和 <code>make_unique</code> 来创建智能指针，避免直接使用 <code>new</code>，提高效率和异常安全性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">auto</span> up = std::<span class="built_in">make_unique</span>&lt;Test&gt;(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>



<h3 id="7-4-不要混用原生指针与智能指针"><a href="#7-4-不要混用原生指针与智能指针" class="headerlink" title="7.4 不要混用原生指针与智能指针"></a>7.4 不要混用原生指针与智能指针</h3><p>避免在智能指针管理的对象上同时使用原生指针进行管理，防止重复释放或不安全访问。</p>
<h3 id="7-5-理解智能指针的所有权语义"><a href="#7-5-理解智能指针的所有权语义" class="headerlink" title="7.5 理解智能指针的所有权语义"></a>7.5 理解智能指针的所有权语义</h3><p>深入理解不同智能指针的所有权规则，避免误用导致资源管理错误。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>智能指针是 C++ 中强大的资源管理工具，通过封装原生指针，提供自动化的内存管理，极大地减少了内存泄漏和资源管理错误。<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 各有其应用场景，理解它们的差异和使用方法对于编写安全、高效的 C++ 代码至关重要。此外，通过实现自己的智能指针（如 <code>SimpleSharedPtr</code>），可以更深入地理解智能指针的工作原理，为高级 C++ 编程打下坚实基础。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/06/cppbase24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/06/cppbase24/" itemprop="url">零基础C++(24) 可调用对象function类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-06T10:57:07+08:00">
                2024-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C++ 提供了多种方式来表示和操作可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code> 和 <code>std::bind</code> 等。这些工具极大地增强了C++的灵活性和表达能力，尤其在处理回调、事件驱动编程和函数式编程时表现尤为出色。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是C++中最基本的可调用对象之一，用于指向普通函数和静态成员函数。</p>
<h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>函数指针的定义涉及到函数的返回类型和参数列表。例如，定义一个指向返回 <code>int</code> 且接受两个 <code>int</code> 参数的函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给函数指针赋值</span></span><br><span class="line">    funcPtr = &amp;add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">funcPtr</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出: 结果: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优点与局限性"><a href="#优点与局限性" class="headerlink" title="优点与局限性"></a>优点与局限性</h3><p><strong>优点:</strong></p>
<ul>
<li>简单直观，适用于简单的回调函数。</li>
</ul>
<p><strong>局限性:</strong></p>
<ul>
<li>不能捕获上下文（如lambda中的闭包）。</li>
<li>语法相对复杂，尤其是指针的声明和使用。</li>
</ul>
<hr>
<h2 id="仿函数（Functors）"><a href="#仿函数（Functors）" class="headerlink" title="仿函数（Functors）"></a>仿函数（Functors）</h2><p><strong>仿函数（Functors）</strong>，又称<strong>函数对象（Function Objects）</strong>，是在C++中重载了 <code>operator()</code> 的类或结构体实例。仿函数不仅可以像普通函数一样被调用，还能携带状态，提供更大的灵活性和功能性。</p>
<h3 id="定义与使用-1"><a href="#定义与使用-1" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>仿函数是通过定义一个类或结构体，并重载其调用运算符 <code>operator()</code> 来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="type">int</span> to_add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> value) : <span class="built_in">to_add</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + to_add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">add5</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个添加5的仿函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 10 + 5 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>携带状态：</strong> 仿函数可以拥有内部状态，通过成员变量存储数据，使其在调用时具备上下文信息。</li>
<li><strong>灵活性高：</strong> 可以根据需要添加更多的成员函数和变量，扩展功能。</li>
<li><strong>性能优化：</strong> 编译器可以对仿函数进行优化，例如内联展开，提高执行效率。</li>
</ol>
<h3 id="高级示例"><a href="#高级示例" class="headerlink" title="高级示例"></a>高级示例</h3><p>仿函数不仅可以执行简单的计算，还可以进行复杂的操作。例如，实现一个可变的仿函数，用于累加多个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变累加器仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Accumulator</span>() : <span class="built_in">sum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Accumulator acc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">acc</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;总和: &quot;</span> &lt;&lt; acc.sum &lt;&lt; std::endl; <span class="comment">// 输出: 总和: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用仿函数的标准库算法"><a href="#使用仿函数的标准库算法" class="headerlink" title="使用仿函数的标准库算法"></a>使用仿函数的标准库算法</h3><p>许多标准库算法可以接受仿函数作为参数，使得算法的行为更加灵活和可定制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数：判断一个数是否大于某个阈值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsGreaterThan</span> &#123;</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IsGreaterThan</span>(<span class="type">int</span> t) : <span class="built_in">threshold</span>(t) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行筛选</span></span><br><span class="line">    <span class="function">IsGreaterThan <span class="title">greaterThan10</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), greaterThan10);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个大于10的数是: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 输出: 第一个大于10的数是: 15</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于10的数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="仿函数与模板"><a href="#仿函数与模板" class="headerlink" title="仿函数与模板"></a>仿函数与模板</h3><p>仿函数与模板相结合，可以实现高度通用和可复用的代码。例如，编写一个通用的比较仿函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用比较仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">Compare</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 5 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="仿函数的优势"><a href="#仿函数的优势" class="headerlink" title="仿函数的优势"></a>仿函数的优势</h3><ul>
<li><strong>可扩展性：</strong> 能够根据需要添加更多功能和状态。</li>
<li><strong>与Lambda的互补性：</strong> 在需要携带复杂状态或多次调用时，仿函数比Lambda更适合。</li>
<li><strong>类型安全：</strong> 仿函数是具体的类型，可以在编译期进行类型检查。</li>
</ul>
<h3 id="何时使用仿函数"><a href="#何时使用仿函数" class="headerlink" title="何时使用仿函数"></a>何时使用仿函数</h3><ul>
<li><strong>需要携带状态时：</strong> 当回调函数需要维护内部状态时，仿函数是理想选择。</li>
<li><strong>复杂操作：</strong> 当简单的函数指针或Lambda难以表达复杂逻辑时。</li>
<li><strong>性能关键场景：</strong> 由于仿函数可以被编译器优化，适用于性能敏感的代码。</li>
</ul>
<hr>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是C++11引入的一种轻量级函数对象，允许在代码中定义匿名函数。它们可以捕获周围的变量，具有更强的表达能力。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[captures](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>captures</strong>: 捕获外部变量的方式，可以是值捕获、引用捕获或者混合捕获。</li>
<li><strong>parameters</strong>: 参数列表。</li>
<li><strong>return_type</strong>: 返回类型，可以省略，编译器会自动推导。</li>
<li><strong>函数体</strong>: 实际执行的代码。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式进行过滤</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">        [threshold](<span class="type">int</span> n) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n &lt; threshold;</span><br><span class="line">        &#125;), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 6 8 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="捕获方式"><a href="#捕获方式" class="headerlink" title="捕获方式"></a>捕获方式</h3><ol>
<li><strong>值捕获 (<code>[=]</code>)</strong>: 捕获所有外部变量的副本。</li>
<li><strong>引用捕获 (<code>[&amp;]</code>)</strong>: 捕获所有外部变量的引用。</li>
<li><strong>混合捕获</strong>: 指定部分变量按值捕获，部分按引用捕获，如 <code>[=, &amp;var]</code> 或 <code>[&amp;, var]</code>。</li>
<li><strong>无捕获 (<code>[]</code>)</strong>: 不捕获任何外部变量。</li>
</ol>
<h3 id="可变Lambda"><a href="#可变Lambda" class="headerlink" title="可变Lambda"></a>可变Lambda</h3><p>默认情况下，Lambda表达式是不可变的（<code>const</code>）。通过<code>mutable</code>关键字，可以允许修改捕获的变量副本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [count]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count inside Lambda: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">increment</span>(); <span class="comment">// 输出: Count inside Lambda: 1</span></span><br><span class="line">    <span class="built_in">increment</span>(); <span class="comment">// 输出: Count inside Lambda: 2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count outside Lambda: &quot;</span> &lt;&lt; count &lt;&lt; std::endl; <span class="comment">// 输出: Count outside Lambda: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="捕获成员函数和类变量"><a href="#捕获成员函数和类变量" class="headerlink" title="捕获成员函数和类变量"></a>捕获成员函数和类变量</h3><p>Lambda表达式可以捕获类的成员变量和成员函数，使其在类的上下文中更加灵活。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Processor</span>(<span class="type">int</span> threshold) : <span class="built_in">threshold</span>(threshold) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理前数据: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式进行过滤</span></span><br><span class="line">        data.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">int</span> n) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n &lt; threshold;</span><br><span class="line">            &#125;), data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;处理后数据: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function">Processor <span class="title">proc</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    proc.<span class="built_in">process</span>(numbers);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    处理前数据: 1 6 3 8 2 7 </span></span><br><span class="line"><span class="comment">    处理后数据: 6 8 7 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lambda与标准库算法"><a href="#Lambda与标准库算法" class="headerlink" title="Lambda与标准库算法"></a>Lambda与标准库算法</h3><p>Lambda表达式与标准库算法紧密结合，提供了更简洁和直观的代码书写方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lambda表达式的优势"><a href="#Lambda表达式的优势" class="headerlink" title="Lambda表达式的优势"></a>Lambda表达式的优势</h3><ul>
<li><strong>简洁性：</strong> 代码更加紧凑，易于理解。</li>
<li><strong>灵活性：</strong> 能够捕获外部变量，适应更多场景。</li>
<li><strong>性能优化：</strong> 编译器可以对Lambda进行优化，如内联展开。</li>
<li><strong>与标准库的良好集成：</strong> 与STL算法无缝结合，简化代码逻辑。</li>
</ul>
<hr>
<h2 id="std-function-对象"><a href="#std-function-对象" class="headerlink" title="std::function 对象"></a><code>std::function</code> 对象</h2><p><code>std::function</code> 是C++11提供的一个通用的可调用包装器，能够封装任何可调用对象，包括普通函数、Lambda表达式、函数对象以及绑定表达式。它实现了类型擦除，使得不同类型的可调用对象可以通过统一的接口进行操作。</p>
<h3 id="定义与使用-2"><a href="#定义与使用-2" class="headerlink" title="定义与使用"></a>定义与使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func1 = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Add: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装Lambda表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func2 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Subtract: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装函数对象</span></span><br><span class="line">    Multiply multiply;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = multiply;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; <span class="built_in">func3</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: Multiply: 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>类型擦除：</strong> 可以存储任何符合签名的可调用对象。</li>
<li><strong>灵活性：</strong> 支持动态改变存储的可调用对象。</li>
<li><strong>性能开销：</strong> 相比于直接使用函数指针或Lambda，<code>std::function</code> 可能带来一定的性能开销，尤其是在频繁调用时。</li>
</ul>
<h3 id="用法场景"><a href="#用法场景" class="headerlink" title="用法场景"></a>用法场景</h3><ul>
<li><strong>回调函数的传递。</strong></li>
<li><strong>事件处理系统。</strong></li>
<li><strong>策略模式的实现。</strong></li>
</ul>
<h3 id="示例：回调机制"><a href="#示例：回调机制" class="headerlink" title="示例：回调机制"></a>示例：回调机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回调类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(Callback cb, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件发生，调用回调</span></span><br><span class="line">    <span class="built_in">cb</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda作为回调</span></span><br><span class="line">    <span class="built_in">triggerEvent</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;事件触发，值为: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;, <span class="number">42</span>); <span class="comment">// 输出: 事件触发，值为: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数作为回调</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Printer打印值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; printer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">triggerEvent</span>(printer, <span class="number">100</span>); <span class="comment">// 输出: Printer打印值: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="存储和调用不同类型的可调用对象"><a href="#存储和调用不同类型的可调用对象" class="headerlink" title="存储和调用不同类型的可调用对象"></a>存储和调用不同类型的可调用对象</h3><p><code>std::function</code> 可以在容器中存储各种不同类型的可调用对象，只要它们符合指定的签名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同类型的可调用对象</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(add); <span class="comment">// 普通函数</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(<span class="built_in">Multiply</span>()); <span class="comment">// 仿函数</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a - b; &#125;); <span class="comment">// Lambda</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">op</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 15 50 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="std-bind-操作"><a href="#std-bind-操作" class="headerlink" title="std::bind 操作"></a><code>std::bind</code> 操作</h2><p><code>std::bind</code> 是C++11中提供的一个函数适配器，用于绑定函数或可调用对象的部分参数，生成一个新的可调用对象。它允许提前固定某些参数，简化函数调用或适应接口需求。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为10，生成新的函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> add10 = std::<span class="built_in">bind</span>(add, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add10</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 10 + 5 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="占位符-std-placeholders"><a href="#占位符-std-placeholders" class="headerlink" title="占位符 (std::placeholders)"></a>占位符 (<code>std::placeholders</code>)</h3><p><code>std::bind</code> 使用占位符来表示未绑定的参数，这些占位符决定了在生成的新函数对象中如何传递参数。</p>
<p>常用的占位符包括：</p>
<ul>
<li><code>std::placeholders::_1</code></li>
<li><code>std::placeholders::_2</code></li>
<li><code>std::placeholders::_3</code></li>
<li>等等，根据需要传递的参数数量。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> std::string&amp; msg, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定消息为&quot;Hello&quot;，生成新的函数对象，只需要传递次数</span></span><br><span class="line">    <span class="keyword">auto</span> sayHello = std::<span class="built_in">bind</span>(display, <span class="string">&quot;Hello&quot;</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sayHello</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    Hello</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定次数为2，生成新的函数对象，只需要传递消息</span></span><br><span class="line">    <span class="keyword">auto</span> sayTwice = std::<span class="built_in">bind</span>(display, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">sayTwice</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Hi</span></span><br><span class="line"><span class="comment">    Hi</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="与Lambda表达式的对比"><a href="#与Lambda表达式的对比" class="headerlink" title="与Lambda表达式的对比"></a>与Lambda表达式的对比</h3><p><code>std::bind</code> 曾在C++11中广泛使用，但随着Lambda表达式的普及，很多情况下Lambda更为直观和高效。不过，在某些复杂的参数绑定场景下，<code>std::bind</code> 依然有其独特优势。</p>
<p><strong>使用 <code>std::bind</code>:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为2，生成新的函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = std::<span class="built_in">bind</span>(multiply, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 5 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2 * 5 = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用 Lambda 表达式:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda表达式绑定第一个参数为2</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = [](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">multiply</span>(<span class="number">2</span>, b);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 5 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2 * 5 = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li><strong>可读性：</strong> Lambda表达式通常更具可读性，语法更直观。</li>
<li><strong>灵活性：</strong> Lambda更易于捕获和使用外部变量。</li>
<li><strong>性能：</strong> Lambda通常比<code>std::bind</code>更高效，因为<code>std::bind</code>可能引入额外的间接层。</li>
</ul>
<hr>
<h2 id="绑定类的成员函数"><a href="#绑定类的成员函数" class="headerlink" title="绑定类的成员函数"></a>绑定类的成员函数</h2><p>在C++中，成员函数与普通函数不同，因为它们需要一个对象实例来调用。使用 <code>std::bind</code> 或Lambda表达式，可以方便地绑定类的成员函数，生成可调用对象。</p>
<h3 id="使用-std-bind-绑定成员函数"><a href="#使用-std-bind-绑定成员函数" class="headerlink" title="使用 std::bind 绑定成员函数"></a>使用 <code>std::bind</code> 绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定成员函数multiply，固定第一个参数为5</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy5 = std::<span class="built_in">bind</span>(&amp;Calculator::multiply, &amp;calc, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 * 3 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy5</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5 * 3 = 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用Lambda表达式绑定成员函数"><a href="#使用Lambda表达式绑定成员函数" class="headerlink" title="使用Lambda表达式绑定成员函数"></a>使用Lambda表达式绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Greeter greeter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式绑定成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> greetFunc = [&amp;greeter](<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">        greeter.<span class="built_in">greet</span>(name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">greetFunc</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绑定静态成员函数"><a href="#绑定静态成员函数" class="headerlink" title="绑定静态成员函数"></a>绑定静态成员函数</h3><p>静态成员函数不依赖于类的实例，可以像普通函数一样使用 <code>std::bind</code> 和 <code>std::function</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用std::bind绑定静态成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> logFunc = std::<span class="built_in">bind</span>(&amp;Logger::log, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logFunc</span>(<span class="string">&quot;This is a static log message.&quot;</span>); <span class="comment">// 输出: Log: This is a static log message.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绑定带有返回值的成员函数"><a href="#绑定带有返回值的成员函数" class="headerlink" title="绑定带有返回值的成员函数"></a>绑定带有返回值的成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">power</span><span class="params">(<span class="type">double</span> base, <span class="type">double</span> exponent)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(exponent); ++i) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Math mathObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定成员函数power，固定基数为2</span></span><br><span class="line">    <span class="keyword">auto</span> powerOf2 = std::<span class="built_in">bind</span>(&amp;Math::power, &amp;mathObj, <span class="number">2.0</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2^3 = &quot;</span> &lt;&lt; <span class="built_in">powerOf2</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 2^3 = 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>对象生命周期：</strong> 绑定成员函数时，确保对象在可调用对象使用期间依然存在，以避免悬空指针问题。</li>
<li><strong>指针与引用：</strong> 可以通过指针或引用传递对象实例给 <code>std::bind</code> 或Lambda表达式。</li>
<li><strong>捕获方式：</strong> 在使用Lambda表达式时，选择合适的捕获方式（值捕获或引用捕获）以确保对象的正确访问。</li>
</ul>
<hr>
<h2 id="C-可调用对象的总结"><a href="#C-可调用对象的总结" class="headerlink" title="C++ 可调用对象的总结"></a>C++ 可调用对象的总结</h2><p>C++ 提供了多种方式来定义和操作可调用对象，每种方式有其独特的特点和适用场景。</p>
<table>
<thead>
<tr>
<th>可调用对象</th>
<th>描述</th>
<th>示例用法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数指针</strong></td>
<td>指向普通函数或静态成员函数的指针</td>
<td><code>int (*func)(int) = &amp;funcName;</code></td>
</tr>
<tr>
<td><strong>仿函数（Functors）</strong></td>
<td>重载了 <code>operator()</code> 的类实例，可以携带状态</td>
<td><code>struct Foo &#123; void operator()(); &#125;;</code></td>
</tr>
<tr>
<td><strong>Lambda表达式</strong></td>
<td>定义在表达式中的匿名函数，支持捕获上下文变量</td>
<td><code>[capture](params) &#123; /* code */ &#125;</code></td>
</tr>
<tr>
<td><strong><code>std::function</code></strong></td>
<td>通用的可调用对象包装器，能够封装任何符合签名的可调用对象</td>
<td><code>std::function&lt;void(int)&gt; func;</code></td>
</tr>
<tr>
<td><strong><code>std::bind</code></strong></td>
<td>绑定函数或可调用对象的部分参数，生成新的可调用对象</td>
<td><code>auto newFunc = std::bind(func, _1);</code></td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul>
<li><strong>简单回调：</strong> 使用函数指针或Lambda表达式。</li>
<li><strong>需要携带状态或更复杂逻辑：</strong> 使用Lambda表达式或仿函数（Functors）。</li>
<li><strong>接口要求 <code>std::function</code>：</strong> 使用 <code>std::function</code>，不过要注意可能的性能开销。</li>
<li><strong>参数预绑定：</strong> 使用 <code>std::bind</code>，但在现代C++中，许多情况下Lambda表达式能达到相同效果且更直观。</li>
</ul>
<hr>
<h2 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h2><p>以下是一个综合示例，展示了函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code>、<code>std::bind</code> 以及绑定类成员函数的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 仿函数（Functors）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> subtract = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayOperation</span><span class="params">(<span class="type">const</span> std::string&amp; op, <span class="type">int</span> result)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; op &lt;&lt; <span class="string">&quot;结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add (Function Pointer): &quot;</span> &lt;&lt; <span class="built_in">funcPtr</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 仿函数（Functors）</span></span><br><span class="line">    Multiply multiply;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply (Functors): &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Lambda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract (Lambda): &quot;</span> &lt;&lt; <span class="built_in">subtract</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. std::function 封装不同可调用对象</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcAdd = add;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcSubtract = subtract;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcMultiply = multiply;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcAdd</span>(<span class="number">20</span>, <span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcSubtract</span>(<span class="number">20</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply (std::function): &quot;</span> &lt;&lt; <span class="built_in">funcMultiply</span>(<span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. std::bind 绑定部分参数</span></span><br><span class="line">    <span class="keyword">auto</span> add5 = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 10 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> multiplyBy2 = std::<span class="built_in">bind</span>(multiply, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 * 10 = &quot;</span> &lt;&lt; <span class="built_in">multiplyBy2</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 绑定类成员函数</span></span><br><span class="line">    Calculator calc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定成员函数 subtract</span></span><br><span class="line">    <span class="keyword">auto</span> boundSubtract = std::<span class="built_in">bind</span>(&amp;Calculator::subtract, &amp;calc, <span class="number">15</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;15 - 5 = &quot;</span> &lt;&lt; <span class="built_in">boundSubtract</span>() &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定成员函数 displayOperation</span></span><br><span class="line">    <span class="keyword">auto</span> displayAdd = std::<span class="built_in">bind</span>(&amp;Calculator::displayOperation, &amp;calc, <span class="string">&quot;Add&quot;</span>, std::placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> displayResult = funcAdd;</span><br><span class="line">    <span class="type">int</span> addResult = <span class="built_in">displayResult</span>(<span class="number">7</span>, <span class="number">8</span>); <span class="comment">// 15</span></span><br><span class="line">    <span class="built_in">displayAdd</span>(addResult); <span class="comment">// 输出: Add结果: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 绑定静态成员函数</span></span><br><span class="line">    <span class="keyword">auto</span> logFunc = std::<span class="built_in">bind</span>(&amp;Logger::log, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">logFunc</span>(<span class="string">&quot;This is a static log message.&quot;</span>); <span class="comment">// 输出: Log: This is a static log message.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 使用 std::function 存储混合可调用对象</span></span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加不同的操作到容器</span></span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::cout &lt;&lt; <span class="string">&quot;Lambda Operation&quot;</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;Calculator::displayOperation, &amp;calc, <span class="string">&quot;Multiply&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::cout &lt;&lt; <span class="string">&quot;Add5(10): &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">10</span>) &lt;&lt; std::endl; &#125;);</span><br><span class="line">    operations.<span class="built_in">emplace_back</span>([&amp;]() &#123; Logger::<span class="built_in">log</span>(<span class="string">&quot;Lambda-based log message.&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        <span class="built_in">op</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Lambda Operation</span></span><br><span class="line"><span class="comment">    Multiply结果: 30</span></span><br><span class="line"><span class="comment">    Add5(10): 15</span></span><br><span class="line"><span class="comment">    Log: Lambda-based log message.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解释:</strong></p>
<ol>
<li><strong>函数指针:</strong> 定义并使用了指向 <code>add</code> 函数的函数指针 <code>funcPtr</code>。</li>
<li><strong>仿函数（Functors）:</strong> 定义了 <code>Multiply</code> 结构体，并使用其实例 <code>multiply</code> 进行乘法运算。</li>
<li><strong>Lambda表达式:</strong> 定义了一个用于减法的Lambda <code>subtract</code>。</li>
<li><strong><code>std::function</code>:</strong> 封装了不同类型的可调用对象，包括普通函数、Lambda和仿函数。</li>
<li><strong><code>std::bind</code>:</strong> 绑定 <code>add</code> 和 <code>multiply</code> 函数的部分参数，生成新的可调用对象 <code>add5</code> 和 <code>multiplyBy2</code>。</li>
<li><strong>绑定类成员函数:</strong> 使用 <code>std::bind</code> 绑定 <code>Calculator</code> 类的成员函数 <code>subtract</code> 和 <code>displayOperation</code>。</li>
<li><strong>绑定静态成员函数:</strong> 使用 <code>std::bind</code> 绑定 <code>Logger</code> 类的静态成员函数 <code>log</code>。</li>
<li><strong>混合可调用对象容器:</strong> 使用 <code>std::function</code> 和 <code>std::vector</code> 存储并执行不同类型的可调用对象，包括Lambda、绑定成员函数和静态成员函数。</li>
</ol>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本教案，学生应能够理解并运用C++中的各种可调用对象，包括传统的函数指针、仿函数（Functors）、Lambda表达式、<code>std::function</code> 和 <code>std::bind</code> 等。掌握这些工具不仅有助于编写更灵活和可维护的代码，还为进一步学习函数式编程和设计模式奠定了坚实的基础。在实际编程中，合理选择和组合这些可调用对象，可以大大提升代码的效率和表达力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/12/05/cppbase22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/05/cppbase22/" itemprop="url">零基础C++(22) 内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-05T15:47:53+08:00">
                2024-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存管理简介"><a href="#内存管理简介" class="headerlink" title="内存管理简介"></a>内存管理简介</h2><p>详细技术视频请看我的主页</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">C++教程视频</a></p>
<p>C++ 提供了多种内存管理方式，包括传统的 C 风格的 <code>malloc</code> 和 <code>free</code>，以及 C++ 专用的 <code>new</code> 和 <code>delete</code>。</p>
<p>理解这些内存管理方法对于编写高效、安全的 C++ 程序至关重要。</p>
<p>本文将详细介绍这些内存管理方法，包含基本用法、复杂操作（如 <code>realloc</code>），并配以实际案例和代码示例。</p>
<h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><p>在 C++ 程序中，内存主要分为以下几个区域：</p>
<ul>
<li><strong>栈（Stack）</strong>：自动管理内存，存储局部变量和函数调用信息。内存分配和释放速度快，但空间有限。</li>
<li><strong>堆（Heap）</strong>：手动管理内存，用于动态分配内存。内存分配和释放由程序员控制，灵活但易出错（如内存泄漏、悬挂指针）。</li>
<li><strong>全局/静态区（<code>Data/BSS Segment</code>）</strong>：存储全局变量和静态变量。</li>
</ul>
<p>了解栈和堆的区别，以及如何有效地在堆上分配和管理内存，是编写高效且安全的 C++ 程序的基础。</p>
<h2 id="C-风格内存管理"><a href="#C-风格内存管理" class="headerlink" title="C 风格内存管理"></a>C 风格内存管理</h2><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc 函数"></a><code>malloc</code> 函数</h3><p><code>malloc</code>（memory allocation）用于在堆上分配指定字节数的内存。其原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>参数</strong>：<code>size</code> - 要分配的内存字节数。</li>
<li><strong>返回值</strong>：指向分配内存的指针，如果分配失败则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a><code>free</code> 函数</h3><p><code>free</code> 用于释放之前由 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 分配的内存。其原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>参数</strong>：<code>ptr</code> - 要释放的内存指针。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 malloc 和 free</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>类型转换</strong>：<code>malloc</code> 返回 <code>void*</code>，需要显式转换为所需类型的指针。</li>
<li><strong>初始化</strong>：<code>malloc</code> 分配的内存未初始化，内容不确定。</li>
<li><strong>释放对应性</strong>：由 <code>malloc</code> 分配的内存必须使用 <code>free</code> 释放，避免使用 <code>delete</code>。</li>
</ul>
<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h2><p>C++ 提供了更高层次的内存管理操作符：<code>new</code> 和 <code>delete</code>，它们不仅分配和释放内存，还调用构造函数和析构函数，提供类型安全。</p>
<h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><strong><code>new</code> 操作符</strong></h3><p>用于在堆上分配对象，并调用其构造函数。</p>
<p><strong>单个对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* ptr = <span class="keyword">new</span> <span class="built_in">Type</span>(parameters);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="keyword">called</span> <span class="keyword">with</span> <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Object <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Destructor <span class="keyword">called</span> <span class="keyword">for</span> <span class="keyword">value</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p><strong>数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* array = <span class="keyword">new</span> Type[size];</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 分配5个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 释放数组内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr[0] = 0</span><br><span class="line">arr[1] = 10</span><br><span class="line">arr[2] = 20</span><br><span class="line">arr[3] = 30</span><br><span class="line">arr[4] = 40</span><br></pre></td></tr></table></figure>



<p><strong><code>delete</code> 操作符</strong></p>
<p>用于释放由 <code>new</code> 分配的内存，并调用析构函数。</p>
<h3 id="释放单个对象"><a href="#释放单个对象" class="headerlink" title="释放单个对象"></a>释放单个对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>



<h3 id="释放数组"><a href="#释放数组" class="headerlink" title="释放数组"></a>释放数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>



<h3 id="区别于-malloc-和-free"><a href="#区别于-malloc-和-free" class="headerlink" title="区别于 malloc 和 free"></a>区别于 <code>malloc</code> 和 <code>free</code></h3><ul>
<li><strong>类型安全</strong>：<code>new</code> 返回正确类型的指针，免去了强制类型转换。</li>
<li><strong>构造/析构</strong>：<code>new</code> 和 <code>delete</code> 自动调用构造函数和析构函数。</li>
<li><strong>异常处理</strong>：在分配失败时，<code>new</code> 默认抛出 <code>std::bad_alloc</code> 异常，而 <code>malloc</code> 返回 <code>nullptr</code>。</li>
</ul>
<h3 id="异常安全的-new"><a href="#异常安全的-new" class="headerlink" title="异常安全的 new"></a>异常安全的 <code>new</code></h3><p>可以通过 <code>nothrow</code> 参数防止 <code>new</code> 抛出异常，改为返回 <code>nullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 包含 std::nothrow</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="总结和对比"><a href="#总结和对比" class="headerlink" title="总结和对比"></a>总结和对比</h2><p>了解 <code>malloc/free</code> 与 <code>new/delete</code> 的区别，有助于在编写 C++ 程序时正确选择内存管理方法。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>malloc/free</th>
<th>new/delete</th>
</tr>
</thead>
<tbody><tr>
<td>类型安全</td>
<td>需要显式类型转换</td>
<td>自动类型转换，无需显式转换</td>
</tr>
<tr>
<td>构造/析构函数</td>
<td>不调用对象的构造/析构函数</td>
<td>调用对象的构造/析构函数</td>
</tr>
<tr>
<td>返回值</td>
<td><code>void*</code>，需要转换为目标类型</td>
<td>返回目标类型指针，类型安全</td>
</tr>
<tr>
<td>错误处理</td>
<td>分配失败返回 <code>nullptr</code></td>
<td>分配失败抛出 <code>std::bad_alloc</code> 异常</td>
</tr>
<tr>
<td>多态行为</td>
<td>无</td>
<td>支持多态，通过虚函数正确调用析构函数</td>
</tr>
<tr>
<td>内存分配与释放对应性</td>
<td>必须使用 <code>free</code> 释放由 <code>malloc</code> 分配的内存</td>
<td>必须使用 <code>delete</code> 释放由 <code>new</code> 分配的内存</td>
</tr>
</tbody></table>
<h3 id="示例对比"><a href="#示例对比" class="headerlink" title="示例对比"></a>示例对比</h3><p><strong>使用 <code>malloc</code> 和 <code>free</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">    MyClass* obj = (MyClass*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyClass));</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;malloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调用构造函数（不推荐）</span></span><br><span class="line">    <span class="keyword">new</span>(obj) <span class="built_in">MyClass</span>(<span class="number">20</span>); <span class="comment">// 通过“定位 new”调用构造函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调用析构函数</span></span><br><span class="line">    obj-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：使用 <code>malloc</code> 分配 C++ 对象时，需要手动调用构造函数和析构函数，这非常不便且易出错。因此，推荐使用 <code>new</code> 和 <code>delete</code>。</p>
<p><strong>使用 <code>new</code> 和 <code>delete</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 new 分配内存并调用构造函数</span></span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 delete 释放内存并调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="keyword">called</span></span><br><span class="line"><span class="keyword">Value</span>: <span class="number">30</span></span><br><span class="line">Destructor <span class="keyword">called</span></span><br></pre></td></tr></table></figure>



<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul>
<li><strong>C++ 类型特性</strong>：<code>new</code> 和 <code>delete</code> 支持 C++ 的类型特性，包括构造函数、析构函数、多态等。</li>
<li><strong>C 兼容性</strong>：在需要兼容 C 代码或通过 C 接口分配内存时，仍可能需要使用 <code>malloc</code> 和 <code>free</code>。</li>
</ul>
<h2 id="高级内存管理"><a href="#高级内存管理" class="headerlink" title="高级内存管理"></a>高级内存管理</h2><h3 id="使用-realloc-进行内存重分配"><a href="#使用-realloc-进行内存重分配" class="headerlink" title="使用 realloc 进行内存重分配"></a>使用 realloc 进行内存重分配</h3><p><code>realloc</code> 用于调整之前分配的内存块大小。这在动态数组等数据结构中非常有用。</p>
<p><strong>原型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>参数</p>
<p>：</p>
<ul>
<li><code>ptr</code>：指向之前分配的内存块。</li>
<li><code>new_size</code>：新的内存大小（以字节为单位）。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：指向重新分配后的内存块的新指针。如果重新分配失败，返回 <code>nullptr</code>，原内存块保持不变。</p>
</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含 memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始分配 3 个整数</span></span><br><span class="line">    <span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Initial malloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配为 5 个整数</span></span><br><span class="line">    <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Realloc failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">free</span>(arr); <span class="comment">// 释放原内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化新元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = (i + <span class="number">1</span>) * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reallocated array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Initial</span> <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">Reallocated <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">40</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure>



<h3 id="动态数组管理"><a href="#动态数组管理" class="headerlink" title="动态数组管理"></a>动态数组管理</h3><p>使用 <code>malloc</code> 和 <code>realloc</code> 来手动管理动态数组可以实现可变大小的数组，但需要处理内存分配、释放和数据复制。</p>
<p><strong>封装动态数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>(<span class="type">size_t</span> initial_size = <span class="number">1</span>)</span><br><span class="line">        : <span class="built_in">size</span>(initial_size), <span class="built_in">data</span>((<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_size)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(data, new_size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">        size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">DynamicArray <span class="title">arr</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Initial array: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整大小</span></span><br><span class="line">        arr.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="number">40</span>;</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resized array: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Initial</span> <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">Resized <span class="keyword">array</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">40</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：这种方式需要手动管理内存和数组大小，且缺乏类型安全性和自动化。推荐使用 C++ 标准容器如 <code>std::vector</code> 来代替。</p>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h3 id="案例一：动态数组实现"><a href="#案例一：动态数组实现" class="headerlink" title="案例一：动态数组实现"></a>案例一：动态数组实现</h3><p>实现一个简单的动态数组类，支持添加元素、访问元素和自动扩展。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>()</span><br><span class="line">        : <span class="built_in">capacity</span>(<span class="number">2</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">data</span>((<span class="type">int</span>*)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(capacity * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[size++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(data, new_capacity * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        data = temp;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DynamicArray arr;</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line">        arr.<span class="built_in">add</span>(<span class="number">30</span>); <span class="comment">// 触发扩展</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dynamic Array Contents:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr.<span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Array access error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dynamic</span> <span class="keyword">Array</span> Contents:</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br></pre></td></tr></table></figure>



<h3 id="案例二：自定义内存管理器"><a href="#案例二：自定义内存管理器" class="headerlink" title="案例二：自定义内存管理器"></a>案例二：自定义内存管理器</h3><p>实现一个简单的内存池，用于高效分配和释放固定大小的对象。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> objectSize, <span class="type">size_t</span> poolSize)</span><br><span class="line">        : <span class="built_in">objSize</span>(objectSize), <span class="built_in">totalSize</span>(poolSize), <span class="built_in">pool</span>((<span class="type">char</span>*)<span class="built_in">malloc</span>(objectSize * poolSize)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 free list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; poolSize; ++i) &#123;</span><br><span class="line">            freeList.<span class="built_in">push</span>(pool + i * objectSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (freeList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">void</span>* ptr = freeList.<span class="built_in">top</span>();</span><br><span class="line">        freeList.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        freeList.<span class="built_in">push</span>((<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> objSize;</span><br><span class="line">    <span class="type">size_t</span> totalSize;</span><br><span class="line">    <span class="type">char</span>* pool;</span><br><span class="line">    std::stack&lt;<span class="type">void</span>*&gt; freeList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个能容纳 3 个 MyClass 对象的内存池</span></span><br><span class="line">        <span class="function">MemoryPool <span class="title">pool</span><span class="params">(<span class="keyword">sizeof</span>(MyClass), <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配对象内存</span></span><br><span class="line">        <span class="type">void</span>* mem1 = pool.<span class="built_in">allocate</span>();</span><br><span class="line">        <span class="type">void</span>* mem2 = pool.<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用“定位 new”构造对象</span></span><br><span class="line">        MyClass* obj1 = <span class="built_in">new</span>(mem1) <span class="built_in">MyClass</span>(<span class="number">100</span>);</span><br><span class="line">        MyClass* obj2 = <span class="built_in">new</span>(mem2) <span class="built_in">MyClass</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用对象</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj1 value: &quot;</span> &lt;&lt; obj1-&gt;value &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 value: &quot;</span> &lt;&lt; obj2-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式调用析构函数</span></span><br><span class="line">        obj1-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line">        obj2-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        pool.<span class="built_in">deallocate</span>(mem1);</span><br><span class="line">        pool.<span class="built_in">deallocate</span>(mem2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory pool allocation error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MyClass constructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">MyClass constructor:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">obj1 value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">obj2 value:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">MyClass destructor:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">MyClass destructor:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>



<p><strong>说明</strong>：</p>
<ul>
<li><strong>MemoryPool</strong> 管理固定大小的内存块，避免频繁调用 <code>malloc</code> 和 <code>free</code>。</li>
<li>使用“<strong>定位 new</strong>”在预分配的内存上构造对象。</li>
<li>需要手动调用析构函数和将内存返回给内存池。</li>
</ul>
<p><strong>注意</strong>：这种方法适用于大量小对象的高效管理，但需要确保正确使用构造和析构函数。</p>
<h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h2><p>内存泄漏是指程序分配的内存未被释放，导致内存被浪费，甚至耗尽。避免内存泄漏的策略包括：</p>
<ul>
<li>**确保每个 <code>new</code> 有对应的 <code>delete</code>**。</li>
<li><strong>使用 <code>RAII</code> 和智能指针</strong>：自动管理资源，避免手动管理内存。</li>
<li><strong>工具辅助</strong>：使用工具如 <code>Valgrind</code> 检测内存泄漏。</li>
</ul>
<p><strong>示例：内存泄漏</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 忘记 delete p; 导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解决方法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 正确释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RAII（资源获取即初始化）"><a href="#RAII（资源获取即初始化）" class="headerlink" title="RAII（资源获取即初始化）"></a><code>RAII</code>（资源获取即初始化）</h2><p><code>RAII</code> 是 C++ 中的一种编程惯用法，通过对象的生命周期管理资源，确保资源在对象构造时获取，析构时释放，避免泄漏。</p>
<p><strong>示例：<code>RAII</code> 实现类似于<code>shared_ptr</code>智能指针</strong></p>
<p><code>std::shared_ptr</code> 是 C++ 标准库中功能强大的智能指针之一，提供了共享所有权的能力，使得多个指针可以共同管理同一个动态分配的对象。通过引用计数机制，<code>shared_ptr</code> 确保了对象在最后一个指针被销毁时自动释放，极大地简化了内存管理，防止了内存泄漏和悬挂指针问题。</p>
<h3 id="SimpleSharedPtr-的基本概念"><a href="#SimpleSharedPtr-的基本概念" class="headerlink" title="SimpleSharedPtr 的基本概念"></a><strong><code>SimpleSharedPtr</code> 的基本概念</strong></h3><p><code>SimpleSharedPtr</code> 是一个简化版的 <code>shared_ptr</code> 实现，旨在帮助理解其核心机制。其基本功能包括：</p>
<ul>
<li><strong>共享所有权</strong>：多个 <code>SimpleSharedPtr</code> 实例可以指向同一个对象，共享对该对象的所有权。</li>
<li><strong>自动管理生命周期</strong>：当最后一个 <code>SimpleSharedPtr</code> 被销毁或指向其他对象时，管理的对象被自动释放。</li>
<li><strong>引用计数</strong>：内部维护一个引用计数，记录有多少个 <code>SimpleSharedPtr</code> 实例指向同一个对象。</li>
</ul>
<h3 id="引用计数控制块的设计"><a href="#引用计数控制块的设计" class="headerlink" title="引用计数控制块的设计"></a><strong>引用计数控制块的设计</strong></h3><p>为了实现引用计数机制，<code>SimpleSharedPtr</code> 需要一个控制块（Control Block），它包含：</p>
<ul>
<li><strong>引用计数（<code>ref_count</code>）</strong>：记录有多少个 <code>SimpleSharedPtr</code> 指向同一个对象。</li>
<li><strong>指向对象的指针（<code>ptr</code>）</strong>：指向实际管理的对象。</li>
</ul>
<p>控制块通常与被管理对象一起被分配，但为了简化实现，本示例将它们独立管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count;    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="comment">// 可以扩展为包含自定义删除器等</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleSharedPtr-的实现"><a href="#SimpleSharedPtr-的实现" class="headerlink" title="SimpleSharedPtr 的实现"></a><code>SimpleSharedPtr</code> 的实现</h3><p><strong>类结构</strong></p>
<p><code>SimpleSharedPtr</code> 是一个模板类，模板参数 <code>T</code> 表示它所管理的对象类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control; <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、析构函数、拷贝与移动操作、操作符重载等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>构造函数与析构函数</strong></p>
<ul>
<li><strong>默认构造函数</strong>：初始化指针和控制块为空。</li>
<li><strong>参数化构造函数</strong>：接受一个裸指针，初始化控制块，并引用计数为1。</li>
<li><strong>析构函数</strong>：减少引用计数，若引用计数为0，则释放对象和控制块。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**辅助函数 <code>release</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (control) &#123;</span><br><span class="line">        control-&gt;ref_count--;</span><br><span class="line">        <span class="keyword">if</span> (control-&gt;ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> control;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    control = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拷贝构造与拷贝赋值"><a href="#拷贝构造与拷贝赋值" class="headerlink" title="拷贝构造与拷贝赋值"></a>拷贝构造与拷贝赋值</h3><p>拷贝构造函数和拷贝赋值操作符允许多个 <code>SimpleSharedPtr</code> 实例共享同一个对象，共享相同的控制块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">    <span class="keyword">if</span> (control) &#123;</span><br><span class="line">        control-&gt;ref_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制新的资源和控制块</span></span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移动构造与移动赋值"><a href="#移动构造与移动赋值" class="headerlink" title="移动构造与移动赋值"></a>移动构造与移动赋值</h3><p>移动语义允许资源所有权从一个 <code>SimpleSharedPtr</code> 转移到另一个，而不增加引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">    other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    other.control = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值操作符</span></span><br><span class="line">SimpleSharedPtr&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接管 `other` 的资源</span></span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        control = other.control;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置 `other` 为空</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>重载 <code>*</code> 和 <code>-&gt;</code> 操作符，以便像使用原生指针一样使用 <code>SimpleSharedPtr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头操作符</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h3><ul>
<li>**<code>use_count</code>**：返回当前引用计数。</li>
<li>**<code>get</code>**：返回裸指针。</li>
<li>**<code>reset</code>**：重置指针，指向新对象或 <code>nullptr</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取引用计数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> control ? control-&gt;ref_count : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裸指针</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向新资源</span></span><br><span class="line">    ptr = p;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><p>以下是 <code>SimpleSharedPtr</code> 的完整实现及其使用示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制块结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版的 shared_ptr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;                <span class="comment">// 指向管理的对象</span></span><br><span class="line">    ControlBlock* control; <span class="comment">// 指向控制块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count--;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Decremented ref_count to &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (control-&gt;ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> control;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Resource and ControlBlock destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        control = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructed SimpleSharedPtr (nullptr).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Constructed SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">        <span class="keyword">if</span> (control) &#123;</span><br><span class="line">            control-&gt;ref_count++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copied SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                control-&gt;ref_count++;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Assigned SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control</span>(other.control) &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved SimpleSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    SimpleSharedPtr&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            control = other.control;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move-assigned SimpleSharedPtr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> control ? control-&gt;ref_count : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        ptr = p;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            control = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Reset SimpleSharedPtr, ref_count = &quot;</span> &lt;&lt; control-&gt;ref_count &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            control = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating default constructed shared_ptr...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    SimpleSharedPtr&lt;Test&gt; ptr1; <span class="comment">// 默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating shared_ptr with resource...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">SimpleSharedPtr&lt;Test&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>))</span></span>; <span class="comment">// 非默认构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCopying ptr2 to ptr3...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    SimpleSharedPtr&lt;Test&gt; ptr3 = ptr2; <span class="comment">// 拷贝构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr3-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning ptr3 to ptr1...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ptr1 = ptr3; <span class="comment">// 拷贝赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nResetting ptr2...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">200</span>)); <span class="comment">// 重新指向新的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr2 use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nExiting scope...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// ptr2, ptr1, ptr3 离开作用域</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of main.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SimpleUniquePtr-的实现"><a href="#SimpleUniquePtr-的实现" class="headerlink" title="SimpleUniquePtr 的实现"></a><code>SimpleUniquePtr</code> 的实现</h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，确保在任意时刻，只有一个 <code>unique_ptr</code> 实例指向特定资源。它不支持拷贝操作，只支持移动操作。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>首先，定义一个模板类 <code>SimpleUniquePtr</code>，它持有一个指向资源的裸指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleUniquePtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr; <span class="comment">// 指向管理对象的裸指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、析构函数、删除拷贝构造与拷贝赋值</span></span><br><span class="line">    <span class="comment">// 实现移动构造与移动赋值</span></span><br><span class="line">    <span class="comment">// 重载操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul>
<li><strong>默认构造函数</strong>：初始化指针为空。</li>
<li><strong>参数化构造函数</strong>：接受一个指向资源的裸指针。</li>
<li><strong>析构函数</strong>：当 <code>SimpleUniquePtr</code> 被销毁时，释放所管理的资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleUniquePtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="built_in">SimpleUniquePtr</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除拷贝构造与拷贝赋值"><a href="#删除拷贝构造与拷贝赋值" class="headerlink" title="删除拷贝构造与拷贝赋值"></a>删除拷贝构造与拷贝赋值</h3><p>为了确保唯一性，禁止拷贝构造和拷贝赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除拷贝构造</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除拷贝赋值</span></span><br><span class="line">SimpleUniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>



<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>支持移动构造和移动赋值，以转移所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造</span></span><br><span class="line"><span class="built_in">SimpleUniquePtr</span>(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;</span><br><span class="line">    other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值</span></span><br><span class="line">SimpleUniquePtr&amp; <span class="keyword">operator</span>=(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;     <span class="comment">// 释放当前资源</span></span><br><span class="line">        ptr = other.ptr; <span class="comment">// 转移所有权</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>重载 <code>*</code> 和 <code>-&gt;</code> 操作符，以模拟指针的行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解引用操作符</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头操作符</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裸指针</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有权，返回裸指针并设为 nullptr</span></span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T* temp = ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设定指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下示例展示了如何使用 <code>SimpleUniquePtr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleUniquePtr 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleUniquePtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimpleUniquePtr</span><span class="params">(T* p)</span> : ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SimpleUniquePtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SimpleUniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="built_in">SimpleUniquePtr</span>(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    SimpleUniquePtr&amp; <span class="keyword">operator</span>=(SimpleUniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头操作符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取裸指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权</span></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* temp = ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设定指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Constructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Destructor: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 SimpleUniquePtr</span></span><br><span class="line">    <span class="function">SimpleUniquePtr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    (*ptr1).<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动所有权到 ptr2</span></span><br><span class="line">    SimpleUniquePtr&lt;Test&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权</span></span><br><span class="line">    Test* rawPtr = ptr2.<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptr2.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now nullptr after release.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    rawPtr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> rawPtr; <span class="comment">// 手动删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reset</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(); <span class="comment">// 自动删除</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2.<span class="built_in">get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now nullptr after reset.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Test Constructor:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="string">ptr1</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">move.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="string">ptr2</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">release.</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Test Constructor:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Value:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Test Destructor:</span> <span class="number">2</span></span><br><span class="line"><span class="string">ptr2</span> <span class="string">is</span> <span class="string">now</span> <span class="string">nullptr</span> <span class="string">after</span> <span class="string">reset.</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：</p>
<ul>
<li>创建 <code>ptr1</code> 并指向一个 <code>Test</code> 对象。</li>
<li>使用 <code>std::move</code> 将所有权转移到 <code>ptr2</code>，<code>ptr1</code> 变为 <code>nullptr</code>。</li>
<li>使用 <code>release()</code> 释放 <code>ptr2</code> 的所有权，获取裸指针后需要手动 <code>delete</code>。</li>
<li>使用 <code>reset()</code> 重新指向一个新的 <code>Test</code> 对象，自动释放之前的资源。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 C++ 中的内存管理方法，包括基础的 <code>malloc</code> 和 <code>free</code>，以及更现代的 C++ 风格的 <code>new</code> 和 <code>delete</code>。通过对比两者的特点，强调了 <code>new</code> 和 <code>delete</code> 在 C++ 中的优势，如类型安全、自动调用构造和析构函数等。</p>
<p>高级内存管理部分探讨了如何使用 <code>realloc</code> 进行内存重分配，并通过实际案例展示了如何实现动态数组和自定义内存管理器。最后，介绍了最佳实践，强调避免内存泄漏的重要性，以及 <code>RAII</code> 和智能指针对内存管理的帮助。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/24/cpppro31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/24/cpppro31/" itemprop="url">聊天项目(31) 单线程文件传输</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-24T18:04:18+08:00">
                2024-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpppro/" itemprop="url" rel="index">
                    <span itemprop="name">C++聊天项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>文件传输必须满足以下几个条件：</p>
<ul>
<li>限制文件大小(不超过<code>4G</code>)</li>
<li>长连接传输(效率高，支持大文件)</li>
<li>客户端和服务器都知道传输进度，以保证支持断点续传(后续实现)</li>
<li>先实现服务器单线程处理版本，在实现多线程处理版本</li>
</ul>
<p>如遇问题可添加我的微信</p>
<img src="https://cdn.llfc.club/wechat.jpg" alt="img" style="zoom: 33%;" />

<p>也可以去我得哔哩哔哩主页查看项目视频详细讲解</p>
<p>B站主页 <a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">https://space.bilibili.com/271469206</a></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端还是采用聊天项目客户端封装的<code>TcpClient</code>, 只是修改了发送逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::slot_send_msg</span><span class="params">(quint16 id, QByteArray body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果连接异常则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(_socket-&gt;<span class="built_in">state</span>() != QAbstractSocket::ConnectedState)&#123;</span><br><span class="line">        <span class="function">emit <span class="title">sig_net_error</span><span class="params">(QString(<span class="string">&quot;断开连接无法发送&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取body的长度</span></span><br><span class="line">    quint32 bodyLength = body.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    QByteArray data;</span><br><span class="line">    <span class="comment">//绑定字节数组</span></span><br><span class="line">    <span class="function">QDataStream <span class="title">stream</span><span class="params">(&amp;data, QIODevice::WriteOnly)</span></span>;</span><br><span class="line">    <span class="comment">//设置大端模式</span></span><br><span class="line">    stream.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">    <span class="comment">//写入ID</span></span><br><span class="line">    stream &lt;&lt; id;</span><br><span class="line">    <span class="comment">//写入长度</span></span><br><span class="line">    stream &lt;&lt; bodyLength;</span><br><span class="line">    <span class="comment">//写入包体</span></span><br><span class="line">    data.<span class="built_in">append</span>(body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">     _socket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里着重叙述以下，发送的格式是<code>id + bodyLength + 文件流数据</code></p>
<p>其中id 为2字节，<code>bodyLength</code>为4字节，之后就是传输的文件流</p>
<p><img src="https://cdn.llfc.club/1732450428990.jpg" alt="https://cdn.llfc.club/1732450428990.jpg"></p>
<p><code>slot_send_msg</code>是槽函数，和 <code>sig_send_msg</code>信号连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接 发送数据信号和槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;TcpClient::sig_send_msg, <span class="keyword">this</span>, &amp;TcpClient::slot_send_msg);</span><br></pre></td></tr></table></figure>

<p>客户端在发送数据的时候调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::sendMsg</span><span class="params">(quint16 id,QByteArray data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发送信号，统一交给槽函数处理，这么做的好处是多线程安全</span></span><br><span class="line">    <span class="function">emit <span class="title">sig_send_msg</span><span class="params">(id, data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在打开文件对话框后选择文件，接下来，点击发送会将文件切分成固定大小的报文发送</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_uploadBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;uploadBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">       <span class="function">QFile <span class="title">file</span><span class="params">(_file_name)</span></span>;</span><br><span class="line">       <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">           <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Could not open file:&quot;</span> &lt;&lt; file.<span class="built_in">errorString</span>();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 保存当前文件指针位置</span></span><br><span class="line">       qint64 originalPos = file.<span class="built_in">pos</span>();</span><br><span class="line">       <span class="function">QCryptographicHash <span class="title">hash</span><span class="params">(QCryptographicHash::Md5)</span></span>;</span><br><span class="line">       <span class="keyword">if</span> (!hash.<span class="built_in">addData</span>(&amp;file)) &#123;</span><br><span class="line">           <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to read data from file:&quot;</span> &lt;&lt; _file_name;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       _file_md5 = hash.<span class="built_in">result</span>().<span class="built_in">toHex</span>(); <span class="comment">// 返回十六进制字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容并发送</span></span><br><span class="line">    QByteArray buffer;</span><br><span class="line">    <span class="type">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QFileInfo <span class="title">fileInfo</span><span class="params">(_file_name)</span></span>; <span class="comment">// 创建 QFileInfo 对象</span></span><br><span class="line"></span><br><span class="line">    QString fileName = fileInfo.<span class="built_in">fileName</span>(); <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件名是：&quot;</span> &lt;&lt; fileName; <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="type">int</span> total_size = fileInfo.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> last_seq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(total_size % MAX_FILE_LEN)&#123;</span><br><span class="line">        last_seq = (total_size/MAX_FILE_LEN)+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        last_seq = total_size/MAX_FILE_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件指针到原来的位置</span></span><br><span class="line">    file.<span class="built_in">seek</span>(originalPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        <span class="comment">//每次读取2048字节发送</span></span><br><span class="line">        buffer = file.<span class="built_in">read</span>(MAX_FILE_LEN);</span><br><span class="line">        QJsonObject jsonObj;</span><br><span class="line">        <span class="comment">// 将文件内容转换为 Base64 编码（可选）</span></span><br><span class="line">        QString base64Data = buffer.<span class="built_in">toBase64</span>();</span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt; &quot;send data is &quot; &lt;&lt; base64Data;</span></span><br><span class="line">        ++seq;</span><br><span class="line">        jsonObj[<span class="string">&quot;md5&quot;</span>] = _file_md5;</span><br><span class="line">        jsonObj[<span class="string">&quot;name&quot;</span>] = fileName;</span><br><span class="line">        jsonObj[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">        jsonObj[<span class="string">&quot;trans_size&quot;</span>] = buffer.<span class="built_in">size</span>() + (seq<span class="number">-1</span>)*MAX_FILE_LEN;</span><br><span class="line">        jsonObj[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">        <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() &lt; MAX_FILE_LEN)&#123;</span><br><span class="line">            jsonObj[<span class="string">&quot;last&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            jsonObj[<span class="string">&quot;last&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonObj[<span class="string">&quot;data&quot;</span>]= base64Data;</span><br><span class="line">        jsonObj[<span class="string">&quot;last_seq&quot;</span>] = last_seq;</span><br><span class="line">        <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(jsonObj)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> send_data = doc.<span class="built_in">toJson</span>();</span><br><span class="line">        TcpClient::<span class="built_in">Inst</span>().<span class="built_in">sendMsg</span>(ID_UPLOAD_FILE_REQ, send_data);</span><br><span class="line">        <span class="comment">//startDelay(500);</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送时数据字段分别为：</p>
<ul>
<li><p>文件<code>md5 </code> : 以后用来做断点续传校验</p>
</li>
<li><p><code>name</code> : 文件名</p>
</li>
<li><p><code>seq</code>:  报文序列号，类似于TCP序列号，自己定义的，服务器根据这个序列号组合数据写入文件。</p>
</li>
<li><p><code>trans_size</code>:   当前已经传输的大小</p>
</li>
<li><p><code>total_size</code>： 传输文件的总大小。</p>
</li>
</ul>
<p>客户端需要接受服务器返回的消息更新进度条</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受服务器发送的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::slot_ready_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取所有数据</span></span><br><span class="line">    QByteArray data = _socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据缓存起来</span></span><br><span class="line">    _buffer.<span class="built_in">append</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理收到的数据</span></span><br><span class="line">    <span class="built_in">processData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理消息更新进度条</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::processData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(_buffer.<span class="built_in">size</span>() &gt;= TCP_HEAD_LEN)&#123;</span><br><span class="line">        <span class="comment">//先取出八字节头部</span></span><br><span class="line">        <span class="keyword">auto</span> head_byte = _buffer.<span class="built_in">left</span>(TCP_HEAD_LEN);</span><br><span class="line">        <span class="function">QDataStream <span class="title">stream</span><span class="params">(head_byte)</span></span>;</span><br><span class="line">        <span class="comment">//设置为大端模式</span></span><br><span class="line">        stream.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">        <span class="comment">//读取ID</span></span><br><span class="line">        quint16 msg_id;</span><br><span class="line">        stream &gt;&gt; msg_id;</span><br><span class="line">        <span class="comment">//读取长度</span></span><br><span class="line">        quint32 body_length;</span><br><span class="line">        stream &gt;&gt; body_length;</span><br><span class="line">        <span class="keyword">if</span>(_buffer.<span class="built_in">size</span>() &gt;= TCP_HEAD_LEN+body_length)&#123;</span><br><span class="line">            <span class="comment">//完整的消息体已经接受</span></span><br><span class="line">            QByteArray body = _buffer.<span class="built_in">mid</span>(TCP_HEAD_LEN,body_length);</span><br><span class="line">            <span class="comment">//去掉完整的消息包</span></span><br><span class="line">            _buffer = _buffer.<span class="built_in">mid</span>(TCP_HEAD_LEN+body_length);</span><br><span class="line">            <span class="comment">// 解析服务器发过来的消息</span></span><br><span class="line">            QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(body);</span><br><span class="line">            <span class="keyword">if</span>(jsonDoc.<span class="built_in">isNull</span>())&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create JSON doc.&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!jsonDoc.<span class="built_in">isObject</span>())&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;JSON is not an object.&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//qDebug() &lt;&lt; &quot;receive data is &quot; &lt;&lt; body;</span></span><br><span class="line">            <span class="comment">// 获取 JSON 对象</span></span><br><span class="line">            QJsonObject jsonObject = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line">            <span class="function">emit <span class="title">sig_logic_process</span><span class="params">(msg_id, jsonObject)</span></span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//消息未完全接受，所以中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单线程逻辑服务器"><a href="#单线程逻辑服务器" class="headerlink" title="单线程逻辑服务器"></a>单线程逻辑服务器</h2><p>我们先讲解单线程处理收包逻辑的服务器，以后再给大家将多线程的。</p>
<p>服务器要配合客户端，对报文头部大小做修改</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部总长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_TOTAL_LEN 6</span></span><br><span class="line"><span class="comment">//头部id长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_ID_LEN 2</span></span><br><span class="line"><span class="comment">//头部数据长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_DATA_LEN 4</span></span><br><span class="line"><span class="comment">// 接受队列最大个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RECVQUE  2000000</span></span><br><span class="line"><span class="comment">// 发送队列最大个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SENDQUE 2000000</span></span><br></pre></td></tr></table></figure>

<p>其余逻辑和我们在网络编程中讲的<code>IocontextPool</code>模型服务器一样</p>
<p>服务器收到报文头后调用<code>LogicSystem</code>来处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::AsyncReadBody</span><span class="params">(<span class="type">int</span> total_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="built_in">asyncReadFull</span>(total_len, [self, <span class="keyword">this</span>, total_len](<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transfered) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ec) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">Close</span>();</span><br><span class="line">				_server-&gt;<span class="built_in">ClearSession</span>(_session_id);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (bytes_transfered &lt; total_len) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;read length not match, read [&quot;</span> &lt;&lt; bytes_transfered &lt;&lt; <span class="string">&quot;] , total [&quot;</span></span><br><span class="line">					&lt;&lt; total_len&lt;&lt;<span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">Close</span>();</span><br><span class="line">				_server-&gt;<span class="built_in">ClearSession</span>(_session_id);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data , _data , bytes_transfered);</span><br><span class="line">			_recv_msg_node-&gt;_cur_len += bytes_transfered;</span><br><span class="line">			_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">			<span class="comment">//此处将消息投递到逻辑队列中</span></span><br><span class="line">			LogicSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line">			<span class="comment">//继续监听头部接受事件</span></span><br><span class="line">			<span class="built_in">AsyncReadHead</span>(HEAD_TOTAL_LEN);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>LogicSystem</code>会将消息投递到队列里，然后单线程处理,  服务器<code>LogicSystem</code>注册上传逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_fun_callbacks[ID_TEST_MSG_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;recv test data is  &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_TEST_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;data&quot;</span>] = data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_UPLOAD_FILE_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			<span class="comment">//std::cout &lt;&lt; &quot;recv file data is  &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 解码</span></span><br><span class="line">			std::string decoded = <span class="built_in">base64_decode</span>(data);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> seq = root[<span class="string">&quot;seq&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> name = root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			<span class="keyword">auto</span> total_size = root[<span class="string">&quot;total_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> trans_size = root[<span class="string">&quot;trans_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> file_path = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetFileOutPath</span>();</span><br><span class="line">			<span class="keyword">auto</span> file_path_str = (file_path / name).<span class="built_in">string</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;file_path_str is &quot;</span> &lt;&lt; file_path_str &lt;&lt; std::endl;</span><br><span class="line">			std::ofstream outfile;</span><br><span class="line">			<span class="comment">//第一个包</span></span><br><span class="line">			<span class="keyword">if</span> (seq == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 打开文件，如果存在则清空，不存在则创建</span></span><br><span class="line">				outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::trunc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 保存为文件</span></span><br><span class="line">				outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::app);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">				std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			outfile.<span class="built_in">write</span>(decoded.<span class="built_in">data</span>(), decoded.<span class="built_in">size</span>());</span><br><span class="line">			<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">				std::cerr &lt;&lt; <span class="string">&quot;写入文件失败。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			outfile.<span class="built_in">close</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;文件已成功保存为: &quot;</span> &lt;&lt; name &lt;&lt;  std::endl;</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">			rtvalue[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">			rtvalue[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">			rtvalue[<span class="string">&quot;trans_size&quot;</span>] = trans_size;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收到上传消息后写入文件。</p>
<h2 id="多线程逻辑服务器"><a href="#多线程逻辑服务器" class="headerlink" title="多线程逻辑服务器"></a>多线程逻辑服务器</h2><p>多线程逻辑服务器主要是为了缓解单线程接受数据造成的瓶颈，因为单线程接收数据，就会影响其他线程接收数据，所以考虑引入线程池处理收到的数据。</p>
<p>在多线程编程中我们讲过划分多线程设计的几种思路：</p>
<ol>
<li>按照任务划分，将不同的任务投递给不同的线程</li>
<li>按照线程数轮询处理</li>
<li>按照递归的方式划分</li>
</ol>
<p>很明显我们不是做二分查找之类的算法处理，所以不会采用第三种。</p>
<p>现在考虑第二种，如果客户端发送一个很大的文件，客户端将文件切分为几个小份发送，服务器通过<code>iocontext</code>池接受数据, 将接受的数据投递到线程池。</p>
<p>我们知道线程池处理任务是不分先后顺序的，只要投递到队列中的都会被无序取出处理。</p>
<p><img src="https://cdn.llfc.club/1732945106584.jpg" alt="https://cdn.llfc.club/1732945106584.jpg"></p>
<p>会造成数据包处理的乱序，当然可以最后交给一个线程去组合，统一写入文件，这么做的一个弊端就是如果文件很大，那就要等待完全重组完成才能组合为一个统一的包，如果文件很大，这个时间就会很长，当然也可以暂时缓存这些数据，每次收到后排序组合，比较麻烦。</p>
<p>所以这里推荐按照任务划分。</p>
<p>按照任务划分就是按照不同的客户端做区分，一个客户端传输的数据按照文件名字的hash值划分给不同的线程单独处理，也就是一个线程专门处理对应的hash值的任务，这样既能保证有序，又能保证其他线程可以处理其他任务，也有概率会命中hash同样的值投递给一个队列，但也扩充了并发能力。</p>
<p><img src="https://cdn.llfc.club/1732948742965.jpg" alt="https://cdn.llfc.club/1732948742965.jpg"></p>
<p>因为我们之前的逻辑处理也是单线程，所以考虑在逻辑层这里做一下解耦合，因为这个服务只是用来处理数据接受，不涉及多个连接互相访问。所以可以讲logic线程扩充为多个，按照<code>sessionid</code>将不同的逻辑分配给不同的线程处理。</p>
<p><img src="https://cdn.llfc.club/1732952125218.jpg" alt="https://cdn.llfc.club/1732952125218.jpg"></p>
<h2 id="多线程处理逻辑"><a href="#多线程处理逻辑" class="headerlink" title="多线程处理逻辑"></a>多线程处理逻辑</h2><p>将<code>LogicSystem</code>中添加多个<code>LogicWorker</code>用来处理逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  function&lt;<span class="type">void</span>(shared_ptr&lt;CSession&gt;, <span class="type">const</span> <span class="type">short</span> &amp;msg_id, <span class="type">const</span> string &amp;msg_data)&gt; FunCallBack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicSystem</span>:<span class="keyword">public</span> Singleton&lt;LogicSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;LogicSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">LogicSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(shared_ptr &lt; LogicNode&gt; msg, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">LogicSystem</span>();</span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;LogicWorker&gt; &gt; _workers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现投递逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LogicSystem::<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LOGIC_WORKER_COUNT; i++) &#123;</span><br><span class="line">		_workers.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;LogicWorker&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogicSystem::~<span class="built_in">LogicSystem</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::PostMsgToQue</span><span class="params">(shared_ptr &lt; LogicNode&gt; msg, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">	_workers[index]-&gt;<span class="built_in">PostTask</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个LogicWorker都包含一个线程，这样LogicWorker可以在独立的线程里处理任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicWorker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LogicWorker</span>();</span><br><span class="line">	~<span class="built_in">LogicWorker</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; task)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RegisterCallBacks</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">task_callback</span><span class="params">(std::shared_ptr&lt;LogicNode&gt;)</span></span>;</span><br><span class="line">	std::thread _work_thread;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;LogicNode&gt;&gt; _task_que;</span><br><span class="line">	std::atomic&lt;<span class="type">bool</span>&gt; _b_stop;</span><br><span class="line">	std::mutex  _mtx;</span><br><span class="line">	std::condition_variable _cv;</span><br><span class="line">	std::unordered_map&lt;<span class="type">short</span>, FunCallBack&gt; _fun_callbacks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>LogicWorker启动一个线程处理任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LogicWorker::<span class="built_in">LogicWorker</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">RegisterCallBacks</span>();</span><br><span class="line"></span><br><span class="line">	_work_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="keyword">while</span> (!_b_stop) &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">			_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">				<span class="keyword">if</span>(_b_stop) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (_task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> task = _task_que.<span class="built_in">front</span>();</span><br><span class="line">			<span class="built_in">task_callback</span>(task);</span><br><span class="line">			_task_que.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然要提前注册好任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicWorker::RegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_fun_callbacks[ID_TEST_MSG_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;recv test data is  &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_TEST_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;data&quot;</span>] = data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_UPLOAD_FILE_REQ] = [<span class="keyword">this</span>](shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id,</span><br><span class="line">		<span class="type">const</span> string&amp; msg_data) &#123;</span><br><span class="line">			Json::Reader reader;</span><br><span class="line">			Json::Value root;</span><br><span class="line">			reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">			<span class="keyword">auto</span> seq = root[<span class="string">&quot;seq&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> name = root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			<span class="keyword">auto</span> total_size = root[<span class="string">&quot;total_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> trans_size = root[<span class="string">&quot;trans_size&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> last = root[<span class="string">&quot;last&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">			<span class="keyword">auto</span> file_data = root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">			Json::Value  rtvalue;</span><br><span class="line">			<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">				session-&gt;Send(return_str, ID_UPLOAD_FILE_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">				&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用 std::hash 对字符串进行哈希</span></span><br><span class="line">			std::hash&lt;std::string&gt; hash_fn;</span><br><span class="line">			<span class="type">size_t</span> hash_value = <span class="built_in">hash_fn</span>(name); <span class="comment">// 生成哈希值</span></span><br><span class="line">			<span class="type">int</span> index = hash_value % FILE_WORKER_COUNT;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Hash value: &quot;</span> &lt;&lt; hash_value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">			FileSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(</span><br><span class="line">				std::<span class="built_in">make_shared</span>&lt;FileTask&gt;(session, name, seq, total_size,</span><br><span class="line">					trans_size, last, file_data),</span><br><span class="line">				index</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">			rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			rtvalue[<span class="string">&quot;total_size&quot;</span>] = total_size;</span><br><span class="line">			rtvalue[<span class="string">&quot;seq&quot;</span>] = seq;</span><br><span class="line">			rtvalue[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">			rtvalue[<span class="string">&quot;trans_size&quot;</span>] = trans_size;</span><br><span class="line">			rtvalue[<span class="string">&quot;last&quot;</span>] = last;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicWorker::task_callback</span><span class="params">(std::shared_ptr&lt;LogicNode&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;recv_msg id  is &quot;</span> &lt;&lt; task-&gt;_recvnode-&gt;_msg_id &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">auto</span> call_back_iter = _fun_callbacks.<span class="built_in">find</span>(task-&gt;_recvnode-&gt;_msg_id);</span><br><span class="line">	<span class="keyword">if</span> (call_back_iter == _fun_callbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	call_back_iter-&gt;<span class="built_in">second</span>(task-&gt;_session, task-&gt;_recvnode-&gt;_msg_id,</span><br><span class="line">		std::<span class="built_in">string</span>(task-&gt;_recvnode-&gt;_data, task-&gt;_recvnode-&gt;_cur_len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如对于文件上传，<code>ID_UPLOAD_FILE_REQ</code>就调用对应的回调，在回调函数里我们再次将要处理的任务封装好投递到文件系统</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileSystem::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">PostMsgToQue</span>(</span><br><span class="line">				std::<span class="built_in">make_shared</span>&lt;FileTask&gt;(session, name, seq, total_size,</span><br><span class="line">					trans_size, last, file_data),</span><br><span class="line">				index</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<p>文件系统和逻辑系统类似，包含一堆FileWorker</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> :<span class="keyword">public</span> Singleton&lt;FileSystem&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;FileSystem&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">FileSystem</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsgToQue</span><span class="params">(shared_ptr &lt;FileTask&gt; msg, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">FileSystem</span>();</span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;FileWorker&gt;&gt;  _file_workers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现投递逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileSystem::~<span class="built_in">FileSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileSystem::PostMsgToQue</span><span class="params">(shared_ptr&lt;FileTask&gt; msg, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_file_workers[index]-&gt;<span class="built_in">PostTask</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileSystem::<span class="built_in">FileSystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILE_WORKER_COUNT; i++) &#123;</span><br><span class="line">		_file_workers.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;FileWorker&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义文件任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileTask</span> &#123;</span><br><span class="line">	<span class="built_in">FileTask</span>(std::shared_ptr&lt;CSession&gt; session, std::string name,</span><br><span class="line">		<span class="type">int</span> seq, <span class="type">int</span> total_size, <span class="type">int</span> trans_size, <span class="type">int</span> last, </span><br><span class="line">		std::string file_data) :_session(session),</span><br><span class="line">		_seq(seq),_name(name),_total_size(total_size),</span><br><span class="line">		_trans_size(trans_size),_last(last),_file_data(file_data)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">FileTask</span>()&#123;&#125;</span><br><span class="line">	std::shared_ptr&lt;CSession&gt; _session;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _seq ;</span><br><span class="line">	std::string _name ;</span><br><span class="line">	<span class="type">int</span> _total_size ;</span><br><span class="line">	<span class="type">int</span> _trans_size ;</span><br><span class="line">	<span class="type">int</span> _last ;</span><br><span class="line">	std::string _file_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现文件工作者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileWorker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FileWorker</span>();</span><br><span class="line">	~<span class="built_in">FileWorker</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">task_callback</span><span class="params">(std::shared_ptr&lt;FileTask&gt;)</span></span>;</span><br><span class="line">	std::thread _work_thread;</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;FileTask&gt;&gt; _task_que;</span><br><span class="line">	std::atomic&lt;<span class="type">bool</span>&gt; _b_stop;</span><br><span class="line">	std::mutex  _mtx;</span><br><span class="line">	std::condition_variable _cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数启动线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FileWorker::<span class="built_in">FileWorker</span>():_b_stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_work_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="keyword">while</span> (!_b_stop) &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">			_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">				<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (_task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_b_stop) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> task = _task_que.<span class="built_in">front</span>();</span><br><span class="line">			_task_que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="built_in">task_callback</span>(task);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构需等待线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileWorker::~<span class="built_in">FileWorker</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_b_stop = <span class="literal">true</span>;</span><br><span class="line">	_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	_work_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>投递任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileWorker::PostTask</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">		_task_que.<span class="built_in">push</span>(task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为线程会触发回调函数保存文件，所以我们实现回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileWorker::task_callback</span><span class="params">(std::shared_ptr&lt;FileTask&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	std::string decoded = <span class="built_in">base64_decode</span>(task-&gt;_file_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> file_path = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetFileOutPath</span>();</span><br><span class="line">	<span class="keyword">auto</span> file_path_str = (file_path / task-&gt;_name).<span class="built_in">string</span>();</span><br><span class="line">	<span class="keyword">auto</span> last = task-&gt;_last;</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; &quot;file_path_str is &quot; &lt;&lt; file_path_str &lt;&lt; std::endl;</span></span><br><span class="line">	std::ofstream outfile;</span><br><span class="line">	<span class="comment">//第一个包</span></span><br><span class="line">	<span class="keyword">if</span> (task-&gt;_seq == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 打开文件，如果存在则清空，不存在则创建</span></span><br><span class="line">		outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::trunc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 保存为文件</span></span><br><span class="line">		outfile.<span class="built_in">open</span>(file_path_str, std::ios::binary | std::ios::app);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;无法打开文件进行写入。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">write</span>(decoded.<span class="built_in">data</span>(), decoded.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (!outfile) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;写入文件失败。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">if</span> (last) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;文件已成功保存为: &quot;</span> &lt;&lt; task-&gt;_name &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p><img src="https://cdn.llfc.club/1732955339237.jpg" alt="https://cdn.llfc.club/1732955339237.jpg"></p>
<h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server">https://gitee.com/secondtonone1/boostasio-learn/tree/master/network/day26-multithread-res-server</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/23/cppbase21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/23/cppbase21/" itemprop="url">零基础C++(21) 类相关面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-23T09:47:27+08:00">
                2024-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>详细技术视频请看我的主页</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">C++教程视频</a></p>
<h2 id="什么是默认构造"><a href="#什么是默认构造" class="headerlink" title="什么是默认构造"></a>什么是默认构造</h2><p>默认构造就是不带参数的构造函数，如果我们不实现任何构造函数，系统会为我们生成一个默认的构造函数</p>
<p>比如下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以我们可以直接使用默认构造函数构造一个对象，并且打印成员<code>_i</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试默认合成</span></span><br><span class="line">JoiningThread jt;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member _i is -1284874240</span><br></pre></td></tr></table></figure>

<p>可以看到默认构造函数并不会帮我们初始化类成员变量。</p>
<h2 id="什么是有参构造"><a href="#什么是有参构造" class="headerlink" title="什么是有参构造"></a>什么是有参构造</h2><p>有参构造就是传递参数的构造函数，可以根据参数构造对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JoiningThread</span>(<span class="type">int</span> i) : _i&#123;i&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下方式构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JoiningThread <span class="title">jt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>当我们执行程序，会输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member _i is 1</span><br></pre></td></tr></table></figure>

<p>但如果这样构造会产生问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JoiningThread jt;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>如果我们实现了参数构造而不实现无参构造，系统将不会为我们实现默认构造，导致无法使用默认构造生成对象。</p>
</blockquote>
<p>所以稳妥一点，我们基本都会实现无参构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JoiningThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JoiningThread</span>() :_i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">JoiningThread</span>(<span class="type">int</span> i) : _i&#123;i&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIndex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread <span class="type">_t</span>;</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝构造函数是什么"><a href="#拷贝构造函数是什么" class="headerlink" title="拷贝构造函数是什么"></a><strong>拷贝构造函数是什么</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：拷贝构造函数用于创建一个对象，该对象是通过复制另一个同类型对象来初始化的。</p>
</li>
<li><p>调用时机</p>
<p>：</p>
<ul>
<li>使用现有对象初始化新对象。</li>
<li>按值传递对象作为函数参数。</li>
<li>按值返回对象。</li>
</ul>
</li>
<li><p><strong>默认拷贝构造函数</strong>：成员逐个拷贝。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        <span class="comment">// 复制代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="是否会默认生成拷贝构造"><a href="#是否会默认生成拷贝构造" class="headerlink" title="是否会默认生成拷贝构造"></a>是否会默认生成拷贝构造</h2><p>在 C++ 中，如果你没有为一个类显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。这个默认拷贝构造函数会按成员的逐个拷贝（member-wise copy）方式来复制对象的每个成员变量。</p>
<h2 id="默认拷贝构造函数的行为"><a href="#默认拷贝构造函数的行为" class="headerlink" title="默认拷贝构造函数的行为"></a>默认拷贝构造函数的行为</h2><ol>
<li><strong>逐个拷贝</strong>：默认拷贝构造函数会逐个拷贝所有的非静态成员变量。</li>
<li><strong>指针成员</strong>：如果类中有指针成员，默认拷贝构造函数只会拷贝指针的值（地址），而不会拷贝指针所指向的对象。这可能会导致多个对象指向同一块内存，进而引发问题（如双重释放、内存泄漏等）。</li>
<li>**<code>const</code> 和<code>引用成员</code>**：如果类中有 <code>const</code> 成员或引用成员，编译器不会生成默认的拷贝构造函数，因为这些成员不能被复制。</li>
<li>类中包含不可拷贝对象时，无法合成默认拷贝构造函数</li>
</ol>
<h2 id="拷贝构造是否必须实现"><a href="#拷贝构造是否必须实现" class="headerlink" title="拷贝构造是否必须实现"></a>拷贝构造是否必须实现</h2><p>当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。</p>
<p>比如一个类<code>JoiningThread</code>中有成员变量<code>std::thread</code>，<code>std::thread</code>没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。</p>
<p>比如我们这样调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JoiningThread <span class="title">jt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">JoiningThread <span class="title">jt2</span><span class="params">(jt)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;member _i is &quot;</span> &lt;&lt; jt.<span class="built_in">GetIndex</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>上面代码报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of deleted function <span class="string">&#x27;std::thread::thread(const std::thread&amp;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以我们要显示实现拷贝构造，指定一个拷贝规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JoiningThread</span>(<span class="type">const</span> JoiningThread &amp; other): _i(other._i)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是浅拷贝和深拷贝"><a href="#什么是浅拷贝和深拷贝" class="headerlink" title="什么是浅拷贝和深拷贝"></a>什么是浅拷贝和深拷贝</h2><p>类在拷贝构造或者拷贝赋值的时候，将被拷贝的类中的成员值拷贝到目的类，如果被拷贝的类中包含指针成员，只是简单的拷贝指针的值。</p>
<p>同样析构也要显示编写，等待线程完成。</p>
<p>除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果</p>
<p><img src="https://cdn.llfc.club/1731294878994.jpg" alt="https://cdn.llfc.club/1731294878994.jpg"></p>
<p><img src="https://cdn.llfc.club/1731295328032.jpg-llfc" alt="https://cdn.llfc.club/1731295328032.jpg-llfc"></p>
<h2 id="构造顺序和析构顺序"><a href="#构造顺序和析构顺序" class="headerlink" title="构造顺序和析构顺序"></a>构造顺序和析构顺序</h2><p>类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？</p>
<p>如果析构的时候是A先析构还是B先析构呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InnerB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InnerB</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;InnerB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">InnerB</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~InnerB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrapperC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WrapperC</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WrapperC()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">WrapperC</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~WrapperC()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    InnerB _inner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行结果，先调用B的构造，在调用C的构造。</p>
<p>析构时，先析构C再析构B</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InnerB</span>()</span><br><span class="line"><span class="built_in">WrapperC</span>()</span><br><span class="line">~<span class="built_in">WrapperC</span>()</span><br><span class="line">~<span class="built_in">InnerB</span>()</span><br></pre></td></tr></table></figure>

<h2 id="类默认构造是否必须实现"><a href="#类默认构造是否必须实现" class="headerlink" title="类默认构造是否必须实现"></a>类默认构造是否必须实现</h2><p>如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。</p>
<p>系统提供的合成的默认构造函数不会对成员做初始化操作。</p>
<p>比如我们之后要学到的继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>: <span class="keyword">public</span> BaseA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedA</span>(std::string name,std::string num) :</span><br><span class="line">    <span class="built_in">BaseA</span>(name), _num(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string _num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DerivedA <span class="title">a</span><span class="params">(<span class="string">&quot;zack&quot;</span>,<span class="string">&quot;1001&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="this-指针的特性和用途"><a href="#this-指针的特性和用途" class="headerlink" title="this 指针的特性和用途"></a><code>this</code> 指针的特性和用途</h2><ol>
<li><p><strong>指向当前对象</strong>：</p>
<ul>
<li><code>this</code> 指针是一个隐式参数，指向调用成员函数的对象。通过 <code>this</code>，你可以访问当前对象的属性和方法。</li>
</ul>
</li>
<li><p><strong>区分成员变量和参数</strong>：</p>
<ul>
<li><p>在构造函数或成员函数中，参数名和成员变量可能同名。使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure>

<p>可以明确指代成员变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>返回当前对象</strong>：</p>
<ul>
<li>```<br>this<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以用于返回当前对象的引用，以支持链式调用。例如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    MyClass&amp; setValue(int value) &#123;</span><br><span class="line">        this-&gt;value = value;</span><br><span class="line">        return *this; // 返回当前对象的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.setValue(10).setValue(20); // 链式调用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>在 const 成员函数中的使用</strong>：</p>
<ul>
<li>在 <code>const</code> 成员函数中，<code>this</code> 的类型为 <code>const MyClass*</code>，这意味着你不能通过 <code>this</code> 修改成员变量。这有助于确保对象的状态不被改变。</li>
</ul>
</li>
<li><p><strong>在静态成员函数中的不可用性</strong>：</p>
<ul>
<li>静态成员函数没有 <code>this</code> 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。</li>
</ul>
</li>
</ol>
<p><strong>示例代码</strong></p>
<p>以下是一个简单的示例，展示了 <code>this</code> 指针的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl; <span class="comment">// 使用 this 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">printValue</span>(); <span class="comment">// 链式调用，输出: Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="delete和default"><a href="#delete和default" class="headerlink" title="delete和default"></a>delete和default</h2><p><code>C++11</code>用法：</p>
<p>delete可以删除指定的构造函数。</p>
<p>default可以指定某个构造函数为系统默认合成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">DefaultClass</span>(<span class="type">const</span> DefaultClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DefaultClass &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DefaultClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;out, <span class="type">const</span> DefaultClass &amp;defaultClass);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _num ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主函数中调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultClass b;</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出<code>num</code>是一个随机数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultClass num is 331</span><br></pre></td></tr></table></figure>



<h2 id="什么是移动构造函数？与拷贝构造函数有何不同？"><a href="#什么是移动构造函数？与拷贝构造函数有何不同？" class="headerlink" title="什么是移动构造函数？与拷贝构造函数有何不同？"></a><strong>什么是移动构造函数？与拷贝构造函数有何不同？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：移动构造函数用于通过“移动”资源来初始化对象，而不是复制资源。</p>
</li>
<li><p><strong>语法</strong>：使用右值引用作为参数 (<code>MyClass(MyClass&amp;&amp; other)</code>).</p>
</li>
<li><p>优势</p>
<p>：</p>
<ul>
<li>性能更高，避免不必要的深拷贝。</li>
<li>适用于临时对象。</li>
</ul>
</li>
<li><p>区别</p>
<p>：</p>
<ul>
<li>拷贝构造函数复制资源，移动构造函数转移资源所有权。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        <span class="comment">// 移动资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="默认构造函数和用户定义的构造函数有什么区别？"><a href="#默认构造函数和用户定义的构造函数有什么区别？" class="headerlink" title="默认构造函数和用户定义的构造函数有什么区别？"></a><strong>默认构造函数和用户定义的构造函数有什么区别？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p>默认构造函数</p>
<p>：</p>
<ul>
<li>无参数的构造函数。</li>
<li>如果没有用户定义的构造函数，编译器会自动生成一个默认构造函数。</li>
</ul>
</li>
<li><p>用户定义的构造函数</p>
<p>：</p>
<ul>
<li>开发者自定义的构造函数，可以有参数。</li>
<li>一旦定义了任何构造函数，编译器不会再生成默认构造函数，除非显式声明。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">// 有参数的构造函数</span></span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="什么是初始化列表？为什么在构造函数中使用它？"><a href="#什么是初始化列表？为什么在构造函数中使用它？" class="headerlink" title="什么是初始化列表？为什么在构造函数中使用它？"></a><strong>什么是初始化列表？为什么在构造函数中使用它？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：初始化列表是在构造函数的参数列表之后，函数体之前，用于初始化成员变量的语法。</p>
</li>
<li><p>优点</p>
<p>：</p>
<ul>
<li>提高性能，特别是对于常量成员或引用成员。</li>
<li>必须用于初始化常量成员、引用成员以及基类。</li>
<li>避免对象先默认构造再赋值，减少不必要的操作。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123; <span class="comment">// 初始化列表</span></span><br><span class="line">        <span class="comment">// 其他初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="什么是虚析构函数？为什么需要它？"><a href="#什么是虚析构函数？为什么需要它？" class="headerlink" title="什么是虚析构函数？为什么需要它？"></a><strong>什么是虚析构函数？为什么需要它？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：在基类中将析构函数声明为<code>virtual</code>，以确保通过基类指针删除派生类对象时，能正确调用派生类的析构函数。</p>
</li>
<li><p>用途</p>
<p>：</p>
<ul>
<li>防止内存泄漏。</li>
<li>确保派生类的资源被正确释放。</li>
</ul>
</li>
<li><p>不使用虚析构函数的风险</p>
<p>：</p>
<ul>
<li>仅调用基类析构函数，导致派生类资源未释放。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>如果<code>BaseA</code>的析构不写成虚析构，则主函数开辟子类对象赋值给基类指针，以后<code>delete</code>基类指针的时候会发现没有析构子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(std::string name):_name(name)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BaseA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>: <span class="keyword">public</span> BaseA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedA</span>(std::string name,std::string num) :</span><br><span class="line">    <span class="built_in">BaseA</span>(name), _num(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DerivedA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~DerivedA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主函数回收内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseA* base = <span class="keyword">new</span> <span class="built_in">DerivedA</span>(<span class="string">&quot;zack&quot;</span>,<span class="string">&quot;1002&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> base;</span><br></pre></td></tr></table></figure>

<p>会看到只调用了基类<code>BaseA</code>的析构函数。</p>
<p>当BaseA的析构改为虚析构的时候，才会回收子类DerivedA</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(std::string name):_name(name)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseA</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~BaseA()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="什么是委托构造函数？它是如何工作的？（C-11引入的特性）"><a href="#什么是委托构造函数？它是如何工作的？（C-11引入的特性）" class="headerlink" title="什么是委托构造函数？它是如何工作的？（C++11引入的特性）"></a><strong>什么是委托构造函数？它是如何工作的？（C++11引入的特性）</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>定义</strong>：一个构造函数可以调用同一类中的另一个构造函数，从而委托初始化任务。</p>
</li>
<li><p>优点</p>
<p>：</p>
<ul>
<li>避免代码重复，提升代码可维护性。</li>
</ul>
</li>
<li><p><strong>语法</strong>：使用构造函数初始化列表中的类名和参数。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>, <span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="什么是析构函数的顺序？"><a href="#什么是析构函数的顺序？" class="headerlink" title="什么是析构函数的顺序？"></a><strong>什么是析构函数的顺序？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><strong>成员变量的析构顺序</strong>：按照声明的逆序析构。</li>
<li><strong>继承关系的析构顺序</strong>：先析构派生类的成员和资源，再析构基类。</li>
<li><strong>全局/静态对象</strong>：按照创建的逆序析构。</li>
</ul>
<p><strong>示例说明：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    <span class="comment">// 当obj被销毁时，首先调用Derived的析构函数，然后调用Base的析构函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived析构</span><br><span class="line">Base析构</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="如何防止对象被复制？"><a href="#如何防止对象被复制？" class="headerlink" title="如何防止对象被复制？"></a><strong>如何防止对象被复制？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><strong>C++11及以上</strong>：使用<code>delete</code>关键字显式删除拷贝构造函数和拷贝赋值运算符。</li>
<li><strong>C++11之前</strong>：将拷贝构造函数和拷贝赋值运算符声明为私有且不实现。</li>
</ul>
<p><strong>示例（C++11及以上）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="构造函数中抛出异常会发生什么？"><a href="#构造函数中抛出异常会发生什么？" class="headerlink" title="构造函数中抛出异常会发生什么？"></a><strong>构造函数中抛出异常会发生什么？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><strong>对象未完全构造</strong>：如果构造函数中抛出异常，析构函数不会被调用，因为对象尚未完全构造。</li>
<li><strong>资源泄漏风险</strong>：如果在构造函数中分配了资源，需使用RAII（资源获取即初始化）类或智能指针来确保资源被正确释放。</li>
<li><strong>异常安全</strong>：确保在构造函数抛出异常时，任何已经初始化的成员都会被正确析构。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        data.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;构造函数异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="解释RAII及其与构造函数、析构函数的关系"><a href="#解释RAII及其与构造函数、析构函数的关系" class="headerlink" title="解释RAII及其与构造函数、析构函数的关系"></a><strong>解释<code>RAII</code>及其与构造函数、析构函数的关系</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><code>RAII</code>（资源获取即初始化）</p>
<p>：</p>
<ul>
<li>编程范式，通过对象的生命周期管理资源。</li>
<li>资源在对象构造时获取，在对象析构时释放。</li>
</ul>
</li>
<li><p>关系</p>
<p>：</p>
<ul>
<li>构造函数负责获取资源。</li>
<li>析构函数负责释放资源。</li>
</ul>
</li>
<li><p>优点</p>
<p>：</p>
<ul>
<li>自动管理资源，防止内存泄漏。</li>
<li>异常安全，确保资源在异常发生时被释放。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    FILE* file;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        file = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file) <span class="built_in">fclose</span>(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁止拷贝和移动</span></span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    FileHandler&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="解释什么是赋值运算符重载？与拷贝构造函数有何不同？"><a href="#解释什么是赋值运算符重载？与拷贝构造函数有何不同？" class="headerlink" title="解释什么是赋值运算符重载？与拷贝构造函数有何不同？"></a><strong>解释什么是赋值运算符重载？与拷贝构造函数有何不同？</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p><strong>赋值运算符重载</strong>：通过重载<code>operator=</code>，定义对象之间的赋值行为。</p>
</li>
<li><p>区别与拷贝构造函数</p>
<p>：</p>
<ul>
<li>拷贝构造函数用于初始化新对象。</li>
<li>赋值运算符用于将一个已存在的对象赋值给另一个已存在的对象。</li>
</ul>
</li>
<li><p>常规实现</p>
<p>：</p>
<ul>
<li>检查自赋值。</li>
<li>释放已有资源。</li>
<li>复制资源。</li>
<li>返回<code>*this</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123; <span class="comment">// 赋值运算符重载</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自赋值检查</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 释放已有资源</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 复制资源</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="解释静态成员变量在构造和析构中的处理"><a href="#解释静态成员变量在构造和析构中的处理" class="headerlink" title="解释静态成员变量在构造和析构中的处理"></a><strong>解释静态成员变量在构造和析构中的处理</strong></h2><p><strong>回答要点：</strong></p>
<ul>
<li><p>静态成员变量</p>
<p>：</p>
<ul>
<li>属于类本身，而非任何对象实例。</li>
<li>在程序开始时初始化，在程序结束时析构。</li>
</ul>
</li>
<li><p>构造顺序</p>
<p>：</p>
<ul>
<li>单例模式中，静态成员在第一次使用时构造。</li>
</ul>
</li>
<li><p>析构顺序</p>
<p>：</p>
<ul>
<li>按逆序构造顺序析构，确保依赖关系被正确处理。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> MyClass instance;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="string">&quot;构造\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//放在cpp中</span></span><br><span class="line">MyClass MyClass::instance; <span class="comment">// 静态成员变量定义</span></span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造</span><br><span class="line">析构</span><br></pre></td></tr></table></figure>

<h2 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a><strong>虚函数原理</strong></h2><h2 id="包含虚函数的类构成"><a href="#包含虚函数的类构成" class="headerlink" title="包含虚函数的类构成"></a>包含虚函数的类构成</h2><p>参考我得另一篇文章，<a target="_blank" rel="noopener" href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73">https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2CmcOeP6BZMbtNiglPTkbmnpb73</a></p>
<h2 id="虚继承与菱形继承问题"><a href="#虚继承与菱形继承问题" class="headerlink" title="虚继承与菱形继承问题"></a><strong>虚继承与菱形继承问题</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string brand;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Device</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">brand</span>(brand_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBrand</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Brand: &quot;</span> &lt;&lt; brand &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Laptop，虚继承 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Laptop</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Tablet，虚继承 Device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tablet</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tablet</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Convertible</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Convertible</span> : <span class="keyword">public</span> Laptop, <span class="keyword">public</span> Tablet &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Convertible</span>(<span class="type">const</span> std::string&amp; brand_) : <span class="built_in">Device</span>(brand_), <span class="built_in">Laptop</span>(brand_), <span class="built_in">Tablet</span>(brand_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Convertible <span class="title">c</span><span class="params">(<span class="string">&quot;TechBrand&quot;</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">showBrand</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Brand: TechBrand</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<ul>
<li>在无虚继承的情况下，<code>Convertible</code> 类将拥有两份 <code>Device</code> 的成员变量，这会导致二义性问题。</li>
<li>通过使用虚继承（<code>virtual public</code>），确保 <code>Convertible</code> 类只有一份 <code>Device</code> 的成员。</li>
<li>在 <code>Convertible</code> 的构造函数中，需要明确调用基类 <code>Device</code> 的构造函数，避免二义性。</li>
<li>在 <code>main</code> 函数中，创建一个 <code>Convertible</code> 对象，并调用 <code>showBrand()</code> 函数，正确显示品牌名称。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>菱形继承（多重继承导致的重复基类）可以通过虚继承来解决，确保共享同一份基类成员。</li>
<li>虚继承会增加一定的开销，需根据具体需求权衡使用。</li>
</ul>
<h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p><strong>概念定义</strong></p>
<ul>
<li>在 C++ 中，协变返回类型（Covariant Return Types）是一个与函数重写（Override）相关的概念。当一个派生类重写基类的虚函数时，协变返回类型允许派生类的函数返回一个从基类函数返回类型派生而来的类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base cloned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 协变返回类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived cloned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    Base* bClone = b-&gt;<span class="built_in">clone</span>(); <span class="comment">// 输出: Base cloned.</span></span><br><span class="line">    Base* dClone = d-&gt;<span class="built_in">clone</span>(); <span class="comment">// 输出: Derived cloned.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">    <span class="keyword">delete</span> bClone;</span><br><span class="line">    <span class="keyword">delete</span> dClone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base cloned.</span><br><span class="line">Derived cloned.</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<ul>
<li><p>基类 <code>Base</code> 定义了一个虚函数 <code>clone()</code>，返回 <code>Base*</code> 类型的指针。</p>
</li>
<li><p>派生类 <code>Derived</code> 重写了 <code>clone()</code> 函数，返回类型为 <code>Derived*</code>，这是一种协变返回类型。</p>
</li>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure>

<p>函数中，通过基类指针调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone()</span><br></pre></td></tr></table></figure>

<p>函数：</p>
<ul>
<li>对于 <code>Base</code> 对象，调用 <code>Base::clone()</code>。</li>
<li>对于 <code>Derived</code> 对象，由于虚函数机制，调用 <code>Derived::clone()</code>。</li>
</ul>
</li>
<li><p>协变返回类型允许派生类的重写函数返回更具体的类型，增强类型安全性和代码可读性。</p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>协变返回类型必须满足派生类返回类型是基类返回类型的派生类。</li>
<li>编译器会检查协变返回类型的正确性，确保类型安全。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/23/cppbase20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/23/cppbase20/" itemprop="url">零基础C++(20) 继承和多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-23T09:44:32+08:00">
                2024-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-类继承（Class-Inheritance）"><a href="#1-类继承（Class-Inheritance）" class="headerlink" title="1. 类继承（Class Inheritance）"></a>1. 类继承（Class Inheritance）</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>类继承</strong> 是面向对象编程（OOP）中的一个核心概念，允许一个类（派生类）从另一个类（基类）继承属性和行为。通过继承，派生类可以重用基类的代码，并根据需要添加新的成员或重写现有成员。</p>
<h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedMember;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-代码示例"><a href="#1-3-代码示例" class="headerlink" title="1.3 代码示例"></a>1.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal eats.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        age = a; <span class="comment">// 访问受保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 继承自Animal</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// Dog特有</span></span><br><span class="line"></span><br><span class="line">    myDog.<span class="built_in">setAge</span>(<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog&#x27;s age: &quot;</span> &lt;&lt; myDog.<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-执行结果"><a href="#1-4-执行结果" class="headerlink" title="1.4 执行结果"></a>1.4 执行结果</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal eats.</span><br><span class="line">Dog barks.</span><br><span class="line">Dog<span class="symbol">&#x27;s</span> age: <span class="number">5</span></span><br></pre></td></tr></table></figure>





<h2 id="2-虚函数（Virtual-Functions）"><a href="#2-虚函数（Virtual-Functions）" class="headerlink" title="2. 虚函数（Virtual Functions）"></a>2. 虚函数（Virtual Functions）</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><strong>虚函数</strong> 允许派生类重新定义基类中的函数，以实现多态性。在运行时，根据对象的实际类型调用相应的函数版本。</p>
<h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(<span class="type">const</span> Shape&amp; shape)</span> </span>&#123;</span><br><span class="line">    shape.<span class="built_in">draw</span>(); <span class="comment">// 动态绑定，根据实际对象类型调用对应的draw()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c;</span><br><span class="line">    Square s;</span><br><span class="line">    Shape genericShape;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(c);           <span class="comment">// 输出: Drawing a circle.</span></span><br><span class="line">    <span class="built_in">render</span>(s);           <span class="comment">// 输出: Drawing a square.</span></span><br><span class="line">    <span class="built_in">render</span>(genericShape); <span class="comment">// 输出: Drawing a shape.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-执行结果"><a href="#2-4-执行结果" class="headerlink" title="2.4 执行结果"></a>2.4 执行结果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing <span class="selector-tag">a</span> circle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> square.</span><br><span class="line">Drawing <span class="selector-tag">a</span> shape.</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-纯虚类与抽象基类（Pure-Virtual-Classes-and-Abstract-Base-Classes）"><a href="#3-纯虚类与抽象基类（Pure-Virtual-Classes-and-Abstract-Base-Classes）" class="headerlink" title="3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）"></a>3. 纯虚类与抽象基类（Pure Virtual Classes and Abstract Base Classes）</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>纯虚函数</strong> 是在基类中声明但不提供实现的虚函数。包含至少一个纯虚函数的类称为 <strong>抽象基类</strong>（Abstract Base Class，ABC）。抽象基类不能被实例化，要求派生类必须实现所有纯虚函数才能被实例化。</p>
<h3 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printm</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-代码示例"><a href="#3-3-代码示例" class="headerlink" title="3.3 代码示例"></a>3.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vehicle</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car engine started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motorcycle</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Motorcycle engine started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Vehicle v; // 错误: 不能实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    Car car;</span><br><span class="line">    Motorcycle bike;</span><br><span class="line"></span><br><span class="line">    car.<span class="built_in">startEngine</span>();     <span class="comment">// 输出: Car engine started.</span></span><br><span class="line">    bike.<span class="built_in">startEngine</span>();    <span class="comment">// 输出: Motorcycle engine started.</span></span><br><span class="line"></span><br><span class="line">    Vehicle* v1 = &amp;car;</span><br><span class="line">    Vehicle* v2 = &amp;bike;</span><br><span class="line"></span><br><span class="line">    v1-&gt;<span class="built_in">startEngine</span>(); <span class="comment">// 动态绑定，输出: Car engine started.</span></span><br><span class="line">    v2-&gt;<span class="built_in">startEngine</span>(); <span class="comment">// 动态绑定，输出: Motorcycle engine started.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-执行结果"><a href="#3-4-执行结果" class="headerlink" title="3.4 执行结果"></a>3.4 执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car engine started.</span><br><span class="line">Motorcycle engine started.</span><br><span class="line">Car engine started.</span><br><span class="line">Motorcycle engine started.</span><br></pre></td></tr></table></figure>



<h2 id="4-继承后的访问控制（Access-Control-in-Inheritance）"><a href="#4-继承后的访问控制（Access-Control-in-Inheritance）" class="headerlink" title="4. 继承后的访问控制（Access Control in Inheritance）"></a>4. 继承后的访问控制（Access Control in Inheritance）</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>继承时的 <strong>访问控制</strong> 决定了基类成员在派生类中的可访问性。继承方式主要有三种：<code>public</code>、<code>protected</code> 和 <code>private</code>。它们影响继承成员的访问级别。</p>
<h3 id="4-2-语法与影响"><a href="#4-2-语法与影响" class="headerlink" title="4.2 语法与影响"></a>4.2 语法与影响</h3><ul>
<li><strong>公有继承（public inheritance）</strong>：<ul>
<li>基类的 <code>public</code> 成员在派生类中保持 <code>public</code>。</li>
<li>基类的 <code>protected</code> 成员在派生类中保持 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员在派生类中不可访问。</li>
</ul>
</li>
<li><strong>保护继承（protected inheritance）</strong>：<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>protected</code>。</li>
</ul>
</li>
<li><strong>私有继承（private inheritance）</strong>：<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>
</ul>
</li>
</ul>
<h3 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicMember;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedMember;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 可访问</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 可访问</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误：privateMember 在派生类中不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerived</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 转为 protected</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 转为 protected</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicMember = <span class="number">1</span>;      <span class="comment">// 转为 private</span></span><br><span class="line">        protectedMember = <span class="number">2</span>;   <span class="comment">// 转为 private</span></span><br><span class="line">        <span class="comment">// privateMember = 3;  // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublicDerived pubDer;</span><br><span class="line">    pubDer.publicMember = <span class="number">10</span>; <span class="comment">// 可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProtectedDerived protDer;</span></span><br><span class="line">    <span class="comment">// protDer.publicMember = 10; // 错误：publicMember 在 ProtectedDerived 中为 protected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PrivateDerived privDer;</span></span><br><span class="line">    <span class="comment">// privDer.publicMember = 10; // 错误：publicMember 在 PrivateDerived 中为 private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-继承中类的作用域（Scope-of-Classes-in-Inheritance）"><a href="#5-继承中类的作用域（Scope-of-Classes-in-Inheritance）" class="headerlink" title="5. 继承中类的作用域（Scope of Classes in Inheritance）"></a>5. 继承中类的作用域（Scope of Classes in Inheritance）</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>在继承关系中，类的作用域决定了成员名称的可见性和访问方式。派生类可以访问基类的成员，根据访问控制的不同，还可能需要使用 <strong>作用域解析符</strong> 来访问隐藏的成员。</p>
<h3 id="5-2-代码示例"><a href="#5-2-代码示例" class="headerlink" title="5.2 代码示例"></a>5.2 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display from Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Show from Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 隐藏基类的 display</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display from Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callBaseDisplay</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">display</span>(); <span class="comment">// 使用作用域解析符调用基类的 display</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 重写 show， show 是虚函数可实现多态</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Show from Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>();          <span class="comment">// 调用 Derived::display</span></span><br><span class="line">    d.<span class="built_in">callBaseDisplay</span>();  <span class="comment">// 调用 Base::display</span></span><br><span class="line">    d.<span class="built_in">show</span>();             <span class="comment">// 调用 Derived::show</span></span><br><span class="line"></span><br><span class="line">    Base* bPtr = &amp;d;</span><br><span class="line">    bPtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Base::display，因为 display 不是虚函数</span></span><br><span class="line">    bPtr-&gt;<span class="built_in">show</span>();    <span class="comment">// show 是虚函数，调用 Derived::show；否则调用 Base::show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-执行结果"><a href="#5-3-执行结果" class="headerlink" title="5.3 执行结果"></a>5.3 执行结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Display <span class="keyword">from</span> Derived</span><br><span class="line">Display <span class="keyword">from</span> Base</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">from</span> Derived</span><br><span class="line">Display <span class="keyword">from</span> Base</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">from</span> Base <span class="operator">/</span><span class="operator">/</span> <span class="keyword">show</span> 是虚函数则输出: <span class="keyword">Show</span> <span class="keyword">from</span> Derived</span><br></pre></td></tr></table></figure>



<h2 id="6-构造函数与拷贝控制（Constructors-and-Copy-Control-in-Inheritance）"><a href="#6-构造函数与拷贝控制（Constructors-and-Copy-Control-in-Inheritance）" class="headerlink" title="6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）"></a>6. 构造函数与拷贝控制（Constructors and Copy Control in Inheritance）</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>在继承体系中，类的构造函数和拷贝控制函数（拷贝构造函数、拷贝赋值运算符、析构函数）的调用顺序和行为需要注意。基类的构造函数在派生类之前调用，析构函数则在派生类之后调用。</p>
<h3 id="6-2-构造函数的调用顺序"><a href="#6-2-构造函数的调用顺序" class="headerlink" title="6.2 构造函数的调用顺序"></a>6.2 构造函数的调用顺序</h3><ol>
<li>基类的 <strong>默认构造函数</strong> 首先被调用，除非派生类在初始化列表中显式调用其他基类构造函数。</li>
<li>派生类的成员按照声明顺序被构造。</li>
<li>派生类的构造函数体被执行。</li>
</ol>
<h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base parameterized constructor: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other) : <span class="built_in">name_</span>(other.name_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base copy assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            name_ = other.name_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base</span>(<span class="string">&quot;Default Derived&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value) : <span class="built_in">Base</span>(name), <span class="built_in">value_</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived parameterized constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; other) : <span class="built_in">Base</span>(other), <span class="built_in">value_</span>(other.value_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived copy assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            Base::<span class="keyword">operator</span>=(other);</span><br><span class="line">            value_ = other.value_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating d1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived d1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="string">&quot;Custom Derived&quot;</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCopy constructing d3 from d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived d3 = d2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning d1 = d2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    d1 = d2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nExiting main...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-执行结果"><a href="#6-4-执行结果" class="headerlink" title="6.4 执行结果"></a>6.4 执行结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Creating d1:</span><br><span class="line">Base parameterized constructor: <span class="keyword">Default</span> Derived</span><br><span class="line">Derived <span class="keyword">default</span> constructor</span><br><span class="line"></span><br><span class="line">Creating d2:</span><br><span class="line">Base parameterized constructor: Custom Derived</span><br><span class="line">Derived parameterized constructor: <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Copy</span> constructing d3 <span class="keyword">from</span> d2:</span><br><span class="line">Base <span class="keyword">copy</span> constructor</span><br><span class="line">Derived <span class="keyword">copy</span> constructor</span><br><span class="line"></span><br><span class="line">Assigning d1 <span class="operator">=</span> d2:</span><br><span class="line">Derived <span class="keyword">copy</span> assignment</span><br><span class="line">Base <span class="keyword">copy</span> assignment</span><br><span class="line"></span><br><span class="line">Exiting main...</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure>



<h2 id="7-容器与继承（Containers-and-Inheritance）"><a href="#7-容器与继承（Containers-and-Inheritance）" class="headerlink" title="7. 容器与继承（Containers and Inheritance）"></a>7. 容器与继承（Containers and Inheritance）</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p><strong>C++ 容器（如 <code>std::vector</code>、<code>std::list</code> 等）</strong> 通常存储对象的副本，而非指向对象的指针。因此，当与继承结合使用时，可能导致 <strong>切片（Object Slicing）</strong> 问题，即仅存储基类部分，丢失派生类特有的信息。为了实现多态性，推荐使用指针或智能指针存储对象。</p>
<h3 id="7-2-切片问题示例"><a href="#7-2-切片问题示例" class="headerlink" title="7.2 切片问题示例"></a>7.2 切片问题示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Base&gt; vec;</span><br><span class="line">    Derived d;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(d); <span class="comment">// 切片发生，派生类特有部分被丢弃</span></span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>].<span class="built_in">show</span>(); <span class="comment">// 输出: Base show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-使用指针避免切片"><a href="#7-3-使用指针避免切片" class="headerlink" title="7.3 使用指针避免切片"></a>7.3 使用指针避免切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived&gt;());</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>]-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived show</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-5-智能指针选择"><a href="#7-5-智能指针选择" class="headerlink" title="7.5 智能指针选择"></a>7.5 智能指针选择</h3><ul>
<li>**<code>std::unique_ptr</code>**：<ul>
<li>独占所有权，不可复制，只能移动。</li>
<li>适用于明确的单一所有权场景。</li>
</ul>
</li>
<li>**<code>std::shared_ptr</code>**：<ul>
<li>共享所有权，可以被多个指针共享和引用计数。</li>
<li>适用于需要多个所有者的场景。</li>
</ul>
</li>
</ul>
<h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="1-简单继承与成员访问"><a href="#1-简单继承与成员访问" class="headerlink" title="1. 简单继承与成员访问"></a>1. 简单继承与成员访问</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Person</code>，包含以下成员：</p>
<ul>
<li><p><strong>私有成员变量</strong>：<code>name</code>（字符串类型），<code>age</code>（整数类型）</p>
</li>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：接受姓名和年龄作为参数并初始化成员变量</li>
<li><code>displayInfo()</code>：打印姓名和年龄</li>
</ul>
</li>
</ul>
<p>然后，定义一个派生类 <code>Student</code>，继承自 <code>Person</code>，并添加以下内容：</p>
<ul>
<li><p><strong>私有成员变量</strong>：<code>studentID</code>（字符串类型）</p>
</li>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：接受姓名、年龄和学号作为参数，并调用基类构造函数初始化姓名和年龄</li>
<li>重写 <code>displayInfo()</code>：除了显示姓名和年龄外，还显示学号</li>
</ul>
</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建一个 <code>Student</code> 对象，并调用 <code>displayInfo()</code> 函数展示信息。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Alice</span></span><br><span class="line"><span class="attr">Age:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">Student ID:</span> <span class="string">S12345</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="2-虚函数重写与多态性"><a href="#2-虚函数重写与多态性" class="headerlink" title="2. 虚函数重写与多态性"></a>2. 虚函数重写与多态性</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Shape</code>，包含以下内容：</p>
<ul>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>虚函数 <code>draw()</code>：在基类中实现，输出 “Drawing a generic shape.”</li>
</ul>
</li>
</ul>
<p>然后，定义两个派生类 <code>Circle</code> 和 <code>Rectangle</code>，分别重写 <code>draw()</code> 函数，实现各自的输出：</p>
<ul>
<li><code>Circle</code> 的 <code>draw()</code> 输出：”Drawing a circle.”</li>
<li><code>Rectangle</code> 的 <code>draw()</code> 输出：”Drawing a rectangle.”</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建一个 <code>Shape</code> 类型的指针数组，包含不同类型的 <code>Shape</code> 对象（<code>Circle</code> 和 <code>Rectangle</code>）。</li>
<li>遍历数组，调用每个对象的 <code>draw()</code> 函数，验证多态性的实现。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing <span class="selector-tag">a</span> circle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> rectangle.</span><br><span class="line">Drawing <span class="selector-tag">a</span> generic shape.</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3-函数重载与隐藏"><a href="#3-函数重载与隐藏" class="headerlink" title="3. 函数重载与隐藏"></a>3. 函数重载与隐藏</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Calculator</code>，包含以下公共成员函数：</p>
<ul>
<li><code>int add(int a, int b)</code>：返回两个整数的和</li>
<li><code>double add(double a, double b)</code>：返回两个浮点数的和</li>
</ul>
<p>然后，定义一个派生类 <code>AdvancedCalculator</code>，继承自 <code>Calculator</code>，并添加以下成员函数：</p>
<ul>
<li><code>int add(int a, int b, int c)</code>：返回三个整数的和</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure>

<p>函数中，创建一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdvancedCalculator</span><br></pre></td></tr></table></figure>

<p>对象，分别调用以下函数，并观察输出：</p>
<ul>
<li><code>add(2, 3)</code></li>
<li><code>add(2.5, 3.5)</code></li>
<li><code>add(1, 2, 3)</code></li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>观察派生类中新增的 <code>add</code> 函数是否影响基类中的同名函数。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-抽象类与纯虚函数"><a href="#4-抽象类与纯虚函数" class="headerlink" title="4. 抽象类与纯虚函数"></a>4. 抽象类与纯虚函数</h3><p><strong>题目：</strong></p>
<p>定义一个抽象基类 <code>Animal</code>，包含以下内容：</p>
<ul>
<li><p>公共纯虚函数</p>
<p>：</p>
<ul>
<li><code>void makeSound() const</code>：纯虚函数，用于发出动物的叫声</li>
</ul>
</li>
</ul>
<p>然后，定义两个派生类 <code>Dog</code> 和 <code>Cat</code>，分别实现 <code>makeSound()</code> 函数：</p>
<ul>
<li><code>Dog</code> 的 <code>makeSound()</code> 输出：”Woof!”</li>
<li><code>Cat</code> 的 <code>makeSound()</code> 输出：”Meow!”</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建 <code>Dog</code> 和 <code>Cat</code> 对象的基类指针，并调用 <code>makeSound()</code> 函数，展示多态性。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Woof!</span><br><span class="line">Meow!</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-构造函数与析构函数的继承"><a href="#5-构造函数与析构函数的继承" class="headerlink" title="5. 构造函数与析构函数的继承"></a>5. 构造函数与析构函数的继承</h3><p><strong>题目：</strong></p>
<p>定义一个基类 <code>Vehicle</code>，包含以下内容：</p>
<ul>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：输出 “Vehicle constructed.”</li>
<li>析构函数：输出 “Vehicle destructed.”</li>
</ul>
</li>
</ul>
<p>然后，定义一个派生类 <code>Car</code>，继承自 <code>Vehicle</code>，并添加以下内容：</p>
<ul>
<li><p>公共成员函数</p>
<p>：</p>
<ul>
<li>构造函数：输出 “Car constructed.”</li>
<li>析构函数：输出 “Car destructed.”</li>
</ul>
</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，创建一个 <code>Car</code> 对象，并观察构造和析构的调用顺序。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vehicle constructed.</span><br><span class="line">Car constructed.</span><br><span class="line">Car destructed.</span><br><span class="line">Vehicle destructed.</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/09/cppbase19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/09/cppbase19/" itemprop="url">零基础C++(19) 类基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-09T20:58:32+08:00">
                2024-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-类与对象简介"><a href="#1-类与对象简介" class="headerlink" title="1. 类与对象简介"></a>1. 类与对象简介</h2><h3 id="1-1-什么是类和对象"><a href="#1-1-什么是类和对象" class="headerlink" title="1.1 什么是类和对象"></a>1.1 什么是类和对象</h3><ul>
<li><strong>类（Class）</strong>是C++中创建用户自定义类型的一种方式，它将数据（成员变量）和操作数据的函数（成员函数）封装在一起。</li>
<li><strong>对象（Object）</strong>是类的实例化，拥有类定义的所有属性和行为。</li>
<li><strong>类</strong>更像是汽车图纸，<strong>对象</strong>更像是造出来的汽车。</li>
</ul>
<h3 id="1-2-类的作用"><a href="#1-2-类的作用" class="headerlink" title="1.2 类的作用"></a>1.2 类的作用</h3><ul>
<li><strong>封装（Encapsulation）</strong>：将数据和操作数据的代码绑定在一起，保护数据不被外界直接访问。</li>
<li><strong>抽象（Abstraction）</strong>：通过类定义抽象出具有共同特性的对象，提高代码的可重用性和可维护性。</li>
<li><strong>继承（Inheritance）和多态（Polymorphism）</strong>：实现代码的复用与动态绑定。</li>
</ul>
<hr>
<h2 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 受保护成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>创建一个表示学生的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-成员变量与成员函数"><a href="#3-成员变量与成员函数" class="headerlink" title="3. 成员变量与成员函数"></a>3. 成员变量与成员函数</h2><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><ul>
<li><strong>成员变量（Member Variables）</strong>：用于存储对象的状态信息。</li>
<li><strong>命名约定</strong>：常用下划线结尾（例如 <code>name_</code>）表示成员变量，避免与局部变量混淆。</li>
</ul>
<h3 id="3-2-成员函数"><a href="#3-2-成员函数" class="headerlink" title="3.2 成员函数"></a>3.2 成员函数</h3><ul>
<li><strong>成员函数（Member Functions）</strong>：定义对象的行为，可以访问和修改成员变量。</li>
<li><strong>常成员函数（Const Member Functions）</strong>：保证函数不会修改对象的状态。</li>
</ul>
<h3 id="3-3-示例实现"><a href="#3-3-示例实现" class="headerlink" title="3.3 示例实现"></a>3.3 示例实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age)</span><br><span class="line">    : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    name_ = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">0</span>)</span><br><span class="line">        age_ = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4. 访问控制"></a>4. 访问控制</h2><h3 id="4-1-访问修饰符"><a href="#4-1-访问修饰符" class="headerlink" title="4.1 访问修饰符"></a>4.1 访问修饰符</h3><ul>
<li><strong>public</strong>：公有成员，可以被所有代码访问。</li>
<li><strong>private</strong>：私有成员，仅能被类的成员函数和友元访问。</li>
<li><strong>protected</strong>：受保护成员，仅能被类的成员函数、友元和派生类访问。</li>
</ul>
<h3 id="4-2-例子"><a href="#4-2-例子" class="headerlink" title="4.2 例子"></a>4.2 例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="5-构造函数与析构函数"><a href="#5-构造函数与析构函数" class="headerlink" title="5. 构造函数与析构函数"></a>5. 构造函数与析构函数</h2><h3 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h3><ul>
<li><strong>默认构造函数</strong>：没有参数的构造函数。</li>
<li><strong>参数化构造函数</strong>：接受参数以初始化对象。</li>
<li><strong>拷贝构造函数</strong>：用一个对象初始化另一个对象。</li>
<li><strong>移动构造函数（C++11）</strong>：从临时对象“移动”资源。</li>
</ul>
<h3 id="5-2-析构函数"><a href="#5-2-析构函数" class="headerlink" title="5.2 析构函数"></a>5.2 析构函数</h3><ul>
<li><strong>析构函数（Destructor）</strong>：在对象生命周期结束时调用，用于释放资源。</li>
</ul>
<h3 id="5-3-示例"><a href="#5-3-示例" class="headerlink" title="5.3 示例"></a>5.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>() : <span class="built_in">data_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> data) : <span class="built_in">data_</span>(data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called with data = &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other) : <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(Example&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.data_ = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for data = &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-4-使用示例"><a href="#5-4-使用示例" class="headerlink" title="5.4 使用示例"></a>5.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example ex1;               <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">Example <span class="title">ex2</span><span class="params">(<span class="number">42</span>)</span></span>;           <span class="comment">// 调用参数化构造函数</span></span><br><span class="line">    Example ex3 = ex2;         <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example ex4 = std::<span class="built_in">move</span>(ex2); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Default <span class="keyword">constructor</span> called.</span><br><span class="line">Parameterized <span class="keyword">constructor</span> called with <span class="keyword">data</span> = <span class="number">42.</span></span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">0.</span></span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">42.</span></span><br><span class="line">Destructor called <span class="keyword">for</span> <span class="keyword">data</span> = <span class="number">42.</span></span><br></pre></td></tr></table></figure>



<h3 id="5-5-拷贝构造是否必须实现"><a href="#5-5-拷贝构造是否必须实现" class="headerlink" title="5.5 拷贝构造是否必须实现"></a>5.5 拷贝构造是否必须实现</h3><p>当一个类A中有成员变量是另一个类类型B的时候，有时候拷贝构造会失效。比如一个类A中有成员变量<code>std::thread</code>，<code>std::thread</code>没有构造函数，所以A类的拷贝构造无法合成，需要显示编写。</p>
<p>同样析构也要显示编写，等待线程完成。</p>
<p>除此之外我们可以自己实现拷贝构造，进而实现浅拷贝和深拷贝的不同效果</p>
<p><img src="https://cdn.llfc.club/1731294878994.jpg" alt="https://cdn.llfc.club/1731294878994.jpg"></p>
<p><img src="https://cdn.llfc.club/1731295328032.jpg-llfc" alt="https://cdn.llfc.club/1731295328032.jpg-llfc"></p>
<h3 id="5-6-构造顺序和析构顺序"><a href="#5-6-构造顺序和析构顺序" class="headerlink" title="5.6 构造顺序和析构顺序"></a>5.6 构造顺序和析构顺序</h3><p>类A中包含成员变量是类B的类型，如果是先调用A的构造还是B的构造呢？</p>
<p>如果析构的时候是A先析构还是B先析构呢？</p>
<h3 id="5-7-类默认构造是否必须实现"><a href="#5-7-类默认构造是否必须实现" class="headerlink" title="5.7 类默认构造是否必须实现"></a>5.7 类默认构造是否必须实现</h3><p>如果类中有继承关系或者其他类型的成员，默认构造函数是很有必要实现的。</p>
<p>系统提供的合成的默认构造函数不会对成员做初始化操作。</p>
<h3 id="5-8-this-指针的特性和用途"><a href="#5-8-this-指针的特性和用途" class="headerlink" title="5.8 this 指针的特性和用途"></a>5.8 <code>this</code> 指针的特性和用途</h3><ol>
<li><p><strong>指向当前对象</strong>：</p>
<ul>
<li><code>this</code> 指针是一个隐式参数，指向调用成员函数的对象。通过 <code>this</code>，你可以访问当前对象的属性和方法。</li>
</ul>
</li>
<li><p><strong>区分成员变量和参数</strong>：</p>
<ul>
<li><p>在构造函数或成员函数中，参数名和成员变量可能同名。使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure>

<p>可以明确指代成员变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>返回当前对象</strong>：</p>
<ul>
<li>```<br>this<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以用于返回当前对象的引用，以支持链式调用。例如：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    MyClass&amp; setValue(int value) &#123;</span><br><span class="line">        this-&gt;value = value;</span><br><span class="line">        return *this; // 返回当前对象的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.setValue(10).setValue(20); // 链式调用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>在 const 成员函数中的使用</strong>：</p>
<ul>
<li>在 <code>const</code> 成员函数中，<code>this</code> 的类型为 <code>const MyClass*</code>，这意味着你不能通过 <code>this</code> 修改成员变量。这有助于确保对象的状态不被改变。</li>
</ul>
</li>
<li><p><strong>在静态成员函数中的不可用性</strong>：</p>
<ul>
<li>静态成员函数没有 <code>this</code> 指针，因为它们不属于任何特定对象，而是属于类本身。因此，静态成员函数不能访问非静态成员变量和成员函数。</li>
</ul>
</li>
</ol>
<p><strong>示例代码</strong></p>
<p>以下是一个简单的示例，展示了 <code>this</code> 指针的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针区分成员变量和参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value; <span class="comment">// 使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl; <span class="comment">// 使用 this 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">printValue</span>(); <span class="comment">// 链式调用，输出: Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-9-delete和default"><a href="#5-9-delete和default" class="headerlink" title="5.9 delete和default"></a>5.9 delete和default</h3><p><code>C++11</code>用法：</p>
<p>delete可以删除指定的构造函数。</p>
<p>default可以指定某个构造函数为系统默认合成。</p>
<h2 id="6-拷贝控制"><a href="#6-拷贝控制" class="headerlink" title="6. 拷贝控制"></a>6. 拷贝控制</h2><p><strong>拷贝构造函数与拷贝赋值运算符</strong></p>
<h3 id="6-1-拷贝构造函数"><a href="#6-1-拷贝构造函数" class="headerlink" title="6.1 拷贝构造函数"></a>6.1 拷贝构造函数</h3><ul>
<li><strong>定义</strong>：用于创建一个新对象，并复制现有对象的成员。</li>
<li><strong>语法</strong>：<code>ClassName(const ClassName&amp; other);</code></li>
</ul>
<h3 id="6-2-拷贝赋值运算符"><a href="#6-2-拷贝赋值运算符" class="headerlink" title="6.2 拷贝赋值运算符"></a>6.2 拷贝赋值运算符</h3><ul>
<li><strong>定义</strong>：用于将一个已有对象的值赋给另一个已有对象。</li>
<li><strong>语法</strong>：<code>ClassName&amp; operator=(const ClassName&amp; other);</code></li>
</ul>
<h3 id="6-3-示例"><a href="#6-3-示例" class="headerlink" title="6.3 示例"></a>6.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            size_ = std::<span class="built_in">strlen</span>(str);</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">            std::<span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size_ = <span class="number">0</span>;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) : <span class="built_in">size_</span>(other.size_) &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自赋值检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_; <span class="comment">// 释放现有资源</span></span><br><span class="line"></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    std::<span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-使用示例"><a href="#6-4-使用示例" class="headerlink" title="6.4 使用示例"></a>6.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = s1;        <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    MyString s3;</span><br><span class="line">    s3 = s1;                  <span class="comment">// 调用拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s3.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constructor called.</span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Constructor called.</span><br><span class="line">Copy assignment <span class="keyword">operator</span> called.</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure>



<h2 id="7-移动语义"><a href="#7-移动语义" class="headerlink" title="7. 移动语义"></a>7. 移动语义</h2><h3 id="7-1-什么是移动语义"><a href="#7-1-什么是移动语义" class="headerlink" title="7.1 什么是移动语义"></a>7.1 什么是移动语义</h3><ul>
<li><strong>移动语义（Move Semantics）</strong>：允许资源的所有权从一个对象转移到另一个对象，避免不必要的拷贝，提高性能。</li>
</ul>
<h3 id="7-2-移动构造函数与移动赋值运算符"><a href="#7-2-移动构造函数与移动赋值运算符" class="headerlink" title="7.2 移动构造函数与移动赋值运算符"></a>7.2 移动构造函数与移动赋值运算符</h3><ul>
<li><strong>移动构造函数</strong>：<code>ClassName(ClassName&amp;&amp; other) noexcept;</code></li>
<li><strong>移动赋值运算符</strong>：<code>ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept;</code></li>
</ul>
<h3 id="7-3-示例"><a href="#7-3-示例" class="headerlink" title="7.3 示例"></a>7.3 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(<span class="type">const</span> MoveExample&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MoveExample</span>(MoveExample&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MoveExample&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MoveExample&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MoveExample&amp; <span class="keyword">operator</span>=(MoveExample&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move assignment operator called.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MoveExample</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-使用示例"><a href="#7-4-使用示例" class="headerlink" title="7.4 使用示例"></a>7.4 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MoveExample <span class="title">ex1</span><span class="params">(<span class="number">100</span>)</span></span>;                 <span class="comment">// Constructor</span></span><br><span class="line">    MoveExample ex2 = ex1;                <span class="comment">// Copy Constructor</span></span><br><span class="line">    MoveExample ex3 = <span class="built_in">MoveExample</span>(<span class="number">200</span>);   <span class="comment">// Move Constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MoveExample <span class="title">ex4</span><span class="params">(<span class="number">300</span>)</span></span>;</span><br><span class="line">    ex4 = ex1;                             <span class="comment">// Copy Assignment</span></span><br><span class="line">    ex4 = <span class="built_in">MoveExample</span>(<span class="number">400</span>);                <span class="comment">// Move Assignment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Constructor called.</span><br><span class="line">Copy <span class="keyword">constructor</span> called.</span><br><span class="line">Constructor called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Destructor called.</span><br><span class="line">Constructor called.</span><br><span class="line">Copy assignment <span class="keyword">operator</span> called.</span><br><span class="line">Move <span class="keyword">constructor</span> called.</span><br><span class="line">Move assignment <span class="keyword">operator</span> called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="8-类的友元"><a href="#8-类的友元" class="headerlink" title="8. 类的友元"></a>8. 类的友元</h2><h3 id="8-1-什么是友元"><a href="#8-1-什么是友元" class="headerlink" title="8.1 什么是友元"></a>8.1 什么是友元</h3><ul>
<li><strong>友元（Friend）</strong>：可以访问类的私有和保护成员的非成员函数或另一个类。</li>
</ul>
<h3 id="8-2-类型"><a href="#8-2-类型" class="headerlink" title="8.2 类型"></a>8.2 类型</h3><ul>
<li><strong>友元函数</strong>：单个函数可以被声明为友元。</li>
<li><strong>友元类</strong>：整个类可以被声明为友元。</li>
</ul>
<h3 id="8-3-使用示例"><a href="#8-3-使用示例" class="headerlink" title="8.3 使用示例"></a>8.3 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> length, <span class="type">double</span> width, <span class="type">double</span> height)</span><br><span class="line">        : <span class="built_in">length_</span>(length), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span> <span class="title">calculateVolume</span><span class="params">(<span class="type">const</span> Box&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length_;</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">(<span class="type">const</span> Box&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.length_ * b.width_ * b.height_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-4-使用友元类"><a href="#8-4-使用友元类" class="headerlink" title="8.4 使用友元类"></a>8.4 使用友元类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height) : <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width_;</span><br><span class="line">    <span class="type">double</span> height_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AreaCalculator</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">const</span> Rectangle&amp; rect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rect.width_ * rect.height_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="9-运算符重载"><a href="#9-运算符重载" class="headerlink" title="9. 运算符重载"></a>9. 运算符重载</h2><h3 id="9-1-什么是运算符重载"><a href="#9-1-什么是运算符重载" class="headerlink" title="9.1 什么是运算符重载"></a>9.1 什么是运算符重载</h3><ul>
<li><strong>运算符重载（Operator Overloading）</strong>：允许对自定义类型使用C++运算符，如 <code>+</code>, <code>-</code>, <code>&lt;&lt;</code> 等。</li>
</ul>
<h3 id="9-2-重载运算符的规则"><a href="#9-2-重载运算符的规则" class="headerlink" title="9.2 重载运算符的规则"></a>9.2 重载运算符的规则</h3><ul>
<li>只能对已有运算符进行重载，不能创建新运算符。</li>
<li>至少有一个操作数必须是用户定义的类型。</li>
<li>不能改变运算符的优先级或结合性。</li>
</ul>
<h3 id="9-3-示例：重载-运算符"><a href="#9-3-示例：重载-运算符" class="headerlink" title="9.3 示例：重载 + 运算符"></a>9.3 示例：重载 <code>+</code> 运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数重载 +</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x_ + other.x_, y_ + other.y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x_ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y_ &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用友元函数重载 +</span></span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x_ - b.x_, a.y_ - b.y_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1.5</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出： (4.5, 6.5)</span></span><br><span class="line"></span><br><span class="line">    Point p4 = p2 - p1;</span><br><span class="line">    p4.<span class="built_in">print</span>(); <span class="comment">// 输出： (1.5, 1.5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-4-示例：重载-lt-lt-运算符（输出流）"><a href="#9-4-示例：重载-lt-lt-运算符（输出流）" class="headerlink" title="9.4 示例：重载 &lt;&lt; 运算符（输出流）"></a>9.4 示例：重载 <code>&lt;&lt;</code> 运算符（输出流）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; name, <span class="type">double</span> salary)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">salary_</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数以重载 &lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Employee&amp; emp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">double</span> salary_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的 &lt;&lt;</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Employee&amp; emp) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Employee Name: &quot;</span> &lt;&lt; emp.name_ &lt;&lt; <span class="string">&quot;, Salary: $&quot;</span> &lt;&lt; emp.salary_;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">emp</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">75000</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; emp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Employee Name:</span> <span class="string">John</span> <span class="string">Doe,</span> <span class="attr">Salary:</span> <span class="string">$75000</span></span><br></pre></td></tr></table></figure>



<h2 id="10-练习示例"><a href="#10-练习示例" class="headerlink" title="10. 练习示例"></a>10. 练习示例</h2><h3 id="项目：实现自定义MyString类"><a href="#项目：实现自定义MyString类" class="headerlink" title="项目：实现自定义MyString类"></a>项目：实现自定义<code>MyString</code>类</h3><p><strong>目标</strong>：创建一个简单的<code>MyString</code>类，支持拷贝构造，默认构造，有参构造，支持输出和比较等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;  <span class="comment">// 动态分配的字符数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]; <span class="comment">// +1 for the null terminator</span></span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.data) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data; <span class="comment">// 释放原有内存</span></span><br><span class="line">            <span class="keyword">if</span> (other.data) &#123;</span><br><span class="line">                data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较运算符重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span> &amp;&amp; other.data == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span> || other.data == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(data, other.data) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyString&amp; myStr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myStr.data) &#123;</span><br><span class="line">            os &lt;&lt; myStr.data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    MyString str2 = str1; <span class="comment">// 拷贝构造</span></span><br><span class="line">    MyString str3;</span><br><span class="line"></span><br><span class="line">    str3 = str1; <span class="comment">// 赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3: &quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><strong>私有成员</strong>：<ul>
<li><code>char* data</code>：指向动态分配的字符数组，用于存储字符串。</li>
</ul>
</li>
<li><strong>构造函数</strong>：<ul>
<li><strong>默认构造函数</strong>：初始化 <code>data</code> 为 <code>nullptr</code>。</li>
<li><strong>有参构造函数</strong>：接收一个 <code>const char*</code> 类型的字符串，动态分配内存并复制字符串内容。</li>
<li><strong>拷贝构造函数</strong>：复制另一个 <code>MyString</code> 对象的内容，确保深拷贝。</li>
</ul>
</li>
<li><strong>赋值运算符重载</strong>：支持将一个 <code>MyString</code> 对象赋值给另一个，确保释放原有内存并进行深拷贝。</li>
<li><strong>比较运算符重载</strong>：支持比较两个 <code>MyString</code> 对象是否相等。</li>
<li><strong>输出运算符重载</strong>：支持直接使用 <code>std::cout</code> 输出 <code>MyString</code> 对象。</li>
<li><strong>析构函数</strong>：释放动态分配的内存，防止内存泄漏。</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在 <code>main</code> 函数中，创建了几个 <code>MyString</code> 对象，演示了拷贝构造、赋值和比较的用法。</p>
<h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p>关于C++的视频教程可参考我的主页</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206">C++教程视频</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/11/03/cppbase18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/03/cppbase18/" itemprop="url">零基础C++(18) 函数用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-03T11:41:04+08:00">
                2024-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-函数简介"><a href="#1-函数简介" class="headerlink" title="1. 函数简介"></a>1. 函数简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数是执行特定任务的代码块，可以被程序中的多个地方调用。使用函数可以增加代码的可重用性、可读性和可维护性。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><strong>封装</strong>：将特定功能封装在函数中，便于管理和修改。</li>
<li><strong>复用</strong>：同一段功能代码可以在程序中多次调用，减少代码重复。</li>
<li><strong>结构化</strong>：通过函数组织代码，提高程序的结构清晰度。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 + 3 = 8</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-函数的声明与定义"><a href="#2-函数的声明与定义" class="headerlink" title="2. 函数的声明与定义"></a>2. 函数的声明与定义</h2><h3 id="函数声明（Function-Declaration）"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h3><p>告诉编译器函数的名称、返回类型和参数类型，但不包含函数体。通常放在头文件中或在使用函数前进行声明。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure>



<h3 id="函数定义（Function-Definition）"><a href="#函数定义（Function-Definition）" class="headerlink" title="函数定义（Function Definition）"></a>函数定义（Function Definition）</h3><p>提供函数的具体实现，包括函数体。函数定义可以在源文件中或与声明一起在头文件中出现（推荐仅声明在头文件中）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 函数定义</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数分离编译"><a href="#函数分离编译" class="headerlink" title="函数分离编译"></a>函数分离编译</h3><ul>
<li><strong>声明</strong>：放在头文件（如 <code>multiply.h</code>）。</li>
<li><strong>定义</strong>：放在源文件（如 <code>multiply.cpp</code>）。</li>
</ul>
<p><strong>multiply.h</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MULTIPLY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTIPLY_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><strong>multiply.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiply.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>main.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiply.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multiply</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4 * 6 = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编译命令</strong>（假设使用g++）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp multiply.cpp -o program</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 * 6 = 24</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-函数调用"><a href="#3-函数调用" class="headerlink" title="3. 函数调用"></a>3. 函数调用</h2><h3 id="基本调用"><a href="#基本调用" class="headerlink" title="基本调用"></a>基本调用</h3><p>通过函数名称和必要的参数来调用函数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>



<h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p>同一函数可以在程序中被调用多次。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-参数传递机制"><a href="#4-参数传递机制" class="headerlink" title="4. 参数传递机制"></a>4. 参数传递机制</h2><p>C++中函数参数的传递方式主要有以下三种：</p>
<ol>
<li><strong>传值调用（Pass by Value）</strong></li>
<li><strong>传引用调用（Pass by Reference）</strong></li>
<li><strong>传指针调用（Pass by Pointer）</strong></li>
</ol>
<h3 id="传值调用"><a href="#传值调用" class="headerlink" title="传值调用"></a>传值调用</h3><p><strong>定义</strong>：函数接收参数的副本，函数内对参数的修改不会影响原始数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 只修改副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 50</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>changeValue</code>函数修改的是<code>num</code>的副本，原始变量<code>value</code>保持不变。</p>
<h3 id="传引用调用"><a href="#传引用调用" class="headerlink" title="传引用调用"></a>传引用调用</h3><p><strong>定义</strong>：函数接收参数的引用，函数内对参数的修改会影响原始数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 修改原始数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 100</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>changeValue</code>函数通过引用修改了原始变量<code>value</code>的值。</p>
<h3 id="传指针调用"><a href="#传指针调用" class="headerlink" title="传指针调用"></a>传指针调用</h3><p><strong>定义</strong>：函数接收指向参数的指针，函数内通过指针可以修改原始数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>; <span class="comment">// 修改原始数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> *num)</span> </span>&#123;</span><br><span class="line">    *num = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function: &quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(&amp;value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside <span class="keyword">function</span>: 100</span><br><span class="line">Outside <span class="keyword">function</span>: 100</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>changeValue</code>函数通过指针修改了原始变量<code>value</code>的值。</p>
<h3 id="选择合适的传递方式"><a href="#选择合适的传递方式" class="headerlink" title="选择合适的传递方式"></a>选择合适的传递方式</h3><ul>
<li><strong>传值调用</strong>：适用于不需要修改原始数据且数据量较小的情况。</li>
<li><strong>传引用调用</strong>：适用于需要修改原始数据或传递大型数据结构以提高效率。</li>
<li><strong>传指针调用</strong>：类似传引用调用，但更灵活，可用于传递<code>nullptr</code>或指向动态分配的内存。</li>
</ul>
<hr>
<h2 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h2><p>函数可以通过<code>return</code>语句将结果返回给调用者。返回值的类型可以是基本数据类型、引用、指针、对象等。</p>
<h3 id="5-1-返回基本数据类型"><a href="#5-1-返回基本数据类型" class="headerlink" title="5.1 返回基本数据类型"></a>5.1 返回基本数据类型</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Sum: 7</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-返回引用"><a href="#5-2-返回引用" class="headerlink" title="5.2 返回引用"></a>5.2 返回引用</h3><p><strong>注意</strong>：返回引用需要确保引用的对象在返回后依然有效（避免悬垂引用）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;max = <span class="built_in">getMax</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max: &quot;</span> &lt;&lt; max &lt;&lt; std::endl;</span><br><span class="line">    max = <span class="number">30</span>; <span class="comment">// 修改引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modification, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Max:</span> <span class="number">20</span></span><br><span class="line"><span class="string">After</span> <span class="string">modification,</span> <span class="attr">y:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>getMax</code>函数返回较大的变量的引用，修改<code>max</code>实际上修改了<code>y</code>。</p>
<h3 id="5-3-返回指针"><a href="#5-3-返回指针" class="headerlink" title="5.3 返回指针"></a>5.3 返回指针</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">allocateArray</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        arr[i] = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>* myArray = <span class="built_in">allocateArray</span>(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        std::cout &lt;&lt; myArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] myArray; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 4 6 8 </span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>allocateArray</code>函数动态分配一个数组并返回指向数组的指针。调用者需负责释放内存。</p>
<h3 id="5-4-返回对象"><a href="#5-4-返回对象" class="headerlink" title="5.4 返回对象"></a>5.4 返回对象</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">createPerson</span><span class="params">(std::string name, <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(name, age)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="built_in">createPerson</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Alice,</span> <span class="attr">Age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>createPerson</code>函数返回一个<code>Person</code>对象。现代编译器通过返回值优化（RVO）减少对象拷贝，提高效率。</p>
<hr>
<h2 id="6-函数重载"><a href="#6-函数重载" class="headerlink" title="6. 函数重载"></a>6. 函数重载</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>函数重载允许在同一个作用域内定义多个名称相同但参数列表不同的函数。编译器通过参数列表的不同来区分调用哪个函数。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>函数名相同。</li>
<li>参数列表（类型、数量或顺序）不同。</li>
<li>返回类型不参与重载的区分。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：不同参数数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：不同参数类型</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2, 3) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2, 3, 4) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(2.5, 3.5) = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">5</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) = <span class="number">9</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) = <span class="number">6</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>仅返回类型不同的重载是非法的。</li>
<li>默认参数可能会与重载产生冲突，使用时需谨慎。</li>
</ul>
<p><strong>非法示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冲突重载，仅返回类型不同</span></span><br><span class="line"><span class="comment">// 会导致编译错误</span></span><br><span class="line"><span class="comment">// double add(int a, int b);</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="7-默认参数"><a href="#7-默认参数" class="headerlink" title="7. 默认参数"></a>7. 默认参数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>函数参数可以指定默认值，调用函数时可以省略这些参数，默认值将被使用。</p>
<h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><ul>
<li>默认参数从右到左设置，不能部分设置。</li>
<li>函数声明和定义中默认参数只需在声明中指定。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明时指定默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(std::string name, <span class="type">int</span> age = <span class="number">18</span>, std::string city = <span class="string">&quot;Unknown&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>, <span class="string">&quot;New York&quot;</span>); <span class="comment">// 全部参数传递</span></span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>);         <span class="comment">// 省略city</span></span><br><span class="line">    <span class="built_in">displayInfo</span>(<span class="string">&quot;Diana&quot;</span>);               <span class="comment">// 省略age和city</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(std::string name, <span class="type">int</span> age, std::string city)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, City: &quot;</span> &lt;&lt; city &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">Bob,</span> <span class="attr">Age:</span> <span class="number">25</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">New</span> <span class="string">York</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">Charlie,</span> <span class="attr">Age:</span> <span class="number">30</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">Unknown</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">Diana,</span> <span class="attr">Age:</span> <span class="number">18</span><span class="string">,</span> <span class="attr">City:</span> <span class="string">Unknown</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>默认参数必须从右端开始，不能跳过中间参数。</li>
<li>如果同时使用默认参数和重载，可能会产生歧义，需谨慎设计。</li>
</ul>
<hr>
<h2 id="8-内联函数"><a href="#8-内联函数" class="headerlink" title="8. 内联函数"></a>8. 内联函数</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>内联函数通过在函数前加<code>inline</code>关键字，建议编译器将函数代码嵌入到调用处，减少函数调用的开销。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于函数体积小、调用频繁的函数，如访问器（getter）和修改器（setter）等。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square of 5: &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Square of <span class="number">5</span>: <span class="number">25</span></span><br></pre></td></tr></table></figure>



<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少函数调用的开销（如栈操作）。</li>
<li>可能提高程序性能。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>使得代码体积增大，可能影响缓存性能。</li>
<li>编译器可能忽略内联请求，特别是对于复杂函数。</li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>编译器对<code>inline</code>关键字的处理是建议性质，最终是否内联由编译器决定。</li>
<li>过度使用内联函数可能导致代码膨胀。</li>
</ul>
<hr>
<h2 id="9-递归函数"><a href="#9-递归函数" class="headerlink" title="9. 递归函数"></a>9. 递归函数</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>递归函数是指在函数体内调用自身的函数。递归通常用于解决可以分解为相似子问题的问题，如阶乘、斐波那契数列、树的遍历等。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>递归函数通常包含两个部分：</p>
<ol>
<li><strong>基准情形（Base Case）</strong>：直接返回结果，避免无限递归。</li>
<li><strong>递归情形（Recursive Case）</strong>：将问题分解为更小的子问题并调用自身。</li>
</ol>
<h3 id="示例：计算阶乘"><a href="#示例：计算阶乘" class="headerlink" title="示例：计算阶乘"></a>示例：计算阶乘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误情况</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基准情形</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); <span class="comment">// 递归情形</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">factorial</span>(number);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid input!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br></pre></td></tr></table></figure>



<h3 id="示例：斐波那契数列"><a href="#示例：斐波那契数列" class="headerlink" title="示例：斐波那契数列"></a>示例：斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> term = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(term) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10) = 55</span><br></pre></td></tr></table></figure>



<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>基准情形</strong>：必须正确设置，避免无限递归导致栈溢出（Stack Overflow）。</li>
<li><strong>效率问题</strong>：一些递归实现可能效率低下（如斐波那契数列），可以通过“记忆化”或改用迭代方法优化。</li>
<li><strong>堆栈深度</strong>：递归深度过大可能导致栈溢出，需避免深度递归。</li>
</ul>
<h3 id="递归优化：尾递归"><a href="#递归优化：尾递归" class="headerlink" title="递归优化：尾递归"></a>递归优化：尾递归</h3><p>尾递归是指递归调用在函数的最后一步，可以被编译器优化为循环，减少堆栈消耗。</p>
<p><strong>示例：尾递归阶乘</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于尾递归</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorialHelper</span><span class="params">(<span class="type">int</span> n, <span class="type">long</span> <span class="type">long</span> accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorialHelper</span>(n - <span class="number">1</span>, n * accumulator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorialHelper</span>(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(number) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5! = 120</span><br></pre></td></tr></table></figure>



<p><strong>解释</strong>：<code>factorialHelper</code>函数的递归调用是函数的最后一步，编译器可以将其优化为迭代，减少堆栈消耗。</p>
<hr>
<h2 id="10-Lambda表达式"><a href="#10-Lambda表达式" class="headerlink" title="10. Lambda表达式"></a>10. Lambda表达式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>Lambda表达式是C++11引入的匿名函数，便于在需要函数对象的地方快速定义和使用函数。它允许定义内联的、小型的可调用对象，无需单独定义函数。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ capture_list ] ( parameter_list ) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式打印每个元素</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式计算总和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> x) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line"><span class="section">Sum: 15</span></span><br></pre></td></tr></table></figure>



<h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ol>
<li><strong>捕获列表（Capture List）</strong>：指定如何访问外部变量。<ul>
<li><code>[ ]</code>：不捕获任何外部变量。</li>
<li><code>[&amp;]</code>：按引用捕获所有外部变量。</li>
<li><code>[=]</code>：按值捕获所有外部变量。</li>
<li><code>[x, &amp;y]</code>：按值捕获<code>x</code>，按引用捕获<code>y</code>。</li>
</ul>
</li>
<li><strong>参数列表（Parameter List）</strong>：类似普通函数的参数列表，可以省略类型（C++14及以上支持自动类型推断）。</li>
<li><strong>返回类型（Return Type）</strong>：可指定返回类型，也可省略，编译器自动推断。</li>
<li><strong>函数体（Function Body）</strong>：Lambda的具体实现。</li>
</ol>
<h3 id="高级示例：捕获并排序"><a href="#高级示例：捕获并排序" class="headerlink" title="高级示例：捕获并排序"></a>高级示例：捕获并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按降序排序，使用Lambda表达式</span></span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted data: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data)</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorted <span class="keyword">data</span>: <span class="number">9</span> <span class="number">6</span> <span class="number">5</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>



<h3 id="使用Lambda表达式与标准库"><a href="#使用Lambda表达式与标准库" class="headerlink" title="使用Lambda表达式与标准库"></a>使用Lambda表达式与标准库</h3><p>C++标准库中的许多算法（如<code>std::for_each</code>、<code>std::sort</code>、<code>std::transform</code>等）常用Lambda表达式作为参数，以实现自定义的操作。</p>
<hr>
<h2 id="11-函数指针与回调函数"><a href="#11-函数指针与回调函数" class="headerlink" title="11. 函数指针与回调函数"></a>11. 函数指针与回调函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p><strong>定义</strong>：指向函数的指针变量，保存函数的地址，可以通过指针调用函数。</p>
<h3 id="声明与使用"><a href="#声明与使用" class="headerlink" title="声明与使用"></a>声明与使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from greet!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义函数指针</span></span><br><span class="line">    <span class="built_in">void</span> (*funcPtr)() = greet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用函数</span></span><br><span class="line">    <span class="built_in">funcPtr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello <span class="keyword">from</span> greet!</span><br></pre></td></tr></table></figure>



<h3 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h3><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数，接受函数指针作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">void</span> (*func)())</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 调用传入的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hi!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">execute</span>(sayHi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi!</span><br></pre></td></tr></table></figure>



<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>定义</strong>：通过函数指针传递的函数，通常用于在特定事件发生时执行自定义操作。</p>
<p><strong>示例</strong>：基于函数指针的回调</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接收回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">cb</span>(); <span class="comment">// 执行回调</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Callback executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">registerCallback</span>(myCallback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before callback</span><br><span class="line">Callback executed!</span><br><span class="line">After callback</span><br></pre></td></tr></table></figure>



<h3 id="与Lambda表达式结合"><a href="#与Lambda表达式结合" class="headerlink" title="与Lambda表达式结合"></a>与Lambda表达式结合</h3><p>函数指针也可以指向Lambda表达式，但仅限于不捕获外部变量的Lambda。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不捕获外部变量的Lambda</span></span><br><span class="line">    Callback cb = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda callback!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeCallback</span>(cb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda callback!</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：捕获外部变量的Lambda无法转换为普通函数指针。</p>
<hr>
<h2 id="12-总结与练习"><a href="#12-总结与练习" class="headerlink" title="12. 总结与练习"></a>12. 总结与练习</h2><h3 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h3><ul>
<li><strong>函数的基本概念</strong>：了解函数的作用、基本结构及使用方法。</li>
<li><strong>函数声明与定义</strong>：掌握在头文件和源文件中分离声明与定义的方法。</li>
<li><strong>参数传递机制</strong>：理解传值、传引用和传指针的区别及应用场景。</li>
<li><strong>返回值</strong>：学习不同类型的返回值及其使用方法。</li>
<li><strong>函数重载</strong>：掌握函数名相同但参数不同的重载机制。</li>
<li><strong>默认参数</strong>：学习设定和使用函数的默认参数。</li>
<li><strong>内联函数</strong>：了解内联函数的概念、优缺点及使用场景。</li>
<li><strong>递归函数</strong>：理解递归的基本原理、编写方法及优化技巧。</li>
<li><strong>Lambda表达式</strong>：掌握定义和使用Lambda表达式的方法，及其在标准库中的应用。</li>
<li><strong>函数指针与回调函数</strong>：了解函数指针的声明、使用以及如何实现回调机制。</li>
</ul>
<h2 id="13-课后练习"><a href="#13-课后练习" class="headerlink" title="13. 课后练习"></a>13. 课后练习</h2><h3 id="1-练习1"><a href="#1-练习1" class="headerlink" title="1. 练习1"></a>1. 练习1</h3><p> <strong>编写一个递归函数，计算斐波那契数列的第n项</strong></p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>斐波那契数列是由0和1开始，后续的每一项都是前两项的和。数列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</span><br></pre></td></tr></table></figure>



<p>编写一个递归函数 <code>fibonacci</code>，接受一个整数 <code>n</code>，返回斐波那契数列的第 <code>n</code> 项。假设 <code>fibonacci(0) = 0</code>，<code>fibonacci(1) = 1</code>。</p>
<h4 id="答案代码"><a href="#答案代码" class="headerlink" title="答案代码"></a><strong>答案代码</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数列的第n项</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Invalid input: n must be non-negative.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 基准情形1</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基准情形2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> term = <span class="number">10</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">fibonacci</span>(term);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10) = 55</span><br></pre></td></tr></table></figure>



<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul>
<li>函数 <code>fibonacci</code> 定义了两个基准情形：<code>n == 0</code> 返回0，<code>n == 1</code> 返回1。</li>
<li>对于 <code>n &gt; 1</code>，函数递归调用自身计算 <code>fibonacci(n - 1)</code> 和 <code>fibonacci(n - 2)</code>，并返回它们的和。</li>
<li>在 <code>main</code> 函数中，计算并输出斐波那契数列的第10项，其值为55。</li>
</ul>
<h3 id="2-练习2"><a href="#2-练习2" class="headerlink" title="2. 练习2"></a>2. 练习2</h3><p><strong>使用Lambda表达式和<code>std::sort</code>对一个字符串数组按长度排序</strong></p>
<h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>给定一个字符串数组，使用Lambda表达式和<code>std::sort</code>函数对数组中的字符串按照其长度进行排序。</p>
<h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a><strong>答案</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; fruits = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式按照字符串长度进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(fruits.<span class="built_in">begin</span>(), fruits.<span class="built_in">end</span>(), [](<span class="type">const</span> std::string &amp;a, <span class="type">const</span> std::string &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fruits sorted by length:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;fruit : fruits)</span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a><strong>输出</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruits sorted <span class="keyword">by</span> length:</span><br><span class="line">kiwi grape apple banana pineapple strawberry </span><br></pre></td></tr></table></figure>



<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul>
<li>定义了一个包含多个水果名称的字符串向量 <code>fruits</code>。</li>
<li>使用 <code>std::sort</code> 对 <code>fruits</code> 进行排序，第三个参数是一个Lambda表达式，用于指定排序的规则。</li>
<li>Lambda表达式接收两个字符串 <code>a</code> 和 <code>b</code>，比较它们的长度，以实现按长度升序排序。</li>
<li>排序完成后，输出排序后的水果名称，按长度从短到长排列。</li>
</ul>
<h3 id="3-练习3"><a href="#3-练习3" class="headerlink" title="3. 练习3"></a>3. 练习3</h3><p><strong>实现一个简易的事件系统，允许注册和触发回调函数</strong></p>
<h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h4><p>构建一个简单的事件系统，允许用户注册多个回调函数（函数指针或Lambda表达式），并在特定事件触发时调用这些回调函数。</p>
<h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a><strong>答案</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义带参数的回调函数类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件系统类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSystem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Callback&gt; callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(<span class="type">const</span> Callback &amp;cb)</span> </span>&#123;</span><br><span class="line">        callbacks.<span class="built_in">push_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，传递参数给回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event triggered with data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;. Executing callbacks...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cb : callbacks)</span><br><span class="line">            <span class="built_in">cb</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数作为回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function callback received data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventSystem eventSystem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册基于函数指针的回调</span></span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>(onEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册基于Lambda表达式的回调</span></span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda callback received: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册带捕获的Lambda表达式的回调</span></span><br><span class="line">    <span class="type">int</span> multiplier = <span class="number">5</span>;</span><br><span class="line">    eventSystem.<span class="built_in">registerCallback</span>([multiplier](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda with capture received: &quot;</span> &lt;&lt; x * multiplier &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，传递参数</span></span><br><span class="line">    eventSystem.<span class="built_in">triggerEvent</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Event</span> triggered <span class="keyword">with</span> data = <span class="number">10</span>. Executing callbacks...</span><br><span class="line"><span class="keyword">Function</span> callback received data: <span class="number">10</span></span><br><span class="line">Lambda callback received: <span class="number">20</span></span><br><span class="line">Lambda <span class="keyword">with</span> capture received: <span class="number">50</span></span><br></pre></td></tr></table></figure>



<h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a><strong>解释</strong></h4><ul>
<li>定义了一个带参数的回调函数类型 <code>std::function&lt;void(int)&gt;</code>，允许回调函数接受一个整数参数。</li>
<li><code>EventSystem</code> 类的方法 <code>triggerEvent</code> 接受一个整数 <code>data</code>，并将其作为参数传递给每个回调函数。</li>
<li>在 <code>main</code> 函数中，注册了三个带不同处理逻辑的回调函数，并在触发事件时传递参数 <code>10</code>。</li>
<li>回调函数根据传入的 <code>data</code> 执行相应的操作，展示了回调函数的灵活性。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/27/cppbase17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/27/cppbase17/" itemprop="url">零基础C++(17) 语句和作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-27T09:12:20+08:00">
                2024-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-简单语句"><a href="#1-简单语句" class="headerlink" title="1. 简单语句"></a>1. 简单语句</h2><h3 id="1-1-表达式语句"><a href="#1-1-表达式语句" class="headerlink" title="1.1 表达式语句"></a>1.1 表达式语句</h3><p><strong>描述</strong>：在 C++ 中，最常见的简单语句是表达式语句。它由一个表达式组成，并以分号结束。表达式语句可以包括函数调用、赋值操作、增减操作等。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;          <span class="comment">// 赋值表达式语句</span></span><br><span class="line">    a = a + <span class="number">10</span>;         <span class="comment">// 赋值表达式语句</span></span><br><span class="line">    std::cout &lt;&lt; a;     <span class="comment">// 函数调用表达式语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// return 表达式语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>int a = 5;</code> 初始化变量 <code>a</code>，这是一个赋值表达式语句。</li>
<li><code>a = a + 10;</code> 更新变量 <code>a</code> 的值。</li>
<li><code>std::cout &lt;&lt; a;</code> 调用了输出流对象的 <code>&lt;&lt;</code> 运算符函数。</li>
<li><code>return 0;</code> 从 <code>main</code> 函数返回，结束程序。</li>
</ul>
<h3 id="1-2-声明语句"><a href="#1-2-声明语句" class="headerlink" title="1.2 声明语句"></a>1.2 声明语句</h3><p><strong>描述</strong>：声明语句用于声明变量、函数、类等标识符。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>int add(int x, int y);</code> 是一个函数声明语句。</li>
<li><code>int result = add(3, 4);</code> 在 <code>main</code> 中调用函数并声明变量。</li>
<li><code>int add(int x, int y) &#123; ... &#125;</code> 是函数定义，提供了函数的实现。</li>
</ul>
<hr>
<h2 id="2-语句作用域"><a href="#2-语句作用域" class="headerlink" title="2. 语句作用域"></a>2. 语句作用域</h2><h3 id="2-1-作用域的基本概念"><a href="#2-1-作用域的基本概念" class="headerlink" title="2.1 作用域的基本概念"></a>2.1 作用域的基本概念</h3><p><strong>描述</strong>：作用域定义了变量或其他标识符在程序中的可见范围。C++ 中主要有以下几种作用域：</p>
<ul>
<li>**局部作用域 (Local Scope)**：在函数或代码块内部定义的变量，仅在其所在的块内可见。</li>
<li>**全局作用域 (Global Scope)**：在所有函数外部定义的变量，在整个文件中可见。</li>
<li>**命名空间作用域 (Namespace Scope)**：在命名空间内部定义的标识符。</li>
</ul>
<h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside display() - globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; <span class="string">&quot;, localVar: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main() - globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> mainVar = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main() - mainVar: &quot;</span> &lt;&lt; mainVar &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试访问 display() 中的局部变量（将导致编译错误）</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; localVar; // 错误：未定义标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">In</span> <span class="string">main()</span> <span class="bullet">-</span> <span class="attr">globalVar:</span> <span class="number">10</span></span><br><span class="line"><span class="string">In</span> <span class="string">main()</span> <span class="bullet">-</span> <span class="attr">mainVar:</span> <span class="number">20</span></span><br><span class="line"><span class="string">Inside</span> <span class="string">display()</span> <span class="bullet">-</span> <span class="attr">globalVar:</span> <span class="number">10</span><span class="string">,</span> <span class="attr">localVar:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>globalVar</code> 在所有函数中都可见。</li>
<li><code>mainVar</code> 仅在 <code>main</code> 函数内部可见。</li>
<li><code>localVar</code> 仅在 <code>display</code> 函数内部可见。</li>
<li>尝试在 <code>main</code> 中访问 <code>display</code> 函数的 <code>localVar</code> 将导致编译错误，因为它不在作用域内。</li>
</ul>
<h3 id="2-3-代码块作用域"><a href="#2-3-代码块作用域" class="headerlink" title="2.3 代码块作用域"></a>2.3 代码块作用域</h3><p><strong>描述</strong>：通过使用花括号 <code>&#123;&#125;</code>，可以创建新的代码块，从而定义局部作用域。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x before block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新的代码块</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">20</span>; <span class="comment">// 局部变量 x，隐藏外部的 x</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x inside block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after block: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 访问外部的 x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x before <span class="keyword">block</span>: <span class="number">10</span></span><br><span class="line">x inside <span class="keyword">block</span>: <span class="number">20</span></span><br><span class="line">x after <span class="keyword">block</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>在内部代码块中重新声明了变量 <code>x</code>，该 <code>x</code> 只在代码块内有效，隐藏了外部的 <code>x</code>。</li>
<li>离开代码块后，内部的 <code>x</code> 不再可见，外部的 <code>x</code> 依然有效。</li>
</ul>
<hr>
<h2 id="3-条件语句"><a href="#3-条件语句" class="headerlink" title="3. 条件语句"></a>3. 条件语句</h2><p>C++ 提供了多种条件语句，用于根据不同的条件执行不同的代码块。</p>
<h3 id="3-1-if-语句"><a href="#3-1-if-语句" class="headerlink" title="3.1 if 语句"></a>3.1 <code>if</code> 语句</h3><p><strong>描述</strong>：<code>if</code> 语句用于在条件为真时执行特定的代码块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The number is positive.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>用户输入一个数字，如果 <code>number</code> 大于 <code>0</code>，则输出 “The number is positive.”。</li>
</ul>
<h3 id="3-2-if-else-语句"><a href="#3-2-if-else-语句" class="headerlink" title="3.2 if-else 语句"></a>3.2 <code>if-else</code> 语句</h3><p><strong>描述</strong>：<code>if-else</code> 语句在条件为假时执行另一个代码块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code to execute if condition is false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is even.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is odd.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>判断输入的数字是奇数还是偶数，并输出相应的结果。</li>
</ul>
<h3 id="3-3-else-if-语句"><a href="#3-3-else-if-语句" class="headerlink" title="3.3 else if 语句"></a>3.3 <code>else if</code> 语句</h3><p><strong>描述</strong>：<code>else if</code> 允许在多重条件下执行不同的代码块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// code if condition1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// code if condition1 is false and condition2 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code if both condition1 and condition2 are false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter your score (0-100): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: C&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: D&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Grade: F&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>根据分数范围判断并输出相应的等级。</li>
</ul>
<h3 id="3-4-switch-语句"><a href="#3-4-switch-语句" class="headerlink" title="3.4 switch 语句"></a>3.4 <code>switch</code> 语句</h3><p><strong>描述</strong>：<code>switch</code> 语句根据变量的值选择执行的代码块，适用于离散的值。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> grade;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter your grade (A, B, C, D, F): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Excellent!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Good!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Fair!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Poor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Invalid grade.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>根据输入的字母等级输出相应的评价。</li>
<li><code>break</code> 语句防止代码“掉入”下一个 <code>case</code> 中。</li>
</ul>
<hr>
<h2 id="4-迭代语句"><a href="#4-迭代语句" class="headerlink" title="4. 迭代语句"></a>4. 迭代语句</h2><p>C++ 提供了多种循环结构，用于重复执行代码块。</p>
<h3 id="4-1-for-循环"><a href="#4-1-for-循环" class="headerlink" title="4.1 for 循环"></a>4.1 <code>for</code> 循环</h3><p><strong>描述</strong>：<code>for</code> 循环用于已知循环次数的情况，结构紧凑。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="selector-tag">from</span> <span class="number">1</span> <span class="selector-tag">to</span> <span class="number">5</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>初始化 <code>int i = 1</code>。</li>
<li>条件 <code>i &lt;= 5</code> 为真时执行循环体。</li>
<li>每次循环后执行 <code>++i</code>，增加 <code>i</code> 的值。</li>
<li>最终输出 1 到 5。</li>
</ul>
<h3 id="4-2-while-循环"><a href="#4-2-while-循环" class="headerlink" title="4.2 while 循环"></a>4.2 <code>while</code> 循环</h3><p><strong>描述</strong>：<code>while</code> 循环在循环前判断条件，适合未知循环次数的情况。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5 using while loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">while</span> <span class="keyword">loop</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>初始化 <code>count = 1</code>。</li>
<li>条件 <code>count &lt;= 5</code> 为真时执行循环体。</li>
<li>每次循环后 <code>++count</code> 增加 <code>count</code> 的值。</li>
</ul>
<h3 id="4-3-do-while-循环"><a href="#4-3-do-while-循环" class="headerlink" title="4.3 do-while 循环"></a>4.3 <code>do-while</code> 循环</h3><p><strong>描述</strong>：<code>do-while</code> 循环在循环后判断条件，保证至少执行一次循环体。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// code to execute</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counting from 1 to 5 using do-while loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt;= <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counting <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">do</span>-<span class="keyword">while</span> <span class="keyword">loop</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>无论条件是否为真，<code>do</code> 块中的代码至少执行一次。</li>
<li>在本例中，<code>count</code> 从 <code>1</code> 开始，逐步增加到 <code>5</code>。</li>
</ul>
<h3 id="4-4-嵌套循环"><a href="#4-4-嵌套循环" class="headerlink" title="4.4 嵌套循环"></a>4.4 嵌套循环</h3><p><strong>描述</strong>：一个循环内部嵌套另一个循环，常用于多维数据结构的遍历。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Outer loop iteration &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  Inner loop iteration &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br><span class="line"><span class="keyword">Outer</span> loop iteration <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">1</span></span><br><span class="line">  <span class="keyword">Inner</span> loop iteration <span class="number">2</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>外层 <code>for</code> 循环控制外层迭代次数。</li>
<li>内层 <code>for</code> 循环在每次外层循环中执行，控制内层迭代次数。</li>
</ul>
<hr>
<h2 id="5-跳转语句"><a href="#5-跳转语句" class="headerlink" title="5. 跳转语句"></a>5. 跳转语句</h2><p>跳转语句用于改变程序的执行流。C++ 中主要有 <code>break</code>、<code>continue</code>、<code>return</code> 和 <code>goto</code>。</p>
<h3 id="5-1-break-语句"><a href="#5-1-break-语句" class="headerlink" title="5.1 break 语句"></a>5.1 <code>break</code> 语句</h3><p><strong>描述</strong>：<code>break</code> 用于立即终止最近的循环或 <code>switch</code> 语句。</p>
<p><strong>示例代码（在循环中使用 <code>break</code>）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nLoop exited when i == 5.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="keyword">Loop</span> exited <span class="keyword">when</span> i == <span class="number">5</span>.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>当 <code>i</code> 达到 <code>5</code> 时，<code>break</code> 终止循环，停止进一步的迭代。</li>
</ul>
<h3 id="5-2-continue-语句"><a href="#5-2-continue-语句" class="headerlink" title="5.2 continue 语句"></a>5.2 <code>continue</code> 语句</h3><p><strong>描述</strong>：<code>continue</code> 用于跳过当前的循环迭代，继续下一次循环。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Even numbers between 1 and 10:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Even numbers <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span>:</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>当 <code>i</code> 是奇数时，<code>continue</code> 跳过本次循环，避免执行 <code>std::cout</code> 语句。</li>
<li>仅输出偶数。</li>
</ul>
<h3 id="5-3-return-语句"><a href="#5-3-return-语句" class="headerlink" title="5.3 return 语句"></a>5.3 <code>return</code> 语句</h3><p><strong>描述</strong>：<code>return</code> 用于从函数中返回一个值或结束函数执行。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，返回两个数中的较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// 返回 a，退出函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b; <span class="comment">// 返回 b，退出函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The maximum of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">max</span>(x, y) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The maximum of <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">is</span> <span class="number">20.</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>max</code> 函数根据条件返回较大的数，并退出函数执行。</li>
</ul>
<h3 id="5-4-goto-语句"><a href="#5-4-goto-语句" class="headerlink" title="5.4 goto 语句"></a>5.4 <code>goto</code> 语句</h3><p><strong>描述</strong>：<code>goto</code> 允许无条件跳转到程序中指定的标签。虽然 <code>goto</code> 有时能简化代码，但不推荐频繁使用，因为它会使程序流程难以理解和维护。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a positive number (negative to quit): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> end; <span class="comment">// 跳转到 end 标签，结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program ended.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（输入为负数）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="selector-tag">a</span> positive number (negative <span class="selector-tag">to</span> quit): -<span class="number">5</span></span><br><span class="line">Program ended.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>当输入负数时，<code>goto end;</code> 跳转到 <code>end</code> 标签，结束程序。</li>
<li>尽管可以使用 <code>goto</code>，但建议使用更结构化的控制流，如循环和条件语句。</li>
</ul>
<hr>
<h2 id="6-异常处理语句"><a href="#6-异常处理语句" class="headerlink" title="6. 异常处理语句"></a>6. 异常处理语句</h2><p>异常处理用于应对程序运行过程中可能出现的错误情况，确保程序的健壮性和可靠性。</p>
<h3 id="6-1-try-catch-和-throw-语句"><a href="#6-1-try-catch-和-throw-语句" class="headerlink" title="6.1 try, catch, 和 throw 语句"></a>6.1 <code>try</code>, <code>catch</code>, 和 <code>throw</code> 语句</h3><p><strong>描述</strong>：</p>
<ul>
<li><code>try</code> 块用于包含可能引发异常的代码。</li>
<li><code>throw</code> 用于抛出异常。</li>
<li><code>catch</code> 块用于捕获并处理异常。</li>
</ul>
<p><strong>基本语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// code that may throw an exception</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// handler for ExceptionType1</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// handler for ExceptionType2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，计算除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> numerator, <span class="type">double</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Denominator cannot be zero.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num, denom;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter numerator: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter denominator: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; denom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">divide</span>(num, denom);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::invalid_argument &amp;e) &#123; <span class="comment">// 捕获 std::invalid_argument 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues after try-catch.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Enter</span> <span class="attr">numerator</span>: <span class="number">10</span></span><br><span class="line"><span class="title class_">Enter</span> <span class="attr">denominator</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Denominator</span> cannot be zero.</span><br><span class="line"><span class="title class_">Program</span> continues after <span class="keyword">try</span>-<span class="keyword">catch</span>.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>divide</code> 函数在分母为零时抛出 <code>std::invalid_argument</code> 异常。</li>
<li><code>try</code> 块尝试执行 <code>divide</code> 函数。</li>
<li>当异常发生时，执行对应的 <code>catch</code> 块，输出错误信息。</li>
<li>程序在异常处理后继续执行，而不会异常终止。</li>
</ul>
<h3 id="6-2-多重-catch-块"><a href="#6-2-多重-catch-块" class="headerlink" title="6.2 多重 catch 块"></a>6.2 多重 <code>catch</code> 块</h3><p><strong>描述</strong>：可以为 <code>try</code> 块指定多个 <code>catch</code> 块，以处理不同类型的异常。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟不同类型的异常</span></span><br><span class="line">        <span class="type">int</span> choice;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Choose exception to throw (1: bad_alloc, 2: invalid_argument): &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid argument provided.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No exception thrown.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123; <span class="comment">// 处理 bad_alloc 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::invalid_argument &amp;e) &#123; <span class="comment">// 处理 invalid_argument 异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::invalid_argument: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues after try-catch.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（选择 <code>1</code>）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Choose exception to <span class="keyword">throw</span> (<span class="number">1</span>: bad_alloc, <span class="number">2</span>: invalid_argument): <span class="number">1</span></span><br><span class="line">Caught std::<span class="variable constant_">bad_alloc</span>: std::<span class="variable constant_">bad_alloc</span></span><br><span class="line">Program continues after <span class="keyword">try</span>-<span class="keyword">catch</span>.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li>根据用户输入抛出不同类型的异常。</li>
<li>对应的 <code>catch</code> 块分别处理不同的异常类型。</li>
<li>如果未匹配的异常被抛出且没有对应的 <code>catch</code> 块，将导致程序终止（未在此示例中展示）。</li>
</ul>
<h3 id="6-3-throw-通常位置"><a href="#6-3-throw-通常位置" class="headerlink" title="6.3 throw 通常位置"></a>6.3 <code>throw</code> 通常位置</h3><p><strong>描述</strong>：<code>throw</code> 语句可以在任何需要引发异常的位置使用，包括函数内部、嵌套调用中等。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，检查数组索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElement</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index is out of range.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter array index (0-4): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="built_in">getElement</span>(myArray, <span class="number">5</span>, index);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element at index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::out_of_range &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（输入为 <code>3</code>）：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter array <span class="keyword">index</span> (<span class="number">0</span>-<span class="number">4</span>): <span class="number">3</span></span><br><span class="line">Element at <span class="keyword">index</span> <span class="number">3</span> is <span class="number">40</span>.</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>（输入为 <code>5</code>）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Enter array <span class="title">index</span> (<span class="params"><span class="number">0</span><span class="number">-4</span></span>): 5</span></span><br><span class="line"><span class="function">Error: Index <span class="keyword">is</span> <span class="keyword">out</span> of range.</span></span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>getElement</code> 函数检查索引是否有效，如果无效则抛出 <code>std::out_of_range</code> 异常。</li>
<li><code>main</code> 函数中的 <code>try</code> 块调用 <code>getElement</code>，并在 <code>catch</code> 块中处理异常。</li>
</ul>
<h3 id="6-4-rethrow-异常"><a href="#6-4-rethrow-异常" class="headerlink" title="6.4 rethrow 异常"></a>6.4 <code>rethrow</code> 异常</h3><p><strong>描述</strong>：可以在 <code>catch</code> 块中使用 <code>throw</code> 语句重新抛出捕获的异常，以便其他部分处理。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error in func1.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，调用 func1 并重新抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func2() caught an exception and is rethrowing it.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123; <span class="comment">// 在 main 中捕获异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Main caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出</strong>：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func2</span>() caught an exception and is rethrowing it.</span><br><span class="line"><span class="selector-tag">Main</span> caught: Error in func1.</span><br></pre></td></tr></table></figure>



<p><strong>讲解</strong>：</p>
<ul>
<li><code>func1</code> 抛出异常。</li>
<li><code>func2</code> 调用 <code>func1</code>，捕获异常后重新抛出。</li>
<li><code>main</code> 最终捕获并处理异常。</li>
</ul>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h2 id="练习题-1：打印九九乘法表"><a href="#练习题-1：打印九九乘法表" class="headerlink" title="练习题 1：打印九九乘法表"></a>练习题 1：打印九九乘法表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，使用嵌套的 <code>for</code> 循环来打印标准的九九乘法表。输出的格式应整齐对齐，便于阅读。</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol>
<li>使用嵌套的 <code>for</code> 循环实现。</li>
<li>输出的乘法表应从 1×1 到 9×9。</li>
<li>每行输出一个数字的乘法结果，例如第 3 行包含 <code>3×1=3</code> 到 <code>3×9=27</code>。</li>
<li>确保输出格式整齐，便于阅读。</li>
</ol>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a><strong>示例输出</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1x1=1	1x2=2	1x3=3	1x4=4	1x5=5	1x6=6	1x7=7	1x8=8	1x9=9	</span><br><span class="line">2x1=2	2x2=4	2x3=6	2x4=8	2x5=10	2x6=12	2x7=14	2x8=16	2x9=18	</span><br><span class="line">3x1=3	3x2=6	3x3=9	3x4=12	3x5=15	3x6=18	3x7=21	3x8=24	3x9=27	</span><br><span class="line">4x1=4	4x2=8	4x3=12	4x4=16	4x5=20	4x6=24	4x7=28	4x8=32	4x9=36	</span><br><span class="line">5x1=5	5x2=10	5x3=15	5x4=20	5x5=25	5x6=30	5x7=35	5x8=40	5x9=45	</span><br><span class="line">6x1=6	6x2=12	6x3=18	6x4=24	6x5=30	6x6=36	6x7=42	6x8=48	6x9=54	</span><br><span class="line">7x1=7	7x2=14	7x3=21	7x4=28	7x5=35	7x6=42	7x7=49	7x8=56	7x9=63	</span><br><span class="line">8x1=8	8x2=16	8x3=24	8x4=32	8x5=40	8x6=48	8x7=56	8x8=64	8x9=72	</span><br><span class="line">9x1=9	9x2=18	9x3=27	9x4=36	9x5=45	9x6=54	9x7=63	9x8=72	9x9=81	</span><br></pre></td></tr></table></figure>



<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul>
<li>使用两个嵌套的 <code>for</code> 循环：外层循环控制行数（1 到 9），内层循环控制列数（1 到 9）。</li>
<li>使用 <code>\t</code> 或者适当的空格来对齐输出结果。</li>
<li>可以使用 <code>std::cout</code> 进行输出。</li>
</ul>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><strong>参考答案</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环控制行数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 内层循环控制列数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i * j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题-2：实现冒泡排序"><a href="#练习题-2：实现冒泡排序" class="headerlink" title="练习题 2：实现冒泡排序"></a>练习题 2：实现冒泡排序</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，使用 <strong>冒泡排序算法</strong> 对用户输入的一组整数进行排序。冒泡排序是一种简单的排序算法，通过重复交换相邻的未按顺序排列的元素，将最大或最小的元素“冒泡”到序列的一端。</p>
<h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol>
<li><strong>输入</strong>：用户输入一组整数，首先输入整数的数量 <code>n</code>，然后输入 <code>n</code> 个整数。</li>
<li><strong>排序</strong>：使用冒泡排序算法对输入的整数进行升序排序。</li>
<li><strong>输出</strong>：显示排序前和排序后的整数序列。</li>
<li><strong>函数封装</strong>：将冒泡排序算法封装在一个独立的函数中，提高代码的模块化和可读性。</li>
</ol>
<h3 id="示例输入与输出"><a href="#示例输入与输出" class="headerlink" title="示例输入与输出"></a><strong>示例输入与输出</strong></h3><p><strong>示例 1：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 5</span></span><br><span class="line">请输入 5 个整数，用空格分隔: 64 34 25 12 22</span><br><span class="line"><span class="section">排序前的数组: 64 34 25 12 22 </span></span><br><span class="line"><span class="section">排序后的数组: 12 22 25 34 64 </span></span><br></pre></td></tr></table></figure>



<p><strong>示例 2：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 8</span></span><br><span class="line">请输入 8 个整数，用空格分隔: 5 1 4 2 8 0 2 9</span><br><span class="line"><span class="section">排序前的数组: 5 1 4 2 8 0 2 9 </span></span><br><span class="line"><span class="section">排序后的数组: 0 1 2 2 4 5 8 9 </span></span><br></pre></td></tr></table></figure>



<h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul>
<li><strong>冒泡排序的基本思想</strong>：通过多次遍历数组，每次比较相邻的元素并交换顺序错误的元素。每一轮遍历后，最大的元素会被移动到数组的末端。</li>
<li><strong>优化</strong>：如果在某一轮遍历中没有发生任何交换，说明数组已经有序，可以提前终止排序过程。</li>
<li><strong>函数设计</strong>：可以设计一个 <code>bubbleSort</code> 函数接收数组及其大小作为参数，并对数组进行排序。</li>
</ul>
<h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><strong>参考答案</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="comment">// 外层循环控制总的遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个元素大于后一个元素，则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在一轮遍历中没有进行任何交换，数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数组大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入整数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数组大小必须为正整数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数组元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 个整数，用空格分隔: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序前的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序前的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行冒泡排序</span></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ol>
<li><p>**函数 <code>bubbleSort</code>**：</p>
<ul>
<li><p><strong>参数</strong>：接收一个整数数组 <code>arr</code> 和数组的大小 <code>n</code>。</p>
</li>
<li><p>逻辑</p>
<p>：</p>
<ul>
<li>使用两层 <code>for</code> 循环实现冒泡排序。</li>
<li>外层循环控制需要进行的遍历次数，总共需要 <code>n-1</code> 轮。</li>
<li>内层循环进行相邻元素的比较和交换，每一轮内层循环会将当前未排序部分的最大元素移动到数组的末端。</li>
<li>使用 <code>swapped</code> 标志位优化排序过程，如果一轮内层循环中没有发生任何交换，说明数组已经有序，提前终止排序。</li>
</ul>
</li>
<li><p><strong>交换操作</strong>：使用 <code>std::swap</code> 函数交换两个元素的位置。</p>
</li>
</ul>
</li>
<li><p>**函数 <code>printArray</code>**：</p>
<ul>
<li><strong>功能</strong>：遍历数组并打印每个元素，便于观察排序前后的结果。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数</strong>：</p>
<ul>
<li><p>步骤</p>
<p>：</p>
<ol>
<li><strong>输入数组大小</strong>：提示用户输入要排序的整数数量 <code>n</code>。</li>
<li><strong>输入数组元素</strong>：动态分配一个大小为 <code>n</code> 的整数数组，并从用户处获取 <code>n</code> 个整数的输入。</li>
<li><strong>打印排序前的数组</strong>：调用 <code>printArray</code> 函数显示原始数组。</li>
<li><strong>执行冒泡排序</strong>：调用 <code>bubbleSort</code> 函数对数组进行排序。</li>
<li><strong>打印排序后的数组</strong>：再次调用 <code>printArray</code> 函数显示排序后的数组。</li>
<li><strong>内存管理</strong>：使用 <code>delete[]</code> 释放动态分配的内存，避免内存泄漏。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li>判断用户输入的数组大小 <code>n</code> 是否为正整数，否者输出错误信息并终止程序。</li>
</ul>
</li>
</ol>
<h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a><strong>运行示例</strong></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入整数的数量: 5</span></span><br><span class="line">请输入 5 个整数，用空格分隔: 64 34 25 12 22</span><br><span class="line"><span class="section">排序前的数组: 64 34 25 12 22 </span></span><br><span class="line"><span class="section">排序后的数组: 12 22 25 34 64 </span></span><br></pre></td></tr></table></figure>





<h2 id="练习题-3：生成斐波那契数列"><a href="#练习题-3：生成斐波那契数列" class="headerlink" title="练习题 3：生成斐波那契数列"></a>练习题 3：生成斐波那契数列</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>编写一个 C++ 程序，生成并显示斐波那契数列。程序应允许用户指定生成数列的长度，并使用 <strong>循环结构</strong> 或 <strong>递归方法</strong> 来生成斐波那契数。</p>
<p>斐波那契数列是一个由 0 和 1 开始，后续的每个数都是前两个数之和的数列。例如：0, 1, 1, 2, 3, 5, 8, 13, …</p>
<h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a><strong>要求</strong></h3><ol>
<li><strong>输入</strong>：用户输入要生成的斐波那契数的数量 <code>n</code>。</li>
<li><strong>生成</strong>：使用循环结构（如 <code>for</code> 或 <code>while</code> 循环）生成斐波那契数列。</li>
<li><strong>输出</strong>：显示生成的斐波那契数列。</li>
<li><strong>函数封装</strong>：将生成斐波那契数列的逻辑封装在一个独立的函数中。</li>
</ol>
<h3 id="示例输入与输出-1"><a href="#示例输入与输出-1" class="headerlink" title="示例输入与输出"></a><strong>示例输入与输出</strong></h3><p><strong>示例 1：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 10</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 </span><br></pre></td></tr></table></figure>



<p><strong>示例 2：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 5</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 </span><br></pre></td></tr></table></figure>



<h3 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a><strong>提示</strong></h3><ul>
<li><p>斐波那契数列的定义</p>
<p>：</p>
<ul>
<li>第 0 个斐波那契数是 0。</li>
<li>第 1 个斐波那契数是 1。</li>
<li>对于 <code>n &gt;= 2</code>，第 <code>n</code> 个斐波那契数是第 <code>n-1</code> 个数和第 <code>n-2</code> 个数的和。</li>
</ul>
</li>
<li><p>实现方法</p>
<p>：</p>
<ul>
<li><strong>迭代法</strong>：使用循环结构依次计算斐波那契数。</li>
<li><strong>递归法</strong>（高级）：使用递归函数实现，但效率较低，通常不推荐用于较大的 <code>n</code>。</li>
</ul>
</li>
<li><p><strong>数据类型</strong>：根据 <code>n</code> 的范围选择合适的数据类型，<code>unsigned long long</code> 可以存储较大的斐波那契数。</p>
</li>
</ul>
<h3 id="参考答案（迭代法实现）"><a href="#参考答案（迭代法实现）" class="headerlink" title="参考答案（迭代法实现）"></a><strong>参考答案（迭代法实现）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成斐波那契数列的函数（迭代法）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">generateFibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fib;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空向量</span></span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个斐波那契数</span></span><br><span class="line">    fib.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个斐波那契数</span></span><br><span class="line">    fib.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成后续的斐波那契数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> next = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        fib.<span class="built_in">push_back</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斐波那契数列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFibonacci</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; &amp;fib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fib.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取要生成的斐波那契数的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要生成的斐波那契数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数量不能为负数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fibonacci = <span class="built_in">generateFibonacci</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印斐波那契数列</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;斐波那契数列:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printFibonacci</span>(fibonacci);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ol>
<li><p>**函数 <code>generateFibonacci</code>**：</p>
<ul>
<li><p><strong>参数</strong>：接收一个整数 <code>n</code>，表示要生成的斐波那契数的数量。</p>
</li>
<li><p><strong>返回值</strong>：返回一个 <code>std::vector&lt;unsigned long long&gt;</code>，包含生成的斐波那契数列。</p>
</li>
<li><p>逻辑</p>
<p>：</p>
<ul>
<li>如果 <code>n &lt;= 0</code>，返回一个空的向量。</li>
<li>初始化斐波那契数列的前两个数：0 和 1。</li>
<li>使用一个 <code>for</code> 循环，从第三个数开始，依次计算当前数为前两个数之和，并将其添加到向量中。</li>
</ul>
</li>
</ul>
</li>
<li><p>**函数 <code>printFibonacci</code>**：</p>
<ul>
<li><strong>参数</strong>：接收一个 <code>const</code> 引用的斐波那契数列向量。</li>
<li><strong>功能</strong>：遍历并打印斐波那契数列中的每个数，用空格分隔。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数</strong>：</p>
<ul>
<li><p>步骤</p>
<p>：</p>
<ol>
<li><strong>输入数量</strong>：提示用户输入要生成的斐波那契数的数量 <code>n</code>。</li>
<li><strong>输入验证</strong>：检查 <code>n</code> 是否为负数，若是则输出错误信息并终止程序。</li>
<li><strong>生成数列</strong>：调用 <code>generateFibonacci</code> 函数生成斐波那契数列。</li>
<li><strong>打印数列</strong>：调用 <code>printFibonacci</code> 函数显示生成的斐波那契数列。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>数据类型选择</strong>：</p>
<ul>
<li>使用 <code>unsigned long long</code> 可以存储较大的斐波那契数，避免整数溢出。但需要注意，<code>unsigned long long</code> 的范围有限，对于非常大的 <code>n</code>，仍然会发生溢出。</li>
</ul>
</li>
</ol>
<h3 id="运行示例-1"><a href="#运行示例-1" class="headerlink" title="运行示例"></a><strong>运行示例</strong></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入要生成的斐波那契数的数量: 10</span></span><br><span class="line"><span class="section">斐波那契数列:</span></span><br><span class="line">0 1 1 2 3 5 8 13 21 34 </span><br></pre></td></tr></table></figure>



<h3 id="递归实现参考代码（可选）"><a href="#递归实现参考代码（可选）" class="headerlink" title="递归实现参考代码（可选）"></a><strong>递归实现参考代码（可选）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，计算第 n 个斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;n 不能为负数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacciRecursive</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacciRecursive</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成斐波那契数列的函数（递归实现）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">generateFibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fib;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fib.<span class="built_in">push_back</span>(<span class="built_in">fibonacciRecursive</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斐波那契数列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFibonacci</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; &amp;fib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fib.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取要生成的斐波那契数的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要生成的斐波那契数的数量: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：数量不能为负数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 生成斐波那契数列（递归实现）</span></span><br><span class="line">        std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; fibonacci = <span class="built_in">generateFibonacciRecursive</span>(n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印斐波那契数列</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;斐波那契数列:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printFibonacci</span>(fibonacci);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归实现说明"><a href="#递归实现说明" class="headerlink" title="递归实现说明"></a><strong>递归实现说明</strong></h3><ul>
<li><p>优点</p>
<p>：</p>
<ul>
<li>代码简洁，符合斐波那契数列的数学定义。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>时间复杂度为指数级 <code>O(2^n)</code>，对于较大的 <code>n</code> 会非常低效。</li>
<li>递归深度过大可能导致栈溢出。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合学习和理解递归概念，但在实际应用中需谨慎使用。</p>
</li>
</ul>
<h3 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h3><p>动态规划通过存储已计算的值来避免重复计算，提高了效率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划实现斐波那契数列</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fibonacci_dynamic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fib</span><span class="params">(n)</span></span>;</span><br><span class="line">    fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入斐波那契数列的项数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; fib = <span class="built_in">fibonacci_dynamic</span>(n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;斐波那契数列的前 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 项为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; fib[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/10/26/cppbase16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/26/cppbase16/" itemprop="url">零基础C++(16) 常见运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-26T11:59:11+08:00">
                2024-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cppbase/" itemprop="url" rel="index">
                    <span itemprop="name">零基础C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>运算符是编程语言中用于执行特定操作的符号或关键字。在C++中，运算符的使用广泛且多样，掌握运算符的使用对于编写高效、简洁的代码至关重要。本教案旨在全面介绍C++中的各种运算符，帮助学习者深入理解和灵活运用。</p>
<h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><p><strong>运算符（Operator）</strong> 是用来对变量进行操作的符号或函数。C++中的运算符可分为多种类型，每种运算符具有特定的功能和使用规则。运算符可以单目（仅操作一个操作数）、双目（操作两个操作数）、甚至三目（操作三个操作数）等。</p>
<h2 id="运算符分类"><a href="#运算符分类" class="headerlink" title="运算符分类"></a>运算符分类</h2><p>C++中的运算符可以根据功能和使用方式分为以下几类：</p>
<h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>用于执行基本的数学计算。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>a + b</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>a - b</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>a * b</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>a / b</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模（求余数）</td>
<td><code>a % b</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增（前缀/后缀）</td>
<td><code>++a</code>, <code>a++</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减（前缀/后缀）</td>
<td><code>--a</code>, <code>a--</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> sum = a + b;    <span class="comment">// 13</span></span><br><span class="line"><span class="type">int</span> diff = a - b;   <span class="comment">// 7</span></span><br><span class="line"><span class="type">int</span> prod = a * b;   <span class="comment">// 30</span></span><br><span class="line"><span class="type">int</span> div = a / b;    <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span> mod = a % b;    <span class="comment">// 1</span></span><br><span class="line">a++;                <span class="comment">// a = 11</span></span><br><span class="line">--b;                <span class="comment">// b = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h3><p>用于比较两个值之间的关系，返回布尔值（<code>true</code> 或 <code>false</code>）。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>a == b</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>a != b</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>a &gt; b</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>a &lt; b</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于或等于</td>
<td><code>a &gt;= b</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
<td><code>a &lt;= b</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> result1 = (a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">bool</span> result2 = (a &lt; b);  <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> result3 = (a &gt;= b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>用于组合或反转布尔表达式，返回布尔值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与（AND）</td>
<td><code>a &amp;&amp; b</code></td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非（NOT）</td>
<td><code>!a</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> result1 = a &amp;&amp; b; <span class="comment">// false</span></span><br><span class="line"><span class="type">bool</span> result2 = a || b; <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> result3 = !a;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>用于按位操作整数类型的二进制位。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>a &amp; b</code></td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>按位或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或（不等时为1）</td>
<td><code>a ^ b</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位取反</td>
<td><code>~a</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>a &lt;&lt; 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>a &gt;&gt; 2</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 二进制：0101</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 二进制：0011</span></span><br><span class="line"><span class="type">int</span> andResult = a &amp; b; <span class="comment">// 1 (0001)</span></span><br><span class="line"><span class="type">int</span> orResult = a | b;  <span class="comment">// 7 (0111)</span></span><br><span class="line"><span class="type">int</span> xorResult = a ^ b; <span class="comment">// 6 (0110)</span></span><br><span class="line"><span class="type">int</span> notResult = ~a;    <span class="comment">// -6 (补码)</span></span><br><span class="line"><span class="type">int</span> leftShift = a &lt;&lt; <span class="number">1</span>; <span class="comment">// 10 (1010)</span></span><br><span class="line"><span class="type">int</span> rightShift = a &gt;&gt; <span class="number">1</span>; <span class="comment">// 2 (0010)</span></span><br></pre></td></tr></table></figure>



<h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h3><p>用于向变量赋值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>简单赋值</td>
<td><code>a = b</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加后赋值</td>
<td><code>a += b</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减后赋值</td>
<td><code>a -= b</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘后赋值</td>
<td><code>a *= b</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除后赋值</td>
<td><code>a /= b</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模后赋值</td>
<td><code>a %= b</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与后赋值</td>
<td><code>a &amp;= b</code></td>
</tr>
<tr>
<td>`</td>
<td>=`</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或后赋值</td>
<td><code>a ^= b</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移后赋值</td>
<td><code>a &lt;&lt;= 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移后赋值</td>
<td><code>a &gt;&gt;= 2</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">a += b; <span class="comment">// a = 8</span></span><br><span class="line">a *= <span class="number">2</span>; <span class="comment">// a = 16</span></span><br><span class="line">a &amp;= b; <span class="comment">// a = 16 &amp; 3 = 0</span></span><br></pre></td></tr></table></figure>



<h3 id="6-复合赋值运算符"><a href="#6-复合赋值运算符" class="headerlink" title="6. 复合赋值运算符"></a>6. 复合赋值运算符</h3><p>结合赋值与其他运算的运算符（如上表中所示的<code>+=</code>, <code>-=</code>, 等）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// 等同于 a = a + 5; 结果 a = 15</span></span><br></pre></td></tr></table></figure>



<h3 id="7-条件运算符"><a href="#7-条件运算符" class="headerlink" title="7. 条件运算符"></a>7. 条件运算符</h3><p>用于基于条件选择值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>?:</code></td>
<td>条件（三目）运算符</td>
<td><code>a ? b : c</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">c = (a &gt; b) ? a : b; <span class="comment">// c = 20</span></span><br></pre></td></tr></table></figure>



<h3 id="8-递增和递减运算符"><a href="#8-递增和递减运算符" class="headerlink" title="8. 递增和递减运算符"></a>8. 递增和递减运算符</h3><p>用于增加或减少变量的值，前缀和后缀形式。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>++</code></td>
<td>自增（前缀/后缀）</td>
<td><code>++a</code>, <code>a++</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减（前缀/后缀）</td>
<td><code>--a</code>, <code>a--</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = ++a; <span class="comment">// a = 6, b = 6</span></span><br><span class="line"><span class="type">int</span> c = a--; <span class="comment">// a = 5, c = 6</span></span><br></pre></td></tr></table></figure>



<h3 id="9-指针运算符"><a href="#9-指针运算符" class="headerlink" title="9. 指针运算符"></a>9. 指针运算符</h3><p>用于操作指针。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>间接访问（解引用）</td>
<td><code>*ptr</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>取地址</td>
<td><code>&amp;a</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>成员访问（指向对象的指针）</td>
<td><code>ptr-&gt;member</code></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>数组下标访问</td>
<td><code>arr[2]</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// value = 10</span></span><br></pre></td></tr></table></figure>



<h3 id="10-成员访问运算符"><a href="#10-成员访问运算符" class="headerlink" title="10. 成员访问运算符"></a>10. 成员访问运算符</h3><p>用于访问类或结构体的成员。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>直接成员访问</td>
<td><code>object.member</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>指向成员的指针访问</td>
<td><code>ptr-&gt;member</code></td>
</tr>
<tr>
<td><code>::*</code></td>
<td>指向成员的指针（成员指针操作符）</td>
<td><code>Class::*ptr</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">Point *ptr = &amp;p;</span><br><span class="line"><span class="type">int</span> a = p.x;      <span class="comment">// 使用 . 运算符</span></span><br><span class="line"><span class="type">int</span> b = ptr-&gt;y;  <span class="comment">// 使用 -&gt; 运算符</span></span><br></pre></td></tr></table></figure>



<h3 id="11-其他运算符"><a href="#11-其他运算符" class="headerlink" title="11. 其他运算符"></a>11. 其他运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>sizeof</code></td>
<td>返回变量或类型所占字节数</td>
<td><code>sizeof(int)</code></td>
</tr>
<tr>
<td><code>?:</code></td>
<td>条件（三目）运算符</td>
<td><code>a ? b : c</code></td>
</tr>
<tr>
<td><code>,</code></td>
<td>逗号运算符</td>
<td><code>a = (b, c)</code></td>
</tr>
<tr>
<td><code>typeid</code></td>
<td>运行时类型信息运算符</td>
<td><code>typeid(a)</code></td>
</tr>
<tr>
<td><code>new</code></td>
<td>动态内存分配</td>
<td><code>int *ptr = new int;</code></td>
</tr>
<tr>
<td><code>delete</code></td>
<td>动态内存释放</td>
<td><code>delete ptr;</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(a); <span class="comment">// size = 4 (通常)</span></span><br><span class="line"><span class="type">int</span> b, c;</span><br><span class="line">b = (a++, a + <span class="number">2</span>); <span class="comment">// a = 6, b = 8</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h2><p>运算符的优先级决定了在没有括号明确指定的情况下，哪一个运算符先被计算。结合性则决定了运算符在具有相同优先级时的计算顺序（从左到右或从右到左）。</p>
<h3 id="优先级表"><a href="#优先级表" class="headerlink" title="优先级表"></a>优先级表</h3><p>以下是C++运算符的优先级从高到低的简要概览：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符类别</th>
<th>运算符</th>
<th>结合性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>范围解析运算符</td>
<td><code>::</code></td>
<td>左到右</td>
<td>用于访问命名空间或类的成员</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>后缀运算符</td>
<td><code>()</code>, <code>[]</code>, <code>.</code>, <code>-&gt;</code>, <code>++</code>(后置), <code>--</code>(后置)</td>
<td>左到右</td>
<td>包含函数调用、数组下标、成员访问</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>一元运算符</td>
<td><code>+</code>, <code>-</code>, <code>!</code>, <code>~</code>, <code>++</code>(前置), <code>--</code>(前置), <code>*</code>(解引用), <code>&amp;</code>(取地址), <code>sizeof</code>, <code>typeid</code></td>
<td>右到左</td>
<td>适用于单个操作数的运算符</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>乘法运算符</td>
<td><code>*</code>, <code>/</code>, <code>%</code></td>
<td>左到右</td>
<td>乘法、除法和取模运算</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>加法运算符</td>
<td><code>+</code>, <code>-</code></td>
<td>左到右</td>
<td>加法和减法运算</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>移位运算符</td>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td>左到右</td>
<td>位左移和位右移</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>关系运算符</td>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
<td>左到右</td>
<td>比较运算符</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>相等运算符</td>
<td><code>==</code>, <code>!=</code></td>
<td>左到右</td>
<td>判断相等与不相等</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>位与运算符</td>
<td><code>&amp;</code></td>
<td>左到右</td>
<td>按位与</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>位异或运算符</td>
<td><code>^</code></td>
<td>左到右</td>
<td>按位异或</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>位或运算符</td>
<td>`</td>
<td>`</td>
<td>左到右</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>逻辑与运算符</td>
<td><code>&amp;&amp;</code></td>
<td>左到右</td>
<td>逻辑与</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>逻辑或运算符</td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td>条件运算符</td>
<td><code>?:</code></td>
<td>右到左</td>
<td>条件（三目）运算符</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>赋值运算符</td>
<td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, `</td>
<td>=<code>, </code>^=<code>, </code>&lt;&lt;=<code>, </code>&gt;&gt;=`</td>
<td>右到左</td>
</tr>
<tr>
<td><strong>16</strong></td>
<td>逗号运算符</td>
<td><code>,</code></td>
<td>左到右</td>
<td>逗号用于表达式中多个操作</td>
</tr>
</tbody></table>
<h3 id="表格说明"><a href="#表格说明" class="headerlink" title="表格说明"></a><strong>表格说明</strong></h3><ul>
<li><strong>优先级</strong>：数字越小，优先级越高。即优先级为1的运算符最先被计算。</li>
<li><strong>运算符类别</strong>：运算符的功能分类，帮助理解不同类型运算符的用途。</li>
<li><strong>运算符</strong>：具体的C++运算符符号。</li>
<li><strong>结合性</strong>：当表达式中出现多个相同优先级的运算符时，决定运算顺序的规则。<code>左到右</code>表示从左侧的操作数开始，<code>右到左</code>表示从右侧的操作数开始。</li>
<li><strong>备注</strong>：对运算符类别或特定运算符的简要说明。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><strong>运算符重载（Operator Overloading）</strong> 允许开发者为自定义类型（如类和结构体）定义或改变运算符的行为，使其表现得像内置类型一样。这提高了代码的可读性和可维护性。</p>
<h3 id="运算符重载的规则"><a href="#运算符重载的规则" class="headerlink" title="运算符重载的规则"></a>运算符重载的规则</h3><ol>
<li><strong>可重载运算符</strong>：几乎所有的运算符都可以被重载，但如 <code>::</code>, <code>?:</code>, <code>sizeof</code> 等运算符不能被重载。</li>
<li><strong>至少一个操作数必须是用户定义类型</strong>：即至少有一个操作数是类、结构体或联合体类型。</li>
<li><strong>运算符重载不改变运算符的优先级、结合性和操作数数量</strong>。</li>
</ol>
<h3 id="运算符重载的基本语法"><a href="#运算符重载的基本语法" class="headerlink" title="运算符重载的基本语法"></a>运算符重载的基本语法</h3><p>运算符可以作为成员函数或友元函数进行重载。</p>
<p><strong>成员函数重载示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">        Complex temp;</span><br><span class="line">        temp.real = real + c.real;</span><br><span class="line">        temp.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>友元函数重载示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2) &#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = c1.real + c2.real;</span><br><span class="line">    temp.imag = c1.imag + c2.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常见的重载运算符"><a href="#常见的重载运算符" class="headerlink" title="常见的重载运算符"></a>常见的重载运算符</h3><ul>
<li><strong>算术运算符</strong>：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>关系运算符</strong>：<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li><strong>逻辑运算符</strong>：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li><strong>赋值运算符</strong>：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li><strong>输入输出运算符</strong>：<code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li><strong>索引运算符</strong>：<code>[]</code></li>
<li><strong>函数调用运算符</strong>：<code>()</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, imag + c.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符（作为友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c) &#123;</span><br><span class="line">    out &lt;&lt; c.real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.8</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl; <span class="comment">// 输出: c1 + c2 = 6.8 + 11.2i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1-交换两个数"><a href="#1-交换两个数" class="headerlink" title="1 交换两个数"></a>1 交换两个数</h3><p><strong>题目：</strong> 使用位运算符，交换两个整数变量的值而不使用第三个变量。</p>
<p><strong>答案：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换操作</span></span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = x ^ y;</span><br><span class="line">    x = x ^ y;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Before swap:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">15</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">27</span></span><br><span class="line"><span class="attr">After swap:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">27</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong> 通过异或运算 <code>^</code> 完成变量值的交换，无需使用临时变量。</p>
<h3 id="2-函数修改外部变量"><a href="#2-函数修改外部变量" class="headerlink" title="2 函数修改外部变量"></a>2 函数修改外部变量</h3><p><strong>题目：</strong> 编写一个函数，接受一个整数指针，使用解引用运算符修改其值为原值的平方。</p>
<p><strong>答案：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">square</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = (*ptr) * (*ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">square</span>(&amp;num);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Before: 5</span></span><br><span class="line"><span class="section">After: 25</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong> 通过指针访问并修改原变量的值。</p>
<h3 id="3-计算范围内所有元素的和"><a href="#3-计算范围内所有元素的和" class="headerlink" title="3 计算范围内所有元素的和"></a>3 计算范围内所有元素的和</h3><p><strong>题目：</strong> 编写一个函数，接受 <code>std::vector&lt;int&gt;</code> 的迭代器范围，计算并返回范围内所有元素的和。</p>
<p><strong>函数示例：</strong></p>
<p>须实现如下函数，返回范围内元素求和的结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator end)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>答案：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="built_in">sumRange</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预期输出：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Sum: 30</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong> 函数通过迭代器遍历范围，累加元素值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/3/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">370</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/secondtonone1" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" target="_blank" title="ZhiHu">
                    
                      <i class="fa fa-fw fa-ZhiHu"></i>ZhiHu</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恋恋风辰</span>

  
  
 
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
 
 
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
