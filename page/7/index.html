<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="恋恋风辰的个人博客" type="application/atom+xml" />






<meta name="description" content="重剑无锋，大巧不工">
<meta property="og:type" content="website">
<meta property="og:title" content="恋恋风辰的个人博客">
<meta property="og:url" content="http://www.limerence2017.com/page/7/index.html">
<meta property="og:site_name" content="恋恋风辰的个人博客">
<meta property="og:description" content="重剑无锋，大巧不工">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="恋恋风辰">
<meta property="article:tag" content="C++ python 大并发网络 逆向">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.limerence2017.com/page/7/"/>





  <title>恋恋风辰的个人博客</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恋恋风辰的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/08/31/cpppro26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/31/cpppro26/" itemprop="url">聊天项目(26) 实现联系人和好友申请列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-31T09:30:35+08:00">
                2024-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpppro/" itemprop="url" rel="index">
                    <span itemprop="name">C++聊天项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今日实现界面效果</p>
<p><img src="https://cdn.llfc.club/1721547194830.jpg" alt="https://cdn.llfc.club/1721547194830.jpg"></p>
<h2 id="联系人列表"><a href="#联系人列表" class="headerlink" title="联系人列表"></a>联系人列表</h2><p>我们自定义一个ChatUserList类，用来管理聊天列表。其声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContactUserList</span> : <span class="keyword">public</span> QListWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ContactUserList</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowRedPoint</span><span class="params">(<span class="type">bool</span> bshow = <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addContactUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">slot_item_clicked</span><span class="params">(QListWidgetItem *item)</span></span>;</span><br><span class="line"><span class="comment">//     void slot_add_auth_firend(std::shared_ptr&lt;AuthInfo&gt;);</span></span><br><span class="line"><span class="comment">//     void slot_auth_rsp(std::shared_ptr&lt;AuthRsp&gt;);</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_loading_contact_user</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_switch_apply_friend_page</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_switch_friend_info_page</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ConUserItem* _add_friend_item;</span><br><span class="line">    QListWidgetItem * _groupitem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">ContactUserList::<span class="built_in">ContactUserList</span>(QWidget *parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(parent);</span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">    <span class="comment">// 安装事件过滤器</span></span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>()-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟从数据库或者后端传输过来的数据,进行列表加载</span></span><br><span class="line">    <span class="built_in">addContactUserList</span>();</span><br><span class="line">    <span class="comment">//连接点击的信号和槽</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;QListWidget::itemClicked, <span class="keyword">this</span>, &amp;ContactUserList::slot_item_clicked);</span><br><span class="line"><span class="comment">//    //链接对端同意认证后通知的信号</span></span><br><span class="line"><span class="comment">//    connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_add_auth_friend,this,</span></span><br><span class="line"><span class="comment">//            &amp;ContactUserList::slot_add_auth_firend);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //链接自己点击同意认证后界面刷新</span></span><br><span class="line"><span class="comment">//    connect(TcpMgr::GetInstance().get(), &amp;TcpMgr::sig_auth_rsp,this,</span></span><br><span class="line"><span class="comment">//            &amp;ContactUserList::slot_auth_rsp);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContactUserList::ShowRedPoint</span><span class="params">(<span class="type">bool</span> bshow <span class="comment">/*= true*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _add_friend_item-&gt;<span class="built_in">ShowRedPoint</span>(bshow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContactUserList::addContactUserList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> * groupTip = <span class="keyword">new</span> <span class="built_in">GroupTipItem</span>();</span><br><span class="line">    QListWidgetItem *item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    item-&gt;<span class="built_in">setSizeHint</span>(groupTip-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setItemWidget</span>(item, groupTip);</span><br><span class="line">    item-&gt;<span class="built_in">setFlags</span>(item-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsSelectable);</span><br><span class="line"></span><br><span class="line">    _add_friend_item = <span class="keyword">new</span> <span class="built_in">ConUserItem</span>();</span><br><span class="line">    _add_friend_item-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;new_friend_item&quot;</span>);</span><br><span class="line">    _add_friend_item-&gt;<span class="built_in">SetInfo</span>(<span class="number">0</span>,<span class="built_in">tr</span>(<span class="string">&quot;新的朋友&quot;</span>),<span class="string">&quot;:/res/add_friend.png&quot;</span>);</span><br><span class="line">    _add_friend_item-&gt;<span class="built_in">SetItemType</span>(ListItemType::APPLY_FRIEND_ITEM);</span><br><span class="line"></span><br><span class="line">    QListWidgetItem *add_item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">    add_item-&gt;<span class="built_in">setSizeHint</span>(_add_friend_item-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addItem</span>(add_item);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setItemWidget</span>(add_item, _add_friend_item);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认设置新的朋友申请条目被选中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCurrentItem</span>(add_item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> * groupCon = <span class="keyword">new</span> <span class="built_in">GroupTipItem</span>();</span><br><span class="line">    groupCon-&gt;<span class="built_in">SetGroupTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;联系人&quot;</span>));</span><br><span class="line">    _groupitem = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    _groupitem-&gt;<span class="built_in">setSizeHint</span>(groupCon-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addItem</span>(_groupitem);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setItemWidget</span>(_groupitem, groupCon);</span><br><span class="line">    _groupitem-&gt;<span class="built_in">setFlags</span>(_groupitem-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsSelectable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QListWidgetItem，并设置自定义的widget</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">        <span class="type">int</span> str_i = randomValue%strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> head_i = randomValue%heads.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> name_i = randomValue%names.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> *con_user_wid = <span class="keyword">new</span> <span class="built_in">ConUserItem</span>();</span><br><span class="line">        con_user_wid-&gt;<span class="built_in">SetInfo</span>(<span class="number">0</span>,names[name_i], heads[head_i]);</span><br><span class="line">        QListWidgetItem *item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">        <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">        item-&gt;<span class="built_in">setSizeHint</span>(con_user_wid-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setItemWidget</span>(item, con_user_wid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContactUserList::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查事件是否是鼠标悬浮进入或离开</span></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::Enter) &#123;</span><br><span class="line">            <span class="comment">// 鼠标悬浮，显示滚动条</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAsNeeded);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::Leave) &#123;</span><br><span class="line">            <span class="comment">// 鼠标离开，隐藏滚动条</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查事件是否是鼠标滚轮事件</span></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>() &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Wheel) &#123;</span><br><span class="line">        QWheelEvent *wheelEvent = <span class="built_in">static_cast</span>&lt;QWheelEvent*&gt;(event);</span><br><span class="line">        <span class="type">int</span> numDegrees = wheelEvent-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">y</span>() / <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> numSteps = numDegrees / <span class="number">15</span>; <span class="comment">// 计算滚动步数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置滚动幅度</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setValue</span>(<span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">value</span>() - numSteps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否滚动到底部</span></span><br><span class="line">        QScrollBar *scrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>();</span><br><span class="line">        <span class="type">int</span> maxScrollValue = scrollBar-&gt;<span class="built_in">maximum</span>();</span><br><span class="line">        <span class="type">int</span> currentValue = scrollBar-&gt;<span class="built_in">value</span>();</span><br><span class="line">        <span class="comment">//int pageSize = 10; // 每页加载的联系人数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxScrollValue - currentValue &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 滚动到底部，加载新的联系人</span></span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;load more contact user&quot;</span>;</span><br><span class="line">            <span class="comment">//发送信号通知聊天界面加载更多聊天内容</span></span><br><span class="line">            <span class="function">emit <span class="title">sig_loading_contact_user</span><span class="params">()</span></span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 停止事件传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QListWidget::<span class="built_in">eventFilter</span>(watched, event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContactUserList::slot_item_clicked</span><span class="params">(QListWidgetItem *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QWidget *widget = <span class="keyword">this</span>-&gt;<span class="built_in">itemWidget</span>(item); <span class="comment">// 获取自定义widget对象</span></span><br><span class="line">    <span class="keyword">if</span>(!widget)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;slot item clicked widget is nullptr&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对自定义widget进行操作， 将item 转化为基类ListItemBase</span></span><br><span class="line">    ListItemBase *customItem = <span class="built_in">qobject_cast</span>&lt;ListItemBase*&gt;(widget);</span><br><span class="line">    <span class="keyword">if</span>(!customItem)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;slot item clicked widget is nullptr&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> itemType = customItem-&gt;<span class="built_in">GetItemType</span>();</span><br><span class="line">    <span class="keyword">if</span>(itemType == ListItemType::INVALID_ITEM</span><br><span class="line">            || itemType == ListItemType::GROUP_TIP_ITEM)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;slot invalid item clicked &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(itemType == ListItemType::APPLY_FRIEND_ITEM)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建对话框，提示用户</span></span><br><span class="line">       <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;apply friend item clicked &quot;</span>;</span><br><span class="line">       <span class="comment">//跳转到好友申请界面</span></span><br><span class="line">       <span class="function">emit <span class="title">sig_switch_apply_friend_page</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(itemType == ListItemType::CONTACT_USER_ITEM)&#123;</span><br><span class="line">       <span class="comment">// 创建对话框，提示用户</span></span><br><span class="line">       <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;contact user item clicked &quot;</span>;</span><br><span class="line">       <span class="comment">//跳转到好友申请界面</span></span><br><span class="line">       <span class="function">emit <span class="title">sig_switch_friend_info_page</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造函数中关闭了滚动条的显示，重写了事件过滤器，实现了根据鼠标区域判断是否显示滚动条的功能。</p>
<p>并且实现了点击其中某个item响应对应的功能。并根据不同的item类型跳转不同的页面。</p>
<h2 id="联系人item"><a href="#联系人item" class="headerlink" title="联系人item"></a>联系人item</h2><p>因为每一个item都是我们自己定义的，所以我们添加设计师界面类，界面布局如下所示</p>
<p><img src="https://cdn.llfc.club/1721544014771.jpg" alt="https://cdn.llfc.club/1721544014771.jpg"></p>
<p>类的声明如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConUserItem</span> : <span class="keyword">public</span> ListItemBase</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ConUserItem</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ConUserItem</span>();</span><br><span class="line">    <span class="function">QSize <span class="title">sizeHint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetInfo</span><span class="params">(std::shared_ptr&lt;AuthInfo&gt; auth_info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetInfo</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetInfo</span><span class="params">(<span class="type">int</span> uid, QString name, QString icon)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowRedPoint</span><span class="params">(<span class="type">bool</span> show = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ConUserItem *ui;</span><br><span class="line">    std::shared_ptr&lt;UserInfo&gt; _info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ConUserItem::<span class="built_in">ConUserItem</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">ListItemBase</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ConUserItem)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">SetItemType</span>(ListItemType::CONTACT_USER_ITEM);</span><br><span class="line">    ui-&gt;red_point-&gt;<span class="built_in">raise</span>();</span><br><span class="line">    <span class="built_in">ShowRedPoint</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConUserItem::~<span class="built_in">ConUserItem</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QSize <span class="title">ConUserItem::sizeHint</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">250</span>, <span class="number">70</span>); <span class="comment">// 返回自定义的尺寸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConUserItem::SetInfo</span><span class="params">(std::shared_ptr&lt;AuthInfo&gt; auth_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;(auth_info);</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(_info-&gt;_icon)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置图片自动缩放</span></span><br><span class="line">    ui-&gt;icon_lb-&gt;<span class="built_in">setPixmap</span>(pixmap.<span class="built_in">scaled</span>(ui-&gt;icon_lb-&gt;<span class="built_in">size</span>(), Qt::KeepAspectRatio, Qt::SmoothTransformation));</span><br><span class="line">    ui-&gt;icon_lb-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;user_name_lb-&gt;<span class="built_in">setText</span>(_info-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConUserItem::SetInfo</span><span class="params">(<span class="type">int</span> uid, QString name, QString icon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     _info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;(uid,name, icon);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加载图片</span></span><br><span class="line">     <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(_info-&gt;_icon)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置图片自动缩放</span></span><br><span class="line">     ui-&gt;icon_lb-&gt;<span class="built_in">setPixmap</span>(pixmap.<span class="built_in">scaled</span>(ui-&gt;icon_lb-&gt;<span class="built_in">size</span>(), Qt::KeepAspectRatio, Qt::SmoothTransformation));</span><br><span class="line">     ui-&gt;icon_lb-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">     ui-&gt;user_name_lb-&gt;<span class="built_in">setText</span>(_info-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConUserItem::SetInfo</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)</span></span>&#123;</span><br><span class="line">    _info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;(auth_rsp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(_info-&gt;_icon)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置图片自动缩放</span></span><br><span class="line">    ui-&gt;icon_lb-&gt;<span class="built_in">setPixmap</span>(pixmap.<span class="built_in">scaled</span>(ui-&gt;icon_lb-&gt;<span class="built_in">size</span>(), Qt::KeepAspectRatio, Qt::SmoothTransformation));</span><br><span class="line">    ui-&gt;icon_lb-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;user_name_lb-&gt;<span class="built_in">setText</span>(_info-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConUserItem::ShowRedPoint</span><span class="params">(<span class="type">bool</span> show)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(show)&#123;</span><br><span class="line">        ui-&gt;red_point-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ui-&gt;red_point-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们启动程序就能看到模拟的联系人列表被加载进来了。</p>
<h2 id="申请列表"><a href="#申请列表" class="headerlink" title="申请列表"></a>申请列表</h2><p>申请页面ui布局如下</p>
<p><img src="https://cdn.llfc.club/1721545292540.jpg" alt="https://cdn.llfc.club/1721545292540.jpg"></p>
<p>我们新增ApplyFriendPage类，用来显示申请列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplyFriendPage</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ApplyFriendPage</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ApplyFriendPage</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddNewApply</span><span class="params">(std::shared_ptr&lt;AddFriendApply&gt; apply)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadApplyList</span><span class="params">()</span></span>;</span><br><span class="line">    Ui::ApplyFriendPage *ui;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, ApplyFriendItem*&gt; _unauth_items;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slot_auth_rsp</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; )</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_show_search</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">ApplyFriendPage::<span class="built_in">ApplyFriendPage</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ApplyFriendPage)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;apply_friend_list, &amp;ApplyFriendList::sig_show_search, <span class="keyword">this</span>, &amp;ApplyFriendPage::sig_show_search);</span><br><span class="line">    <span class="built_in">loadApplyList</span>();</span><br><span class="line">    <span class="comment">//接受tcp传递的authrsp信号处理</span></span><br><span class="line">    <span class="built_in">connect</span>(TcpMgr::<span class="built_in">GetInstance</span>().<span class="built_in">get</span>(), &amp;TcpMgr::sig_auth_rsp, <span class="keyword">this</span>, &amp;ApplyFriendPage::slot_auth_rsp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendPage::~<span class="built_in">ApplyFriendPage</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendPage::AddNewApply</span><span class="params">(std::shared_ptr&lt;AddFriendApply&gt; apply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先模拟头像随机，以后头像资源增加资源服务器后再显示</span></span><br><span class="line">    <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">    <span class="type">int</span> head_i = randomValue % heads.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span>* apply_item = <span class="keyword">new</span> <span class="built_in">ApplyFriendItem</span>();</span><br><span class="line">    <span class="keyword">auto</span> apply_info = std::<span class="built_in">make_shared</span>&lt;ApplyInfo&gt;(apply-&gt;_from_uid,</span><br><span class="line">             apply-&gt;_name, apply-&gt;_desc,heads[head_i], apply-&gt;_name, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    apply_item-&gt;<span class="built_in">SetInfo</span>( apply_info);</span><br><span class="line">    QListWidgetItem* item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">    item-&gt;<span class="built_in">setSizeHint</span>(apply_item-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    item-&gt;<span class="built_in">setFlags</span>(item-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable);</span><br><span class="line">    ui-&gt;apply_friend_list-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>,item);</span><br><span class="line">    ui-&gt;apply_friend_list-&gt;<span class="built_in">setItemWidget</span>(item, apply_item);</span><br><span class="line">    apply_item-&gt;<span class="built_in">ShowAddBtn</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//收到审核好友信号</span></span><br><span class="line">    <span class="built_in">connect</span>(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [<span class="keyword">this</span>](std::shared_ptr&lt;ApplyInfo&gt; apply_info) &#123;</span><br><span class="line"><span class="comment">//        auto* authFriend = new AuthenFriend(this);</span></span><br><span class="line"><span class="comment">//        authFriend-&gt;setModal(true);</span></span><br><span class="line"><span class="comment">//        authFriend-&gt;SetApplyInfo(apply_info);</span></span><br><span class="line"><span class="comment">//        authFriend-&gt;show();</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendPage::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStyleOption opt;</span><br><span class="line">    opt.<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="built_in">style</span>()-&gt;<span class="built_in">drawPrimitive</span>(QStyle::PE_Widget, &amp;opt, &amp;p, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendPage::loadApplyList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//添加好友申请</span></span><br><span class="line">    <span class="keyword">auto</span> apply_list = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetApplyList</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;apply: apply_list)&#123;</span><br><span class="line">        <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">        <span class="type">int</span> head_i = randomValue % heads.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span>* apply_item = <span class="keyword">new</span> <span class="built_in">ApplyFriendItem</span>();</span><br><span class="line">        apply-&gt;<span class="built_in">SetIcon</span>(heads[head_i]);</span><br><span class="line">        apply_item-&gt;<span class="built_in">SetInfo</span>(apply);</span><br><span class="line">        QListWidgetItem* item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">        <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">        item-&gt;<span class="built_in">setSizeHint</span>(apply_item-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">        item-&gt;<span class="built_in">setFlags</span>(item-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable);</span><br><span class="line">        ui-&gt;apply_friend_list-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>,item);</span><br><span class="line">        ui-&gt;apply_friend_list-&gt;<span class="built_in">setItemWidget</span>(item, apply_item);</span><br><span class="line">        <span class="keyword">if</span>(apply-&gt;_status)&#123;</span><br><span class="line">            apply_item-&gt;<span class="built_in">ShowAddBtn</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             apply_item-&gt;<span class="built_in">ShowAddBtn</span>(<span class="literal">true</span>);</span><br><span class="line">             <span class="keyword">auto</span> uid = apply_item-&gt;<span class="built_in">GetUid</span>();</span><br><span class="line">             _unauth_items[uid] = apply_item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收到审核好友信号</span></span><br><span class="line">        <span class="built_in">connect</span>(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [<span class="keyword">this</span>](std::shared_ptr&lt;ApplyInfo&gt; apply_info) &#123;</span><br><span class="line"><span class="comment">//            auto* authFriend = new AuthenFriend(this);</span></span><br><span class="line"><span class="comment">//            authFriend-&gt;setModal(true);</span></span><br><span class="line"><span class="comment">//            authFriend-&gt;SetApplyInfo(apply_info);</span></span><br><span class="line"><span class="comment">//            authFriend-&gt;show();</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟假数据，创建QListWidgetItem，并设置自定义的widget</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">        <span class="type">int</span> str_i = randomValue%strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> head_i = randomValue%heads.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> name_i = randomValue%names.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> *apply_item = <span class="keyword">new</span> <span class="built_in">ApplyFriendItem</span>();</span><br><span class="line">        <span class="keyword">auto</span> apply = std::<span class="built_in">make_shared</span>&lt;ApplyInfo&gt;(<span class="number">0</span>, names[name_i], strs[str_i],</span><br><span class="line">                                    heads[head_i], names[name_i], <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        apply_item-&gt;<span class="built_in">SetInfo</span>(apply);</span><br><span class="line">        QListWidgetItem *item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">        <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">        item-&gt;<span class="built_in">setSizeHint</span>(apply_item-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">        item-&gt;<span class="built_in">setFlags</span>(item-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable);</span><br><span class="line">        ui-&gt;apply_friend_list-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line">        ui-&gt;apply_friend_list-&gt;<span class="built_in">setItemWidget</span>(item, apply_item);</span><br><span class="line">        <span class="comment">//收到审核好友信号</span></span><br><span class="line">        <span class="built_in">connect</span>(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [<span class="keyword">this</span>](std::shared_ptr&lt;ApplyInfo&gt; apply_info)&#123;</span><br><span class="line"><span class="comment">//            auto *authFriend =  new AuthenFriend(this);</span></span><br><span class="line"><span class="comment">//            authFriend-&gt;setModal(true);</span></span><br><span class="line"><span class="comment">//            authFriend-&gt;SetApplyInfo(apply_info);</span></span><br><span class="line"><span class="comment">//            authFriend-&gt;show();</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendPage::slot_auth_rsp</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> uid = auth_rsp-&gt;_uid;</span><br><span class="line">    <span class="keyword">auto</span> find_iter = _unauth_items.<span class="built_in">find</span>(uid);</span><br><span class="line">    <span class="keyword">if</span> (find_iter == _unauth_items.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_iter-&gt;second-&gt;<span class="built_in">ShowAddBtn</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为每个item自定义，所以我们新增设计师界面类ApplyFriendItem</p>
<p>界面布局</p>
<p><img src="https://cdn.llfc.club/1721546273709.jpg" alt="https://cdn.llfc.club/1721546273709.jpg"></p>
<p>类的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplyFriendItem</span> : <span class="keyword">public</span> ListItemBase</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ApplyFriendItem</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ApplyFriendItem</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetInfo</span><span class="params">(std::shared_ptr&lt;ApplyInfo&gt; apply_info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowAddBtn</span><span class="params">(<span class="type">bool</span> bshow)</span></span>;</span><br><span class="line">    <span class="function">QSize <span class="title">sizeHint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">250</span>, <span class="number">80</span>); <span class="comment">// 返回自定义的尺寸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetUid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ApplyFriendItem *ui;</span><br><span class="line">    std::shared_ptr&lt;ApplyInfo&gt; _apply_info;</span><br><span class="line">    <span class="type">bool</span> _added;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_auth_friend</span><span class="params">(std::shared_ptr&lt;ApplyInfo&gt; apply_info)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下为具体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ApplyFriendItem::<span class="built_in">ApplyFriendItem</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">ListItemBase</span>(parent), _added(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ApplyFriendItem)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">SetItemType</span>(ListItemType::APPLY_FRIEND_ITEM);</span><br><span class="line">    ui-&gt;addBtn-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;hover&quot;</span>, <span class="string">&quot;press&quot;</span>);</span><br><span class="line">    ui-&gt;addBtn-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;addBtn, &amp;ClickedBtn::clicked,  [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        emit <span class="keyword">this</span>-&gt;<span class="built_in">sig_auth_friend</span>(_apply_info);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendItem::~<span class="built_in">ApplyFriendItem</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendItem::SetInfo</span><span class="params">(std::shared_ptr&lt;ApplyInfo&gt; apply_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _apply_info = apply_info;</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(_apply_info-&gt;_icon)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置图片自动缩放</span></span><br><span class="line">    ui-&gt;icon_lb-&gt;<span class="built_in">setPixmap</span>(pixmap.<span class="built_in">scaled</span>(ui-&gt;icon_lb-&gt;<span class="built_in">size</span>(), Qt::KeepAspectRatio, Qt::SmoothTransformation));</span><br><span class="line">    ui-&gt;icon_lb-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;user_name_lb-&gt;<span class="built_in">setText</span>(_apply_info-&gt;_name);</span><br><span class="line">    ui-&gt;user_chat_lb-&gt;<span class="built_in">setText</span>(_apply_info-&gt;_desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendItem::ShowAddBtn</span><span class="params">(<span class="type">bool</span> bshow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bshow) &#123;</span><br><span class="line">        ui-&gt;addBtn-&gt;<span class="built_in">show</span>();</span><br><span class="line">        ui-&gt;already_add_lb-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        _added = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;addBtn-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        ui-&gt;already_add_lb-&gt;<span class="built_in">show</span>();</span><br><span class="line">        _added = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ApplyFriendItem::GetUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _apply_info-&gt;_uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请列表类ApplyFriendList的声明如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplyFriendList</span>: <span class="keyword">public</span> QListWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ApplyFriendList</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_show_search</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ApplyFriendList::<span class="built_in">ApplyFriendList</span>(QWidget *parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(parent);</span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">    <span class="comment">// 安装事件过滤器</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>()-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ApplyFriendList::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查事件是否是鼠标悬浮进入或离开</span></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::Enter) &#123;</span><br><span class="line">            <span class="comment">// 鼠标悬浮，显示滚动条</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAsNeeded);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::Leave) &#123;</span><br><span class="line">            <span class="comment">// 鼠标离开，隐藏滚动条</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">            <span class="function">emit <span class="title">sig_show_search</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查事件是否是鼠标滚轮事件</span></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>() &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Wheel) &#123;</span><br><span class="line">        QWheelEvent *wheelEvent = <span class="built_in">static_cast</span>&lt;QWheelEvent*&gt;(event);</span><br><span class="line">        <span class="type">int</span> numDegrees = wheelEvent-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">y</span>() / <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> numSteps = numDegrees / <span class="number">15</span>; <span class="comment">// 计算滚动步数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置滚动幅度</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setValue</span>(<span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">value</span>() - numSteps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 停止事件传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QListWidget::<span class="built_in">eventFilter</span>(watched, event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在ChatDialog的stackedWidget中将friend_apply_page升级为ApplyFriendPage.</p>
<p>这样我们启动程序就能看到联系人列表和申请列表了。</p>
<p>下一步还需要写QSS美化以下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#con_user_list</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">247</span>,<span class="number">247</span>,<span class="number">248</span>);</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#con_user_list</span>::item:selected &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#d3d7d4</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#con_user_list</span>::item:hover &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">206</span>,<span class="number">207</span>,<span class="number">208</span>);</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#con_user_list</span>::focus &#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#GroupTipItem</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eaeaea</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#GroupTipItem</span> QLabel&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2e2f30</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>; <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>; <span class="comment">/* 设置字体 */</span></span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#new_friend_item</span> &#123;</span><br><span class="line">     <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#LineItem</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">247</span>,<span class="number">247</span>,<span class="number">247</span>);</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#friend_apply_lb</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#friend_apply_wid</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f1f2f3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ede9e7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#apply_friend_list</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f1f2f3</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#ede9e7</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">    <span class="attribute">border-right</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendItem &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f1f2f3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#dbd9d9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendItem <span class="selector-id">#user_chat_lb</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a2a2a2</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>; <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>; <span class="comment">/* 设置字体 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendItem <span class="selector-id">#addBtn</span><span class="selector-attr">[state=<span class="string">&#x27;normal&#x27;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#d3d7d4</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2cb46e</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>; <span class="comment">/* 设置字体 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>; <span class="comment">/* 设置圆角 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendItem <span class="selector-id">#addBtn</span><span class="selector-attr">[state=<span class="string">&#x27;hover&#x27;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#D3D3D3</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2cb46e</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>; <span class="comment">/* 设置字体 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>; <span class="comment">/* 设置圆角 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplyFriendItem <span class="selector-id">#addBtn</span><span class="selector-attr">[state=<span class="string">&#x27;press&#x27;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#BEBEBE</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2cb46e</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>; <span class="comment">/* 设置字体 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>; <span class="comment">/* 设置圆角 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#already_add_lb</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">153</span>,<span class="number">153</span>,<span class="number">153</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#user_name_lb</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码连接"><a href="#源码连接" class="headerlink" title="源码连接"></a>源码连接</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/llfcchat">https://gitee.com/secondtonone1/llfcchat</a> </p>
<h2 id="视频连接"><a href="#视频连接" class="headerlink" title="视频连接"></a>视频连接</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SS42197Yo/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9">https://www.bilibili.com/video/BV1SS42197Yo/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/08/31/cpppro9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/31/cpppro9/" itemprop="url">C++ 全栈聊天项目(9) nodejs实现邮箱验证服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-31T09:30:35+08:00">
                2024-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpppro/" itemprop="url" rel="index">
                    <span itemprop="name">C++聊天项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="邮箱验证服务联调"><a href="#邮箱验证服务联调" class="headerlink" title="邮箱验证服务联调"></a>邮箱验证服务联调</h2><p>我们启动GateServer和VarifyServer</p>
<p>我们启动客户端，点击注册按钮进入注册界面，输入邮箱并且点击获取验证码</p>
<p><img src="https://cdn.llfc.club/1710646053282.jpg" alt="https://cdn.llfc.club/1710646053282.jpg"></p>
<p>GateServer收到Client发送的请求后，会调用grpc 服务 访问VarifyServer，VarifyServer会随机生成验证码，并且调用邮箱模块发送邮件给指定邮箱。而且把发送的结果给GateServer，GateServer再将消息回传给客户端。</p>
<h2 id="设置验证码过期"><a href="#设置验证码过期" class="headerlink" title="设置验证码过期"></a>设置验证码过期</h2><p>我们的验证码是要设置过期的，可以用redis管理过期的验证码自动删除，key为邮箱，value为验证码，过期时间为3min。</p>
<h2 id="windows-安装redis服务"><a href="#windows-安装redis服务" class="headerlink" title="windows 安装redis服务"></a>windows 安装redis服务</h2><p>windows 版本下载地址:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>下载速度慢可以去我的网盘</p>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1v_foHZLvBeJQMePSGnp4Ow?pwd=yid3">https://pan.baidu.com/s/1v_foHZLvBeJQMePSGnp4Ow?pwd=yid3</a> 提取码: yid3 </p>
<p>下载完成后解压</p>
<p><img src="https://cdn.llfc.club/1710649614458.jpg" alt="https://cdn.llfc.club/1710649614458.jpg"></p>
<p>修改redis.windows.conf, 并且修改端口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">6380</span></span><br></pre></td></tr></table></figure>
<p>找到requirepass foobared，下面添加requirepass</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># requirepass foobared</span></span><br><span class="line">requirepass <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>启动redis 服务器<code> .\redis-server.exe .\redis.windows.conf</code></p>
<p><img src="https://cdn.llfc.club/1710649945760.jpg" alt="https://cdn.llfc.club/1710649945760.jpg"></p>
<p>启动客户端 <code>.\redis-cli.exe -p 6380</code>, 输入密码登录成功</p>
<p><img src="https://cdn.llfc.club/1710650063208.jpg" alt="https://cdn.llfc.club/1710650063208.jpg"></p>
<h2 id="Linux-安装redis服务"><a href="#Linux-安装redis服务" class="headerlink" title="Linux 安装redis服务"></a>Linux 安装redis服务</h2><p>Linux安装容器后，直接用容器启动redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name llfc-redis -p 6380:6379 redis  --requirepass <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了方便测试能否链接以及以后查看数据,大家可以下载redis desktop manager</p>
<p>官网链接<br><a href="redisdesktop.com/">redisdesktop.com/</a></p>
<p>下载速度慢可以去我的网盘</p>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1v_foHZLvBeJQMePSGnp4Ow?pwd=yid3">https://pan.baidu.com/s/1v_foHZLvBeJQMePSGnp4Ow?pwd=yid3</a> 提取码: yid3 </p>
<p>下载后安装</p>
<p>设置好ip和密码，点击测试连接连通就成功了</p>
<p><img src="https://cdn.llfc.club/1710657223612.jpg" alt="https://cdn.llfc.club/1710657223612.jpg"></p>
<h2 id="widows编译和配置redis"><a href="#widows编译和配置redis" class="headerlink" title="widows编译和配置redis"></a>widows编译和配置redis</h2><p>Linux的redis库直接编译安装即可，windows反而麻烦一些，我们先阐述windows环境如何配置redis库， C++ 的redis库有很多种，最常用的有hredis和redis-plus-plus. 我们用redis-plus-plus. 这里介绍一种简单的安装方式—vcpkg</p>
<p>先安装vcpkg, 源码地址</p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/vcpkg/releases">https://github.com/microsoft/vcpkg/releases</a></p>
<p>下载源码后</p>
<p>windows版本redis下载地址</p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis">https://github.com/microsoftarchive/redis</a></p>
<p>因为是源码，所以进入msvc目录</p>
<p><img src="https://cdn.llfc.club/1710725726234.jpg" alt="https://cdn.llfc.club/1710725726234.jpg"></p>
<p>用visual studio打开sln文件，弹出升级窗口, 我的是vs2019所以升级到142</p>
<p><img src="https://cdn.llfc.club/1710725937787.jpg" alt="https://cdn.llfc.club/1710725937787.jpg"></p>
<p>只需要生成hiredis工程和Win32_Interop工程即可，分别点击生成,生成hiredis.lib和Win32_Interop.lib即可</p>
<p>右键两个工程的属性，代码生成里选择运行时库加载模式为MDD(Debug模式动态运行加载)，为了兼容我们其他的库，其他的库也是MDD模式</p>
<p><img src="https://cdn.llfc.club/1710726777016.jpg" alt="https://cdn.llfc.club/1710726777016.jpg"></p>
<p>编译Win32_Interop.lib时报错， system_error不是std成员，</p>
<p><img src="https://cdn.llfc.club/1710727129177.jpg" alt="https://cdn.llfc.club/1710727129177.jpg"></p>
<p>解决办法为在Win32_variadicFunctor.cpp和Win32_FDAPI.cpp添加<br><code>#include &lt;system_error&gt;</code>,再右键生成成功</p>
<p><img src="https://cdn.llfc.club/1710729372811.jpg" alt="https://cdn.llfc.club/1710729372811.jpg"></p>
<p>将hiredis.lib和Win32_Interop.lib拷贝到<code>D:\cppsoft\reids\lib</code></p>
<p>将<code>redis-3.0\deps</code>和<code>redis-3.0\src</code>文件夹拷贝到<code>D:\cppsoft\reids</code></p>
<p>然后我们在visual studio中配置VC++ 包含目录</p>
<p><img src="https://cdn.llfc.club/1710811823982.jpg" alt="https://cdn.llfc.club/1710811823982.jpg"></p>
<p>配置VC++库目录</p>
<p><img src="https://cdn.llfc.club/1710811986563.jpg" alt="https://cdn.llfc.club/1710811986563.jpg"></p>
<p>然后在链接器-&gt;输入-&gt;附加依赖项中添加</p>
<p><img src="https://cdn.llfc.club/1710812099185.jpg" alt="https://cdn.llfc.club/1710812099185.jpg"></p>
<h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>我们需要写代码测试库配置的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//连接redis 需要启动才可以进行连接</span></span><br><span class="line"><span class="comment">//redis默认监听端口为6387 可以再配置文件中修改</span></span><br><span class="line">	redisContext* c = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">	<span class="keyword">if</span> (c-&gt;err)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Connect to redisServer faile:%s\n&quot;</span>, c-&gt;errstr);</span><br><span class="line">		<span class="built_in">redisFree</span>(c);        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Connect to redisServer Success\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	std::string redis_password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">	redisReply* r = (redisReply*)<span class="built_in">redisCommand</span>(c, <span class="string">&quot;AUTH %s&quot;</span>, redis_password);</span><br><span class="line">	 <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;Redis认证失败！\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Redis认证成功！\n&quot;</span>);</span><br><span class="line">		 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为redis设置key</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* command1 = <span class="string">&quot;set stest1 value1&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行redis命令行</span></span><br><span class="line">    r = (redisReply*)<span class="built_in">redisCommand</span>(c, command1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果返回NULL则说明执行失败</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Execut command1 failure\n&quot;</span>);</span><br><span class="line">		<span class="built_in">redisFree</span>(c);        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果执行失败则释放连接</span></span><br><span class="line">	<span class="keyword">if</span> (!(r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; (<span class="built_in">strcmp</span>(r-&gt;str, <span class="string">&quot;OK&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(r-&gt;str, <span class="string">&quot;ok&quot;</span>) == <span class="number">0</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to execute command[%s]\n&quot;</span>, command1);</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">		<span class="built_in">redisFree</span>(c);        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行成功 释放redisCommand执行后返回的redisReply所占用的内存</span></span><br><span class="line">	<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Succeed to execute command[%s]\n&quot;</span>, command1);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* command2 = <span class="string">&quot;strlen stest1&quot;</span>;</span><br><span class="line">	r = (redisReply*)<span class="built_in">redisCommand</span>(c, command2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果返回类型不是整形 则释放连接</span></span><br><span class="line">	<span class="keyword">if</span> (r-&gt;type != REDIS_REPLY_INTEGER)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to execute command[%s]\n&quot;</span>, command2);</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">		<span class="built_in">redisFree</span>(c);        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取字符串长度</span></span><br><span class="line">	<span class="type">int</span> length = r-&gt;integer;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The length of &#x27;stest1&#x27; is %d.\n&quot;</span>, length);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Succeed to execute command[%s]\n&quot;</span>, command2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取redis键值对信息</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* command3 = <span class="string">&quot;get stest1&quot;</span>;</span><br><span class="line">	r = (redisReply*)<span class="built_in">redisCommand</span>(c, command3);</span><br><span class="line">	<span class="keyword">if</span> (r-&gt;type != REDIS_REPLY_STRING)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to execute command[%s]\n&quot;</span>, command3);</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">		<span class="built_in">redisFree</span>(c);        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The value of &#x27;stest1&#x27; is %s\n&quot;</span>, r-&gt;str);</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Succeed to execute command[%s]\n&quot;</span>, command3);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* command4 = <span class="string">&quot;get stest2&quot;</span>;</span><br><span class="line">	r = (redisReply*)<span class="built_in">redisCommand</span>(c, command4);</span><br><span class="line">	<span class="keyword">if</span> (r-&gt;type != REDIS_REPLY_NIL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to execute command[%s]\n&quot;</span>, command4);</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">		<span class="built_in">redisFree</span>(c);        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Succeed to execute command[%s]\n&quot;</span>, command4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放连接资源</span></span><br><span class="line">	<span class="built_in">redisFree</span>(c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中调用TestRedis，编译项目时发现编译失败，提示</p>
<p><img src="https://cdn.llfc.club/1710812579501.jpg" alt="https://cdn.llfc.club/1710812579501.jpg"></p>
<p>在同时使用Redis连接和socket连接时，遇到了Win32_Interop.lib和WS2_32.lib冲突的问题, 因为我们底层用了socket作为网络通信，也用redis，导致两个库冲突。</p>
<p>引起原因主要是Redis库Win32_FDAPI.cpp有重新定义了socket的一些方法引起来冲突</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="comment">// Unix compatible FD based routines</span></span><br><span class="line">fdapi_accept accept = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_access access = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_bind bind = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_connect connect = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_fcntl fcntl = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_fstat fdapi_fstat64 = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_fsync fsync = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_ftruncate ftruncate = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_freeaddrinfo freeaddrinfo = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_getaddrinfo getaddrinfo = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_getpeername getpeername = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_getsockname getsockname = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_getsockopt getsockopt = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_htonl htonl = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_htons htons = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_isatty isatty = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_inet_ntop inet_ntop = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_inet_pton inet_pton = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_listen listen = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_lseek64 lseek64 = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_ntohl ntohl = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_ntohs ntohs = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_open open = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_pipe pipe = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_poll poll = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_read read = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_select select = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_setsockopt setsockopt = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_socket socket = <span class="literal">NULL</span>;</span><br><span class="line">fdapi_write write = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f_WSACleanup = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSACleanup&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSAFDIsSet = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, fd_set*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;__WSAFDIsSet&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSAGetLastError = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSAGetLastError&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSAGetOverlappedResult = <span class="built_in">dllfunctor_stdcall</span>&lt;BOOL, SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSAGetOverlappedResult&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSADuplicateSocket = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, DWORD, LPWSAPROTOCOL_INFO&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSADuplicateSocketW&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSAIoctl = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPVOID, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSAIoctl&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSARecv = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSARecv&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSASocket = <span class="built_in">dllfunctor_stdcall</span>&lt;SOCKET, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, LPWSAPROTOCOL_INFO, GROUP, DWORD&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSASocketW&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSASend = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSASend&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_WSAStartup = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, WORD, LPWSADATA&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;WSAStartup&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_ioctlsocket = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">long</span>, u_long*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;ioctlsocket&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f_accept = <span class="built_in">dllfunctor_stdcall</span>&lt;SOCKET, SOCKET, <span class="keyword">struct</span> sockaddr*, <span class="type">int</span>*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_bind = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">const</span> <span class="keyword">struct</span> sockaddr*, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_closesocket = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;closesocket&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_connect = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">const</span> <span class="keyword">struct</span> sockaddr*, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_freeaddrinfo = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">void</span>, addrinfo*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;freeaddrinfo&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_getaddrinfo = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, PCSTR, PCSTR, <span class="type">const</span> ADDRINFOA*, ADDRINFOA**&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;getaddrinfo&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_gethostbyname = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="keyword">struct</span> hostent*, <span class="type">const</span> <span class="type">char</span>*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;gethostbyname&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_getpeername = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="keyword">struct</span> sockaddr*, <span class="type">int</span>*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;getpeername&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_getsockname = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="keyword">struct</span> sockaddr*, <span class="type">int</span>*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_getsockopt = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span>*, <span class="type">int</span>*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;getsockopt&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_htonl = <span class="built_in">dllfunctor_stdcall</span>&lt;u_long, u_long&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;htonl&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_htons = <span class="built_in">dllfunctor_stdcall</span>&lt;u_short, u_short&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;htons&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_listen = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_ntohs = <span class="built_in">dllfunctor_stdcall</span>&lt;u_short, u_short&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;ntohs&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_ntohl = <span class="built_in">dllfunctor_stdcall</span>&lt;u_long, u_long&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;ntohl&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_recv = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">char</span>*, <span class="type">int</span>, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;recv&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_select = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, <span class="type">int</span>, fd_set*, fd_set*, fd_set*, <span class="type">const</span> <span class="keyword">struct</span> timeval*&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;select&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_send = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_setsockopt = <span class="built_in">dllfunctor_stdcall</span>&lt;<span class="type">int</span>, SOCKET, <span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f_socket = <span class="built_in">dllfunctor_stdcall</span>&lt;SOCKET, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;(<span class="string">&quot;ws2_32.dll&quot;</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>去掉Redis库里面的socket的函数的重定义，把所有使用这些方法的地方都改为下面对应的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_accept</span><span class="params">(<span class="type">int</span> rfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_bind</span><span class="params">(<span class="type">int</span> rfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_connect</span><span class="params">(<span class="type">int</span> rfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">size_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_fcntl</span><span class="params">(<span class="type">int</span> rfd, <span class="type">int</span> cmd, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_fstat64</span><span class="params">(<span class="type">int</span> rfd, <span class="keyword">struct</span> __stat64 *buffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FDAPI_freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *ai)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_fsync</span><span class="params">(<span class="type">int</span> rfd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_ftruncate</span><span class="params">(<span class="type">int</span> rfd, PORT_LONGLONG length)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_getsockopt</span><span class="params">(<span class="type">int</span> rfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_getpeername</span><span class="params">(<span class="type">int</span> rfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> * addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_getsockname</span><span class="params">(<span class="type">int</span> rfd, <span class="keyword">struct</span> sockaddr* addrsock, <span class="type">int</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function">u_long <span class="title">FDAPI_htonl</span><span class="params">(u_long hostlong)</span></span>;</span><br><span class="line"><span class="function">u_short <span class="title">FDAPI_htons</span><span class="params">(u_short hostshort)</span></span>;</span><br><span class="line"><span class="function">u_int <span class="title">FDAPI_ntohl</span><span class="params">(u_int netlong)</span></span>;</span><br><span class="line"><span class="function">u_short <span class="title">FDAPI_ntohs</span><span class="params">(u_short netshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * _Filename, <span class="type">int</span> _OpenFlag, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_pipe</span><span class="params">(<span class="type">int</span> *pfds)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_listen</span><span class="params">(<span class="type">int</span> rfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FDAPI_setsockopt</span><span class="params">(<span class="type">int</span> rfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">FDAPI_read</span><span class="params">(<span class="type">int</span> rfd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">FDAPI_write</span><span class="params">(<span class="type">int</span> rfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>考虑大家修改起来很麻烦，可以下载我的代码</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/windows-redis">https://gitee.com/secondtonone1/windows-redis</a></p>
<p>再次编译生成hredis和Win32_Interop的lib库，重新配置下，项目再次编译就通过了。</p>
<h2 id="封装redis操作类"><a href="#封装redis操作类" class="headerlink" title="封装redis操作类"></a>封装redis操作类</h2><p>因为hredis提供的操作太别扭了，我们手动封装redis操作类，简化调用流程。</p>
<p>封装的类叫RedisMgr，它是个单例类并且可接受回调，按照我们之前的风格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedisMgr</span>: <span class="keyword">public</span> Singleton&lt;RedisMgr&gt;, </span><br><span class="line">	<span class="keyword">public</span> std::enable_shared_from_this&lt;RedisMgr&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;RedisMgr&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">RedisMgr</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">int</span> port)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(<span class="type">const</span> std::string &amp;key, std::string&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Auth</span><span class="params">(<span class="type">const</span> std::string &amp;password)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">LPush</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">LPop</span><span class="params">(<span class="type">const</span> std::string &amp;key, std::string&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">RPush</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">RPop</span><span class="params">(<span class="type">const</span> std::string&amp; key, std::string&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">HSet</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string  &amp;hkey, <span class="type">const</span> std::string &amp;value)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">HSet</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* hkey, <span class="type">const</span> <span class="type">char</span>* hvalue, <span class="type">size_t</span> hvaluelen)</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">HGet</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;hkey)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Del</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ExistsKey</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">RedisMgr</span>();</span><br><span class="line"></span><br><span class="line">	redisContext* _connect;</span><br><span class="line">	redisReply* _reply;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>连接操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::Connect</span><span class="params">(<span class="type">const</span> std::string &amp;host, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_connect = <span class="built_in">redisConnect</span>(host.<span class="built_in">c_str</span>(), port);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connect != <span class="literal">NULL</span> &amp;&amp; <span class="keyword">this</span>-&gt;_connect-&gt;err)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;connect error &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;_connect-&gt;errstr &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取key对应的value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::Get</span><span class="params">(<span class="type">const</span> std::string &amp;key, std::string&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;GET %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">	 <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;[ GET  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		 <span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply-&gt;type != REDIS_REPLY_STRING) &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;[ GET  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		 <span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 value = <span class="keyword">this</span>-&gt;_reply-&gt;str;</span><br><span class="line">	 <span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line"></span><br><span class="line">	 std::cout &lt;&lt; <span class="string">&quot;Succeed to execute command [ GET &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  ]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置key和value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::Set</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;value)</span></span>&#123;</span><br><span class="line">	<span class="comment">//执行redis命令行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;SET %s %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果返回NULL则说明执行失败</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="keyword">this</span>-&gt;_reply)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ SET &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果执行失败则释放连接</span></span><br><span class="line">	<span class="keyword">if</span> (!(<span class="keyword">this</span>-&gt;_reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; (<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;_reply-&gt;str, <span class="string">&quot;OK&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;_reply-&gt;str, <span class="string">&quot;ok&quot;</span>) == <span class="number">0</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ SET &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);     </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行成功 释放redisCommand执行后返回的redisReply所占用的内存</span></span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ SET &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>密码认证</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::Auth</span><span class="params">(<span class="type">const</span> std::string &amp;password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;AUTH %s&quot;</span>, password.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;认证失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">//执行成功 释放redisCommand执行后返回的redisReply所占用的内存</span></span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//执行成功 释放redisCommand执行后返回的redisReply所占用的内存</span></span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;认证成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左侧push</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::LPush</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;LPUSH %s %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="keyword">this</span>-&gt;_reply)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ LPUSH &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER || <span class="keyword">this</span>-&gt;_reply-&gt;integer &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ LPUSH &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ LPUSH &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左侧pop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::LPop</span><span class="params">(<span class="type">const</span> std::string &amp;key, std::string&amp; value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;LPOP %s &quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (_reply == <span class="literal">nullptr</span> || _reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ LPOP &quot;</span> &lt;&lt; key&lt;&lt;  <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	value = _reply-&gt;str;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ LPOP &quot;</span> &lt;&lt; key &lt;&lt;  <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右侧push</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::RPush</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;RPUSH %s %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="keyword">this</span>-&gt;_reply)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ RPUSH &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER || <span class="keyword">this</span>-&gt;_reply-&gt;integer &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ RPUSH &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ RPUSH &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右侧pop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::RPop</span><span class="params">(<span class="type">const</span> std::string&amp; key, std::string&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;RPOP %s &quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (_reply == <span class="literal">nullptr</span> || _reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ RPOP &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	value = _reply-&gt;str;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ RPOP &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HSet操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::HSet</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;hkey, <span class="type">const</span> std::string &amp;value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;HSET %s %s %s&quot;</span>, key.<span class="built_in">c_str</span>(), hkey.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (_reply == <span class="literal">nullptr</span> || _reply-&gt;type != REDIS_REPLY_INTEGER ) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ HSet &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; hkey &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ HSet &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; hkey &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::HSet</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* hkey, <span class="type">const</span> <span class="type">char</span>* hvalue, <span class="type">size_t</span> hvaluelen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>* argv[<span class="number">4</span>];</span><br><span class="line">	 <span class="type">size_t</span> argvlen[<span class="number">4</span>];</span><br><span class="line">	 argv[<span class="number">0</span>] = <span class="string">&quot;HSET&quot;</span>;</span><br><span class="line">	argvlen[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	argv[<span class="number">1</span>] = key;</span><br><span class="line">	argvlen[<span class="number">1</span>] = <span class="built_in">strlen</span>(key);</span><br><span class="line">	argv[<span class="number">2</span>] = hkey;</span><br><span class="line">	argvlen[<span class="number">2</span>] = <span class="built_in">strlen</span>(hkey);</span><br><span class="line">	argv[<span class="number">3</span>] = hvalue;</span><br><span class="line">	argvlen[<span class="number">3</span>] = hvaluelen;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommandArgv</span>(<span class="keyword">this</span>-&gt;_connect, <span class="number">4</span>, argv, argvlen);</span><br><span class="line">	<span class="keyword">if</span> (_reply == <span class="literal">nullptr</span> || _reply-&gt;type != REDIS_REPLY_INTEGER) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ HSet &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; hkey &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; hvalue &lt;&lt; <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ HSet &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; hkey &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; hvalue &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HGet操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">RedisMgr::HGet</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;hkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* argv[<span class="number">3</span>];</span><br><span class="line">	<span class="type">size_t</span> argvlen[<span class="number">3</span>];</span><br><span class="line">	argv[<span class="number">0</span>] = <span class="string">&quot;HGET&quot;</span>;</span><br><span class="line">	argvlen[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	argv[<span class="number">1</span>] = key.<span class="built_in">c_str</span>();</span><br><span class="line">	argvlen[<span class="number">1</span>] = key.<span class="built_in">length</span>();</span><br><span class="line">	argv[<span class="number">2</span>] = hkey.<span class="built_in">c_str</span>();</span><br><span class="line">	argvlen[<span class="number">2</span>] = hkey.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommandArgv</span>(<span class="keyword">this</span>-&gt;_connect, <span class="number">3</span>, argv, argvlen);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply == <span class="literal">nullptr</span> || <span class="keyword">this</span>-&gt;_reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ HGet &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; hkey &lt;&lt;<span class="string">&quot;  ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::string value = <span class="keyword">this</span>-&gt;_reply-&gt;str;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ HGet &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hkey &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Del 操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::Del</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;DEL %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply == <span class="literal">nullptr</span> || <span class="keyword">this</span>-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Execut command [ Del &quot;</span> &lt;&lt; key &lt;&lt;  <span class="string">&quot; ] failure ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Execut command [ Del &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] success ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	 <span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断键值是否存在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::ExistsKey</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_reply = (redisReply*)<span class="built_in">redisCommand</span>(<span class="keyword">this</span>-&gt;_connect, <span class="string">&quot;exists %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_reply == <span class="literal">nullptr</span> || <span class="keyword">this</span>-&gt;_reply-&gt;type != REDIS_REPLY_INTEGER || <span class="keyword">this</span>-&gt;_reply-&gt;integer == <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Not Found [ Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ]  ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; Found [ Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] exists ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">freeReplyObject</span>(<span class="keyword">this</span>-&gt;_reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RedisMgr::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">redisFree</span>(_connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestRedisMgr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Auth</span>(<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Set</span>(<span class="string">&quot;blogwebsite&quot;</span>,<span class="string">&quot;llfc.club&quot;</span>));</span><br><span class="line">	std::string value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(<span class="string">&quot;blogwebsite&quot;</span>, value) );</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(<span class="string">&quot;nonekey&quot;</span>, value) == <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HSet</span>(<span class="string">&quot;bloginfo&quot;</span>,<span class="string">&quot;blogwebsite&quot;</span>, <span class="string">&quot;llfc.club&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HGet</span>(<span class="string">&quot;bloginfo&quot;</span>,<span class="string">&quot;blogwebsite&quot;</span>) != <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ExistsKey</span>(<span class="string">&quot;bloginfo&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Del</span>(<span class="string">&quot;bloginfo&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Del</span>(<span class="string">&quot;bloginfo&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ExistsKey</span>(<span class="string">&quot;bloginfo&quot;</span>) == <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">LPush</span>(<span class="string">&quot;lpushkey1&quot;</span>, <span class="string">&quot;lpushvalue1&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">LPush</span>(<span class="string">&quot;lpushkey1&quot;</span>, <span class="string">&quot;lpushvalue2&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">LPush</span>(<span class="string">&quot;lpushkey1&quot;</span>, <span class="string">&quot;lpushvalue3&quot;</span>));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">RPop</span>(<span class="string">&quot;lpushkey1&quot;</span>, value));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">RPop</span>(<span class="string">&quot;lpushkey1&quot;</span>, value));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">LPop</span>(<span class="string">&quot;lpushkey1&quot;</span>, value));</span><br><span class="line">	<span class="built_in">assert</span>(RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">LPop</span>(<span class="string">&quot;lpushkey2&quot;</span>, value)==<span class="literal">false</span>);</span><br><span class="line">	RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装redis连接池"><a href="#封装redis连接池" class="headerlink" title="封装redis连接池"></a>封装redis连接池</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedisConPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RedisConPool</span>(<span class="type">size_t</span> poolSize, <span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* pwd)</span><br><span class="line">		: <span class="built_in">poolSize_</span>(poolSize), <span class="built_in">host_</span>(host), <span class="built_in">port_</span>(port), <span class="built_in">b_stop_</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; poolSize_; ++i) &#123;</span><br><span class="line">			<span class="keyword">auto</span>* context = <span class="built_in">redisConnect</span>(host, port);</span><br><span class="line">			<span class="keyword">if</span> (context == <span class="literal">nullptr</span> || context-&gt;err != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (context != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="built_in">redisFree</span>(context);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;AUTH %s&quot;</span>, pwd);</span><br><span class="line">			<span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;认证失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				<span class="comment">//执行成功 释放redisCommand执行后返回的redisReply所占用的内存</span></span><br><span class="line">				<span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//执行成功 释放redisCommand执行后返回的redisReply所占用的内存</span></span><br><span class="line">			<span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;认证成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			connections_.<span class="built_in">push</span>(context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">RedisConPool</span>() &#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!connections_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			connections_.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">redisContext* <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; </span><br><span class="line">			<span class="keyword">if</span> (b_stop_) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> !connections_.<span class="built_in">empty</span>(); </span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="comment">//如果停止则直接返回空指针</span></span><br><span class="line">		<span class="keyword">if</span> (b_stop_) &#123;</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span>* context = connections_.<span class="built_in">front</span>();</span><br><span class="line">		connections_.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">returnConnection</span><span class="params">(redisContext* context)</span> </span>&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (b_stop_) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		connections_.<span class="built_in">push</span>(context);</span><br><span class="line">		cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		b_stop_ = <span class="literal">true</span>;</span><br><span class="line">		cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	atomic&lt;<span class="type">bool</span>&gt; b_stop_;</span><br><span class="line">	<span class="type">size_t</span> poolSize_;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* host_;</span><br><span class="line">	<span class="type">int</span> port_;</span><br><span class="line">	std::queue&lt;redisContext*&gt; connections_;</span><br><span class="line">	std::mutex mutex_;</span><br><span class="line">	std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RedisMgr构造函数中初始化pool连接池</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RedisMgr::<span class="built_in">RedisMgr</span>() &#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; gCfgMgr = ConfigMgr::<span class="built_in">Inst</span>();</span><br><span class="line">	<span class="keyword">auto</span> host = gCfgMgr[<span class="string">&quot;Redis&quot;</span>][<span class="string">&quot;Host&quot;</span>];</span><br><span class="line">	<span class="keyword">auto</span> port = gCfgMgr[<span class="string">&quot;Redis&quot;</span>][<span class="string">&quot;Port&quot;</span>];</span><br><span class="line">	<span class="keyword">auto</span> pwd = gCfgMgr[<span class="string">&quot;Redis&quot;</span>][<span class="string">&quot;Passwd&quot;</span>];</span><br><span class="line">	_con_pool.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RedisConPool</span>(<span class="number">5</span>, host.<span class="built_in">c_str</span>(), <span class="built_in">atoi</span>(port.<span class="built_in">c_str</span>()), pwd.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在析构函数中回收资源</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RedisMgr::~<span class="built_in">RedisMgr</span>() &#123;</span><br><span class="line">	<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RedisMgr::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_con_pool-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候改为从Pool中获取链接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RedisMgr::Get</span><span class="params">(<span class="type">const</span> std::string&amp; key, std::string&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> connect = _con_pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">	<span class="keyword">if</span> (connect == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">auto</span> reply = (redisReply*)<span class="built_in">redisCommand</span>(connect, <span class="string">&quot;GET %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">	 <span class="keyword">if</span> (reply == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;[ GET  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		 <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">		 _con_pool-&gt;<span class="built_in">returnConnection</span>(connect);</span><br><span class="line">		  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">if</span> (reply-&gt;type != REDIS_REPLY_STRING) &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;[ GET  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; ] failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		 <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">		 _con_pool-&gt;<span class="built_in">returnConnection</span>(connect);</span><br><span class="line">		 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 value = reply-&gt;str;</span><br><span class="line">	 <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line"></span><br><span class="line">	 std::cout &lt;&lt; <span class="string">&quot;Succeed to execute command [ GET &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;  ]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	 _con_pool-&gt;<span class="built_in">returnConnection</span>(connect);</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节告诉大家如何搭建redis服务，linux和windows环境的，并且编译了windows版本的hredis库，解决了链接错误，而且封装了RedisMgr管理类。<br>并实现了测试用例，大家感兴趣可以测试一下。下一节实现VarifyServer访问的redis功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/08/31/cpppro28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/31/cpppro28/" itemprop="url">聊天项目(28) 分布式服务通知好友申请</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-31T09:30:35+08:00">
                2024-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpppro/" itemprop="url" rel="index">
                    <span itemprop="name">C++聊天项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍如何实现用户查找和好友申请功能。查找和申请好友会涉及前后端通信和rpc服务间调用。所以目前先从客户端入手，搜索用户后发送查找好友申请请求给服务器，服务器收到后判断是否存在，如果不存在则显示未找到，如果存在则显示查找到的结果</p>
<h2 id="点击查询"><a href="#点击查询" class="headerlink" title="点击查询"></a>点击查询</h2><p>客户端点击搜索列表的添加好友item后，先弹出一个模态对话框，上面有loading动作表示加载，直到服务器返回结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchList::slot_item_clicked</span><span class="params">(QListWidgetItem *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QWidget *widget = <span class="keyword">this</span>-&gt;<span class="built_in">itemWidget</span>(item); <span class="comment">//获取自定义widget对象</span></span><br><span class="line">    <span class="keyword">if</span>(!widget)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;slot item clicked widget is nullptr&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对自定义widget进行操作， 将item 转化为基类ListItemBase</span></span><br><span class="line">    ListItemBase *customItem = <span class="built_in">qobject_cast</span>&lt;ListItemBase*&gt;(widget);</span><br><span class="line">    <span class="keyword">if</span>(!customItem)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;slot item clicked widget is nullptr&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> itemType = customItem-&gt;<span class="built_in">GetItemType</span>();</span><br><span class="line">    <span class="keyword">if</span>(itemType == ListItemType::INVALID_ITEM)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;slot invalid item clicked &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(itemType == ListItemType::ADD_USER_TIP_ITEM)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_send_pending)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!_search_edit) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">waitPending</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">auto</span> search_edit = <span class="built_in">dynamic_cast</span>&lt;CustomizeEdit*&gt;(_search_edit);</span><br><span class="line">        <span class="keyword">auto</span> uid_str = search_edit-&gt;<span class="built_in">text</span>();</span><br><span class="line">        QJsonObject jsonObj;</span><br><span class="line">        jsonObj[<span class="string">&quot;uid&quot;</span>] = uid_str;</span><br><span class="line"></span><br><span class="line">        <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(jsonObj)</span></span>;</span><br><span class="line">        QByteArray jsonData = doc.<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line">        <span class="function">emit <span class="title">TcpMgr::GetInstance</span><span class="params">()</span>-&gt;<span class="title">sig_send_data</span><span class="params">(ReqId::ID_SEARCH_USER_REQ,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  jsonData)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清楚弹出框</span></span><br><span class="line">    <span class="built_in">CloseFindDlg</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_send_pending为新增的成员变量，如果为true则表示发送阻塞.构造函数中将其设置为false。</p>
<p>waitPending函数为根据pending状态展示加载框</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchList::waitPending</span><span class="params">(<span class="type">bool</span> pending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pending)&#123;</span><br><span class="line">        _loadingDialog = <span class="keyword">new</span> <span class="built_in">LoadingDlg</span>(<span class="keyword">this</span>);</span><br><span class="line">        _loadingDialog-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>);</span><br><span class="line">        _loadingDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">        _send_pending = pending;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _loadingDialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        _loadingDialog-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">        _send_pending = pending;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们发送数据后服务器会处理，返回ID_SEARCH_USER_RSP包，所以客户端要实现对ID_SEARCH_USER_RSP包的处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_SEARCH_USER_RSP, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data)&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;handle id is &quot;</span>&lt;&lt; id &lt;&lt; <span class="string">&quot; data is &quot;</span> &lt;&lt; data;</span><br><span class="line">    <span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(jsonDoc.<span class="built_in">isNull</span>())&#123;</span><br><span class="line">       <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>))&#123;</span><br><span class="line">        <span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Login Failed, err is Json Parse Err&quot;</span> &lt;&lt; err ;</span><br><span class="line">        emit <span class="built_in">sig_login_failed</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span>(err != ErrorCodes::SUCCESS)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Login Failed, err is &quot;</span> &lt;&lt; err ;</span><br><span class="line">        emit <span class="built_in">sig_login_failed</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> search_info = std::<span class="built_in">make_shared</span>&lt;SearchInfo&gt;(jsonObj[<span class="string">&quot;uid&quot;</span>].<span class="built_in">toInt</span>(),</span><br><span class="line">          jsonObj[<span class="string">&quot;name&quot;</span>].<span class="built_in">toString</span>(), jsonObj[<span class="string">&quot;nick&quot;</span>].<span class="built_in">toString</span>(),</span><br><span class="line">          jsonObj[<span class="string">&quot;desc&quot;</span>].<span class="built_in">toString</span>(), jsonObj[<span class="string">&quot;sex&quot;</span>].<span class="built_in">toInt</span>(), jsonObj[<span class="string">&quot;icon&quot;</span>].<span class="built_in">toString</span>());</span><br><span class="line"></span><br><span class="line">   emit <span class="built_in">sig_user_search</span>(search_info);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将搜索到的结果封装为search_info发送给SearchList类做展示, search_list中连接信号和槽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接搜索条目</span></span><br><span class="line"><span class="built_in">connect</span>(TcpMgr::<span class="built_in">GetInstance</span>().<span class="built_in">get</span>(), &amp;TcpMgr::sig_user_search, <span class="keyword">this</span>, &amp;SearchList::slot_user_search);</span><br></pre></td></tr></table></figure>
<p>slot_user_search槽函数弹出搜索结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchList::slot_user_search</span><span class="params">(std::shared_ptr&lt;SearchInfo&gt; si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">waitPending</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(si == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _find_dlg = std::<span class="built_in">make_shared</span>&lt;FindFailDlg&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//此处分两种情况，一种是搜多到已经是自己的朋友了，一种是未添加好友</span></span><br><span class="line">        <span class="comment">//查找是否已经是好友 todo...</span></span><br><span class="line">        _find_dlg = std::<span class="built_in">make_shared</span>&lt;FindSuccessDlg&gt;(<span class="keyword">this</span>);</span><br><span class="line">        std::<span class="built_in">dynamic_pointer_cast</span>&lt;FindSuccessDlg&gt;(_find_dlg)-&gt;<span class="built_in">SetSearchInfo</span>(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _find_dlg-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FindSuccessDlg是找到的结果展示，FindFailDlg是未找到结果展示。以下为FindSuccessDlg的ui布局</p>
<p><img src="https://cdn.llfc.club/1722655438089.jpg" alt="https://cdn.llfc.club/1722655438089.jpg"></p>
<p>具体声明如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FindSuccessDlg</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FindSuccessDlg</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">FindSuccessDlg</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetSearchInfo</span><span class="params">(std::shared_ptr&lt;SearchInfo&gt; si)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::FindSuccessDlg *ui;</span><br><span class="line">    std::shared_ptr&lt;SearchInfo&gt; _si;</span><br><span class="line">    QWidget * _parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_add_friend_btn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">FindSuccessDlg::<span class="built_in">FindSuccessDlg</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QDialog</span>(parent), _parent(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::FindSuccessDlg)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置对话框标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;添加&quot;</span>);</span><br><span class="line">    <span class="comment">// 隐藏对话框标题栏</span></span><br><span class="line">    <span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() | Qt::FramelessWindowHint);</span><br><span class="line">    <span class="comment">// 获取当前应用程序的路径</span></span><br><span class="line">    QString app_path = QCoreApplication::<span class="built_in">applicationDirPath</span>();</span><br><span class="line">    QString pix_path = QDir::<span class="built_in">toNativeSeparators</span>(app_path +</span><br><span class="line">                             QDir::<span class="built_in">separator</span>() + <span class="string">&quot;static&quot;</span>+QDir::<span class="built_in">separator</span>()+<span class="string">&quot;head_1.jpg&quot;</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">head_pix</span><span class="params">(pix_path)</span></span>;</span><br><span class="line">    head_pix = head_pix.<span class="built_in">scaled</span>(ui-&gt;head_lb-&gt;<span class="built_in">size</span>(),</span><br><span class="line">            Qt::KeepAspectRatio, Qt::SmoothTransformation);</span><br><span class="line">    ui-&gt;head_lb-&gt;<span class="built_in">setPixmap</span>(head_pix);</span><br><span class="line">    ui-&gt;add_friend_btn-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;hover&quot;</span>,<span class="string">&quot;press&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FindSuccessDlg::~<span class="built_in">FindSuccessDlg</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;FindSuccessDlg destruct&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindSuccessDlg::SetSearchInfo</span><span class="params">(std::shared_ptr&lt;SearchInfo&gt; si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;name_lb-&gt;<span class="built_in">setText</span>(si-&gt;_name);</span><br><span class="line">    _si = si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindSuccessDlg::on_add_friend_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//todo... 添加好友界面弹出</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">//弹出加好友界面</span></span><br><span class="line">    <span class="keyword">auto</span> applyFriend = <span class="keyword">new</span> <span class="built_in">ApplyFriend</span>(_parent);</span><br><span class="line">    applyFriend-&gt;<span class="built_in">SetSearchInfo</span>(_si);</span><br><span class="line">    applyFriend-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>);</span><br><span class="line">    applyFriend-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的FindFailDlg也是这种思路，大家自己实现即可。</p>
<h2 id="服务器查询逻辑"><a href="#服务器查询逻辑" class="headerlink" title="服务器查询逻辑"></a>服务器查询逻辑</h2><p>chatserver服务器要根据客户端发送过来的用户id进行查找,chatserver服务器需先注册ID_SEARCH_USER_REQ和回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_fun_callbacks[MSG_CHAT_LOGIN] = std::<span class="built_in">bind</span>(&amp;LogicSystem::LoginHandler, <span class="keyword">this</span>,</span><br><span class="line">		placeholders::_1, placeholders::_2, placeholders::_3);</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_SEARCH_USER_REQ] = std::<span class="built_in">bind</span>(&amp;LogicSystem::SearchInfo, <span class="keyword">this</span>,</span><br><span class="line">		placeholders::_1, placeholders::_2, placeholders::_3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SearchInfo根据用户uid查询具体信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::SearchInfo</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> string&amp; msg_data)</span> </span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">	<span class="keyword">auto</span> uid_str = root[<span class="string">&quot;uid&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;user SearchInfo uid is  &quot;</span> &lt;&lt; uid_str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Json::Value rtvalue;</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">deder</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">		session-&gt;Send(return_str, ID_SEARCH_USER_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> b_digit = <span class="built_in">isPureDigit</span>(uid_str);</span><br><span class="line">	<span class="keyword">if</span> (b_digit) &#123;</span><br><span class="line">		<span class="built_in">GetUserByUid</span>(uid_str, rtvalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">GetUserByName</span>(uid_str, rtvalue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此客户端和服务器搜索查询的联调功能已经解决了。</p>
<h2 id="客户端添加好友"><a href="#客户端添加好友" class="headerlink" title="客户端添加好友"></a>客户端添加好友</h2><p>当Client1搜索到好友后，点击添加弹出信息界面，然后点击确定即可向对方Client2申请添加好友，这个请求要先发送到Client1所在的服务器Server1，服务器收到后判断Client2所在服务器，如果Client2在Server1则直接在Server1中查找Client2的连接信息，没找到说明Client2未在内存中，找到了则通过Session发送tcp给对方。如果Client2不在Server1而在Server2上，则需要让Server1通过grpc接口通知Server2,Server2收到后继续判断Client2是否在线，如果在线则通知。</p>
<p>如下图，Client1想和Client2以及Client3分别通信，需要先将请求发给Client1所在的Server1，再考虑是否rpc调用。</p>
<p><img src="https://cdn.llfc.club/1722844689701.jpg" alt="https://cdn.llfc.club/1722844689701.jpg"></p>
<p>客户端在ApplySure槽函数中添加好友请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriend::SlotApplySure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Slot Apply Sure called&quot;</span> ;</span><br><span class="line">    QJsonObject jsonObj;</span><br><span class="line">    <span class="keyword">auto</span> uid = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetUid</span>();</span><br><span class="line">    jsonObj[<span class="string">&quot;uid&quot;</span>] = uid;</span><br><span class="line">    <span class="keyword">auto</span> name = ui-&gt;name_ed-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">if</span>(name.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        name = ui-&gt;name_ed-&gt;<span class="built_in">placeholderText</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jsonObj[<span class="string">&quot;applyname&quot;</span>] = name;</span><br><span class="line">    <span class="keyword">auto</span> bakname = ui-&gt;back_ed-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">if</span>(bakname.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">         bakname = ui-&gt;back_ed-&gt;<span class="built_in">placeholderText</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    jsonObj[<span class="string">&quot;bakname&quot;</span>] = bakname;</span><br><span class="line">    jsonObj[<span class="string">&quot;touid&quot;</span>] = _si-&gt;_uid;</span><br><span class="line"></span><br><span class="line">    <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(jsonObj)</span></span>;</span><br><span class="line">    QByteArray jsonData = doc.<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送tcp请求给chat server</span></span><br><span class="line">    <span class="function">emit <span class="title">TcpMgr::GetInstance</span><span class="params">()</span>-&gt;<span class="title">sig_send_data</span><span class="params">(ReqId::ID_ADD_FRIEND_REQ, jsonData)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">deleteLater</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个客户端会收到服务器通知添加好友的请求,所以在TcpMgr里监听这个请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_NOTIFY_ADD_FRIEND_REQ, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data) &#123;</span><br><span class="line">	<span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;handle id is &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; data is &quot;</span> &lt;&lt; data;</span><br><span class="line">	<span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">	QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查转换是否成功</span></span><br><span class="line">	<span class="keyword">if</span> (jsonDoc.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">		<span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Login Failed, err is Json Parse Err&quot;</span> &lt;&lt; err;</span><br><span class="line"></span><br><span class="line">		emit <span class="built_in">sig_user_search</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">	<span class="keyword">if</span> (err != ErrorCodes::SUCCESS) &#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Login Failed, err is &quot;</span> &lt;&lt; err;</span><br><span class="line">		emit <span class="built_in">sig_user_search</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> from_uid = jsonObj[<span class="string">&quot;applyuid&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = jsonObj[<span class="string">&quot;name&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">        QString desc = jsonObj[<span class="string">&quot;desc&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">        QString icon = jsonObj[<span class="string">&quot;icon&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">        QString nick = jsonObj[<span class="string">&quot;nick&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">        <span class="type">int</span> sex = jsonObj[<span class="string">&quot;sex&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">auto</span> apply_info = std::<span class="built_in">make_shared</span>&lt;AddFriendApply&gt;(</span><br><span class="line">                   from_uid, name, desc,</span><br><span class="line">                     icon, nick, sex);</span><br><span class="line"></span><br><span class="line">	emit <span class="built_in">sig_friend_apply</span>(apply_info);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>服务器要处理客户端发过来的添加好友的请求，并决定是否调用rpc通知其他服务。</p>
<p>先将AddFriendApply函数注册到回调map里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::RegisterCallBacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_fun_callbacks[MSG_CHAT_LOGIN] = std::<span class="built_in">bind</span>(&amp;LogicSystem::LoginHandler, <span class="keyword">this</span>,</span><br><span class="line">		placeholders::_1, placeholders::_2, placeholders::_3);</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_SEARCH_USER_REQ] = std::<span class="built_in">bind</span>(&amp;LogicSystem::SearchInfo, <span class="keyword">this</span>,</span><br><span class="line">		placeholders::_1, placeholders::_2, placeholders::_3);</span><br><span class="line"></span><br><span class="line">	_fun_callbacks[ID_ADD_FRIEND_REQ] = std::<span class="built_in">bind</span>(&amp;LogicSystem::AddFriendApply, <span class="keyword">this</span>,</span><br><span class="line">		placeholders::_1, placeholders::_2, placeholders::_3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来实现AddFriendApply</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::AddFriendApply</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> string&amp; msg_data)</span> </span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">	<span class="keyword">auto</span> uid = root[<span class="string">&quot;uid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">	<span class="keyword">auto</span> applyname = root[<span class="string">&quot;applyname&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	<span class="keyword">auto</span> bakname = root[<span class="string">&quot;bakname&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	<span class="keyword">auto</span> touid = root[<span class="string">&quot;touid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;user login uid is  &quot;</span> &lt;&lt; uid &lt;&lt; <span class="string">&quot; applyname  is &quot;</span></span><br><span class="line">		&lt;&lt; applyname &lt;&lt; <span class="string">&quot; bakname is &quot;</span> &lt;&lt; bakname &lt;&lt; <span class="string">&quot; touid is &quot;</span> &lt;&lt; touid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">		session-&gt;Send(return_str, ID_ADD_FRIEND_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先更新数据库</span></span><br><span class="line">	MysqlMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AddFriendApply</span>(uid, touid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查询redis 查找touid对应的server ip</span></span><br><span class="line">	<span class="keyword">auto</span> to_str = std::<span class="built_in">to_string</span>(touid);</span><br><span class="line">	<span class="keyword">auto</span> to_ip_key = USERIPPREFIX + to_str;</span><br><span class="line">	std::string to_ip_value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">bool</span> b_ip = RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(to_ip_key, to_ip_value);</span><br><span class="line">	<span class="keyword">if</span> (!b_ip) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; cfg = ConfigMgr::<span class="built_in">Inst</span>();</span><br><span class="line">	<span class="keyword">auto</span> self_name = cfg[<span class="string">&quot;SelfServer&quot;</span>][<span class="string">&quot;Name&quot;</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接通知对方有申请消息</span></span><br><span class="line">	<span class="keyword">if</span> (to_ip_value == self_name) &#123;</span><br><span class="line">		<span class="keyword">auto</span> session = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetSession</span>(touid);</span><br><span class="line">		<span class="keyword">if</span> (session) &#123;</span><br><span class="line">			<span class="comment">//在内存中则直接发送通知对方</span></span><br><span class="line">			Json::Value  notify;</span><br><span class="line">			notify[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			notify[<span class="string">&quot;applyuid&quot;</span>] = uid;</span><br><span class="line">			notify[<span class="string">&quot;name&quot;</span>] = applyname;</span><br><span class="line">			notify[<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			std::string return_str = notify.<span class="built_in">toStyledString</span>();</span><br><span class="line">			session-&gt;<span class="built_in">Send</span>(return_str, ID_NOTIFY_ADD_FRIEND_REQ);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::string base_key = USER_BASE_INFO + std::<span class="built_in">to_string</span>(uid);</span><br><span class="line">	<span class="keyword">auto</span> apply_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;();</span><br><span class="line">	<span class="type">bool</span> b_info = <span class="built_in">GetBaseInfo</span>(base_key, uid, apply_info);</span><br><span class="line"></span><br><span class="line">	AddFriendReq add_req;</span><br><span class="line">	add_req.<span class="built_in">set_applyuid</span>(uid);</span><br><span class="line">	add_req.<span class="built_in">set_touid</span>(touid);</span><br><span class="line">	add_req.<span class="built_in">set_name</span>(applyname);</span><br><span class="line">	add_req.<span class="built_in">set_desc</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (b_info) &#123;</span><br><span class="line">		add_req.<span class="built_in">set_icon</span>(apply_info-&gt;icon);</span><br><span class="line">		add_req.<span class="built_in">set_sex</span>(apply_info-&gt;sex);</span><br><span class="line">		add_req.<span class="built_in">set_nick</span>(apply_info-&gt;nick);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送通知</span></span><br><span class="line">	ChatGrpcClient::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NotifyAddFriend</span>(to_ip_value, add_req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数中先更新数据库将申请写入数据库中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MysqlMgr::AddFriendApply</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; from, <span class="type">const</span> <span class="type">int</span>&amp; to)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _dao.<span class="built_in">AddFriendApply</span>(from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用dao层面的添加好友请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MysqlDao::AddFriendApply</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; from, <span class="type">const</span> <span class="type">int</span>&amp; to)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> con = pool_-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">	<span class="keyword">if</span> (con == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;con]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		pool_-&gt;returnConnection(std::move(con));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;sql::PreparedStatement&gt; <span class="title">pstmt</span><span class="params">(con-&gt;_con-&gt;prepareStatement(<span class="string">&quot;INSERT INTO friend_apply (from_uid, to_uid) values (?,?) &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;ON DUPLICATE KEY UPDATE from_uid = from_uid, to_uid = to_uid &quot;</span>))</span></span>;</span><br><span class="line">		pstmt-&gt;<span class="built_in">setInt</span>(<span class="number">1</span>, from);</span><br><span class="line">		pstmt-&gt;<span class="built_in">setInt</span>(<span class="number">2</span>, to);</span><br><span class="line">		<span class="comment">//执行更新</span></span><br><span class="line">		<span class="type">int</span> rowAffected = pstmt-&gt;<span class="built_in">executeUpdate</span>();</span><br><span class="line">		<span class="keyword">if</span> (rowAffected &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (sql::SQLException&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;SQLException: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot; (MySQL error code: &quot;</span> &lt;&lt; e.<span class="built_in">getErrorCode</span>();</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;, SQLState: &quot;</span> &lt;&lt; e.<span class="built_in">getSQLState</span>() &lt;&lt; <span class="string">&quot; )&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完成后判断要通知的对端是否在本服务器，如果在本服务器则直接通过uid查找session，判断用户是否在线，如果在线则直接通知对端。</p>
<p>如果不在本服务器，则需要通过rpc通知对端服务器。rpc的客户端这么写即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AddFriendRsp <span class="title">ChatGrpcClient::NotifyAddFriend</span><span class="params">(std::string server_ip, <span class="type">const</span> AddFriendReq&amp; req)</span> </span>&#123;</span><br><span class="line">	AddFriendRsp rsp;</span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([&amp;rsp, &amp;req]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_error(ErrorCodes::Success);</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_applyuid(req.applyuid());</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_touid(req.touid());</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> find_iter = _pools.<span class="built_in">find</span>(server_ip);</span><br><span class="line">	<span class="keyword">if</span> (find_iter == _pools.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> rsp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; pool = find_iter-&gt;second;</span><br><span class="line">	ClientContext context;</span><br><span class="line">	<span class="keyword">auto</span> stub = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">	Status status = stub-&gt;<span class="built_in">NotifyAddFriend</span>(&amp;context, req, &amp;rsp);</span><br><span class="line">	<span class="function">Defer <span class="title">defercon</span><span class="params">([&amp;stub, <span class="keyword">this</span>, &amp;pool]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		pool-&gt;returnConnection(std::move(stub));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">		rsp.<span class="built_in">set_error</span>(ErrorCodes::RPCFailed);</span><br><span class="line">		<span class="keyword">return</span> rsp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样rpc的服务端也要实现，我们先将rpc客户端和服务端的逻辑都在ChatServer1写好，然后复制给ChatServer2即可。 rpc的服务实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ChatServiceImpl::NotifyAddFriend</span><span class="params">(ServerContext* context, <span class="type">const</span> AddFriendReq* request,</span></span></span><br><span class="line"><span class="params"><span class="function">	AddFriendRsp* reply)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//查找用户是否在本服务器</span></span><br><span class="line">	<span class="keyword">auto</span> touid = request-&gt;<span class="built_in">touid</span>();</span><br><span class="line">	<span class="keyword">auto</span> session = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetSession</span>(touid);</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([request, reply]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		reply-&gt;set_error(ErrorCodes::Success);</span></span></span><br><span class="line"><span class="params"><span class="function">		reply-&gt;set_applyuid(request-&gt;applyuid());</span></span></span><br><span class="line"><span class="params"><span class="function">		reply-&gt;set_touid(request-&gt;touid());</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用户不在内存中则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (session == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Status::OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在内存中则直接发送通知对方</span></span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">	rtvalue[<span class="string">&quot;applyuid&quot;</span>] = request-&gt;<span class="built_in">applyuid</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;name&quot;</span>] = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;desc&quot;</span>] = request-&gt;<span class="built_in">desc</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;icon&quot;</span>] = request-&gt;<span class="built_in">icon</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;sex&quot;</span>] = request-&gt;<span class="built_in">sex</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;nick&quot;</span>] = request-&gt;<span class="built_in">nick</span>();</span><br><span class="line"></span><br><span class="line">	std::string return_str = rtvalue.<span class="built_in">toStyledString</span>();</span><br><span class="line"></span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(return_str, ID_NOTIFY_ADD_FRIEND_REQ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Status::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码也是判断要通知的客户端是否在内存中，如果在就通过session发送tcp请求。</p>
<p>将ChatServer1的代码拷贝给ChatServer2,重启两个服务，再启动两个客户端，一个客户端申请另一个客户端，通过查看客户端日志是能看到申请信息的。</p>
<h2 id="申请显示"><a href="#申请显示" class="headerlink" title="申请显示"></a>申请显示</h2><p>接下来被通知申请的客户端要做界面显示，我们实现被通知的客户端收到sig_friend_apply信号的处理逻辑。在ChatDialog的构造函数中连接信号和槽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接申请添加好友信号</span></span><br><span class="line">   <span class="built_in">connect</span>(TcpMgr::<span class="built_in">GetInstance</span>().<span class="built_in">get</span>(), &amp;TcpMgr::sig_friend_apply, <span class="keyword">this</span>, &amp;ChatDialog::slot_apply_friend);</span><br></pre></td></tr></table></figure>
<p>实现申请好友的槽函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatDialog::slot_apply_friend</span><span class="params">(std::shared_ptr&lt;AddFriendApply&gt; apply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;receive apply friend slot, applyuid is &quot;</span> &lt;&lt; apply-&gt;_from_uid &lt;&lt; <span class="string">&quot; name is &quot;</span></span><br><span class="line">		&lt;&lt; apply-&gt;_name &lt;&lt; <span class="string">&quot; desc is &quot;</span> &lt;&lt; apply-&gt;_desc;</span><br><span class="line"></span><br><span class="line">   <span class="type">bool</span> b_already = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AlreadyApply</span>(apply-&gt;_from_uid);</span><br><span class="line">   <span class="keyword">if</span>(b_already)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AddApplyList</span>(std::<span class="built_in">make_shared</span>&lt;ApplyInfo&gt;(apply));</span><br><span class="line">    ui-&gt;side_contact_lb-&gt;<span class="built_in">ShowRedPoint</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;con_user_list-&gt;<span class="built_in">ShowRedPoint</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;friend_apply_page-&gt;<span class="built_in">AddNewApply</span>(apply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能显示新的申请消息和红点了。具体添加一个新的申请条目到申请好友页面的逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendPage::AddNewApply</span><span class="params">(std::shared_ptr&lt;AddFriendApply&gt; apply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先模拟头像随机，以后头像资源增加资源服务器后再显示</span></span><br><span class="line">    <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">    <span class="type">int</span> head_i = randomValue % heads.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">auto</span>* apply_item = <span class="keyword">new</span> <span class="built_in">ApplyFriendItem</span>();</span><br><span class="line">    <span class="keyword">auto</span> apply_info = std::<span class="built_in">make_shared</span>&lt;ApplyInfo&gt;(apply-&gt;_from_uid,</span><br><span class="line">             apply-&gt;_name, apply-&gt;_desc,heads[head_i], apply-&gt;_name, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    apply_item-&gt;<span class="built_in">SetInfo</span>( apply_info);</span><br><span class="line">	QListWidgetItem* item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">	<span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">	item-&gt;<span class="built_in">setSizeHint</span>(apply_item-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">	item-&gt;<span class="built_in">setFlags</span>(item-&gt;<span class="built_in">flags</span>() &amp; ~Qt::ItemIsEnabled &amp; ~Qt::ItemIsSelectable);</span><br><span class="line">	ui-&gt;apply_friend_list-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>,item);</span><br><span class="line">	ui-&gt;apply_friend_list-&gt;<span class="built_in">setItemWidget</span>(item, apply_item);</span><br><span class="line">    apply_item-&gt;<span class="built_in">ShowAddBtn</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//收到审核好友信号</span></span><br><span class="line">    <span class="built_in">connect</span>(apply_item, &amp;ApplyFriendItem::sig_auth_friend, [<span class="keyword">this</span>](std::shared_ptr&lt;ApplyInfo&gt; apply_info) &#123;</span><br><span class="line">		<span class="keyword">auto</span>* authFriend = <span class="keyword">new</span> <span class="built_in">AuthenFriend</span>(<span class="keyword">this</span>);</span><br><span class="line">		authFriend-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>);</span><br><span class="line">        authFriend-&gt;<span class="built_in">SetApplyInfo</span>(apply_info);</span><br><span class="line">		authFriend-&gt;<span class="built_in">show</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试效果, 收到对方请求后如下图</p>
<p><img src="https://cdn.llfc.club/1722851642815.jpg" alt="https://cdn.llfc.club/1722851642815.jpg"></p>
<h2 id="登录加载申请"><a href="#登录加载申请" class="headerlink" title="登录加载申请"></a>登录加载申请</h2><p>当用户登录后，服务器需要将申请列表同步给客户端, 写在登录逻辑里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//从数据库获取申请列表</span></span><br><span class="line">std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt; apply_list;</span><br><span class="line"><span class="keyword">auto</span> b_apply = <span class="built_in">GetFriendApplyInfo</span>(uid,apply_list);</span><br><span class="line"><span class="keyword">if</span> (b_apply) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; apply : apply_list) &#123;</span><br><span class="line">		Json::Value obj;</span><br><span class="line">		obj[<span class="string">&quot;name&quot;</span>] = apply-&gt;_name;</span><br><span class="line">		obj[<span class="string">&quot;uid&quot;</span>] = apply-&gt;_uid;</span><br><span class="line">		obj[<span class="string">&quot;icon&quot;</span>] = apply-&gt;_icon;</span><br><span class="line">		obj[<span class="string">&quot;nick&quot;</span>] = apply-&gt;_nick;</span><br><span class="line">		obj[<span class="string">&quot;sex&quot;</span>] = apply-&gt;_sex;</span><br><span class="line">		obj[<span class="string">&quot;desc&quot;</span>] = apply-&gt;_desc;</span><br><span class="line">		obj[<span class="string">&quot;status&quot;</span>] = apply-&gt;_status;</span><br><span class="line">		rtvalue[<span class="string">&quot;apply_list&quot;</span>].<span class="built_in">append</span>(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取好友申请信息函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LogicSystem::GetFriendApplyInfo</span><span class="params">(<span class="type">int</span> to_uid, std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt; &amp;list)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从mysql获取好友申请列表</span></span><br><span class="line">	<span class="keyword">return</span> MysqlMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetApplyList</span>(to_uid, list, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dao层面实现获取申请列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MysqlMgr::GetApplyList</span><span class="params">(<span class="type">int</span> touid, </span></span></span><br><span class="line"><span class="params"><span class="function">	std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt;&amp; applyList, <span class="type">int</span> begin, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> _dao.<span class="built_in">GetApplyList</span>(touid, applyList, begin, limit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MysqlDao::GetApplyList</span><span class="params">(<span class="type">int</span> touid, std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt;&amp; applyList, <span class="type">int</span> begin, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> con = pool_-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">	<span class="keyword">if</span> (con == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;con]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		pool_-&gt;returnConnection(std::move(con));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 准备SQL语句, 根据起始id和限制条数返回列表</span></span><br><span class="line">		<span class="function">std::unique_ptr&lt;sql::PreparedStatement&gt; <span class="title">pstmt</span><span class="params">(con-&gt;_con-&gt;prepareStatement(<span class="string">&quot;select apply.from_uid, apply.status, user.name, &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="string">&quot;user.nick, user.sex from friend_apply as apply join user on apply.from_uid = user.uid where apply.to_uid = ? &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="string">&quot;and apply.id &gt; ? order by apply.id ASC LIMIT ? &quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">		pstmt-&gt;<span class="built_in">setInt</span>(<span class="number">1</span>, touid); <span class="comment">// 将uid替换为你要查询的uid</span></span><br><span class="line">		pstmt-&gt;<span class="built_in">setInt</span>(<span class="number">2</span>, begin); <span class="comment">// 起始id</span></span><br><span class="line">		pstmt-&gt;<span class="built_in">setInt</span>(<span class="number">3</span>, limit); <span class="comment">//偏移量</span></span><br><span class="line">		<span class="comment">// 执行查询</span></span><br><span class="line">		<span class="function">std::unique_ptr&lt;sql::ResultSet&gt; <span class="title">res</span><span class="params">(pstmt-&gt;executeQuery())</span></span>;</span><br><span class="line">		<span class="comment">// 遍历结果集</span></span><br><span class="line">		<span class="keyword">while</span> (res-&gt;<span class="built_in">next</span>()) &#123;	</span><br><span class="line">			<span class="keyword">auto</span> name = res-&gt;<span class="built_in">getString</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">			<span class="keyword">auto</span> uid = res-&gt;<span class="built_in">getInt</span>(<span class="string">&quot;from_uid&quot;</span>);</span><br><span class="line">			<span class="keyword">auto</span> status = res-&gt;<span class="built_in">getInt</span>(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">			<span class="keyword">auto</span> nick = res-&gt;<span class="built_in">getString</span>(<span class="string">&quot;nick&quot;</span>);</span><br><span class="line">			<span class="keyword">auto</span> sex = res-&gt;<span class="built_in">getInt</span>(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">			<span class="keyword">auto</span> apply_ptr = std::<span class="built_in">make_shared</span>&lt;ApplyInfo&gt;(uid, name, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, nick, sex, status);</span><br><span class="line">			applyList.<span class="built_in">push_back</span>(apply_ptr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (sql::SQLException&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;SQLException: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot; (MySQL error code: &quot;</span> &lt;&lt; e.<span class="built_in">getErrorCode</span>();</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;, SQLState: &quot;</span> &lt;&lt; e.<span class="built_in">getSQLState</span>() &lt;&lt; <span class="string">&quot; )&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="好友认证界面"><a href="#好友认证界面" class="headerlink" title="好友认证界面"></a>好友认证界面</h2><p>客户端需要实现好友认证界面，当点击同意对方好友申请后，弹出认证信息，点击确定后将认证同意的请求发给服务器，服务器再通知申请方，告知对方被申请人已经同意加好友了。认证界面和申请界面类似, 这个大家自己实现即可。</p>
<p><img src="https://cdn.llfc.club/1722854446243.jpg" alt="https://cdn.llfc.club/1722854446243.jpg"></p>
<p>认证界面的函数和逻辑可以照抄申请好友的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br></pre></td><td class="code"><pre><span class="line">AuthenFriend::<span class="built_in">AuthenFriend</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QDialog</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::AuthenFriend),_label_point(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 隐藏对话框标题栏</span></span><br><span class="line">    <span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() | Qt::FramelessWindowHint);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;AuthenFriend&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;lb_ed-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;搜索、添加标签&quot;</span>);</span><br><span class="line">    ui-&gt;back_ed-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;燃烧的胸毛&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_ed-&gt;<span class="built_in">SetMaxLength</span>(<span class="number">21</span>);</span><br><span class="line">    ui-&gt;lb_ed-&gt;<span class="built_in">move</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    ui-&gt;lb_ed-&gt;<span class="built_in">setFixedHeight</span>(<span class="number">20</span>);</span><br><span class="line">    ui-&gt;lb_ed-&gt;<span class="built_in">setMaxLength</span>(<span class="number">10</span>);</span><br><span class="line">    ui-&gt;input_tip_wid-&gt;<span class="built_in">hide</span>();</span><br><span class="line"></span><br><span class="line">    _tip_cur_point = <span class="built_in">QPoint</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    _tip_data = &#123; <span class="string">&quot;同学&quot;</span>,<span class="string">&quot;家人&quot;</span>,<span class="string">&quot;菜鸟教程&quot;</span>,<span class="string">&quot;C++ Primer&quot;</span>,<span class="string">&quot;Rust 程序设计&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;父与子学Python&quot;</span>,<span class="string">&quot;nodejs开发指南&quot;</span>,<span class="string">&quot;go 语言开发指南&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;游戏伙伴&quot;</span>,<span class="string">&quot;金融投资&quot;</span>,<span class="string">&quot;微信读书&quot;</span>,<span class="string">&quot;拼多多拼友&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;more_lb, &amp;ClickedOnceLabel::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::ShowMoreLabel);</span><br><span class="line">    <span class="built_in">InitTipLbs</span>();</span><br><span class="line">    <span class="comment">//链接输入标签回车事件</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;lb_ed, &amp;CustomizeEdit::returnPressed, <span class="keyword">this</span>, &amp;AuthenFriend::SlotLabelEnter);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;lb_ed, &amp;CustomizeEdit::textChanged, <span class="keyword">this</span>, &amp;AuthenFriend::SlotLabelTextChange);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;lb_ed, &amp;CustomizeEdit::editingFinished, <span class="keyword">this</span>, &amp;AuthenFriend::SlotLabelEditFinished);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;tip_lb, &amp;ClickedOnceLabel::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::SlotAddFirendLabelByClickTip);</span><br><span class="line"></span><br><span class="line">    ui-&gt;scrollArea-&gt;<span class="built_in">horizontalScrollBar</span>()-&gt;<span class="built_in">setHidden</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;scrollArea-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setHidden</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;scrollArea-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;sure_btn-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;hover&quot;</span>,<span class="string">&quot;press&quot;</span>);</span><br><span class="line">    ui-&gt;cancel_btn-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>,<span class="string">&quot;hover&quot;</span>,<span class="string">&quot;press&quot;</span>);</span><br><span class="line">    <span class="comment">//连接确认和取消按钮的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;cancel_btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::SlotApplyCancel);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;sure_btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::SlotApplySure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthenFriend::~<span class="built_in">AuthenFriend</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;AuthenFriend destruct&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::InitTipLbs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lines = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _tip_data.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>* lb = <span class="keyword">new</span> <span class="built_in">ClickedLabel</span>(ui-&gt;lb_list);</span><br><span class="line">        lb-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>, <span class="string">&quot;hover&quot;</span>, <span class="string">&quot;pressed&quot;</span>, <span class="string">&quot;selected_normal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;selected_hover&quot;</span>, <span class="string">&quot;selected_pressed&quot;</span>);</span><br><span class="line">        lb-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;tipslb&quot;</span>);</span><br><span class="line">        lb-&gt;<span class="built_in">setText</span>(_tip_data[i]);</span><br><span class="line">        <span class="built_in">connect</span>(lb, &amp;ClickedLabel::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::SlotChangeFriendLabelByTip);</span><br><span class="line"></span><br><span class="line">        <span class="function">QFontMetrics <span class="title">fontMetrics</span><span class="params">(lb-&gt;font())</span></span>; <span class="comment">// 获取QLabel控件的字体信息</span></span><br><span class="line">        <span class="type">int</span> textWidth = fontMetrics.<span class="built_in">width</span>(lb-&gt;<span class="built_in">text</span>()); <span class="comment">// 获取文本的宽度</span></span><br><span class="line">        <span class="type">int</span> textHeight = fontMetrics.<span class="built_in">height</span>(); <span class="comment">// 获取文本的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_tip_cur_point.<span class="built_in">x</span>() + textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;<span class="built_in">width</span>()) &#123;</span><br><span class="line">            lines++;</span><br><span class="line">            <span class="keyword">if</span> (lines &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> lb;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _tip_cur_point.<span class="built_in">setX</span>(tip_offset);</span><br><span class="line">            _tip_cur_point.<span class="built_in">setY</span>(_tip_cur_point.<span class="built_in">y</span>() + textHeight + <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">auto</span> next_point = _tip_cur_point;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">AddTipLbs</span>(lb, _tip_cur_point,next_point, textWidth, textHeight);</span><br><span class="line"></span><br><span class="line">       _tip_cur_point = next_point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::AddTipLbs</span><span class="params">(ClickedLabel* lb, QPoint cur_point, QPoint&amp; next_point, <span class="type">int</span> text_width, <span class="type">int</span> text_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lb-&gt;<span class="built_in">move</span>(cur_point);</span><br><span class="line">    lb-&gt;<span class="built_in">show</span>();</span><br><span class="line">    _add_labels.<span class="built_in">insert</span>(lb-&gt;<span class="built_in">text</span>(), lb);</span><br><span class="line">    _add_label_keys.<span class="built_in">push_back</span>(lb-&gt;<span class="built_in">text</span>());</span><br><span class="line">    next_point.<span class="built_in">setX</span>(lb-&gt;<span class="built_in">pos</span>().<span class="built_in">x</span>() + text_width + <span class="number">15</span>);</span><br><span class="line">    next_point.<span class="built_in">setY</span>(lb-&gt;<span class="built_in">pos</span>().<span class="built_in">y</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AuthenFriend::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == ui-&gt;scrollArea &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Enter)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;scrollArea-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setHidden</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == ui-&gt;scrollArea &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Leave)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;scrollArea-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setHidden</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SetApplyInfo</span><span class="params">(std::shared_ptr&lt;ApplyInfo&gt; apply_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _apply_info = apply_info;</span><br><span class="line">    ui-&gt;back_ed-&gt;<span class="built_in">setPlaceholderText</span>(apply_info-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::ShowMoreLabel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;receive more label clicked&quot;</span>;</span><br><span class="line">    ui-&gt;more_lb_wid-&gt;<span class="built_in">hide</span>();</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_list-&gt;<span class="built_in">setFixedWidth</span>(<span class="number">325</span>);</span><br><span class="line">    _tip_cur_point = <span class="built_in">QPoint</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">auto</span> next_point = _tip_cur_point;</span><br><span class="line">    <span class="type">int</span> textWidth;</span><br><span class="line">    <span class="type">int</span> textHeight;</span><br><span class="line">    <span class="comment">//重拍现有的label</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; added_key : _add_label_keys)&#123;</span><br><span class="line">        <span class="keyword">auto</span> added_lb = _add_labels[added_key];</span><br><span class="line"></span><br><span class="line">        <span class="function">QFontMetrics <span class="title">fontMetrics</span><span class="params">(added_lb-&gt;font())</span></span>; <span class="comment">// 获取QLabel控件的字体信息</span></span><br><span class="line">        textWidth = fontMetrics.<span class="built_in">width</span>(added_lb-&gt;<span class="built_in">text</span>()); <span class="comment">// 获取文本的宽度</span></span><br><span class="line">        textHeight = fontMetrics.<span class="built_in">height</span>(); <span class="comment">// 获取文本的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_tip_cur_point.<span class="built_in">x</span>() +textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;<span class="built_in">width</span>())&#123;</span><br><span class="line">            _tip_cur_point.<span class="built_in">setX</span>(tip_offset);</span><br><span class="line">            _tip_cur_point.<span class="built_in">setY</span>(_tip_cur_point.<span class="built_in">y</span>()+textHeight+<span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        added_lb-&gt;<span class="built_in">move</span>(_tip_cur_point);</span><br><span class="line"></span><br><span class="line">        next_point.<span class="built_in">setX</span>(added_lb-&gt;<span class="built_in">pos</span>().<span class="built_in">x</span>() + textWidth + <span class="number">15</span>);</span><br><span class="line">        next_point.<span class="built_in">setY</span>(_tip_cur_point.<span class="built_in">y</span>());</span><br><span class="line"></span><br><span class="line">        _tip_cur_point = next_point;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加未添加的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _tip_data.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = _add_labels.<span class="built_in">find</span>(_tip_data[i]);</span><br><span class="line">        <span class="keyword">if</span>(iter != _add_labels.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>* lb = <span class="keyword">new</span> <span class="built_in">ClickedLabel</span>(ui-&gt;lb_list);</span><br><span class="line">        lb-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>, <span class="string">&quot;hover&quot;</span>, <span class="string">&quot;pressed&quot;</span>, <span class="string">&quot;selected_normal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;selected_hover&quot;</span>, <span class="string">&quot;selected_pressed&quot;</span>);</span><br><span class="line">        lb-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;tipslb&quot;</span>);</span><br><span class="line">        lb-&gt;<span class="built_in">setText</span>(_tip_data[i]);</span><br><span class="line">        <span class="built_in">connect</span>(lb, &amp;ClickedLabel::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::SlotChangeFriendLabelByTip);</span><br><span class="line"></span><br><span class="line">        <span class="function">QFontMetrics <span class="title">fontMetrics</span><span class="params">(lb-&gt;font())</span></span>; <span class="comment">// 获取QLabel控件的字体信息</span></span><br><span class="line">        <span class="type">int</span> textWidth = fontMetrics.<span class="built_in">width</span>(lb-&gt;<span class="built_in">text</span>()); <span class="comment">// 获取文本的宽度</span></span><br><span class="line">        <span class="type">int</span> textHeight = fontMetrics.<span class="built_in">height</span>(); <span class="comment">// 获取文本的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_tip_cur_point.<span class="built_in">x</span>() + textWidth + tip_offset &gt; ui-&gt;lb_list-&gt;<span class="built_in">width</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            _tip_cur_point.<span class="built_in">setX</span>(tip_offset);</span><br><span class="line">            _tip_cur_point.<span class="built_in">setY</span>(_tip_cur_point.<span class="built_in">y</span>() + textHeight + <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         next_point = _tip_cur_point;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AddTipLbs</span>(lb, _tip_cur_point, next_point, textWidth, textHeight);</span><br><span class="line"></span><br><span class="line">        _tip_cur_point = next_point;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> diff_height = next_point.<span class="built_in">y</span>() + textHeight + tip_offset - ui-&gt;lb_list-&gt;<span class="built_in">height</span>();</span><br><span class="line">   ui-&gt;lb_list-&gt;<span class="built_in">setFixedHeight</span>(next_point.<span class="built_in">y</span>() + textHeight + tip_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;after resize ui-&gt;lb_list size is &quot; &lt;&lt;  ui-&gt;lb_list-&gt;size();</span></span><br><span class="line">    ui-&gt;scrollcontent-&gt;<span class="built_in">setFixedHeight</span>(ui-&gt;scrollcontent-&gt;<span class="built_in">height</span>()+diff_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::resetLabels</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> max_width = ui-&gt;gridWidget-&gt;<span class="built_in">width</span>();</span><br><span class="line">    <span class="keyword">auto</span> label_height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = _friend_labels.<span class="built_in">begin</span>(); iter != _friend_labels.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="comment">//todo... 添加宽度统计</span></span><br><span class="line">        <span class="keyword">if</span>( _label_point.<span class="built_in">x</span>() + iter.<span class="built_in">value</span>()-&gt;<span class="built_in">width</span>() &gt; max_width) &#123;</span><br><span class="line">            _label_point.<span class="built_in">setY</span>(_label_point.<span class="built_in">y</span>()+iter.<span class="built_in">value</span>()-&gt;<span class="built_in">height</span>()+<span class="number">6</span>);</span><br><span class="line">            _label_point.<span class="built_in">setX</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iter.<span class="built_in">value</span>()-&gt;<span class="built_in">move</span>(_label_point);</span><br><span class="line">        iter.<span class="built_in">value</span>()-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">        _label_point.<span class="built_in">setX</span>(_label_point.<span class="built_in">x</span>()+iter.<span class="built_in">value</span>()-&gt;<span class="built_in">width</span>()+<span class="number">2</span>);</span><br><span class="line">        _label_point.<span class="built_in">setY</span>(_label_point.<span class="built_in">y</span>());</span><br><span class="line">        label_height = iter.<span class="built_in">value</span>()-&gt;<span class="built_in">height</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_friend_labels.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">         ui-&gt;lb_ed-&gt;<span class="built_in">move</span>(_label_point);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_label_point.<span class="built_in">x</span>() + MIN_APPLY_LABEL_ED_LEN &gt; ui-&gt;gridWidget-&gt;<span class="built_in">width</span>())&#123;</span><br><span class="line">        ui-&gt;lb_ed-&gt;<span class="built_in">move</span>(<span class="number">2</span>,_label_point.<span class="built_in">y</span>()+label_height+<span class="number">6</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         ui-&gt;lb_ed-&gt;<span class="built_in">move</span>(_label_point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::addLabel</span><span class="params">(QString name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_friend_labels.<span class="built_in">find</span>(name) != _friend_labels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tmplabel = <span class="keyword">new</span> <span class="built_in">FriendLabel</span>(ui-&gt;gridWidget);</span><br><span class="line">    tmplabel-&gt;<span class="built_in">SetText</span>(name);</span><br><span class="line">    tmplabel-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;FriendLabel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> max_width = ui-&gt;gridWidget-&gt;<span class="built_in">width</span>();</span><br><span class="line">    <span class="comment">//todo... 添加宽度统计</span></span><br><span class="line">    <span class="keyword">if</span> (_label_point.<span class="built_in">x</span>() + tmplabel-&gt;<span class="built_in">width</span>() &gt; max_width) &#123;</span><br><span class="line">        _label_point.<span class="built_in">setY</span>(_label_point.<span class="built_in">y</span>() + tmplabel-&gt;<span class="built_in">height</span>() + <span class="number">6</span>);</span><br><span class="line">        _label_point.<span class="built_in">setX</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tmplabel-&gt;<span class="built_in">move</span>(_label_point);</span><br><span class="line">    tmplabel-&gt;<span class="built_in">show</span>();</span><br><span class="line">    _friend_labels[tmplabel-&gt;<span class="built_in">Text</span>()] = tmplabel;</span><br><span class="line">    _friend_label_keys.<span class="built_in">push_back</span>(tmplabel-&gt;<span class="built_in">Text</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tmplabel, &amp;FriendLabel::sig_close, <span class="keyword">this</span>, &amp;AuthenFriend::SlotRemoveFriendLabel);</span><br><span class="line"></span><br><span class="line">    _label_point.<span class="built_in">setX</span>(_label_point.<span class="built_in">x</span>() + tmplabel-&gt;<span class="built_in">width</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_label_point.<span class="built_in">x</span>() + MIN_APPLY_LABEL_ED_LEN &gt; ui-&gt;gridWidget-&gt;<span class="built_in">width</span>()) &#123;</span><br><span class="line">        ui-&gt;lb_ed-&gt;<span class="built_in">move</span>(<span class="number">2</span>, _label_point.<span class="built_in">y</span>() + tmplabel-&gt;<span class="built_in">height</span>() + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;lb_ed-&gt;<span class="built_in">move</span>(_label_point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_ed-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ui-&gt;gridWidget-&gt;<span class="built_in">height</span>() &lt; _label_point.<span class="built_in">y</span>() + tmplabel-&gt;<span class="built_in">height</span>() + <span class="number">2</span>) &#123;</span><br><span class="line">        ui-&gt;gridWidget-&gt;<span class="built_in">setFixedHeight</span>(_label_point.<span class="built_in">y</span>() + tmplabel-&gt;<span class="built_in">height</span>() * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotLabelEnter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;lb_ed-&gt;<span class="built_in">text</span>().<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addLabel</span>(ui-&gt;lb_ed-&gt;<span class="built_in">text</span>());</span><br><span class="line"></span><br><span class="line">    ui-&gt;input_tip_wid-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotRemoveFriendLabel</span><span class="params">(QString name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;receive close signal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    _label_point.<span class="built_in">setX</span>(<span class="number">2</span>);</span><br><span class="line">    _label_point.<span class="built_in">setY</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> find_iter = _friend_labels.<span class="built_in">find</span>(name);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(find_iter == _friend_labels.<span class="built_in">end</span>())&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> find_key = _friend_label_keys.<span class="built_in">end</span>();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> iter = _friend_label_keys.<span class="built_in">begin</span>(); iter != _friend_label_keys.<span class="built_in">end</span>();</span><br><span class="line">       iter++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(*iter == name)&#123;</span><br><span class="line">           find_key = iter;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(find_key != _friend_label_keys.<span class="built_in">end</span>())&#123;</span><br><span class="line">      _friend_label_keys.<span class="built_in">erase</span>(find_key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> find_iter.<span class="built_in">value</span>();</span><br><span class="line"></span><br><span class="line">   _friend_labels.<span class="built_in">erase</span>(find_iter);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">resetLabels</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> find_add = _add_labels.<span class="built_in">find</span>(name);</span><br><span class="line">   <span class="keyword">if</span>(find_add == _add_labels.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   find_add.<span class="built_in">value</span>()-&gt;<span class="built_in">ResetNormalState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击标已有签添加或删除新联系人的标签</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotChangeFriendLabelByTip</span><span class="params">(QString lbtext, ClickLbState state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> find_iter = _add_labels.<span class="built_in">find</span>(lbtext);</span><br><span class="line">    <span class="keyword">if</span>(find_iter == _add_labels.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(state == ClickLbState::Selected)&#123;</span><br><span class="line">        <span class="comment">//编写添加逻辑</span></span><br><span class="line">        <span class="built_in">addLabel</span>(lbtext);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(state == ClickLbState::Normal)&#123;</span><br><span class="line">        <span class="comment">//编写删除逻辑</span></span><br><span class="line">        <span class="built_in">SlotRemoveFriendLabel</span>(lbtext);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotLabelTextChange</span><span class="params">(<span class="type">const</span> QString&amp; text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        ui-&gt;tip_lb-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        ui-&gt;input_tip_wid-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(_tip_data.<span class="built_in">begin</span>(), _tip_data.<span class="built_in">end</span>(), text);</span><br><span class="line">    <span class="keyword">if</span> (iter == _tip_data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> new_text = add_prefix + text;</span><br><span class="line">        ui-&gt;tip_lb-&gt;<span class="built_in">setText</span>(new_text);</span><br><span class="line">        ui-&gt;input_tip_wid-&gt;<span class="built_in">show</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ui-&gt;tip_lb-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">    ui-&gt;input_tip_wid-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotLabelEditFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;input_tip_wid-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotAddFirendLabelByClickTip</span><span class="params">(QString text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = text.<span class="built_in">indexOf</span>(add_prefix);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        text = text.<span class="built_in">mid</span>(index + add_prefix.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">addLabel</span>(text);</span><br><span class="line">    <span class="comment">//标签展示栏也增加一个标签, 并设置绿色选中</span></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        _tip_data.<span class="built_in">push_back</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* lb = <span class="keyword">new</span> <span class="built_in">ClickedLabel</span>(ui-&gt;lb_list);</span><br><span class="line">    lb-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;normal&quot;</span>, <span class="string">&quot;hover&quot;</span>, <span class="string">&quot;pressed&quot;</span>, <span class="string">&quot;selected_normal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;selected_hover&quot;</span>, <span class="string">&quot;selected_pressed&quot;</span>);</span><br><span class="line">    lb-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;tipslb&quot;</span>);</span><br><span class="line">    lb-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">    <span class="built_in">connect</span>(lb, &amp;ClickedLabel::clicked, <span class="keyword">this</span>, &amp;AuthenFriend::SlotChangeFriendLabelByTip);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ui-&gt;lb_list-&gt;width() is &quot;</span> &lt;&lt; ui-&gt;lb_list-&gt;<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;_tip_cur_point.x() is &quot;</span> &lt;&lt; _tip_cur_point.<span class="built_in">x</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QFontMetrics <span class="title">fontMetrics</span><span class="params">(lb-&gt;font())</span></span>; <span class="comment">// 获取QLabel控件的字体信息</span></span><br><span class="line">    <span class="type">int</span> textWidth = fontMetrics.<span class="built_in">width</span>(lb-&gt;<span class="built_in">text</span>()); <span class="comment">// 获取文本的宽度</span></span><br><span class="line">    <span class="type">int</span> textHeight = fontMetrics.<span class="built_in">height</span>(); <span class="comment">// 获取文本的高度</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;textWidth is &quot;</span> &lt;&lt; textWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_tip_cur_point.<span class="built_in">x</span>() + textWidth+ tip_offset+<span class="number">3</span> &gt; ui-&gt;lb_list-&gt;<span class="built_in">width</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        _tip_cur_point.<span class="built_in">setX</span>(<span class="number">5</span>);</span><br><span class="line">        _tip_cur_point.<span class="built_in">setY</span>(_tip_cur_point.<span class="built_in">y</span>() + textHeight + <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> next_point = _tip_cur_point;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">AddTipLbs</span>(lb, _tip_cur_point, next_point, textWidth,textHeight);</span><br><span class="line">    _tip_cur_point = next_point;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> diff_height = next_point.<span class="built_in">y</span>() + textHeight + tip_offset - ui-&gt;lb_list-&gt;<span class="built_in">height</span>();</span><br><span class="line">    ui-&gt;lb_list-&gt;<span class="built_in">setFixedHeight</span>(next_point.<span class="built_in">y</span>() + textHeight + tip_offset);</span><br><span class="line"></span><br><span class="line">    lb-&gt;<span class="built_in">SetCurState</span>(ClickLbState::Selected);</span><br><span class="line"></span><br><span class="line">    ui-&gt;scrollcontent-&gt;<span class="built_in">setFixedHeight</span>(ui-&gt;scrollcontent-&gt;<span class="built_in">height</span>()+ diff_height );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotApplySure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Slot Apply Sure &quot;</span>;</span><br><span class="line">    <span class="comment">//添加发送逻辑</span></span><br><span class="line">    QJsonObject jsonObj;</span><br><span class="line">    <span class="keyword">auto</span> uid = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetUid</span>();</span><br><span class="line">    jsonObj[<span class="string">&quot;fromuid&quot;</span>] = uid;</span><br><span class="line">    jsonObj[<span class="string">&quot;touid&quot;</span>] = _apply_info-&gt;_uid;</span><br><span class="line">    QString back_name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;back_ed-&gt;<span class="built_in">text</span>().<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        back_name = ui-&gt;back_ed-&gt;<span class="built_in">placeholderText</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        back_name = ui-&gt;back_ed-&gt;<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    jsonObj[<span class="string">&quot;back&quot;</span>] = back_name;</span><br><span class="line"></span><br><span class="line">    <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(jsonObj)</span></span>;</span><br><span class="line">    QByteArray jsonData = doc.<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送tcp请求给chat server</span></span><br><span class="line">    <span class="function">emit <span class="title">TcpMgr::GetInstance</span><span class="params">()</span>-&gt;<span class="title">sig_send_data</span><span class="params">(ReqId::ID_AUTH_FRIEND_REQ, jsonData)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">deleteLater</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AuthenFriend::SlotApplyCancel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="built_in">deleteLater</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码连接"><a href="#源码连接" class="headerlink" title="源码连接"></a>源码连接</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/llfcchat">https://gitee.com/secondtonone1/llfcchat</a></p>
<h2 id="视频连接"><a href="#视频连接" class="headerlink" title="视频连接"></a>视频连接</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ex4y1s7cq/">https://www.bilibili.com/video/BV1Ex4y1s7cq/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/08/31/cpppro29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/31/cpppro29/" itemprop="url">聊天项目(29) 好友认证和聊天通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-31T09:30:35+08:00">
                2024-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpppro/" itemprop="url" rel="index">
                    <span itemprop="name">C++聊天项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="好友认证"><a href="#好友认证" class="headerlink" title="好友认证"></a>好友认证</h2><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>服务器接受客户端发送过来的好友认证请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::AuthFriendApply</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> string&amp; msg_data)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> uid = root[<span class="string">&quot;fromuid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">	<span class="keyword">auto</span> touid = root[<span class="string">&quot;touid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">	<span class="keyword">auto</span> back_name = root[<span class="string">&quot;back&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;from &quot;</span> &lt;&lt; uid &lt;&lt; <span class="string">&quot; auth friend to &quot;</span> &lt;&lt; touid &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">	<span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;();</span><br><span class="line"></span><br><span class="line">	std::string base_key = USER_BASE_INFO + std::<span class="built_in">to_string</span>(touid);</span><br><span class="line">	<span class="type">bool</span> b_info = <span class="built_in">GetBaseInfo</span>(base_key, touid, user_info);</span><br><span class="line">	<span class="keyword">if</span> (b_info) &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;name&quot;</span>] = user_info-&gt;name;</span><br><span class="line">		rtvalue[<span class="string">&quot;nick&quot;</span>] = user_info-&gt;nick;</span><br><span class="line">		rtvalue[<span class="string">&quot;icon&quot;</span>] = user_info-&gt;icon;</span><br><span class="line">		rtvalue[<span class="string">&quot;sex&quot;</span>] = user_info-&gt;sex;</span><br><span class="line">		rtvalue[<span class="string">&quot;uid&quot;</span>] = touid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::UidInvalid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">		session-&gt;Send(return_str, ID_AUTH_FRIEND_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先更新数据库</span></span><br><span class="line">	MysqlMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AuthFriendApply</span>(uid, touid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新数据库添加好友</span></span><br><span class="line">	MysqlMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AddFriend</span>(uid, touid,back_name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查询redis 查找touid对应的server ip</span></span><br><span class="line">	<span class="keyword">auto</span> to_str = std::<span class="built_in">to_string</span>(touid);</span><br><span class="line">	<span class="keyword">auto</span> to_ip_key = USERIPPREFIX + to_str;</span><br><span class="line">	std::string to_ip_value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">bool</span> b_ip = RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(to_ip_key, to_ip_value);</span><br><span class="line">	<span class="keyword">if</span> (!b_ip) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; cfg = ConfigMgr::<span class="built_in">Inst</span>();</span><br><span class="line">	<span class="keyword">auto</span> self_name = cfg[<span class="string">&quot;SelfServer&quot;</span>][<span class="string">&quot;Name&quot;</span>];</span><br><span class="line">	<span class="comment">//直接通知对方有认证通过消息</span></span><br><span class="line">	<span class="keyword">if</span> (to_ip_value == self_name) &#123;</span><br><span class="line">		<span class="keyword">auto</span> session = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetSession</span>(touid);</span><br><span class="line">		<span class="keyword">if</span> (session) &#123;</span><br><span class="line">			<span class="comment">//在内存中则直接发送通知对方</span></span><br><span class="line">			Json::Value  notify;</span><br><span class="line">			notify[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">			notify[<span class="string">&quot;fromuid&quot;</span>] = uid;</span><br><span class="line">			notify[<span class="string">&quot;touid&quot;</span>] = touid;</span><br><span class="line">			std::string base_key = USER_BASE_INFO + std::<span class="built_in">to_string</span>(uid);</span><br><span class="line">			<span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;();</span><br><span class="line">			<span class="type">bool</span> b_info = <span class="built_in">GetBaseInfo</span>(base_key, uid, user_info);</span><br><span class="line">			<span class="keyword">if</span> (b_info) &#123;</span><br><span class="line">				notify[<span class="string">&quot;name&quot;</span>] = user_info-&gt;name;</span><br><span class="line">				notify[<span class="string">&quot;nick&quot;</span>] = user_info-&gt;nick;</span><br><span class="line">				notify[<span class="string">&quot;icon&quot;</span>] = user_info-&gt;icon;</span><br><span class="line">				notify[<span class="string">&quot;sex&quot;</span>] = user_info-&gt;sex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				notify[<span class="string">&quot;error&quot;</span>] = ErrorCodes::UidInvalid;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			std::string return_str = notify.<span class="built_in">toStyledString</span>();</span><br><span class="line">			session-&gt;<span class="built_in">Send</span>(return_str, ID_NOTIFY_AUTH_FRIEND_REQ);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	AuthFriendReq auth_req;</span><br><span class="line">	auth_req.<span class="built_in">set_fromuid</span>(uid);</span><br><span class="line">	auth_req.<span class="built_in">set_touid</span>(touid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送通知</span></span><br><span class="line">	ChatGrpcClient::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NotifyAuthFriend</span>(to_ip_value, auth_req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将请求注册到map里，在<code>LogicSystem::RegisterCallBacks</code>中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_fun_callbacks[ID_AUTH_FRIEND_REQ] = std::<span class="built_in">bind</span>(&amp;LogicSystem::AuthFriendApply, <span class="keyword">this</span>,</span><br><span class="line">    placeholders::_1, placeholders::_2, placeholders::_3);</span><br></pre></td></tr></table></figure>

<p>因为上面的逻辑调用了grpc发送通知，所以实现grpc发送认证通知的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AuthFriendRsp <span class="title">ChatGrpcClient::NotifyAuthFriend</span><span class="params">(std::string server_ip, <span class="type">const</span> AuthFriendReq&amp; req)</span> </span>&#123;</span><br><span class="line">	AuthFriendRsp rsp;</span><br><span class="line">	rsp.<span class="built_in">set_error</span>(ErrorCodes::Success);</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([&amp;rsp, &amp;req]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_fromuid(req.fromuid());</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_touid(req.touid());</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> find_iter = _pools.<span class="built_in">find</span>(server_ip);</span><br><span class="line">	<span class="keyword">if</span> (find_iter == _pools.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> rsp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; pool = find_iter-&gt;second;</span><br><span class="line">	ClientContext context;</span><br><span class="line">	<span class="keyword">auto</span> stub = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">	Status status = stub-&gt;<span class="built_in">NotifyAuthFriend</span>(&amp;context, req, &amp;rsp);</span><br><span class="line">	<span class="function">Defer <span class="title">defercon</span><span class="params">([&amp;stub, <span class="keyword">this</span>, &amp;pool]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		pool-&gt;returnConnection(std::move(stub));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">		rsp.<span class="built_in">set_error</span>(ErrorCodes::RPCFailed);</span><br><span class="line">		<span class="keyword">return</span> rsp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意，stub之所以能发送通知，是因为proto里定义了认证通知等服务，大家记得更新proto和我的一样，这事完整的proto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package message;</span><br><span class="line"></span><br><span class="line">service VarifyService &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">GetVarifyCode</span> <span class="params">(GetVarifyReq)</span> <span class="title">returns</span> <span class="params">(GetVarifyRsp)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetVarifyReq &#123;</span><br><span class="line">  string email = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetVarifyRsp &#123;</span><br><span class="line">  int32 error = <span class="number">1</span>;</span><br><span class="line">  string email = <span class="number">2</span>;</span><br><span class="line">  string code = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetChatServerReq &#123;</span><br><span class="line">  int32 uid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetChatServerRsp &#123;</span><br><span class="line">  int32 error = <span class="number">1</span>;</span><br><span class="line">  string host = <span class="number">2</span>;</span><br><span class="line">  string port = <span class="number">3</span>;</span><br><span class="line">  string token = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginReq&#123;</span><br><span class="line">	int32 uid = <span class="number">1</span>;</span><br><span class="line">	string token= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginRsp &#123;</span><br><span class="line">	int32 error = <span class="number">1</span>;</span><br><span class="line">	int32 uid = <span class="number">2</span>;</span><br><span class="line">	string token = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service StatusService &#123;</span><br><span class="line">	<span class="function">rpc <span class="title">GetChatServer</span> <span class="params">(GetChatServerReq)</span> <span class="title">returns</span> <span class="params">(GetChatServerRsp)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function">rpc <span class="title">Login</span><span class="params">(LoginReq)</span> <span class="title">returns</span><span class="params">(LoginRsp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddFriendReq &#123;</span><br><span class="line">	int32  applyuid = <span class="number">1</span>;</span><br><span class="line">	string name = <span class="number">2</span>;</span><br><span class="line">	string desc = <span class="number">3</span>;</span><br><span class="line">	string icon = <span class="number">4</span>;</span><br><span class="line">	string nick = <span class="number">5</span>;</span><br><span class="line">	int32  sex = <span class="number">6</span>;</span><br><span class="line">	int32  touid = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddFriendRsp &#123;</span><br><span class="line">	int32 error = <span class="number">1</span>;</span><br><span class="line">	int32 applyuid = <span class="number">2</span>;</span><br><span class="line">	int32 touid = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RplyFriendReq &#123;</span><br><span class="line">	int32 rplyuid = <span class="number">1</span>;</span><br><span class="line">	<span class="type">bool</span>  agree = <span class="number">2</span>;</span><br><span class="line">	int32 touid = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RplyFriendRsp &#123;</span><br><span class="line">	int32 error = <span class="number">1</span>;</span><br><span class="line">	int32 rplyuid = <span class="number">2</span>;</span><br><span class="line">	int32 touid = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SendChatMsgReq&#123;</span><br><span class="line">		int32 fromuid = <span class="number">1</span>;</span><br><span class="line">		int32 touid = <span class="number">2</span>;</span><br><span class="line">		string message = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SendChatMsgRsp&#123;</span><br><span class="line">		int32 error = <span class="number">1</span>;</span><br><span class="line">		int32 fromuid = <span class="number">2</span>;</span><br><span class="line">		int32 touid = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AuthFriendReq&#123;</span><br><span class="line">	int32 fromuid = <span class="number">1</span>;</span><br><span class="line">	int32 touid = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AuthFriendRsp&#123;</span><br><span class="line">	int32 error = <span class="number">1</span>;</span><br><span class="line">	int32 fromuid = <span class="number">2</span>;</span><br><span class="line">	int32 touid = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TextChatMsgReq &#123;</span><br><span class="line">	int32 fromuid = <span class="number">1</span>;</span><br><span class="line">    int32 touid = <span class="number">2</span>;</span><br><span class="line">	repeated TextChatData textmsgs = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TextChatData&#123;</span><br><span class="line">	string msgid = <span class="number">1</span>;</span><br><span class="line">	string msgcontent = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TextChatMsgRsp &#123;</span><br><span class="line">	int32 error = <span class="number">1</span>;</span><br><span class="line">	int32 fromuid = <span class="number">2</span>;</span><br><span class="line">	int32 touid = <span class="number">3</span>; </span><br><span class="line">	repeated TextChatData textmsgs = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service ChatService &#123;</span><br><span class="line">	<span class="function">rpc <span class="title">NotifyAddFriend</span><span class="params">(AddFriendReq)</span> <span class="title">returns</span> <span class="params">(AddFriendRsp)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function">rpc <span class="title">RplyAddFriend</span><span class="params">(RplyFriendReq)</span> <span class="title">returns</span> <span class="params">(RplyFriendRsp)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function">rpc <span class="title">SendChatMsg</span><span class="params">(SendChatMsgReq)</span> <span class="title">returns</span> <span class="params">(SendChatMsgRsp)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function">rpc <span class="title">NotifyAuthFriend</span><span class="params">(AuthFriendReq)</span> <span class="title">returns</span> <span class="params">(AuthFriendRsp)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function">rpc <span class="title">NotifyTextChatMsg</span><span class="params">(TextChatMsgReq)</span> <span class="title">returns</span> <span class="params">(TextChatMsgRsp)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便生成grpcpb文件，我写了一个start.bat批处理文件</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> PROTOC_PATH=D:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe</span><br><span class="line"><span class="built_in">set</span> GRPC_PLUGIN_PATH=D:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe</span><br><span class="line"><span class="built_in">set</span> PROTO_FILE=message.proto</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Generating gRPC code...</span><br><span class="line"><span class="variable">%PROTOC_PATH%</span> -I=&quot;.&quot; --grpc_out=&quot;.&quot; --plugin=protoc-gen-grpc=&quot;<span class="variable">%GRPC_PLUGIN_PATH%</span>&quot; &quot;<span class="variable">%PROTO_FILE%</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Generating C++ code...</span><br><span class="line"><span class="variable">%PROTOC_PATH%</span> --cpp_out=. &quot;<span class="variable">%PROTO_FILE%</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Done.</span><br></pre></td></tr></table></figure>

<p>执行这个批处理文件就能生成最新的pb文件了。</p>
<p>接下来实现grpc服务对认证的处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ChatServiceImpl::NotifyAuthFriend</span><span class="params">(ServerContext* context, <span class="type">const</span> AuthFriendReq* request,</span></span></span><br><span class="line"><span class="params"><span class="function">	AuthFriendRsp* reply)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//查找用户是否在本服务器</span></span><br><span class="line">	<span class="keyword">auto</span> touid = request-&gt;<span class="built_in">touid</span>();</span><br><span class="line">	<span class="keyword">auto</span> fromuid = request-&gt;<span class="built_in">fromuid</span>();</span><br><span class="line">	<span class="keyword">auto</span> session = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetSession</span>(touid);</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([request, reply]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		reply-&gt;set_error(ErrorCodes::Success);</span></span></span><br><span class="line"><span class="params"><span class="function">		reply-&gt;set_fromuid(request-&gt;fromuid());</span></span></span><br><span class="line"><span class="params"><span class="function">		reply-&gt;set_touid(request-&gt;touid());</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用户不在内存中则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (session == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Status::OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在内存中则直接发送通知对方</span></span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">	rtvalue[<span class="string">&quot;fromuid&quot;</span>] = request-&gt;<span class="built_in">fromuid</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;touid&quot;</span>] = request-&gt;<span class="built_in">touid</span>();</span><br><span class="line"></span><br><span class="line">	std::string base_key = USER_BASE_INFO + std::<span class="built_in">to_string</span>(fromuid);</span><br><span class="line">	<span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;();</span><br><span class="line">	<span class="type">bool</span> b_info = <span class="built_in">GetBaseInfo</span>(base_key, fromuid, user_info);</span><br><span class="line">	<span class="keyword">if</span> (b_info) &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;name&quot;</span>] = user_info-&gt;name;</span><br><span class="line">		rtvalue[<span class="string">&quot;nick&quot;</span>] = user_info-&gt;nick;</span><br><span class="line">		rtvalue[<span class="string">&quot;icon&quot;</span>] = user_info-&gt;icon;</span><br><span class="line">		rtvalue[<span class="string">&quot;sex&quot;</span>] = user_info-&gt;sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::UidInvalid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::string return_str = rtvalue.<span class="built_in">toStyledString</span>();</span><br><span class="line"></span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(return_str, ID_NOTIFY_AUTH_FRIEND_REQ);</span><br><span class="line">	<span class="keyword">return</span> Status::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以A认证B为好友，A所在的服务器会给A回复一个ID_AUTH_FRIEND_RSP的消息，B所在的服务器会给B回复一个ID_NOTIFY_AUTH_FRIEND_REQ消息。</p>
<h3 id="客户端响应"><a href="#客户端响应" class="headerlink" title="客户端响应"></a>客户端响应</h3><p>客户端需要响应服务器发过来的ID_AUTH_FRIEND_RSP和ID_NOTIFY_AUTH_FRIEND_REQ消息</p>
<p>客户端响应ID_AUTH_FRIEND_RSP，在initHandlers中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_AUTH_FRIEND_RSP, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data) &#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;handle id is &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; data is &quot;</span> &lt;&lt; data;</span><br><span class="line">    <span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (jsonDoc.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Auth Friend Failed, err is Json Parse Err&quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span> (err != ErrorCodes::SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Auth Friend Failed, err is &quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name = jsonObj[<span class="string">&quot;name&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">auto</span> nick = jsonObj[<span class="string">&quot;nick&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">auto</span> icon = jsonObj[<span class="string">&quot;icon&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">auto</span> sex = jsonObj[<span class="string">&quot;sex&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">auto</span> uid = jsonObj[<span class="string">&quot;uid&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">auto</span> rsp = std::<span class="built_in">make_shared</span>&lt;AuthRsp&gt;(uid, name, nick, icon, sex);</span><br><span class="line">    emit <span class="built_in">sig_auth_rsp</span>(rsp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Auth Friend Success &quot;</span> ;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在initHandlers中添加ID_NOTIFY_AUTH_FRIEND_REQ</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_NOTIFY_AUTH_FRIEND_REQ, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data) &#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;handle id is &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; data is &quot;</span> &lt;&lt; data;</span><br><span class="line">    <span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (jsonDoc.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Auth Friend Failed, err is &quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span> (err != ErrorCodes::SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Auth Friend Failed, err is &quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> from_uid = jsonObj[<span class="string">&quot;fromuid&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    QString name = jsonObj[<span class="string">&quot;name&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    QString nick = jsonObj[<span class="string">&quot;nick&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    QString icon = jsonObj[<span class="string">&quot;icon&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="type">int</span> sex = jsonObj[<span class="string">&quot;sex&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> auth_info = std::<span class="built_in">make_shared</span>&lt;AuthInfo&gt;(from_uid,name,</span><br><span class="line">                                                nick, icon, sex);</span><br><span class="line"></span><br><span class="line">    emit <span class="built_in">sig_add_auth_friend</span>(auth_info);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>客户端ChatDialog中添加对sig_add_auth_friend响应，实现添加好友到聊天列表中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatDialog::slot_add_auth_friend</span><span class="params">(std::shared_ptr&lt;AuthInfo&gt; auth_info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;receive slot_add_auth__friend uid is &quot;</span> &lt;&lt; auth_info-&gt;_uid</span><br><span class="line">        &lt;&lt; <span class="string">&quot; name is &quot;</span> &lt;&lt; auth_info-&gt;_name &lt;&lt; <span class="string">&quot; nick is &quot;</span> &lt;&lt; auth_info-&gt;_nick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断如果已经是好友则跳过</span></span><br><span class="line">    <span class="keyword">auto</span> bfriend = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">CheckFriendById</span>(auth_info-&gt;_uid);</span><br><span class="line">    <span class="keyword">if</span>(bfriend)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AddFriend</span>(auth_info);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">    <span class="type">int</span> str_i = randomValue % strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> head_i = randomValue % heads.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> name_i = randomValue % names.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* chat_user_wid = <span class="keyword">new</span> <span class="built_in">ChatUserWid</span>();</span><br><span class="line">    <span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;(auth_info);</span><br><span class="line">    chat_user_wid-&gt;<span class="built_in">SetInfo</span>(user_info);</span><br><span class="line">    QListWidgetItem* item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">    item-&gt;<span class="built_in">setSizeHint</span>(chat_user_wid-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    ui-&gt;chat_user_list-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>, item);</span><br><span class="line">    ui-&gt;chat_user_list-&gt;<span class="built_in">setItemWidget</span>(item, chat_user_wid);</span><br><span class="line">    _chat_items_added.<span class="built_in">insert</span>(auth_info-&gt;_uid, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端ChatDialog中添加对sig_auth_rsp响应, 实现添加好友到聊天列表中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatDialog::slot_auth_rsp</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;receive slot_auth_rsp uid is &quot;</span> &lt;&lt; auth_rsp-&gt;_uid</span><br><span class="line">        &lt;&lt; <span class="string">&quot; name is &quot;</span> &lt;&lt; auth_rsp-&gt;_name &lt;&lt; <span class="string">&quot; nick is &quot;</span> &lt;&lt; auth_rsp-&gt;_nick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断如果已经是好友则跳过</span></span><br><span class="line">    <span class="keyword">auto</span> bfriend = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">CheckFriendById</span>(auth_rsp-&gt;_uid);</span><br><span class="line">    <span class="keyword">if</span>(bfriend)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AddFriend</span>(auth_rsp);</span><br><span class="line">    <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">    <span class="type">int</span> str_i = randomValue % strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> head_i = randomValue % heads.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> name_i = randomValue % names.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* chat_user_wid = <span class="keyword">new</span> <span class="built_in">ChatUserWid</span>();</span><br><span class="line">    <span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;(auth_rsp);</span><br><span class="line">    chat_user_wid-&gt;<span class="built_in">SetInfo</span>(user_info);</span><br><span class="line">    QListWidgetItem* item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">    item-&gt;<span class="built_in">setSizeHint</span>(chat_user_wid-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    ui-&gt;chat_user_list-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>, item);</span><br><span class="line">    ui-&gt;chat_user_list-&gt;<span class="built_in">setItemWidget</span>(item, chat_user_wid);</span><br><span class="line">    _chat_items_added.<span class="built_in">insert</span>(auth_rsp-&gt;_uid, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为认证对方为好友后，需要将申请页面的添加按钮变成已添加，所以ApplyFriendPage响应sig_auth_rsp信号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyFriendPage::slot_auth_rsp</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> uid = auth_rsp-&gt;_uid;</span><br><span class="line">    <span class="keyword">auto</span> find_iter = _unauth_items.<span class="built_in">find</span>(uid);</span><br><span class="line">    <span class="keyword">if</span> (find_iter == _unauth_items.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_iter-&gt;second-&gt;<span class="built_in">ShowAddBtn</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同意并认证对方为好友后，也需要将对方添加到联系人列表，ContactUserList响应sig_auth_rsp信号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContactUserList::slot_auth_rsp</span><span class="params">(std::shared_ptr&lt;AuthRsp&gt; auth_rsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;slot auth rsp called&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> isFriend = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">CheckFriendById</span>(auth_rsp-&gt;_uid);</span><br><span class="line">    <span class="keyword">if</span>(isFriend)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 groupitem 之后插入新项</span></span><br><span class="line">    <span class="type">int</span> randomValue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>); <span class="comment">// 生成0到99之间的随机整数</span></span><br><span class="line">    <span class="type">int</span> str_i = randomValue%strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> head_i = randomValue%heads.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> *con_user_wid = <span class="keyword">new</span> <span class="built_in">ConUserItem</span>();</span><br><span class="line">    con_user_wid-&gt;<span class="built_in">SetInfo</span>(auth_rsp-&gt;_uid ,auth_rsp-&gt;_name, heads[head_i]);</span><br><span class="line">    QListWidgetItem *item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">    item-&gt;<span class="built_in">setSizeHint</span>(con_user_wid-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 groupitem 的索引</span></span><br><span class="line">    <span class="type">int</span> index = <span class="keyword">this</span>-&gt;<span class="built_in">row</span>(_groupitem);</span><br><span class="line">    <span class="comment">// 在 groupitem 之后插入新项</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">insertItem</span>(index + <span class="number">1</span>, item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setItemWidget</span>(item, con_user_wid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="登录加载好友"><a href="#登录加载好友" class="headerlink" title="登录加载好友"></a>登录加载好友</h3><p>因为添加好友后，如果客户端重新登录，服务器LoginHandler需要加载好友列表，所以服务器要返回好友列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::LoginHandler</span><span class="params">(shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span> &amp;msg_id, <span class="type">const</span> string &amp;msg_data)</span> </span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line">	<span class="keyword">auto</span> uid = root[<span class="string">&quot;uid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">	<span class="keyword">auto</span> token = root[<span class="string">&quot;token&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;user login uid is  &quot;</span> &lt;&lt; uid &lt;&lt; <span class="string">&quot; user token  is &quot;</span></span><br><span class="line">		&lt;&lt; token &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">		session-&gt;Send(return_str, MSG_CHAT_LOGIN_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从redis获取用户token是否正确</span></span><br><span class="line">	std::string uid_str = std::<span class="built_in">to_string</span>(uid);</span><br><span class="line">	std::string token_key = USERTOKENPREFIX + uid_str;</span><br><span class="line">	std::string token_value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">bool</span> success = RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(token_key, token_value);</span><br><span class="line">	<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::UidInvalid;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (token_value != token) &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::TokenInvalid;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line"></span><br><span class="line">	std::string base_key = USER_BASE_INFO + uid_str;</span><br><span class="line">	<span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;();</span><br><span class="line">	<span class="type">bool</span> b_base = <span class="built_in">GetBaseInfo</span>(base_key, uid, user_info);</span><br><span class="line">	<span class="keyword">if</span> (!b_base) &#123;</span><br><span class="line">		rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::UidInvalid;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rtvalue[<span class="string">&quot;uid&quot;</span>] = uid;</span><br><span class="line">	rtvalue[<span class="string">&quot;pwd&quot;</span>] = user_info-&gt;pwd;</span><br><span class="line">	rtvalue[<span class="string">&quot;name&quot;</span>] = user_info-&gt;name;</span><br><span class="line">	rtvalue[<span class="string">&quot;email&quot;</span>] = user_info-&gt;email;</span><br><span class="line">	rtvalue[<span class="string">&quot;nick&quot;</span>] = user_info-&gt;nick;</span><br><span class="line">	rtvalue[<span class="string">&quot;desc&quot;</span>] = user_info-&gt;desc;</span><br><span class="line">	rtvalue[<span class="string">&quot;sex&quot;</span>] = user_info-&gt;sex;</span><br><span class="line">	rtvalue[<span class="string">&quot;icon&quot;</span>] = user_info-&gt;icon;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从数据库获取申请列表</span></span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;ApplyInfo&gt;&gt; apply_list;</span><br><span class="line">	<span class="keyword">auto</span> b_apply = <span class="built_in">GetFriendApplyInfo</span>(uid,apply_list);</span><br><span class="line">	<span class="keyword">if</span> (b_apply) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; apply : apply_list) &#123;</span><br><span class="line">			Json::Value obj;</span><br><span class="line">			obj[<span class="string">&quot;name&quot;</span>] = apply-&gt;_name;</span><br><span class="line">			obj[<span class="string">&quot;uid&quot;</span>] = apply-&gt;_uid;</span><br><span class="line">			obj[<span class="string">&quot;icon&quot;</span>] = apply-&gt;_icon;</span><br><span class="line">			obj[<span class="string">&quot;nick&quot;</span>] = apply-&gt;_nick;</span><br><span class="line">			obj[<span class="string">&quot;sex&quot;</span>] = apply-&gt;_sex;</span><br><span class="line">			obj[<span class="string">&quot;desc&quot;</span>] = apply-&gt;_desc;</span><br><span class="line">			obj[<span class="string">&quot;status&quot;</span>] = apply-&gt;_status;</span><br><span class="line">			rtvalue[<span class="string">&quot;apply_list&quot;</span>].<span class="built_in">append</span>(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取好友列表</span></span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;UserInfo&gt;&gt; friend_list;</span><br><span class="line">	<span class="type">bool</span> b_friend_list = <span class="built_in">GetFriendList</span>(uid, friend_list);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; friend_ele : friend_list) &#123;</span><br><span class="line">		Json::Value obj;</span><br><span class="line">		obj[<span class="string">&quot;name&quot;</span>] = friend_ele-&gt;name;</span><br><span class="line">		obj[<span class="string">&quot;uid&quot;</span>] = friend_ele-&gt;uid;</span><br><span class="line">		obj[<span class="string">&quot;icon&quot;</span>] = friend_ele-&gt;icon;</span><br><span class="line">		obj[<span class="string">&quot;nick&quot;</span>] = friend_ele-&gt;nick;</span><br><span class="line">		obj[<span class="string">&quot;sex&quot;</span>] = friend_ele-&gt;sex;</span><br><span class="line">		obj[<span class="string">&quot;desc&quot;</span>] = friend_ele-&gt;desc;</span><br><span class="line">		obj[<span class="string">&quot;back&quot;</span>] = friend_ele-&gt;back;</span><br><span class="line">		rtvalue[<span class="string">&quot;friend_list&quot;</span>].<span class="built_in">append</span>(obj);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> server_name = ConfigMgr::<span class="built_in">Inst</span>().<span class="built_in">GetValue</span>(<span class="string">&quot;SelfServer&quot;</span>, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">	<span class="comment">//将登录数量增加</span></span><br><span class="line">	<span class="keyword">auto</span> rd_res = RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HGet</span>(LOGIN_COUNT, server_name);</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!rd_res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		count = std::<span class="built_in">stoi</span>(rd_res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">auto</span> count_str = std::<span class="built_in">to_string</span>(count);</span><br><span class="line">	RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HSet</span>(LOGIN_COUNT, server_name, count_str);</span><br><span class="line">	<span class="comment">//session绑定用户uid</span></span><br><span class="line">	session-&gt;<span class="built_in">SetUserId</span>(uid);</span><br><span class="line">	<span class="comment">//为用户设置登录ip server的名字</span></span><br><span class="line">	std::string  ipkey = USERIPPREFIX + uid_str;</span><br><span class="line">	RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Set</span>(ipkey, server_name);</span><br><span class="line">	<span class="comment">//uid和session绑定管理,方便以后踢人操作</span></span><br><span class="line">	UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">SetUserSession</span>(uid, session);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在initHandlers中加载聊天列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_CHAT_LOGIN_RSP, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data)&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;handle id is &quot;</span>&lt;&lt; id ;</span><br><span class="line">    <span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(jsonDoc.<span class="built_in">isNull</span>())&#123;</span><br><span class="line">       <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;data jsonobj is &quot;</span> &lt;&lt; jsonObj ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>))&#123;</span><br><span class="line">        <span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Login Failed, err is Json Parse Err&quot;</span> &lt;&lt; err ;</span><br><span class="line">        emit <span class="built_in">sig_login_failed</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span>(err != ErrorCodes::SUCCESS)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Login Failed, err is &quot;</span> &lt;&lt; err ;</span><br><span class="line">        emit <span class="built_in">sig_login_failed</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> uid = jsonObj[<span class="string">&quot;uid&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">auto</span> name = jsonObj[<span class="string">&quot;name&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">auto</span> nick = jsonObj[<span class="string">&quot;nick&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">auto</span> icon = jsonObj[<span class="string">&quot;icon&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">auto</span> sex = jsonObj[<span class="string">&quot;sex&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">auto</span> user_info = std::<span class="built_in">make_shared</span>&lt;UserInfo&gt;(uid, name, nick, icon, sex);</span><br><span class="line"></span><br><span class="line">    UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">SetUserInfo</span>(user_info);</span><br><span class="line">    UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">SetToken</span>(jsonObj[<span class="string">&quot;token&quot;</span>].<span class="built_in">toString</span>());</span><br><span class="line">    <span class="keyword">if</span>(jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;apply_list&quot;</span>))&#123;</span><br><span class="line">        UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AppendApplyList</span>(jsonObj[<span class="string">&quot;apply_list&quot;</span>].<span class="built_in">toArray</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加好友列表</span></span><br><span class="line">    <span class="keyword">if</span> (jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;friend_list&quot;</span>)) &#123;</span><br><span class="line">        UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AppendFriendList</span>(jsonObj[<span class="string">&quot;friend_list&quot;</span>].<span class="built_in">toArray</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit <span class="built_in">sig_swich_chatdlg</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="好友聊天"><a href="#好友聊天" class="headerlink" title="好友聊天"></a>好友聊天</h2><h3 id="客户端发送聊天消息"><a href="#客户端发送聊天消息" class="headerlink" title="客户端发送聊天消息"></a>客户端发送聊天消息</h3><p>客户端发送聊天消息，在输入框输入消息后，点击发送回执行下面的槽函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatPage::on_send_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_user_info == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;friend_info is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> user_info = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetUserInfo</span>();</span><br><span class="line">    <span class="keyword">auto</span> pTextEdit = ui-&gt;chatEdit;</span><br><span class="line">    ChatRole role = ChatRole::Self;</span><br><span class="line">    QString userName = user_info-&gt;_name;</span><br><span class="line">    QString userIcon = user_info-&gt;_icon;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> QVector&lt;MsgInfo&gt;&amp; msgList = pTextEdit-&gt;<span class="built_in">getMsgList</span>();</span><br><span class="line">    QJsonObject textObj;</span><br><span class="line">    QJsonArray textArray;</span><br><span class="line">    <span class="type">int</span> txt_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;msgList.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消息内容长度不合规就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(msgList[i].content.<span class="built_in">length</span>() &gt; <span class="number">1024</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QString type = msgList[i].msgFlag;</span><br><span class="line">        ChatItemBase *pChatItem = <span class="keyword">new</span> <span class="built_in">ChatItemBase</span>(role);</span><br><span class="line">        pChatItem-&gt;<span class="built_in">setUserName</span>(userName);</span><br><span class="line">        pChatItem-&gt;<span class="built_in">setUserIcon</span>(<span class="built_in">QPixmap</span>(userIcon));</span><br><span class="line">        QWidget *pBubble = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;text&quot;</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//生成唯一id</span></span><br><span class="line">            QUuid uuid = QUuid::<span class="built_in">createUuid</span>();</span><br><span class="line">            <span class="comment">//转为字符串</span></span><br><span class="line">            QString uuidString = uuid.<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">            pBubble = <span class="keyword">new</span> <span class="built_in">TextBubble</span>(role, msgList[i].content);</span><br><span class="line">            <span class="keyword">if</span>(txt_size + msgList[i].content.<span class="built_in">length</span>()&gt; <span class="number">1024</span>)&#123;</span><br><span class="line">                textObj[<span class="string">&quot;fromuid&quot;</span>] = user_info-&gt;_uid;</span><br><span class="line">                textObj[<span class="string">&quot;touid&quot;</span>] = _user_info-&gt;_uid;</span><br><span class="line">                textObj[<span class="string">&quot;text_array&quot;</span>] = textArray;</span><br><span class="line">                <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(textObj)</span></span>;</span><br><span class="line">                QByteArray jsonData = doc.<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line">                <span class="comment">//发送并清空之前累计的文本列表</span></span><br><span class="line">                txt_size = <span class="number">0</span>;</span><br><span class="line">                textArray = <span class="built_in">QJsonArray</span>();</span><br><span class="line">                textObj = <span class="built_in">QJsonObject</span>();</span><br><span class="line">                <span class="comment">//发送tcp请求给chat server</span></span><br><span class="line">                <span class="function">emit <span class="title">TcpMgr::GetInstance</span><span class="params">()</span>-&gt;<span class="title">sig_send_data</span><span class="params">(ReqId::ID_TEXT_CHAT_MSG_REQ, jsonData)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将bubble和uid绑定，以后可以等网络返回消息后设置是否送达</span></span><br><span class="line">            <span class="comment">//_bubble_map[uuidString] = pBubble;</span></span><br><span class="line">            txt_size += msgList[i].content.<span class="built_in">length</span>();</span><br><span class="line">            QJsonObject obj;</span><br><span class="line">            QByteArray utf8Message = msgList[i].content.<span class="built_in">toUtf8</span>();</span><br><span class="line">            obj[<span class="string">&quot;content&quot;</span>] = QString::<span class="built_in">fromUtf8</span>(utf8Message);</span><br><span class="line">            obj[<span class="string">&quot;msgid&quot;</span>] = uuidString;</span><br><span class="line">            textArray.<span class="built_in">append</span>(obj);</span><br><span class="line">            <span class="keyword">auto</span> txt_msg = std::<span class="built_in">make_shared</span>&lt;TextChatData&gt;(uuidString, obj[<span class="string">&quot;content&quot;</span>].<span class="built_in">toString</span>(),</span><br><span class="line">                user_info-&gt;_uid, _user_info-&gt;_uid);</span><br><span class="line">            <span class="function">emit <span class="title">sig_append_send_chat_msg</span><span class="params">(txt_msg)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;image&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             pBubble = <span class="keyword">new</span> <span class="built_in">PictureBubble</span>(<span class="built_in">QPixmap</span>(msgList[i].content) , role);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;file&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">if</span>(pBubble != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pChatItem-&gt;<span class="built_in">setWidget</span>(pBubble);</span><br><span class="line">            ui-&gt;chat_data_list-&gt;<span class="built_in">appendChatItem</span>(pChatItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;textArray is &quot;</span> &lt;&lt; textArray ;</span><br><span class="line">    <span class="comment">//发送给服务器</span></span><br><span class="line">    textObj[<span class="string">&quot;text_array&quot;</span>] = textArray;</span><br><span class="line">    textObj[<span class="string">&quot;fromuid&quot;</span>] = user_info-&gt;_uid;</span><br><span class="line">    textObj[<span class="string">&quot;touid&quot;</span>] = _user_info-&gt;_uid;</span><br><span class="line">    <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(textObj)</span></span>;</span><br><span class="line">    QByteArray jsonData = doc.<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line">    <span class="comment">//发送并清空之前累计的文本列表</span></span><br><span class="line">    txt_size = <span class="number">0</span>;</span><br><span class="line">    textArray = <span class="built_in">QJsonArray</span>();</span><br><span class="line">    textObj = <span class="built_in">QJsonObject</span>();</span><br><span class="line">    <span class="comment">//发送tcp请求给chat server</span></span><br><span class="line">    <span class="function">emit <span class="title">TcpMgr::GetInstance</span><span class="params">()</span>-&gt;<span class="title">sig_send_data</span><span class="params">(ReqId::ID_TEXT_CHAT_MSG_REQ, jsonData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TcpMgr响应发送信号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpMgr::slot_send_data</span><span class="params">(ReqId reqId, QByteArray dataBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> id = reqId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算长度（使用网络字节序转换）</span></span><br><span class="line">    quint16 len = <span class="built_in">static_cast</span>&lt;quint16&gt;(dataBytes.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个QByteArray用于存储要发送的所有数据</span></span><br><span class="line">    QByteArray block;</span><br><span class="line">    <span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;block, QIODevice::WriteOnly)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据流使用网络字节序</span></span><br><span class="line">    out.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入ID和长度</span></span><br><span class="line">    out &lt;&lt; id &lt;&lt; len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符串数据</span></span><br><span class="line">    block.<span class="built_in">append</span>(dataBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    _socket.<span class="built_in">write</span>(block);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;tcp mgr send byte data is &quot;</span> &lt;&lt; block ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器响应-1"><a href="#服务器响应-1" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>服务器响应客户端发送过来文本消息，在initHandlers中添加处理文本消息的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogicSystem::DealChatTextMsg</span><span class="params">(std::shared_ptr&lt;CSession&gt; session, <span class="type">const</span> <span class="type">short</span>&amp; msg_id, <span class="type">const</span> string&amp; msg_data)</span> </span>&#123;</span><br><span class="line">	Json::Reader reader;</span><br><span class="line">	Json::Value root;</span><br><span class="line">	reader.<span class="built_in">parse</span>(msg_data, root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> uid = root[<span class="string">&quot;fromuid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">	<span class="keyword">auto</span> touid = root[<span class="string">&quot;touid&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Json::Value  arrays = root[<span class="string">&quot;text_array&quot;</span>];</span><br><span class="line">	</span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">	rtvalue[<span class="string">&quot;text_array&quot;</span>] = arrays;</span><br><span class="line">	rtvalue[<span class="string">&quot;fromuid&quot;</span>] = uid;</span><br><span class="line">	rtvalue[<span class="string">&quot;touid&quot;</span>] = touid;</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([<span class="keyword">this</span>, &amp;rtvalue, session]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::string return_str = rtvalue.toStyledString();</span></span></span><br><span class="line"><span class="params"><span class="function">		session-&gt;Send(return_str, ID_TEXT_CHAT_MSG_RSP);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//查询redis 查找touid对应的server ip</span></span><br><span class="line">	<span class="keyword">auto</span> to_str = std::<span class="built_in">to_string</span>(touid);</span><br><span class="line">	<span class="keyword">auto</span> to_ip_key = USERIPPREFIX + to_str;</span><br><span class="line">	std::string to_ip_value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">bool</span> b_ip = RedisMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Get</span>(to_ip_key, to_ip_value);</span><br><span class="line">	<span class="keyword">if</span> (!b_ip) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; cfg = ConfigMgr::<span class="built_in">Inst</span>();</span><br><span class="line">	<span class="keyword">auto</span> self_name = cfg[<span class="string">&quot;SelfServer&quot;</span>][<span class="string">&quot;Name&quot;</span>];</span><br><span class="line">	<span class="comment">//直接通知对方有认证通过消息</span></span><br><span class="line">	<span class="keyword">if</span> (to_ip_value == self_name) &#123;</span><br><span class="line">		<span class="keyword">auto</span> session = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetSession</span>(touid);</span><br><span class="line">		<span class="keyword">if</span> (session) &#123;</span><br><span class="line">			<span class="comment">//在内存中则直接发送通知对方</span></span><br><span class="line">			std::string return_str = rtvalue.<span class="built_in">toStyledString</span>();</span><br><span class="line">			session-&gt;<span class="built_in">Send</span>(return_str, ID_NOTIFY_TEXT_CHAT_MSG_REQ);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	TextChatMsgReq text_msg_req;</span><br><span class="line">	text_msg_req.<span class="built_in">set_fromuid</span>(uid);</span><br><span class="line">	text_msg_req.<span class="built_in">set_touid</span>(touid);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txt_obj : arrays) &#123;</span><br><span class="line">		<span class="keyword">auto</span> content = txt_obj[<span class="string">&quot;content&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">		<span class="keyword">auto</span> msgid = txt_obj[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;content is &quot;</span> &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;msgid is &quot;</span> &lt;&lt; msgid &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">auto</span> *text_msg = text_msg_req.<span class="built_in">add_textmsgs</span>();</span><br><span class="line">		text_msg-&gt;<span class="built_in">set_msgid</span>(msgid);</span><br><span class="line">		text_msg-&gt;<span class="built_in">set_msgcontent</span>(content);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送通知 todo...</span></span><br><span class="line">	ChatGrpcClient::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NotifyTextChatMsg</span>(to_ip_value, text_msg_req, rtvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器实现发送消息的rpc客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TextChatMsgRsp <span class="title">ChatGrpcClient::NotifyTextChatMsg</span><span class="params">(std::string server_ip, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> TextChatMsgReq&amp; req, <span class="type">const</span> Json::Value&amp; rtvalue)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	TextChatMsgRsp rsp;</span><br><span class="line">	rsp.<span class="built_in">set_error</span>(ErrorCodes::Success);</span><br><span class="line"></span><br><span class="line">	<span class="function">Defer <span class="title">defer</span><span class="params">([&amp;rsp, &amp;req]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_fromuid(req.fromuid());</span></span></span><br><span class="line"><span class="params"><span class="function">		rsp.set_touid(req.touid());</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; text_data : req.textmsgs()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			TextChatData* new_msg = rsp.add_textmsgs();</span></span></span><br><span class="line"><span class="params"><span class="function">			new_msg-&gt;set_msgid(text_data.msgid());</span></span></span><br><span class="line"><span class="params"><span class="function">			new_msg-&gt;set_msgcontent(text_data.msgcontent());</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> find_iter = _pools.<span class="built_in">find</span>(server_ip);</span><br><span class="line">	<span class="keyword">if</span> (find_iter == _pools.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> rsp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; pool = find_iter-&gt;second;</span><br><span class="line">	ClientContext context;</span><br><span class="line">	<span class="keyword">auto</span> stub = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">	Status status = stub-&gt;<span class="built_in">NotifyTextChatMsg</span>(&amp;context, req, &amp;rsp);</span><br><span class="line">	<span class="function">Defer <span class="title">defercon</span><span class="params">([&amp;stub, <span class="keyword">this</span>, &amp;pool]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		pool-&gt;returnConnection(std::move(stub));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">		rsp.<span class="built_in">set_error</span>(ErrorCodes::RPCFailed);</span><br><span class="line">		<span class="keyword">return</span> rsp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器实现rpc服务端处理消息通知</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ChatServiceImpl::NotifyTextChatMsg</span><span class="params">(::grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> TextChatMsgReq* request, TextChatMsgRsp* reply)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//查找用户是否在本服务器</span></span><br><span class="line">	<span class="keyword">auto</span> touid = request-&gt;<span class="built_in">touid</span>();</span><br><span class="line">	<span class="keyword">auto</span> session = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetSession</span>(touid);</span><br><span class="line">	reply-&gt;<span class="built_in">set_error</span>(ErrorCodes::Success);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用户不在内存中则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (session == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Status::OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在内存中则直接发送通知对方</span></span><br><span class="line">	Json::Value  rtvalue;</span><br><span class="line">	rtvalue[<span class="string">&quot;error&quot;</span>] = ErrorCodes::Success;</span><br><span class="line">	rtvalue[<span class="string">&quot;fromuid&quot;</span>] = request-&gt;<span class="built_in">fromuid</span>();</span><br><span class="line">	rtvalue[<span class="string">&quot;touid&quot;</span>] = request-&gt;<span class="built_in">touid</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将聊天数据组织为数组</span></span><br><span class="line">	Json::Value text_array;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; msg : request-&gt;<span class="built_in">textmsgs</span>()) &#123;</span><br><span class="line">		Json::Value element;</span><br><span class="line">		element[<span class="string">&quot;content&quot;</span>] = msg.<span class="built_in">msgcontent</span>();</span><br><span class="line">		element[<span class="string">&quot;msgid&quot;</span>] = msg.<span class="built_in">msgid</span>();</span><br><span class="line">		text_array.<span class="built_in">append</span>(element);</span><br><span class="line">	&#125;</span><br><span class="line">	rtvalue[<span class="string">&quot;text_array&quot;</span>] = text_array;</span><br><span class="line"></span><br><span class="line">	std::string return_str = rtvalue.<span class="built_in">toStyledString</span>();</span><br><span class="line"></span><br><span class="line">	session-&gt;<span class="built_in">Send</span>(return_str, ID_NOTIFY_TEXT_CHAT_MSG_REQ);</span><br><span class="line">	<span class="keyword">return</span> Status::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端响应通知"><a href="#客户端响应通知" class="headerlink" title="客户端响应通知"></a>客户端响应通知</h3><p>客户端响应服务器返回的消息，包括两种：</p>
<ol>
<li>A给B发送文本消息，A所在的服务器会给A发送ID_TEXT_CHAT_MSG_RSP消息。</li>
<li>B所在的服务器会通知B，告诉B有来自A的消息，通知消息为ID_NOTIFY_TEXT_CHAT_MSG_REQ</li>
</ol>
<p>所以在tcpmgr的initHandlers中添加响应ID_TEXT_CHAT_MSG_RSP消息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_TEXT_CHAT_MSG_RSP, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data) &#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;handle id is &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; data is &quot;</span> &lt;&lt; data;</span><br><span class="line">    <span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (jsonDoc.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Chat Msg Rsp Failed, err is Json Parse Err&quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span> (err != ErrorCodes::SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Chat Msg Rsp Failed, err is &quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Receive Text Chat Rsp Success &quot;</span> ;</span><br><span class="line">    <span class="comment">//ui设置送达等标记 todo...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在TcpMgr的initHandlers中添加ID_NOTIFY_TEXT_CHAT_MSG_REQ</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_handlers.<span class="built_in">insert</span>(ID_NOTIFY_TEXT_CHAT_MSG_REQ, [<span class="keyword">this</span>](ReqId id, <span class="type">int</span> len, QByteArray data) &#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(len);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;handle id is &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; data is &quot;</span> &lt;&lt; data;</span><br><span class="line">    <span class="comment">// 将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (jsonDoc.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to create QJsonDocument.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!jsonObj.<span class="built_in">contains</span>(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ErrorCodes::ERR_JSON;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Notify Chat Msg Failed, err is Json Parse Err&quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = jsonObj[<span class="string">&quot;error&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span> (err != ErrorCodes::SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Notify Chat Msg Failed, err is &quot;</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Receive Text Chat Notify Success &quot;</span> ;</span><br><span class="line">    <span class="keyword">auto</span> msg_ptr = std::<span class="built_in">make_shared</span>&lt;TextChatMsg&gt;(jsonObj[<span class="string">&quot;fromuid&quot;</span>].<span class="built_in">toInt</span>(),</span><br><span class="line">            jsonObj[<span class="string">&quot;touid&quot;</span>].<span class="built_in">toInt</span>(),jsonObj[<span class="string">&quot;text_array&quot;</span>].<span class="built_in">toArray</span>());</span><br><span class="line">    emit <span class="built_in">sig_text_chat_msg</span>(msg_ptr);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>客户端ChatDialog添加对sig_text_chat_msg的响应</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatDialog::slot_text_chat_msg</span><span class="params">(std::shared_ptr&lt;TextChatMsg&gt; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> find_iter = _chat_items_added.<span class="built_in">find</span>(msg-&gt;_from_uid);</span><br><span class="line">    <span class="keyword">if</span>(find_iter != _chat_items_added.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set chat item msg, uid is &quot;</span> &lt;&lt; msg-&gt;_from_uid;</span><br><span class="line">        QWidget *widget = ui-&gt;chat_user_list-&gt;<span class="built_in">itemWidget</span>(find_iter.<span class="built_in">value</span>());</span><br><span class="line">        <span class="keyword">auto</span> chat_wid = <span class="built_in">qobject_cast</span>&lt;ChatUserWid*&gt;(widget);</span><br><span class="line">        <span class="keyword">if</span>(!chat_wid)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chat_wid-&gt;<span class="built_in">updateLastMsg</span>(msg-&gt;_chat_msgs);</span><br><span class="line">        <span class="comment">//更新当前聊天页面记录</span></span><br><span class="line">        <span class="built_in">UpdateChatMsg</span>(msg-&gt;_chat_msgs);</span><br><span class="line">        UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AppendFriendChatMsg</span>(msg-&gt;_from_uid,msg-&gt;_chat_msgs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没找到，则创建新的插入listwidget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* chat_user_wid = <span class="keyword">new</span> <span class="built_in">ChatUserWid</span>();</span><br><span class="line">    <span class="comment">//查询好友信息</span></span><br><span class="line">    <span class="keyword">auto</span> fi_ptr = UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetFriendById</span>(msg-&gt;_from_uid);</span><br><span class="line">    chat_user_wid-&gt;<span class="built_in">SetInfo</span>(fi_ptr);</span><br><span class="line">    QListWidgetItem* item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;chat_user_wid sizeHint is &quot; &lt;&lt; chat_user_wid-&gt;sizeHint();</span></span><br><span class="line">    item-&gt;<span class="built_in">setSizeHint</span>(chat_user_wid-&gt;<span class="built_in">sizeHint</span>());</span><br><span class="line">    chat_user_wid-&gt;<span class="built_in">updateLastMsg</span>(msg-&gt;_chat_msgs);</span><br><span class="line">     UserMgr::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">AppendFriendChatMsg</span>(msg-&gt;_from_uid,msg-&gt;_chat_msgs);</span><br><span class="line">    ui-&gt;chat_user_list-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>, item);</span><br><span class="line">    ui-&gt;chat_user_list-&gt;<span class="built_in">setItemWidget</span>(item, chat_user_wid);</span><br><span class="line">    _chat_items_added.<span class="built_in">insert</span>(msg-&gt;_from_uid, item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://cdn.llfc.club/1724470182274.jpg" alt="https://cdn.llfc.club/1724470182274.jpg"></p>
<h2 id="源码连接"><a href="#源码连接" class="headerlink" title="源码连接"></a>源码连接</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/llfcchat">https://gitee.com/secondtonone1/llfcchat</a></p>
<h2 id="视频连接"><a href="#视频连接" class="headerlink" title="视频连接"></a>视频连接</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ib421J745/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9">https://www.bilibili.com/video/BV1ib421J745/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/02/24/concpp29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/02/24/concpp29/" itemprop="url">并发编程排错思路和方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-02-24T14:15:17+08:00">
                2024-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>到目前为止，前面一系列的文章已经将多线程编程技术介绍完了，很多人问我如何排查多线程程序的问题，本节是最后一节，给大家提供一些在多线程编程过程中排查问题的思路。因为本节代码演示和实际操作内容较多，该文档仅做基本的说明，详细操作可看视频， 视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>在介绍如何排查前我们先将问题做几个归类：</p>
<ol>
<li>内存问题，包括内存泄露(未回收内存)，空指针，悬垂指针(野指针)，double free问题等。</li>
<li>资源竞争，多个线程竞争同一块临界区的资源，未保证互斥</li>
<li>死锁(互相引用阻塞卡死)和活锁(乐观锁尝试)</li>
<li>引用已释放的变量，生命周期管理失效导致</li>
<li>浅拷贝造成内存异常</li>
<li>线程管控失败，修改或者回收一个已经绑定正在运行线程的变量，或者线程本该回收却被卡死，皆因线程管控失败导致</li>
<li>智能指针和裸指针混用导致二次析构，也属于double free。</li>
</ol>
<p>接下来根据上面列出的问题，我们根据实际案例排查出现问题的原因以及规避的方法。</p>
<p>接下来的案例均取自我的源码，源码链接如下：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot</a></p>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>空指针的问题比较好排查，我们在封装无锁队列的时候照抄《C++并发编程实战》一书引发了崩溃，详见源码链接中crushque.h以及lockfreequetest.cpp。</p>
<p>测试用例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCrushQue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	crush_que&lt;<span class="type">int</span>&gt;  que;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TESTCOUNT * <span class="number">10000</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			que.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TESTCOUNT * <span class="number">10000</span>;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">auto</span> p = que.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">			i++;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后显示的崩溃点在</p>
<p><img src="https://cdn.llfc.club/1708328384150.jpg" alt="https://cdn.llfc.club/1708328384150.jpg"></p>
<p>很明显这是引发崩溃的底层代码，并不是上层代码，通过调用堆栈找到和崩溃最相近的逻辑</p>
<p><img src="https://cdn.llfc.club/1708328755799.jpg" alt="https://cdn.llfc.club/1708328755799.jpg"></p>
<p>我们点击第二行的栈调用跳转到队列的push操作。</p>
<p><img src="https://cdn.llfc.club/1708328906480.jpg" alt="https://cdn.llfc.club/1708328906480.jpg"></p>
<p>在代码166行处是崩溃的上层调用，我们通过分析old_tail.ptr此时为空指针，该问题的根因在于构造无锁队列时未进行头节点和尾部节点的初始化所致。</p>
<p>无论linux还是windows，排查崩溃问题最首要的解决方式为观察栈调用，gdb或者windows的栈信息直观的反应了崩溃的触发顺序。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>一般来说内存泄漏检测有专门的工具库，linux环境下可使用valgrind，windows的visual studio环境下Visual Leak Detector， 这些工具只能被动的检测内存泄漏，很多情况我们需要针对已经开发的类或者逻辑编写测试用例，检测内存泄漏。</p>
<p>比如我们对于无锁队列中提供了一个内存泄漏的版本，详见memoryleakque.h以及测试用例lockfreequetest.cpp，以下为测试代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestLeakQue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	memoryleak_que&lt;<span class="type">int</span>&gt;  que;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TESTCOUNT; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			que.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TESTCOUNT;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">auto</span> p = que.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">			i++;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(que.destruct_count == TESTCOUNT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对这个队列, 我们统计释放节点的个数和开辟节点的个数是否相等，通过<code>assert(que.destruct_count == TESTCOUNT);</code>断言检测，实际测试过程中发现存在内存泄漏。</p>
<p><img src="https://cdn.llfc.club/1708330464493.jpg" alt="https://cdn.llfc.club/1708330464493.jpg"></p>
<p>针对无锁队列的内存泄漏无外乎就是push和pop操作造成的，我们把测试用例改为单线程，先将多线程这个可变因素去掉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestLeakQueSingleThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	memoryleak_que&lt;<span class="type">int</span>&gt;  que;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TESTCOUNT; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			que.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">auto</span> p = que.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(que.destruct_count == TESTCOUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码测试未发现内存泄漏，但这还不能将问题归因于多线程，我们构造一种情况触发空队列的pop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestLeakQueMultiPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	memoryleak_que&lt;<span class="type">int</span>&gt;  que;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TESTCOUNT; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			que.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">auto</span> p = que.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">auto</span> p2 = que.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; *p2 &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(que.destruct_count == TESTCOUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码再一次触发断言，说明存在内存泄漏，那我们可以将问题归因于pop操作，而且是队列为空的pop操作。</p>
<p>接下来配合断点调试，windows断点调试较为方便，或者linux环境gdb调试麻烦，可以在关键点打印信息排查问题。</p>
<p>我们使用visual studio断点排查这个问题，先让队列push一个数据，再pop两次，第二次pop肯定无效因为是空队列，但也是引发泄漏的关键原因。</p>
<p>接下来再push一个数据，再pop节点，我们需观察这次pop是否会触发节点回收的逻辑。</p>
<p>回收节点的逻辑只有两处，在release_ref和free_external_counter内部判断internal_count和external_counters为0时才会调用delete回收内存，所以我们只需要在release_ref和free_external_counter中打断点，观察这两个引用计数是否为0，如果不为0说明引用计数的计算出了问题。</p>
<p><img src="https://cdn.llfc.club/1708334690329.jpg" alt="https://cdn.llfc.club/1708334690329.jpg"></p>
<p>为了便于观察数据，我们采取单步调试的方式，经过断点调试，发现第二次循环pop时，<code>free_external_count</code>内部<code>old_node_ptr.external_count</code>为3，而第一次循环pop时<code>old_node_ptr.external_count</code>为2. 那么第二次计算<code>internal_count</code>就不会为0，导致节点不会回收。</p>
<p>问题的根因也找到了在pop判断队列为空的时候直接返回了，之前进行了<code>increase_external_count</code>将外部引用计数增加了，在判断队列为空未进行修改就返回了，我们知道外部引用计数只是一个副本，可能同时有多个线程修改外部引用计数，所以只需要让内部引用计数释放一次即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == tail.<span class="built_in">load</span>().ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">release_ref</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次测试未发现内存泄漏。</p>
<p>自己设计测试用例时要注意覆盖多种情况，比如无锁队列，我后来又测试了单线程，多线程一进一出，多线程一进多出，多线程一出多进，多线程多出多进等，以及加大线程数测试。详细案例可以看看源码， lockfreequetest.cpp。</p>
<h2 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h2><p>对于悬垂指针也叫做野指针，指的是释放内存后，再次使用这个指针访问数据造成崩溃。double free也属于指针管理失效导致，我们看看网络编程中对官方案例存在隐患的剖析。案例在网络编程network文件夹，day05-AsyncServer中，我们实现了一个异步的echo应答server。<br>正常情况下应答server没有任何问题，但是对于全双工情况(实际情况都是收发解耦合)，比如我们在收到消息后监听读事件，并发送，而不是在发送消息后监听读事件。我们将handle_read处理改为如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transfered)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;</span><br><span class="line">		<span class="function">std::string <span class="title">send_data</span><span class="params">(_data)</span></span>;</span><br><span class="line">		<span class="comment">//在发送</span></span><br><span class="line">		_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read,</span><br><span class="line">			<span class="keyword">this</span>, placeholders::_1, placeholders::_2));</span><br><span class="line">		boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(send_data, bytes_transfered),</span><br><span class="line">			std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, placeholders::_1));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们启动day04-SyncClient和day05-AsyncServer分别测试，在Server handle_read里<code>async_read_some</code>处打断点，然后启动客户端，客户端发送数据后服务器触发<code>async_read_some</code>断点，此时关闭客户端，然后服务器继续执行后面的逻辑会引发崩溃。</p>
<p><img src="https://cdn.llfc.club/1708481010816.jpg" alt="https://cdn.llfc.club/1708481010816.jpg"></p>
<p>遇到崩溃第一反应是看看崩溃的栈信息，崩溃在最底层代码</p>
<p><img src="https://cdn.llfc.club/1708482046203.jpg" alt="https://cdn.llfc.club/1708482046203.jpg"></p>
<p>栈信息也看不懂</p>
<p><img src="https://cdn.llfc.club/1708482122640.jpg" alt="https://cdn.llfc.club/1708482122640.jpg"></p>
<p>看栈调用应该是崩溃在asio底层iocp模型写回调里了。</p>
<p>那我们可以用注释的方式排查问题。我们把handle_write回调里面的逻辑注释掉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// if (!error) &#123;</span></span><br><span class="line">	<span class="comment">// 	memset(_data, 0, max_length);</span></span><br><span class="line">	<span class="comment">// 	_socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&amp;Session::handle_read,</span></span><br><span class="line">	<span class="comment">// 		this, placeholders::_1, placeholders::_2));</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// else &#123;</span></span><br><span class="line">	<span class="comment">// 	delete this;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次启动客户端和服务器，在服务器收到读回调后断点并关闭客户端，服务器放开断点继续执行，未发现崩溃。</p>
<p>观察注释掉的逻辑，最有嫌疑的是<code>delete this</code>, 我们仅仅将<code>delete this</code>注释掉后就不会崩溃了，那我们找到问题根因了</p>
<p>第一次回调触发handle_read没问题，此时在回调里关闭客户端，因为第一次回调再次调用<code>async_read_some</code>将读事件注册给asio底层的事件循环，调用<code>async_write</code>将写事件注册给asio底层循环，当客户端关闭后会第二次触发读回调，这次读回调会执行delete操作，delete this之后，Session所有的数据都被回收，而写回调也会触发，因为那么就行了二次delete操作，这就是double free问题。</p>
<p>解决这个问题我们提出了利用智能指针构造一个伪闭包的方式延长Session周期，保证回调之前不会delete Session。具体可以看看这篇文章<a target="_blank" rel="noopener" href="https://llfc.club/articlepage?id=2OEQEc6p4k79cXsTr6dOVfZbo79">https://llfc.club/articlepage?id=2OEQEc6p4k79cXsTr6dOVfZbo79</a></p>
<p>视频链接</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15P411S7fp/?spm_id_from=333.788&vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9">https://www.bilibili.com/video/BV15P411S7fp/?spm_id_from=333.788&amp;vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9</a></p>
<p>本文仅作排查故障方法整理，其他不做赘述，相关处理方案可以看我博客其他文章和视频。</p>
<h2 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h2><p>资源竞争大部分情况是逻辑错误，比如两个线程A和B同时修改互斥区域，互斥区域未加锁，这期间也可能造成崩溃，比如线程A删除了数据C，而线程B正在访问数据C，引发崩溃后大家不要慌，先看崩溃的堆栈信息，如果是指针显示为0xdddd之类的说明是访问了被删除的数据，那么我们排查删除的逻辑，或者屏蔽删除的逻辑看看会不会出问题，基本思路是</p>
<ol>
<li>崩溃看堆栈信息，排查是不是野指针或者double free问题。</li>
<li>如果不是崩溃信息，数据混乱就查找修改数据的逻辑，或者屏蔽这个逻辑，看看是不是多线程造成的。</li>
<li>崩溃问题也可以通过屏蔽部分逻辑排查是不是多线程导致的。</li>
<li>在必要的逻辑区间增加日志，排查逻辑异常的上层原因。</li>
</ol>
<p>这部分问题要结合实际工作去排查，慢慢熟悉这种思路以后就不陌生了。</p>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>多线程出现死锁问题是很头疼，现象不如内存崩溃或者资源竞争那么明显，表现给开发者的是一种卡死的现象。造成死锁的根本原因在于锁资源互相竞争，遇到这种问题要先梳理逻辑，找到互相引用的关键点。<br>我们通过代码仓库中concurrent文件夹day24-TroubleShoot 中deadlock.h演示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deadlockdemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="type">int</span> global_data = <span class="number">0</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;mtx, &amp;global_data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::lock_guard&lt;std::mutex&gt; outer_lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">		global_data++;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::async([&amp;mtx, &amp;global_data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::lock_guard&lt;std::mutex&gt; inner_lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">			global_data++;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; global_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">		</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数调用这个函数，主进程无法退出。因为不是崩溃问题所以无法查看调用栈，对于这个问题，我们在关键位置打印日志，看看具体走到哪里出了问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deadlockdemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="type">int</span> global_data = <span class="number">0</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;mtx, &amp;global_data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::cout &lt;&lt; <span class="string">&quot;begin lock outer_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::lock_guard&lt;std::mutex&gt; outer_lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">		std::cout &lt;&lt; <span class="string">&quot;after lock outer_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		global_data++;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::async([&amp;mtx, &amp;global_data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;begin lock inner_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::lock_guard&lt;std::mutex&gt; inner_lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;after lock inner_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			global_data++;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; global_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;unlock inner_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">		std::cout &lt;&lt; <span class="string">&quot;unlock  outer_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin lock outer_lock...</span><br><span class="line">after lock outer_lock...</span><br><span class="line">begin lock inner_lock...</span><br></pre></td></tr></table></figure>
<p>可以看到内部锁没有加成功。这种情况就是死锁了，再来分析原因，因为async会返回一个future，作为右值这个future会立即调用析构函数，析构函数内部会等待任务完成(并发编程已经从源码剖析了，这里不再赘述)。内部任务要加锁加不上，外部解不开锁因为async返回的future析构无法调用成功。这就是死锁的原因了。<br>修正，只要让future不立即调用析构即可，我们可以用变量接受future,这样析构就会延缓到解锁之后，变量可以放在最外层，这样变量不会触发析构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lockdemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	<span class="type">int</span> global_data = <span class="number">0</span>;</span><br><span class="line">	std::future&lt;<span class="type">void</span>&gt; future_res;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;mtx, &amp;global_data,&amp;future_res]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::cout &lt;&lt; <span class="string">&quot;begin lock outer_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::lock_guard&lt;std::mutex&gt; outer_lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">		std::cout &lt;&lt; <span class="string">&quot;after lock outer_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		global_data++;</span></span></span><br><span class="line"><span class="params"><span class="function">		future_res = std::async([&amp;mtx, &amp;global_data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;begin lock inner_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::lock_guard&lt;std::mutex&gt; inner_lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;after lock inner_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			global_data++;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; global_data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::cout &lt;&lt; <span class="string">&quot;unlock inner_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">		std::cout &lt;&lt; <span class="string">&quot;unlock  outer_lock...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin lock outer_lock...</span><br><span class="line">after lock outer_lock...</span><br><span class="line">unlock  outer_lock...</span><br><span class="line">begin lock inner_lock...</span><br><span class="line">after lock inner_lock...</span><br><span class="line"><span class="number">2</span></span><br><span class="line">unlock inner_lock...</span><br></pre></td></tr></table></figure>
<p>关于活锁，解决方式类似，在关键位置添加注释排查具体原因。</p>
<h2 id="引用释放的变量"><a href="#引用释放的变量" class="headerlink" title="引用释放的变量"></a>引用释放的变量</h2><p>随着C++ 11 lambda表达式推出后，编程更方便了，但是引用释放的变量这个问题也随之而来。案例在day24-TroubleShoot文件夹deadlock.cpp中reference_invalid函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference_invalid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">class</span> <span class="title class_">task_data</span> &#123;</span><br><span class="line">	 <span class="keyword">public</span>:</span><br><span class="line">		 <span class="built_in">task_data</span>(<span class="type">int</span> i):_data(<span class="keyword">new</span> <span class="built_in">int</span>(i))&#123;&#125;</span><br><span class="line">		 ~<span class="built_in">task_data</span>() &#123; <span class="keyword">delete</span> _data; &#125;</span><br><span class="line">		 <span class="type">int</span>* _data;</span><br><span class="line">	 &#125;;</span><br><span class="line">	 std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_que;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		 <span class="function">task_data <span class="title">data</span><span class="params">(i)</span></span>;</span><br><span class="line">		 task_que.<span class="built_in">push</span>([&amp;data]() &#123;</span><br><span class="line">			 (*data._data)++;</span><br><span class="line">			 std::cout &lt;&lt; <span class="string">&quot;data is &quot;</span> &lt;&lt; *data._data &lt;&lt; std::endl;</span><br><span class="line">			 &#125;);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> res_future =  std::<span class="built_in">async</span>([&amp;task_que]() &#123;</span><br><span class="line">			<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">				<span class="keyword">if</span> (task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">auto</span>&amp; task = task_que.<span class="built_in">front</span>();</span><br><span class="line">				<span class="built_in">task</span>();</span><br><span class="line">				task_que.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	res_future.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数调用后输出的数值为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">1349705340</span></span><br><span class="line">data is <span class="number">-2147481856</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br><span class="line">data is <span class="number">-572662307</span></span><br></pre></td></tr></table></figure>
<p>为什么数据变乱了呢？我们分析一下，这种多线程的逻辑问题就要通过加日志或者梳理逻辑排查了。异步任务里从任务队列弹出任务并执行，我们观察任务是一个lambda表达式，捕获的是task_data类型的引用，既然是引用就有生命周期，我们在将task放入队列时，task_data类型变量data为局部变量，此时还未失效，等离开循环的作用域调用data会调用析构函数，那么内部的数据就被释放了，所以之后线程异步访问时会出现乱码。</p>
<p>怎么改呢？我们在网络编程中介绍了一种思路，利用智能指针构造一个伪闭包逻辑，C++不像js，python，go等有闭包机制，但是我们可以通过智能指针增加引用计数，达到闭包效果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference_sharedptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	 <span class="keyword">class</span> <span class="title class_">task_data</span> &#123;</span><br><span class="line">	 <span class="keyword">public</span>:</span><br><span class="line">		 <span class="built_in">task_data</span>(<span class="type">int</span> i) :_data(<span class="keyword">new</span> <span class="built_in">int</span>(i)) &#123;&#125;</span><br><span class="line">		 ~<span class="built_in">task_data</span>() &#123; <span class="keyword">delete</span> _data; &#125;</span><br><span class="line">		 <span class="type">int</span>* _data;</span><br><span class="line">	 &#125;;</span><br><span class="line">	 std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; task_que;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		 std::shared_ptr&lt;task_data&gt; taskptr = std::<span class="built_in">make_shared</span>&lt;task_data&gt;(i);</span><br><span class="line">		 task_que.<span class="built_in">push</span>([taskptr]() &#123;</span><br><span class="line">			(*( taskptr-&gt;_data))++;</span><br><span class="line">			 std::cout &lt;&lt; <span class="string">&quot;data is &quot;</span> &lt;&lt; *(taskptr-&gt;_data) &lt;&lt; std::endl;</span><br><span class="line">			 &#125;);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">auto</span> res_future = std::<span class="built_in">async</span>([&amp;task_que]() &#123;</span><br><span class="line">		 <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (task_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				 <span class="keyword">break</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">auto</span>&amp; task = task_que.<span class="built_in">front</span>();</span><br><span class="line">			 <span class="built_in">task</span>();</span><br><span class="line">			 task_que.<span class="built_in">pop</span>();</span><br><span class="line">		 &#125;</span><br><span class="line">		 &#125;);</span><br><span class="line"></span><br><span class="line">	 res_future.<span class="built_in">wait</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>再次运行输出正确。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝这个词对于C++开发者并不陌生，如果没有合理的内存管理机制，浅拷贝会造成很严重的内存崩溃问题。<br>看下面这个例子,同样在day24-TroubleShoot文件夹deadlock.cpp中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shallow_copy</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">task_data</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">task_data</span>(<span class="type">int</span> i) :_data(<span class="keyword">new</span> <span class="built_in">int</span>(i)) &#123;&#125;</span><br><span class="line">	 ~<span class="built_in">task_data</span>() &#123; </span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;call task_data destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		 <span class="keyword">delete</span> _data; </span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="type">int</span>* _data;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function">task_data <span class="title">data1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"> task_data data2 = std::<span class="built_in">move</span>(data1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子运行会导致崩溃，我们看data1移动给data2后，二者在作用域结束时都进行析构。</p>
<p>因为我们没实现移动构造和拷贝构造，系统默认的移动构造执行拷贝构造，默认的拷贝构造是浅拷贝，所以data1和data2内部的<code>_data</code>引用同一块内存，他们析构的时候会造成二次析构。</p>
<p>读者可能觉得这个例子太简单，不会犯错，那我们看第二个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shallow_copy2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">task_data</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">task_data</span>(<span class="type">int</span> i) :_data(<span class="keyword">new</span> <span class="built_in">int</span>(i)) &#123;&#125;</span><br><span class="line">	 ~<span class="built_in">task_data</span>() &#123;</span><br><span class="line">		 std::cout &lt;&lt; <span class="string">&quot;call task_data destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		 <span class="keyword">delete</span> _data;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="type">int</span>* _data;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">auto</span> task_call = []() -&gt; task_data &#123;</span><br><span class="line">	 task_data <span class="built_in">data</span>(<span class="number">100</span>);</span><br><span class="line">	 <span class="keyword">return</span> data;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">task_call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个例子中我们定义了一个lambda表达式task_call，返回task_data类型的对象。</p>
<p>关于返回局部对象，编译器有两种情况：</p>
<ol>
<li><p>如果编译器支持返回值优化（Return Value Optimization, RVO），那么在返回局部对象时，编译器可能会通过返回值优化来避免执行移动构造函数。RVO 是一种编译器优化技术，可以避免对返回值进行拷贝或移动操作，直接将局部对象的值放置到调用者提供的空间中，从而减少了不必要的资源开销和性能消耗。</p>
</li>
<li><p>在 C++11 引入移动语义后，编译器有权将返回的局部对象视为右值，从而执行移动构造而非拷贝构造。</p>
</li>
</ol>
<p>无论上述哪一种，都是将值返回，那么都会执行浅拷贝，局部变量随着作用域结束被释放，内部的内存<code>_data</code>被回收，而外部接收的返回值仍在引用<code>_data</code>，此时<code>_data</code>就是野指针。外部对象释放会造成二次析构，或者外部对象使用<code>_data</code>时也会引发野指针崩溃问题。</p>
<p>解决的方式就是实现拷贝构造和移动构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">class</span> <span class="title class_">task_data</span> &#123;</span><br><span class="line">	 <span class="keyword">public</span>:</span><br><span class="line">		 <span class="built_in">task_data</span>(<span class="type">int</span> i) :_data(<span class="keyword">new</span> <span class="built_in">int</span>(i)) &#123;&#125;</span><br><span class="line">		 ~<span class="built_in">task_data</span>() &#123;</span><br><span class="line">			 std::cout &lt;&lt; <span class="string">&quot;call task_data destruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			 <span class="keyword">delete</span> _data;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="built_in">task_data</span>(<span class="type">const</span> task_data&amp; src) &#123;</span><br><span class="line">			 _data = <span class="keyword">new</span> <span class="built_in">int</span>(*(src._data));</span><br><span class="line">		 &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="built_in">task_data</span>(task_data&amp;&amp; src) &#123;</span><br><span class="line">			 _data = <span class="keyword">new</span> <span class="built_in">int</span>(*(src._data));</span><br><span class="line">		 &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="type">int</span>* _data;</span><br><span class="line">	 &#125;;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">auto</span> task_call = []() -&gt; task_data &#123;</span><br><span class="line">		 task_data <span class="built_in">data</span>(<span class="number">100</span>);</span><br><span class="line">		 <span class="keyword">return</span> data;</span><br><span class="line">	 &#125;;</span><br><span class="line"></span><br><span class="line">	 <span class="built_in">task_call</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>再次运行，看到调用两个析构函数，并且未崩溃</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call task_data destruct</span><br><span class="line">call task_data destruct</span><br><span class="line">main <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="线程管控"><a href="#线程管控" class="headerlink" title="线程管控"></a>线程管控</h2><p>多线程编程常遇到的一个问题就是线程管控。案例在day24-TroubleShoot文件夹deadlock.cpp中。</p>
<p>我们实现了一个生产者和消费者的管理类和一个用来控制退出的原子变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> std::atomic&lt;<span class="type">bool</span>&gt;  b_stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductConsumerMgr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ProductConsumerMgr</span>()&#123;</span><br><span class="line">		_consumer = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">while</span> (!b_stop) &#123;</span><br><span class="line">				std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">				_consume_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">if</span> (_data_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;);</span><br><span class="line">				<span class="type">int</span> data = _data_que.<span class="built_in">front</span>();</span><br><span class="line">				_data_que.<span class="built_in">pop</span>();</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">				lock.<span class="built_in">unlock</span>();</span><br><span class="line">				_producer_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		_producer = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (!b_stop) &#123;</span><br><span class="line">				std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">				_producer_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">					<span class="keyword">if</span> (_data_que.<span class="built_in">size</span>() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;);</span><br><span class="line">				_data_que.<span class="built_in">push</span>(++data);</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">				lock.<span class="built_in">unlock</span>();</span><br><span class="line">				_consume_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">ProductConsumerMgr</span>()&#123;</span><br><span class="line">		_producer.<span class="built_in">join</span>();</span><br><span class="line">		_consumer.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::mutex _mtx;</span><br><span class="line">	std::condition_variable _consume_cv;</span><br><span class="line">	std::condition_variable _producer_cv;</span><br><span class="line">	std::queue&lt;<span class="type">int</span>&gt; _data_que;</span><br><span class="line">	std::thread _consumer;</span><br><span class="line">	std::thread _producer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>生产者不断生产数据放入队列，消费者不断从队列消费数据。</li>
<li>ProductConsumerMgr析构时等待生产者和消费者两个线程退出。</li>
<li>b_stop用来控制线程退出。</li>
</ol>
<p>我们实现捕获ctl+c以及关闭窗口信号的函数，然后将b_stop设置为true.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CtrlHandler</span><span class="params">(DWORD fdwCtrlType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">switch</span> (fdwCtrlType)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">// Handle the CTRL-C signal. </span></span><br><span class="line"> <span class="keyword">case</span> CTRL_C_EVENT:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Ctrl-C event\n\n&quot;</span>);</span><br><span class="line">  b_stop = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span>(TRUE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CTRL-CLOSE: confirm that the user wants to exit. </span></span><br><span class="line"> <span class="keyword">case</span> CTRL_CLOSE_EVENT:</span><br><span class="line">  b_stop = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Ctrl-Close event\n\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>(TRUE);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> CTRL_SHUTDOWN_EVENT:</span><br><span class="line">  b_stop = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Ctrl-Shutdown event\n\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestProducerConsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">SetConsoleCtrlHandler</span>((PHANDLER_ROUTINE)CtrlHandler, TRUE);</span><br><span class="line"> ProductConsumerMgr mgr;</span><br><span class="line"> <span class="keyword">while</span> (!b_stop) &#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中启动TestProducerConsumer，生产者和消费者会不断工作，我们按下ctrl+c会中断程序，程序可以安全退出。在一般情况下没有问题，是不是意味着我们的程序足够健壮呢？</p>
<p>我们延缓生产者生产的效率，假设一个小时生产一个数据放入队列，此时Ctrl+c看看是否会中断程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_producer = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">	<span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!b_stop) &#123;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">		std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">		_producer_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="keyword">if</span> (_data_que.<span class="built_in">size</span>() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		_data_que.<span class="built_in">push</span>(++data);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">		lock.<span class="built_in">unlock</span>();</span><br><span class="line">		_consume_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>生产者改为上述每5s产生一个数据，此时ctrl+c并不会中断程序，程序不会退出。</p>
<p>问题的根本在于条件竞争，当我们的生产者生产效率低时，队列为空，测试消费者线程处于挂起状态，ctrl+c虽然将停止信号设置为true，但是ProductConsumerMgr析构并不能执行完成，析构函数会等待两个线程退出，消费者线程不会退出，因为处于挂起状态了。</p>
<p>怎么办呢？我们可以在析构里通知两个线程退出即可。而且两个线程要增加唤醒后判断停止标记的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ProductConsumerMgr</span>()&#123;</span><br><span class="line">	_consume_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	_producer_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	_producer.<span class="built_in">join</span>();</span><br><span class="line">	_consumer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个线程增加条件判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ProductConsumerMgr</span>()&#123;</span><br><span class="line">	_consumer = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="keyword">while</span> (!b_stop) &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">			_consume_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">				<span class="keyword">if</span> (b_stop) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (_data_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (b_stop) &#123;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> data = _data_que.<span class="built_in">front</span>();</span><br><span class="line">			_data_que.<span class="built_in">pop</span>();</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;pop data is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">			lock.<span class="built_in">unlock</span>();</span><br><span class="line">			_producer_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	_producer = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">		<span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!b_stop) &#123;</span><br><span class="line">			std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">			_producer_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">				<span class="keyword">if</span> (b_stop) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (_data_que.<span class="built_in">size</span>() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">			<span class="keyword">if</span> (b_stop) &#123;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			_data_que.<span class="built_in">push</span>(++data);</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;push data is &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">			lock.<span class="built_in">unlock</span>();</span><br><span class="line">			_consume_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按下ctrl+c后，程序输出如下，并且正常退出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push data is 1</span><br><span class="line">pop data is 1</span><br><span class="line">Ctrl-C event</span><br><span class="line">main <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>多线程之间协同工作以及安全退出是设计要考虑的事情。</p>
<h2 id="混用智能指针和裸指针"><a href="#混用智能指针和裸指针" class="headerlink" title="混用智能指针和裸指针"></a>混用智能指针和裸指针</h2><p>有时候混用智能指针和裸指针，我们也会不小心delete一个交给只能指针管理的裸指针。单例在day24-TroubleShoot文件夹中ThreadSafeQue.h以及deadlock.cpp中。</p>
<p>之前我们为了让线程池从其他队列的尾部窃取任务，所以用双向链表实现了线程安全队列，并且实现了从尾部pop数据的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_steal</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex,std::defer_lock)</span></span>;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt;  <span class="title">head_lock</span><span class="params">(head_mutex, std::defer_lock)</span></span>;</span><br><span class="line">	std::<span class="built_in">lock</span>(tail_lock, head_lock);</span><br><span class="line">	<span class="keyword">if</span> (head.<span class="built_in">get</span>() == tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node* prev_node = tail-&gt;prev;</span><br><span class="line">	value = std::<span class="built_in">move</span>(*(prev_node-&gt;data));</span><br><span class="line">	<span class="keyword">delete</span> tail;</span><br><span class="line">	tail = prev_node;</span><br><span class="line">	tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现测试用例，一个线程push数据，一个线程从尾部pop数据，一个线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSteal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> threadsafe_queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"> <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;que]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> index = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">for</span> (; ; ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	  index++;</span></span></span><br><span class="line"><span class="params"><span class="function">	  que.push(index);</span></span></span><br><span class="line"><span class="params"><span class="function">	  std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">200</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;que]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">for</span> (; ; ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="type">int</span> value;</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="type">bool</span> res = que.try_pop(value);</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="keyword">if</span> (!res) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		  std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	  std::cout &lt;&lt; <span class="string">&quot;pop out value is &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;que]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">for</span> (; ; ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="type">int</span> value;</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="type">bool</span> res = que.try_steal(value);</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="keyword">if</span> (!res) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		  std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	  std::cout &lt;&lt; <span class="string">&quot;steal out value is &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> t1.<span class="built_in">join</span>();</span><br><span class="line"> t2.<span class="built_in">join</span>();</span><br><span class="line"> t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行TestSteal时，程序崩溃。</p>
<p><img src="https://cdn.llfc.club/1708753868812.jpg" alt="https://cdn.llfc.club/1708753868812.jpg"></p>
<p>查看堆栈上层信息，崩溃在try_steal这个函数里了。</p>
<p><img src="https://cdn.llfc.club/1708754187835.jpg" alt="https://cdn.llfc.club/1708754187835.jpg"></p>
<p>多线程排查问题时，先把最有嫌疑的线程屏蔽，我们把try_steal的线程屏蔽，发现没有引发崩溃。可以确定是try_steal导致。</p>
<p>我们看try_steal函数内部，涉及内存的有个delete tail, 我们将这个delete tail 注释，发现没问题了。可见是delete tail 出了问题，结合底层崩溃的信息是unique_ptr的析构函数，可以推断我们混用了裸指针和智能指针，很可能是delete了智能指针管理的内存，导致智能指针析构的时候又一次delete内存引发崩溃。<br>我们看下队列里节点的设计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	std::shared_ptr&lt;T&gt; data;</span><br><span class="line">	std::unique_ptr&lt;node&gt; next;</span><br><span class="line">	node* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex head_mutex;</span><br><span class="line">std::unique_ptr&lt;node&gt; head;</span><br><span class="line">std::mutex tail_mutex;</span><br><span class="line">node* tail;</span><br></pre></td></tr></table></figure>
<p>队列是通过node构造的链表，每个节点的next指针为智能指针指向下一个节点，head为<code>std::unique_ptr&lt;node&gt;</code>，tail虽然为<code>node*</code>类型的指针，但是是从智能指针get获取的，那么tail是不应该删除的。</p>
<p>解决的办法就是不用delete即可，pop 尾部节点后将新的尾部节点next指针设置为nullptr，这样就相当于对原tail所属的unique_ptr减少引用计数了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了C++ 多线程以及内存等问题的排错思路和方法，感兴趣的可以看看源码。</p>
<p>源码链接<br><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot</a></p>
<p>视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/02/15/concpp28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/02/15/concpp28/" itemprop="url">中断线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-02-15T09:22:43+08:00">
                2024-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前几篇文章陆续介绍了线程池(ThreadPool)，可汇合线程(join_thread)等技术，其中也用到了当管理类要退出时会通过条件变量唤醒挂起的线程，然后等待其执行完退出。本文按照作者的思路补充设计可中断的线程。</p>
<h2 id="可中断线程"><a href="#可中断线程" class="headerlink" title="可中断线程"></a>可中断线程</h2><p>一个可中断的线程大体的实现是这个样子的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interruptible_thread</span></span><br><span class="line">&#123;</span><br><span class="line">    std::thread internal_thread;</span><br><span class="line">    interrupt_flag* flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function">    <span class="title">interruptible_thread</span><span class="params">(FunctionType f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//⇽-- - 2</span></span><br><span class="line">        std::promise&lt;interrupt_flag*&gt; p;  </span><br><span class="line">        <span class="comment">//⇽-- - 3</span></span><br><span class="line">        internal_thread = std::<span class="built_in">thread</span>([f, &amp;p] &#123;    </span><br><span class="line">            p.<span class="built_in">set_value</span>(&amp;this_thread_interrupt_flag);</span><br><span class="line">            <span class="comment">//⇽-- - 4</span></span><br><span class="line">            <span class="built_in">f</span>();    </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//⇽-- - 5</span></span><br><span class="line">        flag = p.<span class="built_in">get_future</span>().<span class="built_in">get</span>();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internal_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//⇽-- - 6</span></span><br><span class="line">            flag-&gt;<span class="built_in">set</span>();    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>interrupt_flag 为中断标记，其set操作用来标记中断</li>
<li>internal_thread为内部线程，其回调函数内部先设置<code>interrupt_flag*</code>类型的promise值，再执行回调函数。</li>
<li>在interruptible_thread构造函数中等待internal_thread回调函数内部设置好flag的promise值后再退出。</li>
<li>this_thread_interrupt_flag是我们定义的线程变量<code>thread_local interrupt_flag this_thread_interrupt_flag;</code></li>
</ol>
<h2 id="中断标记"><a href="#中断标记" class="headerlink" title="中断标记"></a>中断标记</h2><p>中断标记interrupt_flag类，主要是用来设置中断标记和判断是否已经中断，有可能挂起在条件变量的wait操作上，此时中断就需要唤醒挂起的线程。</p>
<p>为了扩充功能，我们希望设计接口支持在任何锁上等待，那我们使用<code>condition_variable_any</code>支持任意类型的条件变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interrupt_flag</span></span><br><span class="line">&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; flag;</span><br><span class="line">    std::condition_variable* thread_cond;</span><br><span class="line">    std::condition_variable_any* thread_cond_any;</span><br><span class="line">    std::mutex set_clear_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">interrupt_flag</span>() :</span><br><span class="line">        <span class="built_in">thread_cond</span>(<span class="number">0</span>), <span class="built_in">thread_cond_any</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        flag.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(set_clear_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (thread_cond)</span><br><span class="line">        &#123;</span><br><span class="line">            thread_cond-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (thread_cond_any) &#123;</span><br><span class="line">            thread_cond_any-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_set</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_condition_variable</span><span class="params">(std::condition_variable&amp; cv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(set_clear_mutex)</span></span>;</span><br><span class="line">        thread_cond = &amp;cv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_condition_variable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(set_clear_mutex)</span></span>;</span><br><span class="line">        thread_cond = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lockable&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">wait</span><span class="params">(std::condition_variable_any&amp; cv, Lockable&amp; lk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">custom_lock</span> &#123;</span><br><span class="line">            interrupt_flag* self;</span><br><span class="line">            Lockable&amp; lk;</span><br><span class="line">            <span class="built_in">custom_lock</span>(interrupt_flag* self_, std::condition_variable_any&amp; cond, Lockable&amp; lk_) :</span><br><span class="line">                <span class="built_in">self</span>(self_), <span class="built_in">lk</span>(lk_) &#123;</span><br><span class="line">                self-&gt;set_clear_mutex.<span class="built_in">lock</span>();</span><br><span class="line">                self-&gt;thread_cond_any = &amp;cond;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lk.<span class="built_in">unlock</span>();</span><br><span class="line">                self-&gt;set_clear_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                std::<span class="built_in">lock</span>(self-&gt;set_clear_mutex, lk);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">custom_lock</span>() &#123;</span><br><span class="line">                self-&gt;thread_cond_any = <span class="number">0</span>;</span><br><span class="line">                self-&gt;set_clear_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">custom_lock <span class="title">cl</span><span class="params">(<span class="keyword">this</span>, cv, lk)</span></span>;</span><br><span class="line">        <span class="built_in">interruption_point</span>();</span><br><span class="line">        cv.<span class="built_in">wait</span>(cl);</span><br><span class="line">        <span class="built_in">interruption_point</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>set函数将停止标记设置为true，然后用条件变量通知挂起的线程。</li>
<li>set_condition_variable 设置flag关联的条件变量，因为需要用指定的条件变量通知挂起的线程。</li>
<li>clear_condition_variable清除关联的条件变量</li>
<li>wait操作封装了接受任意锁的等待操作，wait函数内部定义了custom_lock，封装了加锁，解锁等操作。</li>
<li>wait操作内部构造了custom_lock对象cl主要是对set_clear_mutex加锁，然后在调用cv.wait，这样能和set函数中的通知条件变量构成互斥，这么做的好处就是要么先将flag设置为true并发送通知，要么先wait，然后再发送通知。这样避免了线程在wait处卡死(线程不会错过发送的通知)</li>
</ol>
<p>interruption_point函数内部判断flag是否为true，如果为true则抛出异常，这里作者处理的突兀了一些。读者可将这个函数改为bool返回值，调用者根据返回值判断是否继续等都可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruption_point</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_interrupt_flag.<span class="built_in">is_set</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">thread_interrupted</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_interrupted为我们自定义的异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_interrupted</span> : <span class="keyword">public</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_interrupted</span>() : <span class="built_in">message</span>(<span class="string">&quot;thread interrupted.&quot;</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">thread_interrupted</span>() <span class="keyword">throw</span> () &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="built_in">what</span>() <span class="type">const</span> <span class="built_in">throw</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> message.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来定义一个类clear_cv_on_destruct</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">clear_cv_on_destruct</span> &#123;</span><br><span class="line">    ~<span class="built_in">clear_cv_on_destruct</span>()&#123;</span><br><span class="line">        this_thread_interrupt_flag.<span class="built_in">clear_condition_variable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clear_cv_on_destruct 这个类主要是用来在析构时释放和flag关联的条件变量。</p>
<p>除此之外，我们还可以封装几个不同版本的等待<br>支持普通条件变量的等待</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruptible_wait</span><span class="params">(std::condition_variable&amp; cv,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_lock&lt;std::mutex&gt;&amp; lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">    this_thread_interrupt_flag.<span class="built_in">set_condition_variable</span>(cv);</span><br><span class="line">    clear_cv_on_destruct guard;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">    cv.<span class="built_in">wait_for</span>(lk, std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持谓词的等待</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruptible_wait</span><span class="params">(std::condition_variable&amp; cv,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_lock&lt;std::mutex&gt;&amp; lk,</span></span></span><br><span class="line"><span class="params"><span class="function">    Predicate pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">    this_thread_interrupt_flag.<span class="built_in">set_condition_variable</span>(cv);</span><br><span class="line">    clear_cv_on_destruct guard;</span><br><span class="line">    <span class="keyword">while</span> (!this_thread_interrupt_flag.<span class="built_in">is_set</span>() &amp;&amp; !<span class="built_in">pred</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cv.<span class="built_in">wait_for</span>(lk, std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个版本采用wait_for而不用wait是因为如果等待之前条件变量的通知已经发送，线程之后才调用wait就会发生死等，所以这里采用的wait_for</p>
<p>支持future的等待</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruptible_wait</span><span class="params">(std::future&lt;T&gt;&amp; uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!this_thread_interrupt_flag.<span class="built_in">is_set</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>)) ==</span><br><span class="line">            std::future_status::ready)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们用案例测试上面的案例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interupthread.h&quot;</span></span></span><br><span class="line">std::vector&lt;interruptible_thread&gt; background_threads;</span><br><span class="line">std::mutex mtx1;</span><br><span class="line">std::mutex mtx2;</span><br><span class="line">std::condition_variable cv1;</span><br><span class="line">std::condition_variable_any cv2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_background_processing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	background_threads.<span class="built_in">push_back</span>([]() &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx1);</span><br><span class="line">			<span class="built_in">interruptible_wait</span>(cv1, lock);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; ex) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;catch exception is &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	background_threads.<span class="built_in">push_back</span>([]() &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx2);</span><br><span class="line">			this_thread_interrupt_flag.<span class="built_in">wait</span>(cv2, mtx2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; ex) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;catch exception is &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">start_background_processing</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; background_threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		background_threads[i].<span class="built_in">interrupt</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; background_threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		background_threads[i].<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的案例中启动了两个线程，每个线程回调函数中调用我们封装的可中断的等待。在主函数中断两个线程，并测试两个线程能否在等待中中断。</p>
<p>程序输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catch exception is thread interrupted.</span><br><span class="line">catch exception is thread interrupted.</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了中断线程的设计，说简单点还是设置终止标记为true，利用条件变量通知挂起的线程唤醒。</p>
<p>源码链接：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day23-interupthread">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day23-interupthread</a></p>
<p>视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/02/12/concpp27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/02/12/concpp27/" itemprop="url">线程池技术补充(轮询，等待完成结果，避免争夺，任务窃取)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-02-12T08:38:09+08:00">
                2024-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前文我们介绍了线程池，已经给大家提供了一个完整的线程池封装了，本节跟着《C++ 并发编程实战》一书中作者的思路，看看他的线程池的实现，以此作为补充</p>
<h2 id="轮询方式的线程池"><a href="#轮询方式的线程池" class="headerlink" title="轮询方式的线程池"></a>轮询方式的线程池</h2><p>配合我们之前封装的线程安全队列threadsafe_queue</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;T&gt; data;</span><br><span class="line">		std::unique_ptr&lt;node&gt; next;</span><br><span class="line">		node* prev;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::mutex head_mutex;</span><br><span class="line">	std::unique_ptr&lt;node&gt; head;</span><br><span class="line">	std::mutex tail_mutex;</span><br><span class="line">	node* tail;</span><br><span class="line">	std::condition_variable data_cond;</span><br><span class="line">	std::atomic_bool  bstop;</span><br><span class="line"></span><br><span class="line">	<span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">		head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">		<span class="keyword">return</span> old_head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">		data_cond.<span class="built_in">wait</span>(head_lock,[&amp;] &#123;<span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>() || bstop.<span class="built_in">load</span>() == <span class="literal">true</span>; &#125;);</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);   </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;   </span><br><span class="line">			<span class="keyword">if</span> (bstop.<span class="built_in">load</span>()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;  </span><br><span class="line">			<span class="keyword">if</span> (bstop.<span class="built_in">load</span>()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">threadsafe_queue</span>() :  <span class="comment">// ⇽-- - 1</span></span><br><span class="line">		<span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>())</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">threadsafe_queue</span>() &#123;</span><br><span class="line">		bstop.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">		data_cond.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">	threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		bstop.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">		data_cond.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">wait_and_pop_timeout</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">		<span class="keyword">auto</span> res = data_cond.<span class="built_in">wait_for</span>(head_lock, std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>),</span><br><span class="line">				[&amp;] &#123;<span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>() || bstop.<span class="built_in">load</span>() == <span class="literal">true</span>; &#125;);</span><br><span class="line">		<span class="keyword">if</span> (res == <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bstop.<span class="built_in">load</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		 </span><br><span class="line">		value = std::<span class="built_in">move</span>(*head-&gt;data);	</span><br><span class="line">		head = std::<span class="built_in">move</span>(head-&gt;next);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> <span class="comment">//  &lt;------3</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">		<span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span>  <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>  <span class="comment">//  &lt;------4</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">		<span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">try_pop_head</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> <span class="comment">//&lt;------2</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">			tail-&gt;data = new_data;</span><br><span class="line">			node* <span class="type">const</span> new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">			new_tail-&gt;prev = tail;</span><br><span class="line">	</span><br><span class="line">			tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">		</span><br><span class="line">			tail = new_tail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">try_steal</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex,std::defer_lock)</span></span>;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt;  <span class="title">head_lock</span><span class="params">(head_mutex, std::defer_lock)</span></span>;</span><br><span class="line">		std::<span class="built_in">lock</span>(tail_lock, head_lock);</span><br><span class="line">		<span class="keyword">if</span> (head.<span class="built_in">get</span>() == tail)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		node* prev_node = tail-&gt;prev;</span><br><span class="line">		value = std::<span class="built_in">move</span>(*(prev_node-&gt;data));</span><br><span class="line">		tail = prev_node;</span><br><span class="line">		tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们封装了一个简单轮询的线程池</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeQue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;join_thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line">    std::atomic_bool done;</span><br><span class="line">    <span class="comment">//⇽-- - 1</span></span><br><span class="line">    threadsafe_queue&lt;std::function&lt;<span class="type">void</span>()&gt; &gt; work_queue; </span><br><span class="line">    <span class="comment">//⇽-- - 2</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads; </span><br><span class="line">    <span class="comment">//⇽-- - 3</span></span><br><span class="line">    join_threads joiner;    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//⇽-- - 4</span></span><br><span class="line">        <span class="keyword">while</span> (!done)    </span><br><span class="line">        &#123;</span><br><span class="line">            std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">            <span class="comment">//⇽-- - 5</span></span><br><span class="line">            <span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task))    </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//⇽-- - 6</span></span><br><span class="line">                <span class="built_in">task</span>();    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//⇽-- - 7</span></span><br><span class="line">                std::this_thread::<span class="built_in">yield</span>();    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">simple_thread_pool</span>() :</span><br><span class="line">		<span class="built_in">done</span>(<span class="literal">false</span>), <span class="built_in">joiner</span>(threads)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽--- 8</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//⇽-- - 9</span></span><br><span class="line">				threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;simple_thread_pool::worker_thread, <span class="keyword">this</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (...)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 10</span></span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> simple_thread_pool&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="type">static</span>  simple_thread_pool pool;</span><br><span class="line">       <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">simple_thread_pool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//⇽-- - 11</span></span><br><span class="line">        done = <span class="literal">true</span>;     </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 9</span></span><br><span class="line">            threads[i].<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">submit</span><span class="params">(FunctionType f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//⇽-- - 12</span></span><br><span class="line">        work_queue.<span class="built_in">push</span>(std::<span class="built_in">function</span>&lt;<span class="built_in">void</span>()&gt;(f));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>worker_thread 即为线程的回调函数，回调函数内从队列中取出任务并处理，如果没有任务则调用yield释放cpu资源。</p>
</li>
<li><p>submit函数比较简单，投递了一个返回值为void，参数为void的任务。这和我们之前自己设计的线程池(可执行任意参数类型，返回值不限的函数)相比功能稍差了一些。</p>
</li>
</ol>
<h2 id="获取任务完成结果"><a href="#获取任务完成结果" class="headerlink" title="获取任务完成结果"></a>获取任务完成结果</h2><p>因为外部投递任务给线程池后要获取线程池执行任务的结果，我们之前自己设计的线程池采用的是future和decltype推断函数返回值的方式构造一个返回类型的future。</p>
<p>这里作者先封装一个可调用对象的类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">function_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">impl_base</span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">impl_base</span>() &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::unique_ptr&lt;impl_base&gt; impl;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">impl_type</span> : impl_base</span><br><span class="line">	&#123;</span><br><span class="line">		F f;</span><br><span class="line">		<span class="built_in">impl_type</span>(F&amp;&amp; f_) : <span class="built_in">f</span>(std::<span class="built_in">move</span>(f_)) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">	<span class="title">function_wrapper</span><span class="params">(F&amp;&amp; f)</span> :</span></span><br><span class="line"><span class="function">		impl(new impl_type&lt;F&gt;(std::move(f)))</span></span><br><span class="line"><span class="function">	&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; impl-&gt;<span class="built_in">call</span>(); &#125;</span><br><span class="line">	<span class="built_in">function_wrapper</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">function_wrapper</span>(function_wrapper&amp;&amp; other) :</span><br><span class="line">		<span class="built_in">impl</span>(std::<span class="built_in">move</span>(other.impl))</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	function_wrapper&amp; <span class="keyword">operator</span>=(function_wrapper&amp;&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		impl = std::<span class="built_in">move</span>(other.impl);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">function_wrapper</span>(<span class="type">const</span> function_wrapper&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">function_wrapper</span>(function_wrapper&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	function_wrapper&amp; <span class="keyword">operator</span>=(<span class="type">const</span> function_wrapper&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>impl_base 是一个基类，内部有一个纯虚函数call，以及一个虚析构，这样可以通过delete 基类指针动态析构子类对象。</p>
</li>
<li><p>impl_type 继承了impl_base类，内部包含了一个可调用对象f，并且实现了构造函数和call函数，call内部调用可调用对象f。</p>
</li>
<li><p>function_wrapper 内部有智能指针impl_base类型的unique_ptr变量impl, function_wrapper构造函数根据可调用对象f构造impl </p>
</li>
<li><p>function_wrapper支持移动构造不支持拷贝和赋值。function_wrapper本质上就是当作task给线程池执行的。</p>
</li>
</ol>
<p>可获取任务执行状态的线程池如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">future_thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!done)</span><br><span class="line">		&#123;</span><br><span class="line">			function_wrapper task;    </span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">task</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> future_thread_pool&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span>  future_thread_pool pool;</span><br><span class="line">		<span class="keyword">return</span> pool;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">future_thread_pool</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽-- - 11</span></span><br><span class="line">		done = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 9</span></span><br><span class="line">			threads[i].<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">	std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;   </span><br><span class="line">		<span class="built_in">submit</span>(FunctionType f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type result_type;   </span><br><span class="line">			<span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;   </span><br><span class="line">			<span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;    </span><br><span class="line">			work_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));    </span><br><span class="line">			<span class="keyword">return</span> res;   </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">future_thread_pool</span>() :</span><br><span class="line">		<span class="built_in">done</span>(<span class="literal">false</span>), <span class="built_in">joiner</span>(threads)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽--- 8</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//⇽-- - 9</span></span><br><span class="line">				threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;future_thread_pool::worker_thread, <span class="keyword">this</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (...)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 10</span></span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::atomic_bool done;</span><br><span class="line">	<span class="comment">//⇽-- - 1</span></span><br><span class="line">	threadsafe_queue&lt;function_wrapper&gt; work_queue;</span><br><span class="line">	<span class="comment">//⇽-- - 2</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">//⇽-- - 3</span></span><br><span class="line">	join_threads joiner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p>worker_thread内部从队列中pop任务并执行，如果没有任务则交出cpu资源。</p>
</li>
<li><p>submit函数返回值为<code>std::future&lt;typename std::result_of&lt;FunctionType()&gt;::type&gt;</code>类型，通过<code>std::result_of&lt;FunctionType()&gt;</code>推断出函数执行的结果，然后通过<code>::type</code>推断出结果的类型，并且根据这个类型构造future，这样调用者就可以在投递完任务获取任务的执行结果了。</p>
</li>
<li><p>submit函数内部我们将函数执行的结果类型定义为result_type类型，并且利用f构造一个packaged_task任务。通过task返回一个future给外部调用者，然后我们调用队列的push将task放入队列，注意队列存储的是function_wrapper，这里是利用task隐式构造了function_wrapper类型的对象。</p>
</li>
</ol>
<h2 id="利用条件变量等待"><a href="#利用条件变量等待" class="headerlink" title="利用条件变量等待"></a>利用条件变量等待</h2><p>当我们的任务队列中没有任务的时候，可以让线程挂起，然后等待有任务投递到队列后在激活线程处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">notify_thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!done)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">auto</span> task_ptr = work_queue.<span class="built_in">wait_and_pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (task_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			(*task_ptr)();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> notify_thread_pool&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span>  notify_thread_pool pool;</span><br><span class="line">		<span class="keyword">return</span> pool;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">notify_thread_pool</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽-- - 11</span></span><br><span class="line">		done = <span class="literal">true</span>;</span><br><span class="line">		work_queue.<span class="built_in">Exit</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 9</span></span><br><span class="line">			threads[i].<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">	std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;   </span><br><span class="line">		<span class="built_in">submit</span>(FunctionType f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type result_type;   </span><br><span class="line">			<span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;   </span><br><span class="line">			<span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;    </span><br><span class="line">			work_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));    </span><br><span class="line">			<span class="keyword">return</span> res;   </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">notify_thread_pool</span>() :</span><br><span class="line">		<span class="built_in">done</span>(<span class="literal">false</span>), <span class="built_in">joiner</span>(threads)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽--- 8</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//⇽-- - 9</span></span><br><span class="line">				threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;notify_thread_pool::worker_thread, <span class="keyword">this</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (...)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 10</span></span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">			work_queue.<span class="built_in">Exit</span>();</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::atomic_bool done;</span><br><span class="line">	<span class="comment">//⇽-- - 1</span></span><br><span class="line">	threadsafe_queue&lt;function_wrapper&gt; work_queue;</span><br><span class="line">	<span class="comment">//⇽-- - 2</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">//⇽-- - 3</span></span><br><span class="line">	join_threads joiner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p>worker_thread内部调用了work_queue的wait_and_pop函数，如果队列中有任务直接返回，如果没任务则挂起。</p>
</li>
<li><p>另外我们在线程池的析构函数和异常处理时都增加了<code>work_queue.Exit();</code> 这需要在我们的线程安全队列中增加Exit函数通知线程唤醒，因为线程发现队列为空会阻塞住。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	bstop.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">	data_cond.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免争夺"><a href="#避免争夺" class="headerlink" title="避免争夺"></a>避免争夺</h2><p>我们的任务队列只有一个，当向任务队列频繁投递任务，线程池中其他线程从队列中获取任务，队列就会频繁加锁和解锁，一般情况下性能不会有什么损耗，但是如果投递的任务较多，我们可以采取分流的方式，创建多个任务队列(可以和线程池中线程数相等)，将任务投递给不同的任务队列，每个线程消费自己的队列即可，这样减少了线程间取任务的冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeQue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeQue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;join_thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FutureThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parrallen_thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!done)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> task_ptr = thread_work_ques[index].<span class="built_in">wait_and_pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (task_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			(*task_ptr)();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> parrallen_thread_pool&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span>  parrallen_thread_pool pool;</span><br><span class="line">		<span class="keyword">return</span> pool;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">parrallen_thread_pool</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽-- - 11</span></span><br><span class="line">		done = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_work_ques.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			thread_work_ques[i].<span class="built_in">Exit</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 9</span></span><br><span class="line">			threads[i].<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">	std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;</span><br><span class="line">		<span class="built_in">submit</span>(FunctionType f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> index = (atm_index.<span class="built_in">load</span>() + <span class="number">1</span>) % thread_work_ques.<span class="built_in">size</span>();</span><br><span class="line">		atm_index.<span class="built_in">store</span>(index);</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type result_type;</span><br><span class="line">		<span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">		<span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">		thread_work_ques[index].<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">parrallen_thread_pool</span>() :</span><br><span class="line">		<span class="built_in">done</span>(<span class="literal">false</span>), <span class="built_in">joiner</span>(threads), <span class="built_in">atm_index</span>(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽--- 8</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			thread_work_ques = std::vector &lt; threadsafe_queue&lt;function_wrapper&gt;&gt;(thread_count);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//⇽-- - 9</span></span><br><span class="line">				threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;parrallen_thread_pool::worker_thread, <span class="keyword">this</span>, i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (...)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 10</span></span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_work_ques.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				thread_work_ques[i].<span class="built_in">Exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::atomic_bool done;</span><br><span class="line">	<span class="comment">//全局队列</span></span><br><span class="line">	std::vector&lt;threadsafe_queue&lt;function_wrapper&gt;&gt; thread_work_ques;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//⇽-- - 2</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">//⇽-- - 3</span></span><br><span class="line">	join_threads joiner;</span><br><span class="line">	std::atomic&lt;<span class="type">int</span>&gt;  atm_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>我们将任务队列变为多个<code>    //全局队列  std::vector&lt;threadsafe_queue&lt;function_wrapper&gt;&gt; thread_work_ques;</code>.</p>
</li>
<li><p>commit的时候根据atm_index索引自增后对总大小取余将任务投递给不同的队列。</p>
</li>
<li><p>worker_thread增加了索引参数，每个线程的在回调的时候会根据自己的索引取出对应队列中的任务进行执行。</p>
</li>
</ol>
<h2 id="任务窃取"><a href="#任务窃取" class="headerlink" title="任务窃取"></a>任务窃取</h2><p>当本线程队列中的任务处理完了，它可以去别的线程的任务队列中看看是否有没处理的任务，帮助其他线程处理任务，简称任务窃取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeQue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeQue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;join_thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FutureThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">steal_thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!done)</span><br><span class="line">		&#123;</span><br><span class="line">			function_wrapper wrapper;</span><br><span class="line">			<span class="type">bool</span> pop_res = thread_work_ques[index].<span class="built_in">try_pop</span>(wrapper);</span><br><span class="line">			<span class="keyword">if</span> (pop_res) &#123;</span><br><span class="line">				<span class="built_in">wrapper</span>();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">bool</span> steal_res = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_work_ques.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				steal_res  = thread_work_ques[i].<span class="built_in">try_pop</span>(wrapper);</span><br><span class="line">				<span class="keyword">if</span> (steal_res) &#123;</span><br><span class="line">					<span class="built_in">wrapper</span>();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (steal_res) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> steal_thread_pool&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span>  steal_thread_pool pool;</span><br><span class="line">		<span class="keyword">return</span> pool;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">steal_thread_pool</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽-- - 11</span></span><br><span class="line">		done = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_work_ques.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			thread_work_ques[i].<span class="built_in">Exit</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 9</span></span><br><span class="line">			threads[i].<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">	std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;</span><br><span class="line">		<span class="built_in">submit</span>(FunctionType f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> index = (atm_index.<span class="built_in">load</span>() + <span class="number">1</span>) % thread_work_ques.<span class="built_in">size</span>();</span><br><span class="line">		atm_index.<span class="built_in">store</span>(index);</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type result_type;</span><br><span class="line">		<span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">		<span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">		thread_work_ques[index].<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">steal_thread_pool</span>() :</span><br><span class="line">		<span class="built_in">done</span>(<span class="literal">false</span>), <span class="built_in">joiner</span>(threads), <span class="built_in">atm_index</span>(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//⇽--- 8</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			thread_work_ques = std::vector &lt; threadsafe_queue&lt;function_wrapper&gt;&gt;(thread_count);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//⇽-- - 9</span></span><br><span class="line">				threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;steal_thread_pool::worker_thread, <span class="keyword">this</span>, i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (...)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//⇽-- - 10</span></span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_work_ques.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				thread_work_ques[i].<span class="built_in">Exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::atomic_bool done;</span><br><span class="line">	<span class="comment">//全局队列</span></span><br><span class="line">	std::vector&lt;threadsafe_queue&lt;function_wrapper&gt;&gt; thread_work_ques;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//⇽-- - 2</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;</span><br><span class="line">	<span class="comment">//⇽-- - 3</span></span><br><span class="line">	join_threads joiner;</span><br><span class="line">	std::atomic&lt;<span class="type">int</span>&gt;  atm_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>worker_thread</code>中本线程会先处理自己队列中的任务，如果自己队列中没有任务则从其它线程的任务队列中获取任务。如果都没有则交出cpu资源。</p>
</li>
<li><p>为了实现try_steal的功能，我们需要修改线程安全队列threadsafe_queue，增加try_steal函数</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_steal</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex,std::defer_lock)</span></span>;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt;  <span class="title">head_lock</span><span class="params">(head_mutex, std::defer_lock)</span></span>;</span><br><span class="line">	std::<span class="built_in">lock</span>(tail_lock, head_lock);</span><br><span class="line">	<span class="keyword">if</span> (head.<span class="built_in">get</span>() == tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node* prev_node = tail-&gt;prev;</span><br><span class="line">	value = std::<span class="built_in">move</span>(*(prev_node-&gt;data));</span><br><span class="line">	tail = prev_node;</span><br><span class="line">	tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为try_steal是从队列的尾部弹出数据，为了防止此时有其他线程从头部弹出数据造成操作同一个节点，或者其他线程弹出头部数据后接着修改头部节点为下一个节点，此时本线程正在弹出尾部节点，而尾部节点正好是头部的下一个节点造成数据混乱，此时加了两把锁，对头部和尾部都加锁。</p>
<p>我们这里所说的弹出尾部节点不是弹出tail，而是tail的前一个节点，因为tail是尾部表示一个空节点，tail前边的节点才是尾部数据的节点，为了实现反向查找，我们为node增加了prev指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	std::shared_ptr&lt;T&gt; data;</span><br><span class="line">	std::unique_ptr&lt;node&gt; next;</span><br><span class="line">	node* prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以在push节点的时候也要把这个节点的prev指针指向前一个节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> <span class="comment">//&lt;------2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">		tail-&gt;data = new_data;</span><br><span class="line">		node* <span class="type">const</span> new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">		new_tail-&gt;prev = tail;</span><br><span class="line">	    tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">		tail = new_tail;</span><br><span class="line">	&#125;</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体来说steal版本的线程池就这些内容和前边变化不大。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试用例已经在源代码中写好，感兴趣可以看下</p>
<p>源码链接：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day22-ThreadPool">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day22-ThreadPool</a></p>
<p>视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/02/07/concpp26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/02/07/concpp26/" itemprop="url">线程池原理和实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-02-07T16:41:09+08:00">
                2024-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程池是一种并发编程的技术，用于有效地管理和复用线程资源。它由一组预先创建的线程组成，这些线程可以在需要时执行任务，并在任务完成后返回线程池中等待下一个任务。</p>
<p>线程池的主要目的是避免反复创建和销毁线程的开销，以及有效地控制并发线程的数量。通过使用线程池，可以降低系统的负载，并提高任务执行的效率。</p>
<p>以下是线程池的一些关键特点：</p>
<ol>
<li>线程池包含一个线程队列和任务队列，任务队列用于存储待执行的任务。</li>
<li>线程池在启动时会创建一定数量的线程，并将它们放入线程队列中。</li>
<li>当有任务需要执行时，线程池从任务队列中获取任务，并将其分配给空闲的线程执行。</li>
<li>执行完任务的线程会继续等待下一个任务的到来，而不是被销毁。</li>
<li>如果任务队列为空，线程池中的线程可以进入睡眠状态，减少资源占用。</li>
<li>线程池可以限制同时执行的线程数量，避免过多的并发线程导致系统负载过高。</li>
</ol>
<p>使用线程池有以下几个优点：</p>
<ol>
<li>提高性能：通过复用线程，避免了线程创建和销毁的开销，提高了任务执行的效率。</li>
<li>资源控制：线程池可以限制并发线程的数量，避免系统负载过高，保护系统资源。</li>
<li>提高响应性：线程池可以在任务到来时立即进行处理，减少了任务等待的时间，提高了系统的响应速度。</li>
<li>简化编程：使用线程池可以将任务的提交和执行分离，简化了并发编程的复杂性。</li>
</ol>
<p>需要注意的是，在使用线程池时，需要合理设置线程池的大小，避免线程过多导致资源浪费，或线程过少导致任务等待的时间过长。</p>
<h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><p>首先我不希望线程池被拷贝，我希望它能以单例的形式在需要的地方调用, 那么单例模式就需要删除拷贝构造和拷贝赋值，所以我设计一个基类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoneCopy</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">NoneCopy</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">NoneCopy</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NoneCopy</span>(<span class="type">const</span> NoneCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NoneCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoneCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后让线程池ThreadPool类继承NoneCopy, 这样ThreadPool也就不支持拷贝构造和拷贝赋值了，拷贝构造和拷贝赋值的前提是其基类可以拷贝构造和赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> : <span class="keyword">public</span> NoneCopy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> ThreadPool ins;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先实现了instance函数，该函数是一个静态成员函数，返回局部的静态实例ins. </p>
<p>我们之前在单例模式中讲过，函数内局部的静态变量，其生命周期和进程同步，但是可见度仅在函数内部。</p>
<p>局部静态变量只会在第一次调用这个函数时初始化一次。故可以作为单例模式。这种模式在C++ 11之前是不安全的，因为各平台编译器实现规则可能不统一导致多线程会生成多个实例。</p>
<p>但是C++ 11过后，语言层面对其优化保证了多个线程调用同一个函数只会生成一个实例，所以C++ 11过后我们可以放心使用。</p>
<p>接下来考虑构造函数，我们说过线程池需要线程队列和任务队列，所以这两个队列要在构造函数中完成构造，线程队列我们可以用一个vector存储，任务队列因为要保证先进先出，所以用queue结构即可。</p>
<p>因为任务队列要有通用性，所以我们规定任务队列中存储的类型为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Task = std::packaged_task&lt;<span class="built_in">void</span>()&gt;;</span><br></pre></td></tr></table></figure>
<p>我们在ThreadPool中添加如下成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_int          thread_num_;</span><br><span class="line">std::queue&lt;Task&gt;         tasks_;</span><br><span class="line">std::vector&lt;std::thread&gt; pool_;</span><br><span class="line">std::atomic_bool         stop_;</span><br></pre></td></tr></table></figure>
<p>其中 tasks_ 表示任务队列， pool_表示线程队列， thread_num_表示空闲的线程数, stop_表示线程池是否退出。</p>
<p>那我们可以实现线程池的构造函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">unsigned</span> <span class="type">int</span> num = std::thread::<span class="built_in">hardware_concurrency</span>())</span><br><span class="line">    : <span class="built_in">stop_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)</span><br><span class="line">        thread_num_ = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        thread_num_ = num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在构造函数中初始化停止标记为false，初始化线程数默认为硬件允许的物理并行核数。然后调用了start函数。</p>
<p>start函数主要的功能为启动线程并且将线程放入vector中管理，线程的回调函数基本功能就是从任务队列中消费数据，如果队列中有任务则pop出任务并执行，否则线程需要挂起。在部分初学者实现的线程池当中会采用循环等待的方式(如果队列为空则继续循环)，这种方式会造成线程忙等，进而引发资源的浪费。</p>
<p>所以我们现在还需要给ThreadPool添加两个成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex               cv_mt_;</span><br><span class="line">std::condition_variable  cv_lock_;</span><br></pre></td></tr></table></figure>
<p>分别表示互斥量和条件变量，用来控制线程的休眠和唤醒。</p>
<p>那我们实现start函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num_; ++i) &#123;</span><br><span class="line">        pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;stop_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">                Task task;</span><br><span class="line">                &#123;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">cv_mt</span>(cv_mt_);</span><br><span class="line">                    <span class="keyword">this</span>-&gt;cv_lock_.<span class="built_in">wait</span>(cv_mt, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop_.<span class="built_in">load</span>() || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>();</span><br><span class="line">                            &#125;);</span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>())</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                    task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">                    <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_num_--;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_num_++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pool_为线程队列，在线程队列中我们采用emplace_back直接调用线程的构造函数，将线程要处理的逻辑写成lambda表达式，从而构造线程并且将线程插入线程队列中。</p>
<p>lambda表达式内的逻辑先判断是否停止，如果停止则退出循环, 否则继续循环。</p>
<p>循环的逻辑就是每次从队列中取任务，先调用条件变量等待队列不为空，或者收到退出信号，二者只要满足其一，条件变量的wait就返回，并且继续向下走。否则条件变量wait不会返回，线程将挂起。</p>
<p>如果条件变量判断条件满足(队列不为空或者发现停止信号)，线程继续向下执行，判断如果任务队列为空则说明是因为收到停止信号所以直接返回退出，否则就说明任务队列有数据，我们取出任务队列头部的task，将空闲线程数减少1，执行task，再将空闲线程数+1.</p>
<p>接下来我们实现析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    <span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数中的stop就是要向线程发送停止信号，避免线程一直处于挂起状态(因为任务队列为空会导致线程挂起)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    cv_lock_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; td : pool_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (td.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;join thread &quot;</span> &lt;&lt; td.<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            td.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stop函数中我们将停止标记设置为true，并且调用条件变量的notify_all唤醒所有线程，并且等待所有线程退出后线程池才析构完成。</p>
<p>我们再实现一个函数提供给外部查询当前空闲的线程数，这个功能可有可无，主要是方便外部根据空闲线程数是否达到阈值派发任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">idleThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thread_num_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现了线程池处理任务的逻辑，接下来我们要封装一个接口提供给外部，支持其投递任务给线程池。</p>
<p>因为我们要投递任务给线程池，任务的功能和参数都不同，而之前我们设置的线程池执行的task类型为void(void)，返回值为void，参数为void的任务。那我们可用用参数绑定的方式将一个函数绑定为void(void)类型, 比如我们用如下操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">functionint</span><span class="params">(<span class="type">int</span> param)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;param is &quot;</span> &lt;&lt; param &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bindfunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; functionv = std::<span class="built_in">bind</span>(functionint, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">functionv</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们希望任务队列里的任务要调用functionint，以及参数为3，因为在投递任务时我们就知道任务要执行的函数和参数，所以我们可以将执行的函数和参数绑定生成参数为void的函数。</p>
<p>我们通过bindfunction将functionint绑定为一个返回值为int，参数为void的新函数functionv。而我们的任务队列要放入返回值为void，参数也为void的函数，该怎么办呢？</p>
<p>其实很简单，我们可以利用lambda表达式生成一个返回值和参数都为void的函数，函数内部调用functionv即可，有点类似于go，python等语言的闭包，但是C++的闭包是一种伪闭包，需要用值的方式捕获用到的变量。</p>
<p>比如我们将上面的函数functionint和调用的参数3打包放入队列，可以这么写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushtasktoque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; functionv = std::<span class="built_in">bind</span>(functionint, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">using</span> Task = std::packaged_task&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">	std::queue&lt;Task&gt; taskque;</span><br><span class="line">	taskque.<span class="built_in">emplace</span>([functionv]() &#123;</span><br><span class="line">		<span class="built_in">functionv</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先将functionint绑定为functionv，然后定义一个队列存储的类型为<code>std::packaged_task&lt;void()&gt;</code>, 为了防止拷贝构造的开销，我们调用队列的emplace函数，该函数接受lambda表达式直接构造任务放入了队列里。因为lambda表达式捕获了functionv的值，所以可以在内部调用functionv。</p>
<p>lambda表达式返回值为void参数也为void，所以可以直接放入任务队列。</p>
<p>接下来要一个问题，一个问题是我们投递任务，有时候投递方需要获取任务是否完成, 那我们可以利用packaged_task返回一个future给调用方，调用方在外部就可以通过future判断任务是否返回了。我们修改上面的函数，实现commit任务的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::future&lt;<span class="type">int</span>&gt; <span class="title">committask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; functionv = std::<span class="built_in">bind</span>(functionint, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">auto</span> taskf = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">int</span>(<span class="type">void</span>)&gt;&gt;(functionv);</span><br><span class="line">	<span class="keyword">auto</span> res = taskf-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="keyword">using</span> Task = std::packaged_task&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">	std::queue&lt;Task&gt; taskque;</span><br><span class="line">	taskque.<span class="built_in">emplace</span>([taskf]() &#123;</span><br><span class="line">		(*taskf)();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将functionv传递给packaged_task构造函数，构造了一个packaged_task类型的智能指针，每个人的编程风格不同，大家也可以不用智能指针，直接使用packaged_task对象，比如下面的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">void</span>)</span>&gt; <span class="title">taskf</span><span class="params">(functionv)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我构造的是packaged_task类型的智能指针，所以通过<code>taskf-&gt;get_future()</code>获取future对象res，这个res作为参数返回给外部，外部就可以通过res判断任务是否完成。</p>
<p>接下来我们定义了一个任务队列，任务队列调用emplace直接构造任务插入队列中，避免拷贝开销。参数为lambda表达式，lamba捕获taskf对象的值，在内部调用<code>(*taskf)()</code>完成任务调用。</p>
<p>上面只是通过具体的函数和参数实现了投递任务的功能，而实际情况是我们要投递各种类型的任务，以及多种类型和多个参数，该怎么实现committask函数更通用呢？</p>
<p>对于更通用的设计我们通常采用模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">std::future&lt;<span class="type">int</span>&gt; <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>上面的模板定义了两个类型，F表示可调用对象类型，可以是lambda表达式，函数，function类等， Args为可变参数模板，可以是任意种类的类型，任意数量。commit函数参数采用F和Args的右值引用，这种模板类型的右值引用也被称作万能引用类型，可以接受左值引用，也可接受右值引用，利用引用折叠技术，可以推断出f和args的最终类型。我在基础课程里讲过，这里再给大家复习一下折叠规则，假设T为模板类型，推到规则如下：</p>
<p>T&amp; &amp; =&gt; T&amp;</p>
<p>T&amp; &amp;&amp; =&gt; T&amp;</p>
<p>T&amp;&amp; &amp; =&gt; T&amp;</p>
<p>T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</p>
<p>总结一下，就是只要出现了左值引用最后折叠的结果都是左值引用，只有右值应用和右值引用折叠才能变成右值引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">Function</span>(a);</span><br><span class="line">    <span class="built_in">Function</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当我们把一个int类型的左值a传递给 Function的 T&amp;&amp; 参数t时(T为模板类型)， T被推导为int &amp; , 那么参数t整体的类型就变为int &amp; &amp;&amp; =&gt; int &amp;类型，也就是左值引用类型。</p>
<p>当我们把一个右值3传递给Function的T&amp;&amp; 参数t时，T被推导为int类型。t被推导为int &amp;&amp; 类型，也就是右值引用类型。</p>
<p>如果大家熟悉boost库，可以用boost库的<code>type_id_with_cvr</code>打印具体类型，比如我们下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">functionint</span><span class="params">(<span class="type">int</span> param)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;param is &quot;</span> &lt;&lt; param &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">std::future&lt;<span class="type">int</span>&gt; <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">		<span class="comment">// 利用Boost库打印模板推导出来的 T 类型</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;F type：&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;F&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用Boost库打印形参的类型</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;f type:&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(f)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Args type：&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;Args...&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;args type：&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(args)...&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference_collapsing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">commit</span>(functionint, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用reference_collapsing函数输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F <span class="built_in">type</span>：int (__cdecl&amp;)(int)</span><br><span class="line">f <span class="built_in">type</span>:int (__cdecl&amp;)(int)</span><br><span class="line">Args <span class="built_in">type</span>：int &amp; __ptr64</span><br><span class="line">args <span class="built_in">type</span>：int &amp; __ptr64</span><br></pre></td></tr></table></figure>
<p>可以看出F和f的类型都为函数对象的左值引用类型<code>int (__cdecl&amp;)(int)</code>，因为可变参数列表只有一个int左值类型，所以Args被推导为int &amp;类型， 同样的道理args也是int &amp;类型。</p>
<p>那如果我们换一种方式调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference_collapsing2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">commit</span>(std::<span class="built_in">move</span>(functionint), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用reference_collapsing2输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F <span class="built_in">type</span>：int __cdecl(int)</span><br><span class="line">f <span class="built_in">type</span>:int (__cdecl&amp;&amp;)(int)</span><br><span class="line">Args <span class="built_in">type</span>：int</span><br><span class="line">args <span class="built_in">type</span>：int &amp;&amp; __ptr64</span><br></pre></td></tr></table></figure>
<p>F为函数对象类型<code>int __cdecl(int)</code>, f被对段位函数对象的右值引用类型<code>int (__cdecl&amp;&amp;)(int)</code></p>
<p>Args 被推断为int类型， args被推断为int &amp;&amp; 类型。</p>
<p>所以我们就可以得出之前给大家的结论，对于模板类型参数T &amp;&amp; , 编译器会根据传入的类型为左值还是右值，将T 推断为不同的类型， 如果传入的类型为int类型的左值，则T为int&amp;类型，如果传入的类型为int类型的右值，则T为int类型。</p>
<p>模板参数介绍完了，还要介绍一下原样转发, 熟悉我视频风格的读者都知道在介绍正确做法前我会先介绍错误示范，我们先看下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_rightref</span><span class="params">(<span class="type">int</span> &amp;&amp; rparam)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_tempref</span><span class="params">(T&amp;&amp; tparam)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">use_rightref</span>(tparam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_tempref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">use_tempref</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我先给大家介绍下上面代码的调用流程，我们在<code>test_tempref</code>里调用<code>use_tempref</code>, 参数3是一个右值，所以<code>use_tempref</code>中T被推断为int类型， tparam为int &amp;&amp; 类型。我们接着将tparam传递给<code>use_rightref</code>,tparam是int &amp;&amp; 类型，刚好可以传递给<code>use_rightref</code>，然而上面的代码会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“void use_rightref(int &amp;&amp;)”: 无法将参数 1 从“T”转换为“int &amp;&amp;”</span><br></pre></td></tr></table></figure>

<p>报错的原因是我们将tparam传递给<code>use_rightref</code>的时候参数类型不匹配。在<code>use_tempref</code>中，tparam为int &amp;&amp; 类型，即int 的右值引用类型。但是将tparam传递给<code>use_rightref</code>时，tparam是作为左值传递的， 他的类型是int &amp;&amp; 类型，但是在函数<code>use_tempref</code>中tparam可以作为左值使用。这么说大家有点难理解</p>
<p>我们分开理解，左值和右值的区别</p>
<p>左值（lvalue） 是指表达式结束后依然存在的、可被取地址的数据。通俗地说，左值就是可以放在赋值符号左边的值。</p>
<p>右值（rvalue） 是指表达式结束后就不再存在的临时数据。通常是不可被取地址的临时值，例如常量、函数返回值、表达式计算结果等。在 C++11 之后，右值引用的引入使得我们可以直接操作右值。</p>
<p>我们看下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_tempref</span><span class="params">(T&amp;&amp; tparam)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">	tparam = a;</span><br><span class="line">	tparam = std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_tempref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">use_tempref</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码编译没有问题可以运行，tparam可以作为左值被赋值。所以当它作为参数传递给其他函数的时候，它也是作为左值使用的，那么传递给<code>use_rightref</code>时，就会出现int&amp;&amp; 绑定左值的情况，这在编译阶段是不允许的。</p>
<p>下面这种tparam也是被作为左值使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_tempref</span><span class="params">(<span class="type">int</span> &amp;&amp; tparam)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">	tparam = a;</span><br><span class="line">	tparam = std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_tempref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">use_tempref</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码编译也会通过的。</p>
<p>那么我们接下来要解决tparam作为左值传递给<code>use_rightref</code>报错的问题，C++ 给我们提供了原样转发功能，这个在基础中也给大家介绍过, C++ 源码对于forward的实现有两个版本，分别是将一个左值转化为一个左值或者右值，以及将一个右值转化为一个右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward an lvalue as either an lvalue or an rvalue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line">    <span class="built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为实现了两个版本，所以forward会根据传递的是左值调用第一个版本，传递的是右值调用第二个版本。</p>
<p>我们看看<code>remove_reference_t&lt;_Ty&gt;</code>的源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Ty&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type                 = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Const_thru_ref_type = <span class="type">const</span> _Ty&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Ty&amp;&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type                 = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Const_thru_ref_type = <span class="type">const</span> _Ty&amp;&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;_Ty&gt;::type;</span><br></pre></td></tr></table></figure>
<p>我们通过观察就会发现<code>remove_reference_t&lt;_Ty&gt;</code>其实是去除了<code>_Ty</code>中的引用返回内部的type.</p>
<p>所以我们forward<int>(3)时，执行<code>forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg)</code>, <code>_Ty</code>为int &amp;&amp; 类型，<code>remove_reference_t&lt;_Ty&gt;</code>为int类型. 返回的为<code>static_cast&lt;_Ty&amp;&amp;&gt;(_Arg)</code>类型，即int &amp;&amp; &amp;&amp;类型,折叠一下变为int &amp;&amp;类型。</p>
<p>同样当我们forward(a)，比如a是一个int类型的左值，则执行<code>_Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp; _Arg)</code>, <code>_Ty</code>为int &amp;类型， <code>remove_reference_t&lt;_Ty&gt;</code>为int类型， 返回值为<code>static_cast&lt;_Ty&amp;&amp;&gt;(_Arg)</code> ,即int &amp; &amp;&amp; 类型折叠为int &amp;类型。</p>
<p>所以有了这些知识，我们解决上面的编译错误可以这么干</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_rightref</span><span class="params">(<span class="type">int</span> &amp;&amp; rparam)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_tempref</span><span class="params">(T&amp;&amp; tparam)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">use_rightref</span>(std::forward&lt;T&gt;(tparam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_tempref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">use_tempref</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们回到线程池的话题，commit函数需要返回future对象，但是我们又无法在函数定义的时候提前写好返回值future的类型，那怎么办呢？</p>
<p>可以用到C++ 11的一个技术就是尾置推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; </span></span><br><span class="line"><span class="function">        std::future&lt;<span class="title">decltype</span><span class="params">(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> std::future&lt;RetType&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在commit函数返回值写成了auto,告诉编译器具体的返回类型在其后，这样编译器在加载完函数的参数f和args之后，可以推导返回值类型.</p>
<p>推导也很简单，我们通过<code>decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))</code>, decltype会根据根据表达式推断表达式的结果类型，我们用future存储这个类型，这个future就是返回值类型。</p>
<p>decltype中我们用了forward原样转发f和args，其实f不用转发，因为我们调用f是按照左值调用的，至于args原样转发是考虑f接受的参数可能是一个右值，但是这种情况其实不多，所以对于普通情形，我们写成<code>decltype(f(args...))</code>没问题的。</p>
<p>因为推导的类型我们以后还会用到，所以用了RetType来记录这个类型。</p>
<p>接下来我们给出commit的完整代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; </span></span><br><span class="line"><span class="function">std::future&lt;<span class="title">decltype</span><span class="params">(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    <span class="keyword">if</span> (stop_.<span class="built_in">load</span>())</span><br><span class="line">        <span class="keyword">return</span> std::future&lt;RetType&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">    std::future&lt;RetType&gt; ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">cv_mt</span><span class="params">(cv_mt_)</span></span>;</span><br><span class="line">        tasks_.<span class="built_in">emplace</span>([task] &#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cv_lock_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在commit中我们生成一个packaged_task&lt;RetType()&gt;类型的智能指针task，通过task获取future.</p>
<p>接下来我们加锁并且将task放入队列，但是因为task的返回类型为RetType，所以我们采用了lambda表达式捕获task，内部调用task，将这个lambda表达式放入任务队列。</p>
<p>然后通知其他线程唤醒，并且返回future。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为了测试线程池，我们可以用前文实现的快速排序的方法，将任务分段递归投递给线程池，让线程池排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::list&lt;T&gt;<span class="built_in">pool_thread_quick_sort</span>(std::list&lt;T&gt; input) &#123;</span><br><span class="line">	<span class="keyword">if</span> (input.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">	std::list&lt;T&gt; result;</span><br><span class="line">	result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">	T <span class="type">const</span>&amp; partition_val = *result.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">typename</span> std::list&lt;T&gt;::iterator divide_point =</span><br><span class="line">		std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(),</span><br><span class="line">			[&amp;](T <span class="type">const</span>&amp; val) &#123;<span class="keyword">return</span> val &lt; partition_val; &#125;);</span><br><span class="line">	std::list&lt;T&gt; new_lower_chunk;</span><br><span class="line">	new_lower_chunk.<span class="built_in">splice</span>(new_lower_chunk.<span class="built_in">end</span>(),</span><br><span class="line">		input, input.<span class="built_in">begin</span>(),</span><br><span class="line">		divide_point);</span><br><span class="line"></span><br><span class="line">	std::future&lt;std::list&lt;T&gt; &gt; new_lower = ThreadPool::<span class="built_in">instance</span>().<span class="built_in">commit</span>(pool_thread_quick_sort&lt;T&gt;, new_lower_chunk);</span><br><span class="line">	</span><br><span class="line">	<span class="function">std::list&lt;T&gt; <span class="title">new_higher</span><span class="params">(pool_thread_quick_sort(input))</span></span>;</span><br><span class="line">	result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);</span><br><span class="line">	result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower.<span class="built_in">get</span>());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再写一个测试用例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestThreadPoolSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::list&lt;<span class="type">int</span>&gt; nlist = &#123; <span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">11</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> sortlist = <span class="built_in">pool_thread_quick_sort</span>&lt;<span class="type">int</span>&gt;(nlist);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : sortlist) &#123;</span><br><span class="line">		std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 5 6 9 11</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍线程池的原理，并实现了线程池</p>
<p>源码链接：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day22-ThreadPool">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day22-ThreadPool</a></p>
<p>视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/01/29/concpp25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/29/concpp25/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-01-29T19:56:02+08:00">
                2024-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: 几种简单并行算法的实现(for_each,find以及partial_sum)<br>date: 2024-01-29 19:56:02<br>tags:  C++<br>categories: C++</p>
<hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前文介绍了几种数据划分的方式，包括按照线程数量划分，按照递归方式划分，以及按照任务类型划分等。</p>
<p>本文结合之前的划分方式，基于stl的find, for_each以及partial_sum等算法实现并行版本。</p>
<h2 id="并行版本for-each"><a href="#并行版本for-each" class="headerlink" title="并行版本for_each"></a>并行版本for_each</h2><p>实现并行的for_each，最简单的方式就是将数据划分，每个线程分别处理一段连续的数据即可。</p>
<p>在介绍并行版本之前，我们先实现一个管理线程 的类join_threads，用来管控线程防止线程过早退出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">join_threads</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt;&amp; threads;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">join_threads</span><span class="params">(std::vector&lt;std::thread&gt;&amp; threads_)</span> :</span></span><br><span class="line"><span class="function">        threads(threads_)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">join_threads</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i].<span class="built_in">joinable</span>())</span><br><span class="line">                threads[i].<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来我们实现第一种方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for_each</span><span class="params">(Iterator first, Iterator last, Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads =</span><br><span class="line">        (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads =</span><br><span class="line">        std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads =</span><br><span class="line">        std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; <span class="built_in">futures</span>(num_threads - <span class="number">1</span>);   <span class="comment">//⇽-- - 1</span></span><br><span class="line">        <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">(<span class="type">void</span>)</span>&gt; <span class="title">task</span><span class="params">( <span class="comment">// ⇽-- - 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">            [=]()</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::for_each(block_start, block_end, f);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">        futures[i] = task.<span class="built_in">get_future</span>();</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task));    <span class="comment">//⇽-- - 3</span></span><br><span class="line">            block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(block_start, last, f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        futures[i].<span class="built_in">get</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 我们规定如果处理的数量不超过25个则用单线程。否则根据处理的数量划分任务，计算开辟的线程数，如果要开辟的线程数大于内核线程的数量，则以内核线程数为准。</p>
<p>2 根据实际开辟的线程数num_threads计算每个线程处理的块大小。并且初始化两个vector，分别用来存储处理结果的future和处理任务的线程。</p>
<p>3 我们在(2处)代码生成了一个任务task，然后获取future赋值给vector对应下标为i的future元素，并且把任务绑定给对应下标为i的thread。</p>
<p>4 numthreads-1个线程并行处理for_each，剩下的主线程处理余下的for_each，最后通过futures.get汇总</p>
<p>第二种划分方式是我们采取递归的方式，我们知道采用递归的方式无法提前开辟准确数量的线程，我们采用async帮我们完成这个任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_for_each</span><span class="params">(Iterator first, Iterator last, Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; (<span class="number">2</span> * min_per_thread))</span><br><span class="line">    &#123;</span><br><span class="line">        std::for_each(first, last, f);    <span class="comment">//⇽-- - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Iterator <span class="type">const</span> mid_point = first + length / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//⇽-- - 2</span></span><br><span class="line">        std::future&lt;<span class="type">void</span>&gt; first_half =   std::<span class="built_in">async</span>(&amp;async_for_each&lt;Iterator, Func&gt;,</span><br><span class="line">                first, mid_point, f);</span><br><span class="line">        <span class="comment">//⇽-- - 3</span></span><br><span class="line">        <span class="built_in">async_for_each</span>(mid_point, last, f); </span><br><span class="line">        <span class="comment">// ⇽-- - 4</span></span><br><span class="line">        first_half.<span class="built_in">get</span>();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async可以帮助我们判断是否需要开启线程还是自动串行执行。每次我们将要处理的数据一分为2，前半部分交给一个async开辟线程处理，后半部分在本线程处理。而所谓的本线程不一定是主线程，因为我们通过async递归执行parallel_for_each，也就相当于在一个线程里独立执行了。</p>
<h2 id="find的并行实现"><a href="#find的并行实现" class="headerlink" title="find的并行实现"></a>find的并行实现</h2><p>find 的并行查找方式还是分两种，一种是将要查找的区间划分为几个段，每段交给一个线程查找。</p>
<p>另一种是采用递归的方式每次折半，前半部分交给一个线程查找，后半部分留在本线程查找。</p>
<p>我们先说第一种</p>
<p>find比较特殊，我们要防止线程忙等待，也要防止线程在其他线程已经查找到值后做无谓的浪费。可以用一个共享的全局atomic变量表示是否找到目标。</p>
<p>因为主线程要获取某个线程查找到的迭代器位置，所以我们用promise 设置 value为迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> MatchType&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">parallel_find</span><span class="params">(Iterator first, Iterator last, MatchType match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">find_element</span>    <span class="comment">//⇽-- - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator begin,Iterator end,</span></span></span><br><span class="line"><span class="params"><span class="function">                        MatchType match,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::promise&lt;Iterator&gt;*result,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::atomic&lt;<span class="type">bool</span>&gt;*done_flag)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; (begin != end) &amp;&amp; !done_flag-&gt;<span class="built_in">load</span>(); ++begin)    <span class="comment">//⇽-- - 2</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (*begin == match)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result-&gt;<span class="built_in">set_value</span>(begin);    <span class="comment">//⇽-- - 3</span></span><br><span class="line">                        done_flag-&gt;<span class="built_in">store</span>(<span class="literal">true</span>);    <span class="comment">//⇽-- - 4</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (...)    <span class="comment">//⇽-- - 5</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    result-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());    <span class="comment">//⇽-- - 6</span></span><br><span class="line">                    done_flag-&gt;<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">catch</span> (...)    <span class="comment">//⇽-- - 7</span></span><br><span class="line">                &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;</span><br><span class="line">    std::promise&lt;Iterator&gt; result;    <span class="comment">//⇽-- - 8</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">done_flag</span><span class="params">(<span class="literal">false</span>)</span></span>;     <span class="comment">//⇽-- - 9</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>; <span class="comment">//⇽-- - 10</span></span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">        Iterator block_start = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterator block_end = block_start;</span><br><span class="line">            std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">            <span class="comment">// ⇽-- - 11</span></span><br><span class="line">            threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">find_element</span>(),  block_start, block_end, match, &amp;result, &amp;done_flag);</span><br><span class="line">            block_start = block_end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ⇽-- - 12</span></span><br><span class="line">        <span class="built_in">find_element</span>()(block_start, last, match, &amp;result, &amp;done_flag);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⇽-- - 13</span></span><br><span class="line">    <span class="keyword">if</span> (!done_flag.<span class="built_in">load</span>())   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//⇽-- - 14</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">get_future</span>().<span class="built_in">get</span>();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 find_element重载了()运算符，接受四个参数，分别是迭代器的开始，迭代起的结束，要查找的数值，以及用来通知外部的promise，还有线程之间用来检测是否有某个线程完成查找的原子变量。</p>
<p>2  find_element重载()的逻辑就是查找这个区间内满足某个值的位置，并将这个位置的迭代起设置到promise中，然后将完成的原子变量标记为true。</p>
<p>说第二种方式，利用递归折半查找，我们可以用async帮助我们完成并行任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> MatchType&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">parallel_find_impl</span><span class="params">(Iterator first, Iterator last, MatchType match,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::atomic&lt;<span class="type">bool</span>&gt;&amp; done)</span>   <span class="comment">// ⇽-- - 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;   <span class="comment">// ⇽-- - 2</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; (<span class="number">2</span> * min_per_thread))    <span class="comment">//⇽-- - 3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; (first != last) &amp;&amp; !done.<span class="built_in">load</span>(); ++first)     <span class="comment">//⇽-- - 4</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (*first == match)</span><br><span class="line">                &#123;</span><br><span class="line">                    done = <span class="literal">true</span>;    <span class="comment">//⇽-- - 5</span></span><br><span class="line">                    <span class="keyword">return</span> first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> last;    <span class="comment">//⇽-- - 6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//⇽-- - 7</span></span><br><span class="line">            Iterator <span class="type">const</span> mid_point = first + (length / <span class="number">2</span>);   </span><br><span class="line">            <span class="comment">//⇽-- - 8</span></span><br><span class="line">            std::future&lt;Iterator&gt; async_result = std::<span class="built_in">async</span>(&amp;parallel_find_impl&lt;Iterator,MatchType&gt;,    </span><br><span class="line">                           mid_point,last,match,std::<span class="built_in">ref</span>(done));</span><br><span class="line">            <span class="comment">//⇽-- - 9</span></span><br><span class="line">            Iterator <span class="type">const</span> direct_result = <span class="built_in">parallel_find_impl</span>(first,mid_point,match,done); </span><br><span class="line">            <span class="comment">//⇽-- - 10</span></span><br><span class="line">            <span class="keyword">return</span> (direct_result == mid_point) ?async_result.<span class="built_in">get</span>() : direct_result;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ⇽-- - 11</span></span><br><span class="line">        done = <span class="literal">true</span>;   </span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> MatchType&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">parallel_find_async</span><span class="params">(Iterator first, Iterator last, MatchType match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">done</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">//⇽-- - 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parallel_find_impl</span>(first, last, match, done);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 并行查找的方式种我们先根据长度是否小于50决定是否开启并行任务，如果小于50则采取单线程方式。</p>
<p>2  如果采用并行的方式，我们将长度折半，前半部分交给async，后半部分交给本线程。</p>
<p>3 最后我们在主线程中汇合，获取结果。</p>
<h2 id="partial-sum并行版本"><a href="#partial-sum并行版本" class="headerlink" title="partial_sum并行版本"></a>partial_sum并行版本</h2><p>C++ 提供了累计计算求和的功能，比如一个vector中存储的数据为{1,2,3},那么经过计算，第一个元素仍然为1，第二个元素为1+2， 第三个元素为1+2+3，结果为{1,3,6}.</p>
<p>关于并行版本我们可以这么思考，假设元数组为{1,2,3,4,5,6,7},那我们可以划分为三个部分，第一部分为{1,2,3}交给第一个线程处理, 第二部分{4,5,6}交给第二个线程处理，7交给本线程处理。</p>
<p>但是我们要考虑的一个问题是线程2要用到线程1最后计算的结果，线程1计算后{1,3,6}，线程2需要用到6做累加，我们可以先让线程1计算出第3个元素值6，再将这个6传递给线程2，剩下的就可以并行计算了。同样的道理本线程要处理最后一个元素的累加结果，他需要等到线程2处理完第6个元素的值。</p>
<p>所以基本思路是每个线程优先处理分区的最后一个元素，通过promise设置给其他线程，在这个阶段线程之间是串行的，等到所有线程都开始计算其他位置后就是并行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_partial_sum</span><span class="params">(Iterator first, Iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process_chunk</span>    <span class="comment">//⇽-- - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator begin, Iterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">            std::future&lt;value_type&gt;* previous_end_value,</span></span></span><br><span class="line"><span class="params"><span class="function">            std::promise&lt;value_type&gt;* end_value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Iterator end = last;</span><br><span class="line">                ++end;</span><br><span class="line">                std::<span class="built_in">partial_sum</span>(begin, end, begin);    <span class="comment">//⇽-- - 2</span></span><br><span class="line">                <span class="keyword">if</span> (previous_end_value)    <span class="comment">//⇽-- - 3</span></span><br><span class="line">                &#123;</span><br><span class="line">                    value_type addend = previous_end_value-&gt;<span class="built_in">get</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">                    *last += addend;   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">                    <span class="keyword">if</span> (end_value)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_value-&gt;<span class="built_in">set_value</span>(*last);    <span class="comment">//⇽-- - 6</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// ⇽-- - 7</span></span><br><span class="line">                    std::for_each(begin, last, [addend](value_type&amp; item)</span><br><span class="line">                        &#123;</span><br><span class="line">                            item += addend;</span><br><span class="line">                        &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (end_value)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// ⇽-- - 8</span></span><br><span class="line">                    end_value-&gt;<span class="built_in">set_value</span>(*last);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (...)  <span class="comment">// ⇽-- - 9</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (end_value)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_value-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());   <span class="comment">// ⇽-- - 10</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span>;   <span class="comment">// ⇽-- - 11</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;     <span class="comment">//⇽-- - 12</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;   <span class="comment">// ⇽-- - 13</span></span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::promise&lt;value_type&gt; &gt; <span class="built_in">end_values</span>(num_threads - <span class="number">1</span>);   <span class="comment">// ⇽-- - 14</span></span><br><span class="line">        </span><br><span class="line">        std::vector&lt;std::future&lt;value_type&gt; &gt; previous_end_values;   <span class="comment">// ⇽-- - 15</span></span><br><span class="line">        previous_end_values.<span class="built_in">reserve</span>(num_threads - <span class="number">1</span>);   <span class="comment">// ⇽-- - 16</span></span><br><span class="line">        <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">        Iterator block_start = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Iterator block_last = block_start;</span><br><span class="line">            std::<span class="built_in">advance</span>(block_last, block_size - <span class="number">1</span>);   <span class="comment">// ⇽-- - 17</span></span><br><span class="line">            <span class="comment">// ⇽-- - 18</span></span><br><span class="line">            threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">process_chunk</span>(), block_start, block_last,</span><br><span class="line">                (i != <span class="number">0</span>) ? &amp;previous_end_values[i - <span class="number">1</span>] : <span class="number">0</span>,</span><br><span class="line">                &amp;end_values[i]);</span><br><span class="line">            block_start = block_last;</span><br><span class="line">            ++block_start;   <span class="comment">// ⇽-- - 19</span></span><br><span class="line">            previous_end_values.<span class="built_in">push_back</span>(end_values[i].<span class="built_in">get_future</span>());   <span class="comment">// ⇽-- - 20</span></span><br><span class="line">        &#125;</span><br><span class="line">        Iterator final_element = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(final_element, std::<span class="built_in">distance</span>(block_start, last) - <span class="number">1</span>);   <span class="comment">// ⇽-- - 21</span></span><br><span class="line">        <span class="comment">// ⇽-- - 22</span></span><br><span class="line">        <span class="built_in">process_chunk</span>()(block_start, final_element, (num_threads &gt; <span class="number">1</span>) ? &amp;previous_end_values.<span class="built_in">back</span>() : <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 定义了process_chunk类，重载了()运算符，在重载的逻辑里我们先计算区间内的partial_sum累计求和(2处)</p>
<p>2 因为我们处理的区间不一定是首个区间，也就是他还需要加上前面区间处理得出的最后一个元素的值，所以我们通过previouse_end_value判断本区间不是首个区间，并且加上前面处理的结果。优先将最后一个值计算出来设置给promise。然后在利用for_each遍历计算其他位置的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何并行设计stl的相关算法，读者有好的思路可以互相交流一下。</p>
<p>测试代码和项目代码链接：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day21-ParallenAlgorithm">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day21-ParallenAlgorithm</a></p>
<p>视频链接</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.limerence2017.com/2024/01/13/concpp24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋恋风辰的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/13/concpp24/" itemprop="url">线程间切分任务的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-01-13T22:45:16+08:00">
                2024-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="按数量切分"><a href="#按数量切分" class="headerlink" title="按数量切分"></a>按数量切分</h3><p>对于大量处理的数据，可以按照任务数量区分，简单来说如果我们要处理n个任务，总计有m个线程，那么我们可以简单的规划每个线程处理n/m个任务。</p>
<p>如下图</p>
<p><img src="https://cdn.llfc.club/1705459243909.jpg" alt="https://cdn.llfc.club/1705459243909.jpg"></p>
<p>这种方式用来划分大量相同任务时可以采用，但是有些逻辑并不是完全可以靠数量划分的，比如递归逻辑。</p>
<h3 id="递归划分"><a href="#递归划分" class="headerlink" title="递归划分"></a>递归划分</h3><p>前文我们提及了快速排序的并行实现，包括利用async和线程池的方式。</p>
<p>快速排序算法含有两大基本步骤：</p>
<p>选定一个元素为比较的基准元素；</p>
<p>将数据集按大小划分为前后两部分，重新构成新序列，再针对这两个部分递归排序。</p>
<p>数据划分无法从一开始就并行化，因为数据只有经过处理后，我们才清楚它会归入哪个部分。</p>
<p>若我们要并行化这个算法，就需要利用递归操作的固有性质。</p>
<p>每层递归均会涉及更多的quick_sort()函数调用，因为我们需对基准元素前后两部分都进行排序。</p>
<p>由于这些递归调用所访问的数据集互不相关，因此它们完全独立，正好吻合并发程序的首选执行方式。</p>
<p>下图展示了以递归方式划分数据。</p>
<p><img src="https://cdn.llfc.club/1705461120545.jpg" alt="https://cdn.llfc.club/1705461120545.jpg"></p>
<p>在早期我们实现并行递归的快速排序，那段代码每深入一层递归，都借std::async()生成新的异步任务处理前半部分数据，而后部分则继续用本线程计算后半部分数据。</p>
<p>我们通过std::async()让C++线程库自主决定，是另起新线程执行新任务，还是在原线程上同步运行。</p>
<p>这点相当重要：假设排序操作的数据集非常庞大，若每次递归都生成新线程，则势必令线程数目激增。</p>
<p>我们将通过后文的性能分析了解到，太多线程反而可能令应用程序变慢。</p>
<p>如果数据集着实庞大，还有可能消耗殆尽全部线程。按上述递归方式来切分数据是不错的思路，但需约束线程数目的增长，不可任其数目无限膨胀。</p>
<p>此例比较简单，std::async()足以应付，但它不是唯一选择。</p>
<p>后来我们觉得开辟过多的线程并不合适，采用了线程池。</p>
<p>并发编程的作者提出的另一种做法是，根据std::hardware_concurrency()函数的返回值设定线程的数目，实现了accumulate()的并行版本。</p>
<p>接着，我们采用之前实现的线程安全的栈容器，将尚未排序的数据段压入其中，而不是启动新线程以执行递归调用。</p>
<p>若某线程无所事事，或因全部数据段均已处理妥当，或因它正等着另一数据段完成排序，若是后者，该线程即从栈容器取出所等的数据段自行排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_safe_stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sorter</span>  <span class="comment">//1  </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">chunk_to_sort</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::list&lt;T&gt; data;</span><br><span class="line">		std::promise&lt;std::list&lt;T&gt; &gt; promise;</span><br><span class="line">	&#125;;</span><br><span class="line">	thread_safe_stack&lt;chunk_to_sort&gt; chunks;    <span class="comment">//⇽-- - 2</span></span><br><span class="line">	std::vector&lt;std::thread&gt; threads;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">const</span> max_thread_count;</span><br><span class="line">	std::atomic&lt;<span class="type">bool</span>&gt; end_of_data;</span><br><span class="line">	<span class="built_in">sorter</span>() :</span><br><span class="line">		<span class="built_in">max_thread_count</span>(std::thread::<span class="built_in">hardware_concurrency</span>() - <span class="number">1</span>),</span><br><span class="line">		<span class="built_in">end_of_data</span>(<span class="literal">false</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">sorter</span>()    <span class="comment">//⇽-- - 4</span></span><br><span class="line">	&#123;</span><br><span class="line">		end_of_data = <span class="literal">true</span>;     <span class="comment">//⇽-- - 5</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			threads[i].<span class="built_in">join</span>();    <span class="comment">//⇽-- - 6</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">try_sort_chunk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::shared_ptr&lt;chunk_to_sort&gt; chunk = chunks.<span class="built_in">try_pop</span>();    <span class="comment">//⇽-- - 7</span></span><br><span class="line">		<span class="keyword">if</span> (chunk)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sort_chunk</span>(chunk);    <span class="comment">//⇽-- - 8</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">std::list&lt;T&gt; <span class="title">do_sort</span><span class="params">(std::list&lt;T&gt;&amp; chunk_data)</span>    <span class="comment">//⇽-- - 9</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (chunk_data.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> chunk_data;</span><br><span class="line">		&#125;</span><br><span class="line">		std::list&lt;T&gt; result;</span><br><span class="line">		result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),chunk_data,chunk_data.<span class="built_in">begin</span>());</span><br><span class="line">		T <span class="type">const</span>&amp; partition_val = *result.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">typename</span> std::list&lt;T&gt;::iterator divide_point =  <span class="comment">//⇽-- - 10</span></span><br><span class="line">			std::<span class="built_in">partition</span>(chunk_data.<span class="built_in">begin</span>(),chunk_data.<span class="built_in">end</span>(),</span><br><span class="line">						   [&amp;](T <span class="type">const</span>&amp; val) &#123;<span class="keyword">return</span> val &lt; partition_val; &#125;);</span><br><span class="line">		chunk_to_sort new_lower_chunk;</span><br><span class="line">		new_lower_chunk.data.<span class="built_in">splice</span>(new_lower_chunk.data.<span class="built_in">end</span>(),</span><br><span class="line">									chunk_data,chunk_data.<span class="built_in">begin</span>(),</span><br><span class="line">									divide_point);</span><br><span class="line">		std::future&lt;std::list&lt;T&gt; &gt; new_lower =</span><br><span class="line">			new_lower_chunk.promise.<span class="built_in">get_future</span>();</span><br><span class="line">		chunks.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_lower_chunk));   <span class="comment">// ⇽-- - 11</span></span><br><span class="line">		<span class="keyword">if</span> (threads.<span class="built_in">size</span>() &lt; max_thread_count)    <span class="comment">// ⇽-- - 12</span></span><br><span class="line">		&#123;</span><br><span class="line">			threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;sorter&lt;T&gt;::sort_thread,<span class="keyword">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">std::list&lt;T&gt; <span class="title">new_higher</span><span class="params">(do_sort(chunk_data))</span></span>;</span><br><span class="line">		result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(),new_higher);</span><br><span class="line">		<span class="keyword">while</span> (new_lower.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>)) !=</span><br><span class="line">			  std::future_status::ready)    <span class="comment">//⇽-- - 13</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">try_sort_chunk</span>();   <span class="comment">// ⇽-- - 14</span></span><br><span class="line">		&#125;</span><br><span class="line">		result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),new_lower.<span class="built_in">get</span>());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sort_chunk</span><span class="params">(std::shared_ptr&lt;chunk_to_sort &gt; <span class="type">const</span>&amp; chunk)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chunk-&gt;promise.<span class="built_in">set_value</span>(<span class="built_in">do_sort</span>(chunk-&gt;data));    <span class="comment">//⇽-- - 15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sort_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!end_of_data)    <span class="comment">//⇽-- - 16</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">try_sort_chunk</span>();    <span class="comment">// ⇽-- - 17</span></span><br><span class="line">			<span class="comment">//交出时间片</span></span><br><span class="line">			std::this_thread::<span class="built_in">yield</span>();    <span class="comment">//⇽-- - 18</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们实现一个函数调用上面的封装快速排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">parallel_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span>    <span class="comment">//⇽-- - 19</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (input.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">	sorter&lt;T&gt; s;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">do_sort</span>(input);    <span class="comment">//⇽-- - 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中，parallel_quick_sort()函数(19处)把绝大部分功能委托给sorter类(1处)，后者通过栈容器管理待排序的数据段(2处)，并集中管控多个线程以并发执行任务(3处)，从而以便捷的操作方式给出了代码实现。</p>
<p>本例中，主要工作由成员函数do_sort()负责(9处)，它借标准库的std::partition()函数完成数据分段(10处)。</p>
<p>do_sort()将新划分出来的数据段压入栈容器(11处)，但没有为每个数据段都专门生成新线程，而仅当仍存在空闲的处理器时(12处)才生成新线程。</p>
<p>因为划分出的前半部分数据可能会由别的线程处理，所以我们需要等待它完成排序而进入就绪状态(13处)。</p>
<p>如果当前线程是整个程序中仅有的线程，或者其他线程都正忙于别的任务，那么这一等待行为则需妥善处理，在当前线程的等待期间，我们让它试着从栈容器取出数据进行处理(14处)。</p>
<p>try_sort_chunk()先从栈容器弹出一段数据(7处)并对其进行排序(8处)，再把结果存入附属该段的promise中(15处)，使之准备就绪，以待提取。</p>
<p>向栈容器压入数据段与取出相关结果相互对应，两项操作均由同一个线程先后执行(11和12处)。</p>
<p>只要标志end_of_data没有成立（16处），各线程便反复循环，尝试对栈内数据段进行排序17。</p>
<p>每个线程在两次检测标志之间进行让步（18处），好让别的线程有机会向栈容器添加数据段。这段代码由sorter类的析构函数汇合各个线程（4处）。</p>
<p>do_sort()将在全部数据段都完成排序后返回（即便许多工作线程仍在运行），主线程进而从parallel_quick_sort()的调用返回20，并销毁sorter对象。其析构函数将设置标志end_of_data成立（5处），然后等待全部线程结束（6处）。标志的成立使得线程函数内的循环终止（16处）。</p>
<h2 id="按照工作类别划分任务"><a href="#按照工作类别划分任务" class="headerlink" title="按照工作类别划分任务"></a>按照工作类别划分任务</h2><p>单线程应用程序照样需要同时运行多个任务，而某些程序即便正忙于手头的任务，也需随时处理外部输入的事件（譬如用户按键或网络数据包传入）。这些情形都与单一功能的设计原则矛盾，必须妥善处理。若我们按照单线程思维手动编写代码，那最后很可能混成“大杂烩”：先执行一下任务甲，再执行一下任务乙，接着检测按键事件，然后检查传入的网络数据包，又回头继续执行任务甲，如此反复循环。这就要求任务甲保存状态，好让控制流程按周期返回主循环，结果令相关的代码复杂化。如果向循环加入太多任务，处理速度便可能严重放缓，让用户感觉按键的响应时间过长。相信读者肯定见过这种操作方式的极端表现：我们让某个应用程序处理一些任务，其用户界面却陷入僵滞，到任务完成后才恢复。</p>
<p>只要把每个任务都放在独立的线程上运行，操作系统便会替我们“包办”切换动作。因此，任务甲的代码可专注于执行任务，我们无须再考虑保存状态和返回主循环，也不必纠结间隔多久就得这样操作。</p>
<p>假定每项任务都相互独立，且各线程无须彼此通信，那么该构想即可轻而易举地实现。可惜往往事与愿违。即便经过良好的设计，后台任务也常常按用户要求执行操作，它们需在完成时通过某种方式更新界面，好让用户知晓。反之，若用户想取消任务，就要通过界面线程向后台任务发送消息，告知它停止。</p>
<p>所以各个任务线程中要提供互相通知的接口，这种思想和Actor模式不谋而合。</p>
<p>当然我们划分任务给不同的线程也要注意精细程度，比如两个线程要做的功能中某个环节是一个共有的功能，那么我们需要将这个功能整合到一个单线程上。我们可以理解在一些高并发的设计中，即便某些模块是高并发，但是耦合度很高的逻辑处理还是采用单线程方式，我们之前设计网络i服务器是逻辑处理也是单线程，但是我们可以根据功能做区分再分化为不同的线程，这就类似于Actor设计模式了。</p>
<p>假设有这样一个情形，我们实现一个系统控制机器中各部件的运动，A部件运动结束后通知B部件运动，B部件结束后通知C部件继续运动等，C运动结束后再通知A部件继续运动。</p>
<p>按照任务划分的模式，A，B，C分别运行在不同的线程中处理不同的任务，而任务又要以流水线A-&gt;B-&gt;C的方式运作。</p>
<p>我们可以这样抽象出一个Actor类，它包含消息的投递，消息的处理，以及消息队列的管理，并且它是一个单例类，全局唯一。</p>
<p>先实现这个基本的模板单例类, 这期间会用到CRTP技术，CRTP：一个继承 以自己为模板参数的模板类 的类。</p>
<p>CRTP 奇特递归模板技术， Curiously recurring template pattern。</p>
<p>模板单例类实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadSafeQue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> QueType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorSingle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> ClassType&amp; <span class="title">Inst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> ClassType as;</span><br><span class="line">		<span class="keyword">return</span> as;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~ <span class="built_in">ActorSingle</span>()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PostMsg</span><span class="params">(<span class="type">const</span> QueType&amp; data)</span> </span>&#123;</span><br><span class="line">		_que.<span class="built_in">push</span>(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">ActorSingle</span>():_bstop(<span class="literal">false</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ActorSingle</span>(<span class="type">const</span> ActorSingle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">ActorSingle</span>(ActorSingle&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	ActorSingle&amp; <span class="keyword">operator</span> = (<span class="type">const</span> ActorSingle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	std::atomic&lt;<span class="type">bool</span>&gt; _bstop;</span><br><span class="line">	ThreadSafeQue&lt;QueType&gt;  _que;</span><br><span class="line">	std::thread _thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模板单例类包含了原子变量_bstop控制线程是否停止</p>
<p>包含了_que用来存储要处理的信息，这是一个线程安全的队列。</p>
<p>_thread是要处理任务的线程。</p>
<p>线程安全队列我们之前有实现过，但是还需要稍微改进下以满足接受外部停止的通知。</p>
<p>我们给ThreadSafeQue添加一个原子变量_bstop表示线程停止的标记</p>
<p>在需要停止等待的时候我们调用如下通知函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NotifyStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_bstop.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">	data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待消息的函数需要补充根据停止条件去返回的逻辑,目的为防止线程被一直挂起</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">	data_cond.<span class="built_in">wait</span>(head_lock,[&amp;] &#123;<span class="built_in">return</span> (_bstop.<span class="built_in">load</span>() == <span class="literal">true</span>) || (head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>()); &#125;);</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改wait_pop_head，根据停止条件返回空指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_bstop.<span class="built_in">load</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待返回数据的逻辑也稍作修改，因为有可能是接收到停止信号后等待返回，所以此时返回空指针即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">WaitAndPop</span><span class="params">()</span> <span class="comment">//  &lt;------3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;node&gt; <span class="type">const</span> old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">	<span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们要实现一个ClassA 处理A类任务，可以这么做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ActorSingle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClassB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MsgClassA</span> &#123;</span><br><span class="line">	std::string name;</span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> MsgClassA&amp; ca) &#123;</span><br><span class="line">		os &lt;&lt; ca.name;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> : <span class="keyword">public</span> ActorSingle&lt;ClassA, MsgClassA&gt; &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ActorSingle</span>&lt;ClassA, MsgClassA&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">ClassA</span>() &#123;</span><br><span class="line">		_bstop = <span class="literal">true</span>;</span><br><span class="line">		_que.<span class="built_in">NotifyStop</span>();</span><br><span class="line">		_thread.<span class="built_in">join</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ClassA destruct &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealMsg</span><span class="params">(std::shared_ptr&lt;MsgClassA&gt; data)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;class A deal msg is &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		MsgClassB msga;</span><br><span class="line">		msga.name = <span class="string">&quot;llfc&quot;</span>;</span><br><span class="line">		ClassB::<span class="built_in">Inst</span>().<span class="built_in">PostMsg</span>(msga);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">ClassA</span>()&#123;</span><br><span class="line">		_thread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">for</span> (; (_bstop.<span class="built_in">load</span>() == <span class="literal">false</span>);) &#123;</span><br><span class="line">				std::shared_ptr&lt;MsgClassA&gt; data = _que.<span class="built_in">WaitAndPop</span>();</span><br><span class="line">				<span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">DealMsg</span>(data);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;ClassA thread exit &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们利用CRTP模式让ClassA继承了以ClassA为类型的模板，然后在DealMsg函数内部调用了 ClassB的投递消息，将任务B交给另一个线程处理。</p>
<p>关于ClassB的实现方式和ClassA类似，然后我们在ClassB的DealMsg中调用ClassC的PostMsg将消息投递给C的线程处理。</p>
<p>达到的效果就是</p>
<p>A-&gt;B-&gt;C</p>
<p>我们在主函数调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClassA.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MsgClassA msga;</span><br><span class="line">    msga.name = <span class="string">&quot;llfc&quot;</span>;</span><br><span class="line">    ClassA::<span class="built_in">Inst</span>().<span class="built_in">PostMsg</span>(msga);</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main process exited!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> deal msg is llfc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> deal msg is llfc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> deal msg is llfc</span><br><span class="line">main process exited!</span><br><span class="line">ClassC thread exit</span><br><span class="line">ClassC destruct</span><br><span class="line">ClassB thread exit</span><br><span class="line">ClassB destruct</span><br><span class="line">ClassA thread exit</span><br><span class="line">ClassA destruct</span><br></pre></td></tr></table></figure>
<p>可以看到处理的顺序是A-&gt;B-&gt;C，并且每个类都有析构和函数回收，说明我们的程序不存在内存泄漏。</p>
<p>这里要提示读者一个问题，如果A给B投递消息，而B又要给A投递消息，那么如果在A的头文件包含B的头文件，而B的头文件包含A的头文件势必会造成互引用问题，那么最好的解决方式就是在A和B的头文件中分别声明对方，在cpp文件中再包含即可。</p>
<p>上面的例子通过模板和继承的方式实现了类似Actor的收发消息的功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了线程划分任务的三种方式</p>
<p>1 按照任务的数量划分</p>
<p>2 递归划分 </p>
<p>3 按照任务的种类划分 </p>
<p>源码链接：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day20-Actor">https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day20-Actor</a></p>
<p>视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290">https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/8/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">370</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/secondtonone1" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" target="_blank" title="ZhiHu">
                    
                      <i class="fa fa-fw fa-ZhiHu"></i>ZhiHu</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恋恋风辰</span>

  
  
 
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
 
 
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
