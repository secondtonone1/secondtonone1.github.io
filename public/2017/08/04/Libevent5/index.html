<!doctype html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="C++ python 大并发网络 逆向">
  <meta name="description" content="重剑无锋，大巧不工">
  <meta name="author" content="恋恋风辰">

  
  <title>Libevent学习笔记(五) 根据例子学习bufferevent</title>
  

  <link rel="alternate" href="/atom.xml" title="恋恋风辰的个人博客" type="application/atom+xml">
  <link rel="canonical" href="http://www.limerence2017.com/2017/08/04/Libevent5/index.html">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="//at.alicdn.com/t/font_pb2xepysv85gsyvi.css">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="文章分类">文章分类</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="我和我的小伙伴">我和我的小伙伴</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="作者简介">作者简介</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-rss"></i><a href="/atom.xml" class="aside-menu-link" title="RSS">RSS</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value="" autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-houdongfangiconfont10"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          恋恋风辰
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">重剑无锋，大巧不工。</p>
      <ul class="aside-show-info">
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link" title="微信" target="_blank"><i class="aside-show-icon iconfont icon-iconfontweixin"></i></a>
          <div class="aside-show-outside aside-show-outside_1">
            <img class="aside-show-IMG aside-show-IMG_1" src="/img/weixin.png" alt="微信">
          </div>
        </li>
        <li class="aside-show-item"><a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" class="aside-show-link" title="知乎" target="_blank"><i class="aside-show-icon iconfont icon-zhihu"></i></a></li>
        <li class="aside-show-item"><a href="https://github.com/secondtonone1" class="aside-show-link" title="github" target="_blank"><i class="aside-show-icon iconfont icon-github"></i></a></li>
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link" title="QQ" target="_blank"><i class="aside-show-icon iconfont icon-qq"></i></a>
          <div class="aside-show-outside">
            <img class="aside-show-IMG" src="/img/qq.png" alt="QQ">
          </div>
        </li>
      </ul>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">Libevent学习笔记(五) 根据例子学习bufferevent</h1>
    <p class="post-meta">
      <span class="post-time">2017-08-04</span>
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <a href="/tags/Linux环境编程/"" title="Linux环境编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>Linux环境编程</a>
      
    </p>
    
  </header>
  <div class="post-content"><p>libevent中提供了一个Hello-world.c 的例子，从这个例子可以学习libevent是如何使用bufferevent的。<br>这个例子在Sample中<br><img src="/2017/08/04/Libevent5/1.png" alt="1"><br>这个例子之前讲解过，这次主要看下bufferevent的使用。<br><a id="more"></a></p>
<h2 id="第一步找到main函数"><a href="#第一步找到main函数" class="headerlink" title="第一步找到main函数"></a>第一步找到main函数</h2><p>main函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="comment">//...</span></div><div class="line">listener = evconnlistener_new_bind(base, listener_cb, (<span class="keyword">void</span> *)base,</div><div class="line">        LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</div><div class="line">        (struct sockaddr*)&amp;<span class="built_in">sin</span>,</div><div class="line">        <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line"></div><div class="line"> <span class="comment">//...</span></div><div class="line"></div><div class="line">　　　　event_base_dispatch(base);</div><div class="line"></div><div class="line">　　　　evconnlistener_free(listener);</div><div class="line">　　　　event_free(signal_event);</div><div class="line">　　　　event_base_free(base);</div><div class="line"></div><div class="line">　　　　<span class="built_in">printf</span>(<span class="string">"done\n"</span>);</div><div class="line">　　　　<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main函数中调用evconnlistener_new_bind()创建了一个evconnlistener 类型的listener,然后拍发消息，之后释放各种资源。</p>
<h2 id="第二步在evconnlistener-new-bind-中调用evconnlistener-new-完成listener属性设置。"><a href="#第二步在evconnlistener-new-bind-中调用evconnlistener-new-完成listener属性设置。" class="headerlink" title="第二步在evconnlistener_new_bind()中调用evconnlistener_new()完成listener属性设置。"></a>第二步在evconnlistener_new_bind()中调用evconnlistener_new()完成listener属性设置。</h2><p>这个函数里对evconnlistener_event中base进行回调函数的绑定和参数设置，通过event_assign将evconnlistener_event的istener设置读事件的回调函数，并且通过evconnlistener_enable让读回调函数触发，也就是触发listener_read_cb。这里evconnlister_enable调用的也是结构体注册的enable具体看代码吧，调用的是r = lev-&gt;ops-&gt;enable(lev);等同于调用event_listener_enable，该函数内部完成event_add。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener_event</span> &#123;</span></div><div class="line">　　　　<span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> <span class="title">base</span>;</span></div><div class="line">　　　　<span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">listener</span>;</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *</span></div><div class="line"><span class="class"><span class="title">evconnlistener_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,</span></div><div class="line"><span class="class">    <span class="title">evconnlistener_cb</span> <span class="title">cb</span>, <span class="title">void</span> *<span class="title">ptr</span>, <span class="title">unsigned</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">backlog</span>,</span></div><div class="line"><span class="class">    <span class="title">evutil_socket_t</span> <span class="title">fd</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener_event</span> *<span class="title">lev</span>;</span><span class="comment">//开辟evconnlistener_event大小区域</span></div><div class="line">    lev = mm_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct evconnlistener_event));</div><div class="line">    <span class="keyword">if</span> (!lev)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">//lev -&gt; base 表示  evconnlistener </span></div><div class="line">    <span class="comment">//evconnlistener     evconnlistener_ops 基本回调参数和回调函数结构体赋值</span></div><div class="line">    lev-&gt;base.ops = &amp;evconnlistener_event_ops;</div><div class="line">    <span class="comment">//evconnlistener_cb 设置为listener_cb</span></div><div class="line">    lev-&gt;base.cb = cb;</div><div class="line">    <span class="comment">//ptr表示event_base 指针</span></div><div class="line">    lev-&gt;base.user_data = ptr;</div><div class="line">    lev-&gt;base.flags = flags;</div><div class="line">    lev-&gt;base.refcnt = <span class="number">1</span>;<span class="comment">//  lev   is evconnlistener_event       </span></div><div class="line">    <span class="comment">//lev-&gt;listener is event</span></div><div class="line">    <span class="comment">//为lev-&gt;listener设置读回调函数和读关注事件，仅进行设置并没加入event队列</span></div><div class="line">    event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST,</div><div class="line">        listener_read_cb, lev);</div><div class="line">    <span class="comment">//实际调用了event_add将事件加入event队列</span></div><div class="line">    evconnlistener_enable(&amp;lev-&gt;base);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &amp;lev-&gt;base;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第三步listener-read-cb内部调用accept生成新的socket处理连接，调用listener-cb"><a href="#第三步listener-read-cb内部调用accept生成新的socket处理连接，调用listener-cb" class="headerlink" title="第三步listener_read_cb内部调用accept生成新的socket处理连接，调用listener_cb"></a>第三步listener_read_cb内部调用accept生成新的socket处理连接，调用listener_cb</h2><p>新的socket作为参数传递给evconnlistener_event中base的回调函数listener_cb</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">listener_read_cb(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, <span class="keyword">void</span> *p)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">lev</span> = <span class="title">p</span>;</span></div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    evconnlistener_cb cb;</div><div class="line">    evconnlistener_errorcb errorcb;</div><div class="line">    <span class="keyword">void</span> *user_data;</div><div class="line">    LOCK(lev);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">      　　<span class="comment">//...//cb 就 是  listener_cb</span></div><div class="line">        cb = lev-&gt;cb;</div><div class="line">        user_data = lev-&gt;user_data;</div><div class="line">        UNLOCK(lev);</div><div class="line">        <span class="comment">//触发了listener_cb</span></div><div class="line">        </div><div class="line">        <span class="comment">//完成了eventbuffer注册写和事件函数  </span></div><div class="line">        cb(lev, new_fd, (struct sockaddr*)&amp;ss, (<span class="keyword">int</span>)socklen,</div><div class="line">            user_data);</div><div class="line">        </div><div class="line">        LOCK(lev);</div><div class="line">        <span class="keyword">if</span> (lev-&gt;refcnt == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> freed = listener_decref_and_unlock(lev);</div><div class="line">            EVUTIL_ASSERT(freed);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        --lev-&gt;refcnt;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第四步listener-cb-调用bufferevent-socket-new-生成bufferevent，"><a href="#第四步listener-cb-调用bufferevent-socket-new-生成bufferevent，" class="headerlink" title="第四步listener_cb 调用bufferevent_socket_new 生成bufferevent，"></a>第四步listener_cb 调用bufferevent_socket_new 生成bufferevent，</h2><p>然后bufferevent_setcb设置读写水位触发的回调函数，bufferevent_enable将bufferevent的写事件加入监听，即开始检测写事件。关闭读事件，并且向outbuf中写入MSG<br>bufferevent_socket_new内部绑定bufferevent的读写事件回调函数，读事件为bufev-&gt;ev_read，绑定了bufferevent_readcb回调函数，<br>写事件为bufev-&gt;ev_write，<br>绑定了bufferevent_writecb回调函数。这两个回调函数和bufferevent的readcb和writecb是不一样的，这两个函数在对应的读写事件激活时才触发。<br>而readcb和writecb是基于水位线达到阈值才会触发。做好区分。bufferevent_socket_new内部还对bufev-&gt;output添加了对调函数bufferevent_socket_outbuf_cb，<br>bufferevent_socket_outbuf_cb内部检测是否开启写事件，以及是否可写，如果可写，同样将写事件加入监听队列，也就是调用了event_add。<br>bufferevent_socket_new内部解释完毕了。bufferevent_setcb设置的是读写水位达到阈值后的回调函数，<br>bufferevent_enable内部也是调用了event_add，将读事件加入监听队列。<br>bufferevent_enable内部调用bufev-&gt;be_ops-&gt;enable(bufev, impl_events)，等同于be_socket_enable，另外bufferevent_write函数内部调用evbuffer_add，<br>evbuffer_add内部调用了evbuffer_invoke_callbacks，就会调用绑定在output buffer上的回调函数bufferevent_socket_outbuf_cb。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</div><div class="line">    struct sockaddr *sa, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *user_data)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></div><div class="line"></div><div class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</div><div class="line">    <span class="keyword">if</span> (!bev) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error constructing bufferevent!"</span>);</div><div class="line">        event_base_loopbreak(base);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置写回调和事件回调</span></div><div class="line">    bufferevent_setcb(bev, <span class="literal">NULL</span>, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</div><div class="line">    bufferevent_enable(bev, EV_WRITE);</div><div class="line">    bufferevent_disable(bev, EV_READ);</div><div class="line">    <span class="comment">//将要发送的内容写入evbuffer结构</span></div><div class="line">    bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</div><div class="line">&#125;</div><div class="line">``` cpp</div><div class="line"> </div><div class="line">``` cpp</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *</span></div><div class="line"><span class="class"><span class="title">bufferevent_socket_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>, <span class="title">evutil_socket_t</span> <span class="title">fd</span>,</span></div><div class="line"><span class="class">    <span class="title">int</span> <span class="title">options</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_private</span> *<span class="title">bufev_p</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bufev</span>;</span></div><div class="line"></div><div class="line">　　<span class="comment">//...//设置bufferevent中   ev_read(event类型)回调函数</span></div><div class="line">    event_assign(&amp;bufev-&gt;ev_read, bufev-&gt;ev_base, fd,</div><div class="line">        EV_READ|EV_PERSIST, bufferevent_readcb, bufev);</div><div class="line">    <span class="comment">//设置bufferevent中   ev_write(event类型)回调函数</span></div><div class="line">    event_assign(&amp;bufev-&gt;ev_write, bufev-&gt;ev_base, fd,</div><div class="line">        EV_WRITE|EV_PERSIST, bufferevent_writecb, bufev);</div><div class="line"></div><div class="line">    <span class="comment">//为bufev-&gt;output(evbuffer类型)设置回调函数，插入bufferevent-&gt;output的callback队列</span></div><div class="line">    <span class="comment">//bufferevent_socket_outbuf_cb回调函数内部将ev_write事件加入事件队列</span></div><div class="line">    evbuffer_add_cb(bufev-&gt;output, bufferevent_socket_outbuf_cb, bufev);</div><div class="line"></div><div class="line">    evbuffer_freeze(bufev-&gt;input, <span class="number">0</span>);</div><div class="line">    evbuffer_freeze(bufev-&gt;output, <span class="number">1</span>);</div><div class="line">  　　<span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> bufev;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">``` cpp</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">be_socket_enable(struct bufferevent *bufev, <span class="keyword">short</span> event)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (event &amp; EV_READ) &#123;</div><div class="line">        <span class="keyword">if</span> (be_socket_add(&amp;bufev-&gt;ev_read,&amp;bufev-&gt;timeout_read) == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event &amp; EV_WRITE) &#123;</div><div class="line">        <span class="keyword">if</span> (be_socket_add(&amp;bufev-&gt;ev_write,&amp;bufev-&gt;timeout_write) == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第五步-bufferevent的output中写入MSG，-并且之前也已经将EV-WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev-write，调用绑定在ev-write上的函数bufferevent-writecb。"><a href="#第五步-bufferevent的output中写入MSG，-并且之前也已经将EV-WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev-write，调用绑定在ev-write上的函数bufferevent-writecb。" class="headerlink" title="第五步 bufferevent的output中写入MSG， 并且之前也已经将EV_WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev_write，调用绑定在ev_write上的函数bufferevent_writecb。"></a>第五步 bufferevent的output中写入MSG， 并且之前也已经将EV_WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev_write，调用绑定在ev_write上的函数bufferevent_writecb。</h2><p>这是bufferevent内部的写操作，我们可以详细看一下。之前也有讲过bufferevent会将接收到的数据放到inputbuffer中，将outputbuffer中的数据发送。所以之前讲过的接口bufferevent_write让我们将要发送的数据放到output中，bufferevent_read可以从input中读出bufferevent接收到的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">bufferevent_writecb(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bufev</span> = <span class="title">arg</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_private</span> *<span class="title">bufev_p</span> =</span></div><div class="line"><span class="class">        <span class="title">EVUTIL_UPCAST</span>(<span class="title">bufev</span>, <span class="title">struct</span> <span class="title">bufferevent_private</span>, <span class="title">bev</span>);</span></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">short</span> what = BEV_EVENT_WRITING;</div><div class="line">    <span class="keyword">int</span> connected = <span class="number">0</span>;</div><div class="line">    <span class="keyword">ev_ssize_t</span> atmost = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//对 bufferevent加锁，支持多线程安全模式</span></div><div class="line">    _bufferevent_incref_and_lock(bufev);</div><div class="line">    <span class="comment">//检测是否带有超时事件</span></div><div class="line">    <span class="keyword">if</span> (event == EV_TIMEOUT) &#123;</div><div class="line">        <span class="comment">/* Note that we only check for event==EV_TIMEOUT. If</span></div><div class="line"><span class="comment">         * event==EV_TIMEOUT|EV_WRITE, we can safely ignore the</span></div><div class="line"><span class="comment">         * timeout, since a read has occurred */</span></div><div class="line">        what |= BEV_EVENT_TIMEOUT;</div><div class="line">        <span class="keyword">goto</span> error;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否是连接事件</span></div><div class="line">    <span class="keyword">if</span> (bufev_p-&gt;connecting) &#123;</div><div class="line">        <span class="keyword">int</span> c = evutil_socket_finished_connecting(fd);</div><div class="line">        <span class="comment">/* we need to fake the error if the connection was refused</span></div><div class="line"><span class="comment">         * immediately - usually connection to localhost on BSD */</span></div><div class="line">        <span class="keyword">if</span> (bufev_p-&gt;connection_refused) &#123;</div><div class="line">          bufev_p-&gt;connection_refused = <span class="number">0</span>;</div><div class="line">          c = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line">        bufev_p-&gt;connecting = <span class="number">0</span>;</div><div class="line">        <span class="comment">//连接失败删除该事件</span></div><div class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</div><div class="line">            event_del(&amp;bufev-&gt;ev_write);</div><div class="line">            event_del(&amp;bufev-&gt;ev_read);</div><div class="line">            _bufferevent_run_eventcb(bufev, BEV_EVENT_ERROR);</div><div class="line">            <span class="keyword">goto</span> done;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            connected = <span class="number">1</span>;</div><div class="line">            <span class="comment">//windows情况下直接运行事件回调函数，然后go done</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">            <span class="keyword">if</span> (BEV_IS_ASYNC(bufev)) &#123;</div><div class="line">                event_del(&amp;bufev-&gt;ev_write);</div><div class="line">                bufferevent_async_set_connected(bufev);</div><div class="line">                _bufferevent_run_eventcb(bufev,</div><div class="line">                        BEV_EVENT_CONNECTED);</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">//linux 下 运行事件回调函数</span></div><div class="line">            _bufferevent_run_eventcb(bufev,</div><div class="line">                    BEV_EVENT_CONNECTED);</div><div class="line">        <span class="comment">//检测是否可写，不可写删除该事件</span></div><div class="line">            <span class="keyword">if</span> (!(bufev-&gt;enabled &amp; EV_WRITE) ||</div><div class="line">                bufev_p-&gt;write_suspended) &#123;</div><div class="line">                event_del(&amp;bufev-&gt;ev_write);</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//计算bufferevent能写的最大数量</span></div><div class="line">    atmost = _bufferevent_get_write_max(bufev_p);</div><div class="line">    <span class="comment">//写事件挂起了，跳过。</span></div><div class="line">    <span class="keyword">if</span> (bufev_p-&gt;write_suspended)</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    </div><div class="line">    <span class="comment">//output非空</span></div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(bufev-&gt;output)) &#123;</div><div class="line">        <span class="comment">//将output的头打开，从头部发送</span></div><div class="line">        evbuffer_unfreeze(bufev-&gt;output, <span class="number">1</span>);</div><div class="line">        <span class="comment">//bufferevent调用写操作，将outbuffer中的内容发送出去</span></div><div class="line">        res = evbuffer_write_atmost(bufev-&gt;output, fd, atmost);</div><div class="line">        <span class="comment">//将output的头部关闭</span></div><div class="line">        evbuffer_freeze(bufev-&gt;output, <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> err = evutil_socket_geterror(fd);</div><div class="line">            <span class="keyword">if</span> (EVUTIL_ERR_RW_RETRIABLE(err))</div><div class="line">                <span class="keyword">goto</span> reschedule;</div><div class="line">            what |= BEV_EVENT_ERROR;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/* eof case</span></div><div class="line"><span class="comment">               XXXX Actually, a 0 on write doesn't indicate</span></div><div class="line"><span class="comment">               an EOF. An ECONNRESET might be more typical.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">             <span class="comment">//写完了</span></div><div class="line">            what |= BEV_EVENT_EOF;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> error;</div><div class="line">        <span class="comment">//bufferevent减少发送的大小，留下未发送的，下次再发送，因为是PERSIST|WRITE</span></div><div class="line">        <span class="comment">//所以会在下次检测到可写时候继续写</span></div><div class="line">        _bufferevent_decrement_write_buckets(bufev_p, res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算是否将outbuf中的内容发送完，发完了就删除写事件</span></div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(bufev-&gt;output) == <span class="number">0</span>) &#123;</div><div class="line">        event_del(&amp;bufev-&gt;ev_write);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Invoke the user callback if our buffer is drained or below the</span></div><div class="line"><span class="comment">     * low watermark.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="comment">//将buffer中的内容发完，或者低于low 水位，那么调用用户注册的写回调函数</span></div><div class="line">    <span class="comment">//之前注册在bufev-&gt;writecb中的回调函数</span></div><div class="line">    <span class="keyword">if</span> ((res || !connected) &amp;&amp;</div><div class="line">        evbuffer_get_length(bufev-&gt;output) &lt;= bufev-&gt;wm_write.low) &#123;</div><div class="line">        _bufferevent_run_writecb(bufev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line"> reschedule:</div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(bufev-&gt;output) == <span class="number">0</span>) &#123;</div><div class="line">        event_del(&amp;bufev-&gt;ev_write);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line"> error:</div><div class="line">    bufferevent_disable(bufev, EV_WRITE);</div><div class="line">    _bufferevent_run_eventcb(bufev, what);</div><div class="line"></div><div class="line"> done:</div><div class="line">    _bufferevent_decref_and_unlock(bufev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第六步：这个函数内部每次尽可能多的发送数据，"><a href="#第六步：这个函数内部每次尽可能多的发送数据，" class="headerlink" title="第六步：这个函数内部每次尽可能多的发送数据，"></a>第六步：这个函数内部每次尽可能多的发送数据，</h2><p>没有发送完就下次轮询继续发送,直到水位低于或等于写数据的低水位，那么就会触发bufferevent低水位写回调函数。也就是conn_writecb，</p>
<p>在conn_writecb内部检测output buffer中数据为空，就释放该bufferevent。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> = <span class="title">bufferevent_get_output</span>(<span class="title">bev</span>);</span></div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"flushed answer\n"</span>);</div><div class="line">        bufferevent_free(bev);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是整体流程，bufferevent内部的流畅看懂即可，我们只需要使用libevent提供的接口即可。</p>
</div>
    
      <p class="post-copyright">若无特别说明，本文系原创，<a class="post-copyright-link" href="https://creativecommons.org/licenses/by/4.0/deed.zh" title="署名-非商业性使用 4.0 (CC BY-NC 4.0)" target="_blank">署名-非商业性使用 4.0 (CC BY-NC 4.0)</a>协议，转载文章请注明来自<a class="post-copyright-link" href="/" title="恋恋风辰的个人博客" target="_blank">恋恋风辰的个人博客</a>，或链接上原文地址：<a class="post-copyright-link" href="http://www.limerence2017.com/2017/08/04/Libevent5/" title="http://www.limerence2017.com/2017/08/04/Libevent5/" target="_blank">http://www.limerence2017.com/2017/08/04/Libevent5/</a></p>

      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一步找到main函数"><span class="toc-text">第一步找到main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二步在evconnlistener-new-bind-中调用evconnlistener-new-完成listener属性设置。"><span class="toc-text">第二步在evconnlistener_new_bind()中调用evconnlistener_new()完成listener属性设置。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三步listener-read-cb内部调用accept生成新的socket处理连接，调用listener-cb"><span class="toc-text">第三步listener_read_cb内部调用accept生成新的socket处理连接，调用listener_cb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四步listener-cb-调用bufferevent-socket-new-生成bufferevent，"><span class="toc-text">第四步listener_cb 调用bufferevent_socket_new 生成bufferevent，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五步-bufferevent的output中写入MSG，-并且之前也已经将EV-WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev-write，调用绑定在ev-write上的函数bufferevent-writecb。"><span class="toc-text">第五步 bufferevent的output中写入MSG， 并且之前也已经将EV_WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev_write，调用绑定在ev_write上的函数bufferevent_writecb。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六步：这个函数内部每次尽可能多的发送数据，"><span class="toc-text">第六步：这个函数内部每次尽可能多的发送数据，</span></a></li></ol>
          </div>
        </div>
      </div>
    
  
</article>

      <footer class="footer">
  <p class="footer-text">驱动于 <a href="https://hexo.io/zh-cn/" class="footer-link" title="Hexo">Hexo</a>，主题由 <a href="/about" class="footer-link" title="恋恋风辰">恋恋风辰</a> 设计移植而来</p>
  <p class="footer-text">&copy; 2016 - 2017 <a href="/about" class="footer-link" title="恋恋风辰">恋恋风辰</a> 保留部分版权</p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
