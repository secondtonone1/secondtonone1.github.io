<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恋恋风辰的个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.limerence2017.com/"/>
  <updated>2017-08-04T10:40:14.802Z</updated>
  <id>http://www.limerence2017.com/</id>
  
  <author>
    <name>恋恋风辰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libevent学习文档(三)working with event</title>
    <link href="http://www.limerence2017.com/2017/08/04/libevent3/"/>
    <id>http://www.limerence2017.com/2017/08/04/libevent3/</id>
    <published>2017-08-04T10:23:33.000Z</published>
    <updated>2017-08-04T10:40:14.802Z</updated>
    
    <content type="html"><![CDATA[<p><code>Events</code> have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an <code>event base</code>, it becomes initialized. At this point, you can add, which makes it pending in the base. When the event is pending, if the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomesactive, and its (user-provided) callback function is run. If the event is configured persistent, it remains pending. If it is not persistent, it stops being pending when its callback runs. You can make a pending event non-pending by deleting it, and you can add a non-pending event to make it pending again.</p>
<p>事件有相似的生命周期，一旦你调用libevent函数设置event和event_base关联后，event被初始化了。add这个事件会使它阻塞，当事件阻塞时，有触发事件的条件出现，事件会激活，回调函数会被调用。<code>如果事件被设置为永久，它保持阻塞</code>。<code>如果不是永久，当事件的回调函数调用的时候就不阻塞了</code>。可以通过删除一个事件使它由阻塞变为非阻塞。通过添加使它由非阻塞变为阻塞。<br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_TIMEOUT      0x01</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_READ         0x02</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WRITE        0x04</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SIGNAL       0x08</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PERSIST      0x10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ET           0x20</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</div><div class="line"></div><div class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">short</span> what, event_callback_fn cb,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *arg)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *event)</span></span>;</div></pre></td></tr></table></figure>
<p>通过event_new创建事件，通过event_free释放。 参数base 表示event绑定在那个event_base上, fd表示event关联的描述符， what表示事件的类型，是一个bitfield, 上面那些宏按位或，cb是事件回调函数，事件就绪后可以触发。event_free释放event事件。</p>
<p>All new events are initialized and non-pending. To make an event pending, call event_add() (documented below).</p>
<p>To deallocate an event, call event_free(). It is safe to call event_free() on an event that is pending or active: doing so makes the event non-pending and inactive before deallocating it.</p>
<p>所有新创建的事件都是初始化的，并且非阻塞，调用event_add可以让一个事件变为阻塞。<br>调用event_free释放event，在事件阻塞或者激活状态下调用event_free是安全的，这个函数会在释放event之前将事件变为非阻塞并且非激活状态。</p>
<p><code>EV_TIMEOUT</code></p>
<p>This flag indicates an event that becomes active after a timeout elapses.</p>
<p><code>EV_READ</code></p>
<p>This flag indicates an event that becomes active when the provided file descriptor is ready for reading.</p>
<p><code>EV_WRITE</code></p>
<p>This flag indicates an event that becomes active when the provided file descriptor is ready for writing.</p>
<p><code>EV_SIGNAL</code></p>
<p>Used to implement signal detection. See “Constructing signal events” below.</p>
<p><code>EV_PERSIST</code></p>
<p>Indicates that the event is persistent. See “About Event Persistence” below.</p>
<p><code>EV_ET</code></p>
<p>Indicates that the event should be edge-triggered, if the underlying event_base backend supports edge-triggered events.</p>
<p><code>EV_TIMEOUT</code>：表示过一段事件后event变为active。</p>
<p><code>EV_READ</code>：当文件描述可读的时候变为就绪。</p>
<p><code>EV_WRITE</code>：当文件描述符可写的时候变为就绪。</p>
<p><code>EV_SIGNAL</code>：信号事件的标记</p>
<p><code>EV_PERSIST</code>：永久事件，下面会介绍。</p>
<p><code>EV_ET</code>：如果后端支持边缘触发事件，那么事件是边缘触发的。</p>
<p>About Event Persistence</p>
<p>By default, whenever a pending event becomes active (because its fd is ready to read or write, or because its timeout expires), it becomes non-pending right before its callback is executed. Thus, if you want to make the event pending again, you can call event_add() on it again from inside the callback function.</p>
<p>If the EV_PERSIST flag is set on an event, however, the event is persistent. This means that event remains pending even when its callback is activated. If you want to make it non-pending from within its callback, you can call event_del() on it.</p>
<p>The timeout on a persistent event resets whenever the event’s callback runs. Thus, if you have an event with flags EV_READ|EV_PERSIST and a timeout of five seconds, the event will become active:</p>
<p>Whenever the socket is ready for reading.</p>
<p>Whenever five seconds have passed since the event last became active.</p>
<p>默认情况下，当一个阻塞事件变为active时，(读事件可读，写事件可写，超时间到期等)，在事件对应的回调函数调用前该事件就会变为非阻塞的。因此，如果想要将事件变为阻塞，需要在事件的回调函数里调用event_add()</p>
<p>如果设置了EV_PERSIST 标记位， 那么事件就变味永久的，这意味着事件在回调函数触发时任然保持pending，如果你想要在回调函数调用后该事件变为非阻塞，需要调用event_del()。</p>
<p>当事件回调函数调用后超时会被重置，因此，如果事件带有EV_READ|EV_PERSIST标记，并且有5秒的超时值，如下情况事件会变为active：</p>
<p><code>1当socket可读时</code></p>
<p><code>2从上次变为active之后过了5秒后事件会变为active。</code></p>
<p>当事件的回调函数需要用到自己作为参数时候，需要将参数传递为</p>
<p>void *event_self_cbarg();</p>
<p>代码例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> n_calls = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, <span class="keyword">void</span> *arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">me</span> = <span class="title">arg</span>;</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"cb_func called %d times so far.\n"</span>, ++n_calls);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n_calls &gt; <span class="number">100</span>)</div><div class="line">       event_del(me);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(struct event_base *base)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">one_sec</span> = &#123;</span> <span class="number">1</span>, <span class="number">0</span> &#125;;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></div><div class="line">    <span class="comment">/* We're going to set up a repeating timer to get called called 100</span></div><div class="line"><span class="comment">       times. */</span></div><div class="line">    ev = event_new(base, <span class="number">-1</span>, EV_PERSIST, cb_func, event_self_cbarg());</div><div class="line">    event_add(ev, &amp;one_sec);</div><div class="line">    event_base_dispatch(base);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>For performance and other reasons, some people like to allocate events as a part of a larger structure. For each use of the event, this saves them:</p>
<p>The memory allocator overhead for allocating a small object on the heap.</p>
<p>The time overhead for dereferencing the pointer to the struct event.</p>
<p>The time overhead from a possible additional cache miss if the event is not already in the cache.</p>
<p>有时候开辟event作为一个较大结构体的一部分，可以节省在堆上开辟小对象的内存，也可以节省间接引用事件指针的事件和额外内存流失的处理。</p>
<p>文档的作者并不提倡用event_assign这个函数，推荐使用event_new，而且对于一些问题event_assign并不好调试</p>
<p>下面是使用event_assign的例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_pair</span> &#123;</span></div><div class="line">         <span class="keyword">evutil_socket_t</span> fd;</div><div class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">read_event</span>;</span></div><div class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">write_event</span>;</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readcb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writecb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</div><div class="line"><span class="function">struct event_pair *<span class="title">event_pair_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_pair</span> *<span class="title">p</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">event_pair</span>));</span></div><div class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        p-&gt;fd = fd;</div><div class="line">        event_assign(&amp;p-&gt;read_event, base, fd, EV_READ|EV_PERSIST, readcb, p);</div><div class="line">        event_assign(&amp;p-&gt;write_event, base, fd, EV_WRITE|EV_PERSIST, writecb, p);</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WARNING<br>Never call event_assign() on an event that is already pending in an event base. Doing so can lead to extremely hard-to-diagnose errors. If the event is already initialized and pending, call event_del() on it before you call event_assign() on it again.</p>
<p>event在event_base中阻塞时不要调用event_assign()，否则会造成很难查找分析的问题，如果一个事件已经初始化并且pending了，需要调用event_del()删除他，然后再次调用event_assign()。</p>
<p>evtimer_assign和evsignal_assign分别是定时器和信号的注册函数。</p>
<p>由于调用event_assign()可能会造成版本兼容的问题，调用如下函数，可以获取到event运行时大小。<br>size_t event_get_struct_event_size(void);</p>
<p>This function returns the number of bytes you need to set aside for a struct event. As before, you should only be using this function if you know that heap-allocation is actually a significant problem in your program, since it can make your code much harder to read and write.</p>
<p>这个函数返回event结构体旁边的偏移位置的字节数，只有在你觉得堆开辟确实是一个难题的时候才采用这个方法。因为这么做会是你的代码更难去读和写。</p>
<p>事件的添加：<br>int event_add(struct event <em>ev, const struct timeval </em>tv);<br>Calling event_add on a non-pending event makes it pending in its configured base. The function returns 0 on success, and -1 on failure. If tv is NULL, the event is added with no timeout. Otherwise, tv is the size of the timeout in seconds and microseconds.</p>
<p>If you call event_add() on an event that is already pending, it will leave it pending, and reschedule it with the provided timeout. If the event is already pending, and you re-add it with the timeout NULL, event_add() will have no effect.</p>
<p>调用event_add会让一个event变得pending，返回0表示成功，-1表示失败。如果tv设置为NULL，表示没有超时检测。否则，tv表示超时的秒数和毫秒。<br>如果在一个pending的event上调用add，会使它pengding，并且根据超时值重新计时。</p>
<p>事件的删除：<br>int event_del(struct event *ev);</p>
<p>事件删除函数，会将一个阻塞或者激活的事件变为非阻塞和非激活的，如果事件是非阻塞的或者非激活的，调用这个函数并没有什么影响。同样，返回0表示成功，-1表示失败。</p>
<p>优先级设置：<br>int event_priority_set(struct event *event, int priority);</p>
<p>每个event_base有priorities，event可以设置从0到这个值之间的一个数，0表示成功，-1表示失败。<br>优先级高的先处理，优先级低的后处理。<br>如果不设置优先级，默认值为event_base中队列大小除以2<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_loop</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">important</span>, *<span class="title">unimportant</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></div><div class="line"></div><div class="line">  base = event_base_new();</div><div class="line">  event_base_priority_init(base, <span class="number">2</span>);</div><div class="line">  <span class="comment">/* Now base has priority 0, and priority 1 */</span></div><div class="line">  important = event_new(base, fd, EV_WRITE|EV_PERSIST, write_cb, <span class="literal">NULL</span>);</div><div class="line">  unimportant = event_new(base, fd, EV_READ|EV_PERSIST, read_cb, <span class="literal">NULL</span>);</div><div class="line">  event_priority_set(important, <span class="number">0</span>);</div><div class="line">  event_priority_set(unimportant, <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* Now, whenever the fd is ready for writing, the write callback will</span></div><div class="line"><span class="comment">     happen before the read callback.  The read callback won't happen at</span></div><div class="line"><span class="comment">     all until the write callback is no longer active. */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除此之外，libevent还为我们提供了一些接口访问当前event_base 和event属性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, <span class="keyword">short</span> what, struct timeval *tv_out)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span></span></div><div class="line"><span class="keyword">evutil_socket_t</span> event_get_fd(<span class="keyword">const</span> struct event *ev);</div><div class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</div><div class="line"><span class="function"><span class="keyword">short</span> <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</div><div class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event,</span></span></div><div class="line"><span class="function"><span class="params">        struct event_base **base_out,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">evutil_socket_t</span> *fd_out,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">short</span> *events_out,</span></span></div><div class="line"><span class="function"><span class="params">        event_callback_fn *callback_out,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">void</span> **arg_out)</span></span>;</div></pre></td></tr></table></figure></p>
<p>event_pending 获取当前event对应的what属性事件是否pending或者被激活，If it is, and any of the flags EV_READ, EV_WRITE, EV_SIGNAL, and EV_TIMEOUT are set in the whatargument, the function returns all of the flags that the event is currently pending or active on</p>
<p>任类型都可以设置到what参数里，这个函数返回当前pending或者激活状态的标记按位或。event_get_signal和event_get_fd返回event关联的信号id和文件描述符id， event_get_base返回event绑定的event_base，<br>event_get_events返回event监听的事件集合，event_get_callback返回event的回调函数，以及<br>event_get_callback_arg返回回调函数参数，<br>event_get_priority返回event的优先级<br>event_get_assignment这个函数返回event所有绑定的信息到对应的指针域，如果形参为NULL，表示忽略。\<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Change the callback and callback_arg of 'ev', which must not be</span></div><div class="line"><span class="comment"> * pending. */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">replace_callback</span><span class="params">(struct event *ev, event_callback_fn new_callback,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *new_callback_arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></div><div class="line">    <span class="keyword">evutil_socket_t</span> fd;</div><div class="line">    <span class="keyword">short</span> events;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pending;</div><div class="line"></div><div class="line">    pending = event_pending(ev, EV_READ|EV_WRITE|EV_SIGNAL|EV_TIMEOUT,</div><div class="line">                            <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (pending) &#123;</div><div class="line">        <span class="comment">/* We want to catch this here so that we do not re-assign a</span></div><div class="line"><span class="comment">         * pending event.  That would be very very bad. */</span></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</div><div class="line">                <span class="string">"Error! replace_callback called on a pending event!\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    event_get_assignment(ev, &amp;base, &amp;fd, &amp;events,</div><div class="line">                         <span class="literal">NULL</span> <span class="comment">/* ignore old callback */</span> ,</div><div class="line">                         <span class="literal">NULL</span> <span class="comment">/* ignore old callback argument */</span>);</div><div class="line"></div><div class="line">    event_assign(ev, base, fd, events, new_callback, new_callback_arg);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有个能只调用一次事件的创建接口</p>
<p>int event_base_once(struct event_base <em>, evutil_socket_t, short,<br>  void (</em>)(evutil_socket_t, short, void <em>), void </em>, const struct timeval *);</p>
<p>这个函数不支持EV_SIGNAL 和 EV_PERSIST ，这个事件也不支持手动删除和激活。当该事件对应的回调函数触发后，该事件会自动从event_base中移除，并且libevent会析构掉该event。</p>
<p>激活event的接口</p>
<p>void event_active(struct event *ev, int what, short ncalls);</p>
<p> 这个函数可以根据what(EV_READ, EV_WRITE,EV_TIMER等)将event设置为active，调用函数前，event是否为pengding并不影响，<br>并且激活它并且变为非阻塞状态。<br>在同一个事件递归的调用event_active会导致内存耗尽。</p>
<p>下面是一个错误例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cb</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">short</span> which, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">        <span class="comment">/* Whoops: Calling event_active on the same event unconditionally</span></div><div class="line"><span class="comment">           from within its callback means that no other events might not get</span></div><div class="line"><span class="comment">           run! */</span></div><div class="line"></div><div class="line">        event_active(ev, EV_WRITE, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></div><div class="line"></div><div class="line">        ev = event_new(base, <span class="number">-1</span>, EV_PERSIST | EV_READ, cb, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        event_add(ev, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        event_active(ev, EV_WRITE, <span class="number">0</span>);</div><div class="line"></div><div class="line">        event_base_loop(base, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有两种改进的方式，一种是采用定时器，另一种是采用libevent提供的event_config_set_max_dispatch_interval</p>
<p>定时器的就是只调用一次loop，之后的回调函数cb会反复调用，因为cb内部发现event不是阻塞状态了，就要将event删除后再加入，loop内部检测到新的event，继续调用cb，反复调用cb<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cb</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">short</span> which, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!evtimer_pending(ev, <span class="literal">NULL</span>)) &#123;</div><div class="line">       event_del(ev);</div><div class="line">       evtimer_add(ev, &amp;tv);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></div><div class="line"></div><div class="line">   tv.tv_sec = <span class="number">0</span>;</div><div class="line">   tv.tv_usec = <span class="number">0</span>;</div><div class="line"></div><div class="line">   ev = evtimer_new(base, cb, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">   evtimer_add(ev, &amp;tv);</div><div class="line"></div><div class="line">   event_base_loop(base, <span class="number">0</span>);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line">event_config_set_max_dispatch_interval设置了dispatch的时间间隔，每个一段时间才派发就绪时间，这样就不会导致递归造成的资源耗尽了。</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cb</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">short</span> which, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">        event_active(ev, EV_WRITE, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_config</span> *<span class="title">cfg</span> = <span class="title">event_config_new</span>();</span></div><div class="line">        <span class="comment">/* Run at most 16 callbacks before checking for other events. */</span></div><div class="line">        event_config_set_max_dispatch_interval(cfg, <span class="literal">NULL</span>, <span class="number">16</span>, <span class="number">0</span>);</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new_with_config</span>(<span class="title">cfg</span>);</span></div><div class="line">        ev = event_new(base, <span class="number">-1</span>, EV_PERSIST | EV_READ, cb, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        event_add(ev, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        event_active(ev, EV_WRITE, <span class="number">0</span>);</div><div class="line"></div><div class="line">        event_base_loop(base, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>今天的学习就到这里，这是我的公众号</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Events&lt;/code&gt; have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an &lt;code&gt;event base&lt;/code&gt;, it becomes initialized. At this point, you can add, which makes it pending in the base. When the event is pending, if the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomesactive, and its (user-provided) callback function is run. If the event is configured persistent, it remains pending. If it is not persistent, it stops being pending when its callback runs. You can make a pending event non-pending by deleting it, and you can add a non-pending event to make it pending again.&lt;/p&gt;
&lt;p&gt;事件有相似的生命周期，一旦你调用libevent函数设置event和event_base关联后，event被初始化了。add这个事件会使它阻塞，当事件阻塞时，有触发事件的条件出现，事件会激活，回调函数会被调用。&lt;code&gt;如果事件被设置为永久，它保持阻塞&lt;/code&gt;。&lt;code&gt;如果不是永久，当事件的回调函数调用的时候就不阻塞了&lt;/code&gt;。可以通过删除一个事件使它由阻塞变为非阻塞。通过添加使它由非阻塞变为阻塞。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Linux环境编程" scheme="http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Libevent学习笔记(四) bufferevent 的 concepts and basics</title>
    <link href="http://www.limerence2017.com/2017/08/04/libevent4/"/>
    <id>http://www.limerence2017.com/2017/08/04/libevent4/</id>
    <published>2017-08-04T10:08:08.000Z</published>
    <updated>2017-08-04T10:21:09.408Z</updated>
    
    <content type="html"><![CDATA[<p><code>Bufferevents and evbuffers</code></p>
<p>Every bufferevent has an input buffer and an output buffer. These are of type “struct evbuffer”. When you have data to write on a bufferevent, you add it to the output buffer; when a bufferevent has data for you to read, you drain it from the input buffer.</p>
<p>每个<code>bufferevents</code>都会包含一个input的buffer和output的buffer,都是<code>struct evbuffer</code>类型， 如果你有数据想通过bufferevent发送，需要将数据放入output buffer里。如果要从bufferevent中读数据，</p>
<p>需要从input buffer里读取。</p>
<p><code>Callbacks and watermarks</code></p>
<p>Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write “watermarks” of the bufferevent.</p>
<p>每一个bufferevent都有两个回调函数，一个<code>读回调</code>和一个<code>写回调</code>函数，默认情况下，只要从底层传输读取数据就回触发读回调函数，当output buffer中足够多的数据排出就会触发写回调函数。而我的理解是，这里的足够多，默认情况下是排空，</p>
<p>用户可以通过调整读写水位来达到控制这些函数触发。<br><a id="more"></a></p>
<p>下面是libevent源码中的一些注释</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   A read or write callback for a bufferevent.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   The read callback is triggered when new data arrives in the input</span></div><div class="line"><span class="comment">   buffer and the amount of readable data exceed the low watermark</span></div><div class="line"><span class="comment">   which is 0 by default.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   The write callback is triggered if the write buffer has been</span></div><div class="line"><span class="comment">   exhausted or fell below its low watermark.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   @param bev the bufferevent that triggered the callback</span></div><div class="line"><span class="comment">   @param ctx the user-specified context for this bufferevent</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
<p>到此为止总结下，bufferevent实际上是libevent为我们准备的一个缓存结构，将接受的数据缓存到input buffer供用户从中读取，用户将发送的数据缓存到output buffer进行发送。bufferevent的input buffer中有数据到来并且可读数据达到或超过读数据的低水位就会触发读回调函数，读数据的低水位默认是0,写回调函数会在outbuffer中的数据低于写的低水位时会触发。bufferevent会自己讲output中的内容发送出去，将接收到的内容放到input中。</p>
<p>Read low-water mark<br>Whenever a read occurs that leaves the bufferevent’s input buffer at this level or higher, the bufferevent’s read callback is invoked. Defaults to 0, so that every read results in the read callback being invoked.</p>
<p>只要读事件让bufferevent超过或者到达这个Read low-water 水位或者更高，读回调会被触发。默认情况下 Read low-water 是0，所以每次bufferevent 读数据都会导致读回调触发。</p>
<p>Read high-water mark<br>If the bufferevent’s input buffer ever gets to this level, the bufferevent stops reading until enough data is drained from the input buffer to take us below it again. Defaults to unlimited, so that we never stop reading because of the size of the input buffer.</p>
<p>如果bufferevent 的 input buffer达到Read high-water水平，那么bufferevent会停止读，直到有数据从input中被用户取出使input buffer的水位线低于Read high-water， 默认情况下Read high-water是无穷大的，因此我们不会因为input buffer不够停止读。 </p>
<p>Write low-water mark<br>Whenever a write occurs that takes us to this level or below, we invoke the write callback. Defaults to 0, so that a write callback is not invoked unless the output buffer is emptied.</p>
<p>当bufferevent写数据导致数据大小低于 Write low-water水平线，就回触发写回调函数。默认这个Write low-water值为0，因此只有当output buffer数据为空时才会触发写回调函数。</p>
<p>Write high-water mark<br>Not used by a bufferevent directly, this watermark can have special meaning when a bufferevent is used as the underlying transport of another bufferevent. See notes on filtering bufferevents below.</p>
<p>这个参数不会直接使用，当一个bufferevent作为参数传递给另一个bufferevent时可以做为特殊意义。filtering bufferevents可能会用到。</p>
<p>A bufferevent also has an “error” or “event” callback that gets invoked to tell the application about non-data-oriented events, like when a connection is closed or an error occurs. The following event flags are defined:</p>
<p>一个bufferevent也会有类似错误或者特殊事件的回调函数，这类函数触发后通知应用程序一些和数据无关的事件，比如当有连接关闭，或者错误出现可以触发这类函数。</p>
<p>BEV_EVENT_READING<br>An event occured during a read operation on the bufferevent. See the other flags for which event it was.</p>
<p>在bufferevent上进行读操作</p>
<p>BEV_EVENT_WRITING<br>An event occured during a write operation on the bufferevent. See the other flags for which event it was.</p>
<p>在bufferevent上进行写操作</p>
<p>BEV_EVENT_ERROR<br>An error occurred during a bufferevent operation. For more information on what the error was, call EVUTIL_SOCKET_ERROR().</p>
<p>bufferevent操作产生错误，通过EVUTIL_SOCKET_ERROR可以详细查看错误源</p>
<p>BEV_EVENT_TIMEOUT<br>A timeout expired on the bufferevent.</p>
<p>超时事件</p>
<p>BEV_EVENT_EOF<br>We got an end-of-file indication on the bufferevent.</p>
<p>读到文件结束符</p>
<p>BEV_EVENT_CONNECTED<br>We finished a requested connection on the bufferevent.</p>
<p>完成连接</p>
<p>Deferred callbacks</p>
<p>By default, a bufferevent callbacks are executed immediately when the corresponding condition happens. (This is true of evbuffer callbacks too; we’ll get to those later.) This immediate invocation can make trouble when dependencies get complex. For example, suppose that there is a callback that moves data into evbuffer A when it grows empty, and another callback that processes data out of evbuffer A when it grows full. Since these calls are all happening on the stack, you might risk a stack overflow if the dependency grows nasty enough.</p>
<p>To solve this, you can tell a bufferevent (or an evbuffer) that its callbacks should be deferred. When the conditions are met for a deferred callback, rather than invoking it immediately, it is queued as part of the event_loop() call, and invoked after the regular events’ callbacks.</p>
<p>(Deferred callbacks were introduced in Libevent 2.0.1-alpha.)</p>
<p>默认情况下，bufferevent回调函数在条件符合时会立即执行。当情况复杂时这种立即出发的方式可能会造成问题，例如，假设有一个回调函数功能是在evbuffer A变空时向evbuffer A中放入数据，</p>
<p>另一个回调函数是在evbuffer A数据满的时候从中取出数据，由于这些操作是在栈上进行，这种做法会造成造成栈溢出，解决方法就是将回调函数延迟触发，条件满足时，将回调函数作为event_loop的一个部分</p>
<p>通过有规律的事件回调触发。</p>
<p>Option flags for bufferevents</p>
<p>You can use one or more flags when creating a bufferevent to alter its behavior. Recognized flags are:</p>
<p>创建bufferevent时可以选择如下选项进行个性化设置</p>
<p>BEV_OPT_CLOSE_ON_FREE<br>When the bufferevent is freed, close the underlying transport. This will close an underlying socket, free an underlying bufferevent, etc.</p>
<p>当bufferevent被释放，关闭底层传输，这个将会关闭底层socket，释放底层的bufferevent等。</p>
<p>BEV_OPT_THREADSAFE<br>Automatically allocate locks for the bufferevent, so that it’s safe to use from multiple threads.</p>
<p>为bufferevent自动上锁，多线程模式会安全。</p>
<p>BEV_OPT_DEFER_CALLBACKS<br>When this flag is set, the bufferevent defers all of its callbacks, as described above.</p>
<p>设置bufferevent的callback延迟处理。</p>
<p>BEV_OPT_UNLOCK_CALLBACKS<br>By default, when the bufferevent is set up to be threadsafe, the bufferevent’s locks are held whenever the any user-provided callback is invoked. Setting this option makes Libevent release the bufferevent’s lock when it’s invoking your callbacks.</p>
<p>如果设置了线程安全选项，设置这个选项会使得调用我们的回调函数时释放锁。</p>
<p>Working with socket-based bufferevents</p>
<p><code>1创建bufferevent，成功返回bufferevent的指针，失败返回空，options是上面提到的选项。</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_socket_new</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    struct event_base *base,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">enum</span> bufferevent_options options)</span></span>;</div></pre></td></tr></table></figure></p>
<p> <code>2连接函数</code></p>
<p>int bufferevent_socket_connect(struct bufferevent <em>bev,<br>    struct sockaddr </em>address, int addrlen);</p>
<p>the address and addrlen arguments are as for the standard call connect(). If the bufferevent does not already have a socket set, calling this function allocates a new stream socket for it, and makes it nonblocking.</p>
<p>If the bufferevent does have a socket already, calling bufferevent_socket_connect() tells Libevent that the socket is not connected, and no reads or writes should be done on the socket until the connect operation has succeeded.</p>
<p>It is okay to add data to the output buffer before the connect is done.</p>
<p>如果bufferevent没有设置socket，调用这个函数会为它创建一个非阻塞socket</p>
<p>如果bufferevent有socket，调用这个函数会通知libevent在连接成功前不能调用读或者写。</p>
<p>在连接成功前可以向output buffer中添加数据。</p>
<p>下面是例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventcb</span><span class="params">(struct bufferevent *bev, <span class="keyword">short</span> events, <span class="keyword">void</span> *ptr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_CONNECTED) &#123;</div><div class="line">         <span class="comment">/* We're connected to 127.0.0.1:8080.   Ordinarily we'd do</span></div><div class="line"><span class="comment">            something here, like start reading or writing. */</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</div><div class="line">         <span class="comment">/* An error occured while connecting. */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main_loop(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    struct event_base *base;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></div><div class="line"></div><div class="line">    base = event_base_new();</div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</div><div class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = htonl(<span class="number">0x7f000001</span>); <span class="comment">/* 127.0.0.1 */</span></div><div class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">8080</span>); <span class="comment">/* Port 8080 */</span></div><div class="line"></div><div class="line">    bev = bufferevent_socket_new(base, <span class="number">-1</span>, BEV_OPT_CLOSE_ON_FREE);</div><div class="line"></div><div class="line">    bufferevent_setcb(bev, <span class="literal">NULL</span>, <span class="literal">NULL</span>, eventcb, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (bufferevent_socket_connect(bev,</div><div class="line">        (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/* Error starting connection */</span></div><div class="line">        bufferevent_free(bev);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    event_base_dispatch(base);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Note that you only get a BEV_EVENT_CONNECTED event if you launch the connect() attempt using bufferevent_socket_connect(). If you call connect() on your own, the connection gets reported as a write.</p>
<p>If you want to call connect() yourself, but still get receive a BEV_EVENT_CONNECTED event when the connection succeeds, call bufferevent_socket_connect(bev, NULL, 0) after connect() returns -1 with errno equal to EAGAIN or EINPROGRESS.</p>
<p>如果通过bufferevent_socket_connect连接，那么返回的事件是BEV_EVENT_CONNECTED ，</p>
<p>如果通过connect连接，那么返回的是write事件。如果调用了connect，还想捕捉到BEV_EVENT_CONNECTED 事件，可以继续调用bufferevent_socket_connect(bev,NULL, 0),返回值为-1，errno为EAGAIN或者EINPROGRESS</p>
<p><code>3释放bufferevent</code></p>
<p>void bufferevent_free(struct bufferevent *bev);<br>This function frees a bufferevent. Bufferevents are internally reference-counted, so if the bufferevent has pending deferred callbacks when you free it, it won’t be deleted until the callbacks are done.</p>
<p>The bufferevent_free() function does, however, try to free the bufferevent as soon as possible. If there is pending data to write on the bufferevent, it probably won’t be flushed before the bufferevent is freed.</p>
<p>If the BEV_OPT_CLOSE_ON_FREE flag was set, and this bufferevent has a socket or underlying bufferevent associated with it as its transport, that transport is closed when you free the bufferevent.</p>
<p>当bufferevent有延迟回调函数没处理，调用bufferevent_free并不会立即释放bufferevent，bufferevent内部是引用计数的，他能做到的是尽快释放，如果bufferevent上存在阻塞的数据还没有写，这部分数据在bufferevent释放前是不会被释放的。</p>
<p><code>4 其他的一些设置函数</code></p>
<p>是指bufferevent回调函数，以及获取回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent *bev,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">short</span> events, <span class="keyword">void</span> *ctx)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,</span></span></div><div class="line"><span class="function"><span class="params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span></span></div><div class="line"><span class="function"><span class="params">    bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_getcb</span><span class="params">(struct bufferevent *bufev,</span></span></div><div class="line"><span class="function"><span class="params">    bufferevent_data_cb *readcb_ptr,</span></span></div><div class="line"><span class="function"><span class="params">    bufferevent_data_cb *writecb_ptr,</span></span></div><div class="line"><span class="function"><span class="params">    bufferevent_event_cb *eventcb_ptr,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">void</span> **cbarg_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><code>5 读写生效函数，读写失效函数</code></p>
<p>void bufferevent_enable(struct bufferevent <em>bufev, short events);<br>void bufferevent_disable(struct bufferevent </em>bufev, short events);</p>
<p>short bufferevent_get_enabled(struct bufferevent *bufev);<br>You can enable or disable the events EV_READ, EV_WRITE, or EV_READ|EV_WRITE on a bufferevent. When reading or writing is not enabled, the bufferevent will not try to read or write data.</p>
<p>There is no need to disable writing when the output buffer is empty: the bufferevent automatically stops writing, and restarts again when there is data to write.</p>
<p>Similarly, there is no need to disable reading when the input buffer is up to its high-water mark: the bufferevent automatically stops reading, and restarts again when there is space to read.</p>
<p>By default, a newly created bufferevent has writing enabled, but not reading.</p>
<p>You can call bufferevent_get_enabled() to see which events are currently enabled on the bufferevent.</p>
<p> 可以设置bufferevent 读，写，或者读和写生效，当读或者写失效，bufferevent将不会尝试读或者写数据。在output为空时没必要让写操作失效，bufferevent会自动停止写，当有数据可写时才再次执行写操作。</p>
<p>同样的，在input buffer超过高水位时，没必要设置读失效，bufferevent 会自动停止读，而等到有空间(其实是input缓冲区非满)再次开始接收数据。</p>
<p>默认情况下，新创建的 bufferevent是可写的不可读的。(因为如果设置可读选项，那么会出现busyloop，因为input一直非满)</p>
<p>用户可以通过bufferevent_get_enabled获取当前哪些事件类型是允许的。</p>
<p><code>6设置水位接口</code></p>
<p>void bufferevent_setwatermark(struct bufferevent *bufev, short events,<br>    size_t lowmark, size_t highmark);<br>The bufferevent_setwatermark() function adjusts the read watermarks, the write watermarks, or both, of a single bufferevent. (If EV_READ is set in the events field, the read watermarks are adjusted. If EV_WRITE is set in the events field, the write watermarks are adjusted.)</p>
<p>A high-water mark of 0 is equivalent to “unlimited”.</p>
<p>bufferevent_setwatermark函数调整读或者写的水位。</p>
<p><code>7获取读写缓冲区的内容</code></p>
<p>struct evbuffer <em>bufferevent_get_input(struct bufferevent </em>bufev);<br>struct evbuffer <em>bufferevent_get_output(struct bufferevent </em>bufev);</p>
<p><code>8向bufferevent中写数据</code></p>
<p>int bufferevent_write(struct bufferevent <em>bufev,<br>    const void </em>data, size_t size);<br>int bufferevent_write_buffer(struct bufferevent <em>bufev,<br>    struct evbuffer </em>buf);</p>
<p>调用bufferevent_write可以向bufev的output 的末尾追加写入。</p>
<p>bufferevent_write_buffer将buf中的数据移除，写入到bufevoutput中。</p>
<p>两个函数返回0表示成功，-1表示失败。</p>
<p><code>9从bufferevent中读数据</code></p>
<p>size_t bufferevent_read(struct bufferevent <em>bufev, void </em>data, size_t size);<br>int bufferevent_read_buffer(struct bufferevent <em>bufev,<br>    struct evbuffer </em>buf); </p>
<p>bufferevent_read 从bufev中input buffer 读取size大小数据，存在data中。</p>
<p>bufferevent_read_buffer从bufev的input buffer中将所有数据取出放入到buf中。</p>
<p>两个函数返回0表示成功，-1表示失败。</p>
<p><code>10设置读写事件的超时时间</code></p>
<p>void bufferevent_set_timeouts(struct bufferevent <em>bufev,<br>    const struct timeval </em>timeout_read, const struct timeval *timeout_write);</p>
<p><code>11强制刷新读或者写</code></p>
<p>int bufferevent_flush(struct bufferevent *bufev,<br>    short iotype, enum bufferevent_flush_mode state);</p>
<p> 强制从底层读取数据，或将数据写入底层。The iotype argument should be EV_READ, EV_WRITE, or EV_READ|EV_WRITE to indicate whether bytes being read, written, or both should be processed.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Bufferevents and evbuffers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Every bufferevent has an input buffer and an output buffer. These are of type “struct evbuffer”. When you have data to write on a bufferevent, you add it to the output buffer; when a bufferevent has data for you to read, you drain it from the input buffer.&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;bufferevents&lt;/code&gt;都会包含一个input的buffer和output的buffer,都是&lt;code&gt;struct evbuffer&lt;/code&gt;类型， 如果你有数据想通过bufferevent发送，需要将数据放入output buffer里。如果要从bufferevent中读数据，&lt;/p&gt;
&lt;p&gt;需要从input buffer里读取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Callbacks and watermarks&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write “watermarks” of the bufferevent.&lt;/p&gt;
&lt;p&gt;每一个bufferevent都有两个回调函数，一个&lt;code&gt;读回调&lt;/code&gt;和一个&lt;code&gt;写回调&lt;/code&gt;函数，默认情况下，只要从底层传输读取数据就回触发读回调函数，当output buffer中足够多的数据排出就会触发写回调函数。而我的理解是，这里的足够多，默认情况下是排空，&lt;/p&gt;
&lt;p&gt;用户可以通过调整读写水位来达到控制这些函数触发。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Linux环境编程" scheme="http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Libevent学习笔记(五) 根据例子学习bufferevent</title>
    <link href="http://www.limerence2017.com/2017/08/04/Libevent5/"/>
    <id>http://www.limerence2017.com/2017/08/04/Libevent5/</id>
    <published>2017-08-04T09:41:54.000Z</published>
    <updated>2017-08-04T10:05:27.247Z</updated>
    
    <content type="html"><![CDATA[<p>libevent中提供了一个Hello-world.c 的例子，从这个例子可以学习libevent是如何使用bufferevent的。<br>这个例子在Sample中<br><img src="/2017/08/04/Libevent5/1.png" alt="1"><br>这个例子之前讲解过，这次主要看下bufferevent的使用。<br><a id="more"></a></p>
<h2 id="第一步找到main函数"><a href="#第一步找到main函数" class="headerlink" title="第一步找到main函数"></a>第一步找到main函数</h2><p>main函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="comment">//...</span></div><div class="line">listener = evconnlistener_new_bind(base, listener_cb, (<span class="keyword">void</span> *)base,</div><div class="line">        LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</div><div class="line">        (struct sockaddr*)&amp;<span class="built_in">sin</span>,</div><div class="line">        <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line"></div><div class="line"> <span class="comment">//...</span></div><div class="line"></div><div class="line">　　　　event_base_dispatch(base);</div><div class="line"></div><div class="line">　　　　evconnlistener_free(listener);</div><div class="line">　　　　event_free(signal_event);</div><div class="line">　　　　event_base_free(base);</div><div class="line"></div><div class="line">　　　　<span class="built_in">printf</span>(<span class="string">"done\n"</span>);</div><div class="line">　　　　<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main函数中调用evconnlistener_new_bind()创建了一个evconnlistener 类型的listener,然后拍发消息，之后释放各种资源。</p>
<h2 id="第二步在evconnlistener-new-bind-中调用evconnlistener-new-完成listener属性设置。"><a href="#第二步在evconnlistener-new-bind-中调用evconnlistener-new-完成listener属性设置。" class="headerlink" title="第二步在evconnlistener_new_bind()中调用evconnlistener_new()完成listener属性设置。"></a>第二步在evconnlistener_new_bind()中调用evconnlistener_new()完成listener属性设置。</h2><p>这个函数里对evconnlistener_event中base进行回调函数的绑定和参数设置，通过event_assign将evconnlistener_event的istener设置读事件的回调函数，并且通过evconnlistener_enable让读回调函数触发，也就是触发listener_read_cb。这里evconnlister_enable调用的也是结构体注册的enable具体看代码吧，调用的是r = lev-&gt;ops-&gt;enable(lev);等同于调用event_listener_enable，该函数内部完成event_add。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener_event</span> &#123;</span></div><div class="line">　　　　<span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> <span class="title">base</span>;</span></div><div class="line">　　　　<span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">listener</span>;</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *</span></div><div class="line"><span class="class"><span class="title">evconnlistener_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,</span></div><div class="line"><span class="class">    <span class="title">evconnlistener_cb</span> <span class="title">cb</span>, <span class="title">void</span> *<span class="title">ptr</span>, <span class="title">unsigned</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">backlog</span>,</span></div><div class="line"><span class="class">    <span class="title">evutil_socket_t</span> <span class="title">fd</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener_event</span> *<span class="title">lev</span>;</span><span class="comment">//开辟evconnlistener_event大小区域</span></div><div class="line">    lev = mm_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct evconnlistener_event));</div><div class="line">    <span class="keyword">if</span> (!lev)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">//lev -&gt; base 表示  evconnlistener </span></div><div class="line">    <span class="comment">//evconnlistener     evconnlistener_ops 基本回调参数和回调函数结构体赋值</span></div><div class="line">    lev-&gt;base.ops = &amp;evconnlistener_event_ops;</div><div class="line">    <span class="comment">//evconnlistener_cb 设置为listener_cb</span></div><div class="line">    lev-&gt;base.cb = cb;</div><div class="line">    <span class="comment">//ptr表示event_base 指针</span></div><div class="line">    lev-&gt;base.user_data = ptr;</div><div class="line">    lev-&gt;base.flags = flags;</div><div class="line">    lev-&gt;base.refcnt = <span class="number">1</span>;<span class="comment">//  lev   is evconnlistener_event       </span></div><div class="line">    <span class="comment">//lev-&gt;listener is event</span></div><div class="line">    <span class="comment">//为lev-&gt;listener设置读回调函数和读关注事件，仅进行设置并没加入event队列</span></div><div class="line">    event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST,</div><div class="line">        listener_read_cb, lev);</div><div class="line">    <span class="comment">//实际调用了event_add将事件加入event队列</span></div><div class="line">    evconnlistener_enable(&amp;lev-&gt;base);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &amp;lev-&gt;base;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第三步listener-read-cb内部调用accept生成新的socket处理连接，调用listener-cb"><a href="#第三步listener-read-cb内部调用accept生成新的socket处理连接，调用listener-cb" class="headerlink" title="第三步listener_read_cb内部调用accept生成新的socket处理连接，调用listener_cb"></a>第三步listener_read_cb内部调用accept生成新的socket处理连接，调用listener_cb</h2><p>新的socket作为参数传递给evconnlistener_event中base的回调函数listener_cb</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">listener_read_cb(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, <span class="keyword">void</span> *p)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">lev</span> = <span class="title">p</span>;</span></div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    evconnlistener_cb cb;</div><div class="line">    evconnlistener_errorcb errorcb;</div><div class="line">    <span class="keyword">void</span> *user_data;</div><div class="line">    LOCK(lev);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">      　　<span class="comment">//...//cb 就 是  listener_cb</span></div><div class="line">        cb = lev-&gt;cb;</div><div class="line">        user_data = lev-&gt;user_data;</div><div class="line">        UNLOCK(lev);</div><div class="line">        <span class="comment">//触发了listener_cb</span></div><div class="line">        </div><div class="line">        <span class="comment">//完成了eventbuffer注册写和事件函数  </span></div><div class="line">        cb(lev, new_fd, (struct sockaddr*)&amp;ss, (<span class="keyword">int</span>)socklen,</div><div class="line">            user_data);</div><div class="line">        </div><div class="line">        LOCK(lev);</div><div class="line">        <span class="keyword">if</span> (lev-&gt;refcnt == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> freed = listener_decref_and_unlock(lev);</div><div class="line">            EVUTIL_ASSERT(freed);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        --lev-&gt;refcnt;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第四步listener-cb-调用bufferevent-socket-new-生成bufferevent，"><a href="#第四步listener-cb-调用bufferevent-socket-new-生成bufferevent，" class="headerlink" title="第四步listener_cb 调用bufferevent_socket_new 生成bufferevent，"></a>第四步listener_cb 调用bufferevent_socket_new 生成bufferevent，</h2><p>然后bufferevent_setcb设置读写水位触发的回调函数，bufferevent_enable将bufferevent的写事件加入监听，即开始检测写事件。关闭读事件，并且向outbuf中写入MSG<br>bufferevent_socket_new内部绑定bufferevent的读写事件回调函数，读事件为bufev-&gt;ev_read，绑定了bufferevent_readcb回调函数，<br>写事件为bufev-&gt;ev_write，<br>绑定了bufferevent_writecb回调函数。这两个回调函数和bufferevent的readcb和writecb是不一样的，这两个函数在对应的读写事件激活时才触发。<br>而readcb和writecb是基于水位线达到阈值才会触发。做好区分。bufferevent_socket_new内部还对bufev-&gt;output添加了对调函数bufferevent_socket_outbuf_cb，<br>bufferevent_socket_outbuf_cb内部检测是否开启写事件，以及是否可写，如果可写，同样将写事件加入监听队列，也就是调用了event_add。<br>bufferevent_socket_new内部解释完毕了。bufferevent_setcb设置的是读写水位达到阈值后的回调函数，<br>bufferevent_enable内部也是调用了event_add，将读事件加入监听队列。<br>bufferevent_enable内部调用bufev-&gt;be_ops-&gt;enable(bufev, impl_events)，等同于be_socket_enable，另外bufferevent_write函数内部调用evbuffer_add，<br>evbuffer_add内部调用了evbuffer_invoke_callbacks，就会调用绑定在output buffer上的回调函数bufferevent_socket_outbuf_cb。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</div><div class="line">    struct sockaddr *sa, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *user_data)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></div><div class="line"></div><div class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</div><div class="line">    <span class="keyword">if</span> (!bev) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error constructing bufferevent!"</span>);</div><div class="line">        event_base_loopbreak(base);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置写回调和事件回调</span></div><div class="line">    bufferevent_setcb(bev, <span class="literal">NULL</span>, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</div><div class="line">    bufferevent_enable(bev, EV_WRITE);</div><div class="line">    bufferevent_disable(bev, EV_READ);</div><div class="line">    <span class="comment">//将要发送的内容写入evbuffer结构</span></div><div class="line">    bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</div><div class="line">&#125;</div><div class="line">``` cpp</div><div class="line"> </div><div class="line">``` cpp</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *</span></div><div class="line"><span class="class"><span class="title">bufferevent_socket_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>, <span class="title">evutil_socket_t</span> <span class="title">fd</span>,</span></div><div class="line"><span class="class">    <span class="title">int</span> <span class="title">options</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_private</span> *<span class="title">bufev_p</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bufev</span>;</span></div><div class="line"></div><div class="line">　　<span class="comment">//...//设置bufferevent中   ev_read(event类型)回调函数</span></div><div class="line">    event_assign(&amp;bufev-&gt;ev_read, bufev-&gt;ev_base, fd,</div><div class="line">        EV_READ|EV_PERSIST, bufferevent_readcb, bufev);</div><div class="line">    <span class="comment">//设置bufferevent中   ev_write(event类型)回调函数</span></div><div class="line">    event_assign(&amp;bufev-&gt;ev_write, bufev-&gt;ev_base, fd,</div><div class="line">        EV_WRITE|EV_PERSIST, bufferevent_writecb, bufev);</div><div class="line"></div><div class="line">    <span class="comment">//为bufev-&gt;output(evbuffer类型)设置回调函数，插入bufferevent-&gt;output的callback队列</span></div><div class="line">    <span class="comment">//bufferevent_socket_outbuf_cb回调函数内部将ev_write事件加入事件队列</span></div><div class="line">    evbuffer_add_cb(bufev-&gt;output, bufferevent_socket_outbuf_cb, bufev);</div><div class="line"></div><div class="line">    evbuffer_freeze(bufev-&gt;input, <span class="number">0</span>);</div><div class="line">    evbuffer_freeze(bufev-&gt;output, <span class="number">1</span>);</div><div class="line">  　　<span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> bufev;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">``` cpp</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">be_socket_enable(struct bufferevent *bufev, <span class="keyword">short</span> event)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (event &amp; EV_READ) &#123;</div><div class="line">        <span class="keyword">if</span> (be_socket_add(&amp;bufev-&gt;ev_read,&amp;bufev-&gt;timeout_read) == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event &amp; EV_WRITE) &#123;</div><div class="line">        <span class="keyword">if</span> (be_socket_add(&amp;bufev-&gt;ev_write,&amp;bufev-&gt;timeout_write) == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第五步-bufferevent的output中写入MSG，-并且之前也已经将EV-WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev-write，调用绑定在ev-write上的函数bufferevent-writecb。"><a href="#第五步-bufferevent的output中写入MSG，-并且之前也已经将EV-WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev-write，调用绑定在ev-write上的函数bufferevent-writecb。" class="headerlink" title="第五步 bufferevent的output中写入MSG， 并且之前也已经将EV_WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev_write，调用绑定在ev_write上的函数bufferevent_writecb。"></a>第五步 bufferevent的output中写入MSG， 并且之前也已经将EV_WRITE事件加入监听，所以内核检测到socket可写，会通知bufferevent的ev_write，调用绑定在ev_write上的函数bufferevent_writecb。</h2><p>这是bufferevent内部的写操作，我们可以详细看一下。之前也有讲过bufferevent会将接收到的数据放到inputbuffer中，将outputbuffer中的数据发送。所以之前讲过的接口bufferevent_write让我们将要发送的数据放到output中，bufferevent_read可以从input中读出bufferevent接收到的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">bufferevent_writecb(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bufev</span> = <span class="title">arg</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_private</span> *<span class="title">bufev_p</span> =</span></div><div class="line"><span class="class">        <span class="title">EVUTIL_UPCAST</span>(<span class="title">bufev</span>, <span class="title">struct</span> <span class="title">bufferevent_private</span>, <span class="title">bev</span>);</span></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">short</span> what = BEV_EVENT_WRITING;</div><div class="line">    <span class="keyword">int</span> connected = <span class="number">0</span>;</div><div class="line">    <span class="keyword">ev_ssize_t</span> atmost = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//对 bufferevent加锁，支持多线程安全模式</span></div><div class="line">    _bufferevent_incref_and_lock(bufev);</div><div class="line">    <span class="comment">//检测是否带有超时事件</span></div><div class="line">    <span class="keyword">if</span> (event == EV_TIMEOUT) &#123;</div><div class="line">        <span class="comment">/* Note that we only check for event==EV_TIMEOUT. If</span></div><div class="line"><span class="comment">         * event==EV_TIMEOUT|EV_WRITE, we can safely ignore the</span></div><div class="line"><span class="comment">         * timeout, since a read has occurred */</span></div><div class="line">        what |= BEV_EVENT_TIMEOUT;</div><div class="line">        <span class="keyword">goto</span> error;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否是连接事件</span></div><div class="line">    <span class="keyword">if</span> (bufev_p-&gt;connecting) &#123;</div><div class="line">        <span class="keyword">int</span> c = evutil_socket_finished_connecting(fd);</div><div class="line">        <span class="comment">/* we need to fake the error if the connection was refused</span></div><div class="line"><span class="comment">         * immediately - usually connection to localhost on BSD */</span></div><div class="line">        <span class="keyword">if</span> (bufev_p-&gt;connection_refused) &#123;</div><div class="line">          bufev_p-&gt;connection_refused = <span class="number">0</span>;</div><div class="line">          c = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line">        bufev_p-&gt;connecting = <span class="number">0</span>;</div><div class="line">        <span class="comment">//连接失败删除该事件</span></div><div class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</div><div class="line">            event_del(&amp;bufev-&gt;ev_write);</div><div class="line">            event_del(&amp;bufev-&gt;ev_read);</div><div class="line">            _bufferevent_run_eventcb(bufev, BEV_EVENT_ERROR);</div><div class="line">            <span class="keyword">goto</span> done;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            connected = <span class="number">1</span>;</div><div class="line">            <span class="comment">//windows情况下直接运行事件回调函数，然后go done</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">            <span class="keyword">if</span> (BEV_IS_ASYNC(bufev)) &#123;</div><div class="line">                event_del(&amp;bufev-&gt;ev_write);</div><div class="line">                bufferevent_async_set_connected(bufev);</div><div class="line">                _bufferevent_run_eventcb(bufev,</div><div class="line">                        BEV_EVENT_CONNECTED);</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">//linux 下 运行事件回调函数</span></div><div class="line">            _bufferevent_run_eventcb(bufev,</div><div class="line">                    BEV_EVENT_CONNECTED);</div><div class="line">        <span class="comment">//检测是否可写，不可写删除该事件</span></div><div class="line">            <span class="keyword">if</span> (!(bufev-&gt;enabled &amp; EV_WRITE) ||</div><div class="line">                bufev_p-&gt;write_suspended) &#123;</div><div class="line">                event_del(&amp;bufev-&gt;ev_write);</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//计算bufferevent能写的最大数量</span></div><div class="line">    atmost = _bufferevent_get_write_max(bufev_p);</div><div class="line">    <span class="comment">//写事件挂起了，跳过。</span></div><div class="line">    <span class="keyword">if</span> (bufev_p-&gt;write_suspended)</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    </div><div class="line">    <span class="comment">//output非空</span></div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(bufev-&gt;output)) &#123;</div><div class="line">        <span class="comment">//将output的头打开，从头部发送</span></div><div class="line">        evbuffer_unfreeze(bufev-&gt;output, <span class="number">1</span>);</div><div class="line">        <span class="comment">//bufferevent调用写操作，将outbuffer中的内容发送出去</span></div><div class="line">        res = evbuffer_write_atmost(bufev-&gt;output, fd, atmost);</div><div class="line">        <span class="comment">//将output的头部关闭</span></div><div class="line">        evbuffer_freeze(bufev-&gt;output, <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> err = evutil_socket_geterror(fd);</div><div class="line">            <span class="keyword">if</span> (EVUTIL_ERR_RW_RETRIABLE(err))</div><div class="line">                <span class="keyword">goto</span> reschedule;</div><div class="line">            what |= BEV_EVENT_ERROR;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/* eof case</span></div><div class="line"><span class="comment">               XXXX Actually, a 0 on write doesn't indicate</span></div><div class="line"><span class="comment">               an EOF. An ECONNRESET might be more typical.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">             <span class="comment">//写完了</span></div><div class="line">            what |= BEV_EVENT_EOF;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> error;</div><div class="line">        <span class="comment">//bufferevent减少发送的大小，留下未发送的，下次再发送，因为是PERSIST|WRITE</span></div><div class="line">        <span class="comment">//所以会在下次检测到可写时候继续写</span></div><div class="line">        _bufferevent_decrement_write_buckets(bufev_p, res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算是否将outbuf中的内容发送完，发完了就删除写事件</span></div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(bufev-&gt;output) == <span class="number">0</span>) &#123;</div><div class="line">        event_del(&amp;bufev-&gt;ev_write);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Invoke the user callback if our buffer is drained or below the</span></div><div class="line"><span class="comment">     * low watermark.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="comment">//将buffer中的内容发完，或者低于low 水位，那么调用用户注册的写回调函数</span></div><div class="line">    <span class="comment">//之前注册在bufev-&gt;writecb中的回调函数</span></div><div class="line">    <span class="keyword">if</span> ((res || !connected) &amp;&amp;</div><div class="line">        evbuffer_get_length(bufev-&gt;output) &lt;= bufev-&gt;wm_write.low) &#123;</div><div class="line">        _bufferevent_run_writecb(bufev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line"> reschedule:</div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(bufev-&gt;output) == <span class="number">0</span>) &#123;</div><div class="line">        event_del(&amp;bufev-&gt;ev_write);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line"> error:</div><div class="line">    bufferevent_disable(bufev, EV_WRITE);</div><div class="line">    _bufferevent_run_eventcb(bufev, what);</div><div class="line"></div><div class="line"> done:</div><div class="line">    _bufferevent_decref_and_unlock(bufev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第六步：这个函数内部每次尽可能多的发送数据，"><a href="#第六步：这个函数内部每次尽可能多的发送数据，" class="headerlink" title="第六步：这个函数内部每次尽可能多的发送数据，"></a>第六步：这个函数内部每次尽可能多的发送数据，</h2><p>没有发送完就下次轮询继续发送,直到水位低于或等于写数据的低水位，那么就会触发bufferevent低水位写回调函数。也就是conn_writecb，</p>
<p>在conn_writecb内部检测output buffer中数据为空，就释放该bufferevent。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> = <span class="title">bufferevent_get_output</span>(<span class="title">bev</span>);</span></div><div class="line">    <span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"flushed answer\n"</span>);</div><div class="line">        bufferevent_free(bev);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是整体流程，bufferevent内部的流畅看懂即可，我们只需要使用libevent提供的接口即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;libevent中提供了一个Hello-world.c 的例子，从这个例子可以学习libevent是如何使用bufferevent的。&lt;br&gt;这个例子在Sample中&lt;br&gt;&lt;img src=&quot;/2017/08/04/Libevent5/1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;这个例子之前讲解过，这次主要看下bufferevent的使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Linux环境编程" scheme="http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程的一些错误总结</title>
    <link href="http://www.limerence2017.com/2017/08/04/neterror/"/>
    <id>http://www.limerence2017.com/2017/08/04/neterror/</id>
    <published>2017-08-04T09:28:12.000Z</published>
    <updated>2017-08-04T09:37:22.790Z</updated>
    
    <content type="html"><![CDATA[<p>最近自己在写一套服务器框架，期间遇到很多问题，对于Linux或者windows出错情况下可以通过错误码获取错误信息。为了测试服务器性能，我在客户端开了2000个线程，这样每个线程都创建socket和服务器通信，连接15个线程，再后来的客户端线程connect过程中会失败，我另起了一个客户端进程进行连接，还是能连接15个过后才出现问题，初步可以排除服务器并没有达到连接上限，之后在linux上打印该错误码为111，查询意思为服务器拒绝客户端连接。查询相关资料是监听队列设置为5，只能接受一部分剩余的由于监听队列满了就被拒绝了。之后查询libevent和redis库的一些监听队列大小，设置为128较为合适，这次同样会出现一部分客户端连接失败，因为监听队列总是有限的，尽管如此，极限的情况下一秒同时连接500多个客户端还是没问题。<br><a id="more"></a><br>这个监听队列的知识可以介绍下：<br><img src="/2017/08/04/neterror/1.gif" alt="1"><br>这个图说明tcp是三次握手处理连接和四次握手处理断开。</p>
<p>listen函数将主动套接字转换为被动监控套接字，其第二个参数backlog决定了内核的连接缓存队列长度。对于一个给定的监听套接字，内核维护两个队列：</p>
<p>① 未就绪队列，存放没有完成三路握手的连接，监听套接字收到SYN并返回ACK+SYN，连接处于SYN_RECV状态，等待对端发送ACK。如果已完成队列非满，则接收ACK，连接握手完成，进入已完成队列；如果已完成队列满则丢弃ACK，对端重发ACK（对端看到的连接是ESTABLISED状态），若未就绪队列中的SYN_RECV等待直到超时还没进入已完成队列则丢弃连接（对端不知道，只有在读写套接字时才知道）。</p>
<p>② 已完成队列，存放已经完成三路握手的连接（ESTABLISHED），等待accept取走连接。</p>
<p>backlog决定了两个队列的长度之和（并不是说两个队列之和等于backlog，而是存在个转换，依赖于具体实现）。</p>
<p>如果未就绪队列满则忽略新到来的SYN请求，对端重发，如果一直不能进入未就绪队列则对端connect失败返回。</p>
<p>除此之外，由于每个客户端进程我开辟了2000个线程，也会报错errorno为9，意为bad file discirp，错误的文件描述符。</p>
<p>因为linux限制每个进程最多开辟1024个线程。</p>
<p>这些都是实际开发中遇到的一些问题，总结出来以便更好地处理以后的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近自己在写一套服务器框架，期间遇到很多问题，对于Linux或者windows出错情况下可以通过错误码获取错误信息。为了测试服务器性能，我在客户端开了2000个线程，这样每个线程都创建socket和服务器通信，连接15个线程，再后来的客户端线程connect过程中会失败，我另起了一个客户端进程进行连接，还是能连接15个过后才出现问题，初步可以排除服务器并没有达到连接上限，之后在linux上打印该错误码为111，查询意思为服务器拒绝客户端连接。查询相关资料是监听队列设置为5，只能接受一部分剩余的由于监听队列满了就被拒绝了。之后查询libevent和redis库的一些监听队列大小，设置为128较为合适，这次同样会出现一部分客户端连接失败，因为监听队列总是有限的，尽管如此，极限的情况下一秒同时连接500多个客户端还是没问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程一些常见问题总结</title>
    <link href="http://www.limerence2017.com/2017/08/04/newproblem/"/>
    <id>http://www.limerence2017.com/2017/08/04/newproblem/</id>
    <published>2017-08-04T09:19:14.000Z</published>
    <updated>2017-08-04T09:26:41.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置网络socket非阻塞："><a href="#1-设置网络socket非阻塞：" class="headerlink" title="1 设置网络socket非阻塞："></a>1 设置网络socket非阻塞：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u_long has = <span class="number">1</span>;</div><div class="line">ioctl(m_sock, FIONBIO , &amp;has);</div></pre></td></tr></table></figure>
<p>这个函数很有可能返回success，却并没有设置成功。<br>windows对此有优化，对于linux版本应采用fcntl设置。</p>
<p>总结如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span></div><div class="line">make_socket_nonblocking(sockfd fd)</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">    &#123;</div><div class="line">        u_long nonblocking = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (ioctlsocket(fd, FIONBIO, &amp;nonblocking) == SOCKET_ERROR) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fcntl failed, fd is : "</span> &lt;&lt; fd; </div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> flags;</div><div class="line">        <span class="keyword">if</span> ((flags = fcntl(fd, F_GETFL, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fcntl failed, fd is : "</span> &lt;&lt; fd;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fcntl failed, fd is : "</span> &lt;&lt; fd;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="2-windows环境下查看错误"><a href="#2-windows环境下查看错误" class="headerlink" title="2 windows环境下查看错误"></a>2 windows环境下查看错误</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">使用WSAGetLastError函数需要配置</div><div class="line"> </div><div class="line">lib,<span class="string">"ws2_32.lib"</span></div></pre></td></tr></table></figure>
<h2 id="3-EPOLLET这个宏是最小int"><a href="#3-EPOLLET这个宏是最小int" class="headerlink" title="3 EPOLLET这个宏是最小int"></a>3 EPOLLET这个宏是最小int</h2><p>EPOLLET这个宏的数值为-2147483648， 是能表示的最小int值。</p>
<h2 id="4-make-警告：检测到时钟错误。您的创建可能是不完整的。"><a href="#4-make-警告：检测到时钟错误。您的创建可能是不完整的。" class="headerlink" title="4 make: 警告：检测到时钟错误。您的创建可能是不完整的。"></a>4 make: 警告：检测到时钟错误。您的创建可能是不完整的。</h2><p>可以通过ls -l查看具体的是哪个文件的时间错了，就可以对症下药了，直接 “ touch 对应文件 “ 就可以解决这个问题。</p>
<p>或者读者可以用 “ touch * “ 来更新整个项目文件的时间,这也可以解决问题。</p>
<h2 id="5-select-fd-set-对于不同平台实现是不同的"><a href="#5-select-fd-set-对于不同平台实现是不同的" class="headerlink" title="5 select fd_set 对于不同平台实现是不同的"></a>5 select fd_set 对于不同平台实现是不同的</h2><p>在windows平台实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> &#123;</span></div><div class="line">        u_int fd_count;               <span class="comment">/* how many are SET? */</span></div><div class="line">        SOCKET  fd_array[FD_SETSIZE];   <span class="comment">/* an array of SOCKETs */</span></div><div class="line">&#125; fd_set;</div></pre></td></tr></table></figure></p>
<p>很明了，一个计数的fd_count，另一个就是SOCKET数组。其中，FD_SETSIZE是可以设置的。整个fd_set的过程实际上就是将对应的<br>fd_count作为数组下标，数组元素存储的是对应socket fd。比如说当前读事件集合readset的fd_count 为7，当要监控socket fd为5 的读事件到来时，那么readset这个集合中下标为8的数组元素为5，fd_count  = 8以此类推。当调用select时，会返回对应读，写集合所有的描述符数组，并且重置内部的fd_count数量，然后分别调用读写函数即可。</p>
<p>下面是fd_set在linux下的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">  &#123;</span></div><div class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></div><div class="line"><span class="comment">       from the global namespace.  */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></div><div class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></div><div class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125; fd_set;</div></pre></td></tr></table></figure></p>
<p>根据UNIX网络编程对fd_set的介绍，fd_set是个整数数组，用每个bit位来表示fd的。比如，一个32位整数，则数组第一个整数表示0-31的fd，以此类推，第二个整数表示32-63<br>查看linux的FD_SET、FD_CLR是用汇编实现的。根据说明可以知道，就是给bit置位。<br>fd_set在不同平台实现的机制不一样，select第一个参数在linux环境下表示最大描述符数+1。windows无意义。</p>
<p>下面是我根据libevent早期版本实现的一套select模型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"modelmanager.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"netmodeldef.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> XFREE(ptr) do &#123; <span class="meta-keyword">if</span> (ptr) free(ptr); &#125; while (0)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> &#123;</span></div><div class="line">    u_int fd_count;</div><div class="line">    SOCKET fd_array[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">win32op</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> num_fds_in_fd_sets;</div><div class="line">    <span class="keyword">int</span> resize_out_sets;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">readset_in</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">writeset_in</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">readset_out</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">writeset_out</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">exset_out</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> signals_are_broken : <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">win32_init</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win32_add</span><span class="params">(<span class="keyword">void</span> *, sockfd, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *_idx)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win32_del</span><span class="params">(<span class="keyword">void</span> *, sockfd, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *_idx)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win32_dispatch</span><span class="params">(<span class="keyword">void</span> *base, struct timeval *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">win32_dealloc</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModelOp</span> <span class="title">win32ops</span> = &#123;</span></div><div class="line">    <span class="string">"win32"</span>,</div><div class="line">    win32_init,</div><div class="line">    win32_add,</div><div class="line">    win32_del,</div><div class="line">    win32_dispatch,</div><div class="line">    win32_dealloc,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SET_ALLOC_SIZE(n) ((sizeof(struct win_fd_set) + ((n)-1)*sizeof(SOCKET)))</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">grow_fd_sets(struct win32op *op, <span class="keyword">unsigned</span> new_num_fds)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( !(new_num_fds &gt;= op-&gt;readset_in-&gt;fd_count &amp;&amp;</div><div class="line">        new_num_fds &gt;= op-&gt;writeset_in-&gt;fd_count) )</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>( !(new_num_fds &gt;= <span class="number">1</span>) )</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    size = FD_SET_ALLOC_SIZE(new_num_fds);</div><div class="line">    <span class="keyword">if</span> (!(op-&gt;readset_in = (struct win_fd_set *)<span class="built_in">realloc</span>(op-&gt;readset_in, size)))</div><div class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span> (!(op-&gt;writeset_in = (struct win_fd_set *)<span class="built_in">realloc</span>(op-&gt;writeset_in, size)))</div><div class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">    op-&gt;resize_out_sets = <span class="number">1</span>;</div><div class="line">    op-&gt;num_fds_in_fd_sets = new_num_fds;</div><div class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">do_fd_set(struct win32op *op, struct SocketIndex *ent, SOCKET s, <span class="keyword">int</span> read)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">set</span> = <span class="title">read</span> ? <span class="title">op</span>-&gt;<span class="title">readset_in</span> :</span> op-&gt;writeset_in;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (read) &#123;</div><div class="line">        <span class="keyword">if</span> (ent-&gt;read_pos_plus1 &gt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ent-&gt;write_pos_plus1 &gt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;fd_count == op-&gt;num_fds_in_fd_sets) &#123;</div><div class="line">        <span class="keyword">if</span> (grow_fd_sets(op, op-&gt;num_fds_in_fd_sets*<span class="number">2</span>))</div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">        <span class="comment">// set pointer will have changed and needs reiniting!</span></div><div class="line">        <span class="built_in">set</span> = read ? op-&gt;readset_in : op-&gt;writeset_in;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span>-&gt;fd_array[<span class="built_in">set</span>-&gt;fd_count] = s;</div><div class="line">    <span class="keyword">if</span> (read)</div><div class="line">        ent-&gt;read_pos_plus1 = <span class="built_in">set</span>-&gt;fd_count+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ent-&gt;write_pos_plus1 = <span class="built_in">set</span>-&gt;fd_count+<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">set</span>-&gt;fd_count++);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">do_fd_clear(<span class="keyword">void</span> *base,</div><div class="line">struct win32op *op, struct SocketIndex *ent, <span class="keyword">int</span> read)</div><div class="line">&#123;</div><div class="line">    ModelManager* pDispatcher = (ModelManager*)base;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win_fd_set</span> *<span class="title">set</span> = <span class="title">read</span> ? <span class="title">op</span>-&gt;<span class="title">readset_in</span> :</span> op-&gt;writeset_in;</div><div class="line">    <span class="keyword">if</span> (read) &#123;</div><div class="line">        i = ent-&gt;read_pos_plus1 - <span class="number">1</span>;</div><div class="line">        ent-&gt;read_pos_plus1 = <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        i = ent-&gt;write_pos_plus1 - <span class="number">1</span>;</div><div class="line">        ent-&gt;write_pos_plus1 = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (--<span class="built_in">set</span>-&gt;fd_count != (<span class="keyword">unsigned</span>)i) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SocketIndex</span> *<span class="title">ent2</span>;</span></div><div class="line">        SOCKET s2;</div><div class="line">        s2 = <span class="built_in">set</span>-&gt;fd_array[i] = <span class="built_in">set</span>-&gt;fd_array[<span class="built_in">set</span>-&gt;fd_count];</div><div class="line"></div><div class="line">        ent2 = pDispatcher-&gt;getSocketIndex( s2 );</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!ent2) <span class="comment">// This indicates a bug.</span></div><div class="line">            <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (read)</div><div class="line">            ent2-&gt;read_pos_plus1 = i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            ent2-&gt;write_pos_plus1 = i+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NEVENT 32</span></div><div class="line"><span class="keyword">void</span> *</div><div class="line">win32_init(<span class="keyword">void</span> *base)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win32op</span> *<span class="title">winop</span>;</span></div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line">    <span class="keyword">if</span> (!(winop = (struct win32op*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(struct win32op))))</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    winop-&gt;num_fds_in_fd_sets = NEVENT;</div><div class="line">    size = FD_SET_ALLOC_SIZE(NEVENT);</div><div class="line">    <span class="keyword">if</span> (!(winop-&gt;readset_in = (struct win_fd_set *)<span class="built_in">malloc</span>(size)))</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    <span class="keyword">if</span> (!(winop-&gt;writeset_in = (struct win_fd_set *)<span class="built_in">malloc</span>(size)))</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    <span class="keyword">if</span> (!(winop-&gt;readset_out = (struct win_fd_set *)<span class="built_in">malloc</span>(size)))</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    <span class="keyword">if</span> (!(winop-&gt;writeset_out = (struct win_fd_set *)<span class="built_in">malloc</span>(size)))</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    <span class="keyword">if</span> (!(winop-&gt;exset_out = (struct win_fd_set *)<span class="built_in">malloc</span>(size)))</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    winop-&gt;readset_in-&gt;fd_count = winop-&gt;writeset_in-&gt;fd_count = <span class="number">0</span>;</div><div class="line">    winop-&gt;readset_out-&gt;fd_count = winop-&gt;writeset_out-&gt;fd_count</div><div class="line">        = winop-&gt;exset_out-&gt;fd_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    winop-&gt;resize_out_sets = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (winop);</div><div class="line">err:</div><div class="line">    XFREE(winop-&gt;readset_in);</div><div class="line">    XFREE(winop-&gt;writeset_in);</div><div class="line">    XFREE(winop-&gt;readset_out);</div><div class="line">    XFREE(winop-&gt;writeset_out);</div><div class="line">    XFREE(winop-&gt;exset_out);</div><div class="line">    XFREE(winop);</div><div class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span></div><div class="line">win32_add(<span class="keyword">void</span> *base, SOCKET fd,</div><div class="line">          <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *_idx)</div><div class="line">&#123;</div><div class="line">    ModelManager* pDispatcher = (ModelManager*)base;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win32op</span> *<span class="title">winop</span> = (<span class="title">struct</span> <span class="title">win32op</span> *)<span class="title">pDispatcher</span>-&gt;<span class="title">getModelData</span>();</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SocketIndex</span> *<span class="title">idx</span> = (<span class="title">struct</span> <span class="title">SocketIndex</span> *)_<span class="title">idx</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(events &amp; (EV_READ|EV_WRITE)))</div><div class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//event_debug(("%s: adding event for %d", __func__, (int)fd));</span></div><div class="line">    <span class="keyword">if</span> (events &amp; EV_READ) &#123;</div><div class="line">        <span class="keyword">if</span> (do_fd_set(winop, idx, fd, <span class="number">1</span>)&lt;<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (events &amp; EV_WRITE) &#123;</div><div class="line">        <span class="keyword">if</span> (do_fd_set(winop, idx, fd, <span class="number">0</span>)&lt;<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span></div><div class="line">win32_del(<span class="keyword">void</span> *base, SOCKET fd, <span class="keyword">short</span> old, <span class="keyword">short</span> events,</div><div class="line">          <span class="keyword">void</span> *_idx)</div><div class="line">&#123;</div><div class="line">    ModelManager* pDispatcher = (ModelManager*)base;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win32op</span> *<span class="title">winop</span> = (<span class="title">struct</span> <span class="title">win32op</span> *)<span class="title">pDispatcher</span>-&gt;<span class="title">getModelData</span>();</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SocketIndex</span> *<span class="title">idx</span> = (<span class="title">struct</span> <span class="title">SocketIndex</span> *)_<span class="title">idx</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">//event_debug(("%s: Removing event for "EV_SOCK_FMT,__func__, EV_SOCK_ARG(fd)));</span></div><div class="line">    <span class="keyword">if</span> ( (old &amp; EV_READ) &amp;&amp; !(events &amp; EV_READ) )</div><div class="line">        do_fd_clear(base, winop, idx, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> ( (old &amp; EV_WRITE) &amp;&amp; !(events &amp; EV_WRITE) )</div><div class="line">        do_fd_clear(base, winop, idx, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">fd_set_copy(struct win_fd_set *out, <span class="keyword">const</span> struct win_fd_set *in)</div><div class="line">&#123;</div><div class="line">    out-&gt;fd_count = in-&gt;fd_count;</div><div class="line">    <span class="built_in">memcpy</span>(out-&gt;fd_array, in-&gt;fd_array, in-&gt;fd_count * (<span class="keyword">sizeof</span>(SOCKET)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">static void dump_fd_set(struct win_fd_set *s)</span></div><div class="line"><span class="comment">&#123;</span></div><div class="line"><span class="comment">unsigned int i;</span></div><div class="line"><span class="comment">printf("[ ");</span></div><div class="line"><span class="comment">for(i=0;i&lt;s-&gt;fd_count;++i)</span></div><div class="line"><span class="comment">printf("%d ",(int)s-&gt;fd_array[i]);</span></div><div class="line"><span class="comment">printf("]\n");</span></div><div class="line"><span class="comment">&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="keyword">int</span></div><div class="line">win32_dispatch(<span class="keyword">void</span> *base, struct timeval *tv)</div><div class="line">&#123;</div><div class="line">    ModelManager* pDispatcher = (ModelManager*)base;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win32op</span> *<span class="title">winop</span> = (<span class="title">struct</span> <span class="title">win32op</span> *)<span class="title">pDispatcher</span>-&gt;<span class="title">getModelData</span>();</span></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> j, i;</div><div class="line">    <span class="keyword">int</span> fd_count;</div><div class="line">    SOCKET s;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (winop-&gt;resize_out_sets) &#123;</div><div class="line">        <span class="keyword">size_t</span> size = FD_SET_ALLOC_SIZE(winop-&gt;num_fds_in_fd_sets);</div><div class="line">        <span class="keyword">if</span> (!(winop-&gt;readset_out = (struct win_fd_set *)<span class="built_in">realloc</span>(winop-&gt;readset_out, size)))</div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span> (!(winop-&gt;exset_out = (struct win_fd_set *)<span class="built_in">realloc</span>(winop-&gt;exset_out, size)))</div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span> (!(winop-&gt;writeset_out = (struct win_fd_set *)<span class="built_in">realloc</span>(winop-&gt;writeset_out, size)))</div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">        winop-&gt;resize_out_sets = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fd_set_copy(winop-&gt;readset_out, winop-&gt;readset_in);</div><div class="line">    fd_set_copy(winop-&gt;exset_out, winop-&gt;writeset_in);</div><div class="line">    fd_set_copy(winop-&gt;writeset_out, winop-&gt;writeset_in);</div><div class="line"></div><div class="line">    fd_count =</div><div class="line">        (winop-&gt;readset_out-&gt;fd_count &gt; winop-&gt;writeset_out-&gt;fd_count) ?</div><div class="line">        winop-&gt;readset_out-&gt;fd_count : winop-&gt;writeset_out-&gt;fd_count;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!fd_count) &#123;</div><div class="line">        Sleep(tv-&gt;tv_usec/<span class="number">1000</span>);</div><div class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    res = select(fd_count,</div><div class="line">        (struct fd_set*)winop-&gt;readset_out,</div><div class="line">        (struct fd_set*)winop-&gt;writeset_out,</div><div class="line">        (struct fd_set*)winop-&gt;exset_out, tv);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//event_debug(("%s: select returned %d", __func__, res));</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span>( res == <span class="number">-1</span> )</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"error:%d\n"</span>, getErrno() );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (winop-&gt;readset_out-&gt;fd_count) &#123;</div><div class="line">        i = rand() % winop-&gt;readset_out-&gt;fd_count;</div><div class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;winop-&gt;readset_out-&gt;fd_count; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (++i &gt;= winop-&gt;readset_out-&gt;fd_count)</div><div class="line">                i = <span class="number">0</span>;</div><div class="line">            s = winop-&gt;readset_out-&gt;fd_array[i];</div><div class="line">            pDispatcher-&gt;insertActiveList( s, EV_READ);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (winop-&gt;exset_out-&gt;fd_count) &#123;</div><div class="line">        i = rand() % winop-&gt;exset_out-&gt;fd_count;</div><div class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;winop-&gt;exset_out-&gt;fd_count; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (++i &gt;= winop-&gt;exset_out-&gt;fd_count)</div><div class="line">                i = <span class="number">0</span>;</div><div class="line">            s = winop-&gt;exset_out-&gt;fd_array[i];</div><div class="line">            pDispatcher-&gt;insertActiveList( s, EV_WRITE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (winop-&gt;writeset_out-&gt;fd_count) &#123;</div><div class="line">        SOCKET s;</div><div class="line">        i = rand() % winop-&gt;writeset_out-&gt;fd_count;</div><div class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;winop-&gt;writeset_out-&gt;fd_count; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (++i &gt;= winop-&gt;writeset_out-&gt;fd_count)</div><div class="line">                i = <span class="number">0</span>;</div><div class="line">            s = winop-&gt;writeset_out-&gt;fd_array[i];</div><div class="line">            pDispatcher-&gt;insertActiveList( s, EV_WRITE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span></div><div class="line">win32_dealloc(<span class="keyword">void</span> *base)</div><div class="line">&#123;</div><div class="line">    ModelManager* pDispatcher = (ModelManager*)base;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">win32op</span> *<span class="title">winop</span> = (<span class="title">struct</span> <span class="title">win32op</span> *)<span class="title">pDispatcher</span>-&gt;<span class="title">getModelData</span>();</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (winop-&gt;readset_in)</div><div class="line">        <span class="built_in">free</span>(winop-&gt;readset_in);</div><div class="line">    <span class="keyword">if</span> (winop-&gt;writeset_in)</div><div class="line">        <span class="built_in">free</span>(winop-&gt;writeset_in);</div><div class="line">    <span class="keyword">if</span> (winop-&gt;readset_out)</div><div class="line">        <span class="built_in">free</span>(winop-&gt;readset_out);</div><div class="line">    <span class="keyword">if</span> (winop-&gt;writeset_out)</div><div class="line">        <span class="built_in">free</span>(winop-&gt;writeset_out);</div><div class="line">    <span class="keyword">if</span> (winop-&gt;exset_out)</div><div class="line">        <span class="built_in">free</span>(winop-&gt;exset_out);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(winop, <span class="number">0</span>, <span class="keyword">sizeof</span>(winop));</div><div class="line">    <span class="built_in">free</span>(winop);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-设置网络socket非阻塞：&quot;&gt;&lt;a href=&quot;#1-设置网络socket非阻塞：&quot; class=&quot;headerlink&quot; title=&quot;1 设置网络socket非阻塞：&quot;&gt;&lt;/a&gt;1 设置网络socket非阻塞：&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;u_long has = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ioctl(m_sock, FIONBIO , &amp;amp;has);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数很有可能返回success，却并没有设置成功。&lt;br&gt;windows对此有优化，对于linux版本应采用fcntl设置。&lt;/p&gt;
&lt;p&gt;总结如下：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;make_socket_nonblocking(sockfd fd)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; WIN32&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        u_long nonblocking = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ioctlsocket(fd, FIONBIO, &amp;amp;nonblocking) == SOCKET_ERROR) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;fcntl failed, fd is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; fd; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((flags = fcntl(fd, F_GETFL, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;fcntl failed, fd is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; fd;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;fcntl failed, fd is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; fd;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ECONNRESET和WSAECONNRESET怎么产生的以及如何避免</title>
    <link href="http://www.limerence2017.com/2017/08/04/econreset/"/>
    <id>http://www.limerence2017.com/2017/08/04/econreset/</id>
    <published>2017-08-04T09:02:28.000Z</published>
    <updated>2017-08-04T09:19:53.829Z</updated>
    
    <content type="html"><![CDATA[<p><code>ECONNRESET</code>是linux环境网络编程产生的错误，错误码为104，</p>
<p><code>WSAECONNRESET</code>是windows环境网络编程产生的错误，错误码为10054</p>
<p>两者产生的原因都一样，分以下几种情况：</p>
<p>1<code>接收端recv或者read， 对端已经关闭连接，recv/read返回该错误</code></p>
<p>2 对端重启连接，还未建立连接</p>
<p>3 <code>发送端已经断开连接，但是调用send会触发这个错误</code></p>
<p>第二点第三点都可以通过判断返回值解决，第一点在一些看似正常情况下也会触发该错误。比如对端close(fd)，接收端调用recv并没有返回0，而是-1，打印错误码为104或</p>
<p>10054，按道理讲这种情况按照返回值为0处理是可以的，但是尽量将代码写的规范一些，避免不必要的错误。<br><a id="more"></a></p>
<p>为什么close(fd)会导致接收端读到复位RST，也就是收到错误的104呢？</p>
<p>因为close(fd)只是将文件描述符关闭，并没有关闭tcp建立起来的连接，断开连接需要四次握手，倘若发送端发送缓冲区有数据未发送完或者接受缓冲区有数据未读完，调用close(fd)，那么连接并没有关闭，这样，接收端收到的就是所谓的104或10054错误了。如何避免这个错误呢，就需要我们判断发送端发送和接受操作是否进行完，也就是判断缓冲区是否有数据，如果有数据需要等待数据处理完毕在关闭，否则会出现上述错误。</p>
<p>有一个做法是通过调用shutdown(s,SHUT_WR);<br>关闭发送端的写端，这样发送端不发送数据，然后调用close这次会发送关闭连接的FIN标志，接收端接收到FIN，那么recv或者read返回的就是0.</p>
<p>int shutdown(int sockfd,int how);<br>　　Sockfd是需要关闭的socket的描述符。参数 how允许为shutdown操作选择以下几种方式：<br>    SHUT_RD：关闭连接的读端。也就是该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被丢弃。</p>
<p>　　进程将不能对该套接字发出任何读操作。</p>
<p>　　对 TCP套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。<br>    SHUT_WR:关闭连接的写端，进程不能在对此套接字发出写操作<br>    SHUT_RDWR:相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR</p>
<p>下面摘用网上的一段话来说明二者的区别：<br>close—–关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id<br>shutdown–则破坏了socket 链接，读的时候可能侦探到EOF结束符，写的时候可能会收到一个SIGPIPE信号，这个信号可能直到<br>socket buffer被填充了才收到。</p>
<p> close(sockfd);使用close中止一个连接，但它只是减少描述符的参考数，并不直接关闭连接，只有当描述符的参考数为0时才关闭连接。</p>
<p>而且shutdown只是处理连接关闭，并不能回收描述符，所以最终还是要调用close(fd)才能回收描述符，在所有描述符引用次数为0时发送</p>
<p>FIN消息给对端。</p>
<p>出了采取shutdown的方式，还可以通过设置socket属性，调用close时，检测在socket完成缓冲区读写后，才关闭连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></div><div class="line"> </div><div class="line">     <span class="keyword">int</span> l_onoff; <span class="comment">/* 0 = off, nozero = on */</span></div><div class="line"> </div><div class="line">     <span class="keyword">int</span> l_linger; <span class="comment">/* linger time */</span></div><div class="line"> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有下列三种情况：<br>1、设置 l_onoff为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close调用会立即返回给调用者，如果可能将会传输任何未发送的数据；</p>
<p>2、设置 l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；</p>
<p>3、设置 l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。</p>
<p>下面是代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> z;</div><div class="line"> <span class="keyword">int</span> s;      </div><div class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></div><div class="line">  </div><div class="line"> so_linger.l_onoff = <span class="number">1</span></div><div class="line"> so_linger.l_linger = <span class="number">30</span>;</div><div class="line"> z = setsockopt(s,SOL_SOCKET,SO_LINGER,&amp;so_linger,</div><div class="line">     <span class="keyword">sizeof</span> so_linger);</div><div class="line"> <span class="keyword">if</span> ( z )</div><div class="line">     perror(<span class="string">"setsockopt(2)"</span>);</div><div class="line">     close(s);</div></pre></td></tr></table></figure></p>
<p>到目前为止，我觉得比较好的主动关闭方式是：</p>
<p>关闭端：</p>
<p>1确保发送缓存区没有数据未发送，调用shutdown(fd,SHUTWR);</p>
<p>2如果能接收到数据，继续接受，直到接收到对方的FIN，也就是</p>
<p>read返回0或者-1</p>
<p>3如果接收到关闭信号，那么调用close正常关闭。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ECONNRESET&lt;/code&gt;是linux环境网络编程产生的错误，错误码为104，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WSAECONNRESET&lt;/code&gt;是windows环境网络编程产生的错误，错误码为10054&lt;/p&gt;
&lt;p&gt;两者产生的原因都一样，分以下几种情况：&lt;/p&gt;
&lt;p&gt;1&lt;code&gt;接收端recv或者read， 对端已经关闭连接，recv/read返回该错误&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2 对端重启连接，还未建立连接&lt;/p&gt;
&lt;p&gt;3 &lt;code&gt;发送端已经断开连接，但是调用send会触发这个错误&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二点第三点都可以通过判断返回值解决，第一点在一些看似正常情况下也会触发该错误。比如对端close(fd)，接收端调用recv并没有返回0，而是-1，打印错误码为104或&lt;/p&gt;
&lt;p&gt;10054，按道理讲这种情况按照返回值为0处理是可以的，但是尽量将代码写的规范一些，避免不必要的错误。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Udp打洞原理和源代码。</title>
    <link href="http://www.limerence2017.com/2017/08/04/udphole/"/>
    <id>http://www.limerence2017.com/2017/08/04/udphole/</id>
    <published>2017-08-04T08:52:04.000Z</published>
    <updated>2017-08-04T08:57:32.732Z</updated>
    
    <content type="html"><![CDATA[<p>所谓<code>udp打洞</code>就是指客户端A通过<code>udp协议</code>向服务器发送数据包，服务器收到后，获取数据包，并且可获取客户端A<code>地址和端口号</code>。同样在客户端B发送给服务器udp数据包后，服务器同样在收到B发送过来的数据包后获取B的地址和端口号，将A和B的地址与端口号分别发送给对方，这样双方可以继续用UDP协议通信。这么做有什么用呢？因为对于一些应用或者需求，需要两个客户端临时做一些通信，而这种通信不需要建立tcp就可以完成，所以才去udp打洞。</p>
<p>下面附上测试代码：</p>
<p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// udphole.cpp : 定义控制台应用程序的入口点。</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></div><div class="line"><span class="keyword">typedef</span> SOCKET socketfd;</div><div class="line"><span class="keyword">typedef</span> SOCKADDR_IN sockaddr_in;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line"></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> socketfd;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>服务器端核心代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;SOCKADDR_IN&gt; addrList;</div><div class="line"></div><div class="line">    WSADATA    wsaData = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"WSAStartup failed. errno=[%d]\n"</span>, WSAGetLastError());</div><div class="line">        <span class="keyword">return</span>    <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;sockaddr_in&gt; addrList;</div><div class="line">    </div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">//addrList 是地址列表，每次存放最新到来的。</span></div><div class="line">    socketfd sockServer = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</div><div class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sockServer)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">        <span class="built_in">printf</span> (<span class="string">"socket server failed. errno=[%d]\n"</span>, WSAGetLastError());</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> __linx__</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"socket server failed. errno=[%d]\n"</span>, errno);</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span>    </span></div><div class="line">    </div><div class="line">        <span class="keyword">return</span>    <span class="number">-2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    sockaddr_in    addrServer = &#123;<span class="number">0</span>&#125;;</div><div class="line">    </div><div class="line">    addrServer.sin_family    = AF_INET;</div><div class="line">    addrServer.sin_addr.s_addr = INADDR_ANY;<span class="comment">//inet_addr("192.168.1.2");</span></div><div class="line">    addrServer.sin_port = htons(<span class="number">10000</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != bind(sockServer, (sockaddr*)&amp;addrServer, <span class="keyword">sizeof</span>(addrServer)))</div><div class="line">    &#123;</div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">        <span class="built_in">printf</span> (<span class="string">"bind server failed.errno=[%d]\n"</span>, WSAGetLastError());</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"bind server failed.errno=[%d]\n"</span>, errno);</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span>        </span></div><div class="line"></div><div class="line">        <span class="keyword">return</span>    <span class="number">-3</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"okok6"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">char</span>    pcContent1[<span class="number">10240</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        sockaddr_in    addrUser1 = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">        <span class="keyword">int</span>    nLen1 = <span class="keyword">sizeof</span>(addrUser1);</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">        <span class="keyword">socklen_t</span> nLen1 = <span class="keyword">sizeof</span>(addrUser1);</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="comment">//服务器接收来自客户端的消息，并且用addrUser1保存地址和端口</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == recvfrom(sockServer, pcContent1, <span class="keyword">sizeof</span>(pcContent1), <span class="number">0</span>, (sockaddr*)&amp;addrUser1, &amp;nLen1))</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"dfdfda"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">            <span class="built_in">printf</span> (<span class="string">"recv user 1 failed.errno=[%d]"</span>, WSAGetLastError());</div><div class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">            <span class="built_in">printf</span> (<span class="string">"recv user 1 failed.errno=[%d]"</span>, errno);</div><div class="line">            <span class="meta">#<span class="meta-keyword">endif</span>            </span></div><div class="line"></div><div class="line">            <span class="keyword">return</span>    <span class="number">-4</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="built_in">printf</span> (<span class="string">"connect user ip=[%s] port=[%d]\n"</span>, inet_ntoa(addrUser1.sin_addr), htons(addrUser1.sin_port));</div><div class="line">           <span class="comment">//如果地址列表非空，那么取出列表中的地址，并且与最新到来的客户端通信</span></div><div class="line">            <span class="keyword">if</span>(addrList.size())</div><div class="line">            &#123;</div><div class="line">                sockaddr_in peerAddr = addrList.front();</div><div class="line">                <span class="keyword">int</span> nLen2 = <span class="keyword">sizeof</span>(peerAddr);</div><div class="line">                <span class="built_in">printf</span> (<span class="string">"peer user ip=[%s] port=[%d]\n"</span>, inet_ntoa(peerAddr.sin_addr), htons(peerAddr.sin_port));</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == sendto(sockServer, (<span class="keyword">char</span>*)&amp;addrUser1, nLen1, <span class="number">0</span>, (sockaddr*)&amp;peerAddr, nLen2))</div><div class="line">                &#123;</div><div class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">                     <span class="built_in">printf</span> (<span class="string">"send to peer user  data failed.\n"</span>, WSAGetLastError());</div><div class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">                     <span class="built_in">printf</span> (<span class="string">"send to peer user  data failed.\n"</span>, errno);</div><div class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">                    <span class="keyword">return</span>    <span class="number">-6</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == sendto(sockServer, (<span class="keyword">char</span>*)&amp;peerAddr, nLen2, <span class="number">0</span>, (sockaddr*)&amp;addrUser1, nLen1))</div><div class="line">                &#123;</div><div class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">                    <span class="built_in">printf</span> (<span class="string">"send to connect user  data failed.\n"</span>, WSAGetLastError());</div><div class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">                     <span class="built_in">printf</span> (<span class="string">"send to connect user  data failed.\n"</span>, errno);</div><div class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">                    <span class="keyword">return</span>    <span class="number">-6</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                addrList.pop_front();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="comment">//如果列表为空，那么将该地址放入列表中。</span></div><div class="line">                addrList.push_back(addrUser1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">    Sleep(INFINITE);</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">    <span class="comment">//sleep(1000);</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是客户端发送消息的代码，比较简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    WSADATA    wsaData = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"WSAStartup failed. errno=[%d]\n"</span>, WSAGetLastError());</div><div class="line">        <span class="keyword">return</span>    <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    SOCKET    sockClient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</div><div class="line">    <span class="keyword">if</span> (SOCKET_ERROR == sockClient)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"socket server failed. errno=[%d]\n"</span>, WSAGetLastError());</div><div class="line">        <span class="keyword">return</span>    <span class="number">-2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">char</span>    pcContent1[UCHAR_MAX] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    SOCKADDR_IN    addrServer = &#123;<span class="number">0</span>&#125;;</div><div class="line">    addrServer.sin_family    = AF_INET;</div><div class="line">    addrServer.sin_addr.s_addr    = inet_addr(<span class="string">"192.168.1.40"</span>);</div><div class="line">    addrServer.sin_port    = htons(<span class="number">10000</span>);</div><div class="line">    <span class="keyword">int</span>    nLen1 = <span class="keyword">sizeof</span>(addrServer);</div><div class="line">    <span class="comment">//客户端发送自己的报文</span></div><div class="line">    <span class="keyword">if</span> (SOCKET_ERROR == sendto(sockClient, pcContent1, <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;addrServer, nLen1))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"recv user 1 failed.errno=[%d]"</span>, WSAGetLastError());</div><div class="line">        <span class="keyword">return</span>    <span class="number">-3</span>;</div><div class="line">    &#125;</div><div class="line">    SOCKADDR_IN    addrUser = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">char</span>    pcContent2[UCHAR_MAX] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="comment">//阻塞接收来自服务器的消息。</span></div><div class="line">    <span class="keyword">if</span> (SOCKET_ERROR == recvfrom(sockClient, pcContent2, <span class="keyword">sizeof</span>(pcContent2), <span class="number">0</span>, (sockaddr*)&amp;addrServer, &amp;nLen1))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"recv user 1 failed.errno=[%d]"</span>, WSAGetLastError());</div><div class="line">        <span class="keyword">return</span>    <span class="number">-5</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memcpy</span> (&amp;addrUser, pcContent2, <span class="keyword">sizeof</span>(addrUser));</div><div class="line">        <span class="built_in">sprintf</span> (pcContent2, <span class="string">"hello, user ip=[%s] port=[%d]\n"</span>, inet_ntoa(addrUser.sin_addr), htons(addrUser.sin_port));</div><div class="line">        <span class="comment">//解析服务器消息后发送消息给另一个客户端。</span></div><div class="line">        <span class="keyword">if</span> (SOCKET_ERROR == sendto(sockClient, pcContent2, <span class="built_in">strlen</span>(pcContent2), <span class="number">0</span>, (sockaddr*)&amp;addrUser, nLen1))</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span> (<span class="string">"recv user 1 failed.errno=[%d]"</span>, WSAGetLastError());</div><div class="line">            <span class="keyword">return</span>    <span class="number">-3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            <span class="comment">//阻塞接收另一个客户端发送过来的消息</span></div><div class="line">            <span class="keyword">if</span> (SOCKET_ERROR == recvfrom(sockClient, pcContent2, <span class="keyword">sizeof</span>(pcContent2), <span class="number">0</span>, (sockaddr*)&amp;addrServer, &amp;nLen1))</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">printf</span> (<span class="string">"recv user 1 failed.errno=[%d]"</span>, WSAGetLastError());</div><div class="line">                <span class="keyword">return</span>    <span class="number">-5</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">printf</span> (<span class="string">"%s"</span>, pcContent2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Sleep(INFINITE);</div><div class="line">    <span class="keyword">return</span>    <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下，服务器收到来自客户端A和客户端B的报文后打印他们的信息，并且互相转发消息。<br><img src="/2017/08/04/udphole/1.png" alt="1"><br>客户端A和客户端B分别打印对方的地址和端口号<br><img src="/2017/08/04/udphole/2.png" alt="2"><br><img src="/2017/08/04/udphole/3.png" alt="3"><br>到此为止，udp打洞的代码介绍完了。可以关注我的公众号，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓&lt;code&gt;udp打洞&lt;/code&gt;就是指客户端A通过&lt;code&gt;udp协议&lt;/code&gt;向服务器发送数据包，服务器收到后，获取数据包，并且可获取客户端A&lt;code&gt;地址和端口号&lt;/code&gt;。同样在客户端B发送给服务器udp数据包后，服务器同样在收到B发送过来的数据包后获取B的地址和端口号，将A和B的地址与端口号分别发送给对方，这样双方可以继续用UDP协议通信。这么做有什么用呢？因为对于一些应用或者需求，需要两个客户端临时做一些通信，而这种通信不需要建立tcp就可以完成，所以才去udp打洞。&lt;/p&gt;
&lt;p&gt;下面附上测试代码：&lt;/p&gt;
&lt;p&gt;头文件&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// udphole.cpp : 定义控制台应用程序的入口点。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; WIN32&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;stdafx.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;winsock2.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&quot;meta-string&quot;&gt;&quot;Ws2_32.lib&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; SOCKET socketfd;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; SOCKADDR_IN sockaddr_in;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; __linux__&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; socketfd;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;list&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程学习方法和图书推荐</title>
    <link href="http://www.limerence2017.com/2017/08/04/networkbook/"/>
    <id>http://www.limerence2017.com/2017/08/04/networkbook/</id>
    <published>2017-08-04T08:38:00.000Z</published>
    <updated>2017-08-04T08:49:53.898Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/04/networkbook/5.jpg" alt="5"><br>从事<code>网络编程</code>有五年多了，写过自己的Server，读过大部分网络库<code>libevent</code>，<code>redis</code>,<code>muduo</code>等等，市面上的网络用书大多读过，给新人一些建议，主要是从事服务器网络编程后端的同学。如果你没写过网络编程的代码，也没有这方面的知识，那么该如何下手呢？这个时候不需要盲目看书，先培养一下自己的兴趣，了解TCP如何建立连接，<code>TCP三次握手</code>和<code>四次握手</code>的过程，<a id="more"></a>有了这个，然后去了解socket方面编程的基本知识，socket的创建，绑定，连接，发送，接收，建立连接等api，学习完这些api，试着去写一个<code>单线程阻塞通信</code> demo，客户端发送数据，服务器接收数据，然后将数据返回给客户端，客户端收到后继续发送，这样简单的<code>echo服务器</code>就写出来了。</p>
<p>这是我做的一个小demo，可以参考下，但是不是echo，读者可自己改为echo服务器。</p>
<p><a href="http://www.cnblogs.com/secondtonone1/p/5460942.html" target="_blank" rel="external">http://www.cnblogs.com/secondtonone1/p/5460942.html</a></p>
<p>如果很多个客户端连接过来怎么处理呢？这时需要了解多线程模式的网络编程，你可以去了解accept原理，和线程创建处理新的连接。这样就可以做出一个多线程echo的Server了。<br>这是我做的一个简单的accept多线程服务器，读者可自己改为echo模式</p>
<p><a href="http://www.cnblogs.com/secondtonone1/p/5461120.html" target="_blank" rel="external">http://www.cnblogs.com/secondtonone1/p/5461120.html</a></p>
<p>有了这些基础知识，你就可以深入了解网络变成了，下一步要做的是了解TCP的socket缓存原理，阻塞原理，非阻塞的socket如何返回错误码，错误码的意义和如何处理，这些知识是你学习非阻塞多路复用的基础，学完这些，可以学多路复用的几种模型了，select，poll，epoll，iocp，kqueue等等，学的时候去补充自己不知道的一些TCP知识。多路复用学习后可以简单的去写一些多路复用服务器demo。</p>
<p>这是我之前讲过的epoll知识和自己写的epoll demo</p>
<p><a href="http://www.cnblogs.com/secondtonone1/p/5367495.html" target="_blank" rel="external">http://www.cnblogs.com/secondtonone1/p/5367495.html</a></p>
<p><a href="http://www.cnblogs.com/secondtonone1/p/5432453.html" target="_blank" rel="external">http://www.cnblogs.com/secondtonone1/p/5432453.html</a></p>
<p>会写多路复用服务器就可以了吗？这只是开始，下面就要阅读源码和高性能的框架了，我推荐去读一读redis和libevent这两个框架，对网络编程提升很大，其中的缓存思想也很重要。这个时候你需要的是从框架的角度搭建一个高性能的服务器，需要了解事件堆，Reactor模式，Proactor模式，将不同的多路复用封装为一个IOService，就像libevent的EventLoop，像boost asio的ioservice一样。</p>
<p>下面是我封装的一个服务器，上传到github了</p>
<p><a href="https://github.com/secondtonone1/betternet" target="_blank" rel="external">https://github.com/secondtonone1/betternet</a></p>
<p>这些都会了，也就是我现在的水平了，我现在在看一些网络大神的思想和视频，从他们的设计角度感受如何架构一个优秀的框架，建议大家看看陈硕的muduo网络库和编程视频，能醍醐灌顶。我现在也在学一些其他的框架，主要是想触类旁通，同时看看优秀的框架代码，虽然自己写不出太优秀的框架，至少可以开阔眼界，作为积累。</p>
<p>下面是推荐大家的网络图书：</p>
<p>我推荐新手先看</p>
<p>Linux程序设计(第4版)<br><img src="/2017/08/04/networkbook/1.jpg" alt="1"><br>Linux高性能服务器编程<br><img src="/2017/08/04/networkbook/2.jpg" alt="2"><br>看过之后再看Richard的三本网络书<br><img src="/2017/08/04/networkbook/3.jpg" alt="3"><br>这些都看过之后，需要实战，实战过程中可以看看<br><img src="/2017/08/04/networkbook/4.jpg" alt="4"><br>以及陈硕的经验之谈，我现在在看的<br><img src="/2017/08/04/networkbook/5.jpg" alt="5"></p>
<p>这些都看过了，可以看看源码</p>
<p> libevent 源码下载地址：<a href="http://libevent.org/" target="_blank" rel="external">http://libevent.org/</a></p>
<p> redis源码下载地址：<a href="http://www.redis.cn/download.html" target="_blank" rel="external">http://www.redis.cn/download.html</a></p>
<p> boost asio 文档和下载：<a href="http://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html" target="_blank" rel="external">http://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html</a></p>
<p> muduo网络库：<a href="http://code.csdn.net/openkb/p-muduo" target="_blank" rel="external">http://code.csdn.net/openkb/p-muduo</a></p>
<p>这些源码都搞通了，就有了自己的方法和框架了，然后就自己闯荡吧。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/04/networkbook/5.jpg&quot; alt=&quot;5&quot;&gt;&lt;br&gt;从事&lt;code&gt;网络编程&lt;/code&gt;有五年多了，写过自己的Server，读过大部分网络库&lt;code&gt;libevent&lt;/code&gt;，&lt;code&gt;redis&lt;/code&gt;,&lt;code&gt;muduo&lt;/code&gt;等等，市面上的网络用书大多读过，给新人一些建议，主要是从事服务器网络编程后端的同学。如果你没写过网络编程的代码，也没有这方面的知识，那么该如何下手呢？这个时候不需要盲目看书，先培养一下自己的兴趣，了解TCP如何建立连接，&lt;code&gt;TCP三次握手&lt;/code&gt;和&lt;code&gt;四次握手&lt;/code&gt;的过程，&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>redis 配置和使用(C++)</title>
    <link href="http://www.limerence2017.com/2017/08/04/redisset/"/>
    <id>http://www.limerence2017.com/2017/08/04/redisset/</id>
    <published>2017-08-04T08:17:47.000Z</published>
    <updated>2017-08-04T08:36:34.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Redis简介："><a href="#一、Redis简介：" class="headerlink" title="一、Redis简介："></a>一、Redis简介：</h2><p><code>Redis</code>为<code>非关系型数据库</code>，Redis是一个<code>Key-Value</code>存储系统。它支持存储的value类型有：<code>string(字符串)</code>,<code>list(链表)</code>, <code>set(无序集合)</code>,<code>zset(sorted set有序集合)</code>和<code>hash</code>，Redis支持各种不同方式的排序。数据都是<code>缓存</code>在<code>内存</code>中的，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并实现了<code>master-slave(主从)同步</code>。</p>
<h2 id="二、Redis安装和使用："><a href="#二、Redis安装和使用：" class="headerlink" title="二、Redis安装和使用："></a>二、Redis安装和使用：</h2><p>Redis下载地址，我下载的为最新版本：</p>
<p>wget <a href="wget http://download.redis.io/releases/redis-3.2.8.tar.gz">http://download.redis.io/releases/redis-3.2.8.tar.gz</a>  </p>
<p>解压安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar xzf redis-3.2.8.tar.gz</div><div class="line">$ <span class="built_in">cd</span> redis-3.2.8</div><div class="line">$ make</div></pre></td></tr></table></figure>
<p>make完后 redis-3.2.8目录下会出现redis-server和redis-cli<br>下面在src目录下启动redis服务.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./redis-server</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./redis-server redis.conf</div></pre></td></tr></table></figure></p>
<p>redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了.<br>下面为官方提供的案例：<br>服务器启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/redis-server redis.conf</div></pre></td></tr></table></figure></p>
<p>客户端读写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ src/redis-cli</div><div class="line">redis&gt; <span class="built_in">set</span> foo bar</div><div class="line">OK</div><div class="line">redis&gt; get foo</div><div class="line"><span class="string">"bar"</span></div></pre></td></tr></table></figure>
<p>redis.conf 为redis配置文件，有很多参数供用户修改，这里仅仅说明几个参数，其他的读者自行搜索。</p>
<p>port: 为redis启动的端口号，当需要启动多个redis服务器时修改该参数，可以启动多个服务。</p>
<p>bind ：绑定ip，设置后只接受自该ip的请求</p>
<p>databases ：设置数据库的个数，默认使用的数据库为0，redis有16个数据库，修改参数可写入不同的数据库。</p>
<p>requirepass ：设置登录时需要使用的密码。</p>
<p>下面修改requirepass  为 zjml123456&amp;&amp;REDIS,那么重启redis-server,放在后台运行。效果就是这样<br><img src="/2017/08/04/redisset/1.png" alt="1"><br>然后启动客户端使用密码登录并且查询数据<br><img src="/2017/08/04/redisset/2.png" alt="2"><br>使用密码命令为：auth 密码</p>
<p>设置key和value的命令为: set key value</p>
<p>取出key对应的value 为： get key</p>
<h2 id="使用C-访问redis"><a href="#使用C-访问redis" class="headerlink" title="使用C++访问redis:"></a>使用C++访问redis:</h2><p>使用redis接口之前需要将hireids.h 和libhiredis.a放到项目目录里，这两个文件在redis解压目录redis-3.2.8/deps/下,我这里写了一个demo，所以都放在demo的文件夹下了。</p>
<p>下面介绍redis提供的供C++访问的接口</p>
<p> 主要包括如下四个方法</p>
<ol>
<li>redisContext<em> redisConnect(const char </em>ip, int port)</li>
</ol>
<p>该函数用来连接redis数据库， 两个参数分别是redis数据库的ip和端口，端口号一般为6379。</p>
<ol>
<li>void <em>redisCommand(redisContext </em>c, const char *format…)</li>
</ol>
<p>该函数用于执行redis数据库中的命令，第一个参数为连接数据库返回的redisContext，剩下的参数为变参，如同C语言中的prinf()函数。此函数的返回值为void*，但是一般会强制转换为redisReply类型，以便做进一步的处理。根据redisReply中的type变量类型判断命令执行情况</p>
<p>REDIS_REPLY_STATUS：</p>
<p>返回执行结果为状态的命令。比如set命令的返回值的类型是REDIS_REPLY_STATUS，然后只有当返回信息是”OK”时，才表示该命令执行成功。</p>
<p>可以通过reply-&gt;str得到文字信息，通过reply-&gt;len得到信息长度。</p>
<p>REDIS_REPLY_ERROR：</p>
<p>返回错误。错误信息可以通过reply-&gt;str得到文字信息，通过reply-&gt;len得到信息长度。</p>
<p>REDIS_REPLY_INTEGER：</p>
<p>返回整型标识。可以通过reply-&gt;integer变量得到类型为long long的值。</p>
<p>REDIS_REPLY_NIL:</p>
<p>返回nil对象，说明不存在要访问的数据。</p>
<p>REDIS_REPLY_STRING:</p>
<p>返回字符串标识。可以通过reply-&gt;str得到具体值，通过reply-&gt;len得到信息长度。</p>
<p>REDIS_REPLY_ARRAY:</p>
<p>返回数据集标识。数据集中元素的数目可以通过reply-&gt;elements获得，每个元素是个redisReply对象，</p>
<p>元素值可以通过reply-&gt;element[..index..].*形式获得，用在获取多个数据结果的操作。</p>
<ol>
<li>void freeReplyObject(void *reply)</li>
</ol>
<p>释放redisCommand执行后返回的的redisReply所占用的内存。</p>
<ol>
<li>void redisFree(redisContext *c)</li>
</ol>
<p>释放redisConnect()所产生的连接。</p>
<p>下面是我封装的一个C++访问redis的类</p>
<p>RedisManager.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisManager</span> </span></div><div class="line"><span class="class">    &#123;</span></div><div class="line">       <span class="keyword">public</span>:</div><div class="line"></div><div class="line">        RedisManager();</div><div class="line">        <span class="keyword">virtual</span> ~RedisManager();</div><div class="line">        <span class="comment">//初始化函数</span></div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">initial</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">//释放函数</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</div><div class="line">        <span class="comment">//封装的set接口</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> key, <span class="built_in">std</span>::<span class="built_in">string</span> value)</span></span>;</div><div class="line">        <span class="comment">//封装的get接口</span></div><div class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span>;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span>:</div><div class="line">        </div><div class="line">        <span class="comment">//连接的缓存指针</span></div><div class="line">        redisContext* m_pConnect;</div><div class="line">        <span class="comment">//请求处理结果指针</span></div><div class="line">        redisReply* m_pReply;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>RedisManager.cpp</p>
<p>分别介绍几个接口：</p>
<p>构造函数和析构函数没写代码，下面是初始化函数：</p>
<p>初始化函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> RedisManager::initial()</div><div class="line">&#123;</div><div class="line">    <span class="comment">//redis服务器ip</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*  redisIp = <span class="string">"192.168.1.40"</span>;</div><div class="line">    <span class="comment">//redis服务器端口</span></div><div class="line">    <span class="keyword">int</span>  redisPort = <span class="number">6379</span>;</div><div class="line">    <span class="comment">//连接redis服务器</span></div><div class="line">    m_pConnect = redisConnect(redisIp, redisPort);                    </div><div class="line">    m_pReply = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span>(!m_pConnect)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (m_pConnect != <span class="literal">NULL</span> &amp;&amp; m_pConnect-&gt;err) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" redis connect failed!!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据密码登录</span></div><div class="line">    m_pReply =(redisReply*) redisCommand(m_pConnect, <span class="string">"AUTH %s"</span>, mypass.c_str()); </div><div class="line">    <span class="keyword">if</span>(!m_pReply)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"redis exe failed!!"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>( !(m_pReply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcasecmp(m_pReply-&gt;str,<span class="string">"OK"</span>)==<span class="number">0</span>))  </div><div class="line">    &#123; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" redis auth failed!!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        freeReplyObject(m_pReply );</div><div class="line">        m_pReply = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    freeReplyObject(<span class="keyword">this</span>-&gt;m_pReply );</div><div class="line">    m_pReply = <span class="literal">NULL</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" redis auth success!!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>释放函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RedisManager::release()</div><div class="line">&#123;</div><div class="line">    <span class="comment">//释放连接</span></div><div class="line">     freeReplyObject(m_pConnect);</div><div class="line">     m_pConnect = <span class="literal">NULL</span>;</div><div class="line">    m_pReply = <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>set函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RedisManager::<span class="built_in">set</span>(<span class="built_in">std</span>::<span class="built_in">string</span> key, <span class="built_in">std</span>::<span class="built_in">string</span> value)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//设置key和value关系，插入redis</span></div><div class="line">    redisReply* r =(redisReply*)redisCommand(<span class="keyword">this</span>-&gt;m_pConnect, <span class="string">"SET %s %s"</span>, key.c_str(), value.c_str());   </div><div class="line">    <span class="keyword">if</span>(!r)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"set redis faliled"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">//执行失败</span></div><div class="line">    <span class="keyword">if</span>( !(r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcasecmp(r-&gt;str,<span class="string">"OK"</span>)==<span class="number">0</span>))  </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"set redis faliled"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        freeReplyObject(r );</div><div class="line">        <span class="keyword">return</span>;    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"set redis success"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    freeReplyObject(r );</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">get函数：</div><div class="line"></div><div class="line">``` cpp</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> RedisManager::get(<span class="built_in">std</span>::<span class="built_in">string</span> key)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//根据key获取value</span></div><div class="line">    m_pReply = (redisReply*)redisCommand(<span class="keyword">this</span>-&gt;m_pConnect, <span class="string">"GET %s"</span>, key.c_str());</div><div class="line">    <span class="keyword">if</span>(!m_pReply)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"get value failed"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">//get成功返回结果为 REDIS_REPLY_STRING </span></div><div class="line">    <span class="keyword">if</span>( m_pReply-&gt;type != REDIS_REPLY_STRING )  </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"get redis faliled"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        freeReplyObject(m_pReply );</div><div class="line">        m_pReply = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>;    </div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"get redis success"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> valuestr = m_pReply-&gt;str;</div><div class="line">    freeReplyObject(m_pReply );</div><div class="line">    m_pReply = <span class="literal">NULL</span>;</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> valuestr ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main 函数为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    RedisManager * redisManager = <span class="keyword">new</span> RedisManager();   </div><div class="line">    <span class="keyword">if</span>(redisManager)</div><div class="line">    &#123;</div><div class="line">        redisManager-&gt;initial();</div><div class="line">    </div><div class="line">        edisManager-&gt;<span class="built_in">set</span>(<span class="string">"test"</span>,<span class="string">"nice to meet u!"</span>);</div><div class="line">    </div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> valueStr = redisManager-&gt;get(<span class="string">"1sdfd"</span>);</div><div class="line">        </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; valueStr &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        </div><div class="line">        redisManager-&gt;release();    </div><div class="line">        <span class="keyword">delete</span> redisManager;        </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码下载地址：</p>
<p><a href="http://download.csdn.net/detail/secondtonone1/9826761" target="_blank" rel="external">http://download.csdn.net/detail/secondtonone1/9826761</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Redis简介：&quot;&gt;&lt;a href=&quot;#一、Redis简介：&quot; class=&quot;headerlink&quot; title=&quot;一、Redis简介：&quot;&gt;&lt;/a&gt;一、Redis简介：&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;为&lt;code&gt;非关系型数据库&lt;/code&gt;，Redis是一个&lt;code&gt;Key-Value&lt;/code&gt;存储系统。它支持存储的value类型有：&lt;code&gt;string(字符串)&lt;/code&gt;,&lt;code&gt;list(链表)&lt;/code&gt;, &lt;code&gt;set(无序集合)&lt;/code&gt;,&lt;code&gt;zset(sorted set有序集合)&lt;/code&gt;和&lt;code&gt;hash&lt;/code&gt;，Redis支持各种不同方式的排序。数据都是&lt;code&gt;缓存&lt;/code&gt;在&lt;code&gt;内存&lt;/code&gt;中的，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并实现了&lt;code&gt;master-slave(主从)同步&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二、Redis安装和使用：&quot;&gt;&lt;a href=&quot;#二、Redis安装和使用：&quot; class=&quot;headerlink&quot; title=&quot;二、Redis安装和使用：&quot;&gt;&lt;/a&gt;二、Redis安装和使用：&lt;/h2&gt;&lt;p&gt;Redis下载地址，我下载的为最新版本：&lt;/p&gt;
&lt;p&gt;wget &lt;a href=&quot;wget http://download.redis.io/releases/redis-3.2.8.tar.gz&quot;&gt;http://download.redis.io/releases/redis-3.2.8.tar.gz&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;解压安装：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ tar xzf redis-3.2.8.tar.gz&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; redis-3.2.8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ make&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;make完后 redis-3.2.8目录下会出现redis-server和redis-cli&lt;br&gt;下面在src目录下启动redis服务.&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$./redis-server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Linux环境编程" scheme="http://www.limerence2017.com/tags/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>大并发服务器框架设计</title>
    <link href="http://www.limerence2017.com/2017/08/04/ioservertype/"/>
    <id>http://www.limerence2017.com/2017/08/04/ioservertype/</id>
    <published>2017-08-04T07:38:23.000Z</published>
    <updated>2017-08-04T08:14:27.867Z</updated>
    
    <content type="html"><![CDATA[<p>简单谈一谈<code>大并发服务器框架</code>设计的基本思路<br>基本的服务器框架都是<code>C/S结构</code>的，请求和相应流程是这样的：<br><img src="/2017/08/04/ioservertype/1.png" alt="1"><br>这样的框架存在一个很严重的问题，当客户端大并发请求到来，服务器需要进行大量的数据库操作，假设数据库最大连接数为1000个，此时有10000个请求访问应用服务器，那么应用服务器只能处理1000个请求，剩下99000个等待1000个请求处理好后再进行访问数据库处理。可以在应用服务器和数据库服务器中间增加中间层DAL，DAL采用缓冲队列和连接池设计。<br><a id="more"></a><br><img src="/2017/08/04/ioservertype/2.png" alt="2"><br>DAL设计缓冲队列，存储等待的请求，并且DAL中设计数据库连接池，当数据库连接池中有空闲连接，那么从缓冲队列中取出一个请求处理，以此类推。这种做法有效的降低了服务器的压力，但是没有提高处理速度，仅仅保证了请求被缓存，处理效率仍受限于数据库的并发数。那么可以再增加一层缓存，将常用的数据加载如缓存，有请求到来时，应用服务器先从缓存中获取数据，如果缓存中有数据，那么不需要访问数据库，如果缓存中没有，在访问数据库取出数据，并更新缓存。<br><img src="/2017/08/04/ioservertype/3.png" alt="3"><br>缓存如何同步？</p>
<p>有两种手段：</p>
<p>第一种方法： <code>缓存是具有时效的，在一定时间过后会超时timeout，如果缓存失效，那么重新去数据库查询，查询后更新缓存，这种方法不是实时的，实时性比较差。</code></p>
<p>第二种方法：<code>当有请求修改数据时，更新缓存，并且将要修改的数据投入DAL层，当数据库有空闲连接时，再持久化存盘。</code></p>
<p>缓存的不足之处：</p>
<p>当缓存足够多时，需要将不活跃缓存数据换出内存，叫做缓存换页。缓存换出算法和操作系统换页算法类似，<code>FIFO</code>，<code>LRU（least recently used）</code>，<code>LFU（least  frequently used）</code>等。实际缓存的实现不需要自己去实现，有很多开源技术，nosql技术就是非关系型数据库的意思。非关系型数据库如redis，memcatched等。缓存可以跟应用服务器部署在同一台机器上，也可以部署在单独机器上。我推荐将缓存服务器部署在单独机器上，假设有两台应用服务器，如果将缓存部署在不同的应用服务器上，那么不同的应用服务器很难访问彼此的缓存，非常不方便。将缓存部署在单独服务器上，各个应用服务器都能访问该缓存服务器。<br><img src="/2017/08/04/ioservertype/4.png" alt="4"><br>如果有大量的业务请求到来，虽然设计了多个应用服务器，也架设了缓存服务器，完善了中间层的缓冲队列和数据库连接池，但是数据库服务器仍然会出现瓶颈。比如当有大量复杂的写操作数据库，很多读数据库的操作就被阻塞了，为解决这个问题可将数据库实现读写分离。由于数据库读操作会比写操作多，那么可以对数据库执行负载均衡。主流数据库都有replication机制，采用replication机制可以实现负载均衡。中间层的写数据库操作投递到master数据库中，读操作从slave数据库中读取，当master数据库中数据被修改后，数据库采用replication机制将数据同步给slave服务器。<br><img src="/2017/08/04/ioservertype/5.png" alt="5"><br>同样的道理，应用服务器也可以实现负载均衡，架设多个应用服务器，不同的请求分配给不同的应用服务器。可单独设计一个任务服务器监控各个应用服务器的负载情况，合理的分配任务给各个应用服务器。这种方式是任务服务器主动地分配任务给应用服务器，应用服务器被动的接受任务，这种方式在任务请求类型相近的情况下，分配方式非常合理。但是假设应用服务器A接受了3个任务，应用服务器B接受了5个任务，按照负载均衡的权重法或最小连接法，肯定会分配给A任务，但是如果这3个任务都是复杂的写操作，而B的5个任务都是简单的读操作，那么这就存在分配的不合理性，如何解决这个问题呢？<br><img src="/2017/08/04/ioservertype/6.png" alt="6"><br>可以换一种思路去解决这个问题，让应用服务器主动去请求任务服务器，主动获取任务处理，如果应用服务器处于忙碌状态就不需要请求新的任务，空闲的应用服务器会去请求任务服务器中的任务，这是最合理的负载均衡。如果所有应用服务器都处于忙碌状态，那么任务服务器将任务缓存至自己的任务队列，当应用服务器空闲时会来取任务。考虑这样一个问题，如果任务服务器出现故障怎么办？任务服务器需要有多台，并且实现failover机制，多台任务服务器之间实现心跳，如果检测不到对方心跳，则使自己成为主任务服务器。<br><img src="/2017/08/04/ioservertype/7.png" alt="7"><br>到目前为止，这个框架可以适用于大部分服务器逻辑。为保证数据库的响应速度和处理效率，可以对数据库进行分区。</p>
<p>数据库分区有两种形式(分库、分表)</p>
<p>分库：数据库可以按照一定的逻辑把表分散到不同的数据库。这叫做垂直分区，就是所每个库的表不同，功能不同。这样做不常见，因为很大情况下，数据库中各个表是关联的，</p>
<p>如果将不同的表分配到不同的数据库中，会存在很多不便。</p>
<p>分表：将一个表的不同数据分配到各个数据库，这样每个数据库的表结构是一样的，只是存储的用户数据不同而已，叫做水平分区。分表的方式很常见，如果数据库的压力增加，</p>
<p>我们就采取分表的方式减少数据库的压力。</p>
<p>另外服务器开发的几个性能杀手：</p>
<p>1 数据拷贝，数据从内核态copy到用户态，或者在用户态之间copy会造成性能损失，尽量采用缓存的方式解决。</p>
<p>2 环境切换 ，多线程上下文切换造成开销。如果服务器是单核的，那么采用状态机方式单线程效果最佳。如果是多核的，</p>
<p>合理采用多线程，可以提升性能。</p>
<p>3 内存分配，可以采用内存池，提前分配。</p>
<p>4 锁竞争，加锁解锁会造成一定的效率衰减。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单谈一谈&lt;code&gt;大并发服务器框架&lt;/code&gt;设计的基本思路&lt;br&gt;基本的服务器框架都是&lt;code&gt;C/S结构&lt;/code&gt;的，请求和相应流程是这样的：&lt;br&gt;&lt;img src=&quot;/2017/08/04/ioservertype/1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;这样的框架存在一个很严重的问题，当客户端大并发请求到来，服务器需要进行大量的数据库操作，假设数据库最大连接数为1000个，此时有10000个请求访问应用服务器，那么应用服务器只能处理1000个请求，剩下99000个等待1000个请求处理好后再进行访问数据库处理。可以在应用服务器和数据库服务器中间增加中间层DAL，DAL采用缓冲队列和连接池设计。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP地址格式转换API</title>
    <link href="http://www.limerence2017.com/2017/08/04/tcpapi/"/>
    <id>http://www.limerence2017.com/2017/08/04/tcpapi/</id>
    <published>2017-08-04T07:30:02.000Z</published>
    <updated>2017-08-04T07:52:48.082Z</updated>
    
    <content type="html"><![CDATA[<p>1、htonl ()和ntohl( )</p>
<p><code>ntohl( )</code>—–<code>网络顺序转换成主机顺序(长整型)</code></p>
<p>u_long PASCAL FAR ntohl (u_long netlong); </p>
<p><code>htonl ()</code>—–<code>主机顺序转换成网络顺序 (长整型)</code></p>
<p>u_long PASCAL FAR htonl (u_long hostlong);<br><a id="more"></a></p>
<p>2、htons ()和ntohs( )  </p>
<p><code>htons()</code>——<code>主机顺序转换成网络顺序(短整型)</code></p>
<p>u_short PASCAL FAR htons (u_short hostshort);</p>
<p><code>ntohs()</code>——<code>网络顺序转换成主机顺序(短整型)</code></p>
<p>u_short PASCAL FAR ntohs (u_short netshort);</p>
<p>3、inet_addr( )和inet_ntoa ( )</p>
<p>unsigned long PASCAL FAR inet_addr (const char FAR * cp);</p>
<p>char FAR * PASCAL FAR inet_ntoa (struct in_addr in);</p>
<p><code>inet_addr</code>函数需要一个字符串作为其参数，该字符串指定了以点分十进制格式表示的IP地址（例如：192.168.1.161）。而且inet_addr函数会返回一个适合分配给S_addr的u_long类型的数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sockfd; </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> </div><div class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </div><div class="line"></div><div class="line">my_addr.sin_family = AF_INET; <span class="comment">/* 主机字节序 */</span> </div><div class="line">my_addr.sin_port = htons(<span class="number">9925</span>); <span class="comment">/* short, 网络字节序 */</span> </div><div class="line">my_addr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.0.1"</span>); </div><div class="line"></div><div class="line">bzero(&amp;(my_addr.sin_zero), <span class="number">8</span>); </div><div class="line"></div><div class="line">bind(sockfd, (struct sockaddr *)&amp;my_addr, <span class="keyword">sizeof</span>(struct sockaddr));</div></pre></td></tr></table></figure>
<p>inet_ntoa函数会完成相反的转换，它接受一个in_addr结构体类型的参数并返回一个以点分十进制格式表示的IP地址字符串。</p>
<p>服务器accept收到一个连接后，可以通过inet_ntoa找到对方ip，输出为字符串格式的点分十进制</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">client = accept(serverSocket, (struct sockaddr *)<span class="meta">&amp;clientAddr, (socklen_t *)&amp;addr_len);  </span></div><div class="line">if (client &lt; <span class="number">0</span>)  </div><div class="line">&#123;  </div><div class="line">    perror(<span class="string">"accept"</span>);  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">      </div><div class="line">printf(<span class="string">"\nRecv client data...\n"</span>);  </div><div class="line">printf(<span class="string">"IP is %s\n"</span>, inet_ntoa(clientAddr.sin_addr));</div></pre></td></tr></table></figure>
<p>sockaddr_in , sockaddr , in_addr区别<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct   sockaddr   &#123;  </div><div class="line">                unsigned   short   sa_family;     </div><div class="line">                char   sa_data[<span class="number">14</span>];     </div><div class="line">        &#125;;</div></pre></td></tr></table></figure></p>
<p>  上面是通用的socket地址，具体到Internet   socket，用下面的结构，二者可以进行类型转换<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct   sockaddr_in   &#123;  </div><div class="line">              short   int   sin_family;     </div><div class="line">              unsigned   short   int   sin_port;     </div><div class="line">              struct   in_addr   sin_addr;     </div><div class="line">              unsigned   char   sin_zero[<span class="number">8</span>];     </div><div class="line">      &#125;;</div></pre></td></tr></table></figure></p>
<p>struct   in_addr就是32位IP地址。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct   in_addr   &#123;  </div><div class="line">                union &#123;</div><div class="line">                        struct &#123; u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</div><div class="line">                        struct &#123; u_short s_w1,s_w2; &#125; S_un_w;</div><div class="line">                        u_long S_addr; </div><div class="line">                &#125; S_un;</div><div class="line"></div><div class="line">                <span class="meta">#define s_addr  S_un.S_addr</span></div><div class="line">        &#125;;</div></pre></td></tr></table></figure></p>
<p>inet_addr()是将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位IP地址(0xC0A80001)。</p>
<p>填值的时候使用sockaddr_in结构，而作为函数（如socket, listen, bind等）的参数传入的时候转换成sockaddr结构就行了，毕竟都是16个字符长。</p>
<p>名词解析：</p>
<p>主机字节序：</p>
<p>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。最常见的有两种</p>
<p>1．Little endian：低字节存高地址，高字节存低地址</p>
<p>2．Big endian：低字节存低地址，高字节存高地址</p>
<p>网络字节序：</p>
<p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</p>
<p>为了进行转换bsd socket提供了转换的函数，有下面四个网络与主机字节转换函数:htons ntohs htonl ntohl (s 就是short l是long h是host n是network)</p>
<p>htons 把unsigned short类型从主机序转换到网络序，htonl 把unsigned long类型从主机序转换到网络序，ntohs 把unsigned short类型从网络序转换到主机序，ntohl 把unsigned long类型从网络序转换到主机序。</p>
<p>在使用little endian的系统中 这些函数会把字节序进行转换 在使用big endian类型的系统中这些函数会定义成空宏</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、htonl ()和ntohl( )&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ntohl( )&lt;/code&gt;—–&lt;code&gt;网络顺序转换成主机顺序(长整型)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;u_long PASCAL FAR ntohl (u_long netlong); &lt;/p&gt;
&lt;p&gt;&lt;code&gt;htonl ()&lt;/code&gt;—–&lt;code&gt;主机顺序转换成网络顺序 (长整型)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;u_long PASCAL FAR htonl (u_long hostlong);&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>柔性数组探索和应用</title>
    <link href="http://www.limerence2017.com/2017/08/04/avilablearray/"/>
    <id>http://www.limerence2017.com/2017/08/04/avilablearray/</id>
    <published>2017-08-04T04:48:23.000Z</published>
    <updated>2017-08-04T07:54:03.713Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>字符串可以实现通过地址偏移找到所在结构体的首地址，<code>struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)))</code><br><img src="/2017/08/04/avilablearray/1.png" alt="1"><br>也就是通过buf地址可以找到sdshdr的地址，这个我一直不理解，写了代码测试下<br><a id="more"></a><br><img src="/2017/08/04/avilablearray/2.png" alt="2"><br>地址一次间隔4，结构体总大小为8，最后一个buf是空数组，没大小。之前自己一直错误的认为buf的大小按照char <em>开辟，这次打印出来大小为0<br>将结构体buf成员改为char </em>类型<br><img src="/2017/08/04/avilablearray/3.png" alt="3"><br>这次大小变为12了，也就是char* 占用了四个字节<br> 现在回到最初的结构<br><img src="/2017/08/04/avilablearray/4.png" alt="4"><br> 我尝试给buf开辟空间<br><img src="/2017/08/04/avilablearray/5.png" alt="5"><br>编译是不允许的，这是个零大小的数组，但是buf[lenth]这种方式可以访问，只是数组越界罢了。<br>那就要一次给这个结构体开辟好空间，通过buf位移取出数据<br><img src="/2017/08/04/avilablearray/6.png" alt="6"><br>结果<br><img src="/2017/08/04/avilablearray/7.png" alt="7">  </p>
<p><img src="/2017/08/04/avilablearray/8.png" alt="8"><br>&amp;buf和buf所指向的地址一个地址。因为它本身没有空间</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;字符串可以实现通过地址偏移找到所在结构体的首地址，&lt;code&gt;struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)))&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/2017/08/04/avilablearray/1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;也就是通过buf地址可以找到sdshdr的地址，这个我一直不理解，写了代码测试下&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>弱点针对训练（函数指针）</title>
    <link href="http://www.limerence2017.com/2017/08/04/weakeness/"/>
    <id>http://www.limerence2017.com/2017/08/04/weakeness/</id>
    <published>2017-08-04T04:40:26.000Z</published>
    <updated>2017-08-04T04:44:55.978Z</updated>
    
    <content type="html"><![CDATA[<p>想着把每一个基础的知识点搞清，趁着早晨凉快就先写一些总结<br>函数指针，基本结构是 <code>函数返回类型（* 函数指针名字）（函数参数1，函数参数2，...）</code>；<br>这种指针用于<code>指向一个函数的地址</code>，可以<code>通过函数指针回调同类型的不同函数</code>，实现类似于<code>事件回调机制</code>的功能。<br>先写一个简单的测试程序<br><img src="/2017/08/04/weakeness/1.png" alt="1"><br><a id="more"></a><br>编译后看看有什么结果<br><img src="/2017/08/04/weakeness/2.png" alt="2"><br>pFunc1和pFunc2是没问题的，pFunc3 提示两个函数指针类型不匹配，因为pFunc3是 int（<em>*）(int , int);<br>pFunc4 其实是一个函数类型的对象，不予许赋值的。<br>所以进行如下更改，并写出测试代码<br><img src="/2017/08/04/weakeness/3.png" alt="3"><br>对于函数指针赋值的时候，可以直接用函数名字，也可以进行&amp;函数名赋值，<br>综上所述，可以先定义一个函数类型<br>typedef 函数返回类型 函数名 （函数形参1， 函数形参2，…）;<br>之后用 函数名 </em> 函数指针;<br>也可以 typedef 函数返回类型 (*函数指针类型名) （函数形参1，函数形参2,…）；<br>之后用 函数指针类型名   函数指针；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想着把每一个基础的知识点搞清，趁着早晨凉快就先写一些总结&lt;br&gt;函数指针，基本结构是 &lt;code&gt;函数返回类型（* 函数指针名字）（函数参数1，函数参数2，...）&lt;/code&gt;；&lt;br&gt;这种指针用于&lt;code&gt;指向一个函数的地址&lt;/code&gt;，可以&lt;code&gt;通过函数指针回调同类型的不同函数&lt;/code&gt;，实现类似于&lt;code&gt;事件回调机制&lt;/code&gt;的功能。&lt;br&gt;先写一个简单的测试程序&lt;br&gt;&lt;img src=&quot;/2017/08/04/weakeness/1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>stringstream使用方法</title>
    <link href="http://www.limerence2017.com/2017/08/04/stringstream/"/>
    <id>http://www.limerence2017.com/2017/08/04/stringstream/</id>
    <published>2017-08-04T04:36:06.000Z</published>
    <updated>2017-08-04T04:38:59.090Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 有<code>stringstream</code>这个工具可以方便的进行数据类型的转换</p>
<p>使用时包含</p>
<p><code>#include &lt;sstream.h&gt;</code></p>
<p><code>using namespace std;</code></p>
<p>当需要将一个整形的数转换为字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stringstream</span> mystream;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line">mystream &lt;&lt; a;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> numstr;</div><div class="line"></div><div class="line">mystream &gt;&gt; mumstr;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果需要将一个字符串转化为整形数</p>
<p>再次使用mystream需要清除之前的状态位</p>
<p>调用 <code>mystream.clear();</code></p>
<p>并且字符串置空</p>
<p>mystream.str(“”);</p>
<p>这样就可以使用了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mystream.clear()</div><div class="line">mystream.str(<span class="string">""</span>);</div><div class="line"></div><div class="line"><span class="built_in">string</span> strtest = <span class="string">"1234"</span>;</div><div class="line">mystream &lt;&lt; strtest;</div><div class="line"><span class="keyword">int</span> numconvert;</div><div class="line">mystream &gt;&gt; numconvert;</div></pre></td></tr></table></figure>
<p>除此之外 stringstream可以连续将输入的内容输出到指定变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"1221"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">"12.34"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str3 = <span class="string">"899"</span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> mystream;</div><div class="line">mystream &lt;&lt; str1 &lt;&lt; str2 &lt;&lt; str3;</div><div class="line"><span class="keyword">int</span> num1, num3;</div><div class="line"><span class="keyword">double</span> num2;</div><div class="line">mystream &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;</div></pre></td></tr></table></figure>
<p>大体上就是mystream常用的用法了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 有&lt;code&gt;stringstream&lt;/code&gt;这个工具可以方便的进行数据类型的转换&lt;/p&gt;
&lt;p&gt;使用时包含&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#include &amp;lt;sstream.h&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;using namespace std;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当需要将一个整形的数转换为字符串&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;stringstream&lt;/span&gt; mystream;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mystream &amp;lt;&amp;lt; a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; numstr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mystream &amp;gt;&amp;gt; mumstr;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>大根堆的原理与实现。</title>
    <link href="http://www.limerence2017.com/2017/08/04/bigheap/"/>
    <id>http://www.limerence2017.com/2017/08/04/bigheap/</id>
    <published>2017-08-04T04:23:28.000Z</published>
    <updated>2017-08-04T04:39:46.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大根堆的定义："><a href="#大根堆的定义：" class="headerlink" title="大根堆的定义："></a>大根堆的定义：</h2><p>1 <code>大根堆是一个大根树</code><br>2 <code>大根堆是一个完全二叉树</code><br>所以大根堆用数组表示是连续的，不会出现空白字段。</p>
<h2 id="对于大根堆的插入"><a href="#对于大根堆的插入" class="headerlink" title="对于大根堆的插入"></a>对于大根堆的插入</h2><p><img src="/2017/08/04/bigheap/1.jpg" alt="1"><br>对于大根堆的插入，可以在排序前确定大根堆的形状，可以确定元素5从位置6插入，那么比较元素5和位置3的元素2，</p>
<p>元素5比元素2大，将2下移。接着比较元素5和元素20，一次类推，直到找到元素5的合理位置。</p>
<p>接着看一下如果插入的元素是21，怎么进行排序。<br><a id="more"></a><br><img src="/2017/08/04/bigheap/2.jpg" alt="2"><br>21比2大，所以将2下移，接着比较21和20，发现20比21小，20下移，最终21放到</p>
<p>根的位置。形成大根堆。</p>
<h2 id="对于大根堆的删除"><a href="#对于大根堆的删除" class="headerlink" title="对于大根堆的删除"></a>对于大根堆的删除</h2><p><img src="/2017/08/04/bigheap/3.jpg" alt="3"><br>大根堆删除根元素，那么可以确定删除后的形状。可以理解成将最后一个叶子节点放在</p>
<p>合理位置，首先比较叶子节点元素10和根节点的两个孩子15和2，选出两个节点中最大的</p>
<p>元素15,15比10大，所以15进行气泡。放到根节点。然后15所在的位置2,变为不确定的问号。</p>
<p>由于14比10大，那么14起泡放到位置2，根据大根堆的形状，最后将10放到左节点</p>
<h2 id="将一个无序的完全二叉树变为大根堆"><a href="#将一个无序的完全二叉树变为大根堆" class="headerlink" title="将一个无序的完全二叉树变为大根堆"></a>将一个无序的完全二叉树变为大根堆</h2><p><img src="/2017/08/04/bigheap/4.jpg" alt="4"><br>将一个无序的完全二叉树变为大根堆(或者小根堆)，首先要找到最有一个叶子节点的父节点，</p>
<p>对该父节点为根节点的子树进行排序，生成一个大根堆(小根堆)。然后从节点位置依次</p>
<p>向前做同样的排序，将该节点到根节点的所有子树变为大根堆(小根堆)<br>举例子：<br><img src="/2017/08/04/bigheap/5.jpg" alt="5"><br>如上图所示，因为总共有6个节点，6/2 = 3,所以元素19的父节点是位置3的元素4，</p>
<p>将以4位根的子树变为大根堆。因为19比4大，所以19上移，4做叶子节点。依次类推，</p>
<p>从位置3到位置1的所有子树都按照这种逻辑处理，最终变成大根堆。</p>
<p>接着要处理位置2的子树，位置2的元素为1，两个节点为25和12，选最大的元素25，因为</p>
<p>25比1大，所以25进行上移，1变为叶子节点。这样位置2的子树就处理完了。</p>
<p>接着处理位置1，因为位置1的元素为6，两个节点分别为25和19，取最大节点元素25，</p>
<p>因为25比6大，所以25上移，而此时位置2还有两个节点元素1和元素12，需要比较元素6</p>
<p>和这两个节点中最大的，以确定大根堆。由于12比6大，所以12上移，6变为叶子节点。</p>
<p>最终用数组表示这个大根堆就是[25,12,19,1,6,4]</p>
<h2 id="下面是代码实现和测试："><a href="#下面是代码实现和测试：" class="headerlink" title="下面是代码实现和测试："></a>下面是代码实现和测试：</h2><h3 id="大根堆的类结构："><a href="#大根堆的类结构：" class="headerlink" title="大根堆的类结构："></a>大根堆的类结构：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">maxHeap</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    maxHeap(<span class="keyword">void</span>)</div><div class="line">    &#123;</div><div class="line">        m_nHeapSize = <span class="number">0</span>;</div><div class="line">            m_nHeapCapacity = <span class="number">0</span>;</div><div class="line">            m_pHeapArray = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    maxHeap(<span class="keyword">const</span> maxHeap&amp; tempHeap);</div><div class="line">    maxHeap(T * heapArray, <span class="keyword">int</span> arrayLen);</div><div class="line"></div><div class="line">    ~maxHeap()&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(m_pHeapArray)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">free</span>(m_pHeapArray);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m_pHeapArray = <span class="literal">NULL</span>;</div><div class="line">        m_nHeapSize = <span class="number">0</span>;</div><div class="line">        m_nHeapCapacity = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//插入节点</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>;</div><div class="line">   <span class="comment">//pop堆顶元素</span></div><div class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">popRoot</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//打印自己的堆元素，用数组表示法输出</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printHeap</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//将一个无序的数组变为大根堆</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMaxHeap</span><span class="params">(T * heapArray, <span class="keyword">int</span> arrayLen)</span></span>;</div><div class="line">    <span class="comment">//销毁自己的堆元素</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocMaxHeap</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//打印数组的元素</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printHeap</span><span class="params">(T * heapArray, <span class="keyword">int</span> arrayLen)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//堆的数组元素，连续区间首地址</span></div><div class="line">    T*  m_pHeapArray;</div><div class="line">    <span class="comment">//当前使用的大小</span></div><div class="line">    <span class="keyword">int</span> m_nHeapSize;</div><div class="line">    <span class="comment">//堆的容量，实际开辟的大小</span></div><div class="line">    <span class="keyword">int</span> m_nHeapCapacity;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="两个构造函数："><a href="#两个构造函数：" class="headerlink" title="两个构造函数："></a>两个构造函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">maxHeap</span>&lt;T&gt;:</span>:maxHeap(<span class="keyword">const</span> maxHeap  &amp;tempHeap)&#123;</div><div class="line">    m_nHeapSize = tempHeap.m_nHeapSize;</div><div class="line">    m_pHeapArray = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(class maxHeap) *m_nHeapSize);</div><div class="line">    m_nHeapCapacity = m_nHeapSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">maxHeap</span>&lt;T&gt;:</span>:maxHeap(T * heapArray, <span class="keyword">int</span> arrayLen)</div><div class="line">&#123;</div><div class="line">    m_nHeapSize = arrayLen;</div><div class="line">    m_pHeapArray = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(class maxHeap) * m_nHeapSize);</div><div class="line">    m_nHeapCapacity = arrayLen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">maxHeap</span>&lt;T&gt;:</span>:insertNode(<span class="keyword">const</span> T&amp; node)</div><div class="line">&#123;</div><div class="line">    m_nHeapSize ++;</div><div class="line">    <span class="keyword">if</span>(m_nHeapSize &gt;= m_nHeapCapacity)</div><div class="line">    &#123;</div><div class="line">        m_pHeapArray = (T *)<span class="built_in">realloc</span>(m_pHeapArray, <span class="keyword">sizeof</span>(T) * m_nHeapSize *<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_nHeapCapacity = m_nHeapSize*<span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">//当前节点所在位置</span></div><div class="line">    <span class="keyword">int</span> currentIndex = m_nHeapSize;</div><div class="line">    <span class="comment">//该节点父节点所在位置</span></div><div class="line">    <span class="keyword">int</span> parentIndex = currentIndex/<span class="number">2</span>;</div><div class="line">    <span class="comment">//当前节点为根节点，跳出循环直接插入即可</span></div><div class="line">    <span class="keyword">while</span>(currentIndex != <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//父节点元素小于该node，因为是大根堆，所以父节点下移</span></div><div class="line">        <span class="keyword">if</span>(m_pHeapArray[parentIndex <span class="number">-1</span>] &lt; node)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//父节点数据下移</span></div><div class="line">            m_pHeapArray[currentIndex - <span class="number">1</span>] = m_pHeapArray[parentIndex <span class="number">-1</span>];</div><div class="line">            <span class="comment">//更新当前节点位置，当前比较位置上移</span></div><div class="line">            currentIndex = currentIndex/<span class="number">2</span>;</div><div class="line">            <span class="comment">//父节点位置同样上移</span></div><div class="line">            parentIndex =  parentIndex/<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//因为节点数是从1开始的，所以节点数-1表示数组中的位置</span></div><div class="line">    m_pHeapArray[currentIndex <span class="number">-1</span>] = node;</div><div class="line"></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="打印元素"><a href="#打印元素" class="headerlink" title="打印元素"></a>打印元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">maxHeap</span>&lt;T&gt;:</span>:printHeap()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"current max heap array is :"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_nHeapSize; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; m_pHeapArray[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">maxHeap</span>&lt;T&gt;:</span>:printHeap(T * heapArray, <span class="keyword">int</span> arrayLen)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"current max heap array is :"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayLen; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; heapArray[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="pop堆顶的元素，取出最大值"><a href="#pop堆顶的元素，取出最大值" class="headerlink" title="pop堆顶的元素，取出最大值"></a>pop堆顶的元素，取出最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">maxHeap</span>&lt;T&gt;:</span>:popRoot()</div><div class="line">&#123;</div><div class="line">    <span class="comment">//先取出最后的叶子节点</span></div><div class="line">    <span class="keyword">const</span> T&amp; lastEle = m_pHeapArray[m_nHeapSize<span class="number">-1</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//更新heapsize</span></div><div class="line">    m_nHeapSize --;</div><div class="line"></div><div class="line">    <span class="comment">//删除时需要从根节点开始，找到最大值起泡</span></div><div class="line">    <span class="keyword">int</span> currentIndex= <span class="number">1</span>;</div><div class="line">    <span class="comment">//当前节点的做孩子</span></div><div class="line">    <span class="keyword">int</span> leftChild = currentIndex *<span class="number">2</span>;</div><div class="line">    <span class="comment">//当前节点的孩子节点超过堆大小，说明该节点为叶子节点</span></div><div class="line">    <span class="keyword">while</span>(leftChild &lt;= m_nHeapSize)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> bigChild = leftChild;</div><div class="line">        <span class="comment">//取出两个孩子中大的孩子，然后将大的孩子节点数据上移</span></div><div class="line">        <span class="keyword">if</span>(leftChild &lt; m_nHeapSize &amp;&amp; m_pHeapArray[leftChild<span class="number">-1</span>] &lt; m_pHeapArray[leftChild])</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//更新大孩子节点为右节点</span></div><div class="line">            bigChild = leftChild +<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//比较两个节点中大的孩子节点和取出的最后叶子节点，那个数值大</span></div><div class="line">        <span class="comment">//如果最后的叶子节点数值大，那么可以跳出循环,因为找到了lastEle的合理位置</span></div><div class="line">        <span class="comment">//剩余的树也是大根堆</span></div><div class="line">        <span class="keyword">if</span>(m_pHeapArray[bigChild <span class="number">-1</span>] &lt;= lastEle)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//大节点数据上移</span></div><div class="line">        m_pHeapArray[currentIndex <span class="number">-1</span>] = m_pHeapArray[bigChild<span class="number">-1</span>];</div><div class="line">        <span class="comment">//更新插入位置为当前大节点位置</span></div><div class="line">        currentIndex = bigChild;</div><div class="line">        leftChild = currentIndex *<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    m_pHeapArray[currentIndex<span class="number">-1</span>] = lastEle;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> lastEle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将一个无序的数组元素，变为大根堆<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">maxHeap</span>&lt;T&gt;:</span>:createMaxHeap(T * heapArray, <span class="keyword">int</span> arrayLen)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//判断异常</span></div><div class="line">    <span class="keyword">if</span>(arrayLen &lt;= <span class="number">0</span> || heapArray == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//从最后一个叶子节点的父节点开始，依次从该位置到根节点</span></div><div class="line">    <span class="comment">//例如该位置为3，那么位置3，位置2，位置1的根节点的子树依次处理为大根堆</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> currentIndex = arrayLen;</div><div class="line">    <span class="comment">//父节点位置</span></div><div class="line">    <span class="keyword">int</span> beginIndex =  currentIndex/<span class="number">2</span>;</div><div class="line">    <span class="comment">//依次处理，形成子树大根堆</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beginIndex; i &gt; <span class="number">0</span>;  i--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> rootEle = heapArray[i<span class="number">-1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> curNode = i;</div><div class="line">        <span class="keyword">int</span> leftChild = i *<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(leftChild &lt;= arrayLen)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> bigChild = leftChild;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> rootElePrint =  heapArray[leftChild<span class="number">-1</span>];</div><div class="line">            <span class="keyword">int</span> rightElePrint = heapArray[leftChild+<span class="number">1</span> <span class="number">-1</span>] ;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(leftChild +<span class="number">1</span> &lt;= arrayLen &amp;&amp; heapArray[leftChild+<span class="number">1</span> <span class="number">-1</span>] &gt; heapArray[leftChild<span class="number">-1</span>])</div><div class="line">            &#123;</div><div class="line">                bigChild = leftChild +<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(heapArray[bigChild <span class="number">-1</span>] &lt;= rootEle )</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        </div><div class="line">             </div><div class="line">            heapArray[curNode <span class="number">-1</span>] = heapArray[bigChild <span class="number">-1</span>];</div><div class="line">            curNode = bigChild;</div><div class="line">            leftChild = curNode *<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        heapArray[curNode <span class="number">-1</span>] = rootEle;</div><div class="line">        </div><div class="line"> 　&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源代码下载地址： <a href="http://download.csdn.net/detail/secondtonone1/9575112" target="_blank" rel="external">http://download.csdn.net/detail/secondtonone1/9575112</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大根堆的定义：&quot;&gt;&lt;a href=&quot;#大根堆的定义：&quot; class=&quot;headerlink&quot; title=&quot;大根堆的定义：&quot;&gt;&lt;/a&gt;大根堆的定义：&lt;/h2&gt;&lt;p&gt;1 &lt;code&gt;大根堆是一个大根树&lt;/code&gt;&lt;br&gt;2 &lt;code&gt;大根堆是一个完全二叉树&lt;/code&gt;&lt;br&gt;所以大根堆用数组表示是连续的，不会出现空白字段。&lt;/p&gt;
&lt;h2 id=&quot;对于大根堆的插入&quot;&gt;&lt;a href=&quot;#对于大根堆的插入&quot; class=&quot;headerlink&quot; title=&quot;对于大根堆的插入&quot;&gt;&lt;/a&gt;对于大根堆的插入&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2017/08/04/bigheap/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;br&gt;对于大根堆的插入，可以在排序前确定大根堆的形状，可以确定元素5从位置6插入，那么比较元素5和位置3的元素2，&lt;/p&gt;
&lt;p&gt;元素5比元素2大，将2下移。接着比较元素5和元素20，一次类推，直到找到元素5的合理位置。&lt;/p&gt;
&lt;p&gt;接着看一下如果插入的元素是21，怎么进行排序。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
      <category term="数据结构和算法" scheme="http://www.limerence2017.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++模板类注意事项</title>
    <link href="http://www.limerence2017.com/2017/08/04/cpptemp/"/>
    <id>http://www.limerence2017.com/2017/08/04/cpptemp/</id>
    <published>2017-08-04T04:16:19.000Z</published>
    <updated>2017-08-04T04:20:59.297Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用<code>C++模板</code>，虽然工作几年了，但是模板用的很少，确切的说自己实现的机会很小。</p>
<p>昨天写了一个代码maxheap.h 中实现了类模板的声明，我将实现写在maxheap.cpp中，</p>
<p>当在main.cpp中引用maxheap中的接口时，提示链接错误。网上提供了几个解决方案，</p>
<p>第一种方式是将maxheap.h和maxheap.cpp包含在某个.h文件中，这样在main函数中</p>
<p>包含这个.h即可。第二种方式叫<code>分离模式</code>，我没看，觉得没必要搞得那么复杂。第三种方式</p>
<p>是我最看好的方式，就是将模板类的实现也放在.h中。C++ <code>stl模板</code>就是在.h中实现的。<br><a id="more"></a></p>
<p>C++编译文件<code>将.cpp编译为.o文件</code>，在<code>链接阶段将.o文件链接生成可执行文件</code>。问题</p>
<p>就出现在模板实现的.cpp文件并不在编译时实例化，读者可以试着在模板实现的.cpp里</p>
<p>写一些错误的代码，编译器并没有监测到，`因为模板实现的cpp没有参与编译。他需要在特定类型</p>
<p>绑定后才会实例化，是延时的`。</p>
<p>编译器使用模板，通过更换模板参数来创建数据类型。这个过程就是模板实例化(Instantiation)。<br>  <code>从模板类创建得到的类型称之为特例(specialization)</code>。<br>  <code>模板实例化取决于编译器能够找到可用代码来创建特例(称之为实例化要素，
  point of instantiation)</code>。<br>  <code>要创建特例，编译器不但要看到模板的声明，还要看到模板的定义</code>。<br>  <code>模板实例化过程是迟钝的，即只能用函数的定义来实现实例化</code>。</p>
<p>`所以将类模板的实现文件放在.h里，main函数包含该.h文件，当main函数用到该模板的特例化时</p>
<p>通过该.h就可以找到所有模板的实例化了`。链接也没问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用&lt;code&gt;C++模板&lt;/code&gt;，虽然工作几年了，但是模板用的很少，确切的说自己实现的机会很小。&lt;/p&gt;
&lt;p&gt;昨天写了一个代码maxheap.h 中实现了类模板的声明，我将实现写在maxheap.cpp中，&lt;/p&gt;
&lt;p&gt;当在main.cpp中引用maxheap中的接口时，提示链接错误。网上提供了几个解决方案，&lt;/p&gt;
&lt;p&gt;第一种方式是将maxheap.h和maxheap.cpp包含在某个.h文件中，这样在main函数中&lt;/p&gt;
&lt;p&gt;包含这个.h即可。第二种方式叫&lt;code&gt;分离模式&lt;/code&gt;，我没看，觉得没必要搞得那么复杂。第三种方式&lt;/p&gt;
&lt;p&gt;是我最看好的方式，就是将模板类的实现也放在.h中。C++ &lt;code&gt;stl模板&lt;/code&gt;就是在.h中实现的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 局部静态变量，全局变量，全局静态变量，局部变量的区别和联系</title>
    <link href="http://www.limerence2017.com/2017/08/04/cppvariable/"/>
    <id>http://www.limerence2017.com/2017/08/04/cppvariable/</id>
    <published>2017-08-04T04:07:00.000Z</published>
    <updated>2017-08-04T04:15:10.576Z</updated>
    
    <content type="html"><![CDATA[<p>C++变量根据定义位置的不同，具有不同的作用域，作用域可分为6种：<code>全局作用域</code>，<code>局部作用域</code>，<code>语句作用域</code>，<code>类作用域</code>，<code>命名作用域</code>和<code>文件作用域</code>。</p>
<p>从作用域看：</p>
<p><code>全局变量</code>具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。</p>
<p><code>静态局部变量</code>具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，即它的生命周期是程序运行就存在，程序结束就结束，</p>
<p>他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。也就是在别的函数访问这个变量是错误的。</p>
<p><code>局部变量</code>也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。</p>
<p>生命周期在函数结束后就结束了，作用域也仅限于该函数。</p>
<p>静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。</p>
<p>这样即使两个不同的源文件都定义了相同的<code>静态全局变量</code>，他们也是不同的变量。<br><a id="more"></a><br>从分配内存空间看：</p>
<p>全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。</p>
<p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p>
<p>1、静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别，单例模式就是利用这个机制。</p>
<p>2、变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。</p>
<p>从以上分析可以看出，把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围，</p>
<p>因此static这个说明符在不同的地方起的作用是不同的。</p>
<p>TIPS：</p>
<p>1、若全局变量仅在单个文件中访问，则可以将这个变量修改为静态全局变量。</p>
<p>2、若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。</p>
<p>3、全局变量、静态局部变量、静态全局变量都存放在静态数据存储区。</p>
<p>4、函数中必须要使用static变量的情况：当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，</p>
<p>因为他的生命周期是整个程序运行周期。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++变量根据定义位置的不同，具有不同的作用域，作用域可分为6种：&lt;code&gt;全局作用域&lt;/code&gt;，&lt;code&gt;局部作用域&lt;/code&gt;，&lt;code&gt;语句作用域&lt;/code&gt;，&lt;code&gt;类作用域&lt;/code&gt;，&lt;code&gt;命名作用域&lt;/code&gt;和&lt;code&gt;文件作用域&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从作用域看：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;全局变量&lt;/code&gt;具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;静态局部变量&lt;/code&gt;具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，即它的生命周期是程序运行就存在，程序结束就结束，&lt;/p&gt;
&lt;p&gt;他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。也就是在别的函数访问这个变量是错误的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;局部变量&lt;/code&gt;也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。&lt;/p&gt;
&lt;p&gt;生命周期在函数结束后就结束了，作用域也仅限于该函数。&lt;/p&gt;
&lt;p&gt;静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。&lt;/p&gt;
&lt;p&gt;这样即使两个不同的源文件都定义了相同的&lt;code&gt;静态全局变量&lt;/code&gt;，他们也是不同的变量。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TCP粘包处理</title>
    <link href="http://www.limerence2017.com/2017/08/04/cpptcpnian/"/>
    <id>http://www.limerence2017.com/2017/08/04/cpptcpnian/</id>
    <published>2017-08-04T03:51:30.000Z</published>
    <updated>2017-08-04T04:05:23.568Z</updated>
    
    <content type="html"><![CDATA[<p><code>TCP</code>（transport control protocol，<code>传输控制协议</code>）是<code>面向连接</code>的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，</p>
<p>因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（<code>Nagle算法</code>），将多次间隔较小且数据量小的数据，合<code>并成一个大的数据块</code>，</p>
<p>然后进行<code>封包</code>。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。</p>
<p><code>UDP</code>（user datagram protocol，用户数据报协议）是<code>无连接的</code>，<code>面向消息</code>的，提供高效率服务。不会使用块的合并优化算法，</p>
<p>由于UDP支持的是一对多的模式，所以接收端的<code>skbuff(套接字缓冲区）</code>采用了链式结构来记录每一个到达的UDP包，</p>
<p>在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即<code>面向消息的通信是有消息保护边界的</code>。<br><a id="more"></a></p>
<h2 id="TCP粘包我总结了几种情况"><a href="#TCP粘包我总结了几种情况" class="headerlink" title="TCP粘包我总结了几种情况"></a>TCP粘包我总结了几种情况</h2><p><img src="/2017/08/04/cpptcpnian/1.png" alt="1.png"><br>tcp发送端发送三个包过来，tcp接收缓存区收到了这三个包，而用户的读写缓存区比这三个包的总大小还大，</p>
<p>此时数据是接受完全的，用户缓存区读到三个包需要分开，这是比较好处理的。<br><img src="/2017/08/04/cpptcpnian/2.png" alt="2.png"><br>第二种情况是因为用户的接收缓存区比tcp接受缓存区大，或者比tcp目前接收到的总数据大，那么用户缓存区读到</p>
<p>的数据就是tcp接收缓存区的数据，这是第一种情况的特例，这种情况需要判断那些包接受完全，那些包没接受完全。<br><img src="/2017/08/04/cpptcpnian/3.png" alt="3.png"><br>第三种情况是用户的接受缓存区比tcp接受缓存区要小，导致用户缓存区读到的数据是tcp接收缓存区</p>
<p>的一部分，这其中有完整的包，也有残缺的包。<br><img src="/2017/08/04/cpptcpnian/4.png" alt="4.png"><br>第四种情况是第三种情况的一个特例，用户缓存区的数据是不完全的，只是tcp缓存区的一部分。</p>
<p>对应特别大的那种包。</p>
<p>我提倡的解决办法就是首先实现一套从tcp缓存区中读取数据的数据结构和算法，因为tcp是面向</p>
<p>字节流的，将tcp缓存区中的数据读到用户缓存区里，这里我简单叫做outstreambuffer和instreambuffer，</p>
<p>这两个结构一个用于向tcp写，一个用于从tcp读。把tcp缓存区的数据尽可能多的读出来，不要判断是否是</p>
<p>完整的包，保证tcp缓存区没数据，这样会减少tcp粘包几率。</p>
<p>第二部就是将读到的数据，也就是instreambuffer中的数据进行分割，我叫做切包，切出一个个完整的包，</p>
<p>剩余不完整的留着下次继续接收。</p>
<p>第三步服务器应用层接口从instreambuffer中读取切割好的完整的包进行逻辑处理。</p>
<p>所以为了处理粘包和切包，需要我们自己设计包头，我设计的包头是八字节的结构体，</p>
<p>包含四字节的包id和四字节的包长度，这个长度既可以表示包头+消息体的长度，</p>
<p>也可以表示后面消息体的长度。我设计的是表示后面消息体的长度。</p>
<p>而上面所说的instreambuffer和outstreambuffer用户可以自己设计实现，也可以</p>
<p>利用成熟的网络库，我用的是libevent中的bufferevent，bufferevent实现了类似</p>
<p>的instreambuffer和outstreambuffer。</p>
<p>我设计的服务器部分代码如下，感兴趣可以去git下载：</p>
<p><a href="https://github.com/secondtonone1/smartserver" target="_blank" rel="external">https://github.com/secondtonone1/smartserver</a></p>
<p>简单列举下接收端处理读数据的过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> NetWorkSystem::tcpread_cb(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</div><div class="line">&#123;</div><div class="line">    getSingleton().dealReadEvent(bev, ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>networksystem是单例模式，处理读事件。因为静态函数tcpread_cb是libevent</p>
<p>设计格式的回调处理函数，在静态函数中调用非静态函数，我采用了单例调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> NetWorkSystem::dealReadEvent(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">evutil_socket_t</span>  bufferfd = bufferevent_getfd(bev);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">evutil_socket_t</span>, TcpHandler *&gt;::iterator tcpHandlerIter = m_mapTcpHandlers.find(bufferfd);</div><div class="line">    <span class="keyword">if</span>(tcpHandlerIter != m_mapTcpHandlers.end())</div><div class="line">    &#123;</div><div class="line">        tcpHandlerIter-&gt;second-&gt;dealReadEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tcphandler是我设计的切包类，这里通过bufferfd找到对应的instream和outstream，从而处理里面的数据完成切包。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//处理读事件</span></div><div class="line"><span class="keyword">void</span> TcpHandler::dealReadEvent()</div><div class="line">&#123;</div><div class="line">    evbuffer * inputBuf = bufferevent_get_input(m_pBufferevent);</div><div class="line">    <span class="keyword">size_t</span> inputLen = evbuffer_get_length(inputBuf);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(inputLen &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//tcphandler第一次接收消息或者该node接收完消息，需要开辟新的node接受消息</span></div><div class="line">        <span class="keyword">if</span>(!m_pLastNode || m_pLastNode-&gt;m_nMsgLen &lt;= m_pLastNode-&gt;m_nOffSet)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//判断消息长度是否满足包头大小，不满足跳出</span></div><div class="line">            <span class="keyword">if</span>(inputLen  &lt; PACKETHEADLEN)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">char</span> data[PACKETHEADLEN]  = &#123;<span class="number">0</span>&#125;;</div><div class="line">            bufferevent_read(m_pBufferevent, data, PACKETHEADLEN);</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">PacketHead</span>  <span class="title">packetHead</span>;</span></div><div class="line"></div><div class="line">            <span class="built_in">memcpy</span>(&amp;packetHead, data, PACKETHEADLEN);</div><div class="line"></div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"packetId is : "</span> &lt;&lt;packetHead.packetID &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"packetLen is :  "</span> &lt;&lt; packetHead.packetLen &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">            insertNode(packetHead.packetID, packetHead.packetLen);</div><div class="line"></div><div class="line">            inputLen -= PACKETHEADLEN;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//考虑可能去包头后剩余的为0</span></div><div class="line">        <span class="keyword">if</span>(inputLen &lt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//读取去除包头后剩余消息</span></div><div class="line">        tcpRead(inputLen);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数判断是否读完一个消息，读完就开辟新的节点存储新来的消息，否则就将新来的消息放入没读完的节点里。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TcpHandler::tcpRead(UInt32 &amp;inputLen)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//node节点中的数据还有多少没读完</span></div><div class="line">    UInt32 remainLen = m_pLastNode-&gt;m_nMsgLen - m_pLastNode-&gt;m_nOffSet;</div><div class="line"></div><div class="line">    UInt32 readLen = bufferevent_read(m_pBufferevent, m_pLastNode-&gt;m_pMsg + m_pLastNode-&gt;m_nOffSet, remainLen);</div><div class="line">    <span class="comment">//统计bufferevent 的inputbuffer中剩余的长度</span></div><div class="line">    inputLen -= readLen;</div><div class="line">    <span class="comment">//更改偏移标记</span></div><div class="line">    m_pLastNode-&gt;m_nOffSet += readLen;</div><div class="line">    <span class="comment">//判断读完</span></div><div class="line">    <span class="keyword">if</span>(m_pLastNode-&gt;m_nOffSet &gt;= m_pLastNode-&gt;m_nMsgLen)</div><div class="line">    &#123;</div><div class="line">        m_pLastNode-&gt;m_pMsg[m_pLastNode-&gt;m_nMsgLen + <span class="number">1</span>] = <span class="string">'\0'</span>; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"receive msg is : "</span> &lt;&lt; m_pLastNode-&gt;m_pMsg &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="comment">//cout &lt;&lt;"read times is :  " &lt;&lt; ++readtimes&lt;&lt; endl;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我的服务器还在完善中，目前已经能处理连续收到1万个包的切包和大并发的问题了，最近在设计应用层的序列化</p>
<p>和应用层消息回调。感兴趣可以下载看看，下载地址：<a href="https://github.com/secondtonone1/smartserver" target="_blank" rel="external">https://github.com/secondtonone1/smartserver</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;（transport control protocol，&lt;code&gt;传输控制协议&lt;/code&gt;）是&lt;code&gt;面向连接&lt;/code&gt;的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，&lt;/p&gt;
&lt;p&gt;因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（&lt;code&gt;Nagle算法&lt;/code&gt;），将多次间隔较小且数据量小的数据，合&lt;code&gt;并成一个大的数据块&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;然后进行&lt;code&gt;封包&lt;/code&gt;。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;（user datagram protocol，用户数据报协议）是&lt;code&gt;无连接的&lt;/code&gt;，&lt;code&gt;面向消息&lt;/code&gt;的，提供高效率服务。不会使用块的合并优化算法，&lt;/p&gt;
&lt;p&gt;由于UDP支持的是一对多的模式，所以接收端的&lt;code&gt;skbuff(套接字缓冲区）&lt;/code&gt;采用了链式结构来记录每一个到达的UDP包，&lt;/p&gt;
&lt;p&gt;在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即&lt;code&gt;面向消息的通信是有消息保护边界的&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
      <category term="网络编程" scheme="http://www.limerence2017.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++单例模式设计和实现</title>
    <link href="http://www.limerence2017.com/2017/08/04/cppsingle/"/>
    <id>http://www.limerence2017.com/2017/08/04/cppsingle/</id>
    <published>2017-08-04T03:44:16.000Z</published>
    <updated>2017-08-04T03:49:31.783Z</updated>
    
    <content type="html"><![CDATA[<p>C++单例模式主要用途就是整个程序中只实例化一个对象，之后获取到的都是该对象本身进行处理问题。</p>
<p><code>单例模式</code>一般都是在函数中采用局部静态变量完成的，因为<code>局部的静态变量</code>生命周期是随着程序的生命周期</p>
<p>一起结束，所以不用担心会失效。另外局部的静态变量<code>作用域</code>仅限于该函数内部，别的函数不会直接使用。</p>
<p>第三点就是局部的静态变量跟所有的静态变量一样，放在<code>全局区(静态区)</code>，只被<code>初始化一次</code>。<br><a id="more"></a><br>下面是我结合模板设计的单例类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SINGLETON_CLASS_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _SINGLETON_CLASS_H_</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Singleton</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">protected</span> :</div><div class="line">    Singleton()&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Type &amp; <span class="title">getSingleton</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;        </div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        </div><div class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; temp)&#123;</div><div class="line">        singleton = temp.singleton;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> Type singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></div><div class="line"><span class="class"><span class="title">Type</span> <span class="title">Singleton</span>&lt;Type&gt;:</span>:singleton;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>其余的类继承就可以了。</p>
<p>需要注意类的静态成员变量，如果不是integer type，需要在类外完成初始化。</p>
<p>int属于integer type，在类内可以完成初始化。</p>
<p>其余的类继承该类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetWorkSystem</span> :</span> <span class="keyword">public</span> Singleton&lt;NetWorkSystem&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    NetWorkSystem():m_nListenfd(<span class="number">0</span>),m_pEvent_base(<span class="literal">NULL</span>),m_nConnId(<span class="number">0</span>)&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">initial</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">tcpread_cb</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">tcpwrite_cb</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">tcperror_cb</span><span class="params">(struct bufferevent *bev, <span class="keyword">short</span> what, <span class="keyword">void</span> *ctx)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">listener_read_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, <span class="keyword">void</span> *p)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//...   </span></div><div class="line"> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用时使用getsinggleton这个函数即可。</p>
<p>这是我服务器中截取的代码，可以从github中下载该服务器源码。</p>
<p>下载地址：<a href="https://github.com/secondtonone1/smartserver" target="_blank" rel="external">https://github.com/secondtonone1/smartserver</a></p>
<p>服务器自己做的，还在不断地完善之中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++单例模式主要用途就是整个程序中只实例化一个对象，之后获取到的都是该对象本身进行处理问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;单例模式&lt;/code&gt;一般都是在函数中采用局部静态变量完成的，因为&lt;code&gt;局部的静态变量&lt;/code&gt;生命周期是随着程序的生命周期&lt;/p&gt;
&lt;p&gt;一起结束，所以不用担心会失效。另外局部的静态变量&lt;code&gt;作用域&lt;/code&gt;仅限于该函数内部，别的函数不会直接使用。&lt;/p&gt;
&lt;p&gt;第三点就是局部的静态变量跟所有的静态变量一样，放在&lt;code&gt;全局区(静态区)&lt;/code&gt;，只被&lt;code&gt;初始化一次&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术开发" scheme="http://www.limerence2017.com/categories/tech/"/>
    
    
      <category term="C++" scheme="http://www.limerence2017.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.limerence2017.com/2017/08/04/hello-world/"/>
    <id>http://www.limerence2017.com/2017/08/04/hello-world/</id>
    <published>2017-08-04T03:15:43.158Z</published>
    <updated>2017-08-04T03:15:43.159Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
