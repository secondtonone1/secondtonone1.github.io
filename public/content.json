[{"title":"windows多线程接口介绍和使用","date":"2017-08-03T12:47:18.000Z","path":"2017/08/03/winmulthread/","text":"一windows多线程接口：1 创建线程CreateThread 与 _beginthreadex都可以实现创建线程，两个函数的参数相同， 12345678 HANDLEWINAPICreateThread( LPSECURITY_ATTRIBUTESlpThreadAttributes, SIZE_TdwStackSize, LPTHREAD_START_ROUTINElpStartAddress, LPVOIDlpParameter, DWORDdwCreationFlags, LPDWORDlpThreadId); 函数说明： 第一个参数表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。 第二个参数表示线程栈空间大小。传入0表示使用默认大小（1MB）。 第三个参数表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。 第四个参数是传给线程函数的参数。 第五个参数指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。 第六个参数将返回线程的ID号，传入NULL表示不需要返回该线程ID号。 函数返回值： 成功返回新线程的句柄，失败返回NULL。 CreateThread 与 _beginthreadex的区别是_beginthreadex更安全一些，_beginthreadex会为每个线程分配一些独立的数据块，这个独立的数据块用于保存线程独有的信息，因 为在调用C的标准库时，有些函数是返回的是全局信息，这个全局信息容易被多线程干扰，_beginthreadex会规避这个问题。 2线程等待函数WaitForSingleObject，WaitForSingleObject这个函数使线程等待某个特定的对象，使线程进入等待状态，直到指定的内核对象被触发。 DWORDWINAPIWaitForSingleObject( HANDLEhHandle, DWORDdwMilliseconds); 函数说明： 第一个参数为要等待的内核对象。 第二个参数为最长等待的时间，以毫秒为单位，如传入5000就表示5秒，传入0就立即返回，传入INFINITE表示无限等待。 因为线程的句柄在线程运行时是未触发的，线程结束运行，句柄处于触发状态。所以可以用WaitForSingleObject()来等待一个线程结束运行。函数返回值：在指定的时间内对象被触发，函数返回WAIT_OBJECT_0。超过最长等待时间对象仍未被触发返回WAIT_TIMEOUT。传入参数有错误将返回WAIT_FAILED 具体的使用 可以从我自己做的服务器里截取一部分代码看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344void BaseThread::startup(UInt32 stackSize)&#123; assert(m_nId == 0); #if defined _WIN32 m_hThread =(HANDLE) _beginthreadex(NULL,0,threadFunc, this, 0, &amp;m_nId); //cout &lt;&lt; this &lt;&lt;endl; ::SetThreadPriority(::GetCurrentThread(), 2); //让线程跑起来后再退出函数 // Sleep(1000); #endif&#125;void BaseThread::join()&#123; #if defined _WIN32 DWORD exitCode; while(1) &#123; if(GetExitCodeThread(m_hThread, &amp;exitCode) != 0) &#123; if(exitCode != STILL_ACTIVE) &#123; break; &#125; else &#123; // wait之前， 需要唤起线程， 防止线程处于挂起状态导致死等 ResumeThread(m_hThread); WaitForSingleObject(m_hThread, INFINITE); &#125; &#125; else &#123; break; &#125; &#125; CloseHandle(m_hThread); #endif m_nId = 0;&#125;","categories":[{"name":"技术开发","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows环境编程/"}]},{"title":"Windows互斥锁demo和分析","date":"2017-08-03T12:36:08.000Z","path":"2017/08/03/winmutexdemo/","text":"一：windows创建锁接口创建互斥锁的方法是调用函数CreateMutex12345HANDLE CreateMutex(LPSECURITY_ATTRIBUTESlpMutexAttributes, // 指向安全属性的指针BOOLbInitialOwner, // 初始化互斥对象的所有者LPCTSTRlpName // 指向互斥对象名的指针); 第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例子： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr); 二：windows持有锁接口：DWORD WaitForSingleObject( HANDLE hHandle,DWORD dwMilliseconds); 这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。 三：释放锁BOOL WINAPI ReleaseMutex(HANDLE hMutex); 四：销毁BOOL CloseHandle(HANDLE hObject); 下面是网上的一个案例，根据我自己做服务器的需求，模仿者写了一个： ‘’’ cpp//各种类型的锁的基类class BaseLock{public: BaseLock(){} virtual ~BaseLock(){} virtual void lock() const = 0 ; virtual void unlock() const = 0 ;}; //互斥锁继承基类class Mutex :public BaseLock{public: Mutex(); ~Mutex(); virtual void lock() const; virtual void unlock() const;private: #if defined _WIN32 HANDLE m_hMutex; #endif}; //互斥锁实现文件： //在构造函数里创建锁Mutex::Mutex(){ #if defined _WIN32 m_hMutex = ::CreateMutex(NULL, FALSE, NULL); #endif } //析构函数里销毁锁Mutex::~ Mutex(){ #if defined _WIN32 ::CloseHandle(m_hMutex); #endif } //互斥锁上锁void Mutex::lock() const{ #if defined _WIN32 DWORD d = WaitForSingleObject(m_hMutex, INFINITE); #endif } //互斥锁解锁void Mutex::unlock() const{ #if defined _WIN32 ::ReleaseMutex(m_hMutex); #endif } class CLock{public: CLock(const BaseLock &amp; baseLock):m_cBaseLock(baseLock){ //构造函数里通过基类锁调用加锁函数(多态) m_cBaseLock.lock(); } ~CLock(){ //析构函数先解锁 m_cBaseLock.unlock(); }private: //常引用变量，需要在初始化列表初始 //多态机制 const BaseLock&amp; m_cBaseLock;};‘’’ CLock是留给外界使用的接口类，可以实现自动加锁和解锁。构造函数传入不同类型的锁，目前只实现了互斥锁，通过基类类型的引用成员可以实现多态调用不同的lock和unlock，而CLock析构函数因为会调用基类的unlock，从而实现不同类型的解锁。那么读者可能会有疑问互斥锁什么时候会销毁？互斥锁的销毁写在互斥锁类的析构函数里，当调用互斥锁的析构函数就会自动销毁这把锁了。什么时候调用互斥锁的析构函数呢？之前有介绍过，析构函数的调用顺序，先析构子类对象，然后析构子类对象中包含的其他类型的对象，最后析构基类对象，所以整个流程是先调用Mutex的构造函数，将Mutex构造的对象传入CLock的构造函数，这样实现自动加锁，当CLock析构的时候先析构CLock对象，之后析构CLock类里的BaseLock对象，因为是多态，会自动根据虚析构函数调用子类也就是MutexLock的析构函数，完成销毁锁的操作。 下面是我服务器中的一段代码截取，算是这个锁的示例 123456789void NetWorker::pushNodeInStream(TcpHandler * tcpHandler)&#123; //加锁处理消息加入到instream里 Mutex mutexlock; CLock mylock(mutexlock); list&lt;MsgNode *&gt; * msgList = tcpHandler-&gt;getListMsgs();&#125; 因为函数}会释放局部变量，那么就会调用CLock析构函数，接着调用Mutex析构函数。依次完成解锁和销毁锁的操作。我的服务器还在制作当中，基本框架制作完毕会做一些服务器设计的研究。","categories":[{"name":"技术开发","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows环境编程/"}]},{"title":"windows环境利用semophore机制进行线程同步","date":"2017-08-03T10:23:28.000Z","path":"2017/08/03/winsemphore/","text":"semophore是信号量的意思，常用于PV操作，所谓PV操作就是pend(等待，直到有资源可用，并且消耗资源)V就是释放资源。semophore和mutex区别，mutex本意为互斥，用于线程独占资源，常用于临界区访问锁住mutex，当线程A对mutex加锁后，其他线程不能反问临界资源，也不能加锁，直到线程A解锁，其他线程才能访问。而semophore则可以在不同的线程之间进行pv操作，semophore可以设置最多有多少个信号量，以及初始的信号量，当调用V操作的时候信号量数量增加一个，调用P操作时候信号量数量减少一个，但是不能超过最多的信号量。信号量是一个非负数。打个比方，一辆车只有一把钥匙，mutex就是这把钥匙，谁有这把钥匙才能开车，开完车把钥匙归还或者给下一个等待的人。现在有一辆公交车，最多容纳二十个人，二十就是信号量的最大值，每个人就是一个信号量，当人满的时候其他的人就不能上车，直到有人下车，其他人才能上车。 semophore主要适用于windows环境下的同步 下面介绍下semophore1 创建信号量1234567891011HANDLE WINAPI CreateSemaphore( _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes _In_ LONG lInitialCount, _In_ LONG lMaximumCount, _In_opt_ LPCTSTR lpName ); 第一个参数：安全属性，如果为NULL则是默认安全属性 第二个参数：信号量的初始值，要&gt;=0且&lt;=第三个参数 第三个参数：信号量的最大值 第四个参数：信号量的名称 返回值：指向信号量的句柄，如果创建的信号量和已有的信号量重名，那么返回已经存在的信号量句柄 2打开其他进程中的信号量12345HANDLE WINAPI OpenSemaphore( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCTSTR lpName ); dwDesiredAccess：指定想要的访问权限，SEMAPHORE_ALL_ACCESS 请求对事件对象的完全访问，SEMAPHORE_MODIFY_STATE 修改状态权限，使用ReleaseSemaphore函数需要该权限；bInheritHandle：是否希望子进程继承信号量对象的句柄，一般设置为false；lpName：要打开的信号量对象的名称； 3等待信号量1234DWORD WINAPI WaitForSingleObject( _In_ HANDLE hHandle, _In_ DWORD dwMilliseconds ); hHandle：指向内核对象的句柄；dwMilliseconds：线程最大等待多长时间，直到该对象被触发。经常使用INFINITE，表示阻塞等待。WaitForSingleObject为等待资源的函数，等待内核对象被触发的通用函数，在这里用于等待信号量，我们之前说过信号量的资源数是非负整数，当信号量数量大于0，那么该函数会将信号量-1，并且返回，线程继续执行后续操作。如果信号量资源数为0，那么该线程处于等待状态，阻塞等待信号量被激活。 4 释放信号量12345BOOL WINAPI ReleaseSemaphore( _In_ HANDLE hSemaphore, _In_ LONG lReleaseCount, _Out_opt_ LPLONG lpPreviousCount ); hSemaphore：信号量内核对象的句柄；lReleaseCount：释放自己使用的资源数目，加到信号量的当前资源计数上，通常会传1，当然是根据线程使用的资源数目而定。lpPreviousCount：返回当前资源计数的原始值，应用程序很少会用到这个值，所以一般置为NULL；当一个线程使用完信号量对象控制的有限资源后，应该调用ReleaseSemaphore，释放使用的资源，使信号量对象的当前资源计数得到恢复。 5关闭内核对象的句柄123BOOL WINAPI CloseHandle( _In_ HANDLE hObject ); hObject：指向内核对象的句柄和其他内核对象一样，无论以什么方式创建内核对象，我们都必须通过调用CloseHandle向系统表明结束使用内核对象。如果传入的句柄有效，系统将获得内核对象数据结构的地址，并将结构中的使用计数减1，如果使用计数0，就会将内核对象销毁，从内存空间中擦除。下面写一个例子，三个线程，分别为如数1,2,3，要求每个线程输出10此，以1,2,3分别输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//先定义三个信号量句柄：HANDLE hsem1,hsem2,hsem3; //线程回调函数：unsigned __stdcall threadFunA(void *)&#123; for(int i = 0; i &lt; 10; i++)&#123; WaitForSingleObject(hsem1, INFINITE);//等待信号量 cout&lt;&lt;\"first thread function\"&lt;&lt;endl; ReleaseSemaphore(hsem2, 1, NULL);//释放信号量2 &#125; return 1;&#125;//该函数内部调用等待第一个信号量，如果获得资源，则打印日志，并且释放资源2//同样的道理，完成第二个，第三个线程回调函数unsigned __stdcall threadFunB(void *)&#123; for(int i = 0; i &lt; 10; i++)&#123; WaitForSingleObject(hsem2, INFINITE);//等待信号量 cout&lt;&lt;\"second thread function\"&lt;&lt;endl; ReleaseSemaphore(hsem3, 1, NULL);//释放信号量3 &#125; return 2;&#125; unsigned __stdcall threadFunC(void *) &#123; for(int i = 0; i &lt; 10; i++)&#123; WaitForSingleObject(hsem3, INFINITE);//等待信号量 cout&lt;&lt;\"third thread function\"&lt;&lt;endl; ReleaseSemaphore(hsem1, 1, NULL);//释放信号量 &#125; return 3; &#125;//接下来在主函数创建三个线程，并且初始化第一个信号量的初始资源数为1，//第二个和第三个信号量初始资源数都是0，他们的最大资源数为1.//创建信号量 hsem1 = CreateSemaphore(NULL, 1, 1, NULL); hsem2 = CreateSemaphore(NULL, 0, 1, NULL); hsem3 = CreateSemaphore(NULL, 0, 1, NULL); HANDLE hth1, hth2, hth3; //创建线程 hth1 = (HANDLE)_beginthreadex(NULL, 0, threadFunA, NULL, 0, NULL); hth2 = (HANDLE)_beginthreadex(NULL, 0, threadFunB, NULL, 0, NULL); hth3 = (HANDLE)_beginthreadex(NULL, 0, threadFunC, NULL, 0, NULL); //当线程调用完回调函数才能让主线程退出，linux系统对应的api为pthread_join()，//我们这里windows api为 WaitForSingleObject//等待子线程结束 WaitForSingleObject(hth1, INFINITE); WaitForSingleObject(hth2, INFINITE); WaitForSingleObject(hth3, INFINITE); //最后释放线程的句柄和信号量的句柄 //一定要记得关闭线程句柄 CloseHandle(hth1); CloseHandle(hth2); CloseHandle(hth3); CloseHandle(hsem1); CloseHandle(hsem2); CloseHandle(hsem3); 打印输出如下：结果显示三个线程是按顺序输出的。所以信号量常用来同步线程。源代码下载地址：semophore测试","categories":[{"name":"技术开发","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows环境编程/"}]},{"title":"windows环境下封装条件wait和signal","date":"2017-08-03T09:46:34.000Z","path":"2017/08/03/winsignal/","text":"linux 环境有提供好的pthread_cond_wait() 和 phread_signal()、pthread_broadcast()windows需要自己封装，利用semophore控制线程等待和释放，先简单谈一下设计好后api该如何使用。假设我们封装好条件变量等待函数名字叫做wait(Mutex&amp; mutex)，Mutex是之前我们封装的条件变量，文章最下边会给出这些文件的下载地址，在这里读者当做linux 的mutex即可。我们封装的释放函数为signal(),广播函数为broadcast。判断等待条件变量和逻辑处理如下：12345678910111213Lock(mutex);while(条件不满足)&#123; wait(mutex);&#125;todo...;UnLock(mutex); 激活条件变量如下：123456789101112131415Lock(mutex); todo ...; if(条件满足) &#123; signal();/broadcast(); &#125; signal();UnLock(mutex); Condition 是我们封装的条件变量类这是封装好api后调用规则，那么先考虑wait内部的基本形式1234567891011121314151617181920212223void Condition::wait(Mutex &amp;mutex)&#123; //1 Condition 类中表示阻塞线程数 mblocked ++; //2 解锁，释放互斥量 UnLock(mutex); //3 阻塞等待 mQueue为信号量 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); //4 做一些判断和逻辑处理 //5 加锁 Lock(mutex);&#125; wait内部记录一个阻塞的线程数mblocked，mblocked 是我们封装Condition类的成员变量，然后释放外部的互斥量，然后调用阻塞函数，等待signal唤醒。当WaitForSingleObject获取信号后会继续执行，做一些逻辑判断，最后将mutex锁住。这里用到的mQueue是一个信号量，用信号量可以接受多个唤醒和控制线程唤醒数量。下面是条件变量释放的函数，我们先做只是放一个条件变量的api123456789101112131415161718192021222324void Condition::signal()&#123; //1阻塞的线程减少 mblocked --; //2将激活的信号个数设置为1 signals = 1; //3 if (signals) &#123; //释放信号量 res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;&#125; 先不要着急往下写，考虑下这么做真的合适么？首先之前设计过外部调用1234567if(条件满足) &#123; signal();/broadcast(); &#125; 这个只要条件满足就可以激活，所以我们只用mblocked表示阻塞线程数是不够的，当信号量被激活很多没有被消耗的情况下就需要统计当前可用的资源数，那么就在Condition类添加mWait表示当前可用的信号量个数。除此之外，考虑这样一种情况，当条件不满足的时候 线程A调用void wait(Mutex &amp;mutex)函数，wait函数先解锁再阻塞，对应wait中第2,3步骤。而另一个线程B当条件满足时调用 signal函数激活之前阻塞的线程A，对应signal函数中第3步。原阻塞线程A因为捕获到信号量，所以一次走到wait中第4、5步。由于第4和第5步之间没有加锁保护，所以这一阶段用到的类的成员变量都是不安全的。所以在第3和第4之间加一个互斥锁，第5步之后释放这个互斥锁。同样的道理，为了避免此时signal内部调用类的成员变量造成数据不一致所以signal内部也需要加锁，在signal内部第1步之前加锁，第3步之后解锁，或者第3步之前解锁都可以。我觉得在第三步之前释放会好一些，在释放信号量之前解锁，避免死锁。所以添加一个成员变量mMutex用于部分代码互斥。那么改良后我们的函数如下： 12345678910111213141516171819202122232425262728voidCondition::wait(Mutex&amp; mutex)&#123; #ifndef WIN32 int ret = pthread_cond_wait(&amp;mId, mutex.getId()); ASSERT(ret == 0); #else //1 mBlocked++;&lt;br&gt; //2 mutex.unlock(); int res = 0;&lt;br&gt; //3 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); //用于暂时存储mWaiting的数值 unsigned wasWaiting = 0; //4 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); wasWaiting = mWaiting; //5 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //6 mutex.lock();#endif&#125; 步骤也做了相应的调整。1234567891011121314151617181920212223242526272829303132333435363738394041424344voidCondition::signal ()&#123;#ifndef WIN32 int ret = pthread_cond_signal(&amp;mId); ASSERT(ret == 0);#else unsigned signals = 0; int res = 0; //1 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); //2 if (mWaiting != 0) &#123; if (mBlocked == 0) &#123; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); return; &#125; ++mWaiting; --mBlocked; signals = 1; &#125; else &#123; signals = mWaiting = 1; --mBlocked; &#125; //3 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //4 if (signals) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;#endif&#125; 改良后更新了步骤，注释的就是步骤，方便接下来讨论这两段代码的隐患，因为仅仅这些还不够。目前现总结下mMutex作用： 1 mMutex用于signal函数内部和wait函数 获取信号量之后的代码互斥，保护类的常用变量。 2 当不同的线程调用wait等待后获得激活时，mMutex保证获得信号量之后的操作是互斥的，安全的。 由于调用wait函数之前需要加外部的互斥锁，所以不同的线程调用wai函数时第一步的mBlocked++是互斥的，不会出错。 唯一有可能出错的是那种情况呢？ 就是当signal发出信号后，当前有一个因为调用wait阻塞的线程A捕获到该信号，进入第四步，修改或者访问mBlocked变量的值，与此同时有线程A调用wait函数，此时会进入wait内部第一步mBlocked++，多线程修改和读取mBlocked会造成数据混乱，所以此时需要在第一步之前加锁，第2步之前解锁，因此添加单个信号量mGate，用于控制当有线程处于解锁状态处理mBlocked等类成员时，其他线程进入wait修改mBlocked值。这个res = WaitForSingleObject(reinterpret_cast(mGate), INFINITE);可以放在wait函数第4步之后，当第4步获得互斥资源后，阻塞等待获取mGate信号，如果没获得需要等待别的线程释放mGate，如果此时mGate不被释放造成mMutex死锁。所以别的线程中先调用 WaitForSingleObject(reinterpret_cast(mGate), INFINITE);后调用WaitForSingleObject mMutex会造成死锁。需要特别注意。如果规避了这一点，那么就可以避免死锁。所有情况都对mGate互斥访问并不友好，出现之前讨论的情况只有一种：就是当前应用程序中至少有一个线程处于等待，而signal释放信号后，某一个等待的线程继续执行4后面的操作，外界有新的线程调用wait时修改mBlocked会出错。所以只需要在signal函数中判断当mWaiting数量为0时对mGate加锁，mWait根据不同情况进行对mGate进行释放。修改后的代码如下： 12345678910voidCondition::enterWait ()&#123; int res = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); ++mBlocked; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res);&#125; 对mBlocked起到保护作用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647voidCondition::wait(Mutex&amp; mutex)&#123;#ifndef WIN32 int ret = pthread_cond_wait(&amp;mId, mutex.getId()); ASSERT(ret == 0);#else //1 enterWait(); //2 mutex.unlock(); int res = 0; //3 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); unsigned wasWaiting = 0; unsigned wasGone = 0; //4 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); wasWaiting = mWaiting; wasGone = mGone; //signal释放资源后，mWaiting 至少为1 if (wasWaiting != 0) &#123; //判断mWaiting 数量为1 if (--mWaiting == 0) &#123; //如果当前没有阻塞线程则释放mGate if (mBlocked != 0) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); // open mGate ASSERT(res); wasWaiting = 0; &#125; &#125; &#125; //5 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //6 mutex.lock();#endif&#125; 对应的signal函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960voidCondition::signal ()&#123;#ifndef WIN32 int ret = pthread_cond_signal(&amp;mId); ASSERT(ret == 0);#else unsigned signals = 0; int res = 0; //1 res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); if (mWaiting != 0) &#123; //当前有空闲的信号量并且没由阻塞的线程 if (mBlocked == 0) &#123; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); return; &#125; //如果由阻塞的线程，那么阻塞数量-- ++mWaiting; --mBlocked; signals = 1; &#125; else &#123; //2当空闲的信号量为0时，互斥获得mGate res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); //3 if (mBlocked ) &#123; //如果当前有线程阻塞那么更新计数 signals = mWaiting = 1; --mBlocked; &#125; else &#123; //由于用户外部不判断条件是否成立多次调动signal，此处不处理直接释放mGate res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); &#125; &#125; //4 res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); //5 if (signals) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;#endif&#125; 到目前为止，对于共享对象的保护和同步都做的比较完善了，还要注意一个问题就是虚假唤醒。这是操作系统可能出现的一种情况，所以需要添加虚假唤醒的逻辑用mGone成员变量表示出错的或是虚假唤醒的线程数最终代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364voidCondition::wait(Mutex&amp; mutex)&#123;#ifndef WIN32 int ret = pthread_cond_wait(&amp;mId, mutex.getId()); ASSERT(ret == 0);#else enterWait(); mutex.unlock(); int res = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); unsigned wasWaiting = 0; unsigned wasGone = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); wasWaiting = mWaiting; wasGone = mGone; if (wasWaiting != 0) &#123; if (--mWaiting == 0) &#123; if (mBlocked != 0) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); // open mGate ASSERT(res); wasWaiting = 0; &#125; else if (mGone != 0) &#123; mGone = 0; &#125; &#125; &#125; else if (++mGone == (ULONG_MAX / 2)) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); mBlocked -= mGone; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); mGone = 0; &#125; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); if (wasWaiting == 1) &#123; for (; wasGone; --wasGone) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); &#125; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); &#125; mutex.lock();#endif&#125; wait部分添加了mGone的处理，当mWaiting数量为0进入res = WaitForSingleObject(reinterpret_cast(mMutex), INFINITE);需要对mGone++表示虚假唤醒的线程数量123456789if (++mGone == (ULONG_MAX / 2)) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); mBlocked -= mGone; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); mGone = 0; &#125; 通过mGate对mBlocked保护起来，当唤醒的个数超过指定值会把多余的mblocked去掉并且把虚假唤醒数量置空。举个例子，当mBLocked为1时该线程被虚假唤醒，那么mGone变为1，由于是虚假唤醒，用户在外部调用wait函数时通过while循环判断条件不满足再次进入wait中enterGate函数对mBlocked自增，此时mBlocked数量为2，所以当冗余的mBlocked超过指定值，就回去掉这些mBlocked并将mGone置空。12345678910if (wasWaiting == 1)&#123; for (; wasGone; --wasGone) &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mQueue), INFINITE); ASSERT(res == WAIT_OBJECT_0); &#125; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res);&#125; 该函数判断Condation类的mWating变量有1变为0，并且阻塞的线程数为0，因为如果用户没有在外边调用while判断条件导致虚假唤醒引起逻辑错误，所以为了起到保护作用对那些因为虚假唤醒错过的信号进行资源占用，直到信号量都被释放后才进入mGate释放。举一个例子如果外部调用123456789Lock(mutex);if(条件不满足)&#123; wait(mutex); &#125;//逻辑处理 ...UnLock(mutex); 当wait执行退出后会执行逻辑，而没有while判断条件是否真的满足。所以我们要对信号量进行控制，保证信号量数量正确。并且和mBlocked，mWait,等一致。下面是signal函数最终版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657voidCondition::signal ()&#123;#ifndef WIN32 int ret = pthread_cond_signal(&amp;mId); ASSERT(ret == 0);#else unsigned signals = 0; int res = 0; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mMutex), INFINITE); ASSERT(res == WAIT_OBJECT_0); if (mWaiting != 0) &#123; if (mBlocked == 0) &#123; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); return; &#125; ++mWaiting; --mBlocked; signals = 1; &#125; else &#123; res = WaitForSingleObject(reinterpret_cast&lt;HANDLE&gt;(mGate), INFINITE); ASSERT(res == WAIT_OBJECT_0); if (mBlocked &gt; mGone) &#123; if (mGone != 0) &#123; mBlocked -= mGone; mGone = 0; &#125; signals = mWaiting = 1; --mBlocked; &#125; else &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mGate), 1, 0); ASSERT(res); &#125; &#125; res = ReleaseMutex(reinterpret_cast&lt;HANDLE&gt;(mMutex)); ASSERT(res); if (signals) &#123; res = ReleaseSemaphore(reinterpret_cast&lt;HANDLE&gt;(mQueue), signals, 0); ASSERT(res); &#125;#endif&#125; 同样的道理12345678910if (mBlocked &gt; mGone) &#123; if (mGone != 0) &#123; mBlocked -= mGone; mGone = 0; &#125; signals = mWaiting = 1; --mBlocked;&#125; 这个逻辑就是处理当虚假唤醒的mBlocked和mGone等数据准确性。因为如果是虚假唤醒，用户通过while(条件不满足)这个方式继续调用wait会导致mBlocked++，假设就一个线程处于阻塞并且因为虚假唤醒通过while循环重新调用wait函数，而此时mGone比mBlocked小1，所以mBlocked - mGone就是更新差值给mBlocked，这是真正的处于阻塞的线程数量。 下面是代码下载地址：betternet 代码效果测试截图：","categories":[{"name":"技术开发","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"},{"name":"Windows环境编程","slug":"Windows环境编程","permalink":"http://www.limerence2017.com/tags/Windows环境编程/"}]},{"title":"C++类成员空间分配和虚函数表","date":"2017-08-03T06:46:34.000Z","path":"2017/08/03/cppvirtual/","text":"最近在自学python，看到继承和类，就顺便复习了C++的类和继承等方面的知识。先看Base基类123456789101112131415161718class Base &#123;private: virtual void display() &#123; cout&lt;&lt;\"Base display()\"&lt;&lt;endl; &#125; void say()&#123; cout&lt;&lt;\"Base say()\"&lt;&lt;endl; &#125;public: virtual void func()&#123;cout &lt;&lt; \"Base func()\" &lt;&lt; endl; &#125; void exec()&#123; display(); say(); &#125; void f1(string a) &#123; cout&lt;&lt;\"Base f1(string)\"&lt;&lt;endl; &#125; void f1(int a) &#123; cout&lt;&lt;\"Base f1(int)\"&lt;&lt;endl; &#125; //overload&#125;; Base类中定义私有的虚函数display， 普通成员函数say，公共的虚函数func， 普通的成员函数exec，重载了f1函数。下面是DeriveA类，继承于Base类12345678910111213class DeriveA:public Base&#123;public: void display() &#123; cout&lt;&lt;\"DeriveA display()\"&lt;&lt;endl; &#125; //override void f1(int a,int b) &#123; cout&lt;&lt;\"DeriveA f1(int,int)\"&lt;&lt;endl; &#125; //redefining void say() &#123; cout&lt;&lt;\"DeriveA say()\"&lt;&lt;endl; &#125; //redefining virtual void func()&#123;cout &lt;&lt; \"DeriveA func()\" &lt;&lt; endl; &#125;&#125;; DeriveA类继承了Base类，重写(覆盖)了虚函数display和func，并且将display权限修改为public。重定义了f1函数和say函数，但是修改了f1的参数列表。下面是基础的几个测试1234567DeriveA a;Base *b=&amp;a; b-&gt;func(); a.func(); b-&gt;f1(\"abc\"); b-&gt;f1(3); a.f1(3,5); 输出结果:func函数在Base类中为虚函数，DeriveA继承Base后，根据多态机制实现了动态调用。所谓多态机制就是用基类指针指向子类对象，基类指针调用虚函数func，会动态调用实际的子类对象的func函数。由于display函数在Base类中为虚函数，所以不可以通过b-&gt;display()调用。由于DeriveA重新定义(redefining)了f1函数，f1函数参数类型修改了，所以只能使用a.f1(int,int)这种调用，而采用a.f1(string)或者采用a.f1(int)这种调用都会出错，编译阶段就会出错。因为DeriveA类对f1重新定义了，基类的f1函数不可通过对象直接调用。同样的道理对于基类指针或对象，无论基类指针指向子类还是基类对象，调用f1只能调用基类定义的两个f1(int)， f1(string)两个函数，如果采用b-&gt;f1(3,5)，编译器在编译阶段就会提出错误。想实现子类对象调用基类的函数可在函数体内加上作用于Base::函数名(参数，…)DeriveA类修改f1函数，先调用基类的f1在调用自己的f1123456789101112131415161718class DeriveA:public Base&#123;public: void display() &#123; cout&lt;&lt;\"DeriveA display()\"&lt;&lt;endl; &#125; //override void f1(int a,int b) &#123; Base::f1(2); Base::f1(\"test\"); cout&lt;&lt;\"DeriveA f1(int,int)\"&lt;&lt;endl; &#125; //redefining void say() &#123; cout&lt;&lt;\"DeriveA say()\"&lt;&lt;endl; &#125; //redefining virtual void func()&#123; cout &lt;&lt; \"DeriveA func()\" &lt;&lt; endl; &#125;&#125;; 打印输出a.f1(3,5);结果如下：先调用了基类的两个f1函数，之后调用DeriveA的f1函数下面调用如下函数b-&gt;exec();a.exec();结果如下：为什么两个结果一样呢？先看b-&gt;exec()；由于b是Base类型变量，那么调用的Base类的exec函数，exec函数内部调用Base类的display()和say() 函数。由于b为指向DeriveA类的基类指针，根据多态机制，调用Base类的display()函数时，会动态调用DeriveA类的display()函数。调用Base类的say()函数时，由于say()函数不是虚函数，所以不触发多态机制。因此b-&gt;exec()函数的结果为调用DeriveA的display，调用Base的say函数。由于DeriveA类继承于Base类，但是没有实现自己的exec()函数，即没有实现重定义，那么当执行a.exec()时，调用的时Base类的exec()函数，原理和上边一样，调用Base类中的display()函数和say()函数，由于display()函数为虚函数，a为DeriveA类对象，调用基类的虚函数display()，根据多态机制，实际调用的是DeriveA类的display()函数。执行下边代码a.say()结果如下：下面修改DeriveA类的内容，在DeriveA类内部实现自己的exec()函数123456789101112131415161718class DeriveA:public Base&#123;public: void exec()&#123; display(); say(); &#125; void display() &#123; cout&lt;&lt;\"DeriveA display()\"&lt;&lt;endl; &#125; //override void f1(int a,int b) &#123; cout&lt;&lt;\"DeriveA f1(int,int)\"&lt;&lt;endl; &#125; //redefining void say() &#123; cout&lt;&lt;\"DeriveA say()\"&lt;&lt;endl; &#125; //redefining virtual void func()&#123; cout &lt;&lt; \"DeriveA func()\" &lt;&lt; endl; &#125;&#125;; 执行下边代码，b-&gt;exec()；a.exec():结果如下:因为DeriveA类重定义了exec函数，那么a.exec()函数调用的是DeriveA类的exec()函数，从而调用的都是DeriveA类的display()和say()函数。 继承类和基类成员函数调用规则总结：DeriveA a; Base *b=&a; 基类指针指向子类对象，该指针调用某个成员函数，先考虑该函数是否为虚函数，如果为虚函数，且子类有覆盖(重写)，会触发多态机制，动态调用子类的重写函数： 如 b-&gt;func()， 输出为DeriveA func() 基类指针指向子类对象，该指针调用某个成员函数，先考虑该函数是否为虚函数，如果为虚函数，子类没有覆盖(没有重写)，不会触发多态机制，调用基类的虚函数： 基类指针指向子类对象，该指针调用某个成员函数，如果该函数不为虚函数，无论该函数是否被子类重定义(redefined)，只调用基类的该成员函数。如DeriveA类内部不实现exec()函数，那么b-&gt;exec()调用的是Base类的exec()函数。 在第3条基础上，基类有成员函数exec()， 子类没有成员函数exec()，在基类的exec() 内部调用虚函数display()， 且子类覆盖了display()函数，那么根据多态机制，调用子类的display()。如果display()虚函数没有被重写，则调用基类的display()函数，同第2条。如果exec()内部调用普通函数say()， 无论子类是否重定义say()，都会调用基类的say()函数，同3 Base类中实现exec()函数，而子类DeriveA类内部不实现exec()函数，DeriveA类对象调用exec()函数，实际调用的为Base类内部的exec()函数。如果exec()内部调用虚函数或者普通成员函数，情况如同第4条。 Base类中实现exec()函数，而子类DeriveA类重定义exec()函数，那么DeriveA类对象调用的是DeriveA类的exec()函数。如果exec()函数内部调用DeriveA类的其他成员函数，那么调用的都是DeriveA类的成员函数。 子类重定义了基类的成员函数，那么子类对象调用该成员函数，要根据子类重定义的形参列表。如a.f1(3,5); 虚函数使用和定义规则: 非类的成员函数不能定义为虚函数，类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。实际上，优秀的程序员常常把基类的析构函数定义为虚函数。因为，将基类的析构函数定义为虚函数后，当利用delete删除一个指向派生类定义的对象指针时，系统会调用相应的类的析构函数。而不将析构函数定义为虚函数时，只调用基类的析构函数。 只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。 如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、参数类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种非虚的同名同返回值同参数个数同参数类型函数。 类的静态函数和构造函数不可以定义为虚函数: 静态函数的目的是通过类名+函数名访问类的static变量，或者通过对象调用staic函数实现对static成员变量的读写，要求内存中只有一份数据。而虚函数在子类中重写，并且通过多态机制实现动态调用，在内存中需要保存不同的重写版本。 构造函数的作用是构造对象，而虚函数的调用是在对象已经构造完成，并且通过调用时动态绑定。动态绑定是因为每个类对象内部都有一个指针，指向虚函数表的首地址。而且虚函数，类的成员函数，static成员函数都不是存储在类对象中，而是在内存中只保留一份。 知其然、知其所以然（虚函数表原理）：虚函数存储在虚函数表中，每个类对象都包含一个指向该虚函数表首地址的指针。定义Baseclass类 123456789class Baseclass &#123; public: Baseclass():a(1024)&#123;&#125; virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; \"Base::g\" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; \"Base::h\" &lt;&lt; endl; &#125; int a;&#125;; 从虚函数表中依次取出函数执行：123456789101112131415161718Baseclass b; cout &lt;&lt;\"类对象大小\" &lt;&lt; sizeof(b) &lt;&lt; endl; int * p = (int *)(&amp;b) ; cout &lt;&lt; \"指向虚函数表的指针的地址\"&lt;&lt; p &lt;&lt; endl; cout &lt;&lt;\"成员a地址\"&lt;&lt; p+1 &lt;&lt; endl; cout &lt;&lt;\"成员a的数值\" &lt;&lt; *(p + 1) &lt;&lt; endl; cout &lt;&lt; \"虚函数表首地址\" &lt;&lt;(int *)(*p) &lt;&lt; endl; Func pFun =(Func) *(int *)(*p); pFun(); pFun =(Func) *((int *)(*p) + 1); pFun(); pFun =(Func) *((int *)(*p) + 2); pFun(); 输出结果如下:可见类对象大小为8字节，4字节正好是指向虚函数表指针的大小。剩余4字节为成员变量a的大小。画个图示意虚函数表结构：p指向的就是类对象的首地址，同时也是虚函数表指针(指向虚函数表的指针)的地址，p指向虚函数表，由于指针是4字节，(int )(p)虚函数表首地址，也是第一个函数指针的地址。Derive类继承于Base类，但是没有覆盖(重写)Base类的虚函数，Derive d; 的虚函数表如下：Derive类继承于Base类，并且覆盖(重写)Base类的虚函数，Derive d; 的虚函数表如下：可以看到d的虚函数表中第一个单元为Derive::f()，覆盖了原有的Base::f()。Derive d;Base p = &d;p指向d的首地址，其实就是d的虚函数表指针的地址，p-&gt;f()实际会调用虚函数表中的Derive::f()，从而实现多态。多重继承结构如下：虚函数表原理后可以篡改部分程序功能，其实很多外挂就是钩子函数回调注入的。12345678910111213141516171819class Baseclass &#123; public: Baseclass():a(1024)&#123;&#125;private: virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; \"Base::g\" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; \"Base::h\" &lt;&lt; endl; &#125; int a;&#125;; class Deriveclass:public Baseclass&#123;public: Deriveclass():Baseclass()&#123;&#125;&#125;; 由于 Baseclass内部的虚函数是私有的，所以Deriveclass类变量是不能直接访问这些函数的。但是可以通过虚函数寻址，并且通过回调函数方式调用。123Deriveclass d; Func pFunc = (Func)*((int *)(*(int *)(&amp;d))); pFunc(); 结果如下： C++类对象的大小为多大？一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。对象大小= vptr(可能不止一个) + 所有非静态数据成员大小 + Aligin字节大小（依赖于不同的编译器对齐和补齐）定义几个类，然后输出他们大小。12345678910111213141516171819202122232425262728293031323334353637class A &#123; &#125;; class B &#123; char ch; void func() &#123; &#125; &#125;; class C &#123; char ch1; //占用1字节 char ch2; //占用1字节 virtual void func() &#123; &#125; &#125;; class D &#123; int in; virtual void func() &#123; &#125; &#125;; class E&#123; char m; virtual void func() &#123; &#125;&#125;; 输出大小：12345678910A a; B b; C c; D d; E e; cout&lt;&lt;\"a对象大小： \"&lt;&lt; sizeof(a)&lt;&lt;endl; cout&lt;&lt;\"b对象大小： \"&lt;&lt; sizeof(b)&lt;&lt;endl; cout&lt;&lt;\"c对象大小： \" &lt;&lt;sizeof(c)&lt;&lt;endl; cout&lt;&lt;\"d对象大小： \"&lt;&lt; sizeof(d)&lt;&lt;endl; cout &lt;&lt;\"e对象大小： \" &lt;&lt;sizeof(e) &lt;&lt;endl; 结果如下： 类和结构体对象对齐和补齐原则？对齐：类(结构体)对象每个成员分配内存的起始地址为其所占空间的整数倍。补齐：类(结构体)对象所占用的总大小为其内部最大成员所占空间的整数倍。 空类定义的对象a 大小为1因为每个对象是独一无二的，编译器为了标识不同对象，要分配一字节的大小作为标识码。对象b 大小为1是因为成员函数在内存中只存储一份，不会存储在对象中。对象c大小为8， 是因为前四个字节存储虚函数表的指针，第5个字节存储成员变量ch1，第6个字节存储成员变量ch2，这样c的大小为6，根据补齐原则，需要补充2字节，使对象大小为8，8是最大字节4的整数倍。对象d大小为8，不需要补齐和对齐。对象e大小为8，前四个字节存储虚函数表指针，第5个字节存储成员m，需要补齐三个字节，总共八个字节，为4字节的倍数。看看下边这几个类123456789101112131415class F&#123; static int num; &#125;; class G&#123; virtual void print()&#123;&#125; virtual void print1()&#123;&#125; &#125;; class H&#123; void print()&#123;&#125; static void print1()&#123;&#125; &#125;; 打印并输出大小:123456F f;cout&lt;&lt;\"f 对象大小： \"&lt;&lt; sizeof(f)&lt;&lt;endl;G g;cout&lt;&lt;\"g 对象大小： \"&lt;&lt; sizeof(g)&lt;&lt;endl;H h;cout&lt;&lt;\"h 对象大小： \"&lt;&lt; sizeof(h)&lt;&lt;endl; 结果：静态成员变量，虚函数和static成员函数都不会占用对象的空间，f大小为1,是因为要开辟一个字节保存对象标识信息。g大小为4是开辟四字节给虚函数表指针。h大小为1字节也是开辟一个字节保存对象标识信息 什么要采取对齐和补齐分配策略？这个要从计算机CPU存取指令说起，每个字节单元为8bit，从地址0到地址3总共四个字节，为32bit。 class A{ char m; char b; }; A a; 对于a 将a.m分配在地址0开始的一个字节中，将a.b分配在地址1开始的额一个字节中。这样a的大小为2，cpu取数据可以执行一条指令就完成了。class B{ int m; char n; }; B b; 对于b将b.m分配在地址为0开始的四个字节(0~3)，对于b.n分配在开始地址为4的一字节空间。如果再定一个B b2;，不采取补齐策略，b2.m将被分起始地址为5的 4字节空间(5~8)，b2.n就被分在了起始地址为9的一字节空间。cpu取数据需要分3次，先取出0~3地址空间的数据(b.m)，再取出地址4~7数据(b.n和b2.m的前三个字节) 最后取出地址为8~11的数据(b2.m的最后一个字节以及b2.n)。取出数据后还要拆分和组合，极大地降低了效率。所以需要采取补齐策略。补齐策略数据分配如下： 地址0~3存储b.m， 地址4~7存储b.n，由于b.n只占用1个字节，地址5~7不存储数据，用于补齐。 地址8~11存储b2.m，地址12~15存储b2.n，13~15同样不存储数据用于补齐。 这样cpu读取四次可以将数据读取出来，进行简单的组合不需要切割数据就可以完成快速处理。 class C{ char n; int m; } C c； c.n存储周期0开始的一个字节中，如果不采取对齐策略，那么c.m会存储在1~4字节中，这样cpu需要读去两次，并且需要进行切割(0~4地址中数据包含c.n和c.m的前三个字节)，以及组合地址4开始的一个字节(存储c.m的最后一个字节)。 如果采取对齐策略，那么地址0~3存储c.n，地址4~7存储c.m，cpu同样读取两次，但是仅需要组合就可以去除对象的所有数据。 这就是为什么存储数据需要采取对齐和补齐的策略。到此为止C++虚函数和类成员的存储知识复习完，谢谢关注我的公众号：","categories":[{"name":"技术开发","slug":"tech","permalink":"http://www.limerence2017.com/categories/tech/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.limerence2017.com/tags/C/"}]}]