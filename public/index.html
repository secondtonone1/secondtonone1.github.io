<!doctype html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="C++ python 大并发网络 逆向">
  <meta name="description" content="重剑无锋，大巧不工">
  <meta name="author" content="恋恋风辰">

  
  <title>恋恋风辰的个人博客</title>
  

  <link rel="alternate" href="/atom.xml" title="恋恋风辰的个人博客" type="application/atom+xml">
  <link rel="canonical" href="http://www.limerence2017.com/index.html">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="//at.alicdn.com/t/font_pb2xepysv85gsyvi.css">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item aside-menu-current"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="文章分类">文章分类</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="我和我的小伙伴">我和我的小伙伴</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="作者简介">作者简介</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-rss"></i><a href="/atom.xml" class="aside-menu-link" title="RSS">RSS</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value="" autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-houdongfangiconfont10"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          恋恋风辰
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">重剑无锋，大巧不工。</p>
      <ul class="aside-show-info">
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link" title="微信" target="_blank"><i class="aside-show-icon iconfont icon-iconfontweixin"></i></a>
          <div class="aside-show-outside aside-show-outside_1">
            <img class="aside-show-IMG aside-show-IMG_1" src="/img/weixin.png" alt="微信">
          </div>
        </li>
        <li class="aside-show-item"><a href="https://www.zhihu.com/people/wang-wu-chen-32/activities" class="aside-show-link" title="知乎" target="_blank"><i class="aside-show-icon iconfont icon-zhihu"></i></a></li>
        <li class="aside-show-item"><a href="https://github.com/secondtonone1" class="aside-show-link" title="github" target="_blank"><i class="aside-show-icon iconfont icon-github"></i></a></li>
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link" title="QQ" target="_blank"><i class="aside-show-icon iconfont icon-qq"></i></a>
          <div class="aside-show-outside">
            <img class="aside-show-IMG" src="/img/qq.png" alt="QQ">
          </div>
        </li>
      </ul>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="posts min-height">
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/libevent3/" class="post-title-link" title="libevent学习文档(三)working with event">libevent学习文档(三)working with event</a></h3>
    <div class="post-excerpt"><p><code>Events</code> have similar lifecycles. Once you call a Libevent function to set up an event and associate it with an <code>event base</code>, it becomes initialized. At this point, you can add, which makes it pending in the base. When the event is pending, if the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomesactive, and its (user-provided) callback function is run. If the event is configured persistent, it remains pending. If it is not persistent, it stops being pending when its callback runs. You can make a pending event non-pending by deleting it, and you can add a non-pending event to make it pending again.</p>
<p>事件有相似的生命周期，一旦你调用libevent函数设置event和event_base关联后，event被初始化了。add这个事件会使它阻塞，当事件阻塞时，有触发事件的条件出现，事件会激活，回调函数会被调用。<code>如果事件被设置为永久，它保持阻塞</code>。<code>如果不是永久，当事件的回调函数调用的时候就不阻塞了</code>。可以通过删除一个事件使它由阻塞变为非阻塞。通过添加使它由非阻塞变为阻塞。<br></p></div>
    <a href="/2017/08/04/libevent3/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <a href="/tags/Linux环境编程/"" title="Linux环境编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>Linux环境编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/libevent4/" class="post-title-link" title="Libevent学习笔记(四) bufferevent 的 concepts and basics">Libevent学习笔记(四) bufferevent 的 concepts and basics</a></h3>
    <div class="post-excerpt"><p><code>Bufferevents and evbuffers</code></p>
<p>Every bufferevent has an input buffer and an output buffer. These are of type “struct evbuffer”. When you have data to write on a bufferevent, you add it to the output buffer; when a bufferevent has data for you to read, you drain it from the input buffer.</p>
<p>每个<code>bufferevents</code>都会包含一个input的buffer和output的buffer,都是<code>struct evbuffer</code>类型， 如果你有数据想通过bufferevent发送，需要将数据放入output buffer里。如果要从bufferevent中读数据，</p>
<p>需要从input buffer里读取。</p>
<p><code>Callbacks and watermarks</code></p>
<p>Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write “watermarks” of the bufferevent.</p>
<p>每一个bufferevent都有两个回调函数，一个<code>读回调</code>和一个<code>写回调</code>函数，默认情况下，只要从底层传输读取数据就回触发读回调函数，当output buffer中足够多的数据排出就会触发写回调函数。而我的理解是，这里的足够多，默认情况下是排空，</p>
<p>用户可以通过调整读写水位来达到控制这些函数触发。<br></p></div>
    <a href="/2017/08/04/libevent4/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <a href="/tags/Linux环境编程/"" title="Linux环境编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>Linux环境编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/Libevent5/" class="post-title-link" title="Libevent学习笔记(五) 根据例子学习bufferevent">Libevent学习笔记(五) 根据例子学习bufferevent</a></h3>
    <div class="post-excerpt"><p>libevent中提供了一个Hello-world.c 的例子，从这个例子可以学习libevent是如何使用bufferevent的。<br>这个例子在Sample中<br><img src="/2017/08/04/Libevent5/1.png" alt="1"><br>这个例子之前讲解过，这次主要看下bufferevent的使用。<br></p></div>
    <a href="/2017/08/04/Libevent5/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <a href="/tags/Linux环境编程/"" title="Linux环境编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>Linux环境编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/neterror/" class="post-title-link" title="网络编程的一些错误总结">网络编程的一些错误总结</a></h3>
    <div class="post-excerpt"><p>最近自己在写一套服务器框架，期间遇到很多问题，对于Linux或者windows出错情况下可以通过错误码获取错误信息。为了测试服务器性能，我在客户端开了2000个线程，这样每个线程都创建socket和服务器通信，连接15个线程，再后来的客户端线程connect过程中会失败，我另起了一个客户端进程进行连接，还是能连接15个过后才出现问题，初步可以排除服务器并没有达到连接上限，之后在linux上打印该错误码为111，查询意思为服务器拒绝客户端连接。查询相关资料是监听队列设置为5，只能接受一部分剩余的由于监听队列满了就被拒绝了。之后查询libevent和redis库的一些监听队列大小，设置为128较为合适，这次同样会出现一部分客户端连接失败，因为监听队列总是有限的，尽管如此，极限的情况下一秒同时连接500多个客户端还是没问题。<br></p></div>
    <a href="/2017/08/04/neterror/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/newproblem/" class="post-title-link" title="网络编程一些常见问题总结">网络编程一些常见问题总结</a></h3>
    <div class="post-excerpt"><h2 id="1-设置网络socket非阻塞："><a href="#1-设置网络socket非阻塞：" class="headerlink" title="1 设置网络socket非阻塞："></a>1 设置网络socket非阻塞：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u_long has = <span class="number">1</span>;</div><div class="line">ioctl(m_sock, FIONBIO , &amp;has);</div></pre></td></tr></table></figure>
<p>这个函数很有可能返回success，却并没有设置成功。<br>windows对此有优化，对于linux版本应采用fcntl设置。</p>
<p>总结如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span></div><div class="line">make_socket_nonblocking(sockfd fd)</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">    &#123;</div><div class="line">        u_long nonblocking = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (ioctlsocket(fd, FIONBIO, &amp;nonblocking) == SOCKET_ERROR) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fcntl failed, fd is : "</span> &lt;&lt; fd; </div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> flags;</div><div class="line">        <span class="keyword">if</span> ((flags = fcntl(fd, F_GETFL, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fcntl failed, fd is : "</span> &lt;&lt; fd;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"fcntl failed, fd is : "</span> &lt;&lt; fd;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></div>
    <a href="/2017/08/04/newproblem/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/econreset/" class="post-title-link" title="ECONNRESET和WSAECONNRESET怎么产生的以及如何避免">ECONNRESET和WSAECONNRESET怎么产生的以及如何避免</a></h3>
    <div class="post-excerpt"><p><code>ECONNRESET</code>是linux环境网络编程产生的错误，错误码为104，</p>
<p><code>WSAECONNRESET</code>是windows环境网络编程产生的错误，错误码为10054</p>
<p>两者产生的原因都一样，分以下几种情况：</p>
<p>1<code>接收端recv或者read， 对端已经关闭连接，recv/read返回该错误</code></p>
<p>2 对端重启连接，还未建立连接</p>
<p>3 <code>发送端已经断开连接，但是调用send会触发这个错误</code></p>
<p>第二点第三点都可以通过判断返回值解决，第一点在一些看似正常情况下也会触发该错误。比如对端close(fd)，接收端调用recv并没有返回0，而是-1，打印错误码为104或</p>
<p>10054，按道理讲这种情况按照返回值为0处理是可以的，但是尽量将代码写的规范一些，避免不必要的错误。<br></p></div>
    <a href="/2017/08/04/econreset/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/udphole/" class="post-title-link" title="Udp打洞原理和源代码。">Udp打洞原理和源代码。</a></h3>
    <div class="post-excerpt"><p>所谓<code>udp打洞</code>就是指客户端A通过<code>udp协议</code>向服务器发送数据包，服务器收到后，获取数据包，并且可获取客户端A<code>地址和端口号</code>。同样在客户端B发送给服务器udp数据包后，服务器同样在收到B发送过来的数据包后获取B的地址和端口号，将A和B的地址与端口号分别发送给对方，这样双方可以继续用UDP协议通信。这么做有什么用呢？因为对于一些应用或者需求，需要两个客户端临时做一些通信，而这种通信不需要建立tcp就可以完成，所以才去udp打洞。</p>
<p>下面附上测试代码：</p>
<p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// udphole.cpp : 定义控制台应用程序的入口点。</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></div><div class="line"><span class="keyword">typedef</span> SOCKET socketfd;</div><div class="line"><span class="keyword">typedef</span> SOCKADDR_IN sockaddr_in;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line"></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> socketfd;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div></pre></td></tr></table></figure></div>
    <a href="/2017/08/04/udphole/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/networkbook/" class="post-title-link" title="网络编程学习方法和图书推荐">网络编程学习方法和图书推荐</a></h3>
    <div class="post-excerpt"><p><img src="/2017/08/04/networkbook/5.jpg" alt="5"><br>从事<code>网络编程</code>有五年多了，写过自己的Server，读过大部分网络库<code>libevent</code>，<code>redis</code>,<code>muduo</code>等等，市面上的网络用书大多读过，给新人一些建议，主要是从事服务器网络编程后端的同学。如果你没写过网络编程的代码，也没有这方面的知识，那么该如何下手呢？这个时候不需要盲目看书，先培养一下自己的兴趣，了解TCP如何建立连接，<code>TCP三次握手</code>和<code>四次握手</code>的过程，</p></div>
    <a href="/2017/08/04/networkbook/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/redisset/" class="post-title-link" title="redis 配置和使用(C++)">redis 配置和使用(C++)</a></h3>
    <div class="post-excerpt"><h2 id="一、Redis简介："><a href="#一、Redis简介：" class="headerlink" title="一、Redis简介："></a>一、Redis简介：</h2><p><code>Redis</code>为<code>非关系型数据库</code>，Redis是一个<code>Key-Value</code>存储系统。它支持存储的value类型有：<code>string(字符串)</code>,<code>list(链表)</code>, <code>set(无序集合)</code>,<code>zset(sorted set有序集合)</code>和<code>hash</code>，Redis支持各种不同方式的排序。数据都是<code>缓存</code>在<code>内存</code>中的，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并实现了<code>master-slave(主从)同步</code>。</p>
<h2 id="二、Redis安装和使用："><a href="#二、Redis安装和使用：" class="headerlink" title="二、Redis安装和使用："></a>二、Redis安装和使用：</h2><p>Redis下载地址，我下载的为最新版本：</p>
<p>wget <a href="wget http://download.redis.io/releases/redis-3.2.8.tar.gz">http://download.redis.io/releases/redis-3.2.8.tar.gz</a>  </p>
<p>解压安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar xzf redis-3.2.8.tar.gz</div><div class="line">$ <span class="built_in">cd</span> redis-3.2.8</div><div class="line">$ make</div></pre></td></tr></table></figure>
<p>make完后 redis-3.2.8目录下会出现redis-server和redis-cli<br>下面在src目录下启动redis服务.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./redis-server</div></pre></td></tr></table></figure></p></div>
    <a href="/2017/08/04/redisset/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/C/"" title="C++" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>C++</a>
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <a href="/tags/Linux环境编程/"" title="Linux环境编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>Linux环境编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
  <section class="post">
    <h3 class="post-title"><a href="/2017/08/04/ioservertype/" class="post-title-link" title="大并发服务器框架设计">大并发服务器框架设计</a></h3>
    <div class="post-excerpt"><p>简单谈一谈<code>大并发服务器框架</code>设计的基本思路<br>基本的服务器框架都是<code>C/S结构</code>的，请求和相应流程是这样的：<br><img src="/2017/08/04/ioservertype/1.png" alt="1"><br>这样的框架存在一个很严重的问题，当客户端大并发请求到来，服务器需要进行大量的数据库操作，假设数据库最大连接数为1000个，此时有10000个请求访问应用服务器，那么应用服务器只能处理1000个请求，剩下99000个等待1000个请求处理好后再进行访问数据库处理。可以在应用服务器和数据库服务器中间增加中间层DAL，DAL采用缓冲队列和连接池设计。<br></p></div>
    <a href="/2017/08/04/ioservertype/" class="post-more" title="阅读全文">阅读全文 »</a>
    <p class="post-meta">
      
      <a href="/categories/tech/" title="技术开发" class="post-categories">技术开发</a>
      
      
      <a href="/tags/网络编程/"" title="网络编程" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>网络编程</a>
      
      <span class="post-time">2017-08-04</span>
    </p>
  </section>
  
</article>


<nav class="paging">
  <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 »</a>
</nav>



      <footer class="footer">
  <p class="footer-text">驱动于 <a href="https://hexo.io/zh-cn/" class="footer-link" title="Hexo">Hexo</a>，主题由 <a href="/about" class="footer-link" title="恋恋风辰">恋恋风辰</a> 设计移植而来</p>
  <p class="footer-text">&copy; 2016 - 2017 <a href="/about" class="footer-link" title="恋恋风辰">恋恋风辰</a> 保留部分版权</p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
